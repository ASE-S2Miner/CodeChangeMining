[{"original_method":"/**\n\t * @param sessionId\n\t * @param key \n\t * @param bytes \n\t */\n\tprivate void savePage(SessionPageKey key, byte[] bytes)\n\t{\n\t\tFile sessionDir = new File(getWorkDir(), key.sessionId);\n\t\tsessionDir.mkdirs();\n\t\tFile pageFile = getPageFile(key.id, key.versionNumber,key.ajaxVersionNumber, sessionDir);\n\n\t\tFileOutputStream fos = null;\n\t\tlong t1 = System.currentTimeMillis();\n\t\tint length = 0;\n\t\ttry\n\t\t{\n\t\t\tfos = new FileOutputStream(pageFile);\n\t\t\tByteBuffer bb = ByteBuffer.wrap(bytes);\n\t\t\tfos.getChannel().write(bb);\n\t\t\tlength = bytes.length;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Error saving page \" + key.pageClass +\" [\" + key.id + \",\"\n\t\t\t\t\t+ key.versionNumber + \"] for the sessionid \" + key.sessionId);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (fos != null)\n\t\t\t\t{\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex)\n\t\t\t{\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tlong t3 = System.currentTimeMillis();\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"storing page \" + key.pageClass + \"[\" + key.id + \",\"\n\t\t\t\t\t+ key.versionNumber + \"] size: \" + length + \" for session \"\n\t\t\t\t\t+ key.sessionId + \" took \" + (t3 - t1) + \" miliseconds to save\");\n\t\t}\n\t\ttotalSavingTime += (t3-t1);\n\t}","id":79000,"modified_method":"/**\n\t * @param sessionId\n\t * @param key \n\t * @param bytes \n\t */\n\tprivate void savePage(SessionPageKey key, byte[] bytes)\n\t{\n\t\tFile sessionDir = new File(getWorkDir(), key.sessionId);\n\t\tsessionDir.mkdirs();\n\t\tFile pageFile = getPageFile(key, sessionDir);\n\n\t\tFileOutputStream fos = null;\n\t\tlong t1 = System.currentTimeMillis();\n\t\tint length = 0;\n\t\ttry\n\t\t{\n\t\t\tfos = new FileOutputStream(pageFile);\n\t\t\tByteBuffer bb = ByteBuffer.wrap(bytes);\n\t\t\tfos.getChannel().write(bb);\n\t\t\tlength = bytes.length;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Error saving page \" + key.pageClass +\" [\" + key.id + \",\"\n\t\t\t\t\t+ key.versionNumber + \"] for the sessionid \" + key.sessionId);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (fos != null)\n\t\t\t\t{\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex)\n\t\t\t{\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tlong t3 = System.currentTimeMillis();\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"storing page \" + key.pageClass + \"[\" + key.id + \",\"\n\t\t\t\t\t+ key.versionNumber + \"] size: \" + length + \" for session \"\n\t\t\t\t\t+ key.sessionId + \" took \" + (t3 - t1) + \" miliseconds to save\");\n\t\t}\n\t\ttotalSavingTime += (t3-t1);\n\t\tsaved++;\n\t\tbytesSaved += length;\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"SessionPageKey(String sessionId, Page page, boolean remove)\n\t\t{\n\t\t\tthis(sessionId, page.getNumericId(), page.getCurrentVersionNumber(), \n\t\t\t\t\tpage.getAjaxVersionNumber(), remove, page.getClass());\n\t\t}","id":79001,"modified_method":"SessionPageKey(String sessionId, Page page)\n\t\t{\n\t\t\tthis(sessionId, page.getNumericId(), page.getCurrentVersionNumber(), \n\t\t\t\t\tpage.getAjaxVersionNumber(), page.getPageMap().getName(), page.getClass(),page);\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#pageAccessed(java.lang.String,\n\t *      wicket.Page)\n\t */\n\tpublic void pageAccessed(String sessionId, Page page)\n\t{\n\t\ttestMap(sessionId, page.getNumericId(), page.getCurrentVersionNumber(), page.getAjaxVersionNumber());\n\t}","id":79002,"modified_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#pageAccessed(java.lang.String,\n\t *      wicket.Page)\n\t */\n\tpublic void pageAccessed(String sessionId, Page page)\n\t{\n\t\tSessionPageKey currentKey = new SessionPageKey(sessionId, page);\n\t\ttestMap(currentKey);\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"SessionPageKey(String sessionId, int id, int versionNumber, int ajaxVersionNumber, boolean remove, Class pageClass)\n\t\t{\n\t\t\tthis.sessionId = sessionId;\n\t\t\tthis.id = id;\n\t\t\tthis.versionNumber = versionNumber;\n\t\t\tthis.ajaxVersionNumber = ajaxVersionNumber;\n\t\t\tthis.remove = remove;\n\t\t\tthis.pageClass = pageClass;\n\t\t}","id":79003,"modified_method":"SessionPageKey(String sessionId, int id, int versionNumber, int ajaxVersionNumber, String pagemap, Class pageClass, Page page)\n\t\t{\n\t\t\tthis.sessionId = sessionId;\n\t\t\tthis.id = id;\n\t\t\tthis.versionNumber = versionNumber;\n\t\t\tthis.ajaxVersionNumber = ajaxVersionNumber;\n\t\t\tthis.pageClass = pageClass;\n\t\t\tthis.pageMap = pagemap;\n\t\t\tthis.data = page;\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Stops this thread.\n\t\t */\n\t\tpublic void stop()\n\t\t{\n\t\t\tSystem.err.println(\"Total time in saving: \" + totalSavingTime);\n\t\t\tSystem.err.println(\"Total time in serialization: \" + totalSerializationTime);\n\t\t\tsynchronized (storePageMap)\n\t\t\t{\n\t\t\t\tstop = true;\n\t\t\t\tstorePageMap.notifyAll();\n\t\t\t}\n\t\t}","id":79004,"modified_method":"/**\n\t\t * Stops this thread.\n\t\t */\n\t\tpublic void stop()\n\t\t{\n\t\t\tSystem.err.println(\"Total time in saving: \" + totalSavingTime);\n\t\t\tSystem.err.println(\"Total time in serialization: \" + totalSerializationTime);\n\t\t\tSystem.err.println(\"Bytes saved: \" + bytesSaved);\n\t\t\tSystem.err.println(\"Pages saved: \" + saved);\n\t\t\tsynchronized (storePageMap)\n\t\t\t{\n\t\t\t\tstop = true;\n\t\t\t\tstorePageMap.notifyAll();\n\t\t\t}\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param pageStore\n\t */\n\tpublic SecondLevelCacheSessionStore(final IPageStore pageStore)\n\t{\n\t\tthis.cachingStore = new IPageStore()\n\t\t{\n\t\t\tprivate Map sessionMap = new ConcurrentHashMap();\n\n\t\t\tpublic Page getPage(String sessionId, int id, int versionNumber, int ajaxVersionNumber)\n\t\t\t{\n\t\t\t\tSoftReference sr = (SoftReference)sessionMap.get(sessionId);\n\t\t\t\tif (sr != null)\n\t\t\t\t{\n\t\t\t\t\tMap map = (Map)sr.get();\n\t\t\t\t\tif (map != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tSoftReference sr2 = (SoftReference)map.get(Integer.toString(id));\n\t\t\t\t\t\tif (sr2 != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPage page = (Page)sr2.get();\n\t\t\t\t\t\t\tif (page != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpage = page.getVersion(versionNumber);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (page != null && page.getAjaxVersionNumber() == ajaxVersionNumber)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn page;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn pageStore.getPage(sessionId, id, versionNumber, ajaxVersionNumber);\n\t\t\t}\n\n\t\t\tpublic void removePage(String sessionId, Page page)\n\t\t\t{\n\t\t\t\tSoftReference sr = (SoftReference)sessionMap.get(sessionId);\n\t\t\t\tif (sr != null)\n\t\t\t\t{\n\t\t\t\t\tMap map = (Map)sr.get();\n\t\t\t\t\tif (map != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap.remove(page.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpageStore.removePage(sessionId, page);\n\t\t\t}\n\n\t\t\tpublic void storePage(String sessionId, Page page)\n\t\t\t{\n\t\t\t\tMap pageMap = null;\n\t\t\t\tSoftReference sr = (SoftReference)sessionMap.get(sessionId);\n\t\t\t\tif (sr == null || (pageMap = (Map)sr.get()) == null)\n\t\t\t\t{\n\t\t\t\t\tpageMap = new ConcurrentHashMap();\n\t\t\t\t\tsessionMap.put(sessionId, new SoftReference(pageMap));\n\t\t\t\t}\n\t\t\t\tpageMap.put(page.getId(), new SoftReference(page));\n\t\t\t\tpageStore.storePage(sessionId, page);\n\t\t\t}\n\n\t\t\tpublic void unbind(String sessionId)\n\t\t\t{\n\t\t\t\tsessionMap.remove(sessionId);\n\t\t\t\tpageStore.unbind(sessionId);\n\t\t\t}\n\n\t\t\tpublic void pageAccessed(String sessionId, Page page)\n\t\t\t{\n\t\t\t\tpageStore.pageAccessed(sessionId, page);\n\t\t\t}\n\n\t\t\tpublic void destroy()\n\t\t\t{\n\t\t\t\tpageStore.destroy();\n\t\t\t}\n\t\t};\n\t}","id":79005,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param pageStore\n\t */\n\tpublic SecondLevelCacheSessionStore(final IPageStore pageStore)\n\t{\n\t\tthis.cachingStore = new IPageStore()\n\t\t{\n\t\t\tprivate Map sessionMap = new ConcurrentHashMap();\n\n\t\t\tpublic Page getPage(String sessionId, String pagemapName, int id, int versionNumber, int ajaxVersionNumber)\n\t\t\t{\n\t\t\t\tSoftReference sr = (SoftReference)sessionMap.get(sessionId);\n\t\t\t\tif (sr != null)\n\t\t\t\t{\n\t\t\t\t\tMap map = (Map)sr.get();\n\t\t\t\t\tif (map != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tSoftReference sr2 = (SoftReference)map.get(Integer.toString(id));\n\t\t\t\t\t\tif (sr2 != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPage page = (Page)sr2.get();\n\t\t\t\t\t\t\tif (page != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpage = page.getVersion(versionNumber);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (page != null && page.getAjaxVersionNumber() == ajaxVersionNumber)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn page;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn pageStore.getPage(sessionId, pagemapName, id, versionNumber, ajaxVersionNumber);\n\t\t\t}\n\n\t\t\tpublic void removePage(String sessionId, Page page)\n\t\t\t{\n\t\t\t\tSoftReference sr = (SoftReference)sessionMap.get(sessionId);\n\t\t\t\tif (sr != null)\n\t\t\t\t{\n\t\t\t\t\tMap map = (Map)sr.get();\n\t\t\t\t\tif (map != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap.remove(page.getId());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpageStore.removePage(sessionId, page);\n\t\t\t}\n\n\t\t\tpublic void storePage(String sessionId, Page page)\n\t\t\t{\n\t\t\t\tMap pageMap = null;\n\t\t\t\tSoftReference sr = (SoftReference)sessionMap.get(sessionId);\n\t\t\t\tif (sr == null || (pageMap = (Map)sr.get()) == null)\n\t\t\t\t{\n\t\t\t\t\tpageMap = new ConcurrentHashMap();\n\t\t\t\t\tsessionMap.put(sessionId, new SoftReference(pageMap));\n\t\t\t\t}\n\t\t\t\tpageMap.put(page.getId(), new SoftReference(page));\n\t\t\t\tpageStore.storePage(sessionId, page);\n\t\t\t}\n\n\t\t\tpublic void unbind(String sessionId)\n\t\t\t{\n\t\t\t\tsessionMap.remove(sessionId);\n\t\t\t\tpageStore.unbind(sessionId);\n\t\t\t}\n\n\t\t\tpublic void pageAccessed(String sessionId, Page page)\n\t\t\t{\n\t\t\t\tpageStore.pageAccessed(sessionId, page);\n\t\t\t}\n\n\t\t\tpublic void destroy()\n\t\t\t{\n\t\t\t\tpageStore.destroy();\n\t\t\t}\n\t\t};\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see wicket.version.IPageVersionManager#rollbackPage(int)\n\t\t */\n\t\tpublic Page rollbackPage(int numberOfVersions)\n\t\t{\n\t\t\tString sessionId = page.getSession().getId();\n\t\t\tif (sessionId != null) \n\t\t\t{\n\t\t\t\tint versionNumber = currentVersionNumber;\n\t\t\t\tint ajaxNumber = currentAjaxVersionNumber;\n\t\t\t\tif (versionStarted)\n\t\t\t\t{\n\t\t\t\t\tversionNumber--;\n\t\t\t\t\tajaxNumber--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tIPageStore store = ((SecondLevelCacheSessionStore)Application.get().getSessionStore()).getStore();\n\t\t\t\t// if the number of versions to rollback can be done inside the current page version.\n\t\t\t\tif ( ajaxNumber >= numberOfVersions)\n\t\t\t\t{\n\t\t\t\t\treturn store.getPage(sessionId, page.getNumericId(), versionNumber, ajaxNumber-numberOfVersions);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// else go one page version down.\n\t\t\t\t\tversionNumber--;\n\t\t\t\t\t// then calculate the previous ajax version by looking at the last ajax number of the previous version.\n\t\t\t\t\tajaxNumber = lastAjaxVersionNumber - (numberOfVersions-ajaxNumber);\n\t\t\t\t\tif (ajaxNumber < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// currently it is not supported to jump over 2 pages....\n\t\t\t\t\t\tlog.error(\"trying to rollback to many versions, jumping over 2 page versions is not supported yet.\");\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn store.getPage(sessionId, page.getNumericId(), versionNumber, ajaxNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}","id":79006,"modified_method":"/**\n\t\t * @see wicket.version.IPageVersionManager#rollbackPage(int)\n\t\t */\n\t\tpublic Page rollbackPage(int numberOfVersions)\n\t\t{\n\t\t\tString sessionId = page.getSession().getId();\n\t\t\tif (sessionId != null) \n\t\t\t{\n\t\t\t\tint versionNumber = currentVersionNumber;\n\t\t\t\tint ajaxNumber = currentAjaxVersionNumber;\n\t\t\t\tif (versionStarted)\n\t\t\t\t{\n\t\t\t\t\tversionNumber--;\n\t\t\t\t\tajaxNumber--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tIPageStore store = ((SecondLevelCacheSessionStore)Application.get().getSessionStore()).getStore();\n\t\t\t\t// if the number of versions to rollback can be done inside the current page version.\n\t\t\t\tif ( ajaxNumber >= numberOfVersions)\n\t\t\t\t{\n\t\t\t\t\treturn store.getPage(sessionId, page.getPageMap().getName(), page.getNumericId(), versionNumber, ajaxNumber-numberOfVersions);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// else go one page version down.\n\t\t\t\t\tversionNumber--;\n\t\t\t\t\t// then calculate the previous ajax version by looking at the last ajax number of the previous version.\n\t\t\t\t\tajaxNumber = lastAjaxVersionNumber - (numberOfVersions-ajaxNumber);\n\t\t\t\t\tif (ajaxNumber < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// currently it is not supported to jump over 2 pages....\n\t\t\t\t\t\tlog.error(\"trying to rollback to many versions, jumping over 2 page versions is not supported yet.\");\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn store.getPage(sessionId, page.getPageMap().getName(), page.getNumericId(), versionNumber, ajaxNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * Restores a page version from the persistent layer\n\t\t * \n\t\t * @param sessionId\n\t\t * @param id\n\t\t * @param versionNumber\n\t\t * @param ajaxVersionNumber \n\t\t * @return The page\n\t\t */\n\t\tPage getPage(String sessionId, int id, int versionNumber, int ajaxVersionNumber);","id":79007,"modified_method":"/**\n\t\t * Restores a page version from the persistent layer\n\t\t * \n\t\t * @param sessionId\n\t\t * @param pagemap \n\t\t * @param id\n\t\t * @param versionNumber\n\t\t * @param ajaxVersionNumber \n\t\t * @return The page\n\t\t */\n\t\tPage getPage(String sessionId, String pagemap, int id, int versionNumber, int ajaxVersionNumber);","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"public Page get(int id, int versionNumber)\n\t\t{\n\t\t\tString sessionId = getSession().getId();\n\t\t\tif (lastPage != null && lastPage.getNumericId() == id)\n\t\t\t{\n\t\t\t\tPage page = lastPage.getVersion(versionNumber);\n\t\t\t\tif (page != null)\n\t\t\t\t{\n\t\t\t\t\t// ask the page store if it is ready saving the page.\n\t\t\t\t\tgetStore().pageAccessed(sessionId, page);\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sessionId != null)\n\t\t\t{\n\t\t\t\t// this is really a page request for a default page. (so without an ajax version)\n\t\t\t\treturn getStore().getPage(sessionId, id, versionNumber,0);\n\t\t\t}\n\t\t\treturn null;\n\t\t}","id":79008,"modified_method":"public Page get(int id, int versionNumber)\n\t\t{\n\t\t\tString sessionId = getSession().getId();\n\t\t\tif (lastPage != null && lastPage.getNumericId() == id)\n\t\t\t{\n\t\t\t\tPage page = lastPage.getVersion(versionNumber);\n\t\t\t\tif (page != null)\n\t\t\t\t{\n\t\t\t\t\t// ask the page store if it is ready saving the page.\n\t\t\t\t\tgetStore().pageAccessed(sessionId, page);\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sessionId != null)\n\t\t\t{\n\t\t\t\t// this is really a page request for a default page. (so without an ajax version)\n\t\t\t\treturn getStore().getPage(sessionId,getName(), id, versionNumber,0);\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n  public synchronized long getWriteTxid() {\n    initialize();\n    long txid = this.timeOracle.getTimestamp();\n    this.inProgress.put(txid, new LinkedList<Undo>());\n    return txid;\n  }","id":79009,"modified_method":"@Override\n  public synchronized long getWriteTxid() {\n    long txid = this.timeOracle.getTimestamp();\n    this.inProgress.put(txid, new InProgress());\n    this.excludes.add(txid);\n    return txid;\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized TransactionResult commit(long txid) throws OmidTransactionException {\n    initialize();\n    // test whether in progress\n    List<Undo> undos = this.inProgress.get(txid);\n    if (null == undos) {\n      throw new OmidTransactionException(StatusCode.ILLEGAL_COMMIT,\n                                         \"Transaction not in progress\");\n    }\n    // determine row set of transaction from undos\n    RowSet rows = computeRowSet(undos);\n    // see if there are any conflicting rows between txid and now - if the tx has written any rows\n    if (rows != null) {\n      long now = this.timeOracle.getTimestamp();\n      NavigableMap<Long,RowSet> rowsToCheck =\n        this.rowSets.subMap(txid, false, now, false);\n      for (Map.Entry<Long,RowSet> entry : rowsToCheck.entrySet()) {\n        if (entry.getValue().conflictsWith(rows)) {\n          // TODO do we have to do more here?\n          return new TransactionResult(undos);\n        }\n      }\n      // No conflicts found, add to row sets\n      this.rowSets.put(now, rows);\n    }\n    // remove this transaction from in-progress\n    moveReadPointer(txid);\n\n    // Find all row sets that were committed earlier than the start of\n    // earliest transaction that's in progress and delete them from the\n    // rowset.\n    long minTxId = this.inProgress.isEmpty() ? Long.MAX_VALUE : this.inProgress.firstKey();\n    SortedMap<Long, RowSet> toRemove = this.rowSets.headMap(minTxId);\n    toRemove.clear(); // removes from the underlying map, this.rowSets\n\n    // success\n    return new TransactionResult();\n  }","id":79010,"modified_method":"@Override\n  public synchronized TransactionResult commit(long txid) throws OmidTransactionException {\n    List<Undo> undos = getInProgress(txid).getUndos();\n    // determine row set of transaction from undos\n    RowSet rows = computeRowSet(undos);\n    // if the tx has written any rows, we check for conflicts and remember its row set\n    if (rows != null) {\n      // a conflict exists iff a transaction that committed after the start of this\n      // transaction has written any row that this transaction also wrote. We remember\n      // the row set of each transaction with its end time. Thus, we need to check all\n      // row sets that have an end time between the start of this transaction (the txid)\n      // and the current oracle time.\n      long now = this.timeOracle.getTimestamp();\n      NavigableMap<Long,RowSet> rowsToCheck =\n        this.rowSets.subMap(txid, false, now, false);\n      for (Map.Entry<Long,RowSet> entry : rowsToCheck.entrySet()) {\n        if (entry.getValue().conflictsWith(rows)) {\n          // we have a conflict -> transaction failed\n          return abort(txid);\n        }\n      }\n      // No conflicts found, add to row sets\n      this.rowSets.put(now, rows);\n    }\n    // remove this transaction from in-progress and from excludes\n    this.inProgress.remove(txid);\n    this.excludes.remove(txid);\n    // and move the read point (only done after a successful commit).\n    moveReadPoint(txid);\n\n    // Find all row sets that were committed earlier than the start of\n    // earliest transaction that's in progress and delete them from the\n    // row set.\n    long minTxId = this.inProgress.isEmpty() ? Long.MAX_VALUE : this.inProgress.firstKey();\n    SortedMap<Long, RowSet> toRemove = this.rowSets.headMap(minTxId);\n    toRemove.clear(); // removes from the underlying map, this.rowSets\n\n    // success\n    return new TransactionResult();\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized ReadPointer getReadPointer(long writeTxid) {\n    initialize();\n    return new MemoryReadPointer(this.readPoint, writeTxid, this.inProgress.keySet());\n  }","id":79011,"modified_method":"@Override\n  public synchronized ReadPointer getReadPointer(long writeTxid) {\n    return new MemoryReadPointer(this.readPoint, writeTxid, this.getExcludes());\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized TransactionResult abort(long txid) throws OmidTransactionException {\n    initialize();\n    // test whether in progress\n    List<Undo> undos = this.inProgress.get(txid);\n    if (null == undos) {\n      throw new OmidTransactionException(StatusCode.ILLEGAL_ABORT,\n                                         \"Transaction not in progress\");\n    }\n    return new TransactionResult(undos);\n  }","id":79012,"modified_method":"@Override\n  public synchronized TransactionResult abort(long txid) throws OmidTransactionException {\n    // this removes the txid from in-progress. It remains in the exclude\n    // list until removed after successful undo of its writes.\n    InProgress existing = this.inProgress.remove(txid);\n    if (null == existing) {\n      throw new OmidTransactionException(\n        StatusCode.INVALID_TRANSACTION, \"Transaction not in progress\");\n    }\n    return new TransactionResult(existing.getUndos());\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void remove(long txid) throws OmidTransactionException {\n    initialize();\n    // test whether in progress\n    List<Undo> undos = this.inProgress.get(txid);\n    if (null == undos) {\n      throw new OmidTransactionException(StatusCode.ILLEGAL_ABORT,\n                                         \"Transaction not in progress\");\n    }\n    moveReadPointer(txid);\n  }","id":79013,"modified_method":"@Override\n  public synchronized void remove(long txid) throws OmidTransactionException {\n    // this is called after all writes of a failed transaction have been\n    // undone successfully. It removes the txid from the invalid and excluded list.\n    if (!this.excludes.remove(txid)) {\n      throw new OmidTransactionException(\n        StatusCode.INVALID_TRANSACTION, \"Transaction not in current set\");\n    }\n    // we must move the read pointer. If the failed transaction performed an\n    // enqueue, then it was undone by overwriting the entry meta data with an\n    // invalid marker. That write must be visible to subsequent dequeue calls.\n    // TODO revisit this after new queue implementation is done\n    moveReadPoint(txid);\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void add(long txid, List<Undo> undos) throws OmidTransactionException {\n    initialize();\n    List<Undo> existing = this.inProgress.get(txid);\n    if (null == existing) {\n      throw new OmidTransactionException(StatusCode.ILLEGAL_ADDTX,\n                                         \"Transaction not in progress\");\n    }\n    existing.addAll(undos);\n  }","id":79014,"modified_method":"@Override\n  public synchronized void add(long txid, List<Undo> undos) throws OmidTransactionException {\n    getInProgress(txid).add(undos);\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized ReadPointer getReadPointer() {\n    initialize();\n    return new MemoryReadPointer(this.readPoint, this.inProgress.keySet());\n  }","id":79015,"modified_method":"@Override\n  public synchronized ReadPointer getReadPointer() {\n    return new MemoryReadPointer(this.readPoint, this.getExcludes());\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"private RowSet computeRowSet(List<Undo> undos) {\n    RowSet rows = null;\n    for (Undo undo : undos) {\n      byte[] rowkey = undo.getRowKey();\n      if (rowkey != null) {\n        if (rows == null) {\n          rows = new MemoryRowSet();\n        }\n        rows.addRow(rowkey);\n      }\n    }\n    return rows;\n  }","id":79016,"modified_method":"/**\n   * Utility to extract the row set of a transaction from its undos.\n   * @param undos the undo operations for this transaction\n   * @return a set of rows that were written by the transaction\n   */\n  private RowSet computeRowSet(List<Undo> undos) {\n    RowSet rows = null;\n    for (Undo undo : undos) {\n      byte[] rowKey = undo.getRowKey();\n      if (rowKey != null) {\n        if (rows == null) {\n          rows = new MemoryRowSet();\n        }\n        rows.addRow(rowKey);\n      }\n    }\n    return rows;\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized ImmutablePair<ReadPointer, Long> getNewPointer() {\n    initialize();\n    long writeTxid = getWriteTxid();\n    return new ImmutablePair<ReadPointer,Long>(\n        getReadPointer(writeTxid), writeTxid);\n  }","id":79017,"modified_method":"@Override\n  public synchronized ImmutablePair<ReadPointer, Long> getNewPointer() {\n    long writeTxid = getWriteTxid();\n    return new ImmutablePair<ReadPointer,Long>(\n        getReadPointer(writeTxid), writeTxid);\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"private void moveReadPointer(long txid) {\n    this.inProgress.remove(txid);\n    this.readPoint = this.timeOracle.getTimestamp();\n  }","id":79018,"modified_method":"/**\n   * Move the read point after a transaction was committed. This is maintained as\n   * greatest transaction id of all committed transactions. This it only needs to\n   * be moved after a successful commit, not after an abort or failed commit.\n   * @param committedTxid the id of the committed transaction\n   */\n  private void moveReadPoint(long committedTxid) {\n    if (committedTxid > this.readPoint) {\n      this.readPoint = committedTxid;\n    }\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWriteBatchJustAck() throws Exception {\n    OmidTransactionalOperationExecutor.DISABLE_QUEUE_PAYLOADS = true;\n    \n    byte [] queueName = Bytes.toBytes(\"testWriteBatchJustAck\");\n\n    TTQueueOnVCTable.TRACE = true;\n    MemoryOracle.TRACE = true;\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\n    QueueConfig config = new QueueConfig(\n        PartitionerType.RANDOM, true);\n\n    // Queue should be empty\n    QueueDequeue dequeue = new QueueDequeue(queueName, consumer, config);\n    DequeueResult result = this.executor.execute(context, dequeue);\n    assertTrue(result.isEmpty());\n\n    // Write to the queue\n    this.executor.execute(context, batch(new QueueEnqueue(queueName,\n        Bytes.toBytes(1L))));\n\n    // DequeuePayload entry just written\n    dequeue = new QueueDequeue(queueName, consumer, config);\n    result = this.executor.execute(context, dequeue);\n    assertDequeueResultSuccess(result, Bytes.toBytes(1L));\n\n    TTQueueOnVCTable.TRACE = false;\n    MemoryOracle.TRACE = false;\n\n    // Ack it\n    this.executor.execute(context, batch(new QueueAck(queueName,\n        result.getEntryPointer(), consumer)));\n\n    // Can't ack it again\n    try {\n      this.executor.execute(context, batch(new QueueAck(queueName,\n        result.getEntryPointer(), consumer)));\n      fail(\"Expecting OperationException for repeated ack.\");\n    } catch (OperationException e) {\n      // expected\n    }\n\n    // Queue should be empty again\n    dequeue = new QueueDequeue(queueName, consumer, config);\n    result = this.executor.execute(context, dequeue);\n    assertTrue(result.isEmpty());\n    \n    OmidTransactionalOperationExecutor.DISABLE_QUEUE_PAYLOADS = false;\n  }","id":79019,"modified_method":"@Test\n  public void testWriteBatchJustAck() throws Exception {\n    OmidTransactionalOperationExecutor.DISABLE_QUEUE_PAYLOADS = true;\n    \n    byte [] queueName = Bytes.toBytes(\"testWriteBatchJustAck\");\n\n    TTQueueOnVCTable.TRACE = true;\n    QueueConsumer consumer = new QueueConsumer(0, 0, 1);\n    QueueConfig config = new QueueConfig(\n        PartitionerType.RANDOM, true);\n\n    // Queue should be empty\n    QueueDequeue dequeue = new QueueDequeue(queueName, consumer, config);\n    DequeueResult result = this.executor.execute(context, dequeue);\n    assertTrue(result.isEmpty());\n\n    // Write to the queue\n    this.executor.execute(context, batch(new QueueEnqueue(queueName,\n        Bytes.toBytes(1L))));\n\n    // DequeuePayload entry just written\n    dequeue = new QueueDequeue(queueName, consumer, config);\n    result = this.executor.execute(context, dequeue);\n    assertDequeueResultSuccess(result, Bytes.toBytes(1L));\n\n    TTQueueOnVCTable.TRACE = false;\n\n    // Ack it\n    this.executor.execute(context, batch(new QueueAck(queueName,\n        result.getEntryPointer(), consumer)));\n\n    // Can't ack it again\n    try {\n      this.executor.execute(context, batch(new QueueAck(queueName,\n        result.getEntryPointer(), consumer)));\n      fail(\"Expecting OperationException for repeated ack.\");\n    } catch (OperationException e) {\n      // expected\n    }\n\n    // Queue should be empty again\n    dequeue = new QueueDequeue(queueName, consumer, config);\n    result = this.executor.execute(context, dequeue);\n    assertTrue(result.isEmpty());\n    \n    OmidTransactionalOperationExecutor.DISABLE_QUEUE_PAYLOADS = false;\n  }","commit_id":"40b75dd1efbf1d253dc0de0ecf4c89de0352d901","url":"https://github.com/caskdata/cdap"},{"original_method":"private ValueContainerImpl<Value> getMergedData() {\n    ValueContainerImpl<Value> merged = myMerged;\n    if (merged != null) {\n      return merged;\n    }\n    synchronized (myInitializer.getLock()) {\n      merged = myMerged;\n      if (merged != null) {\n        return merged;\n      }\n\n      final ValueContainer<Value> fromDisk = myInitializer.compute();\n      final ValueContainerImpl<Value> newMerged;\n\n      if (fromDisk instanceof ValueContainerImpl) {\n        newMerged = ((ValueContainerImpl<Value>)fromDisk).copy();\n      } else {\n        newMerged = ((ChangeTrackingValueContainer<Value>)fromDisk).getMergedData().copy();\n      }\n\n      TIntHashSet invalidated = myInvalidated;\n      if (invalidated != null) {\n        invalidated.forEach(new TIntProcedure() {\n          @Override\n          public boolean execute(int inputId) {\n            newMerged.removeAssociatedValue(inputId);\n            return true;\n          }\n        });\n      }\n\n      ValueContainerImpl<Value> added = myAdded;\n      if (added != null) {\n        added.forEach(new ContainerAction<Value>() {\n          @Override\n          public boolean perform(final int id, final Value value) {\n            newMerged.removeAssociatedValue(id); // enforcing \"one-value-per-file for particular key\" invariant\n            newMerged.addValue(id, value);\n            return true;\n          }\n        });\n      }\n      setNeedsCompacting(fromDisk.needsCompacting());\n\n      myMerged = newMerged;\n      return newMerged;\n    }\n  }","id":79020,"modified_method":"private ValueContainerImpl<Value> getMergedData() {\n    ValueContainerImpl<Value> merged = myMerged;\n    if (merged != null) {\n      return merged;\n    }\n    synchronized (myInitializer.getLock()) {\n      merged = myMerged;\n      if (merged != null) {\n        return merged;\n      }\n\n      final ValueContainer<Value> fromDisk = myInitializer.compute();\n      final ValueContainerImpl<Value> newMerged;\n\n      if (fromDisk instanceof ValueContainerImpl) {\n        newMerged = ((ValueContainerImpl<Value>)fromDisk).copy();\n      } else {\n        newMerged = ((ChangeTrackingValueContainer<Value>)fromDisk).getMergedData().copy();\n      }\n\n      if (myInvalidated != null) {\n        myInvalidated.forEach(new TIntProcedure() {\n          @Override\n          public boolean execute(int inputId) {\n            newMerged.removeAssociatedValue(inputId);\n            return true;\n          }\n        });\n      }\n\n      if (myAdded != null) {\n        myAdded.forEach(new ContainerAction<Value>() {\n          @Override\n          public boolean perform(final int id, final Value value) {\n            newMerged.removeAssociatedValue(id); // enforcing \"one-value-per-file for particular key\" invariant\n            newMerged.addValue(id, value);\n            return true;\n          }\n        });\n      }\n      setNeedsCompacting(fromDisk.needsCompacting());\n\n      myMerged = newMerged;\n      return newMerged;\n    }\n  }","commit_id":"abd1fcf50e16eff9d775607cbf3d4af6a5a23ab1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void addValue(int inputId, Value value) {\n    ValueContainerImpl<Value> merged = myMerged;\n    if (merged != null) {\n      merged.addValue(inputId, value);\n    }\n    ValueContainerImpl<Value> added = myAdded;\n    if (added == null) {\n      myAdded = added = new ValueContainerImpl<Value>();\n    }\n    added.addValue(inputId, value); // will flush the changes & caller should ensure exclusiveness to avoid intermediate visibility issues\n  }","id":79021,"modified_method":"@Override\n  public void addValue(int inputId, Value value) {\n    ValueContainerImpl<Value> merged = myMerged;\n    if (merged != null) {\n      merged.addValue(inputId, value);\n    }\n\n    if (myAdded == null) myAdded = new ValueContainerImpl<Value>();\n    myAdded.addValue(inputId, value);\n  }","commit_id":"abd1fcf50e16eff9d775607cbf3d4af6a5a23ab1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void removeAssociatedValue(int inputId) {\n    ValueContainerImpl<Value> merged = myMerged;\n    if (merged != null) {\n      merged.removeAssociatedValue(inputId);\n    }\n\n    ValueContainerImpl<Value> added = myAdded;\n    if (added != null) added.removeAssociatedValue(inputId);\n\n    TIntHashSet invalidated = myInvalidated;\n    if (invalidated == null) {\n      invalidated = new TIntHashSet(1);\n    }\n    invalidated.add(inputId);\n    myInvalidated = invalidated; // volatile write\n  }","id":79022,"modified_method":"@Override\n  public void removeAssociatedValue(int inputId) {\n    ValueContainerImpl<Value> merged = myMerged;\n    if (merged != null) {\n      merged.removeAssociatedValue(inputId);\n    }\n\n    if (myAdded != null) myAdded.removeAssociatedValue(inputId);\n\n    if (myInvalidated == null) myInvalidated = new TIntHashSet(1);\n    myInvalidated.add(inputId);\n  }","commit_id":"abd1fcf50e16eff9d775607cbf3d4af6a5a23ab1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void removeAllValues(Key key, int inputId) throws StorageException {\n    if (myBufferingEnabled.get()) {\n      getMemValueContainer(key).removeAssociatedValue(inputId);\n      return;\n    }\n    final ChangeTrackingValueContainer<Value> valueContainer = myMap.get(key);\n    if (valueContainer != null) {\n      valueContainer.dropMergedData();\n    }\n\n    myBackendStorage.removeAllValues(key, inputId);\n  }","id":79023,"modified_method":"@Override\n  public void removeAllValues(Key key, int inputId) throws StorageException {\n    if (myBufferingEnabled.get()) {\n      getMemValueContainer(key).removeAssociatedValue(inputId);\n      return;\n    }\n\n    myMap.remove(key); //\n\n    myBackendStorage.removeAllValues(key, inputId);\n  }","commit_id":"abd1fcf50e16eff9d775607cbf3d4af6a5a23ab1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public ValueContainerImpl<T> read(final DataInput in) throws IOException {\n      DataInputStream stream = (DataInputStream)in;\n      final ValueContainerImpl<T> valueContainer = new ValueContainerImpl<T>();\n\n      while (stream.available() > 0) {\n        final int valueCount = DataInputOutputUtil.readSINT(in);\n        if (valueCount < 0) {\n          valueContainer.removeAssociatedValue(-valueCount);\n          valueContainer.setNeedsCompacting(true);\n        }\n        else {\n          for (int valueIdx = 0; valueIdx < valueCount; valueIdx++) {\n            final T value = myExternalizer.read(in);\n            final int idCount = DataInputOutputUtil.readSINT(in);\n            for (int i = 0; i < idCount; i++) {\n              final int id = DataInputOutputUtil.readSINT(in);\n              if (id < 0) {\n                valueContainer.removeValue(-id, value);\n                valueContainer.setNeedsCompacting(true);\n              }\n              else {\n                valueContainer.addValue(id, value);\n              }\n            }\n          }\n        }\n      }\n      return valueContainer;\n    }","id":79024,"modified_method":"@NotNull\n    @Override\n    public ValueContainerImpl<T> read(final DataInput in) throws IOException {\n      DataInputStream stream = (DataInputStream)in;\n      final ValueContainerImpl<T> valueContainer = new ValueContainerImpl<T>();\n\n      while (stream.available() > 0) {\n        final int valueCount = DataInputOutputUtil.readSINT(in);\n        if (valueCount < 0) {\n          valueContainer.removeAssociatedValue(-valueCount);\n          valueContainer.setNeedsCompacting(true);\n        }\n        else {\n          for (int valueIdx = 0; valueIdx < valueCount; valueIdx++) {\n            final T value = myExternalizer.read(in);\n            final int idCount = DataInputOutputUtil.readSINT(in);\n            for (int i = 0; i < idCount; i++) {\n              final int id = DataInputOutputUtil.readSINT(in);\n              valueContainer.addValue(id, value);\n            }\n          }\n        }\n      }\n      return valueContainer;\n    }","commit_id":"abd1fcf50e16eff9d775607cbf3d4af6a5a23ab1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ResourceDescriptionAdapter install(final Resource it) {\n    ResourceDescriptionAdapter _elvis = null;\n    ResourceDescriptionAdapter _get = ResourceDescriptionAdapter.get(it);\n    if (_get != null) {\n      _elvis = _get;\n    } else {\n      ResourceDescriptionAdapter _xifexpression = null;\n      if ((it instanceof XtextResource)) {\n        ResourceDescriptionAdapter _xblockexpression = null;\n        {\n          IResourceServiceProvider _resourceServiceProvider = ((XtextResource)it).getResourceServiceProvider();\n          @Extension\n          final IResourceDescription.Manager resourceDescriptionManager = _resourceServiceProvider.getResourceDescriptionManager();\n          IResourceDescription _resourceDescription = resourceDescriptionManager.getResourceDescription(it);\n          ResourceDescriptionAdapter _resourceDescriptionAdapter = new ResourceDescriptionAdapter(_resourceDescription);\n          final Procedure1<ResourceDescriptionAdapter> _function = new Procedure1<ResourceDescriptionAdapter>() {\n            @Override\n            public void apply(final ResourceDescriptionAdapter adapter) {\n              EList<Adapter> _eAdapters = ((XtextResource)it).eAdapters();\n              _eAdapters.add(adapter);\n            }\n          };\n          _xblockexpression = ObjectExtensions.<ResourceDescriptionAdapter>operator_doubleArrow(_resourceDescriptionAdapter, _function);\n        }\n        _xifexpression = _xblockexpression;\n      }\n      _elvis = _xifexpression;\n    }\n    return _elvis;\n  }","id":79025,"modified_method":"public static ResourceDescriptionAdapter install(final Resource it) {\n    ResourceDescriptionAdapter _xblockexpression = null;\n    {\n      ResourceDescriptionAdapter.remove(it);\n      ResourceDescriptionAdapter _xifexpression = null;\n      if ((it instanceof XtextResource)) {\n        ResourceDescriptionAdapter _xblockexpression_1 = null;\n        {\n          IResourceServiceProvider _resourceServiceProvider = ((XtextResource)it).getResourceServiceProvider();\n          @Extension\n          final IResourceDescription.Manager resourceDescriptionManager = _resourceServiceProvider.getResourceDescriptionManager();\n          IResourceDescription _resourceDescription = resourceDescriptionManager.getResourceDescription(it);\n          ResourceDescriptionAdapter _resourceDescriptionAdapter = new ResourceDescriptionAdapter(_resourceDescription);\n          final Procedure1<ResourceDescriptionAdapter> _function = new Procedure1<ResourceDescriptionAdapter>() {\n            @Override\n            public void apply(final ResourceDescriptionAdapter adapter) {\n              EList<Adapter> _eAdapters = ((XtextResource)it).eAdapters();\n              _eAdapters.add(adapter);\n            }\n          };\n          _xblockexpression_1 = ObjectExtensions.<ResourceDescriptionAdapter>operator_doubleArrow(_resourceDescriptionAdapter, _function);\n        }\n        _xifexpression = _xblockexpression_1;\n      }\n      _xblockexpression = _xifexpression;\n    }\n    return _xblockexpression;\n  }","commit_id":"87603a49236e465800d1c9e7fa47a33ae38301d2","url":"https://github.com/eclipse/xtext"},{"original_method":"public PortletBag create(Portlet portlet) throws Exception {\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (!portletApp.isWARFile() && _warFile) {\n\t\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\t\t_servletContext = ServletContextPool.get(contextPath);\n\n\t\t\t_classLoader = PortalClassLoaderUtil.getClassLoader();\n\t\t}\n\n\t\tClass<?> portletClass = null;\n\n\t\ttry {\n\t\t\tportletClass = _classLoader.loadClass(portlet.getPortletClass());\n\t\t}\n\t\tcatch (Throwable e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tPortletLocalServiceUtil.destroyPortlet(portlet);\n\n\t\t\treturn null;\n\t\t}\n\n\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t(javax.portlet.Portlet)portletClass.newInstance();\n\n\t\tConfigurationAction configurationActionInstance =\n\t\t\tnewConfigurationAction(portlet);\n\n\t\tIndexer indexerInstance = newIndexer(portlet);\n\n\t\tOpenSearch openSearchInstance = newOpenSearch(portlet);\n\n\t\tinitSchedulers(portlet);\n\n\t\tFriendlyURLMapper friendlyURLMapperInstance = newFriendlyURLMapper(\n\t\t\tportlet);\n\n\t\tURLEncoder urlEncoderInstance = newURLEncoder(portlet);\n\n\t\tPortletDataHandler portletDataHandlerInstance = newPortletDataHandler(\n\t\t\tportlet);\n\n\t\tPortletLayoutListener portletLayoutListenerInstance =\n\t\t\tnewPortletLayoutListener(portlet);\n\n\t\tPollerProcessor pollerProcessorInstance = newPollerProcessor(portlet);\n\n\t\tMessageListener popMessageListenerInstance = newPOPMessageListener(\n\t\t\tportlet);\n\n\t\tSocialActivityInterpreter socialActivityInterpreterInstance =\n\t\t\tinitSocialActivityInterpreterInstance(portlet);\n\n\t\tSocialRequestInterpreter socialRequestInterpreterInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getSocialRequestInterpreterClass())) {\n\t\t\tsocialRequestInterpreterInstance =\n\t\t\t\t(SocialRequestInterpreter)newInstance(\n\t\t\t\t\tSocialRequestInterpreter.class,\n\t\t\t\t\tportlet.getSocialRequestInterpreterClass());\n\n\t\t\tsocialRequestInterpreterInstance = new SocialRequestInterpreterImpl(\n\t\t\t\tportlet.getPortletId(), socialRequestInterpreterInstance);\n\n\t\t\tSocialRequestInterpreterLocalServiceUtil.addRequestInterpreter(\n\t\t\t\tsocialRequestInterpreterInstance);\n\t\t}\n\n\t\tWebDAVStorage webDAVStorageInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getWebDAVStorageClass())) {\n\t\t\twebDAVStorageInstance = (WebDAVStorage)newInstance(\n\t\t\t\tWebDAVStorage.class, portlet.getWebDAVStorageClass());\n\n\t\t\twebDAVStorageInstance.setToken(portlet.getWebDAVStorageToken());\n\n\t\t\tWebDAVUtil.addStorage(webDAVStorageInstance);\n\t\t}\n\n\t\tMethod xmlRpcMethodInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getXmlRpcMethodClass())) {\n\t\t\txmlRpcMethodInstance = (Method)newInstance(\n\t\t\t\tMethod.class, portlet.getXmlRpcMethodClass());\n\n\t\t\tXmlRpcServlet.registerMethod(xmlRpcMethodInstance);\n\t\t}\n\n\t\tControlPanelEntry controlPanelEntryInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getControlPanelEntryClass())) {\n\t\t\tcontrolPanelEntryInstance = (ControlPanelEntry)newInstance(\n\t\t\t\tControlPanelEntry.class, portlet.getControlPanelEntryClass());\n\t\t}\n\n\t\tList<AssetRendererFactory> assetRendererFactoryInstances =\n\t\t\tnewAssetRendererFactoryInstances(portlet);\n\n\t\tList<CustomAttributesDisplay> customAttributesDisplayInstances =\n\t\t\tnew ArrayList<CustomAttributesDisplay>();\n\n\t\tfor (String customAttributesDisplayClass :\n\t\t\t\tportlet.getCustomAttributesDisplayClasses()) {\n\n\t\t\tCustomAttributesDisplay customAttributesDisplayInstance =\n\t\t\t\t(CustomAttributesDisplay)newInstance(\n\t\t\t\t\tCustomAttributesDisplay.class,\n\t\t\t\t\tcustomAttributesDisplayClass);\n\n\t\t\tcustomAttributesDisplayInstance.setClassNameId(\n\t\t\t\tPortalUtil.getClassNameId(\n\t\t\t\t\tcustomAttributesDisplayInstance.getClassName()));\n\t\t\tcustomAttributesDisplayInstance.setPortletId(\n\t\t\t\tportlet.getPortletId());\n\n\t\t\tcustomAttributesDisplayInstances.add(\n\t\t\t\tcustomAttributesDisplayInstance);\n\t\t}\n\n\t\tList<WorkflowHandler> workflowHandlerInstances =\n\t\t\tnew ArrayList<WorkflowHandler>();\n\n\t\tfor (String workflowHandlerClass :\n\t\t\t\tportlet.getWorkflowHandlerClasses()) {\n\n\t\t\tWorkflowHandler workflowHandlerInstance =\n\t\t\t\t(WorkflowHandler)newInstance(\n\t\t\t\t\tWorkflowHandler.class, workflowHandlerClass);\n\n\t\t\tworkflowHandlerInstances.add(workflowHandlerInstance);\n\n\t\t\tWorkflowHandlerRegistryUtil.register(workflowHandlerInstance);\n\t\t}\n\n\t\tPreferencesValidator preferencesValidatorInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getPreferencesValidator())) {\n\t\t\tpreferencesValidatorInstance = (PreferencesValidator)newInstance(\n\t\t\t\tPreferencesValidator.class, portlet.getPreferencesValidator());\n\n\t\t\ttry {\n\t\t\t\tif (PropsValues.PREFERENCE_VALIDATE_ON_STARTUP) {\n\t\t\t\t\tpreferencesValidatorInstance.validate(\n\t\t\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\t\t\tportlet.getDefaultPreferences()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Portlet with the name \" + portlet.getPortletId() +\n\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t}\n\t\t}\n\n\t\tMap<String, ResourceBundle> resourceBundles = null;\n\n\t\tif (Validator.isNotNull(portlet.getResourceBundle())) {\n\t\t\tresourceBundles = new HashMap<String, ResourceBundle>();\n\n\t\t\tinitResourceBundle(\n\t\t\t\tresourceBundles, portlet, LocaleUtil.getDefault());\n\n\t\t\tSet<String> supportedLocales = portlet.getSupportedLocales();\n\n\t\t\tif (supportedLocales.isEmpty()) {\n\t\t\t\tsupportedLocales = SetUtil.fromArray(PropsValues.LOCALES);\n\t\t\t}\n\n\t\t\tfor (String supportedLocale : supportedLocales) {\n\t\t\t\tLocale locale = LocaleUtil.fromLanguageId(supportedLocale);\n\n\t\t\t\tinitResourceBundle(resourceBundles, portlet, locale);\n\t\t\t}\n\t\t}\n\n\t\tPortletBag portletBag = new PortletBagImpl(\n\t\t\tportlet.getPortletId(), _servletContext, portletInstance,\n\t\t\tconfigurationActionInstance, indexerInstance, openSearchInstance,\n\t\t\tfriendlyURLMapperInstance, urlEncoderInstance,\n\t\t\tportletDataHandlerInstance, portletLayoutListenerInstance,\n\t\t\tpollerProcessorInstance, popMessageListenerInstance,\n\t\t\tsocialActivityInterpreterInstance, socialRequestInterpreterInstance,\n\t\t\twebDAVStorageInstance, xmlRpcMethodInstance,\n\t\t\tcontrolPanelEntryInstance, assetRendererFactoryInstances,\n\t\t\tcustomAttributesDisplayInstances, workflowHandlerInstances,\n\t\t\tpreferencesValidatorInstance, resourceBundles);\n\n\t\tPortletBagPool.put(portlet.getPortletId(), portletBag);\n\n\t\ttry {\n\t\t\tPortletInstanceFactoryUtil.create(portlet, _servletContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn portletBag;\n\t}","id":79026,"modified_method":"public PortletBag create(Portlet portlet) throws Exception {\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (!portletApp.isWARFile() && _warFile) {\n\t\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\t\t_servletContext = ServletContextPool.get(contextPath);\n\n\t\t\t_classLoader = PortalClassLoaderUtil.getClassLoader();\n\t\t}\n\n\t\tClass<?> portletClass = null;\n\n\t\ttry {\n\t\t\tportletClass = _classLoader.loadClass(portlet.getPortletClass());\n\t\t}\n\t\tcatch (Throwable e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tPortletLocalServiceUtil.destroyPortlet(portlet);\n\n\t\t\treturn null;\n\t\t}\n\n\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t(javax.portlet.Portlet)portletClass.newInstance();\n\n\t\tConfigurationAction configurationActionInstance =\n\t\t\tnewConfigurationAction(portlet);\n\n\t\tIndexer indexerInstance = newIndexer(portlet);\n\n\t\tOpenSearch openSearchInstance = newOpenSearch(portlet);\n\n\t\tinitSchedulers(portlet);\n\n\t\tFriendlyURLMapper friendlyURLMapperInstance = newFriendlyURLMapper(\n\t\t\tportlet);\n\n\t\tURLEncoder urlEncoderInstance = newURLEncoder(portlet);\n\n\t\tPortletDataHandler portletDataHandlerInstance = newPortletDataHandler(\n\t\t\tportlet);\n\n\t\tPortletLayoutListener portletLayoutListenerInstance =\n\t\t\tnewPortletLayoutListener(portlet);\n\n\t\tPollerProcessor pollerProcessorInstance = newPollerProcessor(portlet);\n\n\t\tMessageListener popMessageListenerInstance = newPOPMessageListener(\n\t\t\tportlet);\n\n\t\tSocialActivityInterpreter socialActivityInterpreterInstance =\n\t\t\tinitSocialActivityInterpreterInstance(portlet);\n\n\t\tSocialRequestInterpreter socialRequestInterpreterInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getSocialRequestInterpreterClass())) {\n\t\t\tsocialRequestInterpreterInstance =\n\t\t\t\t(SocialRequestInterpreter)newInstance(\n\t\t\t\t\tSocialRequestInterpreter.class,\n\t\t\t\t\tportlet.getSocialRequestInterpreterClass());\n\n\t\t\tsocialRequestInterpreterInstance = new SocialRequestInterpreterImpl(\n\t\t\t\tportlet.getPortletId(), socialRequestInterpreterInstance);\n\n\t\t\tSocialRequestInterpreterLocalServiceUtil.addRequestInterpreter(\n\t\t\t\tsocialRequestInterpreterInstance);\n\t\t}\n\n\t\tWebDAVStorage webDAVStorageInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getWebDAVStorageClass())) {\n\t\t\twebDAVStorageInstance = (WebDAVStorage)newInstance(\n\t\t\t\tWebDAVStorage.class, portlet.getWebDAVStorageClass());\n\n\t\t\twebDAVStorageInstance.setToken(portlet.getWebDAVStorageToken());\n\n\t\t\tWebDAVUtil.addStorage(webDAVStorageInstance);\n\t\t}\n\n\t\tMethod xmlRpcMethodInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getXmlRpcMethodClass())) {\n\t\t\txmlRpcMethodInstance = (Method)newInstance(\n\t\t\t\tMethod.class, portlet.getXmlRpcMethodClass());\n\n\t\t\tXmlRpcServlet.registerMethod(xmlRpcMethodInstance);\n\t\t}\n\n\t\tControlPanelEntry controlPanelEntryInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getControlPanelEntryClass())) {\n\t\t\tcontrolPanelEntryInstance = (ControlPanelEntry)newInstance(\n\t\t\t\tControlPanelEntry.class, portlet.getControlPanelEntryClass());\n\t\t}\n\n\t\tList<AssetRendererFactory> assetRendererFactoryInstances =\n\t\t\tnewAssetRendererFactoryInstances(portlet);\n\n\t\tList<CustomAttributesDisplay> customAttributesDisplayInstances =\n\t\t\tnew ArrayList<CustomAttributesDisplay>();\n\n\t\tfor (String customAttributesDisplayClass :\n\t\t\t\tportlet.getCustomAttributesDisplayClasses()) {\n\n\t\t\tCustomAttributesDisplay customAttributesDisplayInstance =\n\t\t\t\t(CustomAttributesDisplay)newInstance(\n\t\t\t\t\tCustomAttributesDisplay.class,\n\t\t\t\t\tcustomAttributesDisplayClass);\n\n\t\t\tcustomAttributesDisplayInstance.setClassNameId(\n\t\t\t\tPortalUtil.getClassNameId(\n\t\t\t\t\tcustomAttributesDisplayInstance.getClassName()));\n\t\t\tcustomAttributesDisplayInstance.setPortletId(\n\t\t\t\tportlet.getPortletId());\n\n\t\t\tcustomAttributesDisplayInstances.add(\n\t\t\t\tcustomAttributesDisplayInstance);\n\t\t}\n\n\t\tList<WorkflowHandler> workflowHandlerInstances =\n\t\t\tnew ArrayList<WorkflowHandler>();\n\n\t\tfor (String workflowHandlerClass :\n\t\t\t\tportlet.getWorkflowHandlerClasses()) {\n\n\t\t\tWorkflowHandler workflowHandlerInstance =\n\t\t\t\t(WorkflowHandler)newInstance(\n\t\t\t\t\tWorkflowHandler.class, workflowHandlerClass);\n\n\t\t\tworkflowHandlerInstances.add(workflowHandlerInstance);\n\n\t\t\tWorkflowHandlerRegistryUtil.register(workflowHandlerInstance);\n\t\t}\n\n\t\tPreferencesValidator preferencesValidatorInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getPreferencesValidator())) {\n\t\t\tpreferencesValidatorInstance = (PreferencesValidator)newInstance(\n\t\t\t\tPreferencesValidator.class, portlet.getPreferencesValidator());\n\n\t\t\ttry {\n\t\t\t\tif (PropsValues.PREFERENCE_VALIDATE_ON_STARTUP) {\n\t\t\t\t\tpreferencesValidatorInstance.validate(\n\t\t\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\t\t\tportlet.getDefaultPreferences()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Portlet with the name \" + portlet.getPortletId() +\n\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t}\n\t\t}\n\n\t\tMap<String, ResourceBundle> resourceBundles = null;\n\n\t\tif (Validator.isNotNull(portlet.getResourceBundle())) {\n\t\t\tresourceBundles = new HashMap<String, ResourceBundle>();\n\n\t\t\tinitResourceBundle(\n\t\t\t\tresourceBundles, portlet, LocaleUtil.getDefault());\n\n\t\t\tSet<String> supportedLocales = portlet.getSupportedLocales();\n\n\t\t\tif (supportedLocales.isEmpty()) {\n\t\t\t\tsupportedLocales = SetUtil.fromArray(PropsValues.LOCALES);\n\t\t\t}\n\n\t\t\tfor (String supportedLocale : supportedLocales) {\n\t\t\t\tLocale locale = LocaleUtil.fromLanguageId(supportedLocale);\n\n\t\t\t\tinitResourceBundle(resourceBundles, portlet, locale);\n\t\t\t}\n\t\t}\n\n\t\tPortletBag portletBag = new PortletBagImpl(\n\t\t\tportlet.getPortletId(), _servletContext, portletInstance,\n\t\t\tconfigurationActionInstance, indexerInstance, openSearchInstance,\n\t\t\tfriendlyURLMapperInstance, urlEncoderInstance,\n\t\t\tportletDataHandlerInstance, portletLayoutListenerInstance,\n\t\t\tpollerProcessorInstance, popMessageListenerInstance,\n\t\t\tsocialActivityInterpreterInstance, socialRequestInterpreterInstance,\n\t\t\twebDAVStorageInstance, xmlRpcMethodInstance,\n\t\t\tcontrolPanelEntryInstance, assetRendererFactoryInstances,\n\t\t\tcustomAttributesDisplayInstances, workflowHandlerInstances,\n\t\t\tpreferencesValidatorInstance, resourceBundles);\n\n\t\tPortletBagPool.put(portlet.getRootPortletId(), portletBag);\n\n\t\ttry {\n\t\t\tPortletInstanceFactoryUtil.create(portlet, _servletContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn portletBag;\n\t}","commit_id":"279dec2aa15f18273a3c9d5ad267e3b89a1d4a2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void clear(Portlet portlet) {\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances != null) {\n\t\t\tIterator<Map.Entry<String, InvokerPortlet>> itr =\n\t\t\t\tportletInstances.entrySet().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMap.Entry<String, InvokerPortlet> entry = itr.next();\n\n\t\t\t\tString portletId = entry.getKey();\n\t\t\t\tInvokerPortlet invokerPortletInstance = entry.getValue();\n\n\t\t\t\tif (PortletConstants.getInstanceId(portletId) == null) {\n\t\t\t\t\tinvokerPortletInstance.destroy();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_pool.remove(portlet.getRootPortletId());\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (portletApp.isWARFile()) {\n\t\t\tPortletBag portletBag = PortletBagPool.get(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\t\tif (portletBag != null) {\n\t\t\t\tportletBag.setPortletInstance(null);\n\t\t\t}\n\t\t}\n\t}","id":79027,"modified_method":"public void clear(Portlet portlet) {\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances != null) {\n\t\t\tIterator<Map.Entry<String, InvokerPortlet>> itr =\n\t\t\t\tportletInstances.entrySet().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMap.Entry<String, InvokerPortlet> entry = itr.next();\n\n\t\t\t\tString portletId = entry.getKey();\n\t\t\t\tInvokerPortlet invokerPortletInstance = entry.getValue();\n\n\t\t\t\tif (PortletConstants.getInstanceId(portletId) == null) {\n\t\t\t\t\tinvokerPortletInstance.destroy();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_pool.remove(portlet.getRootPortletId());\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (portletApp.isWARFile()) {\n\t\t\tPortletBagPool.remove(portlet.getRootPortletId());\n\t\t}\n\t}","commit_id":"279dec2aa15f18273a3c9d5ad267e3b89a1d4a2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public InvokerPortlet create(Portlet portlet, ServletContext servletContext)\n\t\tthrows PortletException {\n\n\t\tboolean instanceable = false;\n\n\t\tif ((portlet.isInstanceable()) &&\n\t\t\t(PortletConstants.getInstanceId(portlet.getPortletId()) != null)) {\n\n\t\t\tinstanceable = true;\n\t\t}\n\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances == null) {\n\t\t\tportletInstances = new ConcurrentHashMap<String, InvokerPortlet>();\n\n\t\t\t_pool.put(portlet.getRootPortletId(), portletInstances);\n\t\t}\n\n\t\tInvokerPortlet instanceInvokerPortletInstance = null;\n\n\t\tif (instanceable) {\n\t\t\tinstanceInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getPortletId());\n\t\t}\n\n\t\tInvokerPortlet rootInvokerPortletInstance = null;\n\n\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\trootInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\t\tif (rootInvokerPortletInstance == null) {\n\t\t\t\tPortletBag portletBag = PortletBagPool.get(\n\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\t\t\tportlet, servletContext);\n\n\t\t\t\trootInvokerPortletInstance = init(\n\t\t\t\t\tportlet, portletConfig, portletBag.getPortletInstance());\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getRootPortletId(), rootInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\n\t\tif (instanceable) {\n\t\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t\t\trootInvokerPortletInstance.getPortletInstance();\n\n\t\t\t\tPortletConfig portletConfig =\n\t\t\t\t\tPortletConfigFactoryUtil.create(portlet, servletContext);\n\n\t\t\t\tPortletContext portletContext =\n\t\t\t\t\tportletConfig.getPortletContext();\n\t\t\t\tboolean checkAuthToken =\n\t\t\t\t\trootInvokerPortletInstance.isCheckAuthToken();\n\t\t\t\tboolean facesPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isFacesPortlet();\n\t\t\t\tboolean strutsPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsPortlet();\n\t\t\t\tboolean strutsBridgePortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsBridgePortlet();\n\n\t\t\t\tinstanceInvokerPortletInstance =\n\t\t\t\t\t_internalInvokerPortletPrototype.create(\n\t\t\t\t\t\tportlet, portletInstance, portletConfig, portletContext,\n\t\t\t\t\t\tcheckAuthToken, facesPortlet, strutsPortlet,\n\t\t\t\t\t\tstrutsBridgePortlet);\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getPortletId(), instanceInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (rootInvokerPortletInstance != null) {\n\t\t\t\tinstanceInvokerPortletInstance = rootInvokerPortletInstance;\n\t\t\t}\n\t\t}\n\n\t\treturn instanceInvokerPortletInstance;\n\t}","id":79028,"modified_method":"public InvokerPortlet create(Portlet portlet, ServletContext servletContext)\n\t\tthrows PortletException {\n\n\t\tboolean instanceable = false;\n\n\t\tif ((portlet.isInstanceable()) &&\n\t\t\t(PortletConstants.getInstanceId(portlet.getPortletId()) != null)) {\n\n\t\t\tinstanceable = true;\n\t\t}\n\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances == null) {\n\t\t\tportletInstances = new ConcurrentHashMap<String, InvokerPortlet>();\n\n\t\t\t_pool.put(portlet.getRootPortletId(), portletInstances);\n\t\t}\n\n\t\tInvokerPortlet instanceInvokerPortletInstance = null;\n\n\t\tif (instanceable) {\n\t\t\tinstanceInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getPortletId());\n\t\t}\n\n\t\tInvokerPortlet rootInvokerPortletInstance = null;\n\n\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\trootInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\t\tif (rootInvokerPortletInstance == null) {\n\t\t\t\tPortletBag portletBag = PortletBagPool.get(\n\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\t// Portlet bag should never be null unless the portlet has been\n\t\t\t\t// undeployed\n\n\t\t\t\tif (portletBag == null) {\n\t\t\t\t\tPortletBagFactory portletBagFactory =\n\t\t\t\t\t\tnew PortletBagFactory();\n\n\t\t\t\t\tportletBagFactory.setClassLoader(\n\t\t\t\t\t\tPortalClassLoaderUtil.getClassLoader());\n\t\t\t\t\tportletBagFactory.setServletContext(servletContext);\n\t\t\t\t\tportletBagFactory.setWARFile(false);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tportletBag = portletBagFactory.create(portlet);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tthrow new PortletException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\t\t\tportlet, servletContext);\n\n\t\t\t\trootInvokerPortletInstance = init(\n\t\t\t\t\tportlet, portletConfig, portletBag.getPortletInstance());\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getRootPortletId(), rootInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\n\t\tif (instanceable) {\n\t\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t\t\trootInvokerPortletInstance.getPortletInstance();\n\n\t\t\t\tPortletConfig portletConfig =\n\t\t\t\t\tPortletConfigFactoryUtil.create(portlet, servletContext);\n\n\t\t\t\tPortletContext portletContext =\n\t\t\t\t\tportletConfig.getPortletContext();\n\t\t\t\tboolean checkAuthToken =\n\t\t\t\t\trootInvokerPortletInstance.isCheckAuthToken();\n\t\t\t\tboolean facesPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isFacesPortlet();\n\t\t\t\tboolean strutsPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsPortlet();\n\t\t\t\tboolean strutsBridgePortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsBridgePortlet();\n\n\t\t\t\tinstanceInvokerPortletInstance =\n\t\t\t\t\t_internalInvokerPortletPrototype.create(\n\t\t\t\t\t\tportlet, portletInstance, portletConfig, portletContext,\n\t\t\t\t\t\tcheckAuthToken, facesPortlet, strutsPortlet,\n\t\t\t\t\t\tstrutsBridgePortlet);\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getPortletId(), instanceInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (rootInvokerPortletInstance != null) {\n\t\t\t\tinstanceInvokerPortletInstance = rootInvokerPortletInstance;\n\t\t\t}\n\t\t}\n\n\t\treturn instanceInvokerPortletInstance;\n\t}","commit_id":"279dec2aa15f18273a3c9d5ad267e3b89a1d4a2b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public <T> T sendAndReceiveFixedConnection(Connection conn, Object obj) throws IOException {\n        final SerializationService serializationService = getSerializationService();\n        final Data request = serializationService.toData(obj);\n        conn.write(request);\n        final Data response = conn.read();\n        return (T) serializationService.toObject(response);\n    }","id":79029,"modified_method":"public <T> T sendAndReceiveFixedConnection(Connection conn, Object obj) throws IOException {\n        final SerializationService serializationService = getSerializationService();\n        final Data request = serializationService.toData(obj);\n        conn.write(request);\n        final Data response = conn.read();\n        final Object result = serializationService.toObject(response);\n        return ErrorHandler.returnResultOrThrowException(result) ;\n    }","commit_id":"e0092c3a4f05c71529a9faff007589ca390421b0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private <T> T sendAndReceive(Connection conn, Object obj) throws IOException {\n        try {\n            final SerializationService serializationService = getSerializationService();\n            final Data request = serializationService.toData(obj);\n            conn.write(request);\n            final Data response = conn.read();\n            return (T) serializationService.toObject(response);\n        } catch (IOException e){\n            ((ClientPartitionServiceImpl)client.getClientPartitionService()).refreshPartitions();\n            if (redoOperation || obj instanceof RetryableRequest){\n                return sendAndReceive(obj);\n            }\n            throw new HazelcastException(e);\n        }\n    }","id":79030,"modified_method":"private <T> T sendAndReceive(Connection conn, Object obj) throws IOException {\n        try {\n            final SerializationService serializationService = getSerializationService();\n            final Data request = serializationService.toData(obj);\n            conn.write(request);\n            final Data response = conn.read();\n            final Object result = serializationService.toObject(response);\n            return ErrorHandler.returnResultOrThrowException(result);\n        } catch (IOException e){\n            ((ClientPartitionServiceImpl)client.getClientPartitionService()).refreshPartitions();\n            if (redoOperation || obj instanceof RetryableRequest){\n                return sendAndReceive(obj);\n            }\n            throw new HazelcastException(e);\n        }\n    }","commit_id":"e0092c3a4f05c71529a9faff007589ca390421b0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object read() throws Exception {\n        final Data data = connection.read();\n        return serializationService.toObject(data);\n    }","id":79031,"modified_method":"public Object read() throws Exception {\n        final Data data = connection.read();\n        Object result = serializationService.toObject(data);\n        return ErrorHandler.returnResultOrThrowException(result);\n    }","commit_id":"e0092c3a4f05c71529a9faff007589ca390421b0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Object authenticate(Connection connection, Credentials credentials, ClientPrincipal principal, boolean reAuth, boolean firstConnection) throws IOException {\n        AuthenticationRequest auth = new AuthenticationRequest(credentials, principal);\n        auth.setReAuth(reAuth);\n        auth.setFirstConnection(firstConnection);\n        final SerializationService serializationService = getSerializationService();\n        connection.write(serializationService.toData(auth));\n        final Data addressData = connection.read();\n        Address address = (Address)serializationService.toObject(addressData);\n        connection.setEndpoint(address);\n\n        final Data data = connection.read();\n        return ErrorHandler.returnResultOrThrowException(serializationService.toObject(data));\n    }","id":79032,"modified_method":"private Object authenticate(Connection connection, Credentials credentials, ClientPrincipal principal, boolean reAuth, boolean firstConnection) throws IOException {\n        AuthenticationRequest auth = new AuthenticationRequest(credentials, principal);\n        auth.setReAuth(reAuth);\n        auth.setFirstConnection(firstConnection);\n        final SerializationService serializationService = getSerializationService();\n        connection.write(serializationService.toData(auth));\n        final Data addressData = connection.read();\n        Address address = ErrorHandler.returnResultOrThrowException(serializationService.toObject(addressData));\n        connection.setEndpoint(address);\n\n        final Data data = connection.read();\n        return ErrorHandler.returnResultOrThrowException(serializationService.toObject(data));\n    }","commit_id":"59c4822d4ad5dfac4cecd11231280baa33d4aa35","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\r\n    public void visitInstanceOfExpression(@NotNull PsiInstanceOfExpression expression) {\r\n        super.visitInstanceOfExpression(expression);\r\n        myResult = new IsOperator(\r\n                getConverter().expressionToExpression(expression.getOperand()),\r\n                getConverter().elementToElement(expression.getCheckType()));\r\n    }","id":79033,"modified_method":"@Override\r\n    public void visitInstanceOfExpression(@NotNull PsiInstanceOfExpression expression) {\r\n        super.visitInstanceOfExpression(expression);\r\n        PsiTypeElement checkType = expression.getCheckType();\r\n        myResult = new IsOperator(\r\n                getConverter().expressionToExpression(expression.getOperand()),\r\n                new TypeElement(checkType == null ? new EmptyType() : myConverter.typeToType(checkType.getType())));\r\n    }","commit_id":"d4c7b7b2b7f6586bb70f361d4c1b8cf689ae75a2","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    PsiInstanceOfExpression instanceOfExpression = getInstanceOfExpression(editor, file);\n    if (instanceOfExpression != null) {\n      String castTo = instanceOfExpression.getCheckType().getType().getPresentableText();\n      setText(\"Insert '(\"+castTo+\")\"+instanceOfExpression.getOperand().getText()+\"' declaration\");\n\n      PsiStatement statement = PsiTreeUtil.getParentOfType(instanceOfExpression, PsiStatement.class);\n      return statement instanceof PsiIfStatement && PsiTreeUtil.isAncestor(((PsiIfStatement)statement).getCondition(), instanceOfExpression, false)\n             || statement instanceof PsiWhileStatement && PsiTreeUtil.isAncestor(((PsiWhileStatement)statement).getCondition(), instanceOfExpression, false);\n    }\n    return false;\n  }","id":79034,"modified_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    PsiInstanceOfExpression instanceOfExpression = getInstanceOfExpression(editor, file);\n    if (instanceOfExpression != null) {\n      PsiTypeElement checkType = instanceOfExpression.getCheckType();\n      if (checkType == null) return false;\n      PsiType type = checkType.getType();\n      if (type == null) return false;\n      String castTo = type.getPresentableText();\n      setText(\"Insert '(\"+castTo+\")\"+instanceOfExpression.getOperand().getText()+\"' declaration\");\n\n      PsiStatement statement = PsiTreeUtil.getParentOfType(instanceOfExpression, PsiStatement.class);\n      return statement instanceof PsiIfStatement && PsiTreeUtil.isAncestor(((PsiIfStatement)statement).getCondition(), instanceOfExpression, false)\n             || statement instanceof PsiWhileStatement && PsiTreeUtil.isAncestor(((PsiWhileStatement)statement).getCondition(), instanceOfExpression, false);\n    }\n    return false;\n  }","commit_id":"a95153be9ba2a695233dd69ca0cdee0f5fa597fa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getText() {\n    String text = \"Change to '!(\";\n    text += myPrefixExpression.getOperand().getText();\n    text += \" \";\n    PsiElement parent = myPrefixExpression.getParent();\n    String operation = parent instanceof PsiInstanceOfExpression ? \"instanceof\" : ((PsiBinaryExpression)parent).getOperationSign().getText();\n    text += operation + \" \";\n\n    String rop = parent instanceof PsiInstanceOfExpression ? ((PsiInstanceOfExpression)parent).getCheckType().getText()\n      : ((PsiBinaryExpression)parent).getROperand().getText();\n\n    text += rop;\n    text += \")'\";\n    return text;\n  }","id":79035,"modified_method":"public String getText() {\n    String text = \"Change to '!(\";\n    text += myPrefixExpression.getOperand().getText();\n    text += \" \";\n    PsiElement parent = myPrefixExpression.getParent();\n    String operation = parent instanceof PsiInstanceOfExpression ? \"instanceof\" : ((PsiBinaryExpression)parent).getOperationSign().getText();\n    text += operation + \" \";\n\n    String rop;\n    if (parent instanceof PsiInstanceOfExpression) {\n      final PsiTypeElement type = ((PsiInstanceOfExpression)parent).getCheckType();\n      rop = type == null ? \"\" : type.getText();\n    }\n    else {\n      final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();\n      rop = rOperand == null ? \"\" : rOperand.getText();\n    }\n\n    text += rop;\n    text += \")'\";\n    return text;\n  }","commit_id":"34157df5eb139837e082d463809534c8cfb46fcb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\t\tif (_threadLocalSources == null) {\n\t\t\tthrow new IllegalArgumentException(\"Thread local sources is null\");\n\t\t}\n\n\t\tClassLoader classLoader = getClassLoader();\n\n\t\tfor (KeyValuePair keyValuePair : _threadLocalSources) {\n\t\t\tString className = keyValuePair.getKey();\n\t\t\tString fieldName = keyValuePair.getValue();\n\n\t\t\tClass<?> clazz = classLoader.loadClass(className);\n\n\t\t\tField field = ReflectionUtil.getDeclaredField(clazz, fieldName);\n\n\t\t\tif (!ThreadLocal.class.isAssignableFrom(field.getType())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(fieldName + \" is not type of ThreadLocal.\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(fieldName + \" is not a static ThreadLocal.\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tThreadLocal<Serializable> threadLocal =\n\t\t\t\t(ThreadLocal<Serializable>)field.get(null);\n\n\t\t\tif (threadLocal == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(fieldName + \" is not initialized.\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t_threadLocals.add(threadLocal);\n\t\t}\n\n\t\t_threadLocalValues = new Serializable[_threadLocals.size()];\n\n\t\t_index = ThreadLocalDistributorRegistry.addThreadLocalDistributor(this);\n\t}","id":79036,"modified_method":"public void afterPropertiesSet() throws Exception {\n\t\tif (_threadLocalSources == null) {\n\t\t\tthrow new IllegalArgumentException(\"Thread local sources is null\");\n\t\t}\n\n\t\tClassLoader classLoader = getClassLoader();\n\n\t\tfor (KeyValuePair keyValuePair : _threadLocalSources) {\n\t\t\tString className = keyValuePair.getKey();\n\t\t\tString fieldName = keyValuePair.getValue();\n\n\t\t\tClass<?> clazz = classLoader.loadClass(className);\n\n\t\t\tField field = ReflectionUtil.getDeclaredField(clazz, fieldName);\n\n\t\t\tif (!ThreadLocal.class.isAssignableFrom(field.getType())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(fieldName + \" is not of type ThreadLocal\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(fieldName + \" is not a static ThreadLocal\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tThreadLocal<Serializable> threadLocal =\n\t\t\t\t(ThreadLocal<Serializable>)field.get(null);\n\n\t\t\tif (threadLocal == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(fieldName + \" is not initialized\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t_threadLocals.add(threadLocal);\n\t\t}\n\n\t\t_threadLocalValues = new Serializable[_threadLocals.size()];\n\n\t\t_index = ThreadLocalDistributorRegistry.addThreadLocalDistributor(this);\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void readExternal(ObjectInput objectInput)\n\t\tthrows ClassNotFoundException, IOException {\n\n\t\t_index = objectInput.readInt();\n\t\t_threadLocalValues = (Serializable[])objectInput.readObject();\n\n\t\tThreadLocalDistributor originalThreadLocalDistributor =\n\t\t\tThreadLocalDistributorRegistry.getThreadLocalDistributor(_index);\n\n\t\t_threadLocals = originalThreadLocalDistributor._threadLocals;\n\t}","id":79037,"modified_method":"public void readExternal(ObjectInput objectInput)\n\t\tthrows ClassNotFoundException, IOException {\n\n\t\t_index = objectInput.readInt();\n\t\t_threadLocalValues = (Serializable[])objectInput.readObject();\n\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tThreadLocalDistributorRegistry.getThreadLocalDistributor(_index);\n\n\t\t_threadLocals = threadLocalDistributor._threadLocals;\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void capture() {\n\t\tfor (int i = 0; i < _threadLocalValues.length; i++) {\n\t\t\t_threadLocalValues[i] = _threadLocals.get(i).get();\n\t\t}\n\t}","id":79038,"modified_method":"public void capture() {\n\t\tfor (int i = 0; i < _threadLocalValues.length; i++) {\n\t\t\tThreadLocal<Serializable> threadLocal = _threadLocals.get(i);\n\n\t\t\t_threadLocalValues[i] = threadLocal.get();\n\t\t}\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"static ThreadLocalDistributor getThreadLocalDistributor(int index) {\n\t\treturn _threadLocalDistributors[index];\n\t}","id":79039,"modified_method":"protected static ThreadLocalDistributor getThreadLocalDistributor(\n\t\tint index) {\n\n\t\treturn _threadLocalDistributors[index];\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"static int addThreadLocalDistributor(\n\t\tThreadLocalDistributor threadLocalDistributor) {\n\n\t\tint newLength = _threadLocalDistributors.length + 1;\n\n\t\tThreadLocalDistributor[] threadLocalDistributors = Arrays.copyOf(\n\t\t\t_threadLocalDistributors, newLength);\n\n\t\tthreadLocalDistributors[newLength - 1] = threadLocalDistributor;\n\n\t\t_threadLocalDistributors = threadLocalDistributors;\n\n\t\treturn newLength - 1;\n\t}","id":79040,"modified_method":"protected static int addThreadLocalDistributor(\n\t\tThreadLocalDistributor threadLocalDistributor) {\n\n\t\tint newLength = _threadLocalDistributors.length + 1;\n\n\t\tThreadLocalDistributor[] threadLocalDistributors = Arrays.copyOf(\n\t\t\t_threadLocalDistributors, newLength);\n\n\t\tthreadLocalDistributors[newLength - 1] = threadLocalDistributor;\n\n\t\t_threadLocalDistributors = threadLocalDistributors;\n\n\t\treturn newLength - 1;\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetClassLoader() {\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tClassLoader contextClassLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\tAssert.assertSame(\n\t\t\tcontextClassLoader, threadLocalDistributor.getClassLoader());\n\t}","id":79041,"modified_method":"@Test\n\tpublic void testGetClassLoader() {\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\tAssert.assertSame(\n\t\t\tcontextClassLoader, threadLocalDistributor.getClassLoader());\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSerialization() throws Exception {\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tthreadLocalDistributor.setClassLoader(getClass().getClassLoader());\n\t\tthreadLocalDistributor.setThreadLocalSources(keyValuePairs);\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\tString testValue = \"testValue\";\n\n\t\tTestClass._threadLocal.set(testValue);\n\n\t\tthreadLocalDistributor.capture();\n\n\t\tSerializable[] threadLocalValues = _getThreadLocalValues(\n\t\t\tthreadLocalDistributor);\n\n\t\tAssert.assertEquals(1, threadLocalValues.length);\n\t\tAssert.assertSame(testValue, threadLocalValues[0]);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\t\tObjectOutputStream objectOutputStream = new ObjectOutputStream(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tthreadLocalDistributor.writeExternal(objectOutputStream);\n\n\t\tobjectOutputStream.close();\n\n\t\tbyte[] data = unsyncByteArrayOutputStream.toByteArray();\n\n\t\tUnsyncByteArrayInputStream unsyncByteArrayInputStream =\n\t\t\tnew UnsyncByteArrayInputStream(data);\n\n\t\tObjectInputStream objectInputStream = new ObjectInputStream(\n\t\t\tunsyncByteArrayInputStream);\n\n\t\tAssert.assertEquals(0, objectInputStream.readInt());\n\t\tAssert.assertArrayEquals(\n\t\t\tthreadLocalValues, (Serializable[])objectInputStream.readObject());\n\n\t\tTestClass._threadLocal.remove();\n\n\t\tunsyncByteArrayInputStream = new UnsyncByteArrayInputStream(data);\n\n\t\tobjectInputStream = new ObjectInputStream(unsyncByteArrayInputStream);\n\n\t\tThreadLocalDistributor newThreadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tnewThreadLocalDistributor.readExternal(objectInputStream);\n\n\t\tnewThreadLocalDistributor.restore();\n\n\t\tAssert.assertEquals(testValue, TestClass._threadLocal.get());\n\t}","id":79042,"modified_method":"@Test\n\tpublic void testSerialization() throws Exception {\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tthreadLocalDistributor.setClassLoader(getClassLoader());\n\t\tthreadLocalDistributor.setThreadLocalSources(_keyValuePairs);\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\tString testValue = \"testValue\";\n\n\t\tTestClass._threadLocal.set(testValue);\n\n\t\tthreadLocalDistributor.capture();\n\n\t\tSerializable[] threadLocalValues = getThreadLocalValues(\n\t\t\tthreadLocalDistributor);\n\n\t\tAssert.assertEquals(1, threadLocalValues.length);\n\t\tAssert.assertSame(testValue, threadLocalValues[0]);\n\n\t\tUnsyncByteArrayOutputStream unsyncByteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tObjectOutputStream objectOutputStream = new ObjectOutputStream(\n\t\t\tunsyncByteArrayOutputStream);\n\n\t\tthreadLocalDistributor.writeExternal(objectOutputStream);\n\n\t\tobjectOutputStream.close();\n\n\t\tbyte[] data = unsyncByteArrayOutputStream.toByteArray();\n\n\t\tUnsyncByteArrayInputStream unsyncByteArrayInputStream =\n\t\t\tnew UnsyncByteArrayInputStream(data);\n\n\t\tObjectInputStream objectInputStream = new ObjectInputStream(\n\t\t\tunsyncByteArrayInputStream);\n\n\t\tAssert.assertEquals(0, objectInputStream.readInt());\n\t\tAssert.assertArrayEquals(\n\t\t\tthreadLocalValues, (Serializable[])objectInputStream.readObject());\n\n\t\tTestClass._threadLocal.remove();\n\n\t\tunsyncByteArrayInputStream = new UnsyncByteArrayInputStream(data);\n\n\t\tobjectInputStream = new ObjectInputStream(unsyncByteArrayInputStream);\n\n\t\tThreadLocalDistributor newThreadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\tnewThreadLocalDistributor.readExternal(objectInputStream);\n\n\t\tnewThreadLocalDistributor.restore();\n\n\t\tAssert.assertEquals(testValue, TestClass._threadLocal.get());\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testAfterPropertiesSet() throws Exception {\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\ttry {\n\t\t\tthreadLocalDistributor.afterPropertiesSet();\n\t\t}\n\n\t\tcatch(IllegalArgumentException iae) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Thread local sources is null\", iae.getMessage());\n\t\t}\n\n\t\tthreadLocalDistributor.setClassLoader(getClass().getClassLoader());\n\t\tthreadLocalDistributor.setThreadLocalSources(keyValuePairs);\n\n\t\t// 1) With log\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tThreadLocalDistributor.class.getName(), Level.WARNING);\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\tAssert.assertEquals(3, logRecords.size());\n\n\t\tLogRecord logRecord1 = logRecords.get(0);\n\n\t\tAssert.assertEquals(\n\t\t\t\"_nonStatic is not a static ThreadLocal.\", logRecord1.getMessage());\n\n\t\tLogRecord logRecord2 = logRecords.get(1);\n\n\t\tAssert.assertEquals(\n\t\t\t\"_nullValue is not initialized.\", logRecord2.getMessage());\n\n\t\tLogRecord logRecord3 = logRecords.get(2);\n\n\t\tAssert.assertEquals(\n\t\t\t\"_object is not type of ThreadLocal.\", logRecord3.getMessage());\n\n\t\tList<ThreadLocal<Serializable>> threadLocals = _getThreadLocals(\n\t\t\tthreadLocalDistributor);\n\n\t\tAssert.assertEquals(1, threadLocals.size());\n\n\t\tAssert.assertSame(TestClass._threadLocal, threadLocals.get(0));\n\n\t\t// 2) Without log\n\n\t\tlogRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tThreadLocalDistributor.class.getName(), Level.OFF);\n\n\t\tthreadLocalDistributor = new ThreadLocalDistributor();\n\n\t\tthreadLocalDistributor.setClassLoader(getClass().getClassLoader());\n\t\tthreadLocalDistributor.setThreadLocalSources(keyValuePairs);\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\tthreadLocals = _getThreadLocals(threadLocalDistributor);\n\n\t\tAssert.assertEquals(1, threadLocals.size());\n\n\t\tAssert.assertSame(TestClass._threadLocal, threadLocals.get(0));\n\t}","id":79043,"modified_method":"@Test\n\tpublic void testAfterPropertiesSet() throws Exception {\n\t\tThreadLocalDistributor threadLocalDistributor =\n\t\t\tnew ThreadLocalDistributor();\n\n\t\ttry {\n\t\t\tthreadLocalDistributor.afterPropertiesSet();\n\t\t}\n\n\t\tcatch(IllegalArgumentException iae) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Thread local sources is null\", iae.getMessage());\n\t\t}\n\n\t\tthreadLocalDistributor.setClassLoader(getClassLoader());\n\t\tthreadLocalDistributor.setThreadLocalSources(_keyValuePairs);\n\n\t\t// With log\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tThreadLocalDistributor.class.getName(), Level.WARNING);\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\tAssert.assertEquals(3, logRecords.size());\n\n\t\tLogRecord logRecord1 = logRecords.get(0);\n\n\t\tAssert.assertEquals(\n\t\t\t\"_nonStatic is not a static ThreadLocal\", logRecord1.getMessage());\n\n\t\tLogRecord logRecord2 = logRecords.get(1);\n\n\t\tAssert.assertEquals(\n\t\t\t\"_nullValue is not initialized\", logRecord2.getMessage());\n\n\t\tLogRecord logRecord3 = logRecords.get(2);\n\n\t\tAssert.assertEquals(\n\t\t\t\"_object is not of type ThreadLocal\", logRecord3.getMessage());\n\n\t\tList<ThreadLocal<Serializable>> threadLocals = getThreadLocals(\n\t\t\tthreadLocalDistributor);\n\n\t\tAssert.assertEquals(1, threadLocals.size());\n\t\tAssert.assertSame(TestClass._threadLocal, threadLocals.get(0));\n\n\t\t// Without log\n\n\t\tlogRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tThreadLocalDistributor.class.getName(), Level.OFF);\n\n\t\tthreadLocalDistributor = new ThreadLocalDistributor();\n\n\t\tthreadLocalDistributor.setClassLoader(getClassLoader());\n\t\tthreadLocalDistributor.setThreadLocalSources(_keyValuePairs);\n\n\t\tthreadLocalDistributor.afterPropertiesSet();\n\n\t\tAssert.assertTrue(logRecords.isEmpty());\n\n\t\tthreadLocals = getThreadLocals(threadLocalDistributor);\n\n\t\tAssert.assertEquals(1, threadLocals.size());\n\t\tAssert.assertSame(TestClass._threadLocal, threadLocals.get(0));\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private List<ThreadLocal<Serializable>> _getThreadLocals(\n\t\t\tThreadLocalDistributor threadLocalDistributor)\n\t\tthrows Exception {\n\n\t\tField threadLocalsField = ReflectionUtil.getDeclaredField(\n\t\t\tThreadLocalDistributor.class, \"_threadLocals\");\n\n\t\treturn (List<ThreadLocal<Serializable>>)threadLocalsField.get(\n\t\t\tthreadLocalDistributor);\n\t}","id":79044,"modified_method":"protected List<ThreadLocal<Serializable>> getThreadLocals(\n\t\t\tThreadLocalDistributor threadLocalDistributor)\n\t\tthrows Exception {\n\n\t\tField threadLocalsField = ReflectionUtil.getDeclaredField(\n\t\t\tThreadLocalDistributor.class, \"_threadLocals\");\n\n\t\treturn (List<ThreadLocal<Serializable>>)threadLocalsField.get(\n\t\t\tthreadLocalDistributor);\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Serializable[] _getThreadLocalValues(\n\t\t\tThreadLocalDistributor threadLocalDistributor)\n\t\tthrows Exception {\n\n\t\tField threadLocalValuesField = ReflectionUtil.getDeclaredField(\n\t\t\tThreadLocalDistributor.class, \"_threadLocalValues\");\n\n\t\treturn (Serializable[])threadLocalValuesField.get(\n\t\t\tthreadLocalDistributor);\n\t}","id":79045,"modified_method":"protected Serializable[] getThreadLocalValues(\n\t\t\tThreadLocalDistributor threadLocalDistributor)\n\t\tthrows Exception {\n\n\t\tField threadLocalValuesField = ReflectionUtil.getDeclaredField(\n\t\t\tThreadLocalDistributor.class, \"_threadLocalValues\");\n\n\t\treturn (Serializable[])threadLocalValuesField.get(\n\t\t\tthreadLocalDistributor);\n\t}","commit_id":"39728e18c5c10df2a5b34a3c7252d89fcd8054b8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic void receive(Message message) {\n\t\t\tClassLoader currentClassLoader =\n\t\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\t\tAssert.assertEquals(_testClassLoader, currentClassLoader);\n\t\t}","id":79046,"modified_method":"@Override\n\t\tpublic void receive(Message message) {\n\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\tClassLoader currentClassLoader =\n\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\tAssert.assertEquals(_testClassLoader, currentClassLoader);\n\t\t}","commit_id":"8cda64944390f8109e2bedc59a48a0d3769f29e8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Connection getUpgradeOptimizedConnection()\n\t\tthrows SQLException {\n\n\t\tConnection con = getConnection();\n\n\t\tDatabaseMetaData metaData = con.getMetaData();\n\n\t\tString productName = metaData.getDatabaseProductName();\n\n\t\tif (!productName.equals(\"Microsoft SQL Server\")) {\n\t\t\treturn con;\n\t\t}\n\n\t\treturn (Connection) ProxyUtil.newProxyInstance(\n\t\t\tThread.currentThread().getContextClassLoader(),\n\t\t\tnew Class[] { Connection.class },\n\t\t\tnew UpgradeOptimizedConnectionHandler(con));\n\t}","id":79047,"modified_method":"public static Connection getUpgradeOptimizedConnection()\n\t\tthrows SQLException {\n\n\t\tConnection con = getConnection();\n\n\t\tDatabaseMetaData metaData = con.getMetaData();\n\n\t\tString productName = metaData.getDatabaseProductName();\n\n\t\tif (!productName.equals(\"Microsoft SQL Server\")) {\n\t\t\treturn con;\n\t\t}\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader classLoader = currentThread.getContextClassLoader();\n\n\t\treturn (Connection)ProxyUtil.newProxyInstance(\n\t\t\tclassLoader, new Class[] {Connection.class},\n\t\t\tnew UpgradeOptimizedConnectionHandler(con));\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected PreparedStatement prepareStatement(String sql)\n\t\tthrows SQLException {\n\n\t\tPreparedStatement statement =\n\t\t\t_connection.prepareStatement(\n\t\t\t\tsql, ResultSet.TYPE_SCROLL_SENSITIVE,\n\t\t\t\tResultSet.CONCUR_UPDATABLE);\n\n\t\treturn (PreparedStatement) ProxyUtil.newProxyInstance(\n\t\t\tThread.currentThread().getContextClassLoader(),\n\t\t\tnew Class[] { PreparedStatement.class },\n\t\t\tnew UpgradeOptimizedPreparedStatementHandler(statement));\n\t}","id":79048,"modified_method":"protected PreparedStatement prepareStatement(String sql)\n\t\tthrows SQLException {\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader classLoader = currentThread.getContextClassLoader();\n\n\t\tPreparedStatement preparedStatement = _connection.prepareStatement(\n\t\t\tsql, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n\n\t\treturn (PreparedStatement)ProxyUtil.newProxyInstance(\n\t\t\tclassLoader, new Class[] {PreparedStatement.class},\n\t\t\tnew UpgradeOptimizedPreparedStatementHandler(preparedStatement));\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected ResultSet executeQuery() throws SQLException {\n\t\tResultSet resultSet = _statement.executeQuery();\n\n\t\treturn (ResultSet) ProxyUtil.newProxyInstance(\n\t\t\tThread.currentThread().getContextClassLoader(),\n\t\t\tnew Class[] { ResultSet.class },\n\t\t\tnew UpgradeOptimizedResultSetHandler(resultSet));\n\t}","id":79049,"modified_method":"protected ResultSet executeQuery() throws SQLException {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader classLoader = currentThread.getContextClassLoader();\n\n\t\tResultSet resultSet = _preparedStatement.executeQuery();\n\n\t\treturn (ResultSet) ProxyUtil.newProxyInstance(\n\t\t\tclassLoader, new Class[] {ResultSet.class},\n\t\t\tnew UpgradeOptimizedResultSetHandler(resultSet));\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public UpgradeOptimizedPreparedStatementHandler(\n\t\tPreparedStatement statement) {\n\n\t\t_statement = statement;\n\t}","id":79050,"modified_method":"public UpgradeOptimizedPreparedStatementHandler(\n\t\tPreparedStatement preparedStatement) {\n\n\t\t_preparedStatement = preparedStatement;\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object invoke(Object proxy, Method method, Object[] arguments)\n\t\tthrows Throwable {\n\n\t\ttry {\n\t\t\tString methodName = method.getName();\n\n\t\t\tif (methodName.equals(\"executeQuery\")) {\n\t\t\t\treturn executeQuery();\n\t\t\t}\n\n\t\t\treturn method.invoke(_statement, arguments);\n\t\t}\n\t\tcatch (InvocationTargetException ite) {\n\t\t\tthrow ite.getTargetException();\n\t\t}\n\t}","id":79051,"modified_method":"public Object invoke(Object proxy, Method method, Object[] arguments)\n\t\tthrows Throwable {\n\n\t\ttry {\n\t\t\tString methodName = method.getName();\n\n\t\t\tif (methodName.equals(\"executeQuery\")) {\n\t\t\t\treturn executeQuery();\n\t\t\t}\n\n\t\t\treturn method.invoke(_preparedStatement, arguments);\n\t\t}\n\t\tcatch (InvocationTargetException ite) {\n\t\t\tthrow ite.getTargetException();\n\t\t}\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void cacheColumnValues() throws SQLException, UpgradeException {\n\t\t_columnValues.clear();\n\n\t\tif (!_next) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 1; i < _columnNames.size(); ++i) {\n\t\t\tString columnName = _columnNames.get(i);\n\n\t\t\tString lowerCaseColumnName = columnName.toLowerCase();\n\n\t\t\tInteger columnType = _columnTypes.get(lowerCaseColumnName);\n\n\t\t\tObject value = _getValue(columnName, columnType);\n\n\t\t\t_columnValues.put(i, value);\n\n\t\t\t_columnValues.put(lowerCaseColumnName, value);\n\t\t}\n\t}","id":79052,"modified_method":"private void _cacheColumnValues() throws Exception {\n\t\t_columnValues.clear();\n\n\t\tif (!_next) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i = 1; i < _columnNames.size(); ++i) {\n\t\t\tString columnName = _columnNames.get(i);\n\n\t\t\tString lowerCaseColumnName = columnName.toLowerCase();\n\n\t\t\tInteger columnType = _columnTypes.get(lowerCaseColumnName);\n\n\t\t\tObject value = _getValue(columnName, columnType);\n\n\t\t\t_columnValues.put(i, value);\n\n\t\t\t_columnValues.put(lowerCaseColumnName, value);\n\t\t}\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Object _getValue(String name, Integer type)\n\t\tthrows SQLException, UpgradeException {\n\n\t\tObject value = null;\n\n\t\tint t = type.intValue();\n\n\t\tif (t == Types.BIGINT) {\n\t\t\tvalue = GetterUtil.getLong(_resultSet.getLong(name));\n\t\t}\n\t\telse if (t == Types.BIT) {\n\t\t\tvalue = GetterUtil.getBoolean(_resultSet.getBoolean(name));\n\t\t}\n\t\telse if (t == Types.BOOLEAN) {\n\t\t\tvalue = GetterUtil.getBoolean(_resultSet.getBoolean(name));\n\t\t}\n\t\telse if (t == Types.CLOB) {\n\t\t\tvalue = GetterUtil.getString(_resultSet.getString(name));\n\t\t}\n\t\telse if (t == Types.DOUBLE) {\n\t\t\tvalue = GetterUtil.getDouble(_resultSet.getDouble(name));\n\t\t}\n\t\telse if (t == Types.FLOAT) {\n\t\t\tvalue = GetterUtil.getFloat(_resultSet.getFloat(name));\n\t\t}\n\t\telse if (t == Types.INTEGER) {\n\t\t\tvalue = GetterUtil.getInteger(_resultSet.getInt(name));\n\t\t}\n\t\telse if (t == Types.SMALLINT) {\n\t\t\tvalue = GetterUtil.getShort(_resultSet.getShort(name));\n\t\t}\n\t\telse if (t == Types.TIMESTAMP) {\n\t\t\tvalue = _resultSet.getTimestamp(name);\n\t\t}\n\t\telse if (t == Types.VARCHAR) {\n\t\t\tvalue = GetterUtil.getString(_resultSet.getString(name));\n\t\t}\n\t\telse {\n\t\t\tthrow new UpgradeException(\n\t\t\t\t\"Upgrade code using unsupported class type \" + type);\n\t\t}\n\n\t\treturn value;\n\t}","id":79053,"modified_method":"private Object _getValue(String name, Integer type) throws Exception {\n\t\tObject value = null;\n\n\t\tint t = type.intValue();\n\n\t\tif (t == Types.BIGINT) {\n\t\t\tvalue = GetterUtil.getLong(_resultSet.getLong(name));\n\t\t}\n\t\telse if (t == Types.BIT) {\n\t\t\tvalue = GetterUtil.getBoolean(_resultSet.getBoolean(name));\n\t\t}\n\t\telse if (t == Types.BOOLEAN) {\n\t\t\tvalue = GetterUtil.getBoolean(_resultSet.getBoolean(name));\n\t\t}\n\t\telse if (t == Types.CLOB) {\n\t\t\tvalue = GetterUtil.getString(_resultSet.getString(name));\n\t\t}\n\t\telse if (t == Types.DOUBLE) {\n\t\t\tvalue = GetterUtil.getDouble(_resultSet.getDouble(name));\n\t\t}\n\t\telse if (t == Types.FLOAT) {\n\t\t\tvalue = GetterUtil.getFloat(_resultSet.getFloat(name));\n\t\t}\n\t\telse if (t == Types.INTEGER) {\n\t\t\tvalue = GetterUtil.getInteger(_resultSet.getInt(name));\n\t\t}\n\t\telse if (t == Types.SMALLINT) {\n\t\t\tvalue = GetterUtil.getShort(_resultSet.getShort(name));\n\t\t}\n\t\telse if (t == Types.TIMESTAMP) {\n\t\t\tvalue = _resultSet.getTimestamp(name);\n\t\t}\n\t\telse if (t == Types.VARCHAR) {\n\t\t\tvalue = GetterUtil.getString(_resultSet.getString(name));\n\t\t}\n\t\telse {\n\t\t\tthrow new UpgradeException(\n\t\t\t\t\"Upgrade code using unsupported class type \" + type);\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public UpgradeOptimizedResultSetHandler(ResultSet resultSet)\n\t\tthrows SQLException {\n\n\t\t_resultSet = resultSet;\n\n\t\t_columnNames.add(StringPool.BLANK);\n\n\t\tResultSetMetaData metaData = _resultSet.getMetaData();\n\n\t\tint columnCount = metaData.getColumnCount();\n\n\t\tfor (int i = 1; i <= columnCount; i++) {\n\t\t\tint columnType = metaData.getColumnType(i);\n\n\t\t\t_columnTypes.put(i, columnType);\n\n\t\t\tString columnName = metaData.getColumnName(i);\n\n\t\t\t_columnNames.add(columnName);\n\n\t\t\tString lowerCaseColumnName = columnName.toLowerCase();\n\n\t\t\t_columnTypes.put(lowerCaseColumnName, columnType);\n\t\t}\n\t}","id":79054,"modified_method":"public UpgradeOptimizedResultSetHandler(ResultSet resultSet)\n\t\tthrows SQLException {\n\n\t\t_resultSet = resultSet;\n\n\t\t_columnNames.add(StringPool.BLANK);\n\n\t\tResultSetMetaData resultSetMetaData = _resultSet.getMetaData();\n\n\t\tfor (int i = 1; i <= resultSetMetaData.getColumnCount(); i++) {\n\t\t\tint columnType = resultSetMetaData.getColumnType(i);\n\n\t\t\t_columnTypes.put(i, columnType);\n\n\t\t\tString columnName = resultSetMetaData.getColumnName(i);\n\n\t\t\t_columnNames.add(columnName);\n\n\t\t\tString lowerCaseColumnName = columnName.toLowerCase();\n\n\t\t\t_columnTypes.put(lowerCaseColumnName, columnType);\n\t\t}\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object invoke(Object proxy, Method method, Object[] arguments)\n\t\tthrows Throwable {\n\n\t\tString methodName = method.getName();\n\n\t\tif (methodName.equals(\"next\")) {\n\t\t\tif (_resultSet.isBeforeFirst()) {\n\t\t\t\t_next = _resultSet.next();\n\t\t\t}\n\n\t\t\tObject returnValue = _next;\n\n\t\t\tcacheColumnValues();\n\n\t\t\tif (_next) {\n\t\t\t\t_next = _resultSet.next();\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t}\n\t\telse if (methodName.equals(\"close\")) {\n\t\t\t_resultSet.close();\n\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tObject column = arguments[0];\n\n\t\t\tif (column instanceof String) {\n\t\t\t\tcolumn = ((String) column).toLowerCase();\n\t\t\t}\n\n\t\t\tif (column instanceof String) {\n\t\t\t\tcolumn = ((String) column).toLowerCase();\n\t\t\t}\n\n\t\t\treturn _columnValues.get(column);\n\t\t}\n\t}","id":79055,"modified_method":"public Object invoke(Object proxy, Method method, Object[] arguments)\n\t\tthrows Throwable {\n\n\t\tString methodName = method.getName();\n\n\t\tif (methodName.equals(\"close\")) {\n\t\t\t_resultSet.close();\n\n\t\t\treturn null;\n\t\t}\n\t\telse if (methodName.equals(\"next\")) {\n\t\t\tif (_resultSet.isBeforeFirst()) {\n\t\t\t\t_next = _resultSet.next();\n\t\t\t}\n\n\t\t\tObject returnValue = _next;\n\n\t\t\t_cacheColumnValues();\n\n\t\t\tif (_next) {\n\t\t\t\t_next = _resultSet.next();\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t}\n\t\telse {\n\t\t\tObject column = arguments[0];\n\n\t\t\tif (column instanceof String) {\n\t\t\t\tString columnString = (String)column;\n\n\t\t\t\tcolumn = columnString.toLowerCase();\n\t\t\t}\n\n\t\t\treturn _columnValues.get(column);\n\t\t}\n\t}","commit_id":"494da4937ab592e9c6cf43389612f9884fd4a183","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ContextClassLoaderResourceRetriever(String fileName) {\n\t\tClassLoader contextClassLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\t_inputStream = contextClassLoader.getResourceAsStream(fileName);\n\t}","id":79056,"modified_method":"public ContextClassLoaderResourceRetriever(String fileName) {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\t_inputStream = contextClassLoader.getResourceAsStream(fileName);\n\t}","commit_id":"d4b03954ec9400c86ac8a832158e8d05a26abc27","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected ClassLoader getClassLoader() {\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\tClassLoader contextClassLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\treturn AggregateClassLoader.getAggregateClassLoader(\n\t\t\tclassLoader, contextClassLoader);\n\t}","id":79057,"modified_method":"protected ClassLoader getClassLoader() {\n\t\tClass<?> clazz = getClass();\n\n\t\tClassLoader classLoader = clazz.getClassLoader();\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\treturn AggregateClassLoader.getAggregateClassLoader(\n\t\t\tclassLoader, contextClassLoader);\n\t}","commit_id":"8f4aa6d47820e8580968947c8d570dad345a0cf1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ScriptingExecutor getScriptingExecutor() {\n\t\tGroovyExecutor groovyExecutor = new GroovyExecutor();\n\n\t\treturn groovyExecutor;\n\t}","id":79058,"modified_method":"@Override\n\tpublic ScriptingExecutor getScriptingExecutor() {\n\t\treturn new GroovyExecutor();\n\t}","commit_id":"8f4aa6d47820e8580968947c8d570dad345a0cf1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object doInvoke(Object proxy, Method method, Object[] args)\n\t\tthrows Exception {\n\n\t\tClassLoader classLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\tString methodName = method.getName();\n\n\t\tURL bindingURL = (URL)args[0];\n\n\t\tint x = methodName.indexOf(\"_v2_\") + 4;\n\t\tint y = methodName.lastIndexOf(\"_Service\");\n\n\t\tString serviceName = methodName.substring(x, y);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(_OASIS_PACKAGE);\n\t\tsb.append(_version);\n\t\tsb.append(\".bind.WSRP_\");\n\t\tsb.append(_version);\n\t\tsb.append(StringPool.UNDERLINE) ;\n\t\tsb.append(serviceName);\n\t\tsb.append(\"_Binding_SOAPStub\");\n\n\t\tClass<?> clazz = classLoader.loadClass(sb.toString());\n\n\t\targs = new Object[] {bindingURL, getService()};\n\n\t\tObject stub = ConstructorUtils.invokeConstructor(clazz, args);\n\n\t\tsb = new StringBundler(5);\n\n\t\tsb.append(\"getWSRP_\");\n\t\tsb.append(_version);\n\t\tsb.append(StringPool.UNDERLINE);\n\t\tsb.append(serviceName);\n\t\tsb.append(\"_ServiceWSDDServiceName\");\n\n\t\tObject serviceWSDDServiceName = MethodUtils.invokeMethod(\n\t\t\t_serviceLocator, sb.toString(), null);\n\n\t\tMethodUtils.invokeMethod(stub, \"setPortName\", serviceWSDDServiceName);\n\n\t\tif (_v2) {\n\t\t\treturn stub;\n\t\t}\n\t\telse {\n\t\t\tsb = new StringBundler(4);\n\n\t\t\tsb.append(_OASIS_PACKAGE);\n\t\t\tsb.append(\"v2.intf.WSRP_v2_\");\n\t\t\tsb.append(serviceName);\n\t\t\tsb.append(\"_PortType\");\n\n\t\t\tClass<?> proxyInterface = classLoader.loadClass(sb.toString());\n\n\t\t\tsb = new StringBundler(3);\n\n\t\t\tsb.append(_WSRP_PROXY_PACKAGE);\n\t\t\tsb.append(serviceName);\n\t\t\tsb.append(\"ServiceHandler\");\n\n\t\t\tclazz = classLoader.loadClass(sb.toString());\n\n\t\t\tInvocationHandler invocationHandler =\n\t\t\t\t(InvocationHandler)ConstructorUtils.invokeConstructor(\n\t\t\t\t\tclazz, stub);\n\n\t\t\treturn Proxy.newProxyInstance(\n\t\t\t\tServiceHandler.class.getClassLoader(),\n\t\t\t\tnew Class[] {proxyInterface}, invocationHandler);\n\t\t}\n\t}","id":79059,"modified_method":"public Object doInvoke(Object proxy, Method method, Object[] args)\n\t\tthrows Exception {\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\tString methodName = method.getName();\n\n\t\tURL bindingURL = (URL)args[0];\n\n\t\tint x = methodName.indexOf(\"_v2_\") + 4;\n\t\tint y = methodName.lastIndexOf(\"_Service\");\n\n\t\tString serviceName = methodName.substring(x, y);\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(_OASIS_PACKAGE);\n\t\tsb.append(_version);\n\t\tsb.append(\".bind.WSRP_\");\n\t\tsb.append(_version);\n\t\tsb.append(StringPool.UNDERLINE) ;\n\t\tsb.append(serviceName);\n\t\tsb.append(\"_Binding_SOAPStub\");\n\n\t\tClass<?> clazz = contextClassLoader.loadClass(sb.toString());\n\n\t\targs = new Object[] {bindingURL, getService()};\n\n\t\tObject stub = ConstructorUtils.invokeConstructor(clazz, args);\n\n\t\tsb = new StringBundler(5);\n\n\t\tsb.append(\"getWSRP_\");\n\t\tsb.append(_version);\n\t\tsb.append(StringPool.UNDERLINE);\n\t\tsb.append(serviceName);\n\t\tsb.append(\"_ServiceWSDDServiceName\");\n\n\t\tObject serviceWSDDServiceName = MethodUtils.invokeMethod(\n\t\t\t_serviceLocator, sb.toString(), null);\n\n\t\tMethodUtils.invokeMethod(stub, \"setPortName\", serviceWSDDServiceName);\n\n\t\tif (_v2) {\n\t\t\treturn stub;\n\t\t}\n\n\t\tsb.setIndex(0);\n\n\t\tsb.append(_OASIS_PACKAGE);\n\t\tsb.append(\"v2.intf.WSRP_v2_\");\n\t\tsb.append(serviceName);\n\t\tsb.append(\"_PortType\");\n\n\t\tClass<?> proxyInterface = contextClassLoader.loadClass(sb.toString());\n\n\t\tsb.setIndex(0);\n\n\t\tsb.append(_WSRP_PROXY_PACKAGE);\n\t\tsb.append(serviceName);\n\t\tsb.append(\"ServiceHandler\");\n\n\t\tclazz = contextClassLoader.loadClass(sb.toString());\n\n\t\tInvocationHandler invocationHandler =\n\t\t\t(InvocationHandler)ConstructorUtils.invokeConstructor(\n\t\t\t\tclazz, stub);\n\n\t\treturn Proxy.newProxyInstance(\n\t\t\tServiceHandler.class.getClassLoader(), new Class[] {proxyInterface},\n\t\t\tinvocationHandler);\n\t}","commit_id":"e01fe5fb406dcdcdd09f8a6d5fcb0f624327c341","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public WSRPConsumer updateWSRPConsumer(\n\t\t\tlong wsrpConsumerId, String adminPortletId, String name, String url,\n\t\t\tString forwardCookies, String userToken)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(name);\n\n\t\tWSRPConsumerManagerFactory.destroyWSRPConsumerManager(url);\n\n\t\tWSRPConsumer wsrpConsumer = wsrpConsumerPersistence.findByPrimaryKey(\n\t\t\twsrpConsumerId);\n\n\t\twsrpConsumer.setModifiedDate(new Date());\n\t\twsrpConsumer.setName(name);\n\t\twsrpConsumer.setUrl(url);\n\n\t\t// Must set forward cookies first so that WSRPConsumerManagerFactory\n\t\t// has access to them\n\n\t\twsrpConsumer.setForwardCookies(forwardCookies);\n\t\twsrpConsumer.setWsdl(getWSDL(wsrpConsumer, userToken));\n\n\t\twsrpConsumerPersistence.update(wsrpConsumer, false);\n\n\t\treturn wsrpConsumer;\n\t}","id":79060,"modified_method":"public WSRPConsumer updateWSRPConsumer(\n\t\t\tlong wsrpConsumerId, String adminPortletId, String name, String url,\n\t\t\tString forwardCookies, String userToken)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(name);\n\n\t\tWSRPConsumerManagerFactory.destroyWSRPConsumerManager(url);\n\n\t\tWSRPConsumer wsrpConsumer = wsrpConsumerPersistence.findByPrimaryKey(\n\t\t\twsrpConsumerId);\n\n\t\twsrpConsumer.setModifiedDate(new Date());\n\t\twsrpConsumer.setName(name);\n\t\twsrpConsumer.setUrl(url);\n\t\twsrpConsumer.setWsdl(getWSDL(wsrpConsumer, forwardCookies, userToken));\n\n\t\twsrpConsumerPersistence.update(wsrpConsumer, false);\n\n\t\treturn wsrpConsumer;\n\t}","commit_id":"e01fe5fb406dcdcdd09f8a6d5fcb0f624327c341","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getWSDL(WSRPConsumer wsrpConsumer, String userToken)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tWSRPConsumerManager wsrpConsumerManager =\n\t\t\t\tWSRPConsumerManagerFactory.getWSRPConsumerManager(\n\t\t\t\t\twsrpConsumer, userToken);\n\n\t\t\treturn wsrpConsumerManager.getWsdl();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WSRPConsumerWSDLException(e);\n\t\t}\n\t}","id":79061,"modified_method":"protected String getWSDL(\n\t\t\tWSRPConsumer wsrpConsumer, String forwardCookies, String userToken)\n\t\tthrows PortalException {\n\n\t\ttry {\n\n\t\t\t// Must set forward cookies first so that WSRPConsumerManagerFactory\n\t\t\t// has access to them\n\n\t\t\twsrpConsumer.setForwardCookies(forwardCookies);\n\n\t\t\tWSRPConsumerManager wsrpConsumerManager =\n\t\t\t\tWSRPConsumerManagerFactory.getWSRPConsumerManager(\n\t\t\t\t\twsrpConsumer, userToken);\n\n\t\t\treturn wsrpConsumerManager.getWsdl();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WSRPConsumerWSDLException(e);\n\t\t}\n\t}","commit_id":"e01fe5fb406dcdcdd09f8a6d5fcb0f624327c341","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public WSRPConsumer addWSRPConsumer(\n\t\t\tlong companyId, String adminPortletId, String name, String url,\n\t\t\tString forwardCookies, String userToken,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tlong wsrpConsumerId = CounterLocalServiceUtil.increment();\n\n\t\tWSRPConsumer wsrpConsumer = wsrpConsumerPersistence.create(\n\t\t\twsrpConsumerId);\n\n\t\twsrpConsumer.setUuid(serviceContext.getUuid());\n\t\twsrpConsumer.setCompanyId(companyId);\n\t\twsrpConsumer.setCreateDate(now);\n\t\twsrpConsumer.setModifiedDate(now);\n\t\twsrpConsumer.setName(name);\n\t\twsrpConsumer.setUrl(url);\n\n\t\t// Must set forward cookies first so that WSRPConsumerManagerFactory\n\t\t// has access to them\n\n\t\twsrpConsumer.setForwardCookies(forwardCookies);\n\t\twsrpConsumer.setWsdl(getWSDL(wsrpConsumer, userToken));\n\n\t\twsrpConsumerPersistence.update(wsrpConsumer, false);\n\n\t\treturn wsrpConsumer;\n\t}","id":79062,"modified_method":"public WSRPConsumer addWSRPConsumer(\n\t\t\tlong companyId, String adminPortletId, String name, String url,\n\t\t\tString forwardCookies, String userToken,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tlong wsrpConsumerId = CounterLocalServiceUtil.increment();\n\n\t\tWSRPConsumer wsrpConsumer = wsrpConsumerPersistence.create(\n\t\t\twsrpConsumerId);\n\n\t\twsrpConsumer.setUuid(serviceContext.getUuid());\n\t\twsrpConsumer.setCompanyId(companyId);\n\t\twsrpConsumer.setCreateDate(now);\n\t\twsrpConsumer.setModifiedDate(now);\n\t\twsrpConsumer.setName(name);\n\t\twsrpConsumer.setUrl(url);\n\t\twsrpConsumer.setWsdl(getWSDL(wsrpConsumer, forwardCookies, userToken));\n\n\t\twsrpConsumerPersistence.update(wsrpConsumer, false);\n\n\t\treturn wsrpConsumer;\n\t}","commit_id":"e01fe5fb406dcdcdd09f8a6d5fcb0f624327c341","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private SystemProperties() {\n\t\tProperties p = new Properties();\n\n\t\tClassLoader classLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\t// system.properties\n\n\t\ttry {\n\t\t\tURL url = classLoader.getResource(\"system.properties\");\n\n\t\t\tif (url != null) {\n\t\t\t\tInputStream is = url.openStream();\n\n\t\t\t\tp.load(is);\n\n\t\t\t\tis.close();\n\n\t\t\t\tSystem.out.println(\"Loading \" + url);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// system-ext.properties\n\n\t\ttry {\n\t\t\tURL url = classLoader.getResource(\"system-ext.properties\");\n\n\t\t\tif (url != null) {\n\t\t\t\tInputStream is = url.openStream();\n\n\t\t\t\tp.load(is);\n\n\t\t\t\tis.close();\n\n\t\t\t\tSystem.out.println(\"Loading \" + url);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Set environment properties\n\n\t\tSystemEnv.setProperties(p);\n\n\t\t// Set system properties\n\n\t\tboolean systemPropertiesLoad = GetterUtil.getBoolean(\n\t\t\tSystem.getProperty(SYSTEM_PROPERTIES_LOAD), true);\n\n\t\tboolean systemPropertiesFinal = GetterUtil.getBoolean(\n\t\t\tSystem.getProperty(SYSTEM_PROPERTIES_FINAL), true);\n\n\t\tif (systemPropertiesLoad) {\n\t\t\tEnumeration<String> enu = (Enumeration<String>)p.propertyNames();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString key = enu.nextElement();\n\n\t\t\t\tif (systemPropertiesFinal ||\n\t\t\t\t\tValidator.isNull(System.getProperty(key))) {\n\n\t\t\t\t\tSystem.setProperty(key, p.getProperty(key));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_props = new ConcurrentHashMap<String, String>();\n\n\t\t// Use a fast concurrent hash map implementation instead of the slower\n\t\t// java.util.Properties\n\n\t\tPropertiesUtil.fromProperties(p, _props);\n\t}","id":79063,"modified_method":"private SystemProperties() {\n\t\tProperties properties = new Properties();\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader classLoader = currentThread.getContextClassLoader();\n\n\t\t// system.properties\n\n\t\ttry {\n\t\t\tURL url = classLoader.getResource(\"system.properties\");\n\n\t\t\tif (url != null) {\n\t\t\t\tInputStream inputStream = url.openStream();\n\n\t\t\t\tproperties.load(inputStream);\n\n\t\t\t\tinputStream.close();\n\n\t\t\t\tSystem.out.println(\"Loading \" + url);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// system-ext.properties\n\n\t\ttry {\n\t\t\tURL url = classLoader.getResource(\"system-ext.properties\");\n\n\t\t\tif (url != null) {\n\t\t\t\tInputStream inputStream = url.openStream();\n\n\t\t\t\tproperties.load(inputStream);\n\n\t\t\t\tinputStream.close();\n\n\t\t\t\tSystem.out.println(\"Loading \" + url);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Set environment properties\n\n\t\tSystemEnv.setProperties(properties);\n\n\t\t// Set system properties\n\n\t\tboolean systemPropertiesLoad = GetterUtil.getBoolean(\n\t\t\tSystem.getProperty(SYSTEM_PROPERTIES_LOAD), true);\n\n\t\tboolean systemPropertiesFinal = GetterUtil.getBoolean(\n\t\t\tSystem.getProperty(SYSTEM_PROPERTIES_FINAL), true);\n\n\t\tif (systemPropertiesLoad) {\n\t\t\tEnumeration<String> enu =\n\t\t\t\t(Enumeration<String>)properties.propertyNames();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString key = enu.nextElement();\n\n\t\t\t\tif (systemPropertiesFinal ||\n\t\t\t\t\tValidator.isNull(System.getProperty(key))) {\n\n\t\t\t\t\tSystem.setProperty(key, properties.getProperty(key));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_properties = new ConcurrentHashMap<String, String>();\n\n\t\t// Use a fast concurrent hash map implementation instead of the slower\n\t\t// java.util.Properties\n\n\t\tPropertiesUtil.fromProperties(properties, _properties);\n\t}","commit_id":"564a57c6065826a9feea93d4b0e3a7aa567c83d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void set(String key, String value) {\n\t\tSystem.setProperty(key, value);\n\n\t\t_instance._props.put(key, value);\n\t}","id":79064,"modified_method":"public static void set(String key, String value) {\n\t\tSystem.setProperty(key, value);\n\n\t\t_instance._properties.put(key, value);\n\t}","commit_id":"564a57c6065826a9feea93d4b0e3a7aa567c83d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String get(String key) {\n\t\tString value = _instance._props.get(key);\n\n\t\tif (value == null) {\n\t\t\tvalue = System.getProperty(key);\n\t\t}\n\n\t\treturn value;\n\t}","id":79065,"modified_method":"public static String get(String key) {\n\t\tString value = _instance._properties.get(key);\n\n\t\tif (value == null) {\n\t\t\tvalue = System.getProperty(key);\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"564a57c6065826a9feea93d4b0e3a7aa567c83d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Properties getProperties() {\n\t\treturn PropertiesUtil.fromMap(_instance._props);\n\t}","id":79066,"modified_method":"public static Properties getProperties() {\n\t\treturn PropertiesUtil.fromMap(_instance._properties);\n\t}","commit_id":"564a57c6065826a9feea93d4b0e3a7aa567c83d1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Thread[] getThreads() {\n\t\tThreadGroup threadGroup = Thread.currentThread( ).getThreadGroup( );\n\n\t\twhile (threadGroup.getParent() != null) {\n\t\t\tthreadGroup = threadGroup.getParent();\n\t\t}\n\n\t\tint threadCountGuess = threadGroup.activeCount();\n\n\t\tThread[] threads = new Thread[threadCountGuess];\n\n\t\tint threadCountActual = threadGroup.enumerate(threads);\n\n\t\twhile (threadCountActual == threadCountGuess) {\n\t\t\tthreadCountGuess *= 2;\n\n\t\t\tthreads = new Thread[threadCountGuess];\n\n\t\t\tthreadCountActual = threadGroup.enumerate(threads);\n\t\t}\n\n\t\treturn threads;\n\n\t}","id":79067,"modified_method":"private static Thread[] _getThreads() {\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tThreadGroup threadGroup = currentThread.getThreadGroup( );\n\n\t\twhile (threadGroup.getParent() != null) {\n\t\t\tthreadGroup = threadGroup.getParent();\n\t\t}\n\n\t\tint threadCountGuess = threadGroup.activeCount();\n\n\t\tThread[] threads = new Thread[threadCountGuess];\n\n\t\tint threadCountActual = threadGroup.enumerate(threads);\n\n\t\twhile (threadCountActual == threadCountGuess) {\n\t\t\tthreadCountGuess *= 2;\n\n\t\t\tthreads = new Thread[threadCountGuess];\n\n\t\t\tthreadCountActual = threadGroup.enumerate(threads);\n\t\t}\n\n\t\treturn threads;\n\t}","commit_id":"a7e14f0e2b7af66356de4c8cfef9aa71ce51c615","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void clearThreadLocal() throws Exception {\n\t\tif (!_isInitialized) {\n\t\t\tinitial();\n\t\t}\n\n\t\tThread[] threads = getThreads();\n\n\t\tClassLoader classLoader =\n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\tfor (Thread thread : threads) {\n\t\t\tdoClearThreadLocal(thread, classLoader);\n\t\t}\n\t}","id":79068,"modified_method":"public static void clearThreadLocal() throws Exception {\n\t\t_init();\n\n\t\tThread[] threads = _getThreads();\n\n\t\tThread currentThread = Thread.currentThread();\n\n\t\tClassLoader contextClassLoader = currentThread.getContextClassLoader();\n\n\t\tfor (Thread thread : threads) {\n\t\t\t_clearThreadLocal(thread, contextClassLoader);\n\t\t}\n\t}","commit_id":"a7e14f0e2b7af66356de4c8cfef9aa71ce51c615","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void doClearThreadLocalMap(\n\t\tObject threadLocalMap, ClassLoader classLoader) throws Exception {\n\n\t\tif (threadLocalMap == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject[] table = (Object[])_tableField.get(threadLocalMap);\n\n\t\tif (table == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint staleEntriesCount = 0;\n\n\t\tfor(Object tableEntry : table) {\n\t\t\tif (tableEntry == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean remove = false;\n\n\t\t\tObject key = ((Reference<?>)tableEntry).get();\n\n\t\t\tObject value = _tableValueField.get(tableEntry);\n\n\t\t\tif (key != null && key.getClass().getClassLoader() == classLoader) {\n\t\t\t\tremove = true;\n\t\t\t}\n\n\t\t\tif (value != null &&\n\t\t\t\tvalue.getClass().getClassLoader() == classLoader) {\n\n\t\t\t\tremove = true;\n\t\t\t}\n\n\t\t\tif (remove) {\n\t\t\t\tif (key != null) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Clear a ThreadLocal with key of type \" +\n\t\t\t\t\t\t\tkey.getClass().getCanonicalName());\n\t\t\t\t\t}\n\t\t\t\t\t_removeMethod.invoke(threadLocalMap, key);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstaleEntriesCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (staleEntriesCount > 0) {\n\t\t\t_expungeStaleEntriesMethod.invoke(threadLocalMap);\n\t\t}\n\t}","id":79069,"modified_method":"private static void _clearThreadLocalMap(\n\t\t\tObject threadLocalMap, ClassLoader classLoader)\n\t\tthrows Exception {\n\n\t\tif (threadLocalMap == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject[] table = (Object[])_tableField.get(threadLocalMap);\n\n\t\tif (table == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tint staleEntriesCount = 0;\n\n\t\tfor (Object tableEntry : table) {\n\t\t\tif (tableEntry == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObject key = ((Reference<?>)tableEntry).get();\n\t\t\tObject value = _tableValueField.get(tableEntry);\n\n\t\t\tboolean remove = false;\n\n\t\t\tif (key != null) {\n\t\t\t\tClass<?> keyClass = key.getClass();\n\n\t\t\t\tClassLoader keyClassLoader = keyClass.getClassLoader();\n\n\t\t\t\tif (keyClassLoader == classLoader) {\n\t\t\t\t\tremove = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tClass<?> valueClass = value.getClass();\n\n\t\t\t\tClassLoader valueClassLoader = valueClass.getClassLoader();\n\n\t\t\t\tif (valueClassLoader == classLoader) {\n\t\t\t\t\tremove = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (remove) {\n\t\t\t\tif (key != null) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\tClass<?> keyClass = key.getClass();\n\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Clear a ThreadLocal with key of type \" +\n\t\t\t\t\t\t\t\tkeyClass.getCanonicalName());\n\t\t\t\t\t}\n\n\t\t\t\t\t_removeMethod.invoke(threadLocalMap, key);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstaleEntriesCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (staleEntriesCount > 0) {\n\t\t\t_expungeStaleEntriesMethod.invoke(threadLocalMap);\n\t\t}\n\t}","commit_id":"a7e14f0e2b7af66356de4c8cfef9aa71ce51c615","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void doClearThreadLocal(\n\t\tThread thread, ClassLoader classLoader) throws Exception {\n\n\t\tif (thread == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject threadLocalMap = _threadLocalsField.get(thread);\n\n\t\tObject inheritableThreadLocalMap =\n\t\t\t_inheritableThreadLocalsField.get(thread);\n\n\t\tdoClearThreadLocalMap(threadLocalMap, classLoader);\n\n\t\tdoClearThreadLocalMap(inheritableThreadLocalMap, classLoader);\n\t}","id":79070,"modified_method":"private static void _clearThreadLocal(\n\t\t\tThread thread, ClassLoader classLoader)\n\t\tthrows Exception {\n\n\t\tif (thread == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject threadLocalMap = _threadLocalsField.get(thread);\n\n\t\tObject inheritableThreadLocalMap = _inheritableThreadLocalsField.get(\n\t\t\tthread);\n\n\t\t_clearThreadLocalMap(threadLocalMap, classLoader);\n\t\t_clearThreadLocalMap(inheritableThreadLocalMap, classLoader);\n\t}","commit_id":"a7e14f0e2b7af66356de4c8cfef9aa71ce51c615","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public HistoryPageFilter getHistoryPageFilter() {\n        final HistoryPageFilter<T> historyPageFilter = newPageFilter();\n\n        List<T> items = new LinkedList<T>();\n\n        items.addAll((Collection<? extends T>) getQueuedItems());\n        items.addAll(IteratorUtils.toList(baseList.iterator()));\n        historyPageFilter.add(items);\n        historyPageFilter.widget = this;\n\n        return historyPageFilter;\n    }","id":79071,"modified_method":"@Override\n    public HistoryPageFilter getHistoryPageFilter() {\n        final HistoryPageFilter<T> historyPageFilter = newPageFilter();\n\n        historyPageFilter.add(baseList, getQueuedItems());\n        historyPageFilter.widget = this;\n\n        return historyPageFilter;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void addQueueItem(Queue.Item item) {\n        HistoryPageEntry entry = new HistoryPageEntry(item);\n        queueItems.add(entry);\n        updateNewestOldest(entry.getEntryId());\n    }","id":79072,"modified_method":"private void addQueueItem(Queue.Item item) {\n        HistoryPageEntry<Queue.Item> entry = new HistoryPageEntry<>(item);\n        queueItems.add(entry);\n        updateNewestOldest(entry.getEntryId());\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Add build items to the History page.\n     *\n     * @param items The items to be added. Assumes the list of items are in descending queue ID order i.e. newest first.\n     */\n    public void add(@Nonnull List<T> items) {\n        if (items.isEmpty()) {\n            return;\n        }\n\n        sort(items);\n\n        nextBuildNumber = getNextBuildNumber(items.get(0));\n\n        if (newerThan == null && olderThan == null) {\n            // Just return the first page of entries (newest)\n            for (T item : items) {\n                add(item);\n                if (isFull()) {\n                    break;\n                }\n            }\n            hasDownPage = (items.size() > maxEntries);\n        } else if (newerThan != null) {\n            int toFillCount = getFillCount();\n            if (toFillCount > 0) {\n                // Locate the point in the items list where the 'newerThan' build item is. Once located,\n                // add a max of 'getFillCount' build items before that build item.\n                long newestInList = HistoryPageEntry.getEntryId(items.get(0));\n                long oldestInList = HistoryPageEntry.getEntryId(items.get(items.size() - 1));\n                int newerThanIdx = -1;\n\n                if (newerThan > newestInList) {\n                    // Nothing newer\n                } else if (newerThan >= oldestInList) {\n                    // newerThan is within the range of items in the item list.\n                    // go through the list and locate the cut-off point.\n                    for (int i = 0; i < items.size(); i++) {\n                        T item = items.get(i);\n                        if (HistoryPageEntry.getEntryId(item) <= newerThan) {\n                            newerThanIdx = i;\n                            break;\n                        }\n                    }\n                } else if (newerThan < oldestInList) {\n                    newerThanIdx = items.size();\n                }\n\n                if (newerThanIdx != -1) {\n                    if (newerThanIdx <= maxEntries) {\n                        // If there's less than a full page of items newer than \"newerThan\", then it's ok to\n                        // fill the page with items older than \"newerThan\".\n                        int itemCountToAdd = Math.min(toFillCount, items.size());\n                        for (int i = 0; i < itemCountToAdd; i++) {\n                            add(items.get(i));\n                        }\n                    } else {\n                        // There's more than a full page of items newer than \"newerThan\".\n                        for (int i = (newerThanIdx - toFillCount); i < newerThanIdx; i++) {\n                            add(items.get(i));\n                        }\n                        hasUpPage = true;\n                    }\n                    // if there are items after the \"newerThan\" item, then we\n                    // can page down.\n                    hasDownPage = (items.size() > newerThanIdx + 1);\n                } else {\n                    // All builds are older than newerThan ?\n                    hasDownPage = true;\n                }\n            }\n        } else if (olderThan != null) {\n            for (int i = 0; i < items.size(); i++) {\n                T item = items.get(i);\n                if (HistoryPageEntry.getEntryId(item) >= olderThan) {\n                    hasUpPage = true;\n                } else {\n                    add(item);\n                    if (isFull()) {\n                        // This page is full but there may be more builds older\n                        // than the oldest on this page.\n                        hasDownPage = (i + 1 < items.size());\n                        break;\n                    }\n                }\n            }\n        }\n    }","id":79073,"modified_method":"/**\n     * Add build items to the History page.\n     *\n     * @param runItems The items to be added. Assumes the items are in descending queue ID order i.e. newest first.\n     * @deprecated Replaced by add(Iterable&lt;T&gt;) as of version 2.15\n     */\n    @Deprecated\n    public void add(@Nonnull List<T> runItems) {\n        addInternal(runItems);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private long getNextBuildNumber(@Nonnull T entry) {\n        if (entry instanceof Queue.Item) {\n            Queue.Task task = ((Queue.Item) entry).task;\n            if (task instanceof Job) {\n                return ((Job) task).getNextBuildNumber();\n            }\n        } else if (entry instanceof Run) {\n            return ((Run) entry).getParent().getNextBuildNumber();\n        }\n\n        // TODO maybe this should be an error?\n        return HistoryPageEntry.getEntryId(entry) + 1;\n    }","id":79074,"modified_method":"private long getNextBuildNumber(@Nonnull Object entry) {\n        if (entry instanceof Queue.Item) {\n            Queue.Task task = ((Queue.Item) entry).task;\n            if (task instanceof Job) {\n                return ((Job) task).getNextBuildNumber();\n            }\n        } else if (entry instanceof Run) {\n            return ((Run) entry).getParent().getNextBuildNumber();\n        }\n\n        // TODO maybe this should be an error?\n        return HistoryPageEntry.getEntryId(entry) + 1;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void addRun(Run run) {\n        HistoryPageEntry entry = new HistoryPageEntry(run);\n        runs.add(entry);\n        updateNewestOldest(entry.getEntryId());\n    }","id":79075,"modified_method":"private void addRun(Run run) {\n        HistoryPageEntry<Run> entry = new HistoryPageEntry<>(run);\n        // Assert that runs have been added in descending order\n        if (runs.size() > 0) {\n            if (entry.getEntryId() > runs.get(runs.size() - 1).getEntryId()) {\n                throw new IllegalStateException(\"Runs were out of order\");\n            }\n        }\n        runs.add(entry);\n        updateNewestOldest(entry.getEntryId());\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test olderThan (page down) when set to an id close to the oldest in the list (where\n     * there's less than a full page older than the supplied olderThan arg).\n     */\n    @Test\n    public void test_olderThan_leaving_part_page() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n\n        // Should only be 3 runs on the page (oldest 3)\n        Assert.assertEquals(3, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(3), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);\n    }","id":79076,"modified_method":"/**\n     * Test olderThan (page down) when set to an id close to the oldest in the list (where\n     * there's less than a full page older than the supplied olderThan arg).\n     */\n    @Test\n    public void test_olderThan_leaving_part_page() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n\n        // Should only be 3 runs on the page (oldest 3)\n        Assert.assertEquals(3, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(3), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private List<ModelObject> newRuns(long startId, long endId) throws IOException {\n        List<ModelObject> runs = new ArrayList<ModelObject>();\n        for (long queueId = startId; queueId <= endId; queueId++) {\n            runs.add(new MockRun(queueId));\n        }\n        return runs;\n    }","id":79077,"modified_method":"private List<ModelObject> newRuns(long startId, long endId) throws IOException {\n        // Runs should be in reverse order, newest first.\n        List<ModelObject> runs = new ArrayList<>();\n        for (long queueId = endId; queueId >= startId; queueId--) {\n            runs.add(new MockRun(queueId));\n        }\n        return runs;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test newerThan (page up) when set to id greater than newest (should never happen). Should be an empty list.\n     */\n    @Test\n    public void test_newerThan_gt_newest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 11L, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(0, historyPageFilter.runs.size());\n    }","id":79078,"modified_method":"/**\n     * Test newerThan (page up) when set to id greater than newest (should never happen). Should be an empty list.\n     */\n    @Test\n    public void test_newerThan_gt_newest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 11L, null);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(0, historyPageFilter.runs.size());\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * No items.\n     */\n    @Test\n    public void test_latest_empty_page() {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        historyPageFilter.add(itemList);\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(true, historyPageFilter.queueItems.isEmpty());\n        Assert.assertEquals(true, historyPageFilter.runs.isEmpty());\n    }","id":79079,"modified_method":"/**\n     * No items.\n     */\n    @Test\n    public void test_latest_empty_page() {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null);\n        List<ModelObject> itemList = new ArrayList<>();\n\n        historyPageFilter.add(itemList);\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(true, historyPageFilter.queueItems.isEmpty());\n        Assert.assertEquals(true, historyPageFilter.runs.isEmpty());\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private HistoryPageFilter<ModelObject> newPage(int maxEntries, Long newerThan, Long olderThan) {\n        HistoryPageFilter<ModelObject> pageFilter = new HistoryPageFilter<ModelObject>(maxEntries);\n        if (newerThan != null) {\n            pageFilter.setNewerThan(HistoryPageEntry.getEntryId(newerThan));\n        } else if (olderThan != null) {\n            pageFilter.setOlderThan(HistoryPageEntry.getEntryId(olderThan));\n        }\n        return pageFilter;\n    }","id":79080,"modified_method":"private HistoryPageFilter<ModelObject> newPage(int maxEntries, Long newerThan, Long olderThan) {\n        HistoryPageFilter<ModelObject> pageFilter = new HistoryPageFilter<>(maxEntries);\n        if (newerThan != null) {\n            pageFilter.setNewerThan(HistoryPageEntry.getEntryId(newerThan));\n        } else if (olderThan != null) {\n            pageFilter.setOlderThan(HistoryPageEntry.getEntryId(olderThan));\n        }\n        return pageFilter;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Latest/top page where total number of items less than the max page size.\n     */\n    @Test\n    public void test_latest_partial_page() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 2));\n        itemList.addAll(newQueueItems(3, 4));\n\n        // want to make sure the list items are ordered by id in descending order\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), HistoryPageEntry.getEntryId(itemList.get(0)));\n        historyPageFilter.add(itemList);\n        Assert.assertEquals(4, HistoryPageEntry.getEntryId(itemList.get(0)));\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(2, historyPageFilter.queueItems.size());\n        Assert.assertEquals(2, historyPageFilter.runs.size());\n\n        Assert.assertEquals(4, historyPageFilter.queueItems.get(0).getEntryId());\n        Assert.assertEquals(4, historyPageFilter.newestOnPage);\n        Assert.assertEquals(3, historyPageFilter.queueItems.get(1).getEntryId());\n        Assert.assertEquals(HistoryPageEntry.getEntryId(2), historyPageFilter.runs.get(0).getEntryId());\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.runs.get(1).getEntryId());\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);\n    }","id":79081,"modified_method":"/**\n     * Latest/top page where total number of items less than the max page size.\n     */\n    @Test\n    public void test_latest_partial_page() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null);\n        List<ModelObject> runs = newRuns(1, 2);\n        List<Queue.Item> queueItems = newQueueItems(3, 4);\n\n        historyPageFilter.add(runs, queueItems);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(2, historyPageFilter.queueItems.size());\n        Assert.assertEquals(2, historyPageFilter.runs.size());\n\n        Assert.assertEquals(4, historyPageFilter.queueItems.get(0).getEntryId());\n        Assert.assertEquals(4, historyPageFilter.newestOnPage);\n        Assert.assertEquals(3, historyPageFilter.queueItems.get(1).getEntryId());\n        Assert.assertEquals(HistoryPageEntry.getEntryId(2), historyPageFilter.runs.get(0).getEntryId());\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.runs.get(1).getEntryId());\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private List<ModelObject> newQueueItems(long startId, long endId) {\n        List<ModelObject> items = new ArrayList<ModelObject>();\n        for (long queueId = startId; queueId <= endId; queueId++) {\n            items.add(new MockItem(queueId));\n        }\n        return items;\n    }","id":79082,"modified_method":"private List<Queue.Item> newQueueItems(long startId, long endId) {\n        List<Queue.Item> items = new ArrayList<>();\n        for (long queueId = startId; queueId <= endId; queueId++) {\n            items.add(new MockItem(queueId));\n        }\n        return items;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test olderThan (page down) when set to id greater than newest (should never happen). Should be same as not\n     * specifying newerThan/olderThan.\n     */\n    @Test\n    public void test_olderThan_gt_newest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 11L);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(6), historyPageFilter.oldestOnPage);\n    }","id":79083,"modified_method":"/**\n     * Test olderThan (page down) when set to id greater than newest (should never happen). Should be same as not\n     * specifying newerThan/olderThan.\n     */\n    @Test\n    public void test_olderThan_gt_newest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 11L);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(6), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test newerThan (page up) when set to id less than the oldest (should never happen). Should give the oldest\n     * set of builds.\n     */\n    @Test\n    public void test_newerThan_lt_oldest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(5), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);\n    }","id":79084,"modified_method":"/**\n     * Test newerThan (page up) when set to id less than the oldest (should never happen). Should give the oldest\n     * set of builds.\n     */\n    @Test\n    public void test_newerThan_lt_oldest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(5), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test olderThan (page down) when set to id less than the oldest (should never happen). Should just give an\n     * empty list of builds.\n     */\n    @Test\n    public void test_olderThan_lt_oldest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 0L);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(0, historyPageFilter.runs.size());\n    }","id":79085,"modified_method":"/**\n     * Test olderThan (page down) when set to id less than the oldest (should never happen). Should just give an\n     * empty list of builds.\n     */\n    @Test\n    public void test_olderThan_lt_oldest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 0L);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(false, historyPageFilter.hasDownPage);\n        Assert.assertEquals(0, historyPageFilter.runs.size());\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test olderThan (page down) when set to an id in the middle. Should be a page up and a page down.\n     */\n    @Test\n    public void test_olderThan_mid_page() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 8L);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(7), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(3), historyPageFilter.oldestOnPage);\n    }","id":79086,"modified_method":"/**\n     * Test olderThan (page down) when set to an id in the middle. Should be a page up and a page down.\n     */\n    @Test\n    public void test_olderThan_mid_page() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 8L);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(7), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(3), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Latest/top page where total number of items greater than the max page size.\n     */\n    @Test\n    public void test_latest_longer_list() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        itemList.addAll(newQueueItems(11, 12));\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(2, historyPageFilter.queueItems.size());\n        Assert.assertEquals(3, historyPageFilter.runs.size());\n\n        Assert.assertEquals(12, historyPageFilter.queueItems.get(0).getEntryId());\n        Assert.assertEquals(12, historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.runs.get(0).getEntryId());\n    }","id":79087,"modified_method":"/**\n     * Latest/top page where total number of items greater than the max page size.\n     */\n    @Test\n    public void test_latest_longer_list() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null);\n        List<ModelObject> runs = newRuns(1, 10);\n        List<Queue.Item> queueItems = newQueueItems(11, 12);\n\n        historyPageFilter.add(runs, queueItems);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(2, historyPageFilter.queueItems.size());\n        Assert.assertEquals(3, historyPageFilter.runs.size());\n\n        Assert.assertEquals(12, historyPageFilter.queueItems.get(0).getEntryId());\n        Assert.assertEquals(12, historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.runs.get(0).getEntryId());\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test newerThan (page up) mid range nearer the oldest build in the list.\n     */\n    @Test\n    public void test_newerThan_near_oldest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 3L, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(8), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(4), historyPageFilter.oldestOnPage);\n    }","id":79088,"modified_method":"/**\n     * Test newerThan (page up) mid range nearer the oldest build in the list.\n     */\n    @Test\n    public void test_newerThan_near_oldest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 3L, null);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(true, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(8), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(4), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test newerThan (page up) mid range nearer the newest build in the list. This works a little different\n     * in that it will put the 2 builds newer than newerThan on the page and then fill the remaining slots on the\n     * page with builds equal to and older i.e. it return the newest/latest builds.\n     */\n    @Test\n    public void test_newerThan_near_newest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 8L, null);\n        List<ModelObject> itemList = new ArrayList<ModelObject>();\n\n        itemList.addAll(newRuns(1, 10));\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(6), historyPageFilter.oldestOnPage);\n    }","id":79089,"modified_method":"/**\n     * Test newerThan (page up) mid range nearer the newest build in the list. This works a little different\n     * in that it will put the 2 builds newer than newerThan on the page and then fill the remaining slots on the\n     * page with builds equal to and older i.e. it return the newest/latest builds.\n     */\n    @Test\n    public void test_newerThan_near_newest() throws IOException {\n        HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 8L, null);\n        List<ModelObject> itemList = newRuns(1, 10);\n\n        historyPageFilter.add(itemList);\n\n        Assert.assertEquals(false, historyPageFilter.hasUpPage);\n        Assert.assertEquals(true, historyPageFilter.hasDownPage);\n        Assert.assertEquals(5, historyPageFilter.runs.size());\n\n        Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.newestOnPage);\n        Assert.assertEquals(HistoryPageEntry.getEntryId(6), historyPageFilter.oldestOnPage);\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private List<HistoryPageEntry<T>> toPageEntries(Iterable<T> historyItemList) {\n        Iterator<T> iterator = historyItemList.iterator();\n\n        if (!iterator.hasNext()) {\n            return Collections.EMPTY_LIST;\n        }\n\n        List<HistoryPageEntry<T>> pageEntries = new ArrayList<HistoryPageEntry<T>>();\n        while (iterator.hasNext()) {\n\t        pageEntries.add(new HistoryPageEntry<T>(iterator.next()));\n        }\n\n\treturn pageEntries;\n    }","id":79090,"modified_method":"private List<HistoryPageEntry<T>> toPageEntries(Iterable<T> historyItemList) {\n        Iterator<T> iterator = historyItemList.iterator();\n\n        if (!iterator.hasNext()) {\n            return Collections.emptyList();\n        }\n\n        List<HistoryPageEntry<T>> pageEntries = new ArrayList<HistoryPageEntry<T>>();\n        while (iterator.hasNext()) {\n            pageEntries.add(new HistoryPageEntry<T>(iterator.next()));\n        }\n\n        return pageEntries;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Get a {@link jenkins.widgets.HistoryPageFilter} for rendering a page of queue items.\n     */\n    public HistoryPageFilter getHistoryPageFilter() {\n        HistoryPageFilter<T> historyPageFilter = newPageFilter();\n\n        historyPageFilter.add(IteratorUtils.toList(baseList.iterator()));\n        historyPageFilter.widget = this;\n        return historyPageFilter;\n    }","id":79091,"modified_method":"/**\n     * Get a {@link jenkins.widgets.HistoryPageFilter} for rendering a page of queue items.\n     */\n    public HistoryPageFilter getHistoryPageFilter() {\n        HistoryPageFilter<T> historyPageFilter = newPageFilter();\n\n        historyPageFilter.add(baseList);\n        historyPageFilter.widget = this;\n        return historyPageFilter;\n    }","commit_id":"55203ebeed1b7e182878d3e3c1184ac042f20473","url":"https://github.com/kohsuke/hudson"},{"original_method":"private <C> void write(List<ByteBuffer> buffer)\n    {\n        EndPoint endpoint = getEndPoint();\n\n        if (!isOpen())\n        {\n            writeBytes.failAll(new IOException(\"Connection closed\"));\n            return;\n        }\n\n        try\n        {\n            int bufsize = buffer.size();\n            if (bufsize == 1)\n            {\n                // simple case\n                endpoint.write(writeBytes,buffer.get(0));\n            }\n            else\n            {\n                // gathered writes case\n                ByteBuffer bbarr[] = buffer.toArray(new ByteBuffer[bufsize]);\n                endpoint.write(writeBytes,bbarr);\n            }\n        }\n        catch (Throwable t)\n        {\n            writeBytes.failed(t);\n        }\n    }","id":79092,"modified_method":"private <C> void write(List<ByteBuffer> buffer)\n    {\n        EndPoint endpoint = getEndPoint();\n\n        try\n        {\n            int bufsize = buffer.size();\n            if (bufsize == 1)\n            {\n                // simple case\n                endpoint.write(writeBytes,buffer.get(0));\n            }\n            else\n            {\n                // gathered writes case\n                ByteBuffer bbarr[] = buffer.toArray(new ByteBuffer[bufsize]);\n                endpoint.write(writeBytes,bbarr);\n            }\n        }\n        catch (Throwable t)\n        {\n            writeBytes.failed(t);\n        }\n    }","commit_id":"26faa5f0d731682ea18c8a70dcec8246299a9512","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void flush()\n    {\n        List<ByteBuffer> buffers = null;\n\n        synchronized (writeBytes)\n        {\n            if (flushing)\n            {\n                LOG.debug(\"Actively flushing\");\n                return;\n            }\n\n            if (LOG.isDebugEnabled())\n            {\n                LOG.debug(\".flush() - flushing={} - writeBytes={}\",flushing,writeBytes);\n            }\n\n            if (!isOpen())\n            {\n                // No longer have an open connection, drop them all.\n                writeBytes.failAll(new WebSocketException(\"Connection closed\"));\n                return;\n            }\n\n            buffers = writeBytes.getByteBuffers();\n\n            flushing = true;\n        }\n\n        write(buffers);\n    }","id":79093,"modified_method":"public void flush()\n    {\n        List<ByteBuffer> buffers = null;\n\n        synchronized (writeBytes)\n        {\n            if (flushing)\n            {\n                LOG.debug(\"Actively flushing\");\n                return;\n            }\n\n            if (LOG.isDebugEnabled())\n            {\n                LOG.debug(\".flush() - flushing={} - writeBytes={}\",flushing,writeBytes);\n            }\n\n            if (!isOpen())\n            {\n                // No longer have an open connection, drop them all.\n                writeBytes.failAll(new WebSocketException(\"Connection closed\"));\n                return;\n            }\n\n            buffers = writeBytes.getByteBuffers();\n\n            if ((buffers == null) || (buffers.size() <= 0))\n            {\n                return;\n            }\n\n            flushing = true;\n        }\n\n        write(buffers);\n    }","commit_id":"26faa5f0d731682ea18c8a70dcec8246299a9512","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void assertCloseCode(int expectedCode) throws InterruptedException\n    {\n        Assert.assertThat(\"Was Closed\",closeLatch.await(50,TimeUnit.MILLISECONDS),is(true));\n        Assert.assertThat(\"Close Code\",closeCode,is(expectedCode));\n    }","id":79094,"modified_method":"public void assertCloseCode(int expectedCode) throws InterruptedException\n    {\n        Assert.assertThat(\"Was Closed\",closeLatch.await(50,TimeUnit.MILLISECONDS),is(true));\n        Assert.assertThat(\"Close Code / Received [\" + closeMessage + \"]\",closeCode,is(expectedCode));\n    }","commit_id":"26faa5f0d731682ea18c8a70dcec8246299a9512","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Write of ByteBuffer succeeded.\n     */\n    @Override\n    public void succeeded()\n    {\n        List<Callback> successNotifiers = new ArrayList<>();\n\n        synchronized (this)\n        {\n            // Release the active byte buffer first\n            generator.getBufferPool().release(buffer);\n\n            if ((active != null) && (active.frame.remaining() <= 0))\n            {\n                // All done with active FrameEntry\n                successNotifiers.add(active.callback);\n                // Forget active\n                active = null;\n            }\n\n            for (FrameEntry entry : past)\n            {\n                successNotifiers.add(entry.callback);\n            }\n            past.clear();\n        }\n\n        // notify flush callback\n        flushCallback.succeeded();\n\n        // Notify success (outside of synchronize lock)\n        for (Callback successCallback : successNotifiers)\n        {\n            try\n            {\n                // notify of success\n                successCallback.succeeded();\n            }\n            catch (Throwable t)\n            {\n                LOG.warn(\"Callback failure\",t);\n            }\n        }\n    }","id":79095,"modified_method":"/**\n     * Write of ByteBuffer succeeded.\n     */\n    @Override\n    public void succeeded()\n    {\n        // Release the active byte buffer first\n        generator.getBufferPool().release(buffer);\n\n        if ((active != null) && (active.frame.remaining() <= 0))\n        {\n            // All done with active FrameEntry\n            FrameEntry entry = active;\n            active = null;\n            entry.notifySucceeded();\n        }\n\n        while (!past.isEmpty())\n        {\n            FrameEntry entry = past.pop();\n            entry.notifySucceeded();\n        }\n\n        // notify flush callback\n        flushCallback.succeeded();\n    }","commit_id":"26faa5f0d731682ea18c8a70dcec8246299a9512","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Get the next set of ByteBuffers to write.\n     * \n     * @return the next set of ByteBuffers to write\n     */\n    public List<ByteBuffer> getByteBuffers()\n    {\n        List<ByteBuffer> bufs = new ArrayList<>();\n        int count = 0;\n        synchronized (this)\n        {\n            for (; count < gatheredBufferLimit; count++)\n            {\n                if (active == null)\n                {\n                    if (queue.isEmpty())\n                    {\n                        // nothing in queue\n                        return bufs;\n                    }\n\n                    // get current topmost entry\n                    active = queue.pop();\n\n                    // generate header\n                    bufs.add(active.getHeaderBytes());\n                    count++;\n                }\n\n                // collect payload window\n                bufs.add(active.getPayloadWindow());\n                if (active.isDone())\n                {\n                    past.add(active);\n                    active = null;\n                }\n            }\n        }\n\n        LOG.debug(\"Collected {} ByteBuffers\",bufs.size());\n        return bufs;\n    }","id":79096,"modified_method":"/**\n     * Get the next set of ByteBuffers to write.\n     * \n     * @return the next set of ByteBuffers to write\n     */\n    public List<ByteBuffer> getByteBuffers()\n    {\n        List<ByteBuffer> bufs = null;\n        int count = 0;\n        synchronized (this)\n        {\n            for (; count < gatheredBufferLimit; count++)\n            {\n                if (active == null)\n                {\n                    if (queue.isEmpty())\n                    {\n                        // nothing in queue\n                        return bufs;\n                    }\n\n                    // get current topmost entry\n                    active = queue.pop();\n\n                    // generate header\n                    if (bufs == null)\n                    {\n                        bufs = new ArrayList<>();\n                    }\n                    bufs.add(active.getHeaderBytes());\n                    count++;\n                }\n\n                // collect payload window\n                if (bufs == null)\n                {\n                    bufs = new ArrayList<>();\n                }\n                bufs.add(active.getPayloadWindow());\n                if (active.isDone())\n                {\n                    past.add(active);\n                    active = null;\n                }\n            }\n        }\n\n        LOG.debug(\"Collected {} ByteBuffers\",bufs.size());\n        return bufs;\n    }","commit_id":"26faa5f0d731682ea18c8a70dcec8246299a9512","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void failAll(Throwable t)\n    {\n        synchronized (this)\n        {\n            boolean notified = false;\n\n            // fail active (if set)\n            if (active != null)\n            {\n                active.notifyFailure(t);\n                notified = true;\n            }\n\n            failure = t;\n\n            // fail past\n            for (FrameEntry fe : past)\n            {\n                fe.notifyFailure(t);\n                notified = true;\n            }\n\n            past.clear();\n\n            // fail others\n            for (FrameEntry fe : queue)\n            {\n                fe.notifyFailure(t);\n                notified = true;\n            }\n\n            queue.clear();\n\n            if (notified)\n            {\n                // notify flush callback\n                flushCallback.failed(t);\n            }\n        }\n    }","id":79097,"modified_method":"public void failAll(Throwable t)\n    {\n        boolean notified = false;\n\n        // fail active (if set)\n        if (active != null)\n        {\n            FrameEntry entry = active;\n            active = null;\n            entry.notifyFailure(t);\n            notified = true;\n        }\n\n        failure = t;\n\n        // fail past\n        while(!past.isEmpty())\n        {\n            FrameEntry entry = past.pop();\n            entry.notifyFailure(t);\n            notified = true;\n        }\n\n        // fail others\n        while(!queue.isEmpty())\n        {\n            FrameEntry entry = queue.pop();\n            entry.notifyFailure(t);\n            notified = true;\n        }\n\n        if (notified)\n        {\n            // notify flush callback\n            flushCallback.failed(t);\n        }\n    }","commit_id":"26faa5f0d731682ea18c8a70dcec8246299a9512","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Write of ByteBuffer succeeded.\n     */\n    @Override\n    public void succeeded()\n    {\n        if ((active != null) && (active.frame.remaining() <= 0))\n        {\n            // All done with active FrameEntry\n            FrameEntry entry = active;\n            active = null;\n            entry.notifySucceeded();\n        }\n\n        while (!past.isEmpty())\n        {\n            FrameEntry entry = past.pop();\n            entry.notifySucceeded();\n        }\n\n        // notify flush callback\n        flushCallback.succeeded();\n    }","id":79098,"modified_method":"/**\n     * Write of ByteBuffer succeeded.\n     */\n    @Override\n    public void succeeded()\n    {\n        // Collect entries for callback\n        List<FrameEntry> callbacks = new ArrayList<>();\n\n        synchronized (this)\n        {\n            if ((active != null) && (active.frame.remaining() <= 0))\n            {\n                // All done with active FrameEntry\n                FrameEntry entry = active;\n                active = null;\n                callbacks.add(entry);\n            }\n\n            callbacks.addAll(past);\n            past.clear();\n        }\n\n        // notify flush callback\n        flushCallback.succeeded();\n\n        // notify entry callbacks outside of synchronize\n        for (FrameEntry entry : callbacks)\n        {\n            entry.notifySucceeded();\n        }\n    }","commit_id":"098b1e174bb2c3a3f69483bc91c987c70c6a3bb2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void failAll(Throwable t)\n    {\n        boolean notified = false;\n\n        // fail active (if set)\n        if (active != null)\n        {\n            FrameEntry entry = active;\n            active = null;\n            entry.notifyFailure(t);\n            notified = true;\n        }\n\n        failure = t;\n\n        // fail past\n        while (!past.isEmpty())\n        {\n            FrameEntry entry = past.pop();\n            entry.notifyFailure(t);\n            notified = true;\n        }\n\n        // fail others\n        while (!queue.isEmpty())\n        {\n            FrameEntry entry = queue.pop();\n            entry.notifyFailure(t);\n            notified = true;\n        }\n\n        if (notified)\n        {\n            // notify flush callback\n            flushCallback.failed(t);\n        }\n    }","id":79099,"modified_method":"public void failAll(Throwable t)\n    {\n        // Collect entries for callback\n        List<FrameEntry> callbacks = new ArrayList<>();\n\n        synchronized (this)\n        {\n            // fail active (if set)\n            if (active != null)\n            {\n                FrameEntry entry = active;\n                active = null;\n                callbacks.add(entry);\n            }\n\n            callbacks.addAll(past);\n            callbacks.addAll(queue);\n\n            past.clear();\n            queue.clear();\n        }\n\n        // notify flush callback\n        if (!callbacks.isEmpty())\n        {\n            // TODO: always notify instead?\n            flushCallback.failed(t);\n\n            // notify entry callbacks\n            for (FrameEntry entry : callbacks)\n            {\n                entry.notifyFailure(t);\n            }\n        }\n    }","commit_id":"098b1e174bb2c3a3f69483bc91c987c70c6a3bb2","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Iterable<Function> getFunctions()\n    {\n        Iterable<Function> functions = attrs.getFunctions();\n\n        for (Restriction restriction : processedKeys.values())\n                functions = Iterables.concat(functions, restriction.getFunctions());\n\n        if (columnOperations != null)\n            for (Operation operation : columnOperations)\n                functions = Iterables.concat(functions, operation.getFunctions());\n\n        if (columnConditions != null)\n            for (ColumnCondition condition : columnConditions)\n                functions = Iterables.concat(functions, condition.getFunctions());\n\n        if (staticConditions != null)\n            for (ColumnCondition condition : staticConditions)\n                functions = Iterables.concat(functions, condition.getFunctions());\n\n        return functions;\n    }","id":79100,"modified_method":"public Iterable<Function> getFunctions()\n    {\n        List<Iterable<Function>> iterables = new LinkedList<>();\n        for (Restriction restriction : processedKeys.values())\n            iterables.add(restriction.getFunctions());\n\n        if (columnOperations != null)\n            for (Operation operation : columnOperations)\n                iterables.add(operation.getFunctions());\n\n        if (columnConditions != null)\n            for (ColumnCondition condition : columnConditions)\n                iterables.add(condition.getFunctions());\n\n        if (staticConditions != null)\n            for (ColumnCondition condition : staticConditions)\n                iterables.add(condition.getFunctions());\n\n        return Iterables.concat(iterables);\n    }","commit_id":"3244774572c56400ed96da4d57912779878c16e5","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n\t * Free buckets. Get yer free buckets here! No charge! All you can carry\n\t * free buckets!\n\t * <p>\n\t * If an exception happens the method will attempt to free the remaining\n\t * buckets then retun the first exception. Buckets successfully freed are\n\t * made <code>null<\/code> in the array.\n\t * <\/p>\n\t * \n\t * @param bf\n\t * @param buckets\n\t * @throws IOException\n\t *             the first exception The <code>buckets<\/code> array will\n\t */\n\tpublic static void freeBuckets(BucketFactory bf, Bucket[] buckets)\n\t\tthrows IOException {\n\t\tif (buckets == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIOException firstIoe = null;\n\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\t// Make sure we free any temp buckets on exception\n\t\t\ttry {\n\t\t\t\tif (buckets[i] != null) {\n\t\t\t\t\tbf.freeBucket(buckets[i]);\n\t\t\t\t}\n\t\t\t\tbuckets[i] = null;\n\t\t\t} catch (IOException e) {\n\t\t\t\tif (firstIoe == null) {\n\t\t\t\t\tfirstIoe = e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (firstIoe != null) {\n\t\t\tthrow firstIoe;\n\t\t}\n\t}","id":79101,"modified_method":"/**\n\t * Free buckets. Get yer free buckets here! No charge! All you can carry\n\t * free buckets!\n\t * <p>\n\t * If an exception happens the method will attempt to free the remaining\n\t * buckets then retun the first exception. Buckets successfully freed are\n\t * made <code>null<\/code> in the array.\n\t * <\/p>\n\t * \n\t * @param bf\n\t * @param buckets\n\t * @throws IOException\n\t *             the first exception The <code>buckets<\/code> array will\n\t */\n\tpublic static void freeBuckets(BucketFactory bf, Bucket[] buckets)\n\t\tthrows IOException {\n\t\tif (buckets == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIOException firstIoe = null;\n\n\t\tfor (int i = 0; i < buckets.length; i++) {\n\t\t\t// Make sure we free any temp buckets on exception\n\t\t\tif (buckets[i] != null) {\n\t\t\t\tbuckets[i].free();\n\t\t\t}\n\t\t\tbuckets[i] = null;\n\t\t}\n\n\t\tif (firstIoe != null) {\n\t\t\tthrow firstIoe;\n\t\t}\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"public void register(File file) {\n\t\toriginalFiles.remove(file);\n\t}","id":79102,"modified_method":"public void register(File file) {\n\t\tsynchronized(this) {\n\t\t\toriginalFiles.remove(file);\n\t\t}\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket[] grabBucketsToFree() {\n\t\tsynchronized(this) {\n\t\t\treturn (Bucket[]) bucketsToFree.toArray(new Bucket[bucketsToFree.size()]);\n\t\t}\n\t}","id":79103,"modified_method":"public Bucket[] grabBucketsToFree() {\n\t\tsynchronized(this) {\n\t\t\tBucket[] toFree = (Bucket[]) bucketsToFree.toArray(new Bucket[bucketsToFree.size()]);\n\t\t\tbucketsToFree.clear();\n\t\t\treturn toFree;\n\t\t}\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Restore an encrypted temp bucket from last time.\n\t * @param filename The filename. Must exist unless len=0.\n\t * @param key The encryption key for the bucket.\n\t * @param len The data length. The file must be of at least this length.\n\t * @return\n\t * @throws IOException If the file doesn't exist or if it is too short.\n\t */\n\tpublic Bucket registerEncryptedBucket(String filename, byte[] key, long len) throws IOException {\n\t\tBucket fileBucket = register(filename, len > 0);\n\t\treturn new PaddedEphemerallyEncryptedBucket(fileBucket, 1024, len, key, rand);\n\t}","id":79104,"modified_method":"/**\n\t * Restore an encrypted temp bucket from last time.\n\t * @param filename The filename. Must exist unless len=0.\n\t * @param key The encryption key for the bucket.\n\t * @param len The data length. The file must be of at least this length.\n\t * @return\n\t * @throws IOException If the file doesn't exist or if it is too short.\n\t */\n\tpublic Bucket registerEncryptedBucket(String filename, byte[] key, long len) throws IOException {\n\t\tBucket fileBucket = register(filename, len > 0);\n\t\treturn new DelayedFreeBucket(new PaddedEphemerallyEncryptedBucket(fileBucket, 1024, len, key, rand));\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket makeRawBucket(long size) throws IOException {\n\t\treturn new FileBucket(fg.makeRandomFilename(), false, false, false, true);\n\t}","id":79105,"modified_method":"private Bucket makeRawBucket(long size) throws IOException {\n\t\treturn new FileBucket(fg.makeRandomFilename(), false, false, false, true);\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Free an allocated bucket, but only after the change has been written to disk.\n\t */\n\tpublic void freeBucket(Bucket b) throws IOException {\n\t\tsynchronized(this) {\n\t\t\tbucketsToFree.add(b);\n\t\t}\n\t}","id":79106,"modified_method":"/**\n\t * Free an allocated bucket, but only after the change has been written to disk.\n\t */\n\tpublic void delayedFreeBucket(Bucket b) {\n\t\tsynchronized(this) {\n\t\t\tbucketsToFree.add(b);\n\t\t}\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket makeEncryptedBucket() throws IOException {\n\t\tBucket b = makeRawBucket(-1);\n\t\treturn new PaddedEphemerallyEncryptedBucket(b, 1024, rand, false);\n\t}","id":79107,"modified_method":"public Bucket makeEncryptedBucket() throws IOException {\n\t\tBucket b = makeRawBucket(-1);\n\t\treturn new DelayedFreeBucket(new PaddedEphemerallyEncryptedBucket(b, 1024, rand, false));\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket makeBucket(long size) throws IOException {\n\t\tBucket b = makeRawBucket(size);\n\t\treturn new PaddedEphemerallyEncryptedBucket(b, 1024, rand, false);\n\t}","id":79108,"modified_method":"public Bucket makeBucket(long size) throws IOException {\n\t\tBucket b = makeRawBucket(size);\n\t\treturn new DelayedFreeBucket(new PaddedEphemerallyEncryptedBucket(b, 1024, rand, false));\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Called by a client to fetch the bucket denoted by a specific filename,\n\t * and to register this fact so that it is not deleted on startup completion.\n\t * @throws IOException \n\t */\n\tpublic Bucket register(String filename, boolean mustExist) throws IOException {\n\t\tFile f = new File(dir, filename);\n\t\tif(mustExist && !f.exists())\n\t\t\tthrow new IOException(\"File does not exist (deleted?): \"+f);\n\t\tBucket b = new FileBucket(f, false, false, false, true);\n\t\toriginalFiles.remove(f);\n\t\treturn b;\n\t}","id":79109,"modified_method":"/**\n\t * Called by a client to fetch the bucket denoted by a specific filename,\n\t * and to register this fact so that it is not deleted on startup completion.\n\t * @throws IOException \n\t */\n\tpublic Bucket register(String filename, boolean mustExist) throws IOException {\n\t\tFile f = new File(dir, filename);\n\t\tif(mustExist && !f.exists())\n\t\t\tthrow new IOException(\"File does not exist (deleted?): \"+f);\n\t\tBucket b = new FileBucket(f, false, false, false, true);\n\t\tsynchronized(this) {\n\t\t\toriginalFiles.remove(f);\n\t\t}\n\t\treturn b;\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"private void tryCompress() throws InserterException {\n\t\t// First, determine how small it needs to be\n\t\tBucket origData = block.getData();\n\t\tBucket data = origData;\n\t\tint blockSize;\n\t\tint oneBlockCompressedSize;\n\t\tboolean dontCompress = ctx.dontCompress;\n\t\t\n\t\tlong origSize = data.size();\n\t\tString type = block.desiredURI.getKeyType().toUpperCase();\n\t\tif(type.equals(\"SSK\") || type.equals(\"KSK\") || type.equals(\"USK\")) {\n\t\t\tblockSize = SSKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = SSKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else if(type.equals(\"CHK\")) {\n\t\t\tblockSize = CHKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else {\n\t\t\tthrow new InserterException(InserterException.INVALID_URI, \"Unknown key type: \"+type, null);\n\t\t}\n\t\t\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\n\t\tboolean tryCompress = (origSize > blockSize) && (!ctx.dontCompress) && (!dontCompress);\n\t\tif(tryCompress) {\n\t\t\t// Try to compress the data.\n\t\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\t\tint algos = Compressor.countCompressAlgorithms();\n\t\t\ttry {\n\t\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\t\tif(parent == cb)\n\t\t\t\t\t\tctx.eventProducer.produceEvent(new StartedCompressionEvent(i));\n\t\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\t\tBucket result;\n\t\t\t\t\tresult = comp.compress(origData, ctx.persistentBucketFactory, origData.size());\n\t\t\t\t\tif(result.size() < oneBlockCompressedSize) {\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tdata = result;\n\t\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\t\tctx.bf.freeBucket(bestCompressedData);\n\t\t\t\t\t\tbestCompressedData = data;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\t\tctx.bf.freeBucket(bestCompressedData);\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tdata = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tdata = result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InserterException(InserterException.BUCKET_ERROR, e, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// Impossible\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(parent == cb) {\n\t\t\tif(tryCompress)\n\t\t\t\tctx.eventProducer.produceEvent(new FinishedCompressionEvent(bestCodec == null ? -1 : bestCodec.codecNumberForMetadata(), origSize, data.size()));\n\t\t\tif(logMINOR) Logger.minor(this, \"Compressed \"+origSize+\" to \"+data.size()+\" on \"+this);\n\t\t}\n\t\t\n\t\t// Compressed data\n\t\t\n\t\t// Insert it...\n\t\tshort codecNumber = bestCodec == null ? -1 : bestCodec.codecNumberForMetadata();\n\t\tlong compressedDataSize = data.size();\n\t\tboolean fitsInOneBlockAsIs = bestCodec == null ? compressedDataSize < blockSize : compressedDataSize < oneBlockCompressedSize;\n\t\tboolean fitsInOneCHK = bestCodec == null ? compressedDataSize < CHKBlock.DATA_LENGTH : compressedDataSize < CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\n\t\tif(block.getData().size() > Integer.MAX_VALUE)\n\t\t\tthrow new InserterException(InserterException.INTERNAL_ERROR, \"2GB+ should not encode to one block!\", null);\n\n\t\tboolean noMetadata = ((block.clientMetadata == null) || block.clientMetadata.isTrivial()) && targetFilename == null;\n\t\tif(noMetadata && !insertAsArchiveManifest) {\n\t\t\tif(fitsInOneBlockAsIs) {\n\t\t\t\t// Just insert it\n\t\t\t\tClientPutState bi =\n\t\t\t\t\tcreateInserter(parent, data, codecNumber, block.desiredURI, ctx, cb, metadata, (int)block.getData().size(), -1, getCHKOnly, true, true);\n\t\t\t\tcb.onTransition(this, bi);\n\t\t\t\tbi.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fitsInOneCHK) {\n\t\t\t// Insert single block, then insert pointer to it\n\t\t\tif(reportMetadataOnly) {\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, cb, metadata, (int)origSize, -1, getCHKOnly, true, true, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tcb.onMetadata(meta, this);\n\t\t\t\tcb.onTransition(this, dataPutter);\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t} else {\n\t\t\t\tMultiPutCompletionCallback mcb = \n\t\t\t\t\tnew MultiPutCompletionCallback(cb, parent, token);\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, mcb, metadata, (int)origSize, -1, getCHKOnly, true, false, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tBucket metadataBucket;\n\t\t\t\ttry {\n\t\t\t\t\tmetadataBucket = BucketTools.makeImmutableBucket(ctx.bf, meta.writeToByteArray());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InserterException(InserterException.BUCKET_ERROR, e, null);\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t// Impossible, we're not inserting a manifest.\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InserterException(InserterException.INTERNAL_ERROR, \"Got MetadataUnresolvedException in SingleFileInserter: \"+e.toString(), null);\n\t\t\t\t}\n\t\t\t\tClientPutState metaPutter = createInserter(parent, metadataBucket, (short) -1, block.desiredURI, ctx, mcb, true, (int)origSize, -1, getCHKOnly, true, false);\n\t\t\t\tmcb.addURIGenerator(metaPutter);\n\t\t\t\tmcb.add(dataPutter);\n\t\t\t\tcb.onTransition(this, mcb);\n\t\t\t\tLogger.minor(this, \"\"+mcb+\" : data \"+dataPutter+\" meta \"+metaPutter);\n\t\t\t\tmcb.arm();\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tif(metaPutter instanceof SingleBlockInserter)\n\t\t\t\t\t((SingleBlockInserter)metaPutter).encode();\n\t\t\t\tmetaPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Otherwise the file is too big to fit into one block\n\t\t// We therefore must make a splitfile\n\t\t// Job of SplitHandler: when the splitinserter has the metadata,\n\t\t// insert it. Then when the splitinserter has finished, and the\n\t\t// metadata insert has finished too, tell the master callback.\n\t\tif(reportMetadataOnly) {\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, cb, data, bestCodec, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, false);\n\t\t\tcb.onTransition(this, sfi);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t} else {\n\t\t\tSplitHandler sh = new SplitHandler();\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, sh, data, bestCodec, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, false);\n\t\t\tsh.sfi = sfi;\n\t\t\tcb.onTransition(this, sh);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t}\n\t}","id":79110,"modified_method":"private void tryCompress() throws InserterException {\n\t\t// First, determine how small it needs to be\n\t\tBucket origData = block.getData();\n\t\tBucket data = origData;\n\t\tint blockSize;\n\t\tint oneBlockCompressedSize;\n\t\tboolean dontCompress = ctx.dontCompress;\n\t\t\n\t\tlong origSize = data.size();\n\t\tString type = block.desiredURI.getKeyType().toUpperCase();\n\t\tif(type.equals(\"SSK\") || type.equals(\"KSK\") || type.equals(\"USK\")) {\n\t\t\tblockSize = SSKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = SSKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else if(type.equals(\"CHK\")) {\n\t\t\tblockSize = CHKBlock.DATA_LENGTH;\n\t\t\toneBlockCompressedSize = CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\t\t} else {\n\t\t\tthrow new InserterException(InserterException.INVALID_URI, \"Unknown key type: \"+type, null);\n\t\t}\n\t\t\n\t\tCompressor bestCodec = null;\n\t\tBucket bestCompressedData = null;\n\n\t\tboolean tryCompress = (origSize > blockSize) && (!ctx.dontCompress) && (!dontCompress);\n\t\tif(tryCompress) {\n\t\t\t// Try to compress the data.\n\t\t\t// Try each algorithm, starting with the fastest and weakest.\n\t\t\t// Stop when run out of algorithms, or the compressed data fits in a single block.\n\t\t\tint algos = Compressor.countCompressAlgorithms();\n\t\t\ttry {\n\t\t\t\tfor(int i=0;i<algos;i++) {\n\t\t\t\t\t// Only produce if we are compressing *the original data*\n\t\t\t\t\tif(parent == cb)\n\t\t\t\t\t\tctx.eventProducer.produceEvent(new StartedCompressionEvent(i));\n\t\t\t\t\tCompressor comp = Compressor.getCompressionAlgorithmByDifficulty(i);\n\t\t\t\t\tBucket result;\n\t\t\t\t\tresult = comp.compress(origData, ctx.persistentBucketFactory, origData.size());\n\t\t\t\t\tif(result.size() < oneBlockCompressedSize) {\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tdata = result;\n\t\t\t\t\t\tif(bestCompressedData != null)\n\t\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = data;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((bestCompressedData != null) && (result.size() <  bestCompressedData.size())) {\n\t\t\t\t\t\tbestCompressedData.free();\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tdata = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t} else if((bestCompressedData == null) && (result.size() < data.size())) {\n\t\t\t\t\t\tbestCompressedData = result;\n\t\t\t\t\t\tbestCodec = comp;\n\t\t\t\t\t\tdata = result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InserterException(InserterException.BUCKET_ERROR, e, null);\n\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t// Impossible\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(parent == cb) {\n\t\t\tif(tryCompress)\n\t\t\t\tctx.eventProducer.produceEvent(new FinishedCompressionEvent(bestCodec == null ? -1 : bestCodec.codecNumberForMetadata(), origSize, data.size()));\n\t\t\tif(logMINOR) Logger.minor(this, \"Compressed \"+origSize+\" to \"+data.size()+\" on \"+this);\n\t\t}\n\t\t\n\t\t// Compressed data\n\t\t\n\t\t// Insert it...\n\t\tshort codecNumber = bestCodec == null ? -1 : bestCodec.codecNumberForMetadata();\n\t\tlong compressedDataSize = data.size();\n\t\tboolean fitsInOneBlockAsIs = bestCodec == null ? compressedDataSize < blockSize : compressedDataSize < oneBlockCompressedSize;\n\t\tboolean fitsInOneCHK = bestCodec == null ? compressedDataSize < CHKBlock.DATA_LENGTH : compressedDataSize < CHKBlock.MAX_COMPRESSED_DATA_LENGTH;\n\n\t\tif(block.getData().size() > Integer.MAX_VALUE)\n\t\t\tthrow new InserterException(InserterException.INTERNAL_ERROR, \"2GB+ should not encode to one block!\", null);\n\n\t\tboolean noMetadata = ((block.clientMetadata == null) || block.clientMetadata.isTrivial()) && targetFilename == null;\n\t\tif(noMetadata && !insertAsArchiveManifest) {\n\t\t\tif(fitsInOneBlockAsIs) {\n\t\t\t\t// Just insert it\n\t\t\t\tClientPutState bi =\n\t\t\t\t\tcreateInserter(parent, data, codecNumber, block.desiredURI, ctx, cb, metadata, (int)block.getData().size(), -1, getCHKOnly, true, true);\n\t\t\t\tcb.onTransition(this, bi);\n\t\t\t\tbi.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (fitsInOneCHK) {\n\t\t\t// Insert single block, then insert pointer to it\n\t\t\tif(reportMetadataOnly) {\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, cb, metadata, (int)origSize, -1, getCHKOnly, true, true, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tcb.onMetadata(meta, this);\n\t\t\t\tcb.onTransition(this, dataPutter);\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t} else {\n\t\t\t\tMultiPutCompletionCallback mcb = \n\t\t\t\t\tnew MultiPutCompletionCallback(cb, parent, token);\n\t\t\t\tSingleBlockInserter dataPutter = new SingleBlockInserter(parent, data, codecNumber, FreenetURI.EMPTY_CHK_URI, ctx, mcb, metadata, (int)origSize, -1, getCHKOnly, true, false, token);\n\t\t\t\tMetadata meta = makeMetadata(dataPutter.getURI());\n\t\t\t\tBucket metadataBucket;\n\t\t\t\ttry {\n\t\t\t\t\tmetadataBucket = BucketTools.makeImmutableBucket(ctx.bf, meta.writeToByteArray());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InserterException(InserterException.BUCKET_ERROR, e, null);\n\t\t\t\t} catch (MetadataUnresolvedException e) {\n\t\t\t\t\t// Impossible, we're not inserting a manifest.\n\t\t\t\t\tLogger.error(this, \"Caught \"+e, e);\n\t\t\t\t\tthrow new InserterException(InserterException.INTERNAL_ERROR, \"Got MetadataUnresolvedException in SingleFileInserter: \"+e.toString(), null);\n\t\t\t\t}\n\t\t\t\tClientPutState metaPutter = createInserter(parent, metadataBucket, (short) -1, block.desiredURI, ctx, mcb, true, (int)origSize, -1, getCHKOnly, true, false);\n\t\t\t\tmcb.addURIGenerator(metaPutter);\n\t\t\t\tmcb.add(dataPutter);\n\t\t\t\tcb.onTransition(this, mcb);\n\t\t\t\tLogger.minor(this, \"\"+mcb+\" : data \"+dataPutter+\" meta \"+metaPutter);\n\t\t\t\tmcb.arm();\n\t\t\t\tdataPutter.schedule();\n\t\t\t\tif(metaPutter instanceof SingleBlockInserter)\n\t\t\t\t\t((SingleBlockInserter)metaPutter).encode();\n\t\t\t\tmetaPutter.schedule();\n\t\t\t\tcb.onBlockSetFinished(this);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// Otherwise the file is too big to fit into one block\n\t\t// We therefore must make a splitfile\n\t\t// Job of SplitHandler: when the splitinserter has the metadata,\n\t\t// insert it. Then when the splitinserter has finished, and the\n\t\t// metadata insert has finished too, tell the master callback.\n\t\tif(reportMetadataOnly) {\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, cb, data, bestCodec, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, false);\n\t\t\tcb.onTransition(this, sfi);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t} else {\n\t\t\tSplitHandler sh = new SplitHandler();\n\t\t\tSplitFileInserter sfi = new SplitFileInserter(parent, sh, data, bestCodec, block.clientMetadata, ctx, getCHKOnly, metadata, token, insertAsArchiveManifest, false);\n\t\t\tsh.sfi = sfi;\n\t\t\tcb.onTransition(this, sh);\n\t\t\tsfi.start();\n\t\t\tif(earlyEncode) sfi.forceEncode();\n\t\t}\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Called when a block has completed.\n\t * @param x The block number.\n\t * @return -1 if the segment has already finished, otherwise the number of completed\n\t * blocks.\n\t */\n\tprivate synchronized int innerCompleted(int x) {\n\t\tif(logMINOR) Logger.minor(this, \"Completed: \"+x+\" on \"+this+\" ( completed=\"+blocksCompleted+\", total=\"+(dataBlockInserters.length+checkBlockInserters.length));\n\n\t\tif(finished) return -1;\n\t\tif(x >= dataBlocks.length) {\n\t\t\tx -= dataBlocks.length;\n\t\t\tif(checkBlockInserters[x] == null) {\n\t\t\t\tLogger.error(this, \"Completed twice: check block \"+x+\" on \"+this);\n\t\t\t\treturn blocksCompleted;\n\t\t\t}\n\t\t\tcheckBlockInserters[x] = null;\n\t\t\ttry {\n\t\t\t\tparent.ctx.persistentBucketFactory.freeBucket(checkBlocks[x]);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Could not free \"+checkBlocks[x]+\" : \"+e, e);\n\t\t\t}\n\t\t\tcheckBlocks[x] = null;\n\t\t} else {\n\t\t\tif(dataBlockInserters[x] == null) {\n\t\t\t\tLogger.error(this, \"Completed twice: data block \"+x+\" on \"+this);\n\t\t\t\treturn blocksCompleted;\n\t\t\t}\n\t\t\tdataBlockInserters[x] = null;\n\t\t\tif(encoded) {\n\t\t\t\ttry {\n\t\t\t\t\tparent.ctx.persistentBucketFactory.freeBucket(dataBlocks[x]);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLogger.error(this, \"Could not free \"+dataBlocks[x]+\" : \"+e, e);\n\t\t\t\t}\n\t\t\t\tdataBlocks[x] = null;\n\t\t\t}\n\t\t}\n\t\tblocksCompleted++;\n\t\treturn blocksCompleted;\n\t}","id":79111,"modified_method":"/**\n\t * Called when a block has completed.\n\t * @param x The block number.\n\t * @return -1 if the segment has already finished, otherwise the number of completed\n\t * blocks.\n\t */\n\tprivate synchronized int innerCompleted(int x) {\n\t\tif(logMINOR) Logger.minor(this, \"Completed: \"+x+\" on \"+this+\" ( completed=\"+blocksCompleted+\", total=\"+(dataBlockInserters.length+checkBlockInserters.length));\n\n\t\tif(finished) return -1;\n\t\tif(x >= dataBlocks.length) {\n\t\t\tx -= dataBlocks.length;\n\t\t\tif(checkBlockInserters[x] == null) {\n\t\t\t\tLogger.error(this, \"Completed twice: check block \"+x+\" on \"+this);\n\t\t\t\treturn blocksCompleted;\n\t\t\t}\n\t\t\tcheckBlockInserters[x] = null;\n\t\t\tcheckBlocks[x].free();\n\t\t\tcheckBlocks[x] = null;\n\t\t} else {\n\t\t\tif(dataBlockInserters[x] == null) {\n\t\t\t\tLogger.error(this, \"Completed twice: data block \"+x+\" on \"+this);\n\t\t\t\treturn blocksCompleted;\n\t\t\t}\n\t\t\tdataBlockInserters[x] = null;\n\t\t\tif(encoded) {\n\t\t\t\tdataBlocks[x].free();\n\t\t\t\tdataBlocks[x] = null;\n\t\t\t}\n\t\t}\n\t\tblocksCompleted++;\n\t\treturn blocksCompleted;\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"private void onEncodedSegment() {\n\t\tsynchronized(this) {\n\t\t\tfor(int i=0;i<dataBlockInserters.length;i++) {\n\t\t\t\tif(dataBlockInserters[i] == null && dataBlocks[i] != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparent.ctx.persistentBucketFactory.freeBucket(dataBlocks[i]);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tLogger.error(this, \"Could not free \"+dataBlocks[i]+\" : \"+e, e);\n\t\t\t\t\t}\n\t\t\t\t\tdataBlocks[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":79112,"modified_method":"private void onEncodedSegment() {\n\t\tsynchronized(this) {\n\t\t\tfor(int i=0;i<dataBlockInserters.length;i++) {\n\t\t\t\tif(dataBlockInserters[i] == null && dataBlocks[i] != null) {\n\t\t\t\t\tdataBlocks[i].free();\n\t\t\t\t\tdataBlocks[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"87283290aa494832b974adec87a0fb667dee1899","url":"https://github.com/freenet/fred"},{"original_method":"private void uninstallApplication() throws CLIException,\n\t\t\tInterruptedException, TimeoutException {\n\t\tMap<String, String> uninstallApplicationResponse = this.adminFacade\n\t\t\t\t.uninstallApplication(this.applicationName, timeoutInMinutes);\n\n\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString uninstallPollingID = uninstallApplicationResponse\n\t\t\t\t\t.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(uninstallPollingID, timeoutInMinutes);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t}","id":79113,"modified_method":"private void uninstallApplication() throws CLIException,\n\t\t\tInterruptedException, TimeoutException {\n\t\tMap<String, String> uninstallApplicationResponse = this.adminFacade\n\t\t\t\t.uninstallApplication(this.applicationName, timeoutInMinutes);\n\n\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString uninstallPollingID = uninstallApplicationResponse\n\t\t\t\t\t.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(uninstallPollingID, timeoutInMinutes,\n\t\t\t\t\tUninstallApplication.TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!applicationFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"application_not_found\", applicationFile.getAbsolutePath());\r\n\t\t}\r\n\r\n\t\tlogger.info(\"Validating file \" + applicationFile.getName());\r\n\t\tfinal Application application = ServiceReader.getApplicationFromFile(applicationFile).getApplication();\r\n\r\n\t\tnormalizeApplicationName(application);\r\n\r\n\t\tif (adminFacade.getApplicationsList().contains(applicationName)) {\r\n\t\t\tthrow new CLIStatusException(\"application_already_deployed\", application.getName());\r\n\t\t}\r\n\r\n\t\tFile zipFile;\r\n\t\tif (applicationFile.isFile()) {\n\t\t\tif (applicationFile.getName().endsWith(\".zip\") || applicationFile.getName().endsWith(\".jar\")) {\n\t\t\t\tzipFile = applicationFile;\n\t\t\t} else {\n\t\t\t\tthrow new CLIStatusException(\"application_file_format_mismatch\", applicationFile.getPath());\n\t\t\t}\r\n\t\t} else {//pack an application folder\r\n\t\t\tzipFile = Packager.packApplication(application, applicationFile);\t\t\t\r\n\t\t}\r\n\r\n\t\t// toString of string list (i.e. [service1, service2])\r\n\t\tlogger.info(\"Uploading application \" + applicationName);\r\n\t\tMap<String, String> result = adminFacade.installApplication(zipFile, applicationName, timeoutInMinutes);\n\t\tString serviceOrder = result.get(CloudifyConstants.SERVICE_ORDER);\n\r\n\t\t// If temp file was created, Delete it.\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile.delete();\r\n\t\t}\r\n\r\n\t\tif (serviceOrder.charAt(0) != '[' && serviceOrder.charAt(serviceOrder.length() - 1) != ']') {\r\n\t\t\tthrow new IllegalStateException(\"Cannot parse service order response: \" + serviceOrder);\r\n\t\t}\n\t\t\n\t\tprintApplicationInfo(application);\n\t\tif (result.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = result.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = \n\t\t\t\t\tthis.adminFacade.getLifecycleEventsPollingLatch(pollingID);\n\t\t\tboolean isDone = lifecycleEventsPollingLatch.waitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\twhile (!isDone) {\n\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\t//uninstallApplication();\n\t\t\t\t} else { \n\t\t\t\t\tisDone = lifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\r\n\r\n\t\tsession.put(Constants.ACTIVE_APP, applicationName);\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(applicationName);\r\n\r\n\t\treturn this.getFormattedMessage(\"application_installed_succesfully\", Color.GREEN, applicationName);\r\n\t}","id":79114,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!applicationFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"application_not_found\", applicationFile.getAbsolutePath());\r\n\t\t}\r\n\r\n\t\tlogger.info(\"Validating file \" + applicationFile.getName());\r\n\t\tfinal Application application = ServiceReader.getApplicationFromFile(applicationFile).getApplication();\r\n\r\n\t\tnormalizeApplicationName(application);\r\n\r\n\t\tif (adminFacade.getApplicationsList().contains(applicationName)) {\r\n\t\t\tthrow new CLIStatusException(\"application_already_deployed\", application.getName());\r\n\t\t}\r\n\r\n\t\tFile zipFile;\r\n\t\tif (applicationFile.isFile()) {\n\t\t\tif (applicationFile.getName().endsWith(\".zip\") || applicationFile.getName().endsWith(\".jar\")) {\n\t\t\t\tzipFile = applicationFile;\n\t\t\t} else {\n\t\t\t\tthrow new CLIStatusException(\"application_file_format_mismatch\", applicationFile.getPath());\n\t\t\t}\r\n\t\t} else {//pack an application folder\r\n\t\t\tzipFile = Packager.packApplication(application, applicationFile);\t\t\t\r\n\t\t}\r\n\r\n\t\t// toString of string list (i.e. [service1, service2])\r\n\t\tlogger.info(\"Uploading application \" + applicationName);\r\n\t\tMap<String, String> result = adminFacade.installApplication(zipFile, applicationName, timeoutInMinutes);\n\t\tString serviceOrder = result.get(CloudifyConstants.SERVICE_ORDER);\n\r\n\t\t// If temp file was created, Delete it.\r\n\t\tif (!applicationFile.isFile()) {\r\n\t\t\tzipFile.delete();\r\n\t\t}\r\n\r\n\t\tif (serviceOrder.charAt(0) != '[' && serviceOrder.charAt(serviceOrder.length() - 1) != ']') {\r\n\t\t\tthrow new IllegalStateException(\"Cannot parse service order response: \" + serviceOrder);\r\n\t\t}\n\t\t\n\t\tprintApplicationInfo(application);\n\t\tString returnMessage = this.getFormattedMessage(\"application_installed_succesfully\",\n\t\t\t\tColor.GREEN, applicationName);\n\t\tif (result.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = result.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = \n\t\t\t\t\tthis.adminFacade.getLifecycleEventsPollingLatch(pollingID, TIMEOUT_ERROR_MESSAGE);\n\t\t\tboolean isDone = false;\n\t\t\tboolean continues = false;\n\t\t\twhile (!isDone) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!continues) {\n\t\t\t\t\t\tlifecycleEventsPollingLatch.waitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t\t}\n\t\t\t\t\tisDone = true;\n\t\t\t\t} catch (TimeoutException e) {\n\t\t\t\t\tif (!(Boolean) session.get(Constants.INTERACTIVE_MODE)) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\t\tuninstallApplication();\n\t\t\t\t\t\treturnMessage = getFormattedMessage(\"application_uninstalled_succesfully\",\n\t\t\t\t\t\t\t\tthis.applicationName);\n\t\t\t\t\t\tisDone = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinues = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\r\n\r\n\t\tsession.put(Constants.ACTIVE_APP, applicationName);\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(applicationName);\r\n\r\n\t\treturn returnMessage;\r\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void uninstallService() throws CLIException, InterruptedException,\n\t\t\tTimeoutException {\n\t\tMap<String, String> undeployServiceResponse = adminFacade.undeploy(getCurrentApplicationName(),\n\t\t\t\tserviceName, timeoutInMinutes);\n\t\tif (undeployServiceResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = undeployServiceResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t}","id":79115,"modified_method":"private void uninstallService() throws CLIException, InterruptedException,\n\t\t\tTimeoutException {\n\t\tMap<String, String> undeployServiceResponse = adminFacade.undeploy(getCurrentApplicationName(),\n\t\t\t\tserviceName, timeoutInMinutes);\n\t\tif (undeployServiceResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = undeployServiceResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes, UninstallService.TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!recipe.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", recipe.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (recipe.getName().endsWith(\".jar\") || recipe.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t} else if (recipe.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\n\t\t\t\t\n\t\t\t\tif (serviceFileName != null) {\n\t\t\t\t\tFile fullPathToRecipe = new File(recipe.getAbsolutePath() + \"/\" + serviceFileName);\n\t\t\t\t\tif (!fullPathToRecipe.exists()) {\n\t\t\t\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", fullPathToRecipe.getPath());\n\t\t\t\t\t}\n\t\t\t\t\tpackedFile = Packager.pack(fullPathToRecipe);\n\t\t\t\t\tservice = ServiceReader.readService(fullPathToRecipe);\n\t\t\t\t} else {\r\n\t\t\t\t\tpackedFile = Packager.pack(recipe);\n\t\t\t\t\tservice = ServiceReader.readService(recipe);\r\n\t\t\t\t}\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\n\t\t\tif (serviceFileName != null) {\n\t\t\t\tprops.setProperty(CloudifyConstants.CONTEXT_PROPERTY_SERVICE_FILE_NAME, serviceFileName);\n\t\t\t}\r\n\t\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\tserviceName = recipe.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.isEmpty()) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service == null || service.getCompute() == null) {\n\t\t\ttemplateName = \"\";\n\t\t} else {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t}\n\t\t\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile,\n\t\t\t\tcurrentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\tif (lifecycleEventContainerPollingID != null) {\n\t\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = this.adminFacade.\n\t\t\t\t\tgetLifecycleEventsPollingLatch(lifecycleEventContainerPollingID);\n\t\t\tboolean isDone = lifecycleEventsPollingLatch.waitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\twhile (!isDone) {\n\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\t//uninstallService();\n\t\t\t\t\tisDone = true;\n\t\t\t\t} else {\n\t\t\t\t\tisDone = lifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (recipe.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","id":79116,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!recipe.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", recipe.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (recipe.getName().endsWith(\".jar\") || recipe.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t} else if (recipe.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\n\t\t\t\t\n\t\t\t\tif (serviceFileName != null) {\n\t\t\t\t\tFile fullPathToRecipe = new File(recipe.getAbsolutePath() + \"/\" + serviceFileName);\n\t\t\t\t\tif (!fullPathToRecipe.exists()) {\n\t\t\t\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", fullPathToRecipe.getPath());\n\t\t\t\t\t}\n\t\t\t\t\tpackedFile = Packager.pack(fullPathToRecipe);\n\t\t\t\t\tservice = ServiceReader.readService(fullPathToRecipe);\n\t\t\t\t} else {\r\n\t\t\t\t\tpackedFile = Packager.pack(recipe);\n\t\t\t\t\tservice = ServiceReader.readService(recipe);\r\n\t\t\t\t}\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\n\t\t\tif (serviceFileName != null) {\n\t\t\t\tprops.setProperty(CloudifyConstants.CONTEXT_PROPERTY_SERVICE_FILE_NAME, serviceFileName);\n\t\t\t}\r\n\t\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.isEmpty()) {\r\n\t\t\tserviceName = recipe.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.isEmpty()) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service == null || service.getCompute() == null) {\n\t\t\ttemplateName = \"\";\n\t\t} else {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t}\n\t\t\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile,\n\t\t\t\tcurrentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\tString returnMessage = getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\n\t\tif (lifecycleEventContainerPollingID != null) {\n\t\t\tRestLifecycleEventsLatch lifecycleEventsPollingLatch = this.adminFacade.\n\t\t\t\t\tgetLifecycleEventsPollingLatch(lifecycleEventContainerPollingID, TIMEOUT_ERROR_MESSAGE);\n\t\t\tboolean isDone = false;\n\t\t\tboolean continues = false;\n\t\t\twhile (!isDone) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!continues) {\n\t\t\t\t\t\tlifecycleEventsPollingLatch.waitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlifecycleEventsPollingLatch.continueWaitForLifecycleEvents(timeoutInMinutes, TimeUnit.MINUTES);\n\t\t\t\t\t}\n\t\t\t\t\tisDone = true;\n\t\t\t\t} catch (TimeoutException e) {\n\t\t\t\t\tif (!(Boolean) session.get(Constants.INTERACTIVE_MODE)) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t\tboolean continueInstallation = promptWouldYouLikeToContinueQuestion();\n\t\t\t\t\tif (!continueInstallation) {\n\t\t\t\t\t\tuninstallService();\n\t\t\t\t\t\tisDone = true;\n\t\t\t\t\t\treturnMessage = getFormattedMessage(\"undeployed_successfully\", serviceName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinues = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (recipe.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn returnMessage;\r\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,\n\t\t\tTimeoutException, CLIException {\n\n\t\tList<String> applicationsList = null;\n\t\tboolean applicationsExist = false;\n\t\ttry {\n\t\t\tif (!adminFacade.isConnected()) {\n\t\t\t\tthrow new CLIException(\"Failed to fetch applications list. \"\n\t\t\t\t\t\t+ \"Client is not connected to the rest server.\");\n\t\t\t}\n\n\t\t\tapplicationsList = adminFacade.getApplicationsList();\n\t\t\t// If there existed other applications besides the management.\n\t\t\tapplicationsExist = applicationsList.size() > 1;\n\t\t} catch (final CLIException e) {\n\t\t\tif (!force) {\n\t\t\t\tthrow new CLIStatusException(e, \"failed_to_access_rest_before_teardown\");\n\t\t\t}\n\t\t\tfinal String errorMessage = \"Failed to fetch the currently deployed applications list.\"\n\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\tif (verbose) {\n\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\tpublishEvent(errorMessage + System.getProperty(\"line.separator\") + e.toString());\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\tpublishEvent(errorMessage);\n\t\t\t}\n\t\t\t// Suppress exception. continue with teardown.\n\t\t\treturn;\n\t\t}\n\n\t\tif (applicationsExist && !force) {\n\t\t\tthrow new CLIStatusException(\"apps_deployed_before_teardown_localcloud\", applicationsList.toString());\n\t\t}\n\t\tString uninstallMessage = ShellUtils.getMessageBundle().getString(\"uninstalling_applications_before_teardown\");\n\t\tpublishEvent(uninstallMessage);\n\t\tfor (final String appName : applicationsList) {\n\t\t\ttry {\n\t\t\t\tif (!appName.equals(MANAGEMENT_APPLICATION)) {\n\t\t\t\t\tlogger.fine(\"Uninstalling application \" + appName);\n\t\t\t\t\tMap<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName\n\t\t\t\t\t\t\t, (int) timeout);\n\t\t\t\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\t\t\t\tString pollingID = uninstallApplicationResponse\n\t\t\t\t\t\t.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\t\t\t\t((RestAdminFacade) this.adminFacade)\n\t\t\t\t\t\t.waitForLifecycleEvents(pollingID, (int) timeout);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpublishEvent(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (final CLIException e) {\n\t\t\t\tfinal String errorMessage = \"Application \" + appName + \" faild to uninstall.\"\n\t\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\t\tif (!force) {\n\t\t\t\t\tthrow new CLIStatusException(e, \"failed_to_uninstall_app_before_teardown\", appName);\n\t\t\t\t}\n\t\t\t\tif (verbose) {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\t\tpublishEvent(errorMessage);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (applicationsExist) {\n\t\t\twaitForUninstallApplications(timeout, timeunit);\n\t\t\tpublishEvent(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t\tlogger.fine(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t}\n\t}","id":79117,"modified_method":"private void uninstallApplications(final long timeout, final TimeUnit timeunit) throws InterruptedException,\n\t\t\tTimeoutException, CLIException {\n\n\t\tList<String> applicationsList = null;\n\t\tboolean applicationsExist = false;\n\t\ttry {\n\t\t\tif (!adminFacade.isConnected()) {\n\t\t\t\tthrow new CLIException(\"Failed to fetch applications list. \"\n\t\t\t\t\t\t+ \"Client is not connected to the rest server.\");\n\t\t\t}\n\n\t\t\tapplicationsList = adminFacade.getApplicationsList();\n\t\t\t// If there existed other applications besides the management.\n\t\t\tapplicationsExist = applicationsList.size() > 1;\n\t\t} catch (final CLIException e) {\n\t\t\tif (!force) {\n\t\t\t\tthrow new CLIStatusException(e, \"failed_to_access_rest_before_teardown\");\n\t\t\t}\n\t\t\tfinal String errorMessage = \"Failed to fetch the currently deployed applications list.\"\n\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\tif (verbose) {\n\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\tpublishEvent(errorMessage + System.getProperty(\"line.separator\") + e.toString());\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\tpublishEvent(errorMessage);\n\t\t\t}\n\t\t\t// Suppress exception. continue with teardown.\n\t\t\treturn;\n\t\t}\n\n\t\tif (applicationsExist && !force) {\n\t\t\tthrow new CLIStatusException(\"apps_deployed_before_teardown_localcloud\", applicationsList.toString());\n\t\t}\n\t\tString uninstallMessage = ShellUtils.getMessageBundle().getString(\"uninstalling_applications_before_teardown\");\n\t\tpublishEvent(uninstallMessage);\n\t\tfor (final String appName : applicationsList) {\n\t\t\ttry {\n\t\t\t\tif (!appName.equals(MANAGEMENT_APPLICATION)) {\n\t\t\t\t\tlogger.fine(\"Uninstalling application \" + appName);\n\t\t\t\t\tMap<String, String> uninstallApplicationResponse = adminFacade.uninstallApplication(appName\n\t\t\t\t\t\t\t, (int) timeout);\n\t\t\t\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\t\t\t\tString pollingID = uninstallApplicationResponse\n\t\t\t\t\t\t.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\t\t\t\t((RestAdminFacade) this.adminFacade)\n\t\t\t\t\t\t.waitForLifecycleEvents(pollingID, (int) timeout, UninstallApplication.TIMEOUT_ERROR_MESSAGE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpublishEvent(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t\t\t\t+ \"Check logs for more details.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (final CLIException e) {\n\t\t\t\tfinal String errorMessage = \"Application \" + appName + \" faild to uninstall.\"\n\t\t\t\t\t\t+ \" Continuing teardown-localcloud.\";\n\t\t\t\tif (!force) {\n\t\t\t\t\tthrow new CLIStatusException(e, \"failed_to_uninstall_app_before_teardown\", appName);\n\t\t\t\t}\n\t\t\t\tif (verbose) {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage, e);\n\t\t\t\t\tpublishEvent(errorMessage);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Level.FINE, errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (applicationsExist) {\n\t\t\twaitForUninstallApplications(timeout, timeunit);\n\t\t\tpublishEvent(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t\tlogger.fine(ShellUtils.getMessageBundle().getString(\"all_apps_removed_before_teardown\"));\n\t\t}\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private URL getUrlWithDefaultPort(final URL urlObj) throws MalformedURLException {\n\t\tStringBuilder url = new StringBuilder(urlObj.toString());\n\t\tfinal int portIndex = url.indexOf(\"/\", \"http://\".length());\n\t\turl.insert(portIndex, ':' + CloudifyConstants.DEFAULT_REST_PORT);\n\t\treturn new URL(url.toString());\n\t}","id":79118,"modified_method":"private URL getUrlWithDefaultPort(final URL urlObj) throws MalformedURLException {\n\t\tStringBuilder url = new StringBuilder(urlObj.toString());\n\t\tfinal int portIndex = url.indexOf(\"/\", \"http://\".length());\n\t\turl.insert(portIndex, ':' + Integer.toString(CloudifyConstants.DEFAULT_REST_PORT));\n\t\treturn new URL(url.toString());\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean waitForLifecycleEvents(final String pollingID, final int timeout) \n\t\t\tthrows CLIException, InterruptedException, TimeoutException {\n\t\tRestLifecycleEventsLatch restLifecycleEventsLatch = new RestLifecycleEventsLatch();\n\t\trestLifecycleEventsLatch.setPollingId(pollingID);\n\t\trestLifecycleEventsLatch.setRestClient(client);\n\t\treturn restLifecycleEventsLatch.waitForLifecycleEvents(timeout, TimeUnit.MINUTES);\n\t}","id":79119,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void waitForLifecycleEvents(final String pollingID, final int timeout, String timeoutMessage) \n\t\t\tthrows CLIException, InterruptedException, TimeoutException {\n\t\tRestLifecycleEventsLatch restLifecycleEventsLatch = new RestLifecycleEventsLatch();\n\t\trestLifecycleEventsLatch.setPollingId(pollingID);\n\t\trestLifecycleEventsLatch.setRestClient(client);\n\t\trestLifecycleEventsLatch.setTimeoutMessage(timeoutMessage);\n\t\trestLifecycleEventsLatch.waitForLifecycleEvents(timeout, TimeUnit.MINUTES);\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic RestLifecycleEventsLatch getLifecycleEventsPollingLatch(final String pollingID) {\t\n\t\tRestLifecycleEventsLatch restLifecycleEventsLatch = new RestLifecycleEventsLatch();\n\t\trestLifecycleEventsLatch.setPollingId(pollingID);\n\t\trestLifecycleEventsLatch.setRestClient(client);\n\t\treturn restLifecycleEventsLatch;\n\t}","id":79120,"modified_method":"@Override\n\tpublic RestLifecycleEventsLatch getLifecycleEventsPollingLatch(final String pollingID, String timeoutMessage) {\t\n\t\tRestLifecycleEventsLatch restLifecycleEventsLatch = new RestLifecycleEventsLatch();\n\t\trestLifecycleEventsLatch.setPollingId(pollingID);\n\t\trestLifecycleEventsLatch.setRestClient(client);\n\t\trestLifecycleEventsLatch.setTimeoutMessage(timeoutMessage);\n\t\treturn restLifecycleEventsLatch;\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Waits for lifecycle events. This method will poll the rest for installation lifecycle events \r\n\t * and print the new events to the CLI console.\r\n\t * \r\n\t * @param timeout\r\n\t * @param timeUnit\r\n\t * @return\r\n\t * @throws InterruptedException\r\n\t * @throws TimeoutException\r\n\t * @throws CLIException\r\n\t */\r\n\tpublic boolean waitForLifecycleEvents(final int timeout, TimeUnit timeUnit) \r\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\r\n\r\n\t\tthis.endTime = System.currentTimeMillis() + timeUnit.toMillis(timeout);\r\n\t\t\r\n\t\twhile (System.currentTimeMillis() < this.endTime) {\r\n\t\t\turl = \"/service/lifecycleEventContainerID/\" + pollingID\r\n\t\t\t\t\t+ \"/cursor/\" + cursor;\r\n\t\t\ttry {\r\n\t\t\t\tlifecycleEventLogs = (Map<String, Object>) client.get(url);\r\n\t\t\t} catch (final ErrorStatusException e) {\r\n\t\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\r\n\t\t\t}\r\n\r\n\t\t\tList<String> events = (List<String>) lifecycleEventLogs.get(CloudifyConstants.LIFECYCLE_LOGS);\r\n\t\t\tthis.cursor = (Integer) lifecycleEventLogs.get(CloudifyConstants.CURSOR_POS);\r\n\t\t\tthis.isDone = (Boolean) lifecycleEventLogs.get(CloudifyConstants.IS_TASK_DONE);\r\n\t\t\tthis.exceptionOnServer = (Boolean) lifecycleEventLogs.get(CloudifyConstants.POLLING_EXCEPTION);\r\n\t\t\tthis.remoteTaskLeaseExpiration = Long.valueOf((String) lifecycleEventLogs.\r\n\t\t\t\t\tget(CloudifyConstants.SERVER_POLLING_TASK_EXPIRATION_MILLI)) + System.currentTimeMillis();\r\n\r\n\t\t\tif (events == null) {\r\n\t\t\t\tdisplayer.printNoChange();\r\n\t\t\t} else {\r\n\t\t\t\tdisplayer.printEvents(events);\r\n\t\t\t}\r\n\r\n\t\t\tif (isDone) {\r\n\t\t\t\tif (exceptionOnServer) {\r\n\t\t\t\t\tthrow new CLIException(\"Event polling task failed on remote server.\" \r\n\t\t\t\t\t\t\t+ \"For more information regarding the installation, please refer to full logs\");\r\n\t\t\t\t}\r\n\t\t\t\tdisplayer.eraseCurrentLine();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tThread.sleep(pollingInterval);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":79121,"modified_method":"/**\r\n\t * Waits for lifecycle events. This method will poll the rest for installation lifecycle events \r\n\t * and print the new events to the CLI console.\r\n\t * \r\n\t * @param timeout\r\n\t * @param timeUnit\r\n\t * @return\r\n\t * @throws InterruptedException\r\n\t * @throws TimeoutException\r\n\t * @throws CLIException\r\n\t */\r\n\tpublic void waitForLifecycleEvents(final int timeout, TimeUnit timeUnit) \r\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\r\n\t\tcreateConditionLatch(timeout, TimeUnit.MINUTES).waitFor(new Predicate() {\r\n\t\t\t//\t\tthis.endTime = System.currentTimeMillis() + timeUnit.toMillis(timeout);\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean isDone() throws CLIException, InterruptedException {\r\n\t\t\t\turl = \"/service/lifecycleEventContainerID/\" + pollingID\r\n\t\t\t\t\t\t+ \"/cursor/\" + cursor;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlifecycleEventLogs = (Map<String, Object>) client.get(url);\r\n\t\t\t\t} catch (final ErrorStatusException e) {\r\n\t\t\t\t\tthrow new CLIStatusException(e, e.getReasonCode(), e.getArgs());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tList<String> events = (List<String>) lifecycleEventLogs.get(CloudifyConstants.LIFECYCLE_LOGS);\r\n\t\t\t\tcursor = (Integer) lifecycleEventLogs.get(CloudifyConstants.CURSOR_POS);\r\n\t\t\t\tisDone = (Boolean) lifecycleEventLogs.get(CloudifyConstants.IS_TASK_DONE);\r\n\t\t\t\texceptionOnServer = (Boolean) lifecycleEventLogs.get(CloudifyConstants.POLLING_EXCEPTION);\r\n\t\t\t\tremoteTaskLeaseExpiration = Long.valueOf((String) lifecycleEventLogs.\r\n\t\t\t\t\t\tget(CloudifyConstants.SERVER_POLLING_TASK_EXPIRATION_MILLI)) + System.currentTimeMillis();\r\n\r\n\t\t\t\tif (events == null) {\r\n\t\t\t\t\tdisplayer.printNoChange();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdisplayer.printEvents(events);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isDone) {\r\n\t\t\t\t\tif (exceptionOnServer) {\r\n\t\t\t\t\t\tthrow new CLIException(\"Event polling task failed on remote server.\" \r\n\t\t\t\t\t\t\t\t+ \"For more information regarding the installation, please refer to full logs\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdisplayer.eraseCurrentLine();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t//\t\t\tThread.sleep(pollingInterval);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Continue an already started polling task. Used for when polling was interrupted on the client side.\r\n\t * \r\n\t * @param timeout\r\n\t * @param timeUnit\r\n\t * @return\r\n\t * @throws InterruptedException\r\n\t * @throws TimeoutException\r\n\t * @throws CLIException if the polling task has expired on the remote server side\r\n\t */\r\n\tpublic boolean continueWaitForLifecycleEvents(final int timeout, final TimeUnit timeUnit) \r\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\r\n\t\tif (System.currentTimeMillis() > this.remoteTaskLeaseExpiration) {\r\n\t\t\tthrow new CLIException(\"Events polling task has expired on remote server side\");\r\n\t\t}\r\n\t\treturn waitForLifecycleEvents(timeout, timeUnit);\r\n\t}","id":79122,"modified_method":"/**\r\n\t * Continue an already started polling task. Used for when polling was interrupted on the client side.\r\n\t * \r\n\t * @param timeout\r\n\t * @param timeUnit\r\n\t * @return\r\n\t * @throws InterruptedException\r\n\t * @throws TimeoutException\r\n\t * @throws CLIException if the polling task has expired on the remote server side\r\n\t */\r\n\tpublic void continueWaitForLifecycleEvents(final int timeout, final TimeUnit timeUnit) \r\n\t\t\tthrows InterruptedException, TimeoutException, CLIException {\r\n\t\tif (System.currentTimeMillis() > this.remoteTaskLeaseExpiration) {\r\n\t\t\tthrow new CLIException(\"Events polling task has expired on remote server side\");\r\n\t\t}\r\n\t\twaitForLifecycleEvents(timeout, timeUnit);\r\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tprotected Object doExecute() throws Exception {\n\t\tString applicationName = this.getCurrentApplicationName();\n\t\tif (applicationName == null) {\n\t\t\tapplicationName = CloudifyConstants.DEFAULT_APPLICATION_NAME;\n\t\t}\n\n\t\tfinal int initialNumberOfInstances = adminFacade.getInstanceList(applicationName, serviceName).size();\n\t\tif (initialNumberOfInstances == count) {\n\t\t\treturn getFormattedMessage(\"num_instanes_already_met\", count);\n\t\t}\n\n\t\tMap<String, String> response = adminFacade.setInstances(applicationName, serviceName, count, timeout);\n\n\t\tif (response.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = response.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tboolean waitForLifecycleEvents = this.adminFacade.waitForLifecycleEvents(pollingID, timeout);\n\t\t\tif (!waitForLifecycleEvents) {\n\t\t\t\tthrow new TimeoutException(TIMEOUT_ERROR_MESSAGE);\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.info(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t\t\n\t\treturn getFormattedMessage(\"set_instances_completed_successfully\", serviceName, count);\n\t}","id":79123,"modified_method":"@Override\n\tprotected Object doExecute() throws Exception {\n\t\tString applicationName = this.getCurrentApplicationName();\n\t\tif (applicationName == null) {\n\t\t\tapplicationName = CloudifyConstants.DEFAULT_APPLICATION_NAME;\n\t\t}\n\n\t\tfinal int initialNumberOfInstances = adminFacade.getInstanceList(applicationName, serviceName).size();\n\t\tif (initialNumberOfInstances == count) {\n\t\t\treturn getFormattedMessage(\"num_instanes_already_met\", count);\n\t\t}\n\n\t\tMap<String, String> response = adminFacade.setInstances(applicationName, serviceName, count, timeout);\n\n\t\tif (response.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = response.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeout, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tlogger.info(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\t\t\n\t\treturn getFormattedMessage(\"set_instances_completed_successfully\", serviceName, count);\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\r\n\t\tif (!askUninstallConfirmationQuestion()) {\r\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\r\n\t\t}\r\n\r\n\t\t// we need to look at all containers since the application already undeployed and we cannot get only\r\n\t\t// the application containers\r\n\t\tfinal Set<String> containerIdsOfApplication = ((RestAdminFacade) adminFacade)\r\n\t\t.getGridServiceContainerUidsForApplication(applicationName);\r\n\t\tif (verbose) {\r\n\t\t\tlogger.info(\"Containers running PUs of application \" + applicationName + \":\" + containerIdsOfApplication);\r\n\t\t}\r\n\r\n\t\tMap<String, String> uninstallApplicationResponse = this.adminFacade\n\t\t.uninstallApplication(this.applicationName, timeoutInMinutes);\n\n\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = uninstallApplicationResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tboolean waitForLifecycleEvents = this.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes);\n\t\t\tif (!waitForLifecycleEvents) {\n\t\t\t\tthrow new TimeoutException(TIMEOUT_ERROR_MESSAGE);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\tsession.put(Constants.ACTIVE_APP, \"default\");\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(\"default\");\r\n\t\treturn getFormattedMessage(\"application_uninstalled_succesfully\", this.applicationName);\r\n\t}","id":79124,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\r\n\t\tif (!askUninstallConfirmationQuestion()) {\r\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\r\n\t\t}\r\n\r\n\t\t// we need to look at all containers since the application already undeployed and we cannot get only\r\n\t\t// the application containers\r\n\t\tfinal Set<String> containerIdsOfApplication = ((RestAdminFacade) adminFacade)\r\n\t\t.getGridServiceContainerUidsForApplication(applicationName);\r\n\t\tif (verbose) {\r\n\t\t\tlogger.info(\"Containers running PUs of application \" + applicationName + \":\" + containerIdsOfApplication);\r\n\t\t}\r\n\r\n\t\tMap<String, String> uninstallApplicationResponse = this.adminFacade\n\t\t.uninstallApplication(this.applicationName, timeoutInMinutes);\n\n\t\tif (uninstallApplicationResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)) {\n\t\t\tString pollingID = uninstallApplicationResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" \n\t\t\t+ \"Check logs for more details.\");\n\t\t}\n\r\n\t\tsession.put(Constants.ACTIVE_APP, \"default\");\r\n\t\tGigaShellMain.getInstance().setCurrentApplicationName(\"default\");\r\n\t\treturn getFormattedMessage(\"application_uninstalled_succesfully\", this.applicationName);\r\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tif (!askUninstallConfirmationQuestion()) {\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\n\t\t}\n\n\t\tfinal Set<String> containerIdsOfService = ((RestAdminFacade) adminFacade)\n\t\t.getGridServiceContainerUidsForService(getCurrentApplicationName(), serviceName);\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Found containers: \" + containerIdsOfService);\n\t\t}\n\n\t\tMap<String, String> undeployServiceResponse = adminFacade.undeploy(getCurrentApplicationName(), serviceName, timeoutInMinutes);\n\t\tif (undeployServiceResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)){\n\t\t\tString pollingID = undeployServiceResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tboolean waitForLifecycleEvents = this.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes);\n\t\t\tif (!waitForLifecycleEvents) {\n\t\t\t\tthrow new TimeoutException(TIMEOUT_ERROR_MESSAGE);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\t\t\"Check logs for more details.\");\n\t\t}\n\t\treturn getFormattedMessage(\"undeployed_successfully\", serviceName);\n\t}","id":79125,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected Object doExecute() throws Exception {\n\n\t\tif (!askUninstallConfirmationQuestion()) {\n\t\t\treturn getFormattedMessage(\"uninstall_aborted\");\n\t\t}\n\n\t\tfinal Set<String> containerIdsOfService = ((RestAdminFacade) adminFacade)\n\t\t.getGridServiceContainerUidsForService(getCurrentApplicationName(), serviceName);\n\t\tif (verbose) {\n\t\t\tlogger.info(\"Found containers: \" + containerIdsOfService);\n\t\t}\n\n\t\tMap<String, String> undeployServiceResponse = adminFacade.undeploy(getCurrentApplicationName(), serviceName, timeoutInMinutes);\n\t\tif (undeployServiceResponse.containsKey(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID)){\n\t\t\tString pollingID = undeployServiceResponse.get(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID);\n\t\t\tthis.adminFacade.waitForLifecycleEvents(pollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\t\t\"Check logs for more details.\");\n\t\t}\n\t\treturn getFormattedMessage(\"undeployed_successfully\", serviceName);\n\t}","commit_id":"debaa172bcda9e6bb0ff41779a6e50fae6a82cdd","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    public void connect(final String user, final String password, final String url, final boolean isSecureConnection)\r\n    \t\tthrows CLIException {\r\n        if (!isConnected()) {\r\n            doConnect(user, password, url, isSecureConnection);\r\n            this.connected = true;\r\n        } else {\r\n            throw new CLIStatusException(\"already_connected\");\r\n        }\r\n    }","id":79126,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    public void connect(final String user, final String password, final String url, final boolean sslUsed)\r\n    \t\tthrows CLIException {\r\n        if (!isConnected()) {\r\n            doConnect(user, password, url, sslUsed);\r\n            this.connected = true;\r\n        } else {\r\n            throw new CLIStatusException(\"already_connected\");\r\n        }\r\n    }","commit_id":"8c304a9bf3ffea172b6d892c037d2ba61a9d1cb4","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void setSecurityMode() {\r\n\t\tif (StringUtils.isNotBlank(secured)) {\r\n\t\t\tif (secured.equalsIgnoreCase(\"true\")\r\n\t\t\t\t\t||  secured.equalsIgnoreCase(\"yes\")) {\r\n\t\t\t\t//enable security\r\n\t\t\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SSL));\r\n\t\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SSL;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SECURE));\r\n\t\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SECURE;\r\n\t\t\t\t}\r\n\t\t\t} else if (secured.equalsIgnoreCase(\"false\")\r\n\t\t\t\t\t||  secured.equalsIgnoreCase(\"no\")) {\r\n\t\t\t\t//disable security\r\n\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_NON_SECURE));\r\n\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-secured' can accept only true/false.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_NON_SECURE)) {\r\n\t\t\tif (StringUtils.isNotBlank(username)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-user' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(password)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-password' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(securityFilePath)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-securityfile' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystore)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystore' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystorePassword' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Password is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Username is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystorePassword is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystore is missing or empty\");\r\n\t\t}\r\n\r\n\t}","id":79127,"modified_method":"private void setSecurityMode() {\r\n\t\t\r\n\t\tif (secured) {\r\n\t\t\t//enable security\r\n\t\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SSL));\r\n\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SSL;\r\n\t\t\t} else {\r\n\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SECURE));\r\n\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SECURE;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//disable security\r\n\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_NON_SECURE));\r\n\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;\r\n\t\t}\r\n\t\t\r\n\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_NON_SECURE)) {\r\n\t\t\tif (StringUtils.isNotBlank(username)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-user' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(password)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-password' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(securityFilePath)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-securityfile' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystore)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystore' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystorePassword' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Password is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Username is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystorePassword is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystore is missing or empty\");\r\n\t\t}\r\n\r\n\t}","commit_id":"8c304a9bf3ffea172b6d892c037d2ba61a9d1cb4","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void setSecurityMode() {\r\n\t\tif (StringUtils.isNotBlank(secured)) {\r\n\t\t\tif (secured.equalsIgnoreCase(\"true\")\r\n\t\t\t\t\t||  secured.equalsIgnoreCase(\"yes\")) {\r\n\t\t\t\t//enable security\r\n\t\t\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SSL));\r\n\t\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SSL;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SECURE));\r\n\t\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SECURE;\r\n\t\t\t\t}\r\n\t\t\t} else if (secured.equalsIgnoreCase(\"false\")\r\n\t\t\t\t\t||  secured.equalsIgnoreCase(\"no\")) {\r\n\t\t\t\t//disable security\r\n\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_NON_SECURE));\r\n\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-secured' can accept only true/false.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_NON_SECURE)) {\r\n\t\t\tif (StringUtils.isNotBlank(username)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-user' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(password)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-password' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(securityFilePath)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-securityfile' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystore)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystore' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystorePassword' is only valid when '-secured' is set to true\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Password is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Username is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystorePassword is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystore is missing or empty\");\r\n\t\t}\r\n\t}","id":79128,"modified_method":"private void setSecurityMode() {\r\n\r\n\t\tif (secured) {\r\n\t\t\t//enable security\r\n\t\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SSL));\r\n\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SSL;\r\n\t\t\t} else {\r\n\t\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_SECURE));\r\n\t\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_SECURE;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//disable security\r\n\t\t\tlogger.info(getFormattedMessage(CloudifyErrorMessages.SETTING_SERVER_SECURITY_PROFILE.getName(),\r\n\t\t\t\t\tCloudifyConstants.SPRING_PROFILE_NON_SECURE));\r\n\t\t\tsecurityProfile = CloudifyConstants.SPRING_PROFILE_NON_SECURE;\r\n\t\t}\r\n\r\n\t\t\r\n\t\tif (securityProfile.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_NON_SECURE)) {\r\n\t\t\tif (StringUtils.isNotBlank(username)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-user' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(password)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-password' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(securityFilePath)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-securityfile' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystore)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystore' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"'-keystorePassword' is only valid when '-secured' is set\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(username) && StringUtils.isBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Password is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(username) && StringUtils.isNotBlank(password)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Username is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isNotBlank(keystore) && StringUtils.isBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystorePassword is missing or empty\");\r\n\t\t}\r\n\t\t\r\n\t\tif (StringUtils.isBlank(keystore) && StringUtils.isNotBlank(keystorePassword)) {\r\n\t\t\tthrow new IllegalArgumentException(\"keystore is missing or empty\");\r\n\t\t}\r\n\t}","commit_id":"8c304a9bf3ffea172b6d892c037d2ba61a9d1cb4","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    protected Object doExecute() throws Exception {\r\n        final AdminFacade adminFacade = (AdminFacade) session.get(Constants.ADMIN_FACADE);\r\n        adminFacade.connect(user, password, url, secured);\r\n        return getFormattedMessage(\"connected_successfully\", Color.GREEN);\r\n    }","id":79129,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    @Override\r\n    protected Object doExecute() throws Exception {\r\n        final AdminFacade adminFacade = (AdminFacade) session.get(Constants.ADMIN_FACADE);\r\n        adminFacade.connect(user, password, url, ssl);\r\n        String formattedMessage;\r\n        if (ssl) {\r\n        \tformattedMessage = getFormattedMessage(\"connected_successfully_with_ssl\", Color.GREEN);\r\n        } else {\r\n        \tformattedMessage = getFormattedMessage(\"connected_successfully\", Color.GREEN);\r\n        }\r\n        \r\n        return formattedMessage;\r\n    }","commit_id":"8c304a9bf3ffea172b6d892c037d2ba61a9d1cb4","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void doConnect(final String user, final String password, final String url, final boolean isSecureConnection)\n\t\t\tthrows CLIException {\n\t\t\n\t\tURL urlObj;\n\n\t\ttry {\n\t\t\turlObj = new URL(ShellUtils.getFormattedRestUrl(url, isSecureConnection));\n\t\t\tclient = new GSRestClient(user, password, urlObj, PlatformVersion.getVersionNumber());\n\t\t\t// test connection\n\t\t\tclient.get(SERVICE_CONTROLLER_URL + \"testrest\");\n\t\t} catch (final MalformedURLException e) {\n\t\t\t\tthrow new CLIStatusException(\"could_not_parse_url\", url, e);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e);\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\t}","id":79130,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void doConnect(final String user, final String password, final String url, final boolean sslUsed)\n\t\t\tthrows CLIException {\n\t\t\n\t\tURL urlObj;\n\n\t\ttry {\n\t\t\turlObj = new URL(ShellUtils.getFormattedRestUrl(url, sslUsed));\n\t\t\tclient = new GSRestClient(user, password, urlObj, PlatformVersion.getVersionNumber());\n\t\t\t// test connection\n\t\t\tclient.get(SERVICE_CONTROLLER_URL + \"testrest\");\n\t\t} catch (final MalformedURLException e) {\n\t\t\t\tthrow new CLIStatusException(\"could_not_parse_url\", url, e);\n\t\t} catch (final ErrorStatusException e) {\n\t\t\tthrow new CLIStatusException(e);\n\t\t} catch (final RestException e) {\n\t\t\tthrow new CLIException(e);\n\t\t}\n\t}","commit_id":"8c304a9bf3ffea172b6d892c037d2ba61a9d1cb4","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"protected void assertDoesNotContain( String message, String full, String substring )\n    {\n        if ( full == null || full.indexOf( substring ) != -1 )\n        {\n            StringBuffer buf = new StringBuffer();\n            if ( message != null )\n            {\n                buf.append( message );\n            }\n            buf.append( \". \" );\n            buf.append( \"Unexpected \\\"\" );\n            buf.append( substring );\n            buf.append( \"\\\" found\" );\n        }\n    }","id":79131,"modified_method":"protected void assertDoesNotContain( String message, String full, String substring )\n    {\n        if ( full == null || full.indexOf( substring ) != -1 )\n        {\n            StringBuffer buf = new StringBuffer();\n            if ( message != null )\n            {\n                buf.append( message );\n            }\n            buf.append( \". \" );\n            buf.append( \"Unexpected \\\"\" );\n            buf.append( substring );\n            buf.append( \"\\\" found\" );\n            fail( buf.toString() );\n        }\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param outputDirectory TODO\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources, String outputDirectory )\n        throws MojoExecutionException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, //$NON-NLS-1$  \n                                                                             outputDirectory, false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"org.eclipse.jdt.launching.JRE_CONTAINER\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        List artifacts = project.getTestArtifacts();\n\n        // @todo direct optional artifacts are not included in the list returned by project.getTestArtifacts()\n        // .classpath should include ANY direct dependency, and optional dependencies are required to compile\n        Set depArtifacts = project.getDependencyArtifacts();\n        for ( Iterator it = depArtifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            if ( artifact.isOptional() && !artifacts.contains( artifact ) )\n            {\n                try\n                {\n                    artifactResolver.resolve( artifact, remoteArtifactRepositories, localRepository );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    log.error( \"Unable to resolve optional artifact \" + artifact.getId() );\n                    continue;\n                }\n                catch ( ArtifactNotFoundException e )\n                {\n                    log.error( \"Unable to resolve optional artifact \" + artifact.getId() );\n                    continue;\n                }\n                artifacts.add( artifact );\n            }\n        }\n\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                               artifactFactory, remoteArtifactRepositories, downloadSources );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","id":79132,"modified_method":"/**\n     * @param outputDirectory TODO\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources, String outputDirectory )\n        throws MojoExecutionException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, //$NON-NLS-1$  \n                                                                             outputDirectory, false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"org.eclipse.jdt.launching.JRE_CONTAINER\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        List artifacts = project.getTestArtifacts();\n\n        EclipseUtils.fixMissingOptionalArtifacts( artifacts, project.getDependencyArtifacts(), localRepository,\n                                                  artifactResolver, remoteArtifactRepositories, log );\n\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                               artifactFactory, remoteArtifactRepositories, downloadSources );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void write()\n        throws MojoExecutionException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs =\n            EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog(), outputDirectory );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources,\n                                                      outputDirectory );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, project );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, project, reactorArtifacts, sourceDirs,\n                                                       localRepository );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","id":79133,"modified_method":"public void write()\n        throws MojoExecutionException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs =\n            EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog(), outputDirectory );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources,\n                                                      outputDirectory );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, project );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, project, reactorArtifacts, sourceDirs,\n                                                       localRepository,artifactResolver,\n                                                       remoteArtifactRepositories );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void checkModule2Classpath( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String classpath = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include all\n        assertContains( \"Invalid classpath\", classpath, \"/direct-compile\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-test\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-sysdep\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-optional\" );\n\n        // referenced project: no deps!\n        assertContains( \"Invalid classpath\", classpath, \"/module-1\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-sysdep\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid classpath\", classpath, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-system\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-system\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-optional\" );\n    }","id":79134,"modified_method":"private void checkModule2Classpath( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String classpath = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include all\n        assertContains( \"Invalid classpath\", classpath, \"/direct-compile\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-test\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-sysdep\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-optional\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-provided\" );\n\n        // referenced project: not required, but it's not a problem to have them included\n        assertContains( \"Invalid classpath\", classpath, \"/module-1\" );\n        // assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-compile\" );\n        // assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-sysdep\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-optional\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid classpath\", classpath, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-optional\" );\n        // @todo should this be included? see MNG-514\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid classpath\", classpath, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-optional\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-provided\" );\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void checkModule2Wtpmodules( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String classpath = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include all\n        assertContains( \"Invalid wtpmodules\", classpath, \"/direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/direct-test\" );\n        assertContains( \"Invalid wtpmodules\", classpath, \"/direct-system\" );\n        assertContains( \"Invalid wtpmodules\", classpath, \"/direct-optional\" );\n\n        // referenced project: only runtime deps\n        assertContains( \"Invalid wtpmodules\", classpath, \"/module-1\" );\n        assertContains( \"Invalid wtpmodules\", classpath, \"/refproject-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/refproject-system\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/refproject-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid wtpmodules\", classpath, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-direct-system\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-direct-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-system\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-optional\" );\n    }","id":79135,"modified_method":"private void checkModule2Wtpmodules( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String wtpmodules = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include only runtime (also optional) dependencies\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/direct-test\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/direct-sysdep\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/direct-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/direct-provided\" );\n\n        // referenced project: only runtime deps\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/module-1\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/refproject-compile\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/refproject-sysdep\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/refproject-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/refproject-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-provided\" );\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Convenience method to create a m2 command line from a given working directory.\n     *\n     * @param workingDir a not null working directory.\n     * @return the m2 command line\n     * @throws Exception any exception caught is thrown during tests\n     */\n    protected Commandline createMaven2CommandLine( File workingDir )\n        throws Exception\n    {\n\n        assertNotNull( \"workingDir can't be null\", workingDir );\n        assertTrue( \"workingDir must exist\", workingDir.exists() );\n\n        // read default settings and extract local repository path\n        MavenSettingsBuilder settingsBuilder = (MavenSettingsBuilder) lookup( MavenSettingsBuilder.ROLE );\n        Settings defaultSettings = settingsBuilder.buildSettings();\n\n        // prepare a temporary settings.xml\n        File settings = File.createTempFile( \"settings\", \".xml\" );\n        settings.deleteOnExit();\n        Writer w = new FileWriter( settings );\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n        writer.startElement( \"settings\" );\n\n        // keep default local repository\n        writer.startElement( \"localRepository\" );\n        writer.writeText( defaultSettings.getLocalRepository() );\n        writer.endElement();\n\n        writer.startElement( \"interactiveMode\" );\n        writer.writeText( \"false\" );\n        writer.endElement();\n\n        writer.startElement( \"mirrors\" );\n        writer.startElement( \"mirror\" );\n\n        // add a file mirror, so that dependencies are loaded from the plugin directory\n        writer.startElement( \"id\" );\n        writer.writeText( \"localtest\" );\n        writer.endElement();\n        writer.startElement( \"url\" );\n        writer.writeText( \"file://\" + getBasedir().replace( '\\\\', '/' ) + \"/src/test/m2repo\" );\n        writer.endElement();\n        writer.startElement( \"mirrorOf\" );\n        writer.writeText( \"central\" );\n        writer.endElement();\n\n        writer.endElement();\n        writer.endElement();\n\n        writer.endElement();\n        IOUtil.close( w );\n\n        Commandline cmd = new Commandline();\n\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n\n        cmd.setExecutable( \"mvn\" );\n        cmd.createArgument().setValue( \"-s\" + settings.getAbsolutePath() );\n        cmd.createArgument().setValue( \"-e\" );\n\n        cmd.createArgument().setValue( \"eclipse:clean\" );\n        cmd.createArgument().setValue( \"eclipse:eclipse\" );\n\n        return cmd;\n    }","id":79136,"modified_method":"/**\n     * Convenience method to create a m2 command line from a given working directory.\n     *\n     * @param workingDir a not null working directory.\n     * @return the m2 command line\n     * @throws Exception any exception caught is thrown during tests\n     */\n    protected Commandline createMaven2CommandLine( File workingDir )\n        throws Exception\n    {\n\n        assertNotNull( \"workingDir can't be null\", workingDir );\n        assertTrue( \"workingDir must exist\", workingDir.exists() );\n\n        // read default settings and extract local repository path\n        MavenSettingsBuilder settingsBuilder = (MavenSettingsBuilder) lookup( MavenSettingsBuilder.ROLE );\n        Settings defaultSettings = settingsBuilder.buildSettings();\n\n        String settingsPath = createTestSettings( defaultSettings );\n\n        Commandline cmd = new Commandline();\n\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n\n        cmd.setExecutable( \"mvn\" );\n        cmd.createArgument().setValue( \"-s\" + settingsPath );\n        cmd.createArgument().setValue( \"-e\" );\n\n        cmd.createArgument().setValue( \"eclipse:clean\" );\n        cmd.createArgument().setValue( \"eclipse:eclipse\" );\n\n        return cmd;\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testMasterProject()\n        throws Exception\n    {\n        File basedir = getTestFile( \"src/test/projects/master-test\" );\n\n        executeMaven2CommandLine( basedir );\n\n        assertFileEquals( null, new File( basedir, \"module-1/project\" ), new File( basedir, \"module-1/.project\" ) );\n        assertFileEquals( null, new File( basedir, \"module-1/classpath\" ), new File( basedir, \"module-1/.classpath\" ) );\n        assertFileEquals( null, new File( basedir, \"module-1/wtpmodules\" ), new File( basedir, \"module-1/.wtpmodules\" ) );\n\n        // the real test: this should include any sort of direct/transitive dependency handled by mvn\n        assertFileEquals( null, new File( basedir, \"module-2/project\" ), new File( basedir, \"module-2/.project\" ) );\n\n        // manual check, easier to handle\n        checkModule2Classpath( new File( basedir, \"module-2/.classpath\" ) );\n\n        // manual check, easier to handle\n        checkModule2Wtpmodules( new File( basedir, \"module-2/.wtpmodules\" ) );\n\n    }","id":79137,"modified_method":"/**\n     * Test using a command line. Should be replaced by the embedder test.\n     */\n    public void testMasterProject()\n        throws Exception\n    {\n        executeMaven2CommandLine( basedir );\n        compareFiles();\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static void fixSystemScopeArtifacts( Collection artifacts, Collection dependencies )\n    {\n        // fix path for system dependencies.Artifact.getFile() returns a wrong path in mvn 2.0\n        for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n            {\n                String groupid = artifact.getGroupId();\n                String artifactId = artifact.getArtifactId();\n\n                for ( Iterator depIt = dependencies.iterator(); depIt.hasNext(); )\n                {\n                    Dependency dep = (Dependency) depIt.next();\n                    if ( Artifact.SCOPE_SYSTEM.equals( dep.getScope() ) && groupid.equals( dep.getGroupId() )\n                        && artifactId.equals( dep.getArtifactId() ) )\n                    {\n                        artifact.setFile( new File( dep.getSystemPath() ) );\n                        break;\n                    }\n                }\n            }\n        }\n    }","id":79138,"modified_method":"/**\n     * @todo MNG-1379 Wrong path for artifacts with system scope\n     * Artifacts with a system scope have a wrong path in mvn 2.0. This is a temporary workaround.\n     */\n    public static void fixSystemScopeArtifacts( Collection artifacts, Collection dependencies )\n    {\n        // fix path for system dependencies.Artifact.getFile() returns a wrong path in mvn 2.0\n        for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n            {\n                String groupid = artifact.getGroupId();\n                String artifactId = artifact.getArtifactId();\n\n                for ( Iterator depIt = dependencies.iterator(); depIt.hasNext(); )\n                {\n                    Dependency dep = (Dependency) depIt.next();\n                    if ( Artifact.SCOPE_SYSTEM.equals( dep.getScope() ) && groupid.equals( dep.getGroupId() )\n                        && artifactId.equals( dep.getArtifactId() ) )\n                    {\n                        artifact.setFile( new File( dep.getSystemPath() ) );\n                        break;\n                    }\n                }\n            }\n        }\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void writeWarSpecificResources( XMLWriter writer, File basedir, MavenProject project,\n                                           List referencedReactorArtifacts, ArtifactRepository localRepository )\n    {\n\n        String warSourceDirectory = EclipseUtils.getPluginSetting( project, \"maven-war-plugin\", //$NON-NLS-1$\n                                                                   \"warSourceDirectory\", //$NON-NLS-1$\n                                                                   \"/src/main/webapp\" ); //$NON-NLS-1$\n\n        writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-path\", \"/\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"source-path\", //$NON-NLS-1$\n                             EclipseUtils.toRelativeAndFixSeparator( basedir, warSourceDirectory, false ) );\n        writer.endElement();\n\n        Set artifacts = project.getArtifacts();\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        ScopeArtifactFilter scopeFilter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME );\n\n        // dependencies\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            String type = artifact.getType();\n\n            if ( ( scopeFilter.include( artifact ) || Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n                && ( \"jar\".equals( type ) || \"ejb\".equals( type ) || \"ejb-client\".equals( type ) ) )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository );\n            }\n        }\n    }","id":79139,"modified_method":"private void writeWarSpecificResources( XMLWriter writer, File basedir, MavenProject project,\n                                           List referencedReactorArtifacts, ArtifactRepository localRepository,\n                                           ArtifactResolver artifactResolver, List remoteArtifactRepositories )\n    {\n\n        String warSourceDirectory = EclipseUtils.getPluginSetting( project, \"maven-war-plugin\", //$NON-NLS-1$\n                                                                   \"warSourceDirectory\", //$NON-NLS-1$\n                                                                   \"/src/main/webapp\" ); //$NON-NLS-1$\n\n        writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-path\", \"/\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"source-path\", //$NON-NLS-1$\n                             EclipseUtils.toRelativeAndFixSeparator( basedir, warSourceDirectory, false ) );\n        writer.endElement();\n\n        Set artifacts = project.getArtifacts();\n\n        EclipseUtils.fixMissingOptionalArtifacts( artifacts, project.getDependencyArtifacts(), localRepository,\n                                                  artifactResolver, remoteArtifactRepositories, log );\n\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        ScopeArtifactFilter scopeFilter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME );\n\n        // dependencies\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            String type = artifact.getType();\n\n            if ( ( scopeFilter.include( artifact ) || Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n                && ( \"jar\".equals( type ) || \"ejb\".equals( type ) || \"ejb-client\".equals( type ) ) )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository );\n            }\n        }\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void write( File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, ArtifactRepository localRepository )\n        throws MojoExecutionException\n    {\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".wtpmodules\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"project-modules\" ); //$NON-NLS-1$\n        writer.addAttribute( \"id\", \"moduleCoreId\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n        writer.startElement( \"wb-module\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-name\", project.getArtifactId() ); //$NON-NLS-1$\n\n        writer.startElement( \"module-type\" ); //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            // <module-type module-type-id=\"jst.web\">\n            //   <version>2.4<\/version>\n            //   <property name=\"context-root\" value=\"magnolia\">\n            //   <\/property>\n            // <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.web\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n\n            // defaults to 2.4, try to detect real version from dependencies\n            String servletVersion = \"2.4\"; //$NON-NLS-1$\n\n            for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n                if ( \"servletapi\".equals( artifact.getArtifactId() ) //$NON-NLS-1$\n                    || \"geronimo-spec-servlet\".equals( artifact.getArtifactId() ) ) //$NON-NLS-1$\n                {\n                    servletVersion = StringUtils.substring( artifact.getVersion(), 0, 3 );\n                }\n            }\n\n            writer.writeText( servletVersion );\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"context-root\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", project.getArtifactId() ); //$NON-NLS-1$\n            writer.endElement();\n        }\n        else if ( \"ejb\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            //  <module-type module-type-id=\"jst.ejb\">\n            //    <version>2.1<\/version>\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.ejb\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n            writer.writeText( \"2.1\" ); //$NON-NLS-1$\n            // @todo this is the default, find real ejb version from dependencies\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        else\n        {\n            //  <module-type module-type-id=\"jst.utility\">\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.utility\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        writer.endElement(); // module-type\n\n        // source and resource paths.\n        // deploy-path is \"/\" for utility and ejb projects, \"/WEB-INF/classes\" for webapps\n\n        String target = \"/\"; //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            writeWarSpecificResources( writer, basedir, project, referencedReactorArtifacts, localRepository );\n\n            target = \"/WEB-INF/classes\"; //$NON-NLS-1$\n        }\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n            // test src/resources are not added to wtpmodules\n            if ( !dir.isTest() )\n            {\n                //  <wb-resource deploy-path=\"/\" source-path=\"/src/java\" />\n                writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n                writer.addAttribute( \"deploy-path\", target ); //$NON-NLS-1$\n                writer.addAttribute( \"source-path\", dir.getPath() ); //$NON-NLS-1$\n                writer.endElement();\n            }\n        }\n\n        writer.endElement(); // wb-module\n        writer.endElement(); // project-modules\n\n        IOUtil.close( w );\n    }","id":79140,"modified_method":"protected void write( File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, List remoteArtifactRepositories )\n        throws MojoExecutionException\n    {\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".wtpmodules\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"project-modules\" ); //$NON-NLS-1$\n        writer.addAttribute( \"id\", \"moduleCoreId\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n        writer.startElement( \"wb-module\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-name\", project.getArtifactId() ); //$NON-NLS-1$\n\n        writer.startElement( \"module-type\" ); //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            // <module-type module-type-id=\"jst.web\">\n            //   <version>2.4<\/version>\n            //   <property name=\"context-root\" value=\"magnolia\">\n            //   <\/property>\n            // <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.web\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n\n            // defaults to 2.4, try to detect real version from dependencies\n            String servletVersion = \"2.4\"; //$NON-NLS-1$\n\n            for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n                if ( \"servletapi\".equals( artifact.getArtifactId() ) //$NON-NLS-1$\n                    || \"geronimo-spec-servlet\".equals( artifact.getArtifactId() ) ) //$NON-NLS-1$\n                {\n                    servletVersion = StringUtils.substring( artifact.getVersion(), 0, 3 );\n                }\n            }\n\n            writer.writeText( servletVersion );\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"context-root\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", project.getArtifactId() ); //$NON-NLS-1$\n            writer.endElement();\n        }\n        else if ( \"ejb\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            //  <module-type module-type-id=\"jst.ejb\">\n            //    <version>2.1<\/version>\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.ejb\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n            writer.writeText( \"2.1\" ); //$NON-NLS-1$\n            // @todo this is the default, find real ejb version from dependencies\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        else\n        {\n            //  <module-type module-type-id=\"jst.utility\">\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.utility\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        writer.endElement(); // module-type\n\n        // source and resource paths.\n        // deploy-path is \"/\" for utility and ejb projects, \"/WEB-INF/classes\" for webapps\n\n        String target = \"/\"; //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            writeWarSpecificResources( writer, basedir, project, referencedReactorArtifacts, localRepository,\n                                       artifactResolver, remoteArtifactRepositories );\n\n            target = \"/WEB-INF/classes\"; //$NON-NLS-1$\n        }\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n            // test src/resources are not added to wtpmodules\n            if ( !dir.isTest() )\n            {\n                //  <wb-resource deploy-path=\"/\" source-path=\"/src/java\" />\n                writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n                writer.addAttribute( \"deploy-path\", target ); //$NON-NLS-1$\n                writer.addAttribute( \"source-path\", dir.getPath() ); //$NON-NLS-1$\n                writer.endElement();\n            }\n        }\n\n        writer.endElement(); // wb-module\n        writer.endElement(); // project-modules\n\n        IOUtil.close( w );\n    }","commit_id":"eac4ca45d70990815e5d0899018e4033104a343b","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void assertDoesNotContain( String message, String full, String substring )\n    {\n        if ( full == null || full.indexOf( substring ) != -1 )\n        {\n            StringBuffer buf = new StringBuffer();\n            if ( message != null )\n            {\n                buf.append( message );\n            }\n            buf.append( \". \" );\n            buf.append( \"Unexpected \\\"\" );\n            buf.append( substring );\n            buf.append( \"\\\" found\" );\n        }\n    }","id":79141,"modified_method":"protected void assertDoesNotContain( String message, String full, String substring )\n    {\n        if ( full == null || full.indexOf( substring ) != -1 )\n        {\n            StringBuffer buf = new StringBuffer();\n            if ( message != null )\n            {\n                buf.append( message );\n            }\n            buf.append( \". \" );\n            buf.append( \"Unexpected \\\"\" );\n            buf.append( substring );\n            buf.append( \"\\\" found\" );\n            fail( buf.toString() );\n        }\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @param outputDirectory TODO\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources, String outputDirectory )\n        throws MojoExecutionException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, //$NON-NLS-1$  \n                                                                             outputDirectory, false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"org.eclipse.jdt.launching.JRE_CONTAINER\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        List artifacts = project.getTestArtifacts();\n\n        // @todo direct optional artifacts are not included in the list returned by project.getTestArtifacts()\n        // .classpath should include ANY direct dependency, and optional dependencies are required to compile\n        Set depArtifacts = project.getDependencyArtifacts();\n        for ( Iterator it = depArtifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            if ( artifact.isOptional() && !artifacts.contains( artifact ) )\n            {\n                try\n                {\n                    artifactResolver.resolve( artifact, remoteArtifactRepositories, localRepository );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    log.error( \"Unable to resolve optional artifact \" + artifact.getId() );\n                    continue;\n                }\n                catch ( ArtifactNotFoundException e )\n                {\n                    log.error( \"Unable to resolve optional artifact \" + artifact.getId() );\n                    continue;\n                }\n                artifacts.add( artifact );\n            }\n        }\n\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                               artifactFactory, remoteArtifactRepositories, downloadSources );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","id":79142,"modified_method":"/**\n     * @param outputDirectory TODO\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources, String outputDirectory )\n        throws MojoExecutionException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, //$NON-NLS-1$  \n                                                                             outputDirectory, false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"org.eclipse.jdt.launching.JRE_CONTAINER\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        List artifacts = project.getTestArtifacts();\n\n        EclipseUtils.fixMissingOptionalArtifacts( artifacts, project.getDependencyArtifacts(), localRepository,\n                                                  artifactResolver, remoteArtifactRepositories, log );\n\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            if ( artifact.getArtifactHandler().isAddedToClasspath() )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                               artifactFactory, remoteArtifactRepositories, downloadSources );\n            }\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"public void write()\n        throws MojoExecutionException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs =\n            EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog(), outputDirectory );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources,\n                                                      outputDirectory );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, project );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, project, reactorArtifacts, sourceDirs,\n                                                       localRepository );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","id":79143,"modified_method":"public void write()\n        throws MojoExecutionException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs =\n            EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog(), outputDirectory );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources,\n                                                      outputDirectory );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, project );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, project, reactorArtifacts, sourceDirs,\n                                                       localRepository,artifactResolver,\n                                                       remoteArtifactRepositories );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"public void testMasterProject()\n        throws Exception\n    {\n        File basedir = getTestFile( \"src/test/projects/master-test\" );\n\n        executeMaven2CommandLine( basedir );\n\n        assertFileEquals( null, new File( basedir, \"module-1/project\" ), new File( basedir, \"module-1/.project\" ) );\n        assertFileEquals( null, new File( basedir, \"module-1/classpath\" ), new File( basedir, \"module-1/.classpath\" ) );\n        assertFileEquals( null, new File( basedir, \"module-1/wtpmodules\" ), new File( basedir, \"module-1/.wtpmodules\" ) );\n\n        // the real test: this should include any sort of direct/transitive dependency handled by mvn\n        assertFileEquals( null, new File( basedir, \"module-2/project\" ), new File( basedir, \"module-2/.project\" ) );\n\n        // manual check, easier to handle\n        checkModule2Classpath( new File( basedir, \"module-2/.classpath\" ) );\n\n        // manual check, easier to handle\n        checkModule2Wtpmodules( new File( basedir, \"module-2/.wtpmodules\" ) );\n\n    }","id":79144,"modified_method":"/**\n     * Test using a command line. Should be replaced by the embedder test.\n     */\n    public void testMasterProject()\n        throws Exception\n    {\n        executeMaven2CommandLine( basedir );\n        compareFiles();\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"private void checkModule2Wtpmodules( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String classpath = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include all\n        assertContains( \"Invalid wtpmodules\", classpath, \"/direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/direct-test\" );\n        assertContains( \"Invalid wtpmodules\", classpath, \"/direct-system\" );\n        assertContains( \"Invalid wtpmodules\", classpath, \"/direct-optional\" );\n\n        // referenced project: only runtime deps\n        assertContains( \"Invalid wtpmodules\", classpath, \"/module-1\" );\n        assertContains( \"Invalid wtpmodules\", classpath, \"/refproject-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/refproject-system\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/refproject-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid wtpmodules\", classpath, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-direct-system\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-direct-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-system\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", classpath, \"/deps-refproject-optional\" );\n    }","id":79145,"modified_method":"private void checkModule2Wtpmodules( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String wtpmodules = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include only runtime (also optional) dependencies\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/direct-test\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/direct-sysdep\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/direct-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/direct-provided\" );\n\n        // referenced project: only runtime deps\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/module-1\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/refproject-compile\" );\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/refproject-sysdep\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/refproject-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/refproject-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-direct-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-optional\" );\n        assertDoesNotContain( \"Invalid wtpmodules\", wtpmodules, \"/deps-refproject-provided\" );\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"private void checkModule2Classpath( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String classpath = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include all\n        assertContains( \"Invalid classpath\", classpath, \"/direct-compile\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-test\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-sysdep\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-optional\" );\n\n        // referenced project: no deps!\n        assertContains( \"Invalid classpath\", classpath, \"/module-1\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-sysdep\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid classpath\", classpath, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-system\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-optional\" );\n\n        // transitive dependencies from referenced projects\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-system\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-optional\" );\n    }","id":79146,"modified_method":"private void checkModule2Classpath( File file )\n        throws Exception\n    {\n        InputStream fis = new FileInputStream( file );\n        String classpath = IOUtil.toString( fis );\n        IOUtil.close( fis );\n\n        // direct dependencies: include all\n        assertContains( \"Invalid classpath\", classpath, \"/direct-compile\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-test\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-sysdep\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-optional\" );\n        assertContains( \"Invalid classpath\", classpath, \"/direct-provided\" );\n\n        // referenced project: not required, but it's not a problem to have them included\n        assertContains( \"Invalid classpath\", classpath, \"/module-1\" );\n        // assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-compile\" );\n        // assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-sysdep\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-optional\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/refproject-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid classpath\", classpath, \"/deps-direct-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-optional\" );\n        // @todo should this be included? see MNG-514\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-direct-provided\" );\n\n        // transitive dependencies from referenced projects\n        assertContains( \"Invalid classpath\", classpath, \"/deps-refproject-compile\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-test\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-optional\" );\n        assertDoesNotContain( \"Invalid classpath\", classpath, \"/deps-refproject-provided\" );\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Convenience method to create a m2 command line from a given working directory.\n     *\n     * @param workingDir a not null working directory.\n     * @return the m2 command line\n     * @throws Exception any exception caught is thrown during tests\n     */\n    protected Commandline createMaven2CommandLine( File workingDir )\n        throws Exception\n    {\n\n        assertNotNull( \"workingDir can't be null\", workingDir );\n        assertTrue( \"workingDir must exist\", workingDir.exists() );\n\n        // read default settings and extract local repository path\n        MavenSettingsBuilder settingsBuilder = (MavenSettingsBuilder) lookup( MavenSettingsBuilder.ROLE );\n        Settings defaultSettings = settingsBuilder.buildSettings();\n\n        // prepare a temporary settings.xml\n        File settings = File.createTempFile( \"settings\", \".xml\" );\n        settings.deleteOnExit();\n        Writer w = new FileWriter( settings );\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n        writer.startElement( \"settings\" );\n\n        // keep default local repository\n        writer.startElement( \"localRepository\" );\n        writer.writeText( defaultSettings.getLocalRepository() );\n        writer.endElement();\n\n        writer.startElement( \"interactiveMode\" );\n        writer.writeText( \"false\" );\n        writer.endElement();\n\n        writer.startElement( \"mirrors\" );\n        writer.startElement( \"mirror\" );\n\n        // add a file mirror, so that dependencies are loaded from the plugin directory\n        writer.startElement( \"id\" );\n        writer.writeText( \"localtest\" );\n        writer.endElement();\n        writer.startElement( \"url\" );\n        writer.writeText( \"file://\" + getBasedir().replace( '\\\\', '/' ) + \"/src/test/m2repo\" );\n        writer.endElement();\n        writer.startElement( \"mirrorOf\" );\n        writer.writeText( \"central\" );\n        writer.endElement();\n\n        writer.endElement();\n        writer.endElement();\n\n        writer.endElement();\n        IOUtil.close( w );\n\n        Commandline cmd = new Commandline();\n\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n\n        cmd.setExecutable( \"mvn\" );\n        cmd.createArgument().setValue( \"-s\" + settings.getAbsolutePath() );\n        cmd.createArgument().setValue( \"-e\" );\n\n        cmd.createArgument().setValue( \"eclipse:clean\" );\n        cmd.createArgument().setValue( \"eclipse:eclipse\" );\n\n        return cmd;\n    }","id":79147,"modified_method":"/**\n     * Convenience method to create a m2 command line from a given working directory.\n     *\n     * @param workingDir a not null working directory.\n     * @return the m2 command line\n     * @throws Exception any exception caught is thrown during tests\n     */\n    protected Commandline createMaven2CommandLine( File workingDir )\n        throws Exception\n    {\n\n        assertNotNull( \"workingDir can't be null\", workingDir );\n        assertTrue( \"workingDir must exist\", workingDir.exists() );\n\n        // read default settings and extract local repository path\n        MavenSettingsBuilder settingsBuilder = (MavenSettingsBuilder) lookup( MavenSettingsBuilder.ROLE );\n        Settings defaultSettings = settingsBuilder.buildSettings();\n\n        String settingsPath = createTestSettings( defaultSettings );\n\n        Commandline cmd = new Commandline();\n\n        cmd.setWorkingDirectory( workingDir.getAbsolutePath() );\n\n        cmd.setExecutable( \"mvn\" );\n        cmd.createArgument().setValue( \"-s\" + settingsPath );\n        cmd.createArgument().setValue( \"-e\" );\n\n        cmd.createArgument().setValue( \"eclipse:clean\" );\n        cmd.createArgument().setValue( \"eclipse:eclipse\" );\n\n        return cmd;\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"public static void fixSystemScopeArtifacts( Collection artifacts, Collection dependencies )\n    {\n        // fix path for system dependencies.Artifact.getFile() returns a wrong path in mvn 2.0\n        for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n            {\n                String groupid = artifact.getGroupId();\n                String artifactId = artifact.getArtifactId();\n\n                for ( Iterator depIt = dependencies.iterator(); depIt.hasNext(); )\n                {\n                    Dependency dep = (Dependency) depIt.next();\n                    if ( Artifact.SCOPE_SYSTEM.equals( dep.getScope() ) && groupid.equals( dep.getGroupId() )\n                        && artifactId.equals( dep.getArtifactId() ) )\n                    {\n                        artifact.setFile( new File( dep.getSystemPath() ) );\n                        break;\n                    }\n                }\n            }\n        }\n    }","id":79148,"modified_method":"/**\n     * @todo MNG-1379 Wrong path for artifacts with system scope\n     * Artifacts with a system scope have a wrong path in mvn 2.0. This is a temporary workaround.\n     */\n    public static void fixSystemScopeArtifacts( Collection artifacts, Collection dependencies )\n    {\n        // fix path for system dependencies.Artifact.getFile() returns a wrong path in mvn 2.0\n        for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n            {\n                String groupid = artifact.getGroupId();\n                String artifactId = artifact.getArtifactId();\n\n                for ( Iterator depIt = dependencies.iterator(); depIt.hasNext(); )\n                {\n                    Dependency dep = (Dependency) depIt.next();\n                    if ( Artifact.SCOPE_SYSTEM.equals( dep.getScope() ) && groupid.equals( dep.getGroupId() )\n                        && artifactId.equals( dep.getArtifactId() ) )\n                    {\n                        artifact.setFile( new File( dep.getSystemPath() ) );\n                        break;\n                    }\n                }\n            }\n        }\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"private void writeWarSpecificResources( XMLWriter writer, File basedir, MavenProject project,\n                                           List referencedReactorArtifacts, ArtifactRepository localRepository )\n    {\n\n        String warSourceDirectory = EclipseUtils.getPluginSetting( project, \"maven-war-plugin\", //$NON-NLS-1$\n                                                                   \"warSourceDirectory\", //$NON-NLS-1$\n                                                                   \"/src/main/webapp\" ); //$NON-NLS-1$\n\n        writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-path\", \"/\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"source-path\", //$NON-NLS-1$\n                             EclipseUtils.toRelativeAndFixSeparator( basedir, warSourceDirectory, false ) );\n        writer.endElement();\n\n        Set artifacts = project.getArtifacts();\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        ScopeArtifactFilter scopeFilter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME );\n\n        // dependencies\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            String type = artifact.getType();\n\n            if ( ( scopeFilter.include( artifact ) || Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n                && ( \"jar\".equals( type ) || \"ejb\".equals( type ) || \"ejb-client\".equals( type ) ) )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository );\n            }\n        }\n    }","id":79149,"modified_method":"private void writeWarSpecificResources( XMLWriter writer, File basedir, MavenProject project,\n                                           List referencedReactorArtifacts, ArtifactRepository localRepository,\n                                           ArtifactResolver artifactResolver, List remoteArtifactRepositories )\n    {\n\n        String warSourceDirectory = EclipseUtils.getPluginSetting( project, \"maven-war-plugin\", //$NON-NLS-1$\n                                                                   \"warSourceDirectory\", //$NON-NLS-1$\n                                                                   \"/src/main/webapp\" ); //$NON-NLS-1$\n\n        writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-path\", \"/\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"source-path\", //$NON-NLS-1$\n                             EclipseUtils.toRelativeAndFixSeparator( basedir, warSourceDirectory, false ) );\n        writer.endElement();\n\n        Set artifacts = project.getArtifacts();\n\n        EclipseUtils.fixMissingOptionalArtifacts( artifacts, project.getDependencyArtifacts(), localRepository,\n                                                  artifactResolver, remoteArtifactRepositories, log );\n\n        EclipseUtils.fixSystemScopeArtifacts( artifacts, project.getDependencies() );\n\n        ScopeArtifactFilter scopeFilter = new ScopeArtifactFilter( Artifact.SCOPE_RUNTIME );\n\n        // dependencies\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            String type = artifact.getType();\n\n            if ( ( scopeFilter.include( artifact ) || Artifact.SCOPE_SYSTEM.equals( artifact.getScope() ) )\n                && ( \"jar\".equals( type ) || \"ejb\".equals( type ) || \"ejb-client\".equals( type ) ) )\n            {\n                addDependency( writer, artifact, referencedReactorArtifacts, localRepository );\n            }\n        }\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"protected void write( File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, ArtifactRepository localRepository )\n        throws MojoExecutionException\n    {\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".wtpmodules\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"project-modules\" ); //$NON-NLS-1$\n        writer.addAttribute( \"id\", \"moduleCoreId\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n        writer.startElement( \"wb-module\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-name\", project.getArtifactId() ); //$NON-NLS-1$\n\n        writer.startElement( \"module-type\" ); //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            // <module-type module-type-id=\"jst.web\">\n            //   <version>2.4<\/version>\n            //   <property name=\"context-root\" value=\"magnolia\">\n            //   <\/property>\n            // <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.web\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n\n            // defaults to 2.4, try to detect real version from dependencies\n            String servletVersion = \"2.4\"; //$NON-NLS-1$\n\n            for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n                if ( \"servletapi\".equals( artifact.getArtifactId() ) //$NON-NLS-1$\n                    || \"geronimo-spec-servlet\".equals( artifact.getArtifactId() ) ) //$NON-NLS-1$\n                {\n                    servletVersion = StringUtils.substring( artifact.getVersion(), 0, 3 );\n                }\n            }\n\n            writer.writeText( servletVersion );\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"context-root\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", project.getArtifactId() ); //$NON-NLS-1$\n            writer.endElement();\n        }\n        else if ( \"ejb\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            //  <module-type module-type-id=\"jst.ejb\">\n            //    <version>2.1<\/version>\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.ejb\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n            writer.writeText( \"2.1\" ); //$NON-NLS-1$\n            // @todo this is the default, find real ejb version from dependencies\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        else\n        {\n            //  <module-type module-type-id=\"jst.utility\">\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.utility\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        writer.endElement(); // module-type\n\n        // source and resource paths.\n        // deploy-path is \"/\" for utility and ejb projects, \"/WEB-INF/classes\" for webapps\n\n        String target = \"/\"; //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            writeWarSpecificResources( writer, basedir, project, referencedReactorArtifacts, localRepository );\n\n            target = \"/WEB-INF/classes\"; //$NON-NLS-1$\n        }\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n            // test src/resources are not added to wtpmodules\n            if ( !dir.isTest() )\n            {\n                //  <wb-resource deploy-path=\"/\" source-path=\"/src/java\" />\n                writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n                writer.addAttribute( \"deploy-path\", target ); //$NON-NLS-1$\n                writer.addAttribute( \"source-path\", dir.getPath() ); //$NON-NLS-1$\n                writer.endElement();\n            }\n        }\n\n        writer.endElement(); // wb-module\n        writer.endElement(); // project-modules\n\n        IOUtil.close( w );\n    }","id":79150,"modified_method":"protected void write( File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, List remoteArtifactRepositories )\n        throws MojoExecutionException\n    {\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".wtpmodules\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new MojoExecutionException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"project-modules\" ); //$NON-NLS-1$\n        writer.addAttribute( \"id\", \"moduleCoreId\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n        writer.startElement( \"wb-module\" ); //$NON-NLS-1$\n        writer.addAttribute( \"deploy-name\", project.getArtifactId() ); //$NON-NLS-1$\n\n        writer.startElement( \"module-type\" ); //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            // <module-type module-type-id=\"jst.web\">\n            //   <version>2.4<\/version>\n            //   <property name=\"context-root\" value=\"magnolia\">\n            //   <\/property>\n            // <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.web\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n\n            // defaults to 2.4, try to detect real version from dependencies\n            String servletVersion = \"2.4\"; //$NON-NLS-1$\n\n            for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n                if ( \"servletapi\".equals( artifact.getArtifactId() ) //$NON-NLS-1$\n                    || \"geronimo-spec-servlet\".equals( artifact.getArtifactId() ) ) //$NON-NLS-1$\n                {\n                    servletVersion = StringUtils.substring( artifact.getVersion(), 0, 3 );\n                }\n            }\n\n            writer.writeText( servletVersion );\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"context-root\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", project.getArtifactId() ); //$NON-NLS-1$\n            writer.endElement();\n        }\n        else if ( \"ejb\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            //  <module-type module-type-id=\"jst.ejb\">\n            //    <version>2.1<\/version>\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.ejb\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"version\" ); //$NON-NLS-1$\n            writer.writeText( \"2.1\" ); //$NON-NLS-1$\n            // @todo this is the default, find real ejb version from dependencies\n            writer.endElement();\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        else\n        {\n            //  <module-type module-type-id=\"jst.utility\">\n            //    <property name=\"java-output-path\" value=\"/bin/\"/>\n            //  <\/module-type>\n\n            writer.addAttribute( \"module-type-id\", \"jst.utility\" ); //$NON-NLS-1$ //$NON-NLS-2$\n\n            writer.startElement( \"property\" ); //$NON-NLS-1$\n            writer.addAttribute( \"name\", \"java-output-path\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"value\", \"/\" + //$NON-NLS-1$ //$NON-NLS-2$\n                EclipseUtils.toRelativeAndFixSeparator( project.getBasedir(), project.getBuild().getOutputDirectory(),\n                                                        false ) );\n            writer.endElement();\n        }\n        writer.endElement(); // module-type\n\n        // source and resource paths.\n        // deploy-path is \"/\" for utility and ejb projects, \"/WEB-INF/classes\" for webapps\n\n        String target = \"/\"; //$NON-NLS-1$\n        if ( \"war\".equals( project.getPackaging() ) ) //$NON-NLS-1$\n        {\n            writeWarSpecificResources( writer, basedir, project, referencedReactorArtifacts, localRepository,\n                                       artifactResolver, remoteArtifactRepositories );\n\n            target = \"/WEB-INF/classes\"; //$NON-NLS-1$\n        }\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n            // test src/resources are not added to wtpmodules\n            if ( !dir.isTest() )\n            {\n                //  <wb-resource deploy-path=\"/\" source-path=\"/src/java\" />\n                writer.startElement( \"wb-resource\" ); //$NON-NLS-1$\n                writer.addAttribute( \"deploy-path\", target ); //$NON-NLS-1$\n                writer.addAttribute( \"source-path\", dir.getPath() ); //$NON-NLS-1$\n                writer.endElement();\n            }\n        }\n\n        writer.endElement(); // wb-module\n        writer.endElement(); // project-modules\n\n        IOUtil.close( w );\n    }","commit_id":"aa07bff6b7802c74461667534ba5ec607d8a3aaa","url":"https://github.com/apache/maven"},{"original_method":"protected void addUserViewPermission(long companyId, String[] roleNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tRole userRole = getRole(companyId, RoleConstants.USER);\n\n\t\tfor (String roleName : roleNames) {\n\t\t\tRole role = getRole(companyId, roleName);\n\n\t\t\tString name = Role.class.getName();\n\t\t\tString[] actionIds = new String[]{ActionKeys.VIEW};\n\n\t\t\tif (resourceBlockLocalService.isSupported(name)) {\n\t\t\t\tresourceBlockLocalService.setIndividualScopePermissions(\n\t\t\t\t\tcompanyId, 0, name, role.getRoleId(), userRole.getRoleId(),\n\t\t\t\t\tArrays.asList(actionIds));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\t\tString.valueOf(role.getRoleId()), userRole.getRoleId(),\n\t\t\t\t\tactionIds);\n\t\t\t}\n\t\t}\n\t}","id":79151,"modified_method":"protected void addUserViewPermission(long companyId, String[] roleNames)\n\t\tthrows PortalException, SystemException {\n\n\t\tRole userRole = getRole(companyId, RoleConstants.USER);\n\n\t\tfor (String roleName : roleNames) {\n\t\t\tRole role = getRole(companyId, roleName);\n\n\t\t\tString name = Role.class.getName();\n\t\t\tString[] actionIds = new String[]{ActionKeys.VIEW};\n\n\t\t\tresourcePermissionLocalService.setResourcePermissions(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tString.valueOf(role.getRoleId()), userRole.getRoleId(),\n\t\t\t\tactionIds);\n\t\t}\n\t}","commit_id":"7dac9707c527ef348acd958b8042699878d0c50b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setRolePermissions(\n\t\t\tRole role, String name, String[] actionIds)\n\t\tthrows Exception {\n\n\t\tlong roleId = role.getRoleId();\n\t\tlong companyId = role.getCompanyId();\n\t\tint scope = ResourceConstants.SCOPE_COMPANY;\n\t\tString primKey = String.valueOf(companyId);\n\n\t\tif (_PERMISSIONS_USER_CHECK_ALGORITHM == 6) {\n\t\t\tResourcePermissionLocalServiceUtil.setResourcePermissions(\n\t\t\t\tcompanyId, name, scope, primKey, roleId, actionIds);\n\t\t}\n\t\telse {\n\t\t\tPermissionLocalServiceUtil.setRolePermissions(\n\t\t\t\troleId, companyId, name, scope, primKey, actionIds);\n\t\t}\n\t}","id":79152,"modified_method":"protected void setRolePermissions(\n\t\t\tRole role, String name, String[] actionIds)\n\t\tthrows Exception {\n\n\t\tlong roleId = role.getRoleId();\n\t\tlong companyId = role.getCompanyId();\n\t\tint scope = ResourceConstants.SCOPE_COMPANY;\n\t\tString primKey = String.valueOf(companyId);\n\n\t\tResourcePermissionLocalServiceUtil.setResourcePermissions(\n\t\t\tcompanyId, name, scope, primKey, roleId, actionIds);\n\t}","commit_id":"a7e5ca57c07f0f356336160a8220853f57ccbdc1","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addWikiPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"Wiki\",\n\t\t\t\"Collaborate with members through the wiki on this page. \" +\n\t\t\t\t\"Discover related content through tags, and navigate quickly \" +\n\t\t\t\t\t\"and easily with categories.\",\n\t\t\t\"2_columns_iii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletId = addPortletId(layout, PortletKeys.WIKI, \"column-1\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(\n\t\t\tlayout, PortletKeys.TAGS_CATEGORIES_NAVIGATION, \"column-2\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(layout, PortletKeys.TAGS_ENTRIES_NAVIGATION,\n            \"column-2\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\t}","id":79153,"modified_method":"protected void addWikiPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"Wiki\",\n\t\t\t\"Collaborate with members through the wiki on this page. \" +\n\t\t\t\t\"Discover related content through tags, and navigate quickly \" +\n\t\t\t\t\t\"and easily with categories.\",\n\t\t\t\"2_columns_iii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\taddPortletId(layout, PortletKeys.WIKI, \"column-1\");\n\t\taddPortletId(\n\t\t\tlayout, PortletKeys.TAGS_CATEGORIES_NAVIGATION, \"column-2\");\n\t\taddPortletId(layout, PortletKeys.TAGS_ENTRIES_NAVIGATION, \"column-2\");\n\t}","commit_id":"322b10c67379f245a86e1441b0b81691f6ede5ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addWebContentPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"Content Display Page\",\n\t\t\t\"Create, edit, and explore web content with this page. Search \" +\n\t\t\t\t\"available content, explore related content with tags, and \" +\n\t\t\t\t\t\"browse content categories.\",\n\t\t\t\"2_columns_ii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletId = addPortletId(\n            layout, PortletKeys.TAGS_ENTRIES_NAVIGATION, \"column-1\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(\n\t\t\tlayout, PortletKeys.TAGS_CATEGORIES_NAVIGATION, \"column-1\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(layout, PortletKeys.SEARCH, \"column-2\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(\n\t\t\tlayout, PortletKeys.ASSET_PUBLISHER, \"column-2\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tlayout.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\tLayoutTypePortletConstants.DEFAULT_ASSET_PUBLISHER_PORTLET_ID,\n\t\t\tportletId);\n\n\t\tlayout = LayoutLocalServiceUtil.updateLayout(\n\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\tlayout.getLayoutId(), layout.getTypeSettings());\n\t}","id":79154,"modified_method":"protected void addWebContentPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"Content Display Page\",\n\t\t\t\"Create, edit, and explore web content with this page. Search \" +\n\t\t\t\t\"available content, explore related content with tags, and \" +\n\t\t\t\t\t\"browse content categories.\",\n\t\t\t\"2_columns_ii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\taddPortletId(layout, PortletKeys.TAGS_ENTRIES_NAVIGATION, \"column-1\");\n\t\taddPortletId(\n\t\t\tlayout, PortletKeys.TAGS_CATEGORIES_NAVIGATION, \"column-1\");\n\t\taddPortletId(layout, PortletKeys.SEARCH, \"column-2\");\n\t\tString portletId = addPortletId(\n\t\t\tlayout, PortletKeys.ASSET_PUBLISHER, \"column-2\");\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tlayout.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\tLayoutTypePortletConstants.DEFAULT_ASSET_PUBLISHER_PORTLET_ID,\n\t\t\tportletId);\n\n\t\tlayout = LayoutLocalServiceUtil.updateLayout(\n\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\tlayout.getLayoutId(), layout.getTypeSettings());\n\t}","commit_id":"322b10c67379f245a86e1441b0b81691f6ede5ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addBlogPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"Blog\",\n\t\t\t\"Create, edit, and view blogs from this page. Explore topics \" +\n\t\t\t\t\"using tags, and connect with other members that blog.\",\n\t\t\t\"2_columns_iii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletId = addPortletId(layout, PortletKeys.BLOGS, \"column-1\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(layout, PortletKeys.TAGS_CLOUD, \"column-2\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\n        portletId = addPortletId(layout, PortletKeys.RECENT_BLOGGERS,\n            \"column-2\");\n        addResourcePermissions(companyId, portletId, layout.getPlid());\n\t}","id":79155,"modified_method":"protected void addBlogPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"Blog\",\n\t\t\t\"Create, edit, and view blogs from this page. Explore topics \" +\n\t\t\t\t\"using tags, and connect with other members that blog.\",\n\t\t\t\"2_columns_iii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\taddPortletId(layout, PortletKeys.BLOGS, \"column-1\");\n\t\taddPortletId(layout, PortletKeys.TAGS_CLOUD, \"column-2\");\n\t\taddPortletId(layout, PortletKeys.RECENT_BLOGGERS, \"column-2\");\n\t}","commit_id":"322b10c67379f245a86e1441b0b81691f6ede5ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addResourcePermissions(long companyId, String portletId,\n        long plid)\n            throws SystemException, PortalException {\n        String resourceName = PortletConstants.getRootPortletId(portletId);\n        String primaryKey = PortletPermissionUtil.getPrimaryKey(plid,\n            portletId);\n\n        //Guest\n\n        long roleId = RoleLocalServiceUtil.getRole(companyId, RoleConstants\n            .GUEST).getRoleId();\n        ResourcePermissionLocalServiceUtil.setResourcePermissions(\n            companyId, resourceName, ResourceConstants.SCOPE_INDIVIDUAL,\n            primaryKey, roleId, new String[]{ActionKeys.VIEW});\n\n        //Site Member\n\n        roleId = RoleLocalServiceUtil.getRole(companyId, RoleConstants\n            .SITE_MEMBER).getRoleId();\n        ResourcePermissionLocalServiceUtil.setResourcePermissions(\n            companyId, resourceName, ResourceConstants.SCOPE_INDIVIDUAL,\n            primaryKey, roleId, new String[]{ActionKeys.VIEW});\n\n        //Owner\n\n        roleId = RoleLocalServiceUtil.getRole(companyId, RoleConstants.OWNER)\n            .getRoleId();\n        ResourcePermissionLocalServiceUtil.setResourcePermissions(\n            companyId, resourceName, ResourceConstants.SCOPE_INDIVIDUAL,\n            primaryKey, roleId, new String[]{ActionKeys.ADD_TO_PAGE});\n    }","id":79156,"modified_method":"protected void addResourcePermissions(\n\t\t\tlong companyId, String portletId, long plid)\n        throws SystemException, PortalException {\n\n\t\tString resourceName = PortletConstants.getRootPortletId(portletId);\n\n\t\tString primaryKey = PortletPermissionUtil.getPrimaryKey(\n\t\t\tplid, portletId);\n\n\t\tRole guest = RoleLocalServiceUtil.getRole(companyId, RoleConstants.GUEST);\n\t\tRole siteMember = RoleLocalServiceUtil.getRole(companyId, RoleConstants.SITE_MEMBER);\n\t\tRole owner = RoleLocalServiceUtil.getRole(companyId, RoleConstants.OWNER);\n\n\t\tlong[] roleIds = new long[] {\n\t\t\tguest.getRoleId(), siteMember.getRoleId(), owner.getRoleId()};\n\n\t\tfor (long roleId : roleIds) {\n\t\t\tResourcePermissionLocalServiceUtil.setResourcePermissions(\n\t\t\t\tcompanyId, resourceName, ResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tprimaryKey, roleId, new String[]{ActionKeys.VIEW});\n\t\t}\n    }","commit_id":"322b10c67379f245a86e1441b0b81691f6ede5ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String addPortletId(\n\t\t\tLayout layout, String portletId, String columnId)\n\t\tthrows Exception {\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tportletId = layoutTypePortlet.addPortletId(\n\t\t\t0, portletId, columnId, -1, false);\n\n\t\tupdateLayout(layout);\n\n\t\treturn portletId;\n\t}","id":79157,"modified_method":"protected String addPortletId(\n\t\t\tLayout layout, String portletId, String columnId)\n\t\tthrows Exception {\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tportletId = layoutTypePortlet.addPortletId(\n\t\t\t0, portletId, columnId, -1, false);\n\n\t\tupdateLayout(layout);\n\n\t\taddResourcePermissions(\n\t\t\tlayout.getCompanyId(), portletId, layout.getPlid());\n\n\t\treturn portletId;\n\t}","commit_id":"322b10c67379f245a86e1441b0b81691f6ede5ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n    public void testIndexUpdate() throws IOException\n    {\n        Table table = Table.open(\"Keyspace2\");\n\n        // create a row and update the birthdate value, test that the index query fetches the new version\n        RowMutation rm;\n        rm = new RowMutation(\"Keyspace2\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 1);\n        rm.apply();\n        rm = new RowMutation(\"Keyspace2\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(2L), 2);\n        rm.apply();\n\n        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));\n        IndexClause clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        IFilter filter = new IdentityQueryFilter();\n        IPartitioner p = StorageService.getPartitioner();\n        Range range = new Range(p.getMinimumToken(), p.getMinimumToken());\n        List<Row> rows = table.getColumnFamilyStore(\"Indexed1\").search(clause, range, filter);\n        assert rows.size() == 0;\n\n        expr = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, ByteBufferUtil.bytes(2L));\n        clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        rows = table.getColumnFamilyStore(\"Indexed1\").search(clause, range, filter);\n        String key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); \n        assert \"k1\".equals( key );\n        \n        // update the birthdate value with an OLDER timestamp, and test that the index ignores this\n        rm = new RowMutation(\"Keyspace2\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(3L), 0);\n        rm.apply();\n\n        rows = table.getColumnFamilyStore(\"Indexed1\").search(clause, range, filter);\n        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); \n        assert \"k1\".equals( key );\n    \n    }","id":79158,"modified_method":"@Test\n    public void testIndexUpdate() throws IOException\n    {\n        Table table = Table.open(\"Keyspace2\");\n\n        // create a row and update the birthdate value, test that the index query fetches the new version\n        RowMutation rm;\n        rm = new RowMutation(\"Keyspace2\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 1);\n        rm.apply();\n        rm = new RowMutation(\"Keyspace2\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(2L), 2);\n        rm.apply();\n\n        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));\n        IndexClause clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        IFilter filter = new IdentityQueryFilter();\n        IPartitioner p = StorageService.getPartitioner();\n        Range range = new Range(p.getMinimumToken(), p.getMinimumToken());\n        List<Row> rows = table.getColumnFamilyStore(\"Indexed1\").search(clause, range, filter);\n        assert rows.size() == 0;\n\n        expr = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, ByteBufferUtil.bytes(2L));\n        clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        rows = table.getColumnFamilyStore(\"Indexed1\").search(clause, range, filter);\n        String key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n        \n        // update the birthdate value with an OLDER timestamp, and test that the index ignores this\n        rm = new RowMutation(\"Keyspace2\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(3L), 0);\n        rm.apply();\n\n        rows = table.getColumnFamilyStore(\"Indexed1\").search(clause, range, filter);\n        key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n    \n    }","commit_id":"f9d057edbd56776f73c83a3998664f1334c32a17","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testIndexDeletions() throws IOException\n    {\n        ColumnFamilyStore cfs = Table.open(\"Keyspace3\").getColumnFamilyStore(\"Indexed1\");\n        RowMutation rm;\n\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 0);\n        rm.apply();\n\n        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));\n        IndexClause clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        IFilter filter = new IdentityQueryFilter();\n        IPartitioner p = StorageService.getPartitioner();\n        Range range = new Range(p.getMinimumToken(), p.getMinimumToken());\n        List<Row> rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        String key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); \n        assert \"k1\".equals( key );\n\n        // delete the column directly\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), 1);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty();\n\n        // verify that it's not being indexed under the deletion column value either\n        IColumn deletion = rm.getColumnFamilies().iterator().next().iterator().next();\n        ByteBuffer deletionLong = ByteBufferUtil.bytes((long) ByteBufferUtil.toInt(deletion.value()));\n        IndexExpression expr0 = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, deletionLong);\n        IndexClause clause0 = new IndexClause(Arrays.asList(expr0), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        rows = cfs.search(clause0, range, filter);\n        assert rows.isEmpty();\n\n        // resurrect w/ a newer timestamp\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 2);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining());\n        assert \"k1\".equals( key );\n\n        // verify that row and delete w/ older timestamp does nothing\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 1);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining());\n        assert \"k1\".equals( key );\n\n        // similarly, column delete w/ older timestamp should do nothing\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), 1);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining());\n        assert \"k1\".equals( key );\n\n        // delete the entire row (w/ newer timestamp this time)\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 3);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty() : StringUtils.join(rows, \",\");\n\n        // make sure obsolete mutations don't generate an index entry\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 3);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty() : StringUtils.join(rows, \",\");\n\n        // try insert followed by row delete in the same mutation\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 1);\n        rm.delete(new QueryPath(\"Indexed1\"), 2);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty() : StringUtils.join(rows, \",\");\n\n        // try row delete followed by insert in the same mutation\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 3);\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 4);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining());\n        assert \"k1\".equals( key );\n    }","id":79159,"modified_method":"@Test\n    public void testIndexDeletions() throws IOException\n    {\n        ColumnFamilyStore cfs = Table.open(\"Keyspace3\").getColumnFamilyStore(\"Indexed1\");\n        RowMutation rm;\n\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 0);\n        rm.apply();\n\n        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));\n        IndexClause clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        IFilter filter = new IdentityQueryFilter();\n        IPartitioner p = StorageService.getPartitioner();\n        Range range = new Range(p.getMinimumToken(), p.getMinimumToken());\n        List<Row> rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        String key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n\n        // delete the column directly\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), 1);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty();\n\n        // verify that it's not being indexed under the deletion column value either\n        IColumn deletion = rm.getColumnFamilies().iterator().next().iterator().next();\n        ByteBuffer deletionLong = ByteBufferUtil.bytes((long) ByteBufferUtil.toInt(deletion.value()));\n        IndexExpression expr0 = new IndexExpression(ByteBufferUtil.bytes(\"birthdate\"), IndexOperator.EQ, deletionLong);\n        IndexClause clause0 = new IndexClause(Arrays.asList(expr0), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);\n        rows = cfs.search(clause0, range, filter);\n        assert rows.isEmpty();\n\n        // resurrect w/ a newer timestamp\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 2);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n\n        // verify that row and delete w/ older timestamp does nothing\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 1);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n\n        // similarly, column delete w/ older timestamp should do nothing\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), 1);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n\n        // delete the entire row (w/ newer timestamp this time)\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 3);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty() : StringUtils.join(rows, \",\");\n\n        // make sure obsolete mutations don't generate an index entry\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 3);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty() : StringUtils.join(rows, \",\");\n\n        // try insert followed by row delete in the same mutation\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 1);\n        rm.delete(new QueryPath(\"Indexed1\"), 2);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.isEmpty() : StringUtils.join(rows, \",\");\n\n        // try row delete followed by insert in the same mutation\n        rm = new RowMutation(\"Keyspace3\", ByteBufferUtil.bytes(\"k1\"));\n        rm.delete(new QueryPath(\"Indexed1\"), 3);\n        rm.add(new QueryPath(\"Indexed1\", null, ByteBufferUtil.bytes(\"birthdate\")), ByteBufferUtil.bytes(1L), 4);\n        rm.apply();\n        rows = cfs.search(clause, range, filter);\n        assert rows.size() == 1 : StringUtils.join(rows, \",\");\n        key = ByteBufferUtil.string(rows.get(0).key.key);\n        assert \"k1\".equals( key );\n    }","commit_id":"f9d057edbd56776f73c83a3998664f1334c32a17","url":"https://github.com/apache/cassandra"},{"original_method":"private static String str(ColumnFamily cf)\n    {\n        StringBuilder sb = new StringBuilder();\n        for (IColumn col : cf.getSortedColumns())\n            sb.append(String.format(\"(%s,%s,%d),\", new String(col.name().array()), new String(col.value().array()), col.timestamp()));\n        return sb.toString();\n    }","id":79160,"modified_method":"private static String str(ColumnFamily cf) throws CharacterCodingException\n    {\n        StringBuilder sb = new StringBuilder();\n        for (IColumn col : cf.getSortedColumns())\n            sb.append(String.format(\"(%s,%s,%d),\", ByteBufferUtil.string(col.name()), ByteBufferUtil.string(col.value()), col.timestamp()));\n        return sb.toString();\n    }","commit_id":"f9d057edbd56776f73c83a3998664f1334c32a17","url":"https://github.com/apache/cassandra"},{"original_method":"private void validateNameSort(Table table, int N) throws IOException\n    {\n        for (int i = 0; i < N; ++i)\n        {\n            DecoratedKey key = Util.dk(Integer.toString(i));\n            ColumnFamily cf;\n\n            cf = Util.getColumnFamily(table, key, \"Standard1\");\n            Collection<IColumn> columns = cf.getSortedColumns();\n            for (IColumn column : columns)\n            {\n                int j = Integer.valueOf(new String(column.name().array(),column.name().position(),column.name().remaining()).split(\"-\")[1]);\n                byte[] bytes = j % 2 == 0 ? \"a\".getBytes() : \"b\".getBytes();\n                assertEquals(new String(bytes), new String(column.value().array(), column.value().position(), column\n                        .value().remaining()));\n            }\n\n            cf = Util.getColumnFamily(table, key, \"Super1\");\n            assert cf != null : \"key \" + key + \" is missing!\";\n            Collection<IColumn> superColumns = cf.getSortedColumns();\n            assert superColumns.size() == 8 : cf;\n            for (IColumn superColumn : superColumns)\n            {\n                int j = Integer.valueOf(new String(superColumn.name().array(),superColumn.name().position(),superColumn.name().remaining()).split(\"-\")[1]);\n                Collection<IColumn> subColumns = superColumn.getSubColumns();\n                assert subColumns.size() == 4;\n                for (IColumn subColumn : subColumns)\n                {\n                    long k = subColumn.name().getLong(subColumn.name().position() + subColumn.name().arrayOffset());\n                    byte[] bytes = (j + k) % 2 == 0 ? \"a\".getBytes() : \"b\".getBytes();\n                    assertEquals(new String(bytes), new String(subColumn.value().array(), subColumn.value().position(),\n                            subColumn.value().remaining()));\n                }\n            }\n        }\n    }","id":79161,"modified_method":"private void validateNameSort(Table table, int N) throws IOException\n    {\n        for (int i = 0; i < N; ++i)\n        {\n            DecoratedKey key = Util.dk(Integer.toString(i));\n            ColumnFamily cf;\n\n            cf = Util.getColumnFamily(table, key, \"Standard1\");\n            Collection<IColumn> columns = cf.getSortedColumns();\n            for (IColumn column : columns)\n            {\n                String name = ByteBufferUtil.string(column.name());\n                int j = Integer.valueOf(name.substring(name.length() - 1));\n                byte[] bytes = j % 2 == 0 ? \"a\".getBytes() : \"b\".getBytes();\n                assertEquals(new String(bytes), ByteBufferUtil.string(column.value()));\n            }\n\n            cf = Util.getColumnFamily(table, key, \"Super1\");\n            assert cf != null : \"key \" + key + \" is missing!\";\n            Collection<IColumn> superColumns = cf.getSortedColumns();\n            assert superColumns.size() == 8 : cf;\n            for (IColumn superColumn : superColumns)\n            {\n                int j = Integer.valueOf(ByteBufferUtil.string(superColumn.name()).split(\"-\")[1]);\n                Collection<IColumn> subColumns = superColumn.getSubColumns();\n                assert subColumns.size() == 4;\n                for (IColumn subColumn : subColumns)\n                {\n                    long k = subColumn.name().getLong(subColumn.name().position() + subColumn.name().arrayOffset());\n                    byte[] bytes = (j + k) % 2 == 0 ? \"a\".getBytes() : \"b\".getBytes();\n                    assertEquals(new String(bytes), ByteBufferUtil.string(subColumn.value()));\n                }\n            }\n        }\n    }","commit_id":"c48abe4c1fbebe1052a53840fee98be91316f3f2","url":"https://github.com/apache/cassandra"},{"original_method":"private void testNameSort(int N) throws IOException, ExecutionException, InterruptedException\n    {\n        Table table = Table.open(\"Keyspace1\");\n\n        for (int i = 0; i < N; ++i)\n        {\n            ByteBuffer key = ByteBuffer.wrap(Integer.toString(i).getBytes());\n            RowMutation rm;\n\n            // standard\n            for (int j = 0; j < 8; ++j)\n            {\n                ByteBuffer bytes = ByteBuffer.wrap(j % 2 == 0 ? \"a\".getBytes() : \"b\".getBytes());\n                rm = new RowMutation(\"Keyspace1\", key);\n                rm.add(new QueryPath(\"Standard1\", null, ByteBuffer.wrap((\"Column-\" + j).getBytes())), bytes, j);\n                rm.apply();\n            }\n\n            // super\n            for (int j = 0; j < 8; ++j)\n            {\n                rm = new RowMutation(\"Keyspace1\", key);\n                for (int k = 0; k < 4; ++k)\n                {\n                    String value = (j + k) % 2 == 0 ? \"a\" : \"b\";\n                    addMutation(rm, \"Super1\", \"SuperColumn-\" + j, k, value, k);\n                }\n                rm.apply();\n            }\n        }\n\n        validateNameSort(table, N);\n\n        table.getColumnFamilyStore(\"Standard1\").forceBlockingFlush();\n        table.getColumnFamilyStore(\"Super1\").forceBlockingFlush();\n        validateNameSort(table, N);\n    }","id":79162,"modified_method":"private void testNameSort(int N) throws IOException, ExecutionException, InterruptedException\n    {\n        Table table = Table.open(\"Keyspace1\");\n\n        for (int i = 0; i < N; ++i)\n        {\n            ByteBuffer key = ByteBuffer.wrap(Integer.toString(i).getBytes());\n            RowMutation rm;\n\n            // standard\n            for (int j = 0; j < 8; ++j)\n            {\n                ByteBuffer bytes = ByteBuffer.wrap(j % 2 == 0 ? \"a\".getBytes() : \"b\".getBytes());\n                rm = new RowMutation(\"Keyspace1\", key);\n                rm.add(new QueryPath(\"Standard1\", null, ByteBuffer.wrap((\"Column-\" + j).getBytes())), bytes, j);\n                rm.applyUnsafe();\n            }\n\n            // super\n            for (int j = 0; j < 8; ++j)\n            {\n                rm = new RowMutation(\"Keyspace1\", key);\n                for (int k = 0; k < 4; ++k)\n                {\n                    String value = (j + k) % 2 == 0 ? \"a\" : \"b\";\n                    addMutation(rm, \"Super1\", \"SuperColumn-\" + j, k, value, k);\n                }\n                rm.applyUnsafe();\n            }\n        }\n\n        validateNameSort(table, N);\n\n        table.getColumnFamilyStore(\"Standard1\").forceBlockingFlush();\n        table.getColumnFamilyStore(\"Super1\").forceBlockingFlush();\n        validateNameSort(table, N);\n    }","commit_id":"c48abe4c1fbebe1052a53840fee98be91316f3f2","url":"https://github.com/apache/cassandra"},{"original_method":"protected String getContainerText(final XmlTag element, final String name) {\n    return getAdditionalLocation(getDomElement(element)) +\n           \" (\" + element.getContainingFile().getName() + ')';\n  }","id":79163,"modified_method":"protected String getContainerText(final XmlTag element, final String name) {\n    final T domElement = getDomElement(element);\n    if (domElement == null) {\n      return \" (\" + element.getContainingFile().getName() + ')';\n    }\n\n    return getAdditionalLocation(domElement) + \" (\" + element.getContainingFile().getName() + ')';\n  }","commit_id":"71b83c586153b75680847f251cbc811077375dcb","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  protected DomElement getContextElement(final Project project, final Editor editor, final PsiFile file) {\n    if (!(file instanceof XmlFile)) {\n      return null;\n    }\n\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement element = file.findElementAt(offset);\n    if (element == null) return null;\n\n    XmlTag tag = PsiTreeUtil.getParentOfType(element, XmlTag.class);\n    if (tag != null) {\n      return DomManager.getDomManager(project).getDomElement(tag);\n    }\n    return null;\n  }","id":79164,"modified_method":"@Nullable\n  protected DomElement getContextElement(final Project project, final Editor editor, final PsiFile file) {\n    if (!(file instanceof XmlFile)) {\n      return null;\n    }\n\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement element = file.findElementAt(offset);\n    if (element == null) return null;\n\n    XmlTag tag = PsiTreeUtil.getParentOfType(element, XmlTag.class);\n    while (tag != null) {\n      final DomElement domElement = DomManager.getDomManager(project).getDomElement(tag);\n      if(domElement != null) return domElement;\n\n      tag = PsiTreeUtil.getParentOfType(tag, XmlTag.class, true);\n    }\n    return null;\n  }","commit_id":"704998af3954bb5792e490de37acd85ba5456682","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void updateComponent() {\n    if (!getDomElement().isValid()) return;\n\n    final EditorTextField textField = getEditorTextField(getComponent());\n    final Project project = getProject();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        final DomElement domElement = getDomElement();\n        if (!project.isOpen() || domElement == null || !domElement.isValid()) return;\n\n        final DomElementAnnotationsManager manager = DomElementAnnotationsManager.getInstance(project);\n        final List<DomElementProblemDescriptor> errorProblems = manager.getProblems(domElement, true);\n        final List<DomElementProblemDescriptor> warningProblems = manager.getProblems(domElement, true, true, HighlightSeverity.WARNING);\n\n        Color background = getDefaultBackground();\n        if (errorProblems.size() > 0 && textField.getText().trim().length() == 0) {\n          background = getErrorBackground();\n        }\n        else if (warningProblems.size() > 0) {\n          background = getWarningBackground();\n        }\n        textField.setBackground(background);\n\n        //todo!!! tooltip text isn't shown\n        errorProblems.addAll(warningProblems);\n        final String tooltipText = TooltipUtils.getTooltipText(errorProblems);\n\n\n\n        final Editor editor = textField.getEditor();\n        if (editor != null && isCommitted()) {\n          DaemonCodeAnalyzer.getInstance(project).updateVisibleHighlighters(editor);\n        }\n      }\n    });\n\n  }","id":79165,"modified_method":"protected void updateComponent() {\n    final DomElement domElement = getDomElement();\n    if (domElement == null || !domElement.isValid()) return;\n\n    final EditorTextField textField = getEditorTextField(getComponent());\n    final Project project = getProject();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        final DomElement domElement = getDomElement();\n        if (!project.isOpen() || domElement == null || !domElement.isValid()) return;\n\n        final DomElementAnnotationsManager manager = DomElementAnnotationsManager.getInstance(project);\n        final List<DomElementProblemDescriptor> errorProblems = manager.getProblems(domElement, true);\n        final List<DomElementProblemDescriptor> warningProblems = manager.getProblems(domElement, true, true, HighlightSeverity.WARNING);\n\n        Color background = getDefaultBackground();\n        if (errorProblems.size() > 0 && textField.getText().trim().length() == 0) {\n          background = getErrorBackground();\n        }\n        else if (warningProblems.size() > 0) {\n          background = getWarningBackground();\n        }\n        textField.setBackground(background);\n\n        //todo!!! tooltip text isn't shown\n        errorProblems.addAll(warningProblems);\n        final String tooltipText = TooltipUtils.getTooltipText(errorProblems);\n\n\n\n        final Editor editor = textField.getEditor();\n        if (editor != null && isCommitted()) {\n          DaemonCodeAnalyzer.getInstance(project).updateVisibleHighlighters(editor);\n        }\n      }\n    });\n\n  }","commit_id":"642ec8cedce5728ca8f2786f98b3051eda93d45c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Evaluator evaluate() throws EvaluationException {\n    try {\n      final Set<IClassPathItem> classpaths = new HashSet<IClassPathItem>();\n      for (Language language : this.myLanguages) {\n        IClassPathItem item = language.getClassPathItem();\n        classpaths.add(item);\n      }\n      String path = PathManager.getHomePath() + NameUtil.pathFromNamespace(\".lib.tools.\") + \"tools.jar\";\n      classpaths.add(ClassPathFactory.getInstance().createFromPath(path));\n\n      GeneratorManager manager = new GeneratorManager(myContext.getProject(), new GenerationSettings()) {\n        protected boolean generateRequirements() {\n          return false;\n        }\n      };\n\n      InMemoryJavaGenerationHandler handler = new AbstractEvaluationLogic.MyInMemoryJavaGenerationHandler(false, true, classpaths);\n      Project ideaProject = this.myAuxModule.getMPSProject().getProject();\n      DefaultMessageHandler messageHandler = new DefaultMessageHandler(ideaProject);\n      ProgressWindow progressWindow = new ProgressWindow(false, ideaProject);\n      boolean successful = manager.generateModels(ListSequence.fromListAndArray(new ArrayList<SModelDescriptor>(), this.myAuxModel), myContext, handler, progressWindow, messageHandler, true);\n\n      Disposer.dispose(progressWindow);\n\n      String fullClassName = this.myAuxModel.getLongName() + \".\" + EVALUATOR_NAME;\n      String source = handler.getSources().get(fullClassName);\n\n      if (successful || StringUtils.isNotEmpty(source)) {\n        if (isDeveloperMode()) {\n          System.err.println(source);\n        }\n        ClassLoader loader = handler.getCompiler().getClassLoader(this.myUiState.getClass().getClassLoader());\n        Class clazz = Class.forName(fullClassName, true, loader);\n        Evaluator evaluator;\n        try {\n          evaluator = (Evaluator) clazz.getConstructor(JavaUiState.class).newInstance(this.myUiState);\n        } catch (InvocationTargetException e) {\n          // try again \n          myUiState = myDebugSession.refresh();\n          evaluator = (Evaluator) clazz.getConstructor(JavaUiState.class).newInstance(this.myUiState);\n        }\n        return evaluator;\n      } else {\n        throw new EvaluationException(\"Errors during generation.\");\n      }\n    } catch (InvocationTargetException e) {\n      // invocation target exceptions from newInstance method call via reflection \n      // second time, which means refresh did not help \n      // this is bad \n      // I personally think something should be done with all those exceptions \n      // other then hiding them from user \n      // but I do not know what \n      // TODO think \n      throw new InvocationTargetEvaluationException(e.getCause());\n    } catch (EvaluationException e) {\n      throw e;\n    } catch (Throwable t) {\n      throw new EvaluationException(t);\n    }\n  }","id":79166,"modified_method":"@Nullable\n  public Evaluator evaluate() throws EvaluationException {\n    try {\n      final Set<IClassPathItem> classpaths = new HashSet<IClassPathItem>();\n      for (Language language : this.myLanguages) {\n        IClassPathItem item = language.getClassPathItem();\n        classpaths.add(item);\n      }\n      String path = PathManager.getHomePath() + NameUtil.pathFromNamespace(\".lib.tools.\") + \"tools.jar\";\n      classpaths.add(ClassPathFactory.getInstance().createFromPath(path));\n\n      GeneratorManager manager = new GeneratorManager(myContext.getProject(), new GenerationSettings()) {\n        protected boolean generateRequirements() {\n          return false;\n        }\n      };\n\n      final String fullClassName = this.myAuxModel.getLongName() + \".\" + EVALUATOR_NAME;\n      final byte[][] src = new byte[1][1];\n      InMemoryJavaGenerationHandler handler = new AbstractEvaluationLogic.MyInMemoryJavaGenerationHandler(false, true, classpaths);\n      handler.getCompiler().addCompilationResultListener(new CompilationResultAdapter() {\n        public void onClass(ClassFile file) {\n          if (JavaCompiler.getClassName(file).equals(fullClassName)) {\n            src[0] = file.getBytes();\n          }\n        }\n      });\n      Project ideaProject = this.myAuxModule.getMPSProject().getProject();\n      DefaultMessageHandler messageHandler = new DefaultMessageHandler(ideaProject);\n      ProgressWindow progressWindow = new ProgressWindow(false, ideaProject);\n      boolean successful = manager.generateModels(ListSequence.fromListAndArray(new ArrayList<SModelDescriptor>(), this.myAuxModel), myContext, handler, progressWindow, messageHandler, true);\n\n      Disposer.dispose(progressWindow);\n\n      String source = handler.getSources().get(fullClassName);\n\n      if (successful || StringUtils.isNotEmpty(source)) {\n        if (isDeveloperMode()) {\n          System.err.println(source);\n        }\n        ClassLoader parentClassLoader = this.myUiState.getClass().getClassLoader();\n        Class clazz = Class.forName(fullClassName, true, new TrivialClassLoader(parentClassLoader, fullClassName, src[0]));\n        Evaluator evaluator;\n        try {\n          evaluator = (Evaluator) clazz.getConstructor(JavaUiState.class).newInstance(this.myUiState);\n        } catch (InvocationTargetException e) {\n          // try again \n          myUiState = myDebugSession.refresh();\n          evaluator = (Evaluator) clazz.getConstructor(JavaUiState.class).newInstance(this.myUiState);\n        }\n        return evaluator;\n      } else {\n        throw new EvaluationException(\"Errors during generation.\");\n      }\n    } catch (InvocationTargetException e) {\n      // invocation target exceptions from newInstance method call via reflection \n      // second time, which means refresh did not help \n      // this is bad \n      // I personally think something should be done with all those exceptions \n      // other then hiding them from user \n      // but I do not know what \n      // TODO think \n      throw new InvocationTargetEvaluationException(e.getCause());\n    } catch (EvaluationException e) {\n      throw e;\n    } catch (Throwable t) {\n      throw new EvaluationException(t);\n    }\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static IClassPathItem getMPSClassPath() {\n    CompositeClassPathItem result = new CompositeClassPathItem();\n    result.add(getBaseMPSClassPath());\n    result.add(getIDEAOpenAPIJar());\n    result.add(getIDEAJar());\n    result.add(getIDEAUtilJar());\n    result.add(getIDEAExtensionsJar());\n    result.add(getLibraryJars());\n\n    IClassPathItem kernelClassPath = getMPSKernelClassPath();\n    if (kernelClassPath != null) {\n      result.add(kernelClassPath);\n    }\n\n    IClassPathItem debugClassPath = getMPSDebugClassPath();\n    if (debugClassPath != null) {\n      result.add(debugClassPath);\n    }\n\n    IClassPathItem debugAPIClassPath = getMPSDebugAPIClassPath();\n    if (debugAPIClassPath != null) {\n      result.add(debugAPIClassPath);\n    }\n\n    IClassPathItem supportClassPath = getMPSSupportClassPath();\n    if (supportClassPath != null) {\n      result.add(supportClassPath);\n    }\n\n    IClassPathItem workbenchClassPath = getWorkbenchClassPath();\n    if (workbenchClassPath != null) {\n      result.add(getWorkbenchClassPath());\n    }\n\n    IClassPathItem xmlQueryClassPath = getXmlQueryClassPath();\n    if (xmlQueryClassPath != null) {\n      result.add(getXmlQueryClassPath());\n    }\n\n    IClassPathItem svnClassPath = getSVNSupportClasspath();\n    if (svnClassPath != null) {\n      result.add(svnClassPath);\n    }\n\n    IClassPathItem javaConverterClassPath = getJavaConverterClasspath();\n    if (javaConverterClassPath != null) {\n      result.add(javaConverterClassPath);\n    }\n\n    addIfExists(result, \"/lib/commons-lang/commons-lang-2.1.jar\");\n    addIfExists(result, \"/lib/picocontainer/picocontainer.jar\");\n    addIfExists(result, \"/lib/jdom/jdom.jar\");\n\n    addIfExists(result, \"/lib/jetbrains-ideframework/annotations.jar\");\n\n    return result;\n  }","id":79167,"modified_method":"public static IClassPathItem getMPSClassPath() {\n    CompositeClassPathItem result = new CompositeClassPathItem();\n    result.add(getBaseMPSClassPath());\n    result.add(getIDEAOpenAPIJar());\n    result.add(getIDEAJar());\n    result.add(getIDEAUtilJar());\n    result.add(getIDEAExtensionsJar());\n    result.add(getLibraryJars());\n\n    IClassPathItem kernelClassPath = getMPSKernelClassPath();\n    if (kernelClassPath != null) {\n      result.add(kernelClassPath);\n    }\n\n    IClassPathItem debugClassPath = getMPSDebugClassPath();\n    if (debugClassPath != null) {\n      result.add(debugClassPath);\n    }\n\n    IClassPathItem debugAPIClassPath = getMPSDebugAPIClassPath();\n    if (debugAPIClassPath != null) {\n      result.add(debugAPIClassPath);\n    }\n\n    IClassPathItem supportClassPath = getMPSSupportClassPath();\n    if (supportClassPath != null) {\n      result.add(supportClassPath);\n    }\n\n    IClassPathItem workbenchClassPath = getWorkbenchClassPath();\n    if (workbenchClassPath != null) {\n      result.add(getWorkbenchClassPath());\n    }\n\n    IClassPathItem xmlQueryClassPath = getXmlQueryClassPath();\n    if (xmlQueryClassPath != null) {\n      result.add(getXmlQueryClassPath());\n    }\n\n    IClassPathItem svnClassPath = getSVNSupportClasspath();\n    if (svnClassPath != null) {\n      result.add(svnClassPath);\n    }\n\n    IClassPathItem javaConverterClassPath = getJavaConverterClasspath();\n    if (javaConverterClassPath != null) {\n      result.add(javaConverterClassPath);\n    }\n\n    addIfExists(result, \"/lib/commons-lang/commons-lang-2.1.jar\");\n    addIfExists(result, \"/lib/picocontainer/picocontainer.jar\");\n    addIfExists(result, \"/lib/jdom/jdom.jar\");\n    addIfExists(result, \"/lib/eclipse-compiler/ecj.jar\");\n\n    addIfExists(result, \"/lib/jetbrains-ideframework/annotations.jar\");\n\n    return result;\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<CompilationResult> compile(ITaskProgressHelper progress) {\n    myCompiler = createJavaCompiler();\n\n    for (String key : myJavaSources) {\n      myCompiler.addSource(getJavaNameFromKey(key), mySources.get(key));\n    }\n\n    progress.setText2(\"Compiling...\");\n    myCompiler.compile(getClassPath(myContextModules));\n    progress.setText2(\"Compilation finished.\");\n\n    List<CompilationResult> result = myCompiler.getCompilationResults();\n    boolean hasErrors = false;\n    for (CompilationResult cr : result) {\n      if (cr.hasErrors()) {\n        hasErrors = true;\n        CategorizedProblem[] categorizedProblems = cr.getErrors();\n        for (int i = 0; i < 3 && i < categorizedProblems.length; i++) {\n          error(\"\" + categorizedProblems[i]);\n        }\n        info(\"Compilation finished with errors.\");\n        break;\n      }\n    }\n\n    if (!myKeepSources) {\n      mySources.clear();\n      myJavaSources.clear();\n    }\n    myContextModules.clear();\n\n    progress.setText2(\"reloading MPS classes...\");\n    if (myReloadClasses && !hasErrors) {\n      ClassLoaderManager.getInstance().reloadAll(new EmptyProgressIndicator());\n    }\n\n    return hasErrors ? null : result;\n  }","id":79168,"modified_method":"public boolean compile(ITaskProgressHelper progress) {\n    myCompiler = createJavaCompiler();\n\n    for (String key : myJavaSources) {\n      myCompiler.addSource(getJavaNameFromKey(key), mySources.get(key));\n    }\n\n    progress.setText2(\"Compiling...\");\n    MyCompilationResultListener listener = new MyCompilationResultListener();\n    myCompiler.addCompilationResultListener(listener);\n    myCompiler.compile(getClassPath(myContextModules));\n    myCompiler.removeCompilationResultListener(listener);\n    progress.setText2(\"Compilation finished.\");\n\n    if (!myKeepSources) {\n      mySources.clear();\n      myJavaSources.clear();\n    }\n    myContextModules.clear();\n\n    progress.setText2(\"reloading MPS classes...\");\n    if (myReloadClasses && !listener.hasErrors()) {\n      ClassLoaderManager.getInstance().reloadAll(new EmptyProgressIndicator());\n    }\n\n    return listener.hasErrors();\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean compile(Project p, List<Pair<IModule,List<SModelDescriptor>>> input, boolean generationOK, ITaskProgressHelper progressHelper) throws RemoteException, GenerationCanceledException {\n    myResult = compile(progressHelper);\n    return myResult != null;\n  }","id":79169,"modified_method":"public boolean compile(Project p, List<Pair<IModule,List<SModelDescriptor>>> input, boolean generationOK, ITaskProgressHelper progressHelper) throws RemoteException, GenerationCanceledException {\n    return compile(progressHelper);\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void onCompilationResult(CompilationResult r){\n\n  }","id":79170,"modified_method":"private void onCompilationResult(CompilationResult r){\n    for (CompilationResultListener l :myCompilationResultListeners){\n      l.onCompilationResult(r);\n    }\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<CompilationResult> getCompilationResults() {\n    return myCompilationResults;\n  }","id":79171,"modified_method":"public void addCompilationResultListener(CompilationResultListener l){\n    myCompilationResultListeners.add(l);\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void onClass(ClassFile f){\n\n  }","id":79172,"modified_method":"private void onClass(ClassFile f){\n    for (CompilationResultListener l :myCompilationResultListeners){\n      l.onClass(f);\n    }\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    boolean hasAnythingToCompile = false;\n\n    for (IModule m : modules) {\n      if (m.isCompileInMPS()) {\n        hasAnythingToCompile = true;\n      }\n    }\n\n    if (!hasAnythingToCompile) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false, false);\n    }\n\n    JavaCompiler compiler = new JavaCompiler();\n\n    Set<IModule> modulesWithRemovals = new HashSet<IModule>();\n    for (IModule m : modules) {\n      if (areClassesUpToDate(m)) {\n        continue;\n      }\n\n      if (!m.isCompileInMPS()) {\n        LOG.warning(\"Module which compiled in IDEA depend on module which has to be compiled in MPS:\" + m.getModuleFqName(), m);\n        continue;\n      }\n\n      ModuleSources sources = getModuleSources(m);\n\n      for (IFile f : sources.getFilesToDelete()) {\n        f.delete();\n        modulesWithRemovals.add(m);\n      }\n\n      for (JavaFile f : sources.getFilesToCompile()) {\n        compiler.addSource(f.getClassName(), f.getContents());\n        myContainingModules.put(f.getClassName(), m);\n      }\n    }\n\n    invalidateClasspath(modulesWithRemovals);\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    compiler.compile(classPathItems);\n\n    invalidateClasspath(modules);\n\n    int errorCount = 0;\n    int outputtedErrors = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      Set<String> classesWithErrors = new HashSet<String>();\n      if (cr.getErrors() != null) {\n        for (final CategorizedProblem cp : cr.getErrors()) {\n          String fileName = new String(cp.getOriginatingFileName());\n          final String fqName = fileName.substring(0, fileName.length() - MPSExtentions.DOT_JAVAFILE.length()).replace(File.separatorChar, '.');\n          classesWithErrors.add(fqName);\n\n          IModule containingModule = myContainingModules.get(fqName);\n          assert containingModule != null;\n          JavaFile javaFile = myModuleSources.get(containingModule).getJavaFile(fqName);\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n\n          //final SNode nodeToShow = getNodeByLine(cp, fqName);\n\n          Object hintObject = new FileWithPosition(javaFile.getFile(), cp.getSourceStart());\n\n          if (cp.isWarning()) {\n            LOG.warning(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n          } else {\n            if (outputtedErrors == 0) {\n              LOG.error(\"Errors encountered:\\nModules: \" + modules.toString() + \"\\nClasspath: \" + classPathItems + \"\\n\");\n            }\n            if (outputtedErrors < MAX_ERRORS) {\n              outputtedErrors++;\n              LOG.error(messageStirng + \" (line: \" + cp.getSourceLineNumber() + \")\", hintObject);\n            }\n          }\n        }\n\n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String fqName = getName(cf.getCompoundName());\n        String containerClassName = fqName;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen().toFile();\n          String packageName = NameUtil.namespaceFromLongName(fqName);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          if (!outputDir.exists()) {\n            if (!outputDir.mkdirs()) {\n              throw new RuntimeException(\"Can't create \" + outputDir.getPath() + \" directory\");\n            }\n          }\n          String className = NameUtil.shortNameFromLongName(fqName);\n          File output = new File(outputDir, className + \".class\");\n          if (!classesWithErrors.contains(containerClassName)) {\n            FileOutputStream os = null;\n            try {\n              os = new FileOutputStream(output);\n              os.write(cf.getBytes());\n            } catch (IOException e) {\n              LOG.error(\"Can't write to \" + output.getAbsolutePath());\n            } finally {\n              if (os != null) {\n                try {\n                  os.close();\n                } catch (IOException e) {\n                  LOG.error(e);\n                }\n              }\n            }\n          } else {\n            if (output.exists() && !(output.delete())) {\n              LOG.error(\"Can't delete \" + output.getPath());\n            }\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + fqName);\n        }\n      }\n    }\n\n    for (IModule module : modules) {\n      ModuleSources sources = getModuleSources(module);\n      for (ResourceFile toCopy : sources.getResourcesToCopy()) {\n        String fqName = toCopy.getPath();\n\n        fqName = fqName.substring(0, fqName.length() - toCopy.getFile().getName().length());\n        String path = fqName.replace('/', File.separatorChar) + toCopy.getFile().getName();\n\n        FileUtil.copyFile(\n          toCopy.getFile().toFile(),\n          module.getClassesGen().child(path).toFile()\n        );\n      }\n    }\n\n    for (IModule module : modules) {\n      module.updateClassPath();\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","id":79173,"modified_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    boolean hasAnythingToCompile = false;\n\n    for (IModule m : modules) {\n      if (m.isCompileInMPS()) {\n        hasAnythingToCompile = true;\n      }\n    }\n\n    if (!hasAnythingToCompile) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false, false);\n    }\n\n    JavaCompiler compiler = new JavaCompiler();\n\n    Set<IModule> modulesWithRemovals = new HashSet<IModule>();\n    for (IModule m : modules) {\n      if (areClassesUpToDate(m)) {\n        continue;\n      }\n\n      if (!m.isCompileInMPS()) {\n        LOG.warning(\"Module which compiled in IDEA depend on module which has to be compiled in MPS:\" + m.getModuleFqName(), m);\n        continue;\n      }\n\n      ModuleSources sources = getModuleSources(m);\n\n      for (IFile f : sources.getFilesToDelete()) {\n        f.delete();\n        modulesWithRemovals.add(m);\n      }\n\n      for (JavaFile f : sources.getFilesToCompile()) {\n        compiler.addSource(f.getClassName(), f.getContents());\n        myContainingModules.put(f.getClassName(), m);\n      }\n    }\n\n    //todo:do we need this invalidation?\n    invalidateClasspath(modulesWithRemovals);\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    MyCompilationResultAdapter listener = new MyCompilationResultAdapter(modules,classPathItems);\n    compiler.addCompilationResultListener(listener);\n    compiler.compile(classPathItems);\n    compiler.removeCompilationResultListener(listener);\n\n    invalidateClasspath(modules);\n\n\n    for (IModule module : modules) {\n      ModuleSources sources = getModuleSources(module);\n      for (ResourceFile toCopy : sources.getResourcesToCopy()) {\n        String fqName = toCopy.getPath();\n\n        fqName = fqName.substring(0, fqName.length() - toCopy.getFile().getName().length());\n        String path = fqName.replace('/', File.separatorChar) + toCopy.getFile().getName();\n\n        FileUtil.copyFile(\n          toCopy.getFile().toFile(),\n          module.getClassesGen().child(path).toFile()\n        );\n      }\n    }\n\n    for (IModule module : modules) {\n      module.updateClassPath();\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(listener.getErrorCount(), 0, false);\n  }","commit_id":"576dd691664d98d819fe40ade2e51b63cab21bb1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler)\n            throws OperationFailedException {\n        final ModelNode subModel = context.getSubModel();\n\n        populateModel(operation, subModel);\n\n        // Compensating is remove\n        final ModelNode address = operation.require(OP_ADDR);\n        final ModelNode compensating = Util.getResourceRemoveOperation(address);\n        final String rawJndiName = operation.require(JNDINAME).asString();\n        final String jndiName;\n        if (!rawJndiName.startsWith(\"java:/\") && operation.hasDefined(USE_JAVA_CONTEXT)\n                && operation.get(USE_JAVA_CONTEXT).asBoolean()) {\n            jndiName = \"java:/\" + rawJndiName;\n        } else {\n            jndiName = rawJndiName;\n        }\n        final AbstractDataSourceService dataSourceService = createDataSourceService(jndiName, operation);\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                @Override\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceTarget serviceTarget = context.getServiceTarget();\n\n                    boolean enabled = !operation.hasDefined(ENABLED) || operation.get(ENABLED).asBoolean();\n\n                    final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n                    final ServiceBuilder<?> dataSourceServiceBuilder = serviceTarget\n                            .addService(dataSourceServiceName, dataSourceService)\n                            .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                                    dataSourceService.getTransactionIntegrationInjector())\n                            .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n                                    dataSourceService.getmanagementRepositoryInjector())\n                            .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                                    dataSourceService.getSubjectFactoryInjector()).addDependency(NamingService.SERVICE_NAME);\n\n                    final String driverName = operation.require(DRIVER).asString();\n                    final ServiceName driverServiceName = getDriverDependency(driverName);\n                    if (driverServiceName != null) {\n                        dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                                dataSourceService.getDriverInjector());\n                    }\n\n                    final DataSourceReferenceFactoryService referenceFactoryService = new DataSourceReferenceFactoryService();\n                    final ServiceName referenceFactoryServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE\n                            .append(jndiName);\n                    final ServiceBuilder<?> referenceBuilder = serviceTarget.addService(referenceFactoryServiceName,\n                            referenceFactoryService).addDependency(dataSourceServiceName, DataSource.class,\n                            referenceFactoryService.getDataSourceInjector());\n\n                    final BinderService binderService = new BinderService(jndiName.substring(6));\n                    final ServiceName binderServiceName = ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(jndiName);\n                    final ServiceBuilder<?> binderBuilder = serviceTarget\n                            .addService(binderServiceName, binderService)\n                            .addDependency(referenceFactoryServiceName, ManagedReferenceFactory.class,\n                                    binderService.getManagedObjectInjector())\n                            .addDependency(ContextNames.JAVA_CONTEXT_SERVICE_NAME, NamingStore.class,\n                                    binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                                @Override\n                                public void serviceStarted(ServiceController<?> controller) {\n                                    log.infof(\"Bound JDBC Data-source [%s]\", jndiName);\n                                }\n\n                                @Override\n                                public void serviceStopped(ServiceController<?> serviceController) {\n                                    log.infof(\"Unbound JDBC Data-source [%s]\", jndiName);\n                                }\n\n                                @Override\n                                public void serviceRemoved(ServiceController<?> serviceController) {\n                                    log.infof(\"Removed JDBC Data-source [%s]\", jndiName);\n                                    serviceController.removeListener(this);\n                                }\n                            });\n\n                    if (enabled) {\n                        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n                        referenceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n                        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n                    } else {\n                        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.NEVER).install();\n                        referenceBuilder.setInitialMode(ServiceController.Mode.NEVER).install();\n                        binderBuilder.setInitialMode(ServiceController.Mode.NEVER).install();\n                    }\n                    resultHandler.handleResultComplete();\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensating);\n    }","id":79174,"modified_method":"@Override\n    public OperationResult execute(final OperationContext context, final ModelNode operation, final ResultHandler resultHandler)\n            throws OperationFailedException {\n        final ModelNode subModel = context.getSubModel();\n\n        populateModel(operation, subModel);\n\n        // Compensating is remove\n        final ModelNode address = operation.require(OP_ADDR);\n        final ModelNode compensating = Util.getResourceRemoveOperation(address);\n        final String rawJndiName = operation.require(JNDINAME).asString();\n        final String jndiName;\n        if (!rawJndiName.startsWith(\"java:/\") && operation.hasDefined(USE_JAVA_CONTEXT)\n                && operation.get(USE_JAVA_CONTEXT).asBoolean()) {\n            jndiName = \"java:/\" + rawJndiName;\n        } else {\n            jndiName = rawJndiName;\n        }\n        final AbstractDataSourceService dataSourceService = createDataSourceService(jndiName, operation);\n\n        if (context.getRuntimeContext() != null) {\n            context.getRuntimeContext().setRuntimeTask(new RuntimeTask() {\n                @Override\n                public void execute(RuntimeTaskContext context) throws OperationFailedException {\n                    final ServiceTarget serviceTarget = context.getServiceTarget();\n\n                    boolean enabled = !operation.hasDefined(ENABLED) || operation.get(ENABLED).asBoolean();\n\n                    final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n                    final ServiceBuilder<?> dataSourceServiceBuilder = serviceTarget\n                            .addService(dataSourceServiceName, dataSourceService)\n                            .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                                    dataSourceService.getTransactionIntegrationInjector())\n                            .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n                                    dataSourceService.getmanagementRepositoryInjector())\n                            .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                                    dataSourceService.getSubjectFactoryInjector()).addDependency(NamingService.SERVICE_NAME);\n\n                    final String driverName = operation.require(DRIVER).asString();\n                    final ServiceName driverServiceName = getDriverDependency(driverName);\n                    if (driverServiceName != null) {\n                        dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                                dataSourceService.getDriverInjector());\n                    }\n\n                    final DataSourceReferenceFactoryService referenceFactoryService = new DataSourceReferenceFactoryService();\n                    final ServiceName referenceFactoryServiceName = DataSourceReferenceFactoryService.SERVICE_NAME_BASE\n                            .append(jndiName);\n                    final ServiceBuilder<?> referenceBuilder = serviceTarget.addService(referenceFactoryServiceName,\n                            referenceFactoryService).addDependency(dataSourceServiceName, DataSource.class,\n                            referenceFactoryService.getDataSourceInjector());\n\n                    final BinderService binderService = new BinderService(jndiName.substring(6));\n                    final ServiceName binderServiceName = ContextNames.JAVA_CONTEXT_SERVICE_NAME.append(jndiName);\n                    final ServiceBuilder<?> binderBuilder = serviceTarget\n                            .addService(binderServiceName, binderService)\n                            .addDependency(referenceFactoryServiceName, ManagedReferenceFactory.class,\n                                    binderService.getManagedObjectInjector())\n                            .addDependency(ContextNames.JAVA_CONTEXT_SERVICE_NAME, NamingStore.class,\n                                    binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                                @Override\n                                public void serviceStarted(ServiceController<?> controller) {\n                                    log.infof(\"Bound data source [%s]\", jndiName);\n                                }\n\n                                @Override\n                                public void serviceStopped(ServiceController<?> serviceController) {\n                                    log.infof(\"Unbound data source [%s]\", jndiName);\n                                }\n\n                                @Override\n                                public void serviceRemoved(ServiceController<?> serviceController) {\n                                    log.debugf(\"Removed JDBC Data-source [%s]\", jndiName);\n                                    serviceController.removeListener(this);\n                                }\n                            });\n\n                    if (enabled) {\n                        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n                        referenceBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n                        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n                    } else {\n                        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.NEVER).install();\n                        referenceBuilder.setInitialMode(ServiceController.Mode.NEVER).install();\n                        binderBuilder.setInitialMode(ServiceController.Mode.NEVER).install();\n                    }\n                    resultHandler.handleResultComplete();\n                }\n            });\n        } else {\n            resultHandler.handleResultComplete();\n        }\n        return new BasicOperationResult(compensating);\n    }","commit_id":"3b2b8df025855df6c89e108b2bf17a3edb03988b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Create an instance\n     * @param identifier The identifier\n     * @param deployment The deployment\n     */\n    public ResourceAdapterDeployment(ModuleIdentifier identifier, CommonDeployment deployment) {\n        this.identifier = identifier;\n        this.deployment = deployment;\n    }","id":79175,"modified_method":"/**\n     * Create an instance\n     * @param identifier The identifier\n     * @param deployment The deployment\n     */\n    public ResourceAdapterDeployment(CommonDeployment deployment) {\n        this.deployment = deployment;\n    }","commit_id":"3b2b8df025855df6c89e108b2bf17a3edb03988b","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final AS7RaDeployer raDeployer = new AS7RaDeployer(container);\n        raDeployer.setConfiguration(config.getValue());\n        final URL url = connectorXmlDescriptor == null ? null : connectorXmlDescriptor.getUrl();\n        final String deploymentName = connectorXmlDescriptor == null ? null : connectorXmlDescriptor.getDeploymentName();\n        final File root = connectorXmlDescriptor == null ? null : connectorXmlDescriptor.getRoot();\n        CommonDeployment raDeployment = null;\n        try {\n            raDeployment = raDeployer.doDeploy(url, deploymentName, root, module.getClassLoader(), cmd, ijmd);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to start RA deployment [\" + deploymentName + \"]\", t);\n        }\n\n        value = new ResourceAdapterDeployment(module.getIdentifier(), raDeployment);\n        registry.getValue().registerResourceAdapterDeployment(value);\n        managementRepository.getValue().getConnectors().add(value.getDeployment().getConnector());\n        log.debugf(\"Starting sevice %s\",\n                ConnectorServices.RESOURCE_ADAPTER_SERVICE_PREFIX.append(this.value.getDeployment().getDeploymentName()));\n\n        context.getChildTarget()\n                .addService(ServiceName.of(value.getDeployment().getDeploymentName()),\n                        new ResourceAdapterService(value.getDeployment().getResourceAdapter())).setInitialMode(Mode.ACTIVE)\n                .install();\n\n    }","id":79176,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final URL url = connectorXmlDescriptor == null ? null : connectorXmlDescriptor.getUrl();\n        final String deploymentName = connectorXmlDescriptor == null ? null : connectorXmlDescriptor.getDeploymentName();\n        final File root = connectorXmlDescriptor == null ? null : connectorXmlDescriptor.getRoot();\n        CommonDeployment raDeployment = null;\n        final AS7RaDeployer raDeployer = new AS7RaDeployer(container, url, deploymentName, root, module.getClassLoader(), cmd,\n                ijmd);\n        raDeployer.setConfiguration(config.getValue());\n\n        try {\n            raDeployment = raDeployer.doDeploy();\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to start RA deployment [\" + deploymentName + \"]\", t);\n        }\n\n        value = new ResourceAdapterDeployment(raDeployment);\n        registry.getValue().registerResourceAdapterDeployment(value);\n        managementRepository.getValue().getConnectors().add(value.getDeployment().getConnector());\n        log.debugf(\"Starting sevice %s\",\n                ConnectorServices.RESOURCE_ADAPTER_SERVICE_PREFIX.append(this.value.getDeployment().getDeploymentName()));\n\n        context.getChildTarget()\n                .addService(ServiceName.of(value.getDeployment().getDeploymentName()),\n                        new ResourceAdapterService(value.getDeployment().getResourceAdapter())).setInitialMode(Mode.ACTIVE)\n                .install();\n\n    }","commit_id":"3b2b8df025855df6c89e108b2bf17a3edb03988b","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** create an instance **/\n\n    @Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting sevice %s\",\n                ConnectorServices.RESOURCE_ADAPTER_XML_SERVICE_PREFIX.append(this.value.getDeployment().getDeploymentName()));\n\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final AS7RaDeployer raDeployer = new AS7RaDeployer(container);\n        raDeployer.setConfiguration(config.getValue());\n\n        CommonDeployment raxmlDeployment = null;\n        try {\n            raxmlDeployment = raDeployer.doDeploy(connectorXmlDescriptor.getUrl(), deploymentName, root,\n                    module.getClassLoader(), cmd, ijmd, raxml);\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to start RA deployment [\" + deploymentName + \"]\", t);\n        }\n\n        value = new ResourceAdapterDeployment(module.getIdentifier(), raxmlDeployment);\n\n        registry.getValue().registerResourceAdapterDeployment(value);\n        managementRepository.getValue().getConnectors().add(value.getDeployment().getConnector());\n\n    }","id":79177,"modified_method":"/** create an instance **/\n\n    @Override\n    public void start(StartContext context) throws StartException {\n        log.debugf(\"Starting sevice %s\",\n                ConnectorServices.RESOURCE_ADAPTER_XML_SERVICE_PREFIX.append(this.value.getDeployment().getDeploymentName()));\n\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final AS7RaXmlDeployer raDeployer = new AS7RaXmlDeployer(container, connectorXmlDescriptor.getUrl(), deploymentName, root,\n                module.getClassLoader(), cmd, raxml);\n\n        raDeployer.setConfiguration(config.getValue());\n\n        CommonDeployment raxmlDeployment = null;\n        try {\n            raxmlDeployment = raDeployer.doDeploy();\n        } catch (Throwable t) {\n            throw new StartException(\"Failed to start RA deployment [\" + deploymentName + \"]\", t);\n        }\n\n        value = new ResourceAdapterDeployment(raxmlDeployment);\n\n        registry.getValue().registerResourceAdapterDeployment(value);\n        managementRepository.getValue().getConnectors().add(value.getDeployment().getConnector());\n\n    }","commit_id":"3b2b8df025855df6c89e108b2bf17a3edb03988b","url":"https://github.com/wildfly/wildfly"},{"original_method":"public boolean includeFile(FileSelectInfo info) \n\t\t{\n\t\t\tboolean returncode=false;\n\t\t\tFileObject file_name=null;\n\t\t\t\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (!info.getFile().toString().equals(root_folder))\n\t\t\t\t{\n\t\t\t\t\t// Pass over the Base folder itself\n\t\t\t\t\tif ((info.getFile().getType() == FileType.FILE))\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (info.getFile().getParent().equals(info.getBaseFolder()))\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t// We are in the Base folder\n\t\t\t\t\t\t\tif((isSpecifyWildcard() && GetFileWildcard(info.getFile().toString()) || !isSpecifyWildcard()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Found files\", \"We found file : \" + info.getFile().toString());\n\t\t\t\t\t\t\t\tfilescount++; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// We are not in the base Folder...ONLY if Use sub folders\n\t\t\t\t\t\t\t// We are in the Base folder\n\t\t\t\t\t\t\tif((isSpecifyWildcard() && GetFileWildcard(info.getFile().toString()) || !isSpecifyWildcard())\n\t\t\t\t\t\t\t\t\t&& (isIncludeSubFolders()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Found files\", \"We found file : \" + info.getFile().toString());\n\t\t\t\t\t\t\t\tfilescount++; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfolderscount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (Exception e) \n\t\t\t{\n\t\t\t\tlog.logError(Messages.getString(\"JobFolderIsEmpty.Error\") , Messages.getString(\"JobFolderIsEmpty.Error.Exception\", \n\t\t\t\t\t\tinfo.getFile().toString(),e.getMessage()));\n\t\t\t\t returncode= false;\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\tif ( file_name != null )\n\t\t\t\t{\n\t\t\t\t\ttry  \n\t\t\t\t\t{\n\t\t\t\t\t\tfile_name.close();\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn returncode;\n\t\t}","id":79178,"modified_method":"public boolean includeFile(FileSelectInfo info) \n\t\t{\n\t\t\tboolean returncode=false;\n\t\t\tFileObject file_name=null;\n\t\t\t\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (!info.getFile().toString().equals(root_folder))\n\t\t\t\t{\n\t\t\t\t\t// Pass over the Base folder itself\n\t\t\t\t\tif ((info.getFile().getType() == FileType.FILE))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (info.getFile().getParent().equals(info.getBaseFolder()))\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t// We are in the Base folder\n\t\t\t\t\t\t\tif((isSpecifyWildcard() && GetFileWildcard(info.getFile().getName().getBaseName())) || !isSpecifyWildcard())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Found files\", \"We found file : \" + info.getFile().toString());\n\t\t\t\t\t\t\t\tfilescount++; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t }\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// We are not in the base Folder...ONLY if Use sub folders\n\t\t\t\t\t\t\t// We are in the Base folder\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(isIncludeSubFolders())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif((isSpecifyWildcard() && GetFileWildcard(info.getFile().getName().getBaseName())) || !isSpecifyWildcard())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(log.isDetailed()) log.logDetailed(\"Found files\", \"We found file : \" + info.getFile().toString());\n\t\t\t\t\t\t\t\t\tfilescount++; \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfolderscount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tcatch (Exception e) \n\t\t\t{\n\t\t\t\tlog.logError(Messages.getString(\"JobFolderIsEmpty.Error\") , \n\t\t\t\t\t\tMessages.getString(\"JobFolderIsEmpty.Error.Exception\", \n\t\t\t\t\t\tinfo.getFile().toString(),e.getMessage()));\n\t\t\t\t returncode= false;\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\tif ( file_name != null )\n\t\t\t\t{\n\t\t\t\t\ttry  \n\t\t\t\t\t{\n\t\t\t\t\t\tfile_name.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn returncode;\n\t\t}","commit_id":"46c2271e50d9880ea3ef70a3796051f8e681e407","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**********************************************************\n\t * \n\t * @param selectedfile\n\t * @param wildcard\n\t * @return True if the selectedfile matches the wildcard\n\t **********************************************************/\n\tprivate boolean GetFileWildcard(String selectedfile)\n\t{\n\t\tPattern pattern = null;\n\t\tboolean getIt=true;\n\t\n        if (!Const.isEmpty(getWildcard()))\n        {\n        \t pattern = Pattern.compile(getRealWildcard());\n\t\t\t// First see if the file matches the regular expression!\n\t\t\tif (pattern!=null)\n\t\t\t{\n\t\t\t\tMatcher matcher = pattern.matcher(selectedfile);\n\t\t\t\tgetIt = matcher.matches();\n\t\t\t}\n        }\n\t\t\n\t\treturn getIt;\n\t}","id":79179,"modified_method":"/**********************************************************\n\t * \n\t * @param selectedfile\n\t * @param wildcard\n\t * @return True if the selectedfile matches the wildcard\n\t **********************************************************/\n\tprivate boolean GetFileWildcard(String selectedfile)\n\t{\n\t\tboolean getIt=true;\n\t\n\t\t// First see if the file matches the regular expression!\n\t\tif (pattern!=null)\n\t\t{\n\t\t\tMatcher matcher = pattern.matcher(selectedfile);\n\t\t\tgetIt = matcher.matches();\n\t\t}\n\t\treturn getIt;\n\t}","commit_id":"46c2271e50d9880ea3ef70a3796051f8e681e407","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tResult result = previousResult;\n\t\tresult.setResult( false );\n\t\t\n\t\tfilescount=0;\n\t\tfolderscount=0;\n\t\t\n\t\tif (foldername!=null)\n\t\t{\n            String realFoldername = getRealFoldername();\n            FileObject FolderObject = null;\n\t\t\ttry {\n\t\t\t\tFolderObject = KettleVFS.getFileObject(realFoldername);\n\n\t\t\t\tif ( FolderObject.exists() )\n\t\t\t\t{\n\t\t\t\t\t//Check if it's a folder\n\t\t\t\t\tif(FolderObject.getType() == FileType.FOLDER) \n\t\t\t\t\t{\n\t\t\t\t\t\t// File provided is a folder, so we can process ...\n\t\t\t\t\t\tFolderObject.findFiles(new TextFileSelector(FolderObject.toString()));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(log.isBasic())\n\t\t\t\t\t\t\tlog.logBasic(\"Total files\", \"We found : \"+filescount + \" file(s)\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(filescount==0) result.setResult(true);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Not a folder, fail\n\t\t\t\t\t\tlog.logError(\"Found files\", \"[\" + realFoldername+\"] is not a folder, failing.\");\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//  No Folder found\t\n\t\t\t\t\tif(log.isBasic())\n\t\t\t\t\t\tlog.logBasic(toString(), \"we can not find [\"+realFoldername+\"] !\");\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tlog.logError(toString(), \"Could not create Folder [\"+realFoldername+\"], exception: \" + e.getMessage());\n\t\t\t\tresult.setResult( false );\n\t\t\t\tresult.setNrErrors(1);\t\t\t\t\t\n\t\t\t}\n            finally {\n            \tif ( FolderObject != null )\n            \t{\n            \t\ttry  {\n            \t\t     FolderObject.close();\n            \t\t}\n            \t\tcatch ( IOException ex ) {};\n            \t}\n            }\t\t\t\n\t\t}\n\t\telse\n\t\t{\t\t\t\n\t\t\tlog.logError(toString(), \"No Foldername is defined.\");\n\t\t}\n\t\t\n\t\treturn result;\n\t}","id":79180,"modified_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tResult result = previousResult;\n\t\tresult.setResult( false );\n\t\tresult.setNrErrors(1);\n\t\t\n\t\tfilescount=0;\n\t\tfolderscount=0;\n\t\tpattern = null;\n\t\t\n\t\tif (!Const.isEmpty(getWildcard()))  pattern = Pattern.compile(getRealWildcard());\n\t\t\n\t\tif (foldername!=null)\n\t\t{\n            String realFoldername = getRealFoldername();\n            FileObject FolderObject = null;\n\t\t\ttry {\n\t\t\t\tFolderObject = KettleVFS.getFileObject(realFoldername);\n\n\t\t\t\tif ( FolderObject.exists() )\n\t\t\t\t{\n\t\t\t\t\t//Check if it's a folder\n\t\t\t\t\tif(FolderObject.getType() == FileType.FOLDER) \n\t\t\t\t\t{\n\t\t\t\t\t\t// File provided is a folder, so we can process ...\n\t\t\t\t\t\tFolderObject.findFiles(new TextFileSelector(FolderObject.toString()));\n\t\t\t\t\t\tif(log.isBasic())\tlog.logBasic(\"Total files\", \"We found : \"+filescount + \" file(s)\");\n\t\t\t\t\t\tif(filescount==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult.setResult(true);\n\t\t\t\t\t\t\tresult.setNrErrors(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Not a folder, fail\n\t\t\t\t\t\tlog.logError(\"Found files\", \"[\" + realFoldername+\"] is not a folder, failing.\");\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//  No Folder found\t\n\t\t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"we can not find [\"+realFoldername+\"] !\");\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tlog.logError(toString(), \"Could not create Folder [\"+realFoldername+\"], exception: \" + e.getMessage());\n\t\t\t\tresult.setResult( false );\n\t\t\t\tresult.setNrErrors(1);\t\t\t\t\t\n\t\t\t}\n            finally {\n            \tif ( FolderObject != null )\n            \t{\n            \t\ttry  {\n            \t\t     FolderObject.close();\n            \t\t}\n            \t\tcatch ( IOException ex ) {};\n            \t}\n            }\t\t\t\n\t\t}\n\t\telse\n\t\t{\t\t\t\n\t\t\tlog.logError(toString(), \"No Foldername is defined.\");\n\t\t}\n\t\t\n\t\treturn result;\n\t}","commit_id":"46c2271e50d9880ea3ef70a3796051f8e681e407","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\t\n\t\t\ttablename  = rep.getJobEntryAttributeString(id_jobentry, \"tablename\");\n\t\t\tfilename  = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tseparator  = rep.getJobEntryAttributeString(id_jobentry, \"separator\");\n\t\t\treplacedata = rep.getJobEntryAttributeBoolean(id_jobentry, \"replacedata\");\n\t\t\tignorelines  = rep.getJobEntryAttributeString(id_jobentry, \"ignorelines\");\n\t\t\tlistattribut  = rep.getJobEntryAttributeString(id_jobentry, \"listattribut\");\n\n\t\t\tlong id_db = rep.getJobEntryAttributeInteger(id_jobentry, \"id_database\");\n\t\t\tif (id_db>0)\n\t\t\t{\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, id_db);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is were we end up in normally, the previous lines are for backward compatibility.\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, rep.getJobEntryAttributeString(id_jobentry, \"connection\"));\n\t\t\t}\n\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'table exists' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","id":79181,"modified_method":"public void loadRep(Repository rep, long id_jobentry, ArrayList databases)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases);\n\t\t\t\n\t\t\ttablename  = rep.getJobEntryAttributeString(id_jobentry, \"tablename\");\n\t\t\tfilename  = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tseparator  = rep.getJobEntryAttributeString(id_jobentry, \"separator\");\n\t\t\treplacedata = rep.getJobEntryAttributeBoolean(id_jobentry, \"replacedata\");\n\t\t\tignorelines  = rep.getJobEntryAttributeString(id_jobentry, \"ignorelines\");\n\t\t\tlistattribut  = rep.getJobEntryAttributeString(id_jobentry, \"listattribut\");\n\n\t\t\tlocalinfile=rep.getJobEntryAttributeBoolean(id_jobentry, \"localinfile\");\n\n\t\t\tlong id_db = rep.getJobEntryAttributeInteger(id_jobentry, \"id_database\");\n\t\t\tif (id_db>0)\n\t\t\t{\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, id_db);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is were we end up in normally, the previous lines are for backward compatibility.\n\t\t\t\tconnection = DatabaseMeta.findDatabase(databases, rep.getJobEntryAttributeString(id_jobentry, \"connection\"));\n\t\t\t}\n\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'table exists' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getRealFilename()\n\t{\n\t\treturn StringUtil.environmentSubstitute(getFilename());\n\t}","id":79182,"modified_method":"public String getRealFilename()\n\t{\n \n\t\tString RealFile= StringUtil.environmentSubstitute(getFilename());\n\t\treturn RealFile.replace('\\\\','/');\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_job)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.saveRep(rep, id_job);\n\t\t\t\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"tablename\", tablename);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename\", filename);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"separator\", separator);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"replacedata\", replacedata);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"ignorelines\", ignorelines);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"listattribut\", listattribut);\t\t\n\n\n\t\t\tif (connection!=null) rep.saveJobEntryAttribute(id_job, getID(), \"connection\", connection.getName());\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'table exists' to the repository for id_job=\"+id_job, dbe);\n\t\t}\n\t}","id":79183,"modified_method":"public void saveRep(Repository rep, long id_job)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.saveRep(rep, id_job);\n\t\t\t\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"tablename\", tablename);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename\", filename);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"separator\", separator);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"replacedata\", replacedata);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"ignorelines\", ignorelines);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"listattribut\", listattribut);\t\n\t\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"localinfile\", localinfile);\n\t\t\t\n\n\n\t\t\tif (connection!=null) rep.saveJobEntryAttribute(id_job, getID(), \"connection\", connection.getName());\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'Mysql Bulk Load' to the repository for id_job=\"+id_job, dbe);\n\t\t}\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(200);\n\t\t\n\t\tretval.append(super.getXML());\n\t\t\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"tablename\",  tablename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\",  filename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"separator\",  separator));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"replacedata\",  replacedata));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"ignorelines\",  ignorelines));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"listattribut\",  listattribut));\n\n\t\t\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"connection\", connection==null?null:connection.getName()));\n\t\t\n\t\treturn retval.toString();\n\t}","id":79184,"modified_method":"public String getXML()\n\t{\n\t\tStringBuffer retval = new StringBuffer(200);\n\t\t\n\t\tretval.append(super.getXML());\n\t\t\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"tablename\",  tablename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\",  filename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"separator\",  separator));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"replacedata\",  replacedata));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"ignorelines\",  ignorelines));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"listattribut\",  listattribut));\n\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"localinfile\",  localinfile));\n\n\t\t\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"connection\", connection==null?null:connection.getName()));\n\t\t\n\t\treturn retval.toString();\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result execute(Result prev_result, int nr, Repository rep, Job parentJob)\n\t{\n\t\tString ReplaceIgnore;\n\t\tString IgnoreNbrLignes;\n\t\tString ListOfColumn=\"\";\n\t\tLogWriter log = LogWriter.getInstance();\n\n\t\tResult result = new Result(nr);\n\t\tresult.setResult(false);\n\t\t\n\t\tif (connection!=null)\n\t\t{\n\t\t\tDatabase db = new Database(connection);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n                String realTablename = StringUtil.environmentSubstitute(tablename);\n\t\t\t\tif (db.checkTableExists(realTablename))\n\t\t\t\t{\n\t\t\t\t\t// The table existe, we can continue\n\t\t\t\t\tlog.logDetailed(toString(), \"Table [\"+realTablename+\"] exists.\");\n\n\t\t\t\t\t// Let's check now the filename ...\n\t\t\t\t\tif (filename!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tString realFilename = getRealFilename(); \n\t\t\t\t\t\t// File file = new File(realFilename);\n\t\t\t\t\t\tif (1 == 1 ) //file.exists() && file.canRead())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// File exist, we can continue ...\n\t\t\t\t\t\t\tlog.logDetailed(toString(), \"File [\"+realFilename+\"] exists.\");\n\n\t\t\t\t\t\t\t// Set the REPLACE or IGNORE \n\t\t\t\t\t\t\tif (isReplacedata())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tReplaceIgnore=\"REPLACE\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tReplaceIgnore=\"IGNORE\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set the IGNORE LINES\n\t\t\t\t\t\t\tif (Const.toInt(getRealIgnorelines(),0)>0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIgnoreNbrLignes = \" IGNORE \" + getRealIgnorelines() + \" LINES \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIgnoreNbrLignes =\" \";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Set list of Column \n\t\t\t\t\t\t\tif (getRealListattribut()!= null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tListOfColumn=\"(\" + getRealListattribut() + \")\";\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\t\t// Let's built Bulk Load String\n\t\t\t\t\t\t\tString SQLBULKLOAD=\"LOAD DATA INFILE '\" + \n\t\t\t\t\t\t\t\trealFilename + \t\"' \" + ReplaceIgnore + \n\t\t\t\t\t\t\t\t\" INTO TABLE \" + realTablename + \" FIELDS TERMINATED BY  '\" + \n\t\t\t\t\t\t\t\tgetRealSeparator() + \"' \" + IgnoreNbrLignes + \" \" + ListOfColumn + \";\";\n\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdb.execStatements(SQLBULKLOAD);\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch(KettleDatabaseException je)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\t\t\t\tlog.logError(toString(), \"An error occurred executing this job entry : \"+je.getMessage());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdb.disconnect();\r\n\t\t\t\t\t\t\t}\t\n\n\t\t\t\t\t\t\t\tdb.disconnect();\n\t\t\t\t\t\t\t\tresult.setResult(true);\n\n\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult.setNrErrors(1);\n\t\t\t\t\t\t\tlog.logDetailed(toString(), \"File [\"+realFilename+\"] doesn't exist!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.setNrErrors(1);\n\t\t\t\t\t\tlog.logError(toString(), \"No filename is defined.\");\n\t\t\t\t\t}\n\n\n\t\t\t\t\t//result.setResult(true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Of course, the table should have been created already before the bulk load operation\n\t\t\t\t\tlog.logDetailed(toString(), \"Table [\"+realTablename+\"] doesn't exist!\");\n\t\t\t\t}\n\t\t\t\tdb.disconnect();\n\t\t\t}\n\t\t\tcatch(KettleDatabaseException dbe)\n\t\t\t{\n\t\t\t\tresult.setNrErrors(1);\n\t\t\t\tlog.logError(toString(), \"An error occurred executing this step: \"+dbe.getMessage());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.setNrErrors(1);\n\t\t\tlog.logError(toString(), \"No database connection is defined.\");\n\t\t}\n\t\t\n\t\treturn result;\n\t}","id":79185,"modified_method":"public Result execute(Result prev_result, int nr, Repository rep, Job parentJob)\n\t{\n\t\tString ReplaceIgnore;\r\n\t\tString IgnoreNbrLignes;\r\n\t\tString ListOfColumn=\"\";\r\n\t\tString LocalExec=\"\";\r\n\t\tLogWriter log = LogWriter.getInstance();\n\t\t\r\n\t\tResult result = new Result(nr);\r\n\t\tresult.setResult(false);\n\n\t\t// Let's check  the filename ...\r\n\t\tif (filename!=null)\r\n\t\t{\n\t\t\t// User has specified a file, We can continue ...\n\t\t\tString realFilename = getRealFilename(); \r\n\t\t\tFile file = new File(realFilename);\r\n\t\t\tif ((file.exists() && file.canRead()) ||  isLocalInfile()==false)\r\n\t\t\t{\r\n\t\t\t\t// User has specified an existing file, We can continue ...\n\t\t\t\tlog.logDetailed(toString(), \"File [\"+realFilename+\"] exists.\");\n\n\n\t\t\t\tif (connection!=null)\r\n\t\t\t\t{\n\t\t\t\t\t// User has specified a connection, We can continue ...\n\t\t\t\t\tDatabase db = new Database(connection);\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdb.connect();\r\n\t\t\t\t\t\t// Get tablename\r\n\t\t\t\t\t\tString realTablename = StringUtil.environmentSubstitute(tablename);\r\n\r\n\t\t\t\t\t\tif (db.checkTableExists(realTablename))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// The table existe, We can continue ...\r\n\t\t\t\t\t\t\tlog.logDetailed(toString(), \"Table [\"+realTablename+\"] exists.\");\r\n\r\n\n\t\t\t\t\t\t\t// Set the REPLACE or IGNORE \r\n\t\t\t\t\t\t\tif (isReplacedata())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tReplaceIgnore=\"REPLACE\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tReplaceIgnore=\"IGNORE\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Set the IGNORE LINES\r\n\t\t\t\t\t\t\tif (Const.toInt(getRealIgnorelines(),0)>0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tIgnoreNbrLignes = \" IGNORE \" + getRealIgnorelines() + \" LINES \";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tIgnoreNbrLignes =\" \";\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Set list of Column \r\n\t\t\t\t\t\t\tif (getRealListattribut()!= null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tListOfColumn=\"(\" + getRealListattribut() + \")\";\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\t\t// Local File execution\r\n\t\t\t\t\t\t\tif (isLocalInfile())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tLocalExec = \" LOCAL \";\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Let's built Bulk Load String\r\n\t\t\t\t\t\t\tString SQLBULKLOAD=\"LOAD DATA \" + LocalExec + \" INFILE '\" + realFilename + \t\"' \" + ReplaceIgnore + \r\n\t\t\t\t\t\t\t\t\" INTO TABLE \" + realTablename + \" FIELDS TERMINATED BY  '\" + getRealSeparator() + \"' \" + IgnoreNbrLignes + \" \" + ListOfColumn + \";\";\r\n\n\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Run the SQL\r\n\t\t\t\t\t\t\t\tdb.execStatements(SQLBULKLOAD);\r\n\r\n\r\n\t\t\t\t\t\t\t\t// Everything is OK...we can deconnect now\r\n\t\t\t\t\t\t\t\tdb.disconnect();\r\n\t\t\t\t\t\t\t\tresult.setResult(true);\r\n\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch(KettleDatabaseException je)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdb.disconnect();\r\n\t\t\t\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\t\t\t\tlog.logError(toString(), \"An error occurred executing this job entry : \"+je.getMessage());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Of course, the table should have been created already before the bulk load operation\r\n\t\t\t\t\t\t\tdb.disconnect();\r\n\t\t\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\t\t\tlog.logDetailed(toString(), \"Table [\"+realTablename+\"] doesn't exist!\");\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(KettleDatabaseException dbe)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdb.disconnect();\r\n\t\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\t\tlog.logError(toString(), \"An error occurred executing this entry: \"+dbe.getMessage());\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\n\n\n\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// No database connection is defined\n\t\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\t\tlog.logError(toString(),  Messages.getString(\"JobMysqlBulkLoad.Nodatabase.Label\"));\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// the file doesn't exist\n\t\t\t\tresult.setNrErrors(1);\r\n\t\t\t\tlog.logDetailed(toString(), \"File [\"+realFilename+\"] doesn't exist!\");\n\n\t\t\t}\n\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// No file was specified\n\t\t\tresult.setNrErrors(1);\r\n\t\t\tlog.logError(toString(), Messages.getString(\"JobMysqlBulkLoad.Nofilename.Label\"));\n\t\t}\n\n\t\treturn result;\n\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryMysqlBulkLoad(String n)\n\t{\n\t    super(n, \"\");\n\t\ttablename=null;\n\t\tfilename=null;\n\t\tseparator=null;\n\t\treplacedata=true;\n\t\tignorelines = \"0\";\n\t\tlistattribut=null;\n\t\tconnection=null;\n\t\tsetID(-1L);\n\t\tsetType(JobEntryInterface.TYPE_JOBENTRY_MYSQL_BULK_LOAD);\n\t}","id":79186,"modified_method":"public JobEntryMysqlBulkLoad(String n)\n\t{\n\t\tsuper(n, \"\");\n\t\ttablename=null;\n\t\tfilename=null;\n\t\tseparator=null;\n\t\treplacedata=true;\n\t\tignorelines = \"0\";\n\t\tlistattribut=null;\n\t\tlocalinfile=true;\n\t\tconnection=null;\n\t\tsetID(-1L);\n\t\tsetType(JobEntryInterface.TYPE_JOBENTRY_MYSQL_BULK_LOAD);\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadXML(Node entrynode, ArrayList databases, Repository rep) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadXML(entrynode, databases);\n\t\t\t\n\t\t\ttablename     = XMLHandler.getTagValue(entrynode, \"tablename\");\n\t\t\tfilename     = XMLHandler.getTagValue(entrynode, \"filename\");\n\t\t\tseparator     = XMLHandler.getTagValue(entrynode, \"separator\");\n\t\t\treplacedata = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"replacedata\"));\n\t\t\tignorelines     = XMLHandler.getTagValue(entrynode, \"ignorelines\");\n\t\t\tlistattribut     = XMLHandler.getTagValue(entrynode, \"listattribut\");\n\n\t\t\tString dbname = XMLHandler.getTagValue(entrynode, \"connection\");\n\t\t\tconnection    = DatabaseMeta.findDatabase(databases, dbname);\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load job entry of type 'table exists' from XML node\", e);\n\t\t}\n\t}","id":79187,"modified_method":"public void loadXML(Node entrynode, ArrayList databases, Repository rep) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadXML(entrynode, databases);\n\t\t\t\n\t\t\ttablename     = XMLHandler.getTagValue(entrynode, \"tablename\");\n\t\t\tfilename     = XMLHandler.getTagValue(entrynode, \"filename\");\n\t\t\tseparator     = XMLHandler.getTagValue(entrynode, \"separator\");\n\t\t\treplacedata = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"replacedata\"));\n\t\t\tignorelines     = XMLHandler.getTagValue(entrynode, \"ignorelines\");\n\t\t\tlistattribut     = XMLHandler.getTagValue(entrynode, \"listattribut\");\n\n\t\t\tlocalinfile = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"localinfile\"));\n\n\n\t\t\tString dbname = XMLHandler.getTagValue(entrynode, \"connection\");\n\t\t\tconnection    = DatabaseMeta.findDatabase(databases, dbname);\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load job entry of type 'table exists' from XML node\", e);\n\t\t}\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n    {\n        Shell parent = getParent();\n        Display display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n        ModifyListener lsMod = new ModifyListener()\n        {\n            public void modifyText(ModifyEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        };\n        changed = jobEntry.hasChanged();\n\n        FormLayout formLayout = new FormLayout();\n        formLayout.marginWidth = Const.FORM_MARGIN;\n        formLayout.marginHeight = Const.FORM_MARGIN;\n\n        shell.setLayout(formLayout);\n        shell.setText(Messages.getString(\"JobMysqlBulkLoad.Title\"));\n\n        int middle = props.getMiddlePct();\n        int margin = Const.MARGIN;\n\n        // Filename line\n        wlName = new Label(shell, SWT.RIGHT);\n        wlName.setText(Messages.getString(\"JobMysqlBulkLoad.Name.Label\"));\n        props.setLook(wlName);\n        fdlName = new FormData();\n        fdlName.left = new FormAttachment(0, 0);\n        fdlName.right = new FormAttachment(middle, 0);\n        fdlName.top = new FormAttachment(0, margin);\n        wlName.setLayoutData(fdlName);\n        wName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wName);\n        wName.addModifyListener(lsMod);\n        fdName = new FormData();\n        fdName.left = new FormAttachment(middle, 0);\n        fdName.top = new FormAttachment(0, margin);\n        fdName.right = new FormAttachment(100, 0);\n        wName.setLayoutData(fdName);\n\n        // Connection line\n        wlConnection = new Label(shell, SWT.RIGHT);\n        wlConnection.setText(Messages.getString(\"JobMysqlBulkLoad.Connection.Label\"));\n        props.setLook(wlConnection);\n        fdlConnection = new FormData();\n        fdlConnection.left = new FormAttachment(0, 0);\n        fdlConnection.top = new FormAttachment(wName, margin);\n        fdlConnection.right = new FormAttachment(middle, -margin);\n        wlConnection.setLayoutData(fdlConnection);\n\n        wbConnection = new Button(shell, SWT.PUSH);\n        wbConnection.setText(Messages.getString(\"System.Button.New\") + \"...\");\n        wbConnection.addSelectionListener(new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent e)\n            {\n                DatabaseMeta databaseMeta = new DatabaseMeta();\n                DatabaseDialog cid = new DatabaseDialog(shell, databaseMeta);\n                if (cid.open() != null)\n                {\n                    jobMeta.addDatabase(databaseMeta);\n\n                    // SB: Maybe do the same her as in BaseStepDialog: remove\n                    // all db connections and add them again.\n                    wConnection.add(databaseMeta.getName());\n                    wConnection.select(wConnection.getItemCount() - 1);\n                }\n            }\n        });\n        fdbConnection = new FormData();\n        fdbConnection.right = new FormAttachment(100, 0);\n        fdbConnection.top = new FormAttachment(wName, margin);\n        fdbConnection.height = 20;\n        wbConnection.setLayoutData(fdbConnection);\n\n        wConnection = new CCombo(shell, SWT.BORDER | SWT.READ_ONLY);\n        props.setLook(wConnection);\n        for (int i = 0; i < jobMeta.nrDatabases(); i++)\n        {\n            DatabaseMeta ci = jobMeta.getDatabase(i);\n            wConnection.add(ci.getName());\n        }\n        wConnection.select(0);\n        wConnection.addModifyListener(lsMod);\n        fdConnection = new FormData();\n        fdConnection.left = new FormAttachment(middle, 0);\n        fdConnection.top = new FormAttachment(wName, margin);\n        fdConnection.right = new FormAttachment(wbConnection, -margin);\n        wConnection.setLayoutData(fdConnection);\n\n        // Table name line\n        wlTablename = new Label(shell, SWT.RIGHT);\n        wlTablename.setText(Messages.getString(\"JobMysqlBulkLoad.Tablename.Label\"));\n        props.setLook(wlTablename);\n        fdlTablename = new FormData();\n        fdlTablename.left = new FormAttachment(0, 0);\n        fdlTablename.right = new FormAttachment(middle, 0);\n        fdlTablename.top = new FormAttachment(wConnection, margin);\n        wlTablename.setLayoutData(fdlTablename);\n\n        wTablename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wTablename);\n        wTablename.addModifyListener(lsMod);\n        fdTablename = new FormData();\n        fdTablename.left = new FormAttachment(middle, 0);\n        fdTablename.top = new FormAttachment(wConnection, margin);\n        fdTablename.right = new FormAttachment(100, 0);\n        wTablename.setLayoutData(fdTablename);\n\n\n\n\n\t\t// Filename line\n\t\twlFilename = new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"JobMysqlBulkLoad.Filename.Label\"));\n\t\tprops.setLook(wlFilename);\n\t\tfdlFilename = new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdlFilename.right = new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbFilename = new Button(shell, SWT.PUSH | SWT.CENTER);\n\t\tprops.setLook(wbFilename);\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename = new FormData();\n\t\tfdbFilename.right = new FormAttachment(100, 0);\n\t\tfdbFilename.top = new FormAttachment(wTablename, 0);\n\t\t// fdbFilename.height = 22;\n\t\twbFilename.setLayoutData(fdbFilename);\n\n\t\twFilename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename = new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdFilename.right = new FormAttachment(wbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twFilename.setToolTipText(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t}\n\t\t});\n\n\t\twbFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\tdialog.setFilterExtensions(new String[] { \"*.txt\", \"*.csv\", \"*\" });\n\t\t\t\tif (wFilename.getText() != null)\n\t\t\t\t{\n\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t\t}\n\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\tif (dialog.open() != null)\n\t\t\t\t{\n\t\t\t\t\twFilename.setText(dialog.getFilterPath() + Const.FILE_SEPARATOR\n\t\t\t\t\t\t+ dialog.getFileName());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\n\t\t// Separator\n\t\twlSeparator = new Label(shell, SWT.RIGHT);\n\t\twlSeparator.setText(Messages.getString(\"JobMysqlBulkLoad.Separator.Label\"));\n\t\tprops.setLook(wlSeparator);\n\t\tfdlSeparator = new FormData();\n\t\tfdlSeparator.left = new FormAttachment(0, 0);\n\t\tfdlSeparator.right = new FormAttachment(middle, 0);\n\t\tfdlSeparator.top = new FormAttachment(wFilename, margin);\n\t\twlSeparator.setLayoutData(fdlSeparator);\n\n\t\twSeparator = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wSeparator);\n\t\twSeparator.addModifyListener(lsMod);\n\t\tfdSeparator = new FormData();\n\t\tfdSeparator.left = new FormAttachment(middle, 0);\n\t\tfdSeparator.top = new FormAttachment(wFilename, margin);\n\t\tfdSeparator.right = new FormAttachment(100, 0);\n\t\twSeparator.setLayoutData(fdSeparator);\n\n\n\n\t\t// List of columns to set for\n\t\twlListattribut = new Label(shell, SWT.RIGHT);\n\t\twlListattribut.setText(Messages.getString(\"JobMysqlBulkLoad.Listattribut.Label\"));\n\t\tprops.setLook(wlListattribut);\n\t\tfdlListattribut = new FormData();\n\t\tfdlListattribut.left = new FormAttachment(0, 0);\n\t\tfdlListattribut.right = new FormAttachment(middle, 0);\n\t\tfdlListattribut.top = new FormAttachment(wSeparator, margin);\n\t\twlListattribut.setLayoutData(fdlListattribut);\n\n\t\twListattribut = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wListattribut);\n\t\twListattribut.setToolTipText(Messages.getString(\"JobMysqlBulkLoad.Listattribut.Tooltip\"));\n\t\twListattribut.addModifyListener(lsMod);\n\t\tfdListattribut = new FormData();\n\t\tfdListattribut.left = new FormAttachment(middle, 0);\n\t\tfdListattribut.top = new FormAttachment(wSeparator, margin);\n\t\tfdListattribut.right = new FormAttachment(100, 0);\n\t\twListattribut.setLayoutData(fdListattribut);\n\n\n\n\n\n\n\t\t//Replace data\n\t\twlReplacedata = new Label(shell, SWT.RIGHT);\n\t\twlReplacedata.setText(Messages.getString(\"JobMysqlBulkLoad.Replacedata.Label\"));\n\t\tprops.setLook(wlReplacedata);\n\t\tfdlReplacedata = new FormData();\n\t\tfdlReplacedata.left = new FormAttachment(0, 0);\n\t\tfdlReplacedata.top = new FormAttachment(wListattribut, margin);\n\t\tfdlReplacedata.right = new FormAttachment(middle, -margin);\n\t\twlReplacedata.setLayoutData(fdlReplacedata);\n\t\twReplacedata = new Button(shell, SWT.CHECK);\n\t\tprops.setLook(wReplacedata);\n\t\twReplacedata.setToolTipText(Messages.getString(\"JobMysqlBulkLoad.Replacedata.Tooltip\"));\n\t\tfdReplacedata = new FormData();\n\t\tfdReplacedata.left = new FormAttachment(middle, 0);\n\t\tfdReplacedata.top = new FormAttachment(wListattribut, margin);\n\t\tfdReplacedata.right = new FormAttachment(100, 0);\n\t\twReplacedata.setLayoutData(fdReplacedata);\n\t\twReplacedata.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\n\n\n\n\n\t\t// Nbr of lines to ignore\n\t\twlIgnorelines = new Label(shell, SWT.RIGHT);\n\t\twlIgnorelines.setText(Messages.getString(\"JobMysqlBulkLoad.Ignorelines.Label\"));\n\t\tprops.setLook(wlIgnorelines);\n\t\tfdlIgnorelines = new FormData();\n\t\tfdlIgnorelines.left = new FormAttachment(0, 0);\n\t\tfdlIgnorelines.right = new FormAttachment(middle, 0);\n\t\tfdlIgnorelines.top = new FormAttachment(wReplacedata, margin);\n\t\twlIgnorelines.setLayoutData(fdlIgnorelines);\n\n\t\twIgnorelines = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wIgnorelines);\n\t\twIgnorelines.addModifyListener(lsMod);\n\t\tfdIgnorelines = new FormData();\n\t\tfdIgnorelines.left = new FormAttachment(middle, 0);\n\t\tfdIgnorelines.top = new FormAttachment(wReplacedata, margin);\n\t\tfdIgnorelines.right = new FormAttachment(100, 0);\n\t\twIgnorelines.setLayoutData(fdIgnorelines);\n\n\n\n\n\n\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        FormData fd = new FormData();\n        fd.right = new FormAttachment(50, -10);\n        fd.bottom = new FormAttachment(100, 0);\n        fd.width = 100;\n        wOK.setLayoutData(fd);\n\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n        fd = new FormData();\n        fd.left = new FormAttachment(50, 10);\n        fd.bottom = new FormAttachment(100, 0);\n        fd.width = 100;\n        wCancel.setLayoutData(fd);\n\n        // Add listeners\n        lsCancel = new Listener()\n        {\n            public void handleEvent(Event e)\n            {\n                cancel();\n            }\n        };\n        lsOK = new Listener()\n        {\n            public void handleEvent(Event e)\n            {\n                ok();\n            }\n        };\n\n        wCancel.addListener(SWT.Selection, lsCancel);\n        wOK.addListener(SWT.Selection, lsOK);\n\n        lsDef = new SelectionAdapter()\n        {\n            public void widgetDefaultSelected(SelectionEvent e)\n            {\n                ok();\n            }\n        };\n\n        wName.addSelectionListener(lsDef);\n        wTablename.addSelectionListener(lsDef);\n\n        // Detect X or ALT-F4 or something that kills this window...\n        shell.addShellListener(new ShellAdapter()\n        {\n            public void shellClosed(ShellEvent e)\n            {\n                cancel();\n            }\n        });\n\n        getData();\n\n        BaseStepDialog.setSize(shell);\n\n        shell.open();\n        props.setDialogSize(shell, \"JobMysqlBulkLoadDialogSize\");\n        while (!shell.isDisposed())\n        {\n            if (!display.readAndDispatch())\n                display.sleep();\n        }\n        return jobEntry;\n    }","id":79188,"modified_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, props.getJobsDialogStyle());\n\t\tprops.setLook(shell);\n\t\tJobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobMysqlBulkLoad.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName = new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobMysqlBulkLoad.Name.Label\"));\n\t\tprops.setLook(wlName);\n\t\tfdlName = new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right = new FormAttachment(middle, 0);\n\t\tfdlName.top = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName = new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top = new FormAttachment(0, margin);\n\t\tfdName.right = new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Connection line\n\t\twlConnection = new Label(shell, SWT.RIGHT);\n\t\twlConnection.setText(Messages.getString(\"JobMysqlBulkLoad.Connection.Label\"));\n\t\tprops.setLook(wlConnection);\n\t\tfdlConnection = new FormData();\n\t\tfdlConnection.left = new FormAttachment(0, 0);\n\t\tfdlConnection.top = new FormAttachment(wName, margin);\n\t\tfdlConnection.right = new FormAttachment(middle, -margin);\n\t\twlConnection.setLayoutData(fdlConnection);\n\n\t\twbConnection = new Button(shell, SWT.PUSH);\n\t\twbConnection.setText(Messages.getString(\"System.Button.New\") + \"...\");\n\t\twbConnection.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tDatabaseMeta databaseMeta = new DatabaseMeta();\n\t\t\t\tDatabaseDialog cid = new DatabaseDialog(shell, databaseMeta);\n\t\t\t\tif (cid.open() != null)\n\t\t\t\t{\n\t\t\t\t\tjobMeta.addDatabase(databaseMeta);\n\n\t\t\t\t\t// SB: Maybe do the same her as in BaseStepDialog: remove\n\t\t\t\t\t// all db connections and add them again.\n\t\t\t\t\twConnection.add(databaseMeta.getName());\n\t\t\t\t\twConnection.select(wConnection.getItemCount() - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfdbConnection = new FormData();\n\t\tfdbConnection.right = new FormAttachment(100, 0);\n\t\tfdbConnection.top = new FormAttachment(wName, margin);\n\t\tfdbConnection.height = 20;\n\t\twbConnection.setLayoutData(fdbConnection);\n\n\t\twConnection = new CCombo(shell, SWT.BORDER | SWT.READ_ONLY);\n\t\tprops.setLook(wConnection);\n\t\tfor (int i = 0; i < jobMeta.nrDatabases(); i++)\n\t\t{\n\t\t\tDatabaseMeta ci = jobMeta.getDatabase(i);\n\t\t\twConnection.add(ci.getName());\n\t\t}\n\t\twConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\tfdConnection = new FormData();\n\t\tfdConnection.left = new FormAttachment(middle, 0);\n\t\tfdConnection.top = new FormAttachment(wName, margin);\n\t\tfdConnection.right = new FormAttachment(wbConnection, -margin);\n\t\twConnection.setLayoutData(fdConnection);\n\n\t\t// Table name line\n\t\twlTablename = new Label(shell, SWT.RIGHT);\n\t\twlTablename.setText(Messages.getString(\"JobMysqlBulkLoad.Tablename.Label\"));\n\t\tprops.setLook(wlTablename);\n\t\tfdlTablename = new FormData();\n\t\tfdlTablename.left = new FormAttachment(0, 0);\n\t\tfdlTablename.right = new FormAttachment(middle, 0);\n\t\tfdlTablename.top = new FormAttachment(wConnection, margin);\n\t\twlTablename.setLayoutData(fdlTablename);\n\n\t\twTablename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wTablename);\n\t\twTablename.addModifyListener(lsMod);\n\t\tfdTablename = new FormData();\n\t\tfdTablename.left = new FormAttachment(middle, 0);\n\t\tfdTablename.top = new FormAttachment(wConnection, margin);\n\t\tfdTablename.right = new FormAttachment(100, 0);\n\t\twTablename.setLayoutData(fdTablename);\n\n\n\n\n\t\t// Filename line\n\t\twlFilename = new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"JobMysqlBulkLoad.Filename.Label\"));\n\t\tprops.setLook(wlFilename);\n\t\tfdlFilename = new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdlFilename.right = new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbFilename = new Button(shell, SWT.PUSH | SWT.CENTER);\n\t\tprops.setLook(wbFilename);\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename = new FormData();\n\t\tfdbFilename.right = new FormAttachment(100, 0);\n\t\tfdbFilename.top = new FormAttachment(wTablename, 0);\n\t\t// fdbFilename.height = 22;\n\t\twbFilename.setLayoutData(fdbFilename);\n\n\t\twFilename = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename = new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.top = new FormAttachment(wTablename, margin);\n\t\tfdFilename.right = new FormAttachment(wbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twFilename.setToolTipText(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t}\n\t\t});\n\n\t\twbFilename.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\tdialog.setFilterExtensions(new String[] { \"*.txt\", \"*.csv\", \"*\" });\n\t\t\t\tif (wFilename.getText() != null)\n\t\t\t\t{\n\t\t\t\t\tdialog.setFileName(StringUtil.environmentSubstitute(wFilename.getText()));\n\t\t\t\t}\n\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\tif (dialog.open() != null)\n\t\t\t\t{\n\t\t\t\t\twFilename.setText(dialog.getFilterPath() + Const.FILE_SEPARATOR\n\t\t\t\t\t\t+ dialog.getFileName());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t//Local\n\t\twlLocalInfile = new Label(shell, SWT.RIGHT);\n\t\twlLocalInfile.setText(Messages.getString(\"JobMysqlBulkLoad.LocalInfile.Label\"));\n\t\tprops.setLook(wlLocalInfile);\n\t\tfdlLocalInfile = new FormData();\n\t\tfdlLocalInfile.left = new FormAttachment(0, 0);\n\t\tfdlLocalInfile.top = new FormAttachment(wFilename, margin);\n\t\tfdlLocalInfile.right = new FormAttachment(middle, -margin);\n\t\twlLocalInfile.setLayoutData(fdlLocalInfile);\n\t\twLocalInfile = new Button(shell, SWT.CHECK);\n\t\tprops.setLook(wLocalInfile);\n\t\twLocalInfile.setToolTipText(Messages.getString(\"JobMysqlBulkLoad.LocalInfile.Tooltip\"));\n\t\tfdLocalInfile = new FormData();\n\t\tfdLocalInfile.left = new FormAttachment(middle, 0);\n\t\tfdLocalInfile.top = new FormAttachment(wFilename, margin);\n\t\tfdLocalInfile.right = new FormAttachment(100, 0);\n\t\twLocalInfile.setLayoutData(fdLocalInfile);\n\t\twLocalInfile.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\n\n\n\t\t// Separator\n\t\twlSeparator = new Label(shell, SWT.RIGHT);\n\t\twlSeparator.setText(Messages.getString(\"JobMysqlBulkLoad.Separator.Label\"));\n\t\tprops.setLook(wlSeparator);\n\t\tfdlSeparator = new FormData();\n\t\tfdlSeparator.left = new FormAttachment(0, 0);\n\t\tfdlSeparator.right = new FormAttachment(middle, 0);\n\t\tfdlSeparator.top = new FormAttachment(wFilename, margin);\n\t\twlSeparator.setLayoutData(fdlSeparator);\n\n\t\twSeparator = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wSeparator);\n\t\twSeparator.addModifyListener(lsMod);\n\t\tfdSeparator = new FormData();\n\t\tfdSeparator.left = new FormAttachment(middle, 0);\n\t\tfdSeparator.top = new FormAttachment(wFilename, margin);\n\t\tfdSeparator.right = new FormAttachment(100, 0);\n\t\twSeparator.setLayoutData(fdSeparator);\n\n\n\n\t\t// List of columns to set for\n\t\twlListattribut = new Label(shell, SWT.RIGHT);\n\t\twlListattribut.setText(Messages.getString(\"JobMysqlBulkLoad.Listattribut.Label\"));\n\t\tprops.setLook(wlListattribut);\n\t\tfdlListattribut = new FormData();\n\t\tfdlListattribut.left = new FormAttachment(0, 0);\n\t\tfdlListattribut.right = new FormAttachment(middle, 0);\n\t\tfdlListattribut.top = new FormAttachment(wSeparator, margin);\n\t\twlListattribut.setLayoutData(fdlListattribut);\n\n\t\twListattribut = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wListattribut);\n\t\twListattribut.setToolTipText(Messages.getString(\"JobMysqlBulkLoad.Listattribut.Tooltip\"));\n\t\twListattribut.addModifyListener(lsMod);\n\t\tfdListattribut = new FormData();\n\t\tfdListattribut.left = new FormAttachment(middle, 0);\n\t\tfdListattribut.top = new FormAttachment(wSeparator, margin);\n\t\tfdListattribut.right = new FormAttachment(100, 0);\n\t\twListattribut.setLayoutData(fdListattribut);\n\n\n\n\t\t//Replace data\n\t\twlReplacedata = new Label(shell, SWT.RIGHT);\n\t\twlReplacedata.setText(Messages.getString(\"JobMysqlBulkLoad.Replacedata.Label\"));\n\t\tprops.setLook(wlReplacedata);\n\t\tfdlReplacedata = new FormData();\n\t\tfdlReplacedata.left = new FormAttachment(0, 0);\n\t\tfdlReplacedata.top = new FormAttachment(wListattribut, margin);\n\t\tfdlReplacedata.right = new FormAttachment(middle, -margin);\n\t\twlReplacedata.setLayoutData(fdlReplacedata);\n\t\twReplacedata = new Button(shell, SWT.CHECK);\n\t\tprops.setLook(wReplacedata);\n\t\twReplacedata.setToolTipText(Messages.getString(\"JobMysqlBulkLoad.Replacedata.Tooltip\"));\n\t\tfdReplacedata = new FormData();\n\t\tfdReplacedata.left = new FormAttachment(middle, 0);\n\t\tfdReplacedata.top = new FormAttachment(wListattribut, margin);\n\t\tfdReplacedata.right = new FormAttachment(100, 0);\n\t\twReplacedata.setLayoutData(fdReplacedata);\n\t\twReplacedata.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\n\n\n\n\n\t\t// Nbr of lines to ignore\n\t\twlIgnorelines = new Label(shell, SWT.RIGHT);\n\t\twlIgnorelines.setText(Messages.getString(\"JobMysqlBulkLoad.Ignorelines.Label\"));\n\t\tprops.setLook(wlIgnorelines);\n\t\tfdlIgnorelines = new FormData();\n\t\tfdlIgnorelines.left = new FormAttachment(0, 0);\n\t\tfdlIgnorelines.right = new FormAttachment(middle, 0);\n\t\tfdlIgnorelines.top = new FormAttachment(wReplacedata, margin);\n\t\twlIgnorelines.setLayoutData(fdlIgnorelines);\n\n\t\twIgnorelines = new TextVar(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wIgnorelines);\n\t\twIgnorelines.addModifyListener(lsMod);\n\t\tfdIgnorelines = new FormData();\n\t\tfdIgnorelines.left = new FormAttachment(middle, 0);\n\t\tfdIgnorelines.top = new FormAttachment(wReplacedata, margin);\n\t\tfdIgnorelines.right = new FormAttachment(100, 0);\n\t\twIgnorelines.setLayoutData(fdIgnorelines);\n\n\n\n\n\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\tFormData fd = new FormData();\n\t\tfd.right = new FormAttachment(50, -10);\n\t\tfd.bottom = new FormAttachment(100, 0);\n\t\tfd.width = 100;\n\t\twOK.setLayoutData(fd);\n\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\t\tfd = new FormData();\n\t\tfd.left = new FormAttachment(50, 10);\n\t\tfd.bottom = new FormAttachment(100, 0);\n\t\tfd.width = 100;\n\t\twCancel.setLayoutData(fd);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n\n\t\tlsDef = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twName.addSelectionListener(lsDef);\n\t\twTablename.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter()\n\t\t{\n\t\t\tpublic void shellClosed(ShellEvent e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\tprops.setDialogSize(shell, \"JobMysqlBulkLoadDialogSize\");\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Copy information from the meta-data input to the dialog fields.\n     */\n    public void getData()\n    {\n        // System.out.println(\"evaluates: \"+jobentry.evaluates());\n\n        if (jobEntry.getName() != null)\n            wName.setText(jobEntry.getName());\n        if (jobEntry.getTablename() != null)\n            wTablename.setText(jobEntry.getTablename());\n\t\tif (jobEntry.getFilename() != null)\n\t\t\twFilename.setText(jobEntry.getFilename());\n\t\tif (jobEntry.getSeparator() != null)\n\t\t\twSeparator.setText(jobEntry.getSeparator());\n\t\n\t\t\n\t\t\n\t\twReplacedata.setSelection(jobEntry.isReplacedata());\n\t\t\n\n\t\tif (jobEntry.getIgnorelines() != null)\n\t\t{\n\n\t\t\t\twIgnorelines.setText(jobEntry.getIgnorelines());\n\n\t\t}\n\t\telse\n\t\t\twIgnorelines.setText(\"0\");\n\t\t\n\t\tif (jobEntry.getListattribut() != null)\n\t\t\twListattribut.setText(jobEntry.getListattribut());\n\t\t\n\n\t\t\n\t\t\n\t\tif (jobEntry.getDatabase() != null)\n        {\n            wConnection.setText(jobEntry.getDatabase().getName());\n        }\n        wName.selectAll();\n    }","id":79189,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\t// System.out.println(\"evaluates: \"+jobentry.evaluates());\n\n\t\tif (jobEntry.getName() != null)\n\t\t\twName.setText(jobEntry.getName());\n\t\tif (jobEntry.getTablename() != null)\n\t\t\twTablename.setText(jobEntry.getTablename());\n\t\tif (jobEntry.getFilename() != null)\n\t\t\twFilename.setText(jobEntry.getFilename());\n\t\tif (jobEntry.getSeparator() != null)\n\t\t\twSeparator.setText(jobEntry.getSeparator());\n\t\n\t\t\n\t\t\n\t\twReplacedata.setSelection(jobEntry.isReplacedata());\n\t\t\n\t\twLocalInfile.setSelection(jobEntry.isLocalInfile());\n\t\t\n\n\t\tif (jobEntry.getIgnorelines() != null)\n\t\t{\n\n\t\t\twIgnorelines.setText(jobEntry.getIgnorelines());\n\n\t\t}\n\t\telse\n\t\t\twIgnorelines.setText(\"0\");\n\t\t\n\t\tif (jobEntry.getListattribut() != null)\n\t\t\twListattribut.setText(jobEntry.getListattribut());\n\t\t\n\n\t\t\n\t\t\n\t\tif (jobEntry.getDatabase() != null)\n\t\t{\n\t\t\twConnection.setText(jobEntry.getDatabase().getName());\n\t\t}\n\t\twName.selectAll();\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n    {\n        jobEntry.setName(wName.getText());\n        jobEntry.setDatabase(jobMeta.findDatabase(wConnection.getText()));\n        jobEntry.setTablename(wTablename.getText());\n\t\tjobEntry.setFilename(wFilename.getText());\n\t\tjobEntry.setSeparator(wSeparator.getText());\n\t\tjobEntry.setReplacedata(wReplacedata.getSelection());\n\t\tjobEntry.setIgnorelines(wIgnorelines.getText());\n\t\tjobEntry.setListattribut(wListattribut.getText());\n        dispose();\n    }","id":79190,"modified_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setDatabase(jobMeta.findDatabase(wConnection.getText()));\n\t\tjobEntry.setTablename(wTablename.getText());\n\t\tjobEntry.setFilename(wFilename.getText());\n\t\tjobEntry.setSeparator(wSeparator.getText());\n\t\tjobEntry.setReplacedata(wReplacedata.getSelection());\n\t\tjobEntry.setIgnorelines(wIgnorelines.getText());\n\t\tjobEntry.setListattribut(wListattribut.getText());\n\n\t\tjobEntry.setLocalInfile(wLocalInfile.getSelection());\n\n\t\tdispose();\n\t}","commit_id":"8431e711ec0838999b25ae5fcfa11d093b717de0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void updateBadFormed()\r\n\t{\r\n\t\tNrBadFormed++;\r\n\t}","id":79191,"modified_method":"private void updateBadFormed()\r\n\t{\r\n\t\tNrBadFormed++;\r\n\t\tupdateAllErrors();\r\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean checkIfSuccessConditionBroken()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tif ((NrErrors>0 && getSuccessCondition().equals(SUCCESS_IF_NO_ERRORS))\r\n\t\t\t\t|| (NrErrors>=limitFiles && getSuccessCondition().equals(SUCCESS_IF_BAD_FORMED_FILES_LESS)))\r\n\t\t{\r\n\t\t\tretval=true;\t\r\n\t\t}\r\n\t\treturn retval;\r\n\t}","id":79192,"modified_method":"private boolean checkIfSuccessConditionBroken()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tif ((NrAllErrors>0 && getSuccessCondition().equals(SUCCESS_IF_NO_ERRORS))\r\n\t\t\t\t|| (NrBadFormed>=limitFiles && getSuccessCondition().equals(SUCCESS_IF_BAD_FORMED_FILES_LESS)))\r\n\t\t{\r\n\t\t\tretval=true;\t\r\n\t\t}\r\n\t\treturn retval;\r\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean ProcessFileFolder(String sourcefilefoldername,String wildcard,Job parentJob,Result result)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tboolean entrystatus = false ;\n\t\tFileObject sourcefilefolder = null;\r\n\t\tFileObject CurrentFile = null;\n\t\t\n\t\t// Get real source file and wildcard\n\t\tString realSourceFilefoldername = environmentSubstitute(sourcefilefoldername);\r\n\t\tif(Const.isEmpty(realSourceFilefoldername))\r\n\t\t{\n\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.log.FileFolderEmpty\",sourcefilefoldername));\r\n\t\t\t// Update Errors\r\n\t\t\tupdateErrors();\r\n\t\t\t\r\n\t\t\treturn entrystatus;\r\n\t\t}\r\n\t\tString realWildcard=environmentSubstitute(wildcard);\n\n\t\ttry\n\t\t{\n\t\t\tsourcefilefolder = KettleVFS.getFileObject(realSourceFilefoldername);\n\t\t\t\n\t\t\tif (sourcefilefolder.exists())\n\t\t\t{\r\n\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(),Messages.getString(\"JobXMLWellFormed.Log.FileExists\",sourcefilefolder.toString()));\n\t\t\t\t if(sourcefilefolder.getType() == FileType.FILE)\r\n\t\t\t\t {\r\n\t\t\t\t\t entrystatus=checkOneFile(sourcefilefolder,log,result,parentJob);\r\n\t\t\t\t\t \r\n\t\t\t\t }else if(sourcefilefolder.getType() == FileType.FOLDER)\r\n\t\t\t\t {\r\n\t\t\t\t\t FileObject[] fileObjects = sourcefilefolder.findFiles(\r\n                             new AllFileSelector() \r\n                             {\t\r\n                                 public boolean traverseDescendents(FileSelectInfo info)\r\n                                 {\r\n                                     return true;\r\n                                 }\r\n                                 \r\n                                 public boolean includeFile(FileSelectInfo info)\r\n                                 {\r\n                                 \r\n                                 \tFileObject fileObject = info.getFile();\r\n                                 \ttry {\r\n                                 \t    if ( fileObject == null) return false;\r\n                                 \t    if(fileObject.getType() != FileType.FILE) return false;\r\n                                 \t}\r\n                                 \tcatch (Exception ex)\r\n                                 \t{\r\n                                 \t\t// Upon error don't process the file.\r\n                                 \t\treturn false;\r\n                                 \t}\r\n                                 \t\r\n                                 \tfinally \r\n                             \t\t{\r\n                             \t\t\tif ( fileObject != null )\r\n                             \t\t\t{\r\n                             \t\t\t\ttry  {fileObject.close();} catch ( IOException ex ) {};\r\n                             \t\t\t}\r\n        \r\n                             \t\t}\r\n                                 \treturn true;\r\n                                 }\r\n                             }\r\n                         );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t if (fileObjects != null) \r\n                     {\r\n                         for (int j = 0; j < fileObjects.length; j++)\r\n                         {\r\n                        \t if(successConditionBroken)\r\n             \t\t\t\t{\r\n             \t\t\t\t\tif(!successConditionBrokenExit)\r\n             \t\t\t\t\t{\r\n             \t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SuccessConditionbroken\",\"\"+NrErrors));\r\n             \t\t\t\t\t\tsuccessConditionBrokenExit=true;\r\n             \t\t\t\t\t}\r\n             \t\t\t\t\treturn false;\r\n             \t\t\t\t}\r\n                         \t// Fetch files in list one after one ...\r\n                             CurrentFile=fileObjects[j];\r\n                             \r\n                             if (!CurrentFile.getParent().toString().equals(sourcefilefolder.toString()))\r\n                \t\t\t {\r\n                            \t// Not in the Base Folder..Only if include sub folders  \r\n                \t\t\t\t if (include_subfolders)\r\n                \t\t\t\t {\r\n                \t\t\t\t\tif(GetFileWildcard(CurrentFile.toString(),realWildcard))\r\n                \t\t\t\t\t{\r\n                \t\t\t\t\t\tcheckOneFile(CurrentFile,log,result,parentJob);\r\n                \t\t\t\t\t}\r\n                \t\t\t\t }\r\n                            \t \r\n                \t\t\t }else\r\n                \t\t\t {\r\n                \t\t\t\t // In the base folder\r\n                \t\t\t\tif (GetFileWildcard(CurrentFile.toString(),realWildcard))\r\n          \t\t\t\t\t\t{\t\r\n                \t\t\t\t\tcheckOneFile(CurrentFile,log,result,parentJob);\r\n          \t\t\t\t\t\t}\r\n                \t\t\t }        \r\n                         }\r\n                     }\t \r\n\t\t\t\t }else\r\n\t\t\t\t {\r\n\t\t\t\t\t log.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.UnknowFileFormat\",sourcefilefolder.toString()));\t\t\t\t\t\r\n\t\t\t\t\t // Update Errors\r\n\t\t\t\t\t updateErrors(); \r\n\t\t\t\t }\n\t\t\t} \n\t\t\telse\n\t\t\t{\t\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SourceFileNotExists\",realSourceFilefoldername));\t\t\t\t\t\r\n\t\t\t\t// Update Errors\r\n\t\t\t\tupdateErrors();\n\t\t\t}\n\t\t} // end try\n\t\n\t\tcatch (IOException e) \n\t\t{\n\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.Exception.Processing\",realSourceFilefoldername.toString(),e.getMessage()));\t\t\t\t\t\n\t\t\t// Update Errors\r\n\t\t\tupdateErrors();\r\n\t\t}\n\t\tfinally \n\t\t{\n\t\t\tif ( sourcefilefolder != null )\n\t\t\t{\n\t\t\t\ttry{\n\t\t\t\t\tsourcefilefolder.close();\n\t\t\t\t}catch ( IOException ex ) {};\n\r\n\t\t\t}\r\n\t\t\tif ( CurrentFile != null )\r\n\t\t\t{\r\n\t\t\t\ttry {\r\n\t\t\t\t\tCurrentFile.close();\r\n\t\t\t\t}catch ( IOException ex ) {};\r\n\t\t\t}\n\t\t}\n\t\treturn entrystatus;\n\t}","id":79193,"modified_method":"private boolean ProcessFileFolder(String sourcefilefoldername,String wildcard,Job parentJob,Result result)\r\n\t{\r\n\t\tLogWriter log = LogWriter.getInstance();\r\n\t\tboolean entrystatus = false ;\r\n\t\tFileObject sourcefilefolder = null;\r\n\t\tFileObject CurrentFile = null;\r\n\t\t\r\n\t\t// Get real source file and wilcard\r\n\t\tString realSourceFilefoldername = environmentSubstitute(sourcefilefoldername);\r\n\t\tif(Const.isEmpty(realSourceFilefoldername))\r\n\t\t{\r\n\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.log.FileFolderEmpty\",sourcefilefoldername));\r\n\t\t\t// Update Errors\r\n\t\t\tupdateErrors();\r\n\t\t\t\r\n\t\t\treturn entrystatus;\r\n\t\t}\r\n\t\tString realWildcard=environmentSubstitute(wildcard);\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tsourcefilefolder = KettleVFS.getFileObject(realSourceFilefoldername);\r\n\t\t\t\r\n\t\t\tif (sourcefilefolder.exists())\r\n\t\t\t{\r\n\t\t\t\t if(log.isDetailed()) log.logDetailed(toString(),Messages.getString(\"JobXMLWellFormed.Log.FileExists\",sourcefilefolder.toString()));\r\n\t\t\t\t if(sourcefilefolder.getType() == FileType.FILE)\r\n\t\t\t\t {\r\n\t\t\t\t\t entrystatus=checkOneFile(sourcefilefolder,log,result,parentJob);\r\n\t\t\t\t\t \r\n\t\t\t\t }else if(sourcefilefolder.getType() == FileType.FOLDER)\r\n\t\t\t\t {\r\n\t\t\t\t\t FileObject[] fileObjects = sourcefilefolder.findFiles(\r\n                             new AllFileSelector() \r\n                             {\t\r\n                                 public boolean traverseDescendents(FileSelectInfo info)\r\n                                 {\r\n                                     return true;\r\n                                 }\r\n                                 \r\n                                 public boolean includeFile(FileSelectInfo info)\r\n                                 {\r\n                                 \r\n                                 \tFileObject fileObject = info.getFile();\r\n                                 \ttry {\r\n                                 \t    if ( fileObject == null) return false;\r\n                                 \t    if(fileObject.getType() != FileType.FILE) return false;\r\n                                 \t}\r\n                                 \tcatch (Exception ex)\r\n                                 \t{\r\n                                 \t\t// Upon error don't process the file.\r\n                                 \t\treturn false;\r\n                                 \t}\r\n                                 \t\r\n                                 \tfinally \r\n                             \t\t{\r\n                             \t\t\tif ( fileObject != null )\r\n                             \t\t\t{\r\n                             \t\t\t\ttry  {fileObject.close();} catch ( IOException ex ) {};\r\n                             \t\t\t}\r\n        \r\n                             \t\t}\r\n                                 \treturn true;\r\n                                 }\r\n                             }\r\n                         );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t if (fileObjects != null) \r\n                     {\r\n                         for (int j = 0; j < fileObjects.length && !parentJob.isStopped(); j++)\r\n                         {\r\n                        \t if(successConditionBroken)\r\n             \t\t\t\t{\r\n             \t\t\t\t\tif(!successConditionBrokenExit)\r\n             \t\t\t\t\t{\r\n             \t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SuccessConditionbroken\",\"\"+NrAllErrors));\r\n             \t\t\t\t\t\tsuccessConditionBrokenExit=true;\r\n             \t\t\t\t\t}\r\n             \t\t\t\t\treturn false;\r\n             \t\t\t\t}\r\n                         \t// Fetch files in list one after one ...\r\n                             CurrentFile=fileObjects[j];\r\n                             \r\n                             if (!CurrentFile.getParent().toString().equals(sourcefilefolder.toString()))\r\n                \t\t\t {\r\n                            \t// Not in the Base Folder..Only if include sub folders  \r\n                \t\t\t\t if (include_subfolders)\r\n                \t\t\t\t {\r\n                \t\t\t\t\tif(GetFileWildcard(CurrentFile.toString(),realWildcard))\r\n                \t\t\t\t\t{\r\n                \t\t\t\t\t\tcheckOneFile(CurrentFile,log,result,parentJob);\r\n                \t\t\t\t\t}\r\n                \t\t\t\t }\r\n                            \t \r\n                \t\t\t }else\r\n                \t\t\t {\r\n                \t\t\t\t // In the base folder\r\n                \t\t\t\tif (GetFileWildcard(CurrentFile.toString(),realWildcard))\r\n          \t\t\t\t\t\t{\t\r\n                \t\t\t\t\tcheckOneFile(CurrentFile,log,result,parentJob);\r\n          \t\t\t\t\t\t}\r\n                \t\t\t }        \r\n                         }\r\n                     }\t \r\n\t\t\t\t }else\r\n\t\t\t\t {\r\n\t\t\t\t\t log.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.UnknowFileFormat\",sourcefilefolder.toString()));\t\t\t\t\t\r\n\t\t\t\t\t // Update Errors\r\n\t\t\t\t\t updateErrors(); \r\n\t\t\t\t }\r\n\t\t\t} \r\n\t\t\telse\r\n\t\t\t{\t\r\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SourceFileNotExists\",realSourceFilefoldername));\t\t\t\t\t\r\n\t\t\t\t// Update Errors\r\n\t\t\t\tupdateErrors();\r\n\t\t\t}\r\n\t\t} // end try\r\n\t\r\n\t\tcatch (IOException e) \r\n\t\t{\r\n\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.Exception.Processing\",realSourceFilefoldername.toString(),e.getMessage()));\t\t\t\t\t\r\n\t\t\t// Update Errors\r\n\t\t\tupdateErrors();\r\n\t\t}\r\n\t\tfinally \r\n\t\t{\r\n\t\t\tif ( sourcefilefolder != null )\r\n\t\t\t{\r\n\t\t\t\ttry{\r\n\t\t\t\t\tsourcefilefolder.close();\r\n\t\t\t\t}catch ( IOException ex ) {};\r\n\r\n\t\t\t}\r\n\t\t\tif ( CurrentFile != null )\r\n\t\t\t{\r\n\t\t\t\ttry {\r\n\t\t\t\t\tCurrentFile.close();\r\n\t\t\t\t}catch ( IOException ex ) {};\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn entrystatus;\r\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean getSuccessStatus()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\t\r\n\t\tif ((NrErrors==0 && getSuccessCondition().equals(SUCCESS_IF_NO_ERRORS))\r\n\t\t\t\t|| (NrWellFormed>=limitFiles && getSuccessCondition().equals(SUCCESS_IF_AT_LEAST_X_FILES_WELL_FORMED))\r\n\t\t\t\t|| (NrBadFormed<=limitFiles && getSuccessCondition().equals(SUCCESS_IF_BAD_FORMED_FILES_LESS)))\r\n\t\t\t{\r\n\t\t\t\tretval=true;\t\r\n\t\t\t}\r\n\t\t\r\n\t\treturn retval;\r\n\t}","id":79194,"modified_method":"private boolean getSuccessStatus()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\t\r\n\t\tif ((NrAllErrors==0 && getSuccessCondition().equals(SUCCESS_IF_NO_ERRORS))\r\n\t\t\t\t|| (NrWellFormed>=limitFiles && getSuccessCondition().equals(SUCCESS_IF_AT_LEAST_X_FILES_WELL_FORMED))\r\n\t\t\t\t|| (NrBadFormed<limitFiles && getSuccessCondition().equals(SUCCESS_IF_BAD_FORMED_FILES_LESS)))\r\n\t\t\t{\r\n\t\t\t\tretval=true;\t\r\n\t\t\t}\r\n\t\t\r\n\t\treturn retval;\r\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void updateErrors()\r\n\t{\r\n\t\tNrErrors++;\r\n\t\tif(checkIfSuccessConditionBroken())\r\n\t\t{\r\n\t\t\t// Success condition was broken\r\n\t\t\tsuccessConditionBroken=true;\r\n\t\t}\r\n\t}","id":79195,"modified_method":"private void updateErrors()\r\n\t{\r\n\t\tNrErrors++;\r\n\t\tupdateAllErrors();\r\n\t\tif(checkIfSuccessConditionBroken())\r\n\t\t{\r\n\t\t\t// Success condition was broken\r\n\t\t\tsuccessConditionBroken=true;\r\n\t\t}\r\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void addFileToResultFilenames(String fileaddentry,LogWriter log,Result result,Job parentJob)\r\n\t{\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(fileaddentry), parentJob.getJobname(), toString());\r\n\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n\t    \r\n\t\t\tif(log.isDetailed())\r\n\t\t\t{\r\n\t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobXMLWellFormed.Log.FileAddedToResultFilesName\",fileaddentry));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}catch (Exception e)\r\n\t\t{\r\n\t\t\tlog.logError(toString(),Messages.getString(\"JobXMLWellFormed.Error.AddingToFilenameResult\",fileaddentry,e.getMessage()));\r\n\t\t}\r\n\r\n}","id":79196,"modified_method":"private void addFileToResultFilenames(String fileaddentry,LogWriter log,Result result,Job parentJob)\r\n\t{\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(fileaddentry), parentJob.getName(), toString());\r\n\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n\t    \r\n\t\t\tif(log.isDetailed())\r\n\t\t\t{\r\n\t\t\t\tlog.logDetailed(toString(),Messages.getString(\"JobXMLWellFormed.Log.FileAddedToResultFilesName\",fileaddentry));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}catch (Exception e)\r\n\t\t{\r\n\t\t\tlog.logError(toString(),Messages.getString(\"JobXMLWellFormed.Error.AddingToFilenameResult\",fileaddentry,e.getMessage()));\r\n\t\t}\r\n\r\n}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob) throws KettleException \n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tResult result = previousResult;\r\n\t\tresult.setNrErrors(1);\r\n\t\tresult.setResult(false);\n\n\t    List<RowMetaAndData> rows = result.getRows();\n\t    RowMetaAndData resultRow = null;\n\t\t\n\t    NrErrors=0;\r\n\t    NrWellFormed=0;\r\n\t    NrBadFormed=0;\r\n\t    limitFiles=Const.toInt(environmentSubstitute(getNrErrorsLessThan()),10);\r\n\t\tsuccessConditionBroken=false;\r\n\t\tsuccessConditionBrokenExit=false;\r\n\n\t\t// Get source and destination files, also wildcard\n\t\tString vsourcefilefolder[] = source_filefolder;\n\t\tString vwildcard[] = wildcard;\n\t\t\r\n\t\t\t\n\t\tif (arg_from_previous)\n\t\t{\n\t\t\tif (log.isDetailed())\r\n\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobXMLWellFormed.Log.ArgFromPrevious.Found\",(rows!=null?rows.size():0)+ \"\"));\n\t\t\t\n\t\t}\n\t\tif (arg_from_previous && rows!=null) // Copy the input row to the (command line) arguments\n\t\t{\n\t\t\tfor (int iteration=0;iteration<rows.size();iteration++) \n\t\t\t{\r\n\t\t\t\tif(successConditionBroken)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!successConditionBrokenExit)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SuccessConditionbroken\",\"\"+NrErrors));\r\n\t\t\t\t\t\tsuccessConditionBrokenExit=true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.setEntryNr(NrErrors);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\n\t\t\t\tresultRow = rows.get(iteration);\n\t\t\t\n\t\t\t\t// Get source and destination file names, also wildcard\n\t\t\t\tString vsourcefilefolder_previous = resultRow.getString(0,null);\n\t\t\t\tString vwildcard_previous = resultRow.getString(1,null);\n\t\t\t\t\r\n\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobXMLWellFormed.Log.ProcessingRow\",vsourcefilefolder_previous,vwildcard_previous));\r\n\r\n\t\t\t\tProcessFileFolder(vsourcefilefolder_previous, vwildcard_previous,parentJob,result);\n\t\t\t}\n\t\t}\n\t\telse if (vsourcefilefolder!=null)\n\t\t{\n\t\t\tfor (int i=0;i<vsourcefilefolder.length;i++)\n\t\t\t{\r\n\t\t\t\tif(successConditionBroken)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!successConditionBrokenExit)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SuccessConditionbroken\",\"\"+NrErrors));\r\n\t\t\t\t\t\tsuccessConditionBrokenExit=true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.setEntryNr(NrErrors);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobXMLWellFormed.Log.ProcessingRow\",vsourcefilefolder[i],vwildcard[i]));\n\t\t\t\t\t\r\n\t\t\t\tProcessFileFolder(vsourcefilefolder[i], vwildcard[i],parentJob,result);\n\t\t\t\t\n\t\t\t}\n\t\t}\t\r\n\t\t\n\t\t// Success Condition\r\n\t\tresult.setNrErrors(NrErrors);\r\n\t\tresult.setNrLinesWritten(NrWellFormed);\r\n\t\tif(getSuccessStatus())\tresult.setResult(true);\r\n\t\t\r\n\t\tdisplayResults(log);\n\t\t\n\t\treturn result;\n\t}","id":79197,"modified_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob) throws KettleException \r\n\t{\r\n\t\tLogWriter log = LogWriter.getInstance();\r\n\t\tResult result = previousResult;\r\n\t\tresult.setNrErrors(1);\r\n\t\tresult.setResult(false);\r\n\r\n\t    List<RowMetaAndData> rows = result.getRows();\r\n\t    RowMetaAndData resultRow = null;\r\n\t\t\r\n\t    NrErrors=0;\r\n\t    NrWellFormed=0;\r\n\t    NrBadFormed=0;\r\n\t    limitFiles=Const.toInt(environmentSubstitute(getNrErrorsLessThan()),10);\r\n\t\tsuccessConditionBroken=false;\r\n\t\tsuccessConditionBrokenExit=false;\r\n\r\n\t\t// Get source and destination files, also wildcard\r\n\t\tString vsourcefilefolder[] = source_filefolder;\r\n\t\tString vwildcard[] = wildcard;\r\n\t\t\r\n\t\t\t\r\n\t\tif (arg_from_previous)\r\n\t\t{\r\n\t\t\tif (log.isDetailed())\r\n\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobXMLWellFormed.Log.ArgFromPrevious.Found\",(rows!=null?rows.size():0)+ \"\"));\r\n\t\t\t\r\n\t\t}\r\n\t\tif (arg_from_previous && rows!=null) // Copy the input row to the (command line) arguments\r\n\t\t{\r\n\t\t\tfor (int iteration=0;iteration<rows.size() && !parentJob.isStopped();iteration++) \r\n\t\t\t{\r\n\t\t\t\tif(successConditionBroken)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!successConditionBrokenExit)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SuccessConditionbroken\",\"\"+NrAllErrors));\r\n\t\t\t\t\t\tsuccessConditionBrokenExit=true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.setEntryNr(NrAllErrors);\r\n\t\t\t\t\tresult.setNrLinesRejected(NrBadFormed);\r\n\t\t\t\t\tresult.setNrLinesWritten(NrWellFormed);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresultRow = rows.get(iteration);\r\n\t\t\t\r\n\t\t\t\t// Get source and destination file names, also wildcard\r\n\t\t\t\tString vsourcefilefolder_previous = resultRow.getString(0,null);\r\n\t\t\t\tString vwildcard_previous = resultRow.getString(1,null);\r\n\t\t\t\t\r\n\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobXMLWellFormed.Log.ProcessingRow\",vsourcefilefolder_previous,vwildcard_previous));\r\n\r\n\t\t\t\tProcessFileFolder(vsourcefilefolder_previous, vwildcard_previous,parentJob,result);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (vsourcefilefolder!=null)\r\n\t\t{\r\n\t\t\tfor (int i=0;i<vsourcefilefolder.length && !parentJob.isStopped();i++)\r\n\t\t\t{\r\n\t\t\t\tif(successConditionBroken)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!successConditionBrokenExit)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobXMLWellFormed.Error.SuccessConditionbroken\",\"\"+NrAllErrors));\r\n\t\t\t\t\t\tsuccessConditionBrokenExit=true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.setEntryNr(NrAllErrors);\r\n\t\t\t\t\tresult.setNrLinesRejected(NrBadFormed);\r\n\t\t\t\t\tresult.setNrLinesWritten(NrWellFormed);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\tlog.logDetailed(toString(), Messages.getString(\"JobXMLWellFormed.Log.ProcessingRow\",vsourcefilefolder[i],vwildcard[i]));\r\n\t\t\t\t\t\r\n\t\t\t\tProcessFileFolder(vsourcefilefolder[i], vwildcard[i],parentJob,result);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\t\r\n\t\t\r\n\t\t// Success Condition\r\n\t\tresult.setNrErrors(NrAllErrors);\r\n\t\tresult.setNrLinesRejected(NrBadFormed);\r\n\t\tresult.setNrLinesWritten(NrWellFormed);\r\n\t\tif(getSuccessStatus())\r\n\t\t{\r\n\t\t\tresult.setNrErrors(0);\r\n\t\t\tresult.setResult(true);\r\n\t\t}\r\n\t\t\r\n\t\tdisplayResults(log);\r\n\t\t\r\n\t\treturn result;\r\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, props.getJobsDialogStyle());\n\t\tprops.setLook(shell);\n\t\tJobDialog.setShellImage(shell, jobEntry);\n\t\t\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobXMLWellFormed.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobXMLWellFormed.Name.Label\"));\n\t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\t\t\n\t\t\n\t\t\n\t\t  \n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\n \t\t\n \t\t//////////////////////////\n\t\t// START OF GENERAL TAB   ///\n\t\t//////////////////////////\n\t\t\n\t\t\n\t\t\n\t\twGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twGeneralTab.setText(Messages.getString(\"JobXMLWellFormed.Tab.General.Label\"));\n\t\t\n\t\twGeneralComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wGeneralComp);\n\n\t\tFormLayout generalLayout = new FormLayout();\n\t\tgeneralLayout.marginWidth  = 3;\n\t\tgeneralLayout.marginHeight = 3;\n\t\twGeneralComp.setLayout(generalLayout);\n\t\t\n\n\t\t// SETTINGS grouping?\n\t\t// ////////////////////////\n\t\t// START OF SETTINGS GROUP\n\t\t// \n\n\t\twSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\n\t\tprops.setLook(wSettings);\n\t\twSettings.setText(Messages.getString(\"JobXMLWellFormed.Settings.Label\"));\n\n\t\tFormLayout groupLayout = new FormLayout();\n\t\tgroupLayout.marginWidth = 10;\n\t\tgroupLayout.marginHeight = 10;\n\t\twSettings.setLayout(groupLayout);\n\t\t\n\t\twlIncludeSubfolders = new Label(wSettings, SWT.RIGHT);\n\t\twlIncludeSubfolders.setText(Messages.getString(\"JobXMLWellFormed.IncludeSubfolders.Label\"));\n\t\tprops.setLook(wlIncludeSubfolders);\n\t\tfdlIncludeSubfolders = new FormData();\n\t\tfdlIncludeSubfolders.left = new FormAttachment(0, 0);\n\t\tfdlIncludeSubfolders.top = new FormAttachment(wName, margin);\n\t\tfdlIncludeSubfolders.right = new FormAttachment(middle, -margin);\n\t\twlIncludeSubfolders.setLayoutData(fdlIncludeSubfolders);\n\t\twIncludeSubfolders = new Button(wSettings, SWT.CHECK);\n\t\tprops.setLook(wIncludeSubfolders);\n\t\twIncludeSubfolders.setToolTipText(Messages.getString(\"JobXMLWellFormed.IncludeSubfolders.Tooltip\"));\n\t\tfdIncludeSubfolders = new FormData();\n\t\tfdIncludeSubfolders.left = new FormAttachment(middle, 0);\n\t\tfdIncludeSubfolders.top = new FormAttachment(wName, margin);\n\t\tfdIncludeSubfolders.right = new FormAttachment(100, 0);\n\t\twIncludeSubfolders.setLayoutData(fdIncludeSubfolders);\n\t\twIncludeSubfolders.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\t\t\n\r\n\t\n\t\t// previous\n\t\twlPrevious = new Label(wSettings, SWT.RIGHT);\n\t\twlPrevious.setText(Messages.getString(\"JobXMLWellFormed.Previous.Label\"));\n\t\tprops.setLook(wlPrevious);\n\t\tfdlPrevious = new FormData();\n\t\tfdlPrevious.left = new FormAttachment(0, 0);\n\t\tfdlPrevious.top = new FormAttachment(wIncludeSubfolders, margin );\n\t\tfdlPrevious.right = new FormAttachment(middle, -margin);\n\t\twlPrevious.setLayoutData(fdlPrevious);\n\t\twPrevious = new Button(wSettings, SWT.CHECK);\n\t\tprops.setLook(wPrevious);\n\t\twPrevious.setSelection(jobEntry.arg_from_previous);\n\t\twPrevious.setToolTipText(Messages.getString(\"JobXMLWellFormed.Previous.Tooltip\"));\n\t\tfdPrevious = new FormData();\n\t\tfdPrevious.left = new FormAttachment(middle, 0);\n\t\tfdPrevious.top = new FormAttachment(wIncludeSubfolders, margin );\n\t\tfdPrevious.right = new FormAttachment(100, 0);\n\t\twPrevious.setLayoutData(fdPrevious);\n\t\twPrevious.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\n\t\t\t\tRefreshArgFromPrevious();\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t\tfdSettings = new FormData();\n\t\tfdSettings.left = new FormAttachment(0, margin);\n\t\tfdSettings.top = new FormAttachment(wName, margin);\n\t\tfdSettings.right = new FormAttachment(100, -margin);\n\t\twSettings.setLayoutData(fdSettings);\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t// / END OF SETTINGS GROUP\n\t\t// ///////////////////////////////////////////////////////////\n\n\t\t// SourceFileFolder line\n\t\twlSourceFileFolder=new Label(wGeneralComp, SWT.RIGHT);\n\t\twlSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.SourceFileFolder.Label\"));\n\t\tprops.setLook(wlSourceFileFolder);\n\t\tfdlSourceFileFolder=new FormData();\n\t\tfdlSourceFileFolder.left = new FormAttachment(0, 0);\n\t\tfdlSourceFileFolder.top  = new FormAttachment(wSettings, 2*margin);\n\t\tfdlSourceFileFolder.right= new FormAttachment(middle, -margin);\n\t\twlSourceFileFolder.setLayoutData(fdlSourceFileFolder);\n\n\t\t// Browse Source folders button ...\n\t\twbSourceDirectory=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbSourceDirectory);\n\t\twbSourceDirectory.setText(Messages.getString(\"JobXMLWellFormed.BrowseFolders.Label\"));\n\t\tfdbSourceDirectory=new FormData();\n\t\tfdbSourceDirectory.right= new FormAttachment(100, 0);\n\t\tfdbSourceDirectory.top  = new FormAttachment(wSettings, margin);\n\t\twbSourceDirectory.setLayoutData(fdbSourceDirectory);\n\t\t\n\t\twbSourceDirectory.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tDirectoryDialog ddialog = new DirectoryDialog(shell, SWT.OPEN);\n\t\t\t\t\tif (wSourceFileFolder.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tddialog.setFilterPath(jobMeta.environmentSubstitute(wSourceFileFolder.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t // Calling open() will open and run the dialog.\n\t\t\t        // It will return the selected directory, or\n\t\t\t        // null if user cancels\n\t\t\t        String dir = ddialog.open();\n\t\t\t        if (dir != null) {\n\t\t\t          // Set the text box to the new selection\n\t\t\t        \twSourceFileFolder.setText(dir);\n\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Browse Source files button ...\n\t\twbSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbSourceFileFolder);\n\t\twbSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.BrowseFiles.Label\"));\n\t\tfdbSourceFileFolder=new FormData();\n\t\tfdbSourceFileFolder.right= new FormAttachment(wbSourceDirectory, -margin);\n\t\tfdbSourceFileFolder.top  = new FormAttachment(wSettings, margin);\n\t\twbSourceFileFolder.setLayoutData(fdbSourceFileFolder);\n\t\t\n\t\t// Browse Destination file add button ...\n\t\twbaSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbaSourceFileFolder);\n\t\twbaSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.FilenameAdd.Button\"));\n\t\tfdbaSourceFileFolder=new FormData();\n\t\tfdbaSourceFileFolder.right= new FormAttachment(wbSourceFileFolder, -margin);\n\t\tfdbaSourceFileFolder.top  = new FormAttachment(wSettings, margin);\n\t\twbaSourceFileFolder.setLayoutData(fdbaSourceFileFolder);\n\n\t\twSourceFileFolder=new TextVar(jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSourceFileFolder.setToolTipText(Messages.getString(\"JobXMLWellFormed.SourceFileFolder.Tooltip\"));\n\t\t\n\t\tprops.setLook(wSourceFileFolder);\n\t\twSourceFileFolder.addModifyListener(lsMod);\n\t\tfdSourceFileFolder=new FormData();\n\t\tfdSourceFileFolder.left = new FormAttachment(middle, 0);\n\t\tfdSourceFileFolder.top  = new FormAttachment(wSettings, 2*margin);\n\t\tfdSourceFileFolder.right= new FormAttachment(wbSourceFileFolder, -55);\n\t\twSourceFileFolder.setLayoutData(fdSourceFileFolder);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twSourceFileFolder.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twSourceFileFolder.setToolTipText(jobMeta.environmentSubstitute(wSourceFileFolder.getText() ) );\n\t\t\t}\n\t\t}\n\t\t\t);\n\n\t\twbSourceFileFolder.addSelectionListener\n\t\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xml;*.XML\", \"*\"});\n\t\t\t\tif (wSourceFileFolder.getText()!=null)\n\t\t\t\t{\n\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wSourceFileFolder.getText()) );\n\t\t\t\t}\n\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t{\n\t\t\t\t\twSourceFileFolder.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t);\n\t\t\n\n\t\t\n\t\t\n\n\t\t// Buttons to the right of the screen...\n\t\twbdSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbdSourceFileFolder);\n\t\twbdSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.FilenameDelete.Button\"));\n\t\twbdSourceFileFolder.setToolTipText(Messages.getString(\"JobXMLWellFormed.FilenameDelete.Tooltip\"));\n\t\tfdbdSourceFileFolder=new FormData();\n\t\tfdbdSourceFileFolder.right = new FormAttachment(100, 0);\n\t\tfdbdSourceFileFolder.top  = new FormAttachment (wSourceFileFolder, 40);\n\t\twbdSourceFileFolder.setLayoutData(fdbdSourceFileFolder);\n\n\t\twbeSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbeSourceFileFolder);\n\t\twbeSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.FilenameEdit.Button\"));\n\t\twbeSourceFileFolder.setToolTipText(Messages.getString(\"JobXMLWellFormed.FilenameEdit.Tooltip\"));\n\t\tfdbeSourceFileFolder=new FormData();\n\t\tfdbeSourceFileFolder.right = new FormAttachment(100, 0);\n\t\tfdbeSourceFileFolder.left = new FormAttachment(wbdSourceFileFolder, 0, SWT.LEFT);\n\t\tfdbeSourceFileFolder.top  = new FormAttachment (wbdSourceFileFolder, margin);\n\t\twbeSourceFileFolder.setLayoutData(fdbeSourceFileFolder);\n\t\t\n\t\t\n\t\t\n\t\t// Wildcard\n\t\twlWildcard = new Label(wGeneralComp, SWT.RIGHT);\n\t\twlWildcard.setText(Messages.getString(\"JobXMLWellFormed.Wildcard.Label\"));\n\t\tprops.setLook(wlWildcard);\n\t\tfdlWildcard = new FormData();\n\t\tfdlWildcard.left = new FormAttachment(0, 0);\n\t\tfdlWildcard.top = new FormAttachment(wSourceFileFolder, margin);\n\t\tfdlWildcard.right = new FormAttachment(middle, -margin);\n\t\twlWildcard.setLayoutData(fdlWildcard);\n\t\t\n\t\twWildcard = new TextVar(jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twWildcard.setToolTipText(Messages.getString(\"JobXMLWellFormed.Wildcard.Tooltip\"));\n\t\tprops.setLook(wWildcard);\n\t\twWildcard.addModifyListener(lsMod);\n\t\tfdWildcard = new FormData();\n\t\tfdWildcard.left = new FormAttachment(middle, 0);\n\t\tfdWildcard.top = new FormAttachment(wSourceFileFolder, margin);\n\t\tfdWildcard.right= new FormAttachment(wbSourceFileFolder, -55);\n\t\twWildcard.setLayoutData(fdWildcard);\n\n\t\twlFields = new Label(wGeneralComp, SWT.NONE);\n\t\twlFields.setText(Messages.getString(\"JobXMLWellFormed.Fields.Label\"));\n\t\tprops.setLook(wlFields);\n\t\tfdlFields = new FormData();\n\t\tfdlFields.left = new FormAttachment(0, 0);\n\t\tfdlFields.right= new FormAttachment(middle, -margin);\n\t\tfdlFields.top = new FormAttachment(wWildcard,margin);\n\t\twlFields.setLayoutData(fdlFields);\n\n\t\tint rows = jobEntry.source_filefolder == null\n\t\t\t? 1\n\t\t\t: (jobEntry.source_filefolder.length == 0\n\t\t\t? 0\n\t\t\t: jobEntry.source_filefolder.length);\n\t\tfinal int FieldsRows = rows;\n\n\t\tColumnInfo[] colinf=new ColumnInfo[]\n\t\t\t{\n\t\t\t\tnew ColumnInfo(Messages.getString(\"JobXMLWellFormed.Fields.SourceFileFolder.Label\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false),\n\t\t\t\tnew ColumnInfo(Messages.getString(\"JobXMLWellFormed.Fields.Wildcard.Label\"), ColumnInfo.COLUMN_TYPE_TEXT,    false ),\n\t\t\t};\n\n\t\tcolinf[0].setUsingVariables(true);\n\t\tcolinf[0].setToolTip(Messages.getString(\"JobXMLWellFormed.Fields.SourceFileFolder.Tooltip\"));\n\t\tcolinf[1].setUsingVariables(true);\n\t\tcolinf[1].setToolTip(Messages.getString(\"JobXMLWellFormed.Fields.Wildcard.Tooltip\"));\n\n\t\twFields = new TableView(jobMeta, wGeneralComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf,\tFieldsRows, lsMod, props);\n\n\t\tfdFields = new FormData();\n\t\tfdFields.left = new FormAttachment(0, 0);\n\t\tfdFields.top = new FormAttachment(wlFields, margin);\n\t\tfdFields.right = new FormAttachment(100, -75);\n\t\tfdFields.bottom = new FormAttachment(100, -margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\tRefreshArgFromPrevious();\n\n\t\t// Add the file to the list of files...\n\t\tSelectionAdapter selA = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\twFields.add(new String[] { wSourceFileFolder.getText(), wWildcard.getText() } );\n\t\t\t\twSourceFileFolder.setText(\"\");\n\n\t\t\t\twWildcard.setText(\"\");\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t\twFields.optWidth(true);\n\t\t\t}\n\t\t};\n\t\twbaSourceFileFolder.addSelectionListener(selA);\n\t\twSourceFileFolder.addSelectionListener(selA);\n\n\t\t// Delete files from the list of files...\n\t\twbdSourceFileFolder.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx[] = wFields.getSelectionIndices();\n\t\t\t\twFields.remove(idx);\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Edit the selected file & remove from the list...\n\t\twbeSourceFileFolder.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx = wFields.getSelectionIndex();\n\t\t\t\tif (idx>=0)\n\t\t\t\t{\n\t\t\t\t\tString string[] = wFields.getItem(idx);\n\t\t\t\t\twSourceFileFolder.setText(string[0]);\n\t\t\t\t\twWildcard.setText(string[2]);\n\t\t\t\t\twFields.remove(idx);\n\t\t\t\t}\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\t\n\n\t\tfdGeneralComp=new FormData();\n\t\tfdGeneralComp.left  = new FormAttachment(0, 0);\n\t\tfdGeneralComp.top   = new FormAttachment(0, 0);\n\t\tfdGeneralComp.right = new FormAttachment(100, 0);\n\t\tfdGeneralComp.bottom= new FormAttachment(100, 0);\n\t\twGeneralComp.setLayoutData(fdGeneralComp);\n\t\t\n\t\twGeneralComp.layout();\n\t\twGeneralTab.setControl(wGeneralComp);\n \t\tprops.setLook(wGeneralComp);\n \t\t\n \t\t\n \t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF GENERAL TAB\n\t\t/////////////////////////////////////////////////////////////\n\t\t\r\n\n \t\t//////////////////////////////////////\n\t\t// START OF ADVANCED  TAB   ///\n\t\t/////////////////////////////////////\n\t\t\n\t\t\n\t\t\n\t\twAdvancedTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twAdvancedTab.setText(Messages.getString(\"JobXMLWellFormed.Tab.Advanced.Label\"));\n\n\t\tFormLayout contentLayout = new FormLayout ();\n\t\tcontentLayout.marginWidth  = 3;\n\t\tcontentLayout.marginHeight = 3;\n\t\t\n\t\twAdvancedComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wAdvancedComp);\n \t\twAdvancedComp.setLayout(contentLayout);\r\n \t\t\r\n \t\t\r\n \t   \r\n \t\t\r\n\t\t // SuccessOngrouping?\r\n\t     // ////////////////////////\r\n\t     // START OF SUCCESS ON GROUP///\r\n\t     // /\r\n\t    wSuccessOn= new Group(wAdvancedComp, SWT.SHADOW_NONE);\r\n\t    props.setLook(wSuccessOn);\r\n\t    wSuccessOn.setText(Messages.getString(\"JobXMLWellFormed.SuccessOn.Group.Label\"));\r\n\r\n\t    FormLayout successongroupLayout = new FormLayout();\r\n\t    successongroupLayout.marginWidth = 10;\r\n\t    successongroupLayout.marginHeight = 10;\r\n\r\n\t    wSuccessOn.setLayout(successongroupLayout);\r\n\t    \r\n\r\n\t    //Success Condition\r\n\t  \twlSuccessCondition = new Label(wSuccessOn, SWT.RIGHT);\r\n\t  \twlSuccessCondition.setText(Messages.getString(\"JobXMLWellFormed.SuccessCondition.Label\"));\r\n\t  \tprops.setLook(wlSuccessCondition);\r\n\t  \tfdlSuccessCondition = new FormData();\r\n\t  \tfdlSuccessCondition.left = new FormAttachment(0, 0);\r\n\t  \tfdlSuccessCondition.right = new FormAttachment(middle, 0);\r\n\t  \tfdlSuccessCondition.top = new FormAttachment(0, margin);\r\n\t  \twlSuccessCondition.setLayoutData(fdlSuccessCondition);\r\n\t  \twSuccessCondition = new CCombo(wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\r\n\t  \twSuccessCondition.add(Messages.getString(\"JobXMLWellFormed.SuccessWhenAllWorksFine.Label\"));\r\n\t  \twSuccessCondition.add(Messages.getString(\"JobXMLWellFormed.SuccessWhenAtLeat.Label\"));\r\n\t  \twSuccessCondition.add(Messages.getString(\"JobXMLWellFormed.SuccessWhenBadFormedLessThan.Label\"));\r\n\t  \twSuccessCondition.select(0); // +1: starts at -1\r\n\t  \t\r\n\t\tprops.setLook(wSuccessCondition);\r\n\t\tfdSuccessCondition= new FormData();\r\n\t\tfdSuccessCondition.left = new FormAttachment(middle, 0);\r\n\t\tfdSuccessCondition.top = new FormAttachment(0, margin);\r\n\t\tfdSuccessCondition.right = new FormAttachment(100, 0);\r\n\t\twSuccessCondition.setLayoutData(fdSuccessCondition);\r\n\t\twSuccessCondition.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tactiveSuccessCondition();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Success when number of errors less than\r\n\t\twlNrErrorsLessThan= new Label(wSuccessOn, SWT.RIGHT);\r\n\t\twlNrErrorsLessThan.setText(Messages.getString(\"JobXMLWellFormed.NrBadFormedLessThan.Label\"));\r\n\t\tprops.setLook(wlNrErrorsLessThan);\r\n\t\tfdlNrErrorsLessThan= new FormData();\r\n\t\tfdlNrErrorsLessThan.left = new FormAttachment(0, 0);\r\n\t\tfdlNrErrorsLessThan.top = new FormAttachment(wSuccessCondition, margin);\r\n\t\tfdlNrErrorsLessThan.right = new FormAttachment(middle, -margin);\r\n\t\twlNrErrorsLessThan.setLayoutData(fdlNrErrorsLessThan);\r\n\t\t\r\n\t\t\r\n\t\twNrErrorsLessThan= new TextVar(jobMeta,wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, Messages\r\n\t\t\t.getString(\"JobXMLWellFormed.NrBadFormedLessThan.Tooltip\"));\r\n\t\tprops.setLook(wNrErrorsLessThan);\r\n\t\twNrErrorsLessThan.addModifyListener(lsMod);\r\n\t\tfdNrErrorsLessThan= new FormData();\r\n\t\tfdNrErrorsLessThan.left = new FormAttachment(middle, 0);\r\n\t\tfdNrErrorsLessThan.top = new FormAttachment(wSuccessCondition, margin);\r\n\t\tfdNrErrorsLessThan.right = new FormAttachment(100, -margin);\r\n\t\twNrErrorsLessThan.setLayoutData(fdNrErrorsLessThan);\r\n\t\t\r\n\t\r\n\t    fdSuccessOn= new FormData();\r\n\t    fdSuccessOn.left = new FormAttachment(0, margin);\r\n\t    fdSuccessOn.top = new FormAttachment(0, margin);\r\n\t    fdSuccessOn.right = new FormAttachment(100, -margin);\r\n\t    wSuccessOn.setLayoutData(fdSuccessOn);\r\n\t     // ///////////////////////////////////////////////////////////\r\n\t     // / END OF Success ON GROUP\r\n\t     // ///////////////////////////////////////////////////////////\r\n\r\n \t\t\r\n \t\t\n \t\t\n \t\t\n\t\t // fileresult grouping?\n\t     // ////////////////////////\n\t     // START OF LOGGING GROUP///\n\t     // /\n\t    wFileResult = new Group(wAdvancedComp, SWT.SHADOW_NONE);\n\t    props.setLook(wFileResult);\n\t    wFileResult.setText(Messages.getString(\"JobXMLWellFormed.FileResult.Group.Label\"));\n\n\t    FormLayout fileresultgroupLayout = new FormLayout();\n\t    fileresultgroupLayout.marginWidth = 10;\n\t    fileresultgroupLayout.marginHeight = 10;\n\n\t    wFileResult.setLayout(fileresultgroupLayout);\n\t      \n\t      \n\t    //Add Filenames to result filenames?\r\n\t  \twlAddFilenameToResult = new Label(wFileResult, SWT.RIGHT);\r\n\t  \twlAddFilenameToResult.setText(Messages.getString(\"JobXMLWellFormed.AddFilenameToResult.Label\"));\r\n\t  \tprops.setLook(wlAddFilenameToResult);\r\n\t  \tfdlAddFilenameToResult = new FormData();\r\n\t  \tfdlAddFilenameToResult.left = new FormAttachment(0, 0);\r\n\t  \tfdlAddFilenameToResult.right = new FormAttachment(middle, 0);\r\n\t  \tfdlAddFilenameToResult.top = new FormAttachment(0, margin);\r\n\t  \twlAddFilenameToResult.setLayoutData(fdlAddFilenameToResult);\r\n\t  \twAddFilenameToResult = new CCombo(wFileResult, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\r\n\t  \twAddFilenameToResult.add(Messages.getString(\"JobXMLWellFormed.AddAllFilenamesToResult.Label\"));\r\n\t  \twAddFilenameToResult.add(Messages.getString(\"JobXMLWellFormed.AddOnlyWellFormedFilenames.Label\"));\r\n\t  \twAddFilenameToResult.add(Messages.getString(\"JobXMLWellFormed.AddOnlyBadFormedFilenames.Label\"));\r\n\t  \twAddFilenameToResult.select(0); // +1: starts at -1\r\n\t  \t\r\n\t\tprops.setLook(wAddFilenameToResult);\r\n\t\tfdAddFilenameToResult= new FormData();\r\n\t\tfdAddFilenameToResult.left = new FormAttachment(middle, 0);\r\n\t\tfdAddFilenameToResult.top = new FormAttachment(0, margin);\r\n\t\tfdAddFilenameToResult.right = new FormAttachment(100, 0);\r\n\t\twAddFilenameToResult.setLayoutData(fdAddFilenameToResult);\r\n\t\twAddFilenameToResult.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\n\t      \n\t     fdFileResult = new FormData();\n\t     fdFileResult.left = new FormAttachment(0, margin);\n\t     fdFileResult.top = new FormAttachment(wSuccessOn, margin);\n\t     fdFileResult.right = new FormAttachment(100, -margin);\n\t     wFileResult.setLayoutData(fdFileResult);\n\t     // ///////////////////////////////////////////////////////////\n\t     // / END OF FilesResult GROUP\n\t     // ///////////////////////////////////////////////////////////\n\n\t\t\n \t\t\n \t\t\n \t\t\n\t    fdAdvancedComp = new FormData();\n\t\tfdAdvancedComp.left  = new FormAttachment(0, 0);\n \t\tfdAdvancedComp.top   = new FormAttachment(0, 0);\n \t\tfdAdvancedComp.right = new FormAttachment(100, 0);\n \t\tfdAdvancedComp.bottom= new FormAttachment(100, 0);\n \t\twAdvancedComp.setLayoutData(wAdvancedComp);\n\n \t\twAdvancedComp.layout();\n\t\twAdvancedTab.setControl(wAdvancedComp);\n\n\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF ADVANCED TAB\n\t\t/////////////////////////////////////////////////////////////\n \t\t\n \t\t\n \t\t\n\t\tfdTabFolder = new FormData();\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\n\t\tfdTabFolder.top   = new FormAttachment(wName, margin);\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\n\t\twTabFolder.setLayoutData(fdTabFolder);\n\t\t\n\t\t\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wTabFolder);\n\t\t\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twSourceFileFolder.addSelectionListener( lsDef );\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\r\n\t\tactiveSuccessCondition();\r\n\r\n\t\tactiveSuccessCondition();\r\n\n\t\twTabFolder.setSelection(0);\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","id":79198,"modified_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, props.getJobsDialogStyle());\n\t\tprops.setLook(shell);\n\t\tJobDialog.setShellImage(shell, jobEntry);\n\t\t\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobXMLWellFormed.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobXMLWellFormed.Name.Label\"));\n\t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\t\t\n\t\t\n\t\t\n\t\t  \n        wTabFolder = new CTabFolder(shell, SWT.BORDER);\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\n \t\t\n \t\t//////////////////////////\n\t\t// START OF GENERAL TAB   ///\n\t\t//////////////////////////\n\t\t\n\t\t\n\t\t\n\t\twGeneralTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twGeneralTab.setText(Messages.getString(\"JobXMLWellFormed.Tab.General.Label\"));\n\t\t\n\t\twGeneralComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wGeneralComp);\n\n\t\tFormLayout generalLayout = new FormLayout();\n\t\tgeneralLayout.marginWidth  = 3;\n\t\tgeneralLayout.marginHeight = 3;\n\t\twGeneralComp.setLayout(generalLayout);\n\t\t\n\n\t\t// SETTINGS grouping?\n\t\t// ////////////////////////\n\t\t// START OF SETTINGS GROUP\n\t\t// \n\n\t\twSettings = new Group(wGeneralComp, SWT.SHADOW_NONE);\n\t\tprops.setLook(wSettings);\n\t\twSettings.setText(Messages.getString(\"JobXMLWellFormed.Settings.Label\"));\n\n\t\tFormLayout groupLayout = new FormLayout();\n\t\tgroupLayout.marginWidth = 10;\n\t\tgroupLayout.marginHeight = 10;\n\t\twSettings.setLayout(groupLayout);\n\t\t\n\t\twlIncludeSubfolders = new Label(wSettings, SWT.RIGHT);\n\t\twlIncludeSubfolders.setText(Messages.getString(\"JobXMLWellFormed.IncludeSubfolders.Label\"));\n\t\tprops.setLook(wlIncludeSubfolders);\n\t\tfdlIncludeSubfolders = new FormData();\n\t\tfdlIncludeSubfolders.left = new FormAttachment(0, 0);\n\t\tfdlIncludeSubfolders.top = new FormAttachment(wName, margin);\n\t\tfdlIncludeSubfolders.right = new FormAttachment(middle, -margin);\n\t\twlIncludeSubfolders.setLayoutData(fdlIncludeSubfolders);\n\t\twIncludeSubfolders = new Button(wSettings, SWT.CHECK);\n\t\tprops.setLook(wIncludeSubfolders);\n\t\twIncludeSubfolders.setToolTipText(Messages.getString(\"JobXMLWellFormed.IncludeSubfolders.Tooltip\"));\n\t\tfdIncludeSubfolders = new FormData();\n\t\tfdIncludeSubfolders.left = new FormAttachment(middle, 0);\n\t\tfdIncludeSubfolders.top = new FormAttachment(wName, margin);\n\t\tfdIncludeSubfolders.right = new FormAttachment(100, 0);\n\t\twIncludeSubfolders.setLayoutData(fdIncludeSubfolders);\n\t\twIncludeSubfolders.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t});\n\t\t\n\r\n\t\n\t\t// previous\n\t\twlPrevious = new Label(wSettings, SWT.RIGHT);\n\t\twlPrevious.setText(Messages.getString(\"JobXMLWellFormed.Previous.Label\"));\n\t\tprops.setLook(wlPrevious);\n\t\tfdlPrevious = new FormData();\n\t\tfdlPrevious.left = new FormAttachment(0, 0);\n\t\tfdlPrevious.top = new FormAttachment(wIncludeSubfolders, margin );\n\t\tfdlPrevious.right = new FormAttachment(middle, -margin);\n\t\twlPrevious.setLayoutData(fdlPrevious);\n\t\twPrevious = new Button(wSettings, SWT.CHECK);\n\t\tprops.setLook(wPrevious);\n\t\twPrevious.setSelection(jobEntry.arg_from_previous);\n\t\twPrevious.setToolTipText(Messages.getString(\"JobXMLWellFormed.Previous.Tooltip\"));\n\t\tfdPrevious = new FormData();\n\t\tfdPrevious.left = new FormAttachment(middle, 0);\n\t\tfdPrevious.top = new FormAttachment(wIncludeSubfolders, margin );\n\t\tfdPrevious.right = new FormAttachment(100, 0);\n\t\twPrevious.setLayoutData(fdPrevious);\n\t\twPrevious.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\n\t\t\t\tRefreshArgFromPrevious();\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t\tfdSettings = new FormData();\n\t\tfdSettings.left = new FormAttachment(0, margin);\n\t\tfdSettings.top = new FormAttachment(wName, margin);\n\t\tfdSettings.right = new FormAttachment(100, -margin);\n\t\twSettings.setLayoutData(fdSettings);\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t// / END OF SETTINGS GROUP\n\t\t// ///////////////////////////////////////////////////////////\n\n\t\t// SourceFileFolder line\n\t\twlSourceFileFolder=new Label(wGeneralComp, SWT.RIGHT);\n\t\twlSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.SourceFileFolder.Label\"));\n\t\tprops.setLook(wlSourceFileFolder);\n\t\tfdlSourceFileFolder=new FormData();\n\t\tfdlSourceFileFolder.left = new FormAttachment(0, 0);\n\t\tfdlSourceFileFolder.top  = new FormAttachment(wSettings, 2*margin);\n\t\tfdlSourceFileFolder.right= new FormAttachment(middle, -margin);\n\t\twlSourceFileFolder.setLayoutData(fdlSourceFileFolder);\n\n\t\t// Browse Source folders button ...\n\t\twbSourceDirectory=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbSourceDirectory);\n\t\twbSourceDirectory.setText(Messages.getString(\"JobXMLWellFormed.BrowseFolders.Label\"));\n\t\tfdbSourceDirectory=new FormData();\n\t\tfdbSourceDirectory.right= new FormAttachment(100, 0);\n\t\tfdbSourceDirectory.top  = new FormAttachment(wSettings, margin);\n\t\twbSourceDirectory.setLayoutData(fdbSourceDirectory);\n\t\t\n\t\twbSourceDirectory.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tDirectoryDialog ddialog = new DirectoryDialog(shell, SWT.OPEN);\n\t\t\t\t\tif (wSourceFileFolder.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tddialog.setFilterPath(jobMeta.environmentSubstitute(wSourceFileFolder.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t // Calling open() will open and run the dialog.\n\t\t\t        // It will return the selected directory, or\n\t\t\t        // null if user cancels\n\t\t\t        String dir = ddialog.open();\n\t\t\t        if (dir != null) {\n\t\t\t          // Set the text box to the new selection\n\t\t\t        \twSourceFileFolder.setText(dir);\n\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t\n\t\t// Browse Source files button ...\n\t\twbSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbSourceFileFolder);\n\t\twbSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.BrowseFiles.Label\"));\n\t\tfdbSourceFileFolder=new FormData();\n\t\tfdbSourceFileFolder.right= new FormAttachment(wbSourceDirectory, -margin);\n\t\tfdbSourceFileFolder.top  = new FormAttachment(wSettings, margin);\n\t\twbSourceFileFolder.setLayoutData(fdbSourceFileFolder);\n\t\t\n\t\t// Browse Destination file add button ...\n\t\twbaSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbaSourceFileFolder);\n\t\twbaSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.FilenameAdd.Button\"));\n\t\tfdbaSourceFileFolder=new FormData();\n\t\tfdbaSourceFileFolder.right= new FormAttachment(wbSourceFileFolder, -margin);\n\t\tfdbaSourceFileFolder.top  = new FormAttachment(wSettings, margin);\n\t\twbaSourceFileFolder.setLayoutData(fdbaSourceFileFolder);\n\n\t\twSourceFileFolder=new TextVar(jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSourceFileFolder.setToolTipText(Messages.getString(\"JobXMLWellFormed.SourceFileFolder.Tooltip\"));\n\t\t\n\t\tprops.setLook(wSourceFileFolder);\n\t\twSourceFileFolder.addModifyListener(lsMod);\n\t\tfdSourceFileFolder=new FormData();\n\t\tfdSourceFileFolder.left = new FormAttachment(middle, 0);\n\t\tfdSourceFileFolder.top  = new FormAttachment(wSettings, 2*margin);\n\t\tfdSourceFileFolder.right= new FormAttachment(wbSourceFileFolder, -55);\n\t\twSourceFileFolder.setLayoutData(fdSourceFileFolder);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twSourceFileFolder.addModifyListener(new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\twSourceFileFolder.setToolTipText(jobMeta.environmentSubstitute(wSourceFileFolder.getText() ) );\n\t\t\t}\n\t\t}\n\t\t\t);\n\n\t\twbSourceFileFolder.addSelectionListener\n\t\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.xml;*.XML\", \"*\"});\n\t\t\t\tif (wSourceFileFolder.getText()!=null)\n\t\t\t\t{\n\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wSourceFileFolder.getText()) );\n\t\t\t\t}\n\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t{\n\t\t\t\t\twSourceFileFolder.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t);\n\t\t\n\n\t\t\n\t\t\n\n\t\t// Buttons to the right of the screen...\n\t\twbdSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbdSourceFileFolder);\n\t\twbdSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.FilenameDelete.Button\"));\n\t\twbdSourceFileFolder.setToolTipText(Messages.getString(\"JobXMLWellFormed.FilenameDelete.Tooltip\"));\n\t\tfdbdSourceFileFolder=new FormData();\n\t\tfdbdSourceFileFolder.right = new FormAttachment(100, 0);\n\t\tfdbdSourceFileFolder.top  = new FormAttachment (wSourceFileFolder, 40);\n\t\twbdSourceFileFolder.setLayoutData(fdbdSourceFileFolder);\n\n\t\twbeSourceFileFolder=new Button(wGeneralComp, SWT.PUSH| SWT.CENTER);\n\t\tprops.setLook(wbeSourceFileFolder);\n\t\twbeSourceFileFolder.setText(Messages.getString(\"JobXMLWellFormed.FilenameEdit.Button\"));\n\t\twbeSourceFileFolder.setToolTipText(Messages.getString(\"JobXMLWellFormed.FilenameEdit.Tooltip\"));\n\t\tfdbeSourceFileFolder=new FormData();\n\t\tfdbeSourceFileFolder.right = new FormAttachment(100, 0);\n\t\tfdbeSourceFileFolder.left = new FormAttachment(wbdSourceFileFolder, 0, SWT.LEFT);\n\t\tfdbeSourceFileFolder.top  = new FormAttachment (wbdSourceFileFolder, margin);\n\t\twbeSourceFileFolder.setLayoutData(fdbeSourceFileFolder);\n\t\t\n\t\t\n\t\t\n\t\t// Wildcard\n\t\twlWildcard = new Label(wGeneralComp, SWT.RIGHT);\n\t\twlWildcard.setText(Messages.getString(\"JobXMLWellFormed.Wildcard.Label\"));\n\t\tprops.setLook(wlWildcard);\n\t\tfdlWildcard = new FormData();\n\t\tfdlWildcard.left = new FormAttachment(0, 0);\n\t\tfdlWildcard.top = new FormAttachment(wSourceFileFolder, margin);\n\t\tfdlWildcard.right = new FormAttachment(middle, -margin);\n\t\twlWildcard.setLayoutData(fdlWildcard);\n\t\t\n\t\twWildcard = new TextVar(jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twWildcard.setToolTipText(Messages.getString(\"JobXMLWellFormed.Wildcard.Tooltip\"));\n\t\tprops.setLook(wWildcard);\n\t\twWildcard.addModifyListener(lsMod);\n\t\tfdWildcard = new FormData();\n\t\tfdWildcard.left = new FormAttachment(middle, 0);\n\t\tfdWildcard.top = new FormAttachment(wSourceFileFolder, margin);\n\t\tfdWildcard.right= new FormAttachment(wbSourceFileFolder, -55);\n\t\twWildcard.setLayoutData(fdWildcard);\n\n\t\twlFields = new Label(wGeneralComp, SWT.NONE);\n\t\twlFields.setText(Messages.getString(\"JobXMLWellFormed.Fields.Label\"));\n\t\tprops.setLook(wlFields);\n\t\tfdlFields = new FormData();\n\t\tfdlFields.left = new FormAttachment(0, 0);\n\t\tfdlFields.right= new FormAttachment(middle, -margin);\n\t\tfdlFields.top = new FormAttachment(wWildcard,margin);\n\t\twlFields.setLayoutData(fdlFields);\n\n\t\tint rows = jobEntry.source_filefolder == null\n\t\t\t? 1\n\t\t\t: (jobEntry.source_filefolder.length == 0\n\t\t\t? 0\n\t\t\t: jobEntry.source_filefolder.length);\n\t\tfinal int FieldsRows = rows;\n\n\t\tColumnInfo[] colinf=new ColumnInfo[]\n\t\t\t{\n\t\t\t\tnew ColumnInfo(Messages.getString(\"JobXMLWellFormed.Fields.SourceFileFolder.Label\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false),\n\t\t\t\tnew ColumnInfo(Messages.getString(\"JobXMLWellFormed.Fields.Wildcard.Label\"), ColumnInfo.COLUMN_TYPE_TEXT,    false ),\n\t\t\t};\n\n\t\tcolinf[0].setUsingVariables(true);\n\t\tcolinf[0].setToolTip(Messages.getString(\"JobXMLWellFormed.Fields.SourceFileFolder.Tooltip\"));\n\t\tcolinf[1].setUsingVariables(true);\n\t\tcolinf[1].setToolTip(Messages.getString(\"JobXMLWellFormed.Fields.Wildcard.Tooltip\"));\n\n\t\twFields = new TableView(jobMeta, wGeneralComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf,\tFieldsRows, lsMod, props);\n\n\t\tfdFields = new FormData();\n\t\tfdFields.left = new FormAttachment(0, 0);\n\t\tfdFields.top = new FormAttachment(wlFields, margin);\n\t\tfdFields.right = new FormAttachment(100, -75);\n\t\tfdFields.bottom = new FormAttachment(100, -margin);\n\t\twFields.setLayoutData(fdFields);\n\n\t\tRefreshArgFromPrevious();\n\n\t\t// Add the file to the list of files...\n\t\tSelectionAdapter selA = new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\twFields.add(new String[] { wSourceFileFolder.getText(), wWildcard.getText() } );\n\t\t\t\twSourceFileFolder.setText(\"\");\n\n\t\t\t\twWildcard.setText(\"\");\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t\twFields.optWidth(true);\n\t\t\t}\n\t\t};\n\t\twbaSourceFileFolder.addSelectionListener(selA);\n\t\twSourceFileFolder.addSelectionListener(selA);\n\n\t\t// Delete files from the list of files...\n\t\twbdSourceFileFolder.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx[] = wFields.getSelectionIndices();\n\t\t\t\twFields.remove(idx);\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t}\n\t\t});\n\n\t\t// Edit the selected file & remove from the list...\n\t\twbeSourceFileFolder.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent arg0)\n\t\t\t{\n\t\t\t\tint idx = wFields.getSelectionIndex();\n\t\t\t\tif (idx>=0)\n\t\t\t\t{\n\t\t\t\t\tString string[] = wFields.getItem(idx);\n\t\t\t\t\twSourceFileFolder.setText(string[0]);\n\t\t\t\t\twWildcard.setText(string[1]);\n\t\t\t\t\twFields.remove(idx);\n\t\t\t\t}\n\t\t\t\twFields.removeEmptyRows();\n\t\t\t\twFields.setRowNums();\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\t\n\n\t\tfdGeneralComp=new FormData();\n\t\tfdGeneralComp.left  = new FormAttachment(0, 0);\n\t\tfdGeneralComp.top   = new FormAttachment(0, 0);\n\t\tfdGeneralComp.right = new FormAttachment(100, 0);\n\t\tfdGeneralComp.bottom= new FormAttachment(100, 0);\n\t\twGeneralComp.setLayoutData(fdGeneralComp);\n\t\t\n\t\twGeneralComp.layout();\n\t\twGeneralTab.setControl(wGeneralComp);\n \t\tprops.setLook(wGeneralComp);\n \t\t\n \t\t\n \t\t\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF GENERAL TAB\n\t\t/////////////////////////////////////////////////////////////\n\t\t\r\n\n \t\t//////////////////////////////////////\n\t\t// START OF ADVANCED  TAB   ///\n\t\t/////////////////////////////////////\n\t\t\n\t\t\n\t\t\n\t\twAdvancedTab=new CTabItem(wTabFolder, SWT.NONE);\n\t\twAdvancedTab.setText(Messages.getString(\"JobXMLWellFormed.Tab.Advanced.Label\"));\n\n\t\tFormLayout contentLayout = new FormLayout ();\n\t\tcontentLayout.marginWidth  = 3;\n\t\tcontentLayout.marginHeight = 3;\n\t\t\n\t\twAdvancedComp = new Composite(wTabFolder, SWT.NONE);\n \t\tprops.setLook(wAdvancedComp);\n \t\twAdvancedComp.setLayout(contentLayout);\r\n \t\t\r\n \t\t\r\n \t   \r\n \t\t\r\n\t\t // SuccessOngrouping?\r\n\t     // ////////////////////////\r\n\t     // START OF SUCCESS ON GROUP///\r\n\t     // /\r\n\t    wSuccessOn= new Group(wAdvancedComp, SWT.SHADOW_NONE);\r\n\t    props.setLook(wSuccessOn);\r\n\t    wSuccessOn.setText(Messages.getString(\"JobXMLWellFormed.SuccessOn.Group.Label\"));\r\n\r\n\t    FormLayout successongroupLayout = new FormLayout();\r\n\t    successongroupLayout.marginWidth = 10;\r\n\t    successongroupLayout.marginHeight = 10;\r\n\r\n\t    wSuccessOn.setLayout(successongroupLayout);\r\n\t    \r\n\r\n\t    //Success Condition\r\n\t  \twlSuccessCondition = new Label(wSuccessOn, SWT.RIGHT);\r\n\t  \twlSuccessCondition.setText(Messages.getString(\"JobXMLWellFormed.SuccessCondition.Label\"));\r\n\t  \tprops.setLook(wlSuccessCondition);\r\n\t  \tfdlSuccessCondition = new FormData();\r\n\t  \tfdlSuccessCondition.left = new FormAttachment(0, 0);\r\n\t  \tfdlSuccessCondition.right = new FormAttachment(middle, 0);\r\n\t  \tfdlSuccessCondition.top = new FormAttachment(0, margin);\r\n\t  \twlSuccessCondition.setLayoutData(fdlSuccessCondition);\r\n\t  \twSuccessCondition = new CCombo(wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\r\n\t  \twSuccessCondition.add(Messages.getString(\"JobXMLWellFormed.SuccessWhenAllWorksFine.Label\"));\r\n\t  \twSuccessCondition.add(Messages.getString(\"JobXMLWellFormed.SuccessWhenAtLeat.Label\"));\r\n\t  \twSuccessCondition.add(Messages.getString(\"JobXMLWellFormed.SuccessWhenBadFormedLessThan.Label\"));\r\n\t  \twSuccessCondition.select(0); // +1: starts at -1\r\n\t  \t\r\n\t\tprops.setLook(wSuccessCondition);\r\n\t\tfdSuccessCondition= new FormData();\r\n\t\tfdSuccessCondition.left = new FormAttachment(middle, 0);\r\n\t\tfdSuccessCondition.top = new FormAttachment(0, margin);\r\n\t\tfdSuccessCondition.right = new FormAttachment(100, 0);\r\n\t\twSuccessCondition.setLayoutData(fdSuccessCondition);\r\n\t\twSuccessCondition.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\tactiveSuccessCondition();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Success when number of errors less than\r\n\t\twlNrErrorsLessThan= new Label(wSuccessOn, SWT.RIGHT);\r\n\t\twlNrErrorsLessThan.setText(Messages.getString(\"JobXMLWellFormed.NrBadFormedLessThan.Label\"));\r\n\t\tprops.setLook(wlNrErrorsLessThan);\r\n\t\tfdlNrErrorsLessThan= new FormData();\r\n\t\tfdlNrErrorsLessThan.left = new FormAttachment(0, 0);\r\n\t\tfdlNrErrorsLessThan.top = new FormAttachment(wSuccessCondition, margin);\r\n\t\tfdlNrErrorsLessThan.right = new FormAttachment(middle, -margin);\r\n\t\twlNrErrorsLessThan.setLayoutData(fdlNrErrorsLessThan);\r\n\t\t\r\n\t\t\r\n\t\twNrErrorsLessThan= new TextVar(jobMeta,wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, Messages\r\n\t\t\t.getString(\"JobXMLWellFormed.NrBadFormedLessThan.Tooltip\"));\r\n\t\tprops.setLook(wNrErrorsLessThan);\r\n\t\twNrErrorsLessThan.addModifyListener(lsMod);\r\n\t\tfdNrErrorsLessThan= new FormData();\r\n\t\tfdNrErrorsLessThan.left = new FormAttachment(middle, 0);\r\n\t\tfdNrErrorsLessThan.top = new FormAttachment(wSuccessCondition, margin);\r\n\t\tfdNrErrorsLessThan.right = new FormAttachment(100, -margin);\r\n\t\twNrErrorsLessThan.setLayoutData(fdNrErrorsLessThan);\r\n\t\t\r\n\t\r\n\t    fdSuccessOn= new FormData();\r\n\t    fdSuccessOn.left = new FormAttachment(0, margin);\r\n\t    fdSuccessOn.top = new FormAttachment(0, margin);\r\n\t    fdSuccessOn.right = new FormAttachment(100, -margin);\r\n\t    wSuccessOn.setLayoutData(fdSuccessOn);\r\n\t     // ///////////////////////////////////////////////////////////\r\n\t     // / END OF Success ON GROUP\r\n\t     // ///////////////////////////////////////////////////////////\r\n\r\n \t\t\r\n \t\t\n \t\t\n \t\t\n\t\t // fileresult grouping?\n\t     // ////////////////////////\n\t     // START OF LOGGING GROUP///\n\t     // /\n\t    wFileResult = new Group(wAdvancedComp, SWT.SHADOW_NONE);\n\t    props.setLook(wFileResult);\n\t    wFileResult.setText(Messages.getString(\"JobXMLWellFormed.FileResult.Group.Label\"));\n\n\t    FormLayout fileresultgroupLayout = new FormLayout();\n\t    fileresultgroupLayout.marginWidth = 10;\n\t    fileresultgroupLayout.marginHeight = 10;\n\n\t    wFileResult.setLayout(fileresultgroupLayout);\n\t      \n\t      \n\t    //Add Filenames to result filenames?\r\n\t  \twlAddFilenameToResult = new Label(wFileResult, SWT.RIGHT);\r\n\t  \twlAddFilenameToResult.setText(Messages.getString(\"JobXMLWellFormed.AddFilenameToResult.Label\"));\r\n\t  \tprops.setLook(wlAddFilenameToResult);\r\n\t  \tfdlAddFilenameToResult = new FormData();\r\n\t  \tfdlAddFilenameToResult.left = new FormAttachment(0, 0);\r\n\t  \tfdlAddFilenameToResult.right = new FormAttachment(middle, 0);\r\n\t  \tfdlAddFilenameToResult.top = new FormAttachment(0, margin);\r\n\t  \twlAddFilenameToResult.setLayoutData(fdlAddFilenameToResult);\r\n\t  \twAddFilenameToResult = new CCombo(wFileResult, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER);\r\n\t  \twAddFilenameToResult.add(Messages.getString(\"JobXMLWellFormed.AddAllFilenamesToResult.Label\"));\r\n\t  \twAddFilenameToResult.add(Messages.getString(\"JobXMLWellFormed.AddOnlyWellFormedFilenames.Label\"));\r\n\t  \twAddFilenameToResult.add(Messages.getString(\"JobXMLWellFormed.AddOnlyBadFormedFilenames.Label\"));\r\n\t  \twAddFilenameToResult.select(0); // +1: starts at -1\r\n\t  \t\r\n\t\tprops.setLook(wAddFilenameToResult);\r\n\t\tfdAddFilenameToResult= new FormData();\r\n\t\tfdAddFilenameToResult.left = new FormAttachment(middle, 0);\r\n\t\tfdAddFilenameToResult.top = new FormAttachment(0, margin);\r\n\t\tfdAddFilenameToResult.right = new FormAttachment(100, 0);\r\n\t\twAddFilenameToResult.setLayoutData(fdAddFilenameToResult);\r\n\t\twAddFilenameToResult.addSelectionListener(new SelectionAdapter()\r\n\t\t{\r\n\t\t\tpublic void widgetSelected(SelectionEvent e)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\n\t      \n\t     fdFileResult = new FormData();\n\t     fdFileResult.left = new FormAttachment(0, margin);\n\t     fdFileResult.top = new FormAttachment(wSuccessOn, margin);\n\t     fdFileResult.right = new FormAttachment(100, -margin);\n\t     wFileResult.setLayoutData(fdFileResult);\n\t     // ///////////////////////////////////////////////////////////\n\t     // / END OF FilesResult GROUP\n\t     // ///////////////////////////////////////////////////////////\n\n\t\t\n \t\t\n \t\t\n \t\t\n\t    fdAdvancedComp = new FormData();\n\t\tfdAdvancedComp.left  = new FormAttachment(0, 0);\n \t\tfdAdvancedComp.top   = new FormAttachment(0, 0);\n \t\tfdAdvancedComp.right = new FormAttachment(100, 0);\n \t\tfdAdvancedComp.bottom= new FormAttachment(100, 0);\n \t\twAdvancedComp.setLayoutData(wAdvancedComp);\n\n \t\twAdvancedComp.layout();\n\t\twAdvancedTab.setControl(wAdvancedComp);\n\n\n\t\t/////////////////////////////////////////////////////////////\n\t\t/// END OF ADVANCED TAB\n\t\t/////////////////////////////////////////////////////////////\n \t\t\n \t\t\n \t\t\n\t\tfdTabFolder = new FormData();\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\n\t\tfdTabFolder.top   = new FormAttachment(wName, margin);\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\n\t\twTabFolder.setLayoutData(fdTabFolder);\n\t\t\n\t\t\n\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wTabFolder);\n\t\t\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twSourceFileFolder.addSelectionListener( lsDef );\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\r\n\t\tactiveSuccessCondition();\r\n\r\n\t\tactiveSuccessCondition();\r\n\n\t\twTabFolder.setSelection(0);\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","commit_id":"f83ab9825a89e1364c20684d093f29b017690e90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Pinger( HostnamePort address, UdcInformationCollector collector )\n    {\n        this.address = address;\n        this.collector = collector;\n        if ( collector.getCrashPing() )\n        {\n            pingCount = -1;\n        }\n    }","id":79199,"modified_method":"public Pinger( String address, UdcInformationCollector collector )\n    {\n        this.address = address;\n        this.collector = collector;\n        if ( collector.getCrashPing() )\n        {\n            pingCount = -1;\n        }\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPingServer()\n    {\n        final HostnamePort hostURL = new HostnamePort( hostname, server.getServicePort() );\n        final Map<String, String> udcFields = new HashMap<String, String>();\n        udcFields.put( ID, EXPECTED_STORE_ID );\n        udcFields.put( UdcConstants.VERSION, EXPECTED_KERNEL_VERSION );\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ) );\n        Exception thrownException = null;\n        try\n        {\n            p.ping();\n        }\n        catch ( IOException e )\n        {\n            thrownException = e;\n            e.printStackTrace();\n        }\n        assertThat( thrownException, nullValue() );\n\n        Map<String, String> actualQueryMap = handler.getQueryMap();\n        assertThat( actualQueryMap, notNullValue() );\n        assertThat( actualQueryMap.get( ID ), is( EXPECTED_STORE_ID ) );\n\n    }","id":79200,"modified_method":"@Test\n    public void shouldPingServer()\n    {\n        final String hostURL = hostname+\":\"+ server.getServicePort();\n        final Map<String, String> udcFields = new HashMap<String, String>();\n        udcFields.put( ID, EXPECTED_STORE_ID );\n        udcFields.put( UdcConstants.VERSION, EXPECTED_KERNEL_VERSION );\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ) );\n        Exception thrownException = null;\n        try\n        {\n            p.ping();\n        }\n        catch ( IOException e )\n        {\n            thrownException = e;\n            e.printStackTrace();\n        }\n        assertThat( thrownException, nullValue() );\n\n        Map<String, String> actualQueryMap = handler.getQueryMap();\n        assertThat( actualQueryMap, notNullValue() );\n        assertThat( actualQueryMap.get( ID ), is( EXPECTED_STORE_ID ) );\n\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void crashPingSequenceShouldBeMinusOneThenTwoThenThreeEtc() throws Exception\n    {\n        int[] expectedSequence = {-1, 2, 3, 4};\n        final HostnamePort hostURL = new HostnamePort( hostname, server.getServicePort() );\n        final Map<String, String> udcFields = new HashMap<String, String>();\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ).withCrash() );\n        for ( int i = 0; i < expectedSequence.length; i++ )\n        {\n            p.ping();\n            int count = Integer.parseInt( handler.getQueryMap().get( UdcConstants.PING ) );\n            assertEquals( expectedSequence[i], count );\n        }\n    }","id":79201,"modified_method":"@Test\n    public void crashPingSequenceShouldBeMinusOneThenTwoThenThreeEtc() throws Exception\n    {\n        int[] expectedSequence = {-1, 2, 3, 4};\n        final String hostURL = hostname+\":\"+ server.getServicePort();\n        final Map<String, String> udcFields = new HashMap<String, String>();\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ).withCrash() );\n        for ( int i = 0; i < expectedSequence.length; i++ )\n        {\n            p.ping();\n            int count = Integer.parseInt( handler.getQueryMap().get( UdcConstants.PING ) );\n            assertEquals( expectedSequence[i], count );\n        }\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldIncludePingCountInURI() throws IOException\n    {\n        final int EXPECTED_PING_COUNT = 16;\n        final HostnamePort hostURL = new HostnamePort( hostname, server.getServicePort() );\n        final Map<String, String> udcFields = new HashMap<String, String>();\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ) );\n        for ( int i = 0; i < EXPECTED_PING_COUNT; i++ )\n        {\n            p.ping();\n        }\n\n        assertThat( p.getPingCount(), is( equalTo( EXPECTED_PING_COUNT ) ) );\n\n        Map<String, String> actualQueryMap = handler.getQueryMap();\n        assertThat( actualQueryMap.get( UdcConstants.PING ), is( Integer.toString( EXPECTED_PING_COUNT ) ) );\n    }","id":79202,"modified_method":"@Test\n    public void shouldIncludePingCountInURI() throws IOException\n    {\n        final int EXPECTED_PING_COUNT = 16;\n        final String hostURL = hostname+\":\"+ server.getServicePort();\n        final Map<String, String> udcFields = new HashMap<String, String>();\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ) );\n        for ( int i = 0; i < EXPECTED_PING_COUNT; i++ )\n        {\n            p.ping();\n        }\n\n        assertThat( p.getPingCount(), is( equalTo( EXPECTED_PING_COUNT ) ) );\n\n        Map<String, String> actualQueryMap = handler.getQueryMap();\n        assertThat( actualQueryMap.get( UdcConstants.PING ), is( Integer.toString( EXPECTED_PING_COUNT ) ) );\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void normalPingSequenceShouldBeOneThenTwoThenThreeEtc() throws Exception\n    {\n        int[] expectedSequence = {1, 2, 3, 4};\n        final HostnamePort hostURL = new HostnamePort( hostname, server.getServicePort() );\n        final Map<String, String> udcFields = new HashMap<String, String>();\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ) );\n        for ( int i = 0; i < expectedSequence.length; i++ )\n        {\n            p.ping();\n            int count = Integer.parseInt( handler.getQueryMap().get( UdcConstants.PING ) );\n            assertEquals( expectedSequence[i], count );\n        }\n    }","id":79203,"modified_method":"@Test\n    public void normalPingSequenceShouldBeOneThenTwoThenThreeEtc() throws Exception\n    {\n        int[] expectedSequence = {1, 2, 3, 4};\n        final String hostURL = hostname+\":\"+ server.getServicePort();\n        final Map<String, String> udcFields = new HashMap<String, String>();\n\n        Pinger p = new Pinger( hostURL, new TestUdcCollector( udcFields ) );\n        for ( int i = 0; i < expectedSequence.length; i++ )\n        {\n            p.ping();\n            int count = Integer.parseInt( handler.getQueryMap().get( UdcConstants.PING ) );\n            assertEquals( expectedSequence[i], count );\n        }\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void start() throws Throwable\n    {\n        if ( !config.get( UdcSettings.udc_enabled ) )\n        {\n            return;\n        }\n\n        int firstDelay = config.get( UdcSettings.first_delay );\n        int interval = config.get( UdcSettings.interval );\n        HostnamePort hostAddress = config.get( UdcSettings.udc_host );\n\n        UdcInformationCollector collector = new DefaultUdcInformationCollector( config, xadsm, kernelData );\n        UdcTimerTask task = new UdcTimerTask( hostAddress, collector );\n\n        timer.scheduleAtFixedRate( task, firstDelay, interval );\n    }","id":79204,"modified_method":"@Override\n    public void start() throws Throwable\n    {\n        if ( !config.get( UdcSettings.udc_enabled ) )\n        {\n            return;\n        }\n\n        int firstDelay = config.get( UdcSettings.first_delay );\n        int interval = config.get( UdcSettings.interval );\n        String hostAddress = config.get(UdcSettings.udc_host);\n\n        UdcInformationCollector collector = new DefaultUdcInformationCollector( config, xadsm, kernelData );\n        UdcTimerTask task = new UdcTimerTask( hostAddress, collector );\n\n        timer.scheduleAtFixedRate( task, firstDelay, interval );\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"public UdcTimerTask( HostnamePort hostAddress, UdcInformationCollector collector )\n    {\n        this.storeId = collector.getStoreId();\n\n        successCounts.put( storeId, 0 );\n        failureCounts.put( storeId, 0 );\n\n        pinger = new Pinger( hostAddress, collector );\n    }","id":79205,"modified_method":"public UdcTimerTask( String hostAddress, UdcInformationCollector collector )\n    {\n        this.storeId = collector.getStoreId();\n\n        successCounts.put( storeId, 0 );\n        failureCounts.put( storeId, 0 );\n\n        pinger = new Pinger( hostAddress, collector );\n    }","commit_id":"64ac58353fa7f3fb0b1b26a897264fdd49a2a403","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void inlineElement(Project project, Editor editor, PsiElement element) {\n    final PsiField field = (PsiField) element.getNavigationElement();\n\n    if (!field.hasInitializer()) {\n      String message = RefactoringBundle.message(\"no.initializer.present.for.the.field\");\n      CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n      return;\n    }\n\n    if (field instanceof PsiEnumConstant) {\n      String message = REFACTORING_NAME + \" is not supported for enum constants\";\n      CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n      return;\n    }\n\n    if (ReferencesSearch.search(field, ProjectScope.getProjectScope(project), false).findFirst() == null) {\n      String message = RefactoringBundle.message(\"field.0.is.never.used\", field.getName());\n      CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n      return;\n    }\n\n    if (!field.hasModifierProperty(PsiModifier.FINAL)) {\n      final Ref<Boolean> hasWriteUsages = new Ref<Boolean>(false);\n      if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        @Override\n        public void run() {\n          for (PsiReference reference : ReferencesSearch.search(field)) {\n            final PsiElement referenceElement = reference.getElement();\n            if (!(referenceElement instanceof PsiExpression && PsiUtil.isAccessedForReading((PsiExpression)referenceElement))) {\n              hasWriteUsages.set(true);\n              break;\n            }\n          }\n        }\n      }, \"Check if inline is possible...\", true, project)) {\n        return;\n      }\n      if (hasWriteUsages.get()) {\n        String message = RefactoringBundle.message(\"0.refactoring.is.supported.only.for.final.fields\", REFACTORING_NAME);\n        CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n        return;\n      }\n    }\n\n    PsiReference reference = editor != null ? TargetElementUtilBase.findReference(editor, editor.getCaretModel().getOffset()) : null;\n    if (reference != null) {\n      final PsiElement resolve = reference.resolve();\n      if (resolve != null && !field.equals(resolve.getNavigationElement())) {\n        reference = null;\n      }\n    }\n\n    if ((!(element instanceof PsiCompiledElement) || reference == null) && !CommonRefactoringUtil.checkReadOnlyStatus(project, field)) return;\n    PsiReferenceExpression refExpression = reference instanceof PsiReferenceExpression ? (PsiReferenceExpression)reference : null;\n    InlineFieldDialog dialog = new InlineFieldDialog(project, field, refExpression);\n    dialog.show();\n  }","id":79206,"modified_method":"public void inlineElement(Project project, Editor editor, PsiElement element) {\n    final PsiElement navigationElement = element.getNavigationElement();\n    final PsiField field = (PsiField)(navigationElement instanceof PsiField ? navigationElement : element);\n\n    if (!field.hasInitializer()) {\n      String message = RefactoringBundle.message(\"no.initializer.present.for.the.field\");\n      CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n      return;\n    }\n\n    if (field instanceof PsiEnumConstant) {\n      String message = REFACTORING_NAME + \" is not supported for enum constants\";\n      CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n      return;\n    }\n\n    if (ReferencesSearch.search(field, ProjectScope.getProjectScope(project), false).findFirst() == null) {\n      String message = RefactoringBundle.message(\"field.0.is.never.used\", field.getName());\n      CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n      return;\n    }\n\n    if (!field.hasModifierProperty(PsiModifier.FINAL)) {\n      final Ref<Boolean> hasWriteUsages = new Ref<Boolean>(false);\n      if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        @Override\n        public void run() {\n          for (PsiReference reference : ReferencesSearch.search(field)) {\n            final PsiElement referenceElement = reference.getElement();\n            if (!(referenceElement instanceof PsiExpression && PsiUtil.isAccessedForReading((PsiExpression)referenceElement))) {\n              hasWriteUsages.set(true);\n              break;\n            }\n          }\n        }\n      }, \"Check if inline is possible...\", true, project)) {\n        return;\n      }\n      if (hasWriteUsages.get()) {\n        String message = RefactoringBundle.message(\"0.refactoring.is.supported.only.for.final.fields\", REFACTORING_NAME);\n        CommonRefactoringUtil.showErrorHint(project, editor, message, REFACTORING_NAME, HelpID.INLINE_FIELD);\n        return;\n      }\n    }\n\n    PsiReference reference = editor != null ? TargetElementUtilBase.findReference(editor, editor.getCaretModel().getOffset()) : null;\n    if (reference != null) {\n      final PsiElement resolve = reference.resolve();\n      if (resolve != null && !field.equals(resolve.getNavigationElement())) {\n        reference = null;\n      }\n    }\n\n    if ((!(element instanceof PsiCompiledElement) || reference == null) && !CommonRefactoringUtil.checkReadOnlyStatus(project, field)) return;\n    PsiReferenceExpression refExpression = reference instanceof PsiReferenceExpression ? (PsiReferenceExpression)reference : null;\n    InlineFieldDialog dialog = new InlineFieldDialog(project, field, refExpression);\n    dialog.show();\n  }","commit_id":"b1b13dc528e3d692d5f284169d7564e734c20424","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      super.visitMethod(method);\n      final PsiCodeBlock body = method.getBody();\n      if (body == null) {\n        return;\n      }\n      if (method.getNameIdentifier() == null) {\n        return;\n      }\n      final PsiMethod leastConcreteSuperMethod = getDirectSuperMethod(method);\n      if (leastConcreteSuperMethod == null) {\n        return;\n      }\n      final PsiClass objectClass = ClassUtils.findObjectClass(method);\n      final PsiMethod[] superMethods = method.findSuperMethods(objectClass);\n      if (superMethods.length > 0) {\n        return;\n      }\n      if (ignoreEmptySuperMethods) {\n        final PsiMethod superMethod = (PsiMethod)leastConcreteSuperMethod.getNavigationElement();\n        if (MethodUtils.isTrivial(superMethod, true)) {\n          return;\n        }\n      }\n      if (onlyReportWhenAnnotated) {\n        if (!AnnotationUtil.isAnnotated(leastConcreteSuperMethod, annotations)) {\n          return;\n        }\n      }\n      if (containsSuperCall(body, leastConcreteSuperMethod)) {\n        return;\n      }\n      registerMethodError(method);\n    }","id":79207,"modified_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      super.visitMethod(method);\n      final PsiCodeBlock body = method.getBody();\n      if (body == null) {\n        return;\n      }\n      if (method.getNameIdentifier() == null) {\n        return;\n      }\n      final PsiMethod leastConcreteSuperMethod = getDirectSuperMethod(method);\n      if (leastConcreteSuperMethod == null) {\n        return;\n      }\n      final PsiClass objectClass = ClassUtils.findObjectClass(method);\n      final PsiMethod[] superMethods = method.findSuperMethods(objectClass);\n      if (superMethods.length > 0) {\n        return;\n      }\n      if (ignoreEmptySuperMethods) {\n        final PsiElement element = leastConcreteSuperMethod.getNavigationElement();\n        final PsiMethod superMethod = element instanceof PsiMethod ? (PsiMethod)element : leastConcreteSuperMethod;\n        if (MethodUtils.isTrivial(superMethod, true)) {\n          return;\n        }\n      }\n      if (onlyReportWhenAnnotated) {\n        if (!AnnotationUtil.isAnnotated(leastConcreteSuperMethod, annotations)) {\n          return;\n        }\n      }\n      if (containsSuperCall(body, leastConcreteSuperMethod)) {\n        return;\n      }\n      registerMethodError(method);\n    }","commit_id":"b8a0f83e64d797c5e9a3ab8e5021f6f7f848f27b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiDocComment getDocComment(final PsiDocCommentOwner docOwner) {\n    PsiDocComment comment = ((PsiDocCommentOwner)docOwner.getNavigationElement()).getDocComment();\n    if (comment == null) { //check for non-normalized fields\n      final PsiModifierList modifierList = docOwner.getModifierList();\n      if (modifierList != null) {\n        final PsiElement parent = modifierList.getParent();\n        if (parent instanceof PsiDocCommentOwner) {\n          return ((PsiDocCommentOwner)parent.getNavigationElement()).getDocComment();\n        }\n      }\n    }\n    return comment;\n  }","id":79208,"modified_method":"@Nullable\n  private static PsiDocComment getDocComment(final PsiDocCommentOwner docOwner) {\n    PsiElement navElement = docOwner.getNavigationElement();\n    if (!(navElement instanceof PsiDocCommentOwner)) {\n      throw new AssertionError(\"Wrong navElement: \" + navElement + \"; original = \" + docOwner + \" of class \" + docOwner.getClass());\n    }\n    PsiDocComment comment = ((PsiDocCommentOwner)navElement).getDocComment();\n    if (comment == null) { //check for non-normalized fields\n      final PsiModifierList modifierList = docOwner.getModifierList();\n      if (modifierList != null) {\n        final PsiElement parent = modifierList.getParent();\n        if (parent instanceof PsiDocCommentOwner) {\n          return ((PsiDocCommentOwner)parent.getNavigationElement()).getDocComment();\n        }\n      }\n    }\n    return comment;\n  }","commit_id":"db159679567abdc7894a8371ac9bbdba3305fce5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setOutFaultMessage(Message m) {\n        outFaultMessage = m;\n        m.setExchange(this);\n    }","id":79209,"modified_method":"public void setOutFaultMessage(Message m) {\n        outFaultMessage = m;\n        if (null != m) {\n            m.setExchange(this);\n        }\n    }","commit_id":"e3d8ccc09f6c540dc1d377ffb42b2d867ee86ac8","url":"https://github.com/apache/cxf"},{"original_method":"public void setInFaultMessage(Message m) {\n        inFaultMessage = m;\n        m.setExchange(this);\n    }","id":79210,"modified_method":"public void setInFaultMessage(Message m) {\n        inFaultMessage = m;\n        if (null != m) {\n            m.setExchange(this);\n        }\n    }","commit_id":"e3d8ccc09f6c540dc1d377ffb42b2d867ee86ac8","url":"https://github.com/apache/cxf"},{"original_method":"@NotNull\n    @Override\n    public ChildAttributes getChildAttributes(int newChildIndex) {\n        IElementType type = getNode().getElementType();\n        if (CODE_BLOCKS.contains(type) ||\n            type == WHEN ||\n            type == IF ||\n            type == FOR ||\n            type == WHILE ||\n            type == DO_WHILE) {\n\n            return new ChildAttributes(Indent.getNormalIndent(), null);\n        }\n        else if (type == TRY) {\n            // In try - try BLOCK catch BLOCK finally BLOCK\n            return new ChildAttributes(Indent.getNoneIndent(), null);\n        }\n        else if (type == DOT_QUALIFIED_EXPRESSION) {\n            return new ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null);\n        }\n        else if (type == VALUE_PARAMETER_LIST || type == VALUE_ARGUMENT_LIST) {\n            // Child index 1 - cursor is after ( - parameter alignment should be recreated\n            // Child index 0 - before expression - know nothing about it\n            if (newChildIndex != 1 && newChildIndex != 0 && newChildIndex < getSubBlocks().size()) {\n                Block block = getSubBlocks().get(newChildIndex);\n                return new ChildAttributes(block.getIndent(), block.getAlignment());\n            }\n            return new ChildAttributes(Indent.getContinuationIndent(), null);\n        }\n\n        if (isIncomplete()) {\n            return super.getChildAttributes(newChildIndex);\n        }\n\n        return new ChildAttributes(Indent.getNoneIndent(), null);\n    }","id":79211,"modified_method":"@NotNull\n    @Override\n    public ChildAttributes getChildAttributes(int newChildIndex) {\n        IElementType type = getNode().getElementType();\n        if (CODE_BLOCKS.contains(type) ||\n            type == WHEN ||\n            type == IF ||\n            type == FOR ||\n            type == WHILE ||\n            type == DO_WHILE) {\n\n            return new ChildAttributes(Indent.getNormalIndent(), null);\n        }\n        else if (type == TRY) {\n            // In try - try BLOCK catch BLOCK finally BLOCK\n            return new ChildAttributes(Indent.getNoneIndent(), null);\n        }\n        else if (type == DOT_QUALIFIED_EXPRESSION) {\n            return new ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null);\n        }\n        else if (type == VALUE_PARAMETER_LIST || type == VALUE_ARGUMENT_LIST) {\n            // Child index 1 - cursor is after ( - parameter alignment should be recreated\n            // Child index 0 - before expression - know nothing about it\n            if (newChildIndex != 1 && newChildIndex != 0 && newChildIndex < getSubBlocks().size()) {\n                Block block = getSubBlocks().get(newChildIndex);\n                return new ChildAttributes(block.getIndent(), block.getAlignment());\n            }\n            return new ChildAttributes(Indent.getContinuationIndent(), null);\n        }\n        else if (type == DOC_COMMENT) {\n            return new ChildAttributes(Indent.getSpaceIndent(KDOC_COMMENT_INDENT), null);\n        }\n\n        if (isIncomplete()) {\n            return super.getChildAttributes(newChildIndex);\n        }\n\n        return new ChildAttributes(Indent.getNoneIndent(), null);\n    }","commit_id":"9dfe0f42a38c2f482166b2744b9dc270d9ce3e17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .aroundInside(ARROW, WHEN_ENTRY).spaces(1)\n                ;\n    }","id":79212,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .aroundInside(ARROW, WHEN_ENTRY).spaces(1)\n\n                // KDoc\n                .between(KDocTokens.LEADING_ASTERISK, KDocTokens.TEXT).spacing(1, 100, 0, true, 100)\n                ;\n    }","commit_id":"9dfe0f42a38c2f482166b2744b9dc270d9ce3e17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public FormattingModel createModel(PsiElement element, CodeStyleSettings settings) {\n        JetBlock block = new JetBlock(\n            element.getNode(), ASTAlignmentStrategy.getNullStrategy(), Indent.getNoneIndent(), null, settings,\n            createSpacingBuilder(settings));\n\n        return FormattingModelProvider.createFormattingModelForPsiFile(\n            element.getContainingFile(), block, settings);\n    }","id":79213,"modified_method":"@NotNull\n    @Override\n    public FormattingModel createModel(PsiElement element, CodeStyleSettings settings) {\n        PsiFile containingFile = element.getContainingFile().getViewProvider().getPsi(JetLanguage.INSTANCE);\n        JetBlock block = new JetBlock(\n            containingFile.getNode(), ASTAlignmentStrategy.getNullStrategy(), Indent.getNoneIndent(), null, settings,\n            createSpacingBuilder(settings));\n\n        return FormattingModelProvider.createFormattingModelForPsiFile(\n            element.getContainingFile(), block, settings);\n    }","commit_id":"9dfe0f42a38c2f482166b2744b9dc270d9ce3e17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n\n                .aroundInside(ELSE_KEYWORD, IF).spaces(1)\n                .betweenInside(RPAR, THEN, IF).spaces(1)\n                ;\n    }","id":79214,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n\n                .aroundInside(ELSE_KEYWORD, IF).spaces(1)\n                .betweenInside(RPAR, THEN, IF).spaces(1)\n\n                .between(RPAR, BODY).spaces(1)\n                ;\n    }","commit_id":"7587e8ffcb486a49b55ced92a99e0fbee119b8ec","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n    final IFileElementType file = LanguageParserDefinitions.INSTANCE.forLanguage(PythonLanguage.getInstance()).getFileNodeType();\n    final PyCodeStyleSettings pySettings = settings.getCustomSettings(PyCodeStyleSettings.class);\n    final TokenSet STATEMENT_OR_DECLARATION =\n      TokenSet.orSet(PythonDialectsTokenSetProvider.INSTANCE.getStatementTokens(), CLASS_OR_FUNCTION);\n\n    final CommonCodeStyleSettings commonSettings = settings.getCommonSettings(PythonLanguage.getInstance());\n    return new SpacingBuilder(settings)\n      .between(IMPORT_STATEMENTS, TokenSet.andNot(STATEMENT_OR_DECLARATION, IMPORT_STATEMENTS)).blankLines(commonSettings.BLANK_LINES_AFTER_IMPORTS)\n      .betweenInside(CLASS_OR_FUNCTION, CLASS_OR_FUNCTION, file).blankLines(pySettings.BLANK_LINES_BETWEEN_TOP_LEVEL_CLASSES_FUNCTIONS)\n      .between(CLASS_DECLARATION, STATEMENT_OR_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_CLASS)\n      .between(STATEMENT_OR_DECLARATION, CLASS_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_CLASS)\n      .between(FUNCTION_DECLARATION, STATEMENT_OR_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_METHOD)\n      .between(STATEMENT_OR_DECLARATION, FUNCTION_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_METHOD)\n      .after(FUNCTION_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_METHOD)\n      .after(CLASS_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_CLASS)\n      .between(STATEMENT_OR_DECLARATION, STATEMENT_OR_DECLARATION).spacing(0, Integer.MAX_VALUE, 1, false, 1)\n      \n      .between(COLON, STATEMENT_LIST).spacing(1, Integer.MAX_VALUE, 0, true, 0)\n      .afterInside(COLON, TokenSet.create(KEY_VALUE_EXPRESSION, LAMBDA_EXPRESSION)).spaceIf(pySettings.SPACE_AFTER_PY_COLON)\n\n      .afterInside(GT, ANNOTATION).spaces(1)\n      .betweenInside(MINUS, GT, ANNOTATION).none()\n      .beforeInside(ANNOTATION, FUNCTION_DECLARATION).spaces(1)\n\n      .between(allButLambda(), PARAMETER_LIST).spaceIf(commonSettings.SPACE_BEFORE_METHOD_PARENTHESES)\n\n      .before(COLON).spaceIf(pySettings.SPACE_BEFORE_PY_COLON)\n      .after(COMMA).spaceIf(commonSettings.SPACE_AFTER_COMMA)\n      .before(COMMA).spaceIf(commonSettings.SPACE_BEFORE_COMMA)\n      .between(FROM_KEYWORD, DOT).spaces(1)\n      .around(DOT).spaces(0)\n      .before(SEMICOLON).spaceIf(commonSettings.SPACE_BEFORE_SEMICOLON)\n      .withinPairInside(LPAR, RPAR, ARGUMENT_LIST).spaceIf(commonSettings.SPACE_WITHIN_METHOD_CALL_PARENTHESES)\n      .before(LBRACKET).spaceIf(pySettings.SPACE_BEFORE_LBRACKET)\n\n      .withinPair(LBRACE, RBRACE).spaceIf(commonSettings.SPACE_WITHIN_BRACES)\n      .withinPair(LBRACKET, RBRACKET).spaceIf(commonSettings.SPACE_WITHIN_BRACKETS)\n\n      .before(ARGUMENT_LIST).spaceIf(commonSettings.SPACE_BEFORE_METHOD_CALL_PARENTHESES)\n\n      .around(DECORATOR_CALL).spacing(1, Integer.MAX_VALUE, 0, true, 0)\n      .after(DECORATOR_LIST).spacing(1, Integer.MAX_VALUE, 0, true, 0)\n\n      .aroundInside(EQ, ASSIGNMENT_STATEMENT).spaceIf(commonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n      .aroundInside(EQ, NAMED_PARAMETER).spaceIf(pySettings.SPACE_AROUND_EQ_IN_NAMED_PARAMETER)\n      .aroundInside(EQ, KEYWORD_ARGUMENT_EXPRESSION).spaceIf(pySettings.SPACE_AROUND_EQ_IN_KEYWORD_ARGUMENT)\n\n      .around(AUG_ASSIGN_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n      .aroundInside(ADDITIVE_OPERATIONS, BINARY_EXPRESSION).spaceIf(commonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n      .aroundInside(MULTIPLICATIVE_OR_EXP, STAR_PARAMETERS).none()\n      .around(MULTIPLICATIVE_OR_EXP).spaceIf(commonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n      .around(SHIFT_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_SHIFT_OPERATORS)\n      .around(BITWISE_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_BITWISE_OPERATORS)\n      .around(EQUALITY_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n      .around(RELATIONAL_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n      .around(SINGLE_SPACE_KEYWORDS).spaces(1);\n  }","id":79215,"modified_method":"protected SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n    final IFileElementType file = LanguageParserDefinitions.INSTANCE.forLanguage(PythonLanguage.getInstance()).getFileNodeType();\n    final PyCodeStyleSettings pySettings = settings.getCustomSettings(PyCodeStyleSettings.class);\n    final TokenSet STATEMENT_OR_DECLARATION =\n      TokenSet.orSet(PythonDialectsTokenSetProvider.INSTANCE.getStatementTokens(), CLASS_OR_FUNCTION);\n\n    final CommonCodeStyleSettings commonSettings = settings.getCommonSettings(PythonLanguage.getInstance());\n    return new SpacingBuilder(settings)\n      .between(IMPORT_STATEMENTS, TokenSet.andNot(STATEMENT_OR_DECLARATION, IMPORT_STATEMENTS)).blankLines(commonSettings.BLANK_LINES_AFTER_IMPORTS)\n      .betweenInside(CLASS_OR_FUNCTION, CLASS_OR_FUNCTION, file).blankLines(pySettings.BLANK_LINES_BETWEEN_TOP_LEVEL_CLASSES_FUNCTIONS)\n      .between(CLASS_DECLARATION, STATEMENT_OR_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_CLASS)\n      .between(STATEMENT_OR_DECLARATION, CLASS_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_CLASS)\n      .between(FUNCTION_DECLARATION, STATEMENT_OR_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_METHOD)\n      .between(STATEMENT_OR_DECLARATION, FUNCTION_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_METHOD)\n      .after(FUNCTION_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_METHOD)\n      .after(CLASS_DECLARATION).blankLines(commonSettings.BLANK_LINES_AROUND_CLASS)\n      .between(STATEMENT_OR_DECLARATION, STATEMENT_OR_DECLARATION).spacing(0, Integer.MAX_VALUE, 1, false, 1)\n      \n      .between(COLON, STATEMENT_LIST).spacing(1, Integer.MAX_VALUE, 0, true, 0)\n      .afterInside(COLON, TokenSet.create(KEY_VALUE_EXPRESSION, LAMBDA_EXPRESSION)).spaceIf(pySettings.SPACE_AFTER_PY_COLON)\n\n      .afterInside(GT, ANNOTATION).spaces(1)\n      .betweenInside(MINUS, GT, ANNOTATION).none()\n      .beforeInside(ANNOTATION, FUNCTION_DECLARATION).spaces(1)\n\n      .between(allButLambda(), PARAMETER_LIST).spaceIf(commonSettings.SPACE_BEFORE_METHOD_PARENTHESES)\n\n      .before(COLON).spaceIf(pySettings.SPACE_BEFORE_PY_COLON)\n      .after(COMMA).spaceIf(commonSettings.SPACE_AFTER_COMMA)\n      .before(COMMA).spaceIf(commonSettings.SPACE_BEFORE_COMMA)\n      .between(FROM_KEYWORD, DOT).spaces(1)\n      .between(DOT, IMPORT_KEYWORD).spaces(1)\n      .around(DOT).spaces(0)\n      .before(SEMICOLON).spaceIf(commonSettings.SPACE_BEFORE_SEMICOLON)\n      .withinPairInside(LPAR, RPAR, ARGUMENT_LIST).spaceIf(commonSettings.SPACE_WITHIN_METHOD_CALL_PARENTHESES)\n      .before(LBRACKET).spaceIf(pySettings.SPACE_BEFORE_LBRACKET)\n\n      .withinPair(LBRACE, RBRACE).spaceIf(commonSettings.SPACE_WITHIN_BRACES)\n      .withinPair(LBRACKET, RBRACKET).spaceIf(commonSettings.SPACE_WITHIN_BRACKETS)\n\n      .before(ARGUMENT_LIST).spaceIf(commonSettings.SPACE_BEFORE_METHOD_CALL_PARENTHESES)\n\n      .around(DECORATOR_CALL).spacing(1, Integer.MAX_VALUE, 0, true, 0)\n      .after(DECORATOR_LIST).spacing(1, Integer.MAX_VALUE, 0, true, 0)\n\n      .aroundInside(EQ, ASSIGNMENT_STATEMENT).spaceIf(commonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n      .aroundInside(EQ, NAMED_PARAMETER).spaceIf(pySettings.SPACE_AROUND_EQ_IN_NAMED_PARAMETER)\n      .aroundInside(EQ, KEYWORD_ARGUMENT_EXPRESSION).spaceIf(pySettings.SPACE_AROUND_EQ_IN_KEYWORD_ARGUMENT)\n\n      .around(AUG_ASSIGN_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n      .aroundInside(ADDITIVE_OPERATIONS, BINARY_EXPRESSION).spaceIf(commonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n      .aroundInside(MULTIPLICATIVE_OR_EXP, STAR_PARAMETERS).none()\n      .around(MULTIPLICATIVE_OR_EXP).spaceIf(commonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n      .around(SHIFT_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_SHIFT_OPERATORS)\n      .around(BITWISE_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_BITWISE_OPERATORS)\n      .around(EQUALITY_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n      .around(RELATIONAL_OPERATIONS).spaceIf(commonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n      .around(SINGLE_SPACE_KEYWORDS).spaces(1);\n  }","commit_id":"e57ceea8f418d9217a4d33bbff907ad37171761b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public ChildAttributes getChildAttributes(int newChildIndex) {\n        IElementType type = getNode().getElementType();\n        if (CODE_BLOCKS.contains(type) ||\n            type == WHEN ||\n            type == IF ||\n            type == FOR ||\n            type == WHILE ||\n            type == DO_WHILE) {\n\n            return new ChildAttributes(Indent.getNormalIndent(), null);\n        }\n        else if (type == TRY) {\n            // In try - try BLOCK catch BLOCK finally BLOCK\n            return new ChildAttributes(Indent.getNoneIndent(), null);\n        }\n        else if (type == DOT_QUALIFIED_EXPRESSION) {\n            return new ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null);\n        }\n        else if (type == VALUE_PARAMETER_LIST || type == VALUE_ARGUMENT_LIST) {\n            // Child index 1 - cursor is after ( - parameter alignment should be recreated\n            // Child index 0 - before expression - know nothing about it\n            if (newChildIndex != 1 && newChildIndex != 0 && newChildIndex < getSubBlocks().size()) {\n                Block block = getSubBlocks().get(newChildIndex);\n                return new ChildAttributes(block.getIndent(), block.getAlignment());\n            }\n            return new ChildAttributes(Indent.getContinuationIndent(), null);\n        }\n\n        if (isIncomplete()) {\n            return super.getChildAttributes(newChildIndex);\n        }\n\n        return new ChildAttributes(Indent.getNoneIndent(), null);\n    }","id":79216,"modified_method":"@NotNull\n    @Override\n    public ChildAttributes getChildAttributes(int newChildIndex) {\n        IElementType type = getNode().getElementType();\n        if (CODE_BLOCKS.contains(type) ||\n            type == WHEN ||\n            type == IF ||\n            type == FOR ||\n            type == WHILE ||\n            type == DO_WHILE) {\n\n            return new ChildAttributes(Indent.getNormalIndent(), null);\n        }\n        else if (type == TRY) {\n            // In try - try BLOCK catch BLOCK finally BLOCK\n            return new ChildAttributes(Indent.getNoneIndent(), null);\n        }\n        else if (type == DOT_QUALIFIED_EXPRESSION) {\n            return new ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null);\n        }\n        else if (type == VALUE_PARAMETER_LIST || type == VALUE_ARGUMENT_LIST) {\n            // Child index 1 - cursor is after ( - parameter alignment should be recreated\n            // Child index 0 - before expression - know nothing about it\n            if (newChildIndex != 1 && newChildIndex != 0 && newChildIndex < getSubBlocks().size()) {\n                Block block = getSubBlocks().get(newChildIndex);\n                return new ChildAttributes(block.getIndent(), block.getAlignment());\n            }\n            return new ChildAttributes(Indent.getContinuationIndent(), null);\n        }\n        else if (type == DOC_COMMENT) {\n            return new ChildAttributes(Indent.getSpaceIndent(KDOC_COMMENT_INDENT), null);\n        }\n\n        if (isIncomplete()) {\n            return super.getChildAttributes(newChildIndex);\n        }\n\n        return new ChildAttributes(Indent.getNoneIndent(), null);\n    }","commit_id":"f9e8683db560a0d01f72891350c63eb3b0464003","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .aroundInside(ARROW, WHEN_ENTRY).spaces(1)\n                ;\n    }","id":79217,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .aroundInside(ARROW, WHEN_ENTRY).spaces(1)\n\n                // KDoc\n                .between(KDocTokens.LEADING_ASTERISK, KDocTokens.TEXT).spacing(1, 100, 0, true, 100)\n                ;\n    }","commit_id":"f9e8683db560a0d01f72891350c63eb3b0464003","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public FormattingModel createModel(PsiElement element, CodeStyleSettings settings) {\n        JetBlock block = new JetBlock(\n            element.getNode(), ASTAlignmentStrategy.getNullStrategy(), Indent.getNoneIndent(), null, settings,\n            createSpacingBuilder(settings));\n\n        return FormattingModelProvider.createFormattingModelForPsiFile(\n            element.getContainingFile(), block, settings);\n    }","id":79218,"modified_method":"@NotNull\n    @Override\n    public FormattingModel createModel(PsiElement element, CodeStyleSettings settings) {\n        PsiFile containingFile = element.getContainingFile().getViewProvider().getPsi(JetLanguage.INSTANCE);\n        JetBlock block = new JetBlock(\n            containingFile.getNode(), ASTAlignmentStrategy.getNullStrategy(), Indent.getNoneIndent(), null, settings,\n            createSpacingBuilder(settings));\n\n        return FormattingModelProvider.createFormattingModelForPsiFile(\n            element.getContainingFile(), block, settings);\n    }","commit_id":"f9e8683db560a0d01f72891350c63eb3b0464003","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n   * The default implementations checks for resolve problems (if {@link #shouldCheckResolveProblems(com.intellij.util.xml.GenericDomValue)} returns true),\n   * then runs annotators (see {@link com.intellij.util.xml.DomFileDescription#createAnnotator()}),\n   * checks for {@link @com.intellij.util.xml.Required} and {@link @com.intellij.util.xml.ExtendClass} annotation problems, checks\n   * for name identity (see {@link @com.intellij.util.xml.NameValue} annotation).\n   * @param element element to check\n   * @param holder a place to add problems to\n   * @param helper helper object\n   */\n  protected void checkDomElement(DomElement element, DomElementAnnotationHolder holder, DomHighlightingHelper helper) {\n    final int oldSize = holder.getSize();\n    if (element instanceof GenericDomValue) {\n      final GenericDomValue genericDomValue = (GenericDomValue)element;\n      if (shouldCheckResolveProblems(genericDomValue)) {\n        helper.checkResolveProblems(genericDomValue, holder);\n      }\n    }\n    for (final Class<? extends T> aClass : getDomClasses()) {\n      helper.runAnnotators(element, holder, aClass);\n    }\n    if (oldSize != holder.getSize()) return;\n\n    if (!helper.checkRequired(element, holder).isEmpty()) return;\n    if (element instanceof GenericDomValue) {\n      helper.checkExtendClass((GenericDomValue)element, holder);\n    } else {\n      helper.checkNameIdentity(element, holder);\n    }\n  }","id":79219,"modified_method":"/**\n   * The default implementations checks for resolve problems (if {@link #shouldCheckResolveProblems(com.intellij.util.xml.GenericDomValue)} returns true),\n   * then runs annotators (see {@link com.intellij.util.xml.DomFileDescription#createAnnotator()}),\n   * checks for {@link @com.intellij.util.xml.Required} and {@link @com.intellij.util.xml.ExtendClass} annotation problems, checks\n   * for name identity (see {@link @com.intellij.util.xml.NameValue} annotation).\n   * @param element element to check\n   * @param holder a place to add problems to\n   * @param helper helper object\n   */\n  protected void checkDomElement(DomElement element, DomElementAnnotationHolder holder, DomHighlightingHelper helper) {\n    final int oldSize = holder.getSize();\n    if (element instanceof GenericDomValue) {\n      final GenericDomValue genericDomValue = (GenericDomValue)element;\n      if (shouldCheckResolveProblems(genericDomValue)) {\n        helper.checkResolveProblems(genericDomValue, holder);\n      }\n    }\n    for (final Class<? extends T> aClass : getDomClasses()) {\n      helper.runAnnotators(element, holder, aClass);\n    }\n    if (oldSize != holder.getSize()) return;\n\n    if (!helper.checkRequired(element, holder).isEmpty()) return;\n    if (element instanceof GenericDomValue) {\n      helper.checkExtendClass((GenericDomValue)element, holder);\n    }\n    if (!(element instanceof GenericAttributeValue) && !GenericDomValue.class.equals(ReflectionUtil.getRawType(element.getDomElementType()))) {\n      helper.checkNameIdentity(element, holder);\n    }\n  }","commit_id":"219d32794f6eaf245181d5297063bad43b43a961","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls\n  public final String getName() {\n    return ElementPresentationManager.getElementName(myElement);\n  }","id":79220,"modified_method":"@NonNls\n  public final String getName() {\n    final String s = ElementPresentationManager.getElementName(myElement);\n    if (s != null) return s;\n\n    final GenericDomValue value = getNameElement(myElement);\n    return value == null ? null : value.getStringValue();\n  }","commit_id":"219d32794f6eaf245181d5297063bad43b43a961","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isClassAcceptable(Class hintClass) {\n    throw new UnsupportedOperationException(\"Method isClassAcceptable is not yet implemented in \" + getClass().getName());\n  }","id":79221,"modified_method":"public boolean isClassAcceptable(Class hintClass) {\n    return true;\n    //throw new UnsupportedOperationException(\"Method isClassAcceptable is not yet implemented in \" + getClass().getName());\n  }","commit_id":"219d32794f6eaf245181d5297063bad43b43a961","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getFullName(final Object element) {\n    for(ChooseByNameContributor c: getContributors()) {\n      if (c instanceof GotoClassContributor) {\n        String result = ((GotoClassContributor) c).getQualifiedName((NavigationItem) element);\n        if (result != null) return result;\n      }\n    }\n\n    if (element instanceof PsiElement) {\n      final PsiElement psiElement = (PsiElement)element;\n\n      final String containerText = SymbolPresentationUtil.getSymbolContainerText(psiElement);\n      return containerText + \".\" + getElementName(element);\n    }\n\n    return getElementName(element);\n  }","id":79222,"modified_method":"@Override\n  public String getFullName(final Object element) {\n    for(ChooseByNameContributor c: getContributors()) {\n      if (c instanceof GotoClassContributor) {\n        String result = ((GotoClassContributor) c).getQualifiedName((NavigationItem) element);\n        if (result != null) {\n          return result;\n        }\n      }\n    }\n\n    String elementName = getElementName(element);\n    if (elementName == null) return null;\n    \n    if (element instanceof PsiElement) {\n      return SymbolPresentationUtil.getSymbolContainerText((PsiElement)element) + \".\" + elementName;\n    }\n\n    return elementName;\n  }","commit_id":"933c61a41054a2ed79aca52544dacf8c12c74ef3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void close(final boolean isOk) {\n    if (myDisposedFlag){\n      return;\n    }\n\n    if (isOk){\n      myModel.saveInitialCheckBoxState(myCheckBox.isSelected());\n\n      final List<Object> chosenElements = getChosenElements();\n      if (chosenElements != null) {\n        for (Object element : chosenElements) {\n          myActionListener.elementChosen(element);\n        }\n      } else {\n        return;\n      }\n\n      if (chosenElements.size() > 0){\n        final String enteredText = myTextField.getText().toLowerCase();\n        if (enteredText.indexOf('*') >= 0) {\n          FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.wildcards\");\n        }\n        else {\n          for (Object element : chosenElements) {\n            final String choosenElementText = myModel.getElementName(element).toLowerCase();\n            if (!choosenElementText.startsWith(enteredText)) {\n              FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.camelprefix\");\n              break;\n            }\n          }\n        }\n      }\n      else{\n        return;\n      }\n    }\n\n    myDisposedFlag = true;\n    myAlarm.cancelAllRequests();\n    myProject.putUserData(CHOOSE_BY_NAME_POPUP_IN_PROJECT_KEY, null);\n\n    //LaterInvocator.leaveModal(myTextFieldPanel);\n\n    cleanupUI();\n    myActionListener.onClose ();\n  }","id":79223,"modified_method":"protected void close(final boolean isOk) {\n    if (myDisposedFlag){\n      return;\n    }\n\n    if (isOk){\n      myModel.saveInitialCheckBoxState(myCheckBox.isSelected());\n\n      final List<Object> chosenElements = getChosenElements();\n      if (chosenElements != null) {\n        for (Object element : chosenElements) {\n          myActionListener.elementChosen(element);\n        }\n      } else {\n        return;\n      }\n\n      if (chosenElements.size() > 0){\n        final String enteredText = myTextField.getText().toLowerCase();\n        if (enteredText.indexOf('*') >= 0) {\n          FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.wildcards\");\n        }\n        else {\n          for (Object element : chosenElements) {\n            final String name = myModel.getElementName(element);\n            if (name != null) {\n              final String choosenElementText = name.toLowerCase();\n              if (!choosenElementText.startsWith(enteredText)) {\n                FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.camelprefix\");\n                break;\n              }\n            }\n          }\n        }\n      }\n      else{\n        return;\n      }\n    }\n\n    myDisposedFlag = true;\n    myAlarm.cancelAllRequests();\n    myProject.putUserData(CHOOSE_BY_NAME_POPUP_IN_PROJECT_KEY, null);\n\n    //LaterInvocator.leaveModal(myTextFieldPanel);\n\n    cleanupUI();\n    myActionListener.onClose ();\n  }","commit_id":"197c8ff98d3c8d29e9d18a3d4330fd581259fb6f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#getDefault(org.opencms.file.CmsObject, org.opencms.xml.types.I_CmsXmlSchemaType, java.util.Locale)\n     */\n    public String getDefault(CmsObject cms, I_CmsXmlSchemaType type, Locale locale) {\n\n        String defaultValue = (String)m_defaultValues.get(type.getElementName());\n        if (defaultValue != null) {\n            // return the string set in the appinfo with processed macros\n            return CmsStringUtil.substituteMacros(defaultValue, new CmsStringMapper(this, null, locale, cms));\n        }\n\n        // default implementation currently just uses the \"getDefault\" mehod of the given value\n        return type.getDefault(locale);\n    }","id":79224,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#getDefault(org.opencms.file.CmsObject, org.opencms.xml.types.I_CmsXmlSchemaType, java.util.Locale)\n     */\n    public String getDefault(CmsObject cms, I_CmsXmlSchemaType type, Locale locale) {\n        \n        String elementName = type.getElementName();\n        String defaultValue = (String)m_defaultValues.get(elementName);\n        if (defaultValue == null) {\n            // use the \"getDefault\" method of the given value, will use value from standard XML schema\n            defaultValue = type.getDefault(locale);\n        }        \n        if (defaultValue != null) {            \n            // return the default value with processed macros\n            return CmsStringUtil.substituteMacros(defaultValue, new CmsStringMapper(this, null, locale, cms));\n        }\n        // no default value is available\n        return null; \n    }","commit_id":"c334418c5e5ea72c046ae705a22c15c113d4db2d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"Grouping getGrouping(){\r\n\t\treturn provider.getGrouping();\r\n\t}","id":79225,"modified_method":"Grouping getGrouping(){\r\n\t\treturn provider == null? null : provider.getGrouping();\r\n\t}","commit_id":"c7ad8e964d1462e0ab60d0aa6965124e285e3fb5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private String getDescriptionAndMarkersCount(Object[] objects) {\r\n\t\tif(objects.length == 0){\r\n\t\t\treturn \"Nothing...\";\r\n\t\t}\r\n\t\tif(objects.length == 1){\r\n\t\t\treturn getText(objects[0]);\r\n\t\t}\r\n\t\tList<BugGroup> groups = new ArrayList<BugGroup>();\r\n\t\tList<IMarker> markers = new ArrayList<IMarker>();\r\n\t\tfor (Object object : objects) {\r\n\t\t\tif(object instanceof BugGroup){\r\n\t\t\t\tgroups.add((BugGroup) object);\r\n\t\t\t} else if(object instanceof IMarker){\r\n\t\t\t\tmarkers.add((IMarker) object);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(groups.size() > 1) {\r\n\t\t\tCollections.sort(groups, new Comparator<BugGroup>(){\r\n\t\t\t\tGrouping grouping = getGrouping();\r\n\t\t\t\tpublic int compare(BugGroup o1, BugGroup o2) {\r\n\t\t\t\t\treturn grouping.compare(o1.getType(), o2.getType());\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\t\t}\r\n\t\tSet<BugGroup> finalGroups = new HashSet<BugGroup>();\r\n\t\tint count = 0;\r\n\t\twhile(!groups.isEmpty()){\r\n\t\t\tBugGroup g1 = groups.remove(groups.size() - 1);\r\n\t\t\tboolean keepIt = true;\r\n\t\t\tfor (BugGroup g2 : groups) {\r\n\t\t\t\tObject parent = g1.getParent();\r\n\t\t\t\twhile(g2 != parent && parent instanceof BugGroup){\r\n\t\t\t\t\tparent = ((BugGroup) parent).getParent();\r\n\t\t\t\t}\r\n\t\t\t\tif(g2 == parent){\r\n\t\t\t\t\tkeepIt = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(keepIt){\r\n\t\t\t\tfinalGroups.add(g1);\r\n\t\t\t\tcount += g1.getMarkersCount() - getFilteredMarkersCount(g1);\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(!markers.isEmpty()) {\r\n\t\t\tIMarker marker = markers.remove(markers.size() - 1);\r\n\t\t\tboolean keepIt = true;\r\n\t\t\tfor (BugGroup group : finalGroups) {\r\n\t\t\t\tif(group.contains(marker)){\r\n\t\t\t\t\tkeepIt = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(keepIt){\r\n\t\t\t\tcount ++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tStringBuffer sb = new StringBuffer(\"Selection contains \");\r\n\t\tif(count == 1){\r\n\t\t\tsb.append(\"exactly one single bug\");\r\n\t\t} else if(count == 0){\r\n\t\t\tsb.append(\"zero bugs (change filter settings to see more...)\");\r\n\t\t} else {\r\n\t\t\tsb.append(count).append(\" bugs\");\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}","id":79226,"modified_method":"private String getDescriptionAndBugCount(Object[] objects) {\r\n\t\tif(objects.length == 0){\r\n\t\t\treturn \"Nothing...\";\r\n\t\t}\r\n\t\tif(objects.length == 1){\r\n\t\t\treturn getText(objects[0]);\r\n\t\t}\r\n\t\tint count = getBugCountsSum(objects);\r\n\t\tStringBuffer sb = new StringBuffer(\"Selection contains \");\r\n\t\tif(count == 1){\r\n\t\t\tsb.append(\"exactly one single bug\");\r\n\t\t} else if(count == 0){\r\n\t\t\tsb.append(\"zero bugs (change filter settings to see more...)\");\r\n\t\t} else {\r\n\t\t\tsb.append(count).append(\" bugs\");\r\n\t\t}\r\n\t\tif(isStandalone()){\r\n\t\t\tsb.append(\" (not filtered)\");\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}","commit_id":"c7ad8e964d1462e0ab60d0aa6965124e285e3fb5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public String getText(Object element) {\r\n\t\tif (element instanceof BugGroup) {\r\n\t\t\tBugGroup group = (BugGroup) element;\r\n\t\t\tif(isStandalone()){\r\n\t\t\t\treturn group.getShortDescription();\r\n\t\t\t}\r\n\t\t\tint filtered = getFilteredMarkersCount(group);\r\n\t\t\tString filterCount = filtered > 0? \"/\" + filtered + \" filtered\" : \"\";\r\n\t\t\treturn group.getShortDescription() + \" (\"\r\n\t\t\t\t\t+ (group.getMarkersCount() - filtered) + filterCount + \")\";\r\n\t\t}\r\n\t\tif(element instanceof IMarker){\r\n\t\t\tIMarker marker = (IMarker) element;\r\n\t\t\tif(!marker.exists()){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(element instanceof IStructuredSelection){\r\n\t\t\treturn getDescriptionAndMarkersCount(((IStructuredSelection)element).toArray());\r\n\t\t}\r\n\t\tif(element instanceof Object[]){\r\n\t\t\treturn getDescriptionAndMarkersCount((Object[]) element);\r\n\t\t}\r\n\t\treturn wbProvider.getText(element);\r\n\t}","id":79227,"modified_method":"public String getText(Object element) {\r\n\t\tif (element instanceof BugGroup) {\r\n\t\t\tBugGroup group = (BugGroup) element;\r\n\t\t\tif(isStandalone()){\r\n\t\t\t\treturn group.getShortDescription();\r\n\t\t\t}\r\n\t\t\tint filtered = getFilteredMarkersCount(group);\r\n\t\t\tString filterCount = filtered > 0? \"/\" + filtered + \" filtered\" : \"\";\r\n\t\t\treturn group.getShortDescription() + \" (\"\r\n\t\t\t\t\t+ (group.getMarkersCount() - filtered) + filterCount + \")\";\r\n\t\t}\r\n\t\tif(element instanceof IMarker){\r\n\t\t\tIMarker marker = (IMarker) element;\r\n\t\t\tif(!marker.exists()){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(element instanceof IStructuredSelection){\r\n\t\t\treturn getDescriptionAndBugCount(((IStructuredSelection)element).toArray());\r\n\t\t}\r\n\t\tif(element instanceof Object[]){\r\n\t\t\treturn getDescriptionAndBugCount((Object[]) element);\r\n\t\t}\r\n\t\treturn wbProvider.getText(element);\r\n\t}","commit_id":"c7ad8e964d1462e0ab60d0aa6965124e285e3fb5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"String getTitle(IPackageFragment pack){\r\n\t\tif(pack == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tStringBuilder sb = new StringBuilder(\"Package: \");\r\n\t\tsb.append(pack.getElementName());\r\n\t\treturn sb.toString();\r\n\t}","id":79228,"modified_method":"String getTitle(IPackageFragment pack){\r\n\t\tif(pack == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tStringBuilder sb = new StringBuilder(\"Package: \");\r\n\t\tString name = pack.getElementName();\r\n\t\tif(name == null || name.length() == 0){\r\n\t\t\tsb.append(\"default package\");\r\n\t\t} else {\r\n\t\t\tsb.append(name);\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}","commit_id":"c7ad8e964d1462e0ab60d0aa6965124e285e3fb5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\r\n\tpublic String getText(Object element) {\r\n\t\tif(element instanceof IStructuredSelection){\r\n\t\t\tIStructuredSelection selection = (IStructuredSelection) element;\r\n\t\t\telement = selection.getFirstElement();\r\n\t\t}\r\n\t\tString title = getTitle(element);\r\n\t\tif(title != null){\r\n\t\t\treturn title;\r\n\t\t}\r\n\t\treturn super.getText(element);\r\n\t}","id":79229,"modified_method":"@Override\r\n\tpublic String getText(Object element) {\r\n\t\tif(element instanceof IStructuredSelection){\r\n\t\t\tIStructuredSelection selection = (IStructuredSelection) element;\r\n\t\t\tif(selection.size() > 1){\r\n\t\t\t\treturn super.getText(element);\r\n\t\t\t}\r\n\t\t\telement = selection.getFirstElement();\r\n\t\t}\r\n\t\tString title = getTitle(element);\r\n\t\tif(title != null){\r\n\t\t\treturn title;\r\n\t\t}\r\n\t\treturn super.getText(element);\r\n\t}","commit_id":"c7ad8e964d1462e0ab60d0aa6965124e285e3fb5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"String getTitle(IJavaElement pack){\r\n\t\tif(pack == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tStringBuilder sb = new StringBuilder(\"Class: \");\r\n\t\tsb.append(pack.getElementName());\r\n\t\treturn sb.toString();\r\n\t}","id":79230,"modified_method":"String getTitle(IJavaElement elem){\r\n\t\tif(elem == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tStringBuilder sb = new StringBuilder(\"Class: \");\r\n\t\tsb.append(elem.getElementName());\r\n\t\treturn sb.toString();\r\n\t}","commit_id":"c7ad8e964d1462e0ab60d0aa6965124e285e3fb5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static void getVariantsFromQualifier(GrReferenceExpression refExpr, ResolverProcessor processor, GrExpression qualifier) {\n    Project project = qualifier.getProject();\n    PsiType qualifierType = qualifier.getType();\n    if (qualifierType == null) {\n      if (qualifier instanceof GrReferenceExpression) {\n        PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n        if (resolved instanceof PsiPackage) {\n          resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr);\n          return;\n        }\n      }\n      final PsiClassType type = refExpr.getManager().getElementFactory().createTypeByFQClassName(GrTypeDefinition.DEFAULT_BASE_CLASS_NAME, refExpr.getResolveScope());\n      getVariantsFromQualifierType(refExpr, processor, type, project);\n    } else {\n      if (qualifierType instanceof PsiIntersectionType) {\n        for (PsiType conjunct : ((PsiIntersectionType) qualifierType).getConjuncts()) {\n          getVariantsFromQualifierType(refExpr, processor, conjunct, project);\n        }\n      } else {\n        getVariantsFromQualifierType(refExpr, processor, qualifierType, project);\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n          if (resolved instanceof PsiClass) { ////omitted .class\n            GlobalSearchScope scope = refExpr.getResolveScope();\n            PsiClass javaLangClass = PsiUtil.getJavaLangClass(resolved, scope);\n            if (javaLangClass != null) {\n              javaLangClass.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr);\n            }\n          }\n        }\n      }\n    }\n  }","id":79231,"modified_method":"private static void getVariantsFromQualifier(GrReferenceExpression refExpr, ResolverProcessor processor, GrExpression qualifier) {\n    Project project = qualifier.getProject();\n    PsiType qualifierType = qualifier.getType();\n    if (qualifierType == null) {\n      if (qualifier instanceof GrReferenceExpression) {\n        PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n        if (resolved instanceof PsiPackage) {\n          resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr);\n          return;\n        }\n      }\n      final PsiClassType type = refExpr.getManager().getElementFactory().createTypeByFQClassName(GrTypeDefinition.DEFAULT_BASE_CLASS_NAME, refExpr.getResolveScope());\n      getVariantsFromQualifierType(refExpr, processor, type, project);\n    } else {\n      if (qualifierType instanceof PsiIntersectionType) {\n        for (PsiType conjunct : ((PsiIntersectionType) qualifierType).getConjuncts()) {\n          getVariantsFromQualifierType(refExpr, processor, conjunct, project);\n        }\n      } else {\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n          if (resolved instanceof PsiClass) { ////omitted .class\n            GlobalSearchScope scope = refExpr.getResolveScope();\n            PsiClass javaLangClass = PsiUtil.getJavaLangClass(resolved, scope);\n            if (javaLangClass != null) {\n              PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n              PsiTypeParameter[] typeParameters = javaLangClass.getTypeParameters();\n              if (typeParameters.length == 1) {\n                substitutor = substitutor.put(typeParameters[0], qualifierType);\n              }\n              javaLangClass.processDeclarations(processor, substitutor, null, refExpr);\n              PsiType javaLangClassType = refExpr.getManager().getElementFactory().createType(javaLangClass, substitutor);\n              ResolveUtil.processNonCodeMethods(javaLangClassType, processor, refExpr.getProject());\n              return;\n            }\n          }\n        }\n        getVariantsFromQualifierType(refExpr, processor, qualifierType, project);\n      }\n    }\n  }","commit_id":"43b7bdb72342674e9cf8e94d00e41bba160abcbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processQualifier(GrReferenceExpressionImpl refExpr, ResolverProcessor processor, GrExpression qualifier) {\n      PsiType qualifierType = qualifier.getType();\n      if (qualifierType == null) {\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n          if (resolved instanceof PsiPackage) {\n            if (!resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr)) return;\n          }\n        }\n      } else {\n        if (qualifierType instanceof PsiIntersectionType) {\n          for (PsiType conjunct : ((PsiIntersectionType) qualifierType).getConjuncts()) {\n            processClassQualifierType(refExpr, processor, conjunct);\n          }\n        } else {\n          processClassQualifierType(refExpr, processor, qualifierType);\n          if (qualifier instanceof GrReferenceExpression) {\n            PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n            if (resolved instanceof PsiClass) { //omitted .class\n              PsiClass javaLangClass = PsiUtil.getJavaLangClass(resolved, refExpr.getResolveScope());\n              if (javaLangClass != null) {\n                PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n                PsiTypeParameter[] typeParameters = javaLangClass.getTypeParameters();\n                if (typeParameters.length == 1) {\n                  substitutor = substitutor.put(typeParameters[0], qualifierType);\n                }\n                javaLangClass.processDeclarations(processor, substitutor, null, refExpr);\n              }\n            }\n          }\n        }\n      }\n    }","id":79232,"modified_method":"private void processQualifier(GrReferenceExpressionImpl refExpr, ResolverProcessor processor, GrExpression qualifier) {\n      PsiType qualifierType = qualifier.getType();\n      if (qualifierType == null) {\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n          if (resolved instanceof PsiPackage) {\n            if (!resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr)) return;\n          }\n        }\n      } else {\n        if (qualifierType instanceof PsiIntersectionType) {\n          for (PsiType conjunct : ((PsiIntersectionType) qualifierType).getConjuncts()) {\n            processClassQualifierType(refExpr, processor, conjunct);\n          }\n        } else {\n          if (qualifier instanceof GrReferenceExpression) {\n            PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n            if (resolved instanceof PsiClass) { //omitted .class\n              PsiClass javaLangClass = PsiUtil.getJavaLangClass(resolved, refExpr.getResolveScope());\n              if (javaLangClass != null) {\n                PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n                PsiTypeParameter[] typeParameters = javaLangClass.getTypeParameters();\n                if (typeParameters.length == 1) {\n                  substitutor = substitutor.put(typeParameters[0], qualifierType);\n                }\n                if (!javaLangClass.processDeclarations(processor, substitutor, null, refExpr)) return;\n                PsiType javaLangClassType = refExpr.getManager().getElementFactory().createType(javaLangClass, substitutor);\n                ResolveUtil.processNonCodeMethods(javaLangClassType, processor, refExpr.getProject());\n                return;\n              }\n            }\n            processClassQualifierType(refExpr, processor, qualifierType);\n          }\n        }\n      }\n    }","commit_id":"43b7bdb72342674e9cf8e94d00e41bba160abcbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isStaticsOK(PsiModifierListOwner owner, PsiElement place) {\n    if (!owner.hasModifierProperty(PsiModifier.STATIC)) {\n      if (place instanceof GrReferenceExpression) {\n        GrExpression qualifier = ((GrReferenceExpression) place).getQualifierExpression();\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement qualifierResolved = ((GrReferenceExpression) qualifier).resolve();\n          if (qualifierResolved instanceof PsiClass) {\n\n            if (owner instanceof PsiMember) {\n              //members from java.lang.Class can be invoked without \".class\"\n              PsiClass javaLangClass = place.getManager().findClass(\"java.lang.Class\", place.getResolveScope());\n              if (javaLangClass != null) {\n                if (owner instanceof PsiMethod && javaLangClass.findMethodBySignature((PsiMethod) owner, true) != null) return true;\n                if (owner instanceof PsiField && javaLangClass.findFieldByName(((PsiField) owner).getName(), true) != null) return true;\n              }\n            }\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }","id":79233,"modified_method":"public static boolean isStaticsOK(PsiModifierListOwner owner, PsiElement place) {\n    if (!owner.hasModifierProperty(PsiModifier.STATIC)) {\n      if (place instanceof GrReferenceExpression) {\n        GrExpression qualifier = ((GrReferenceExpression) place).getQualifierExpression();\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement qualifierResolved = ((GrReferenceExpression) qualifier).resolve();\n          if (qualifierResolved instanceof PsiClass) {\n\n            if (owner instanceof PsiMember) {\n              //members from java.lang.Class can be invoked without \".class\"\n              PsiClass javaLangClass = place.getManager().findClass(\"java.lang.Class\", place.getResolveScope());\n              if (javaLangClass != null) {\n                PsiClass containingClass = ((PsiMember) owner).getContainingClass();\n                if (containingClass == null || //default groovy method\n                    InheritanceUtil.isInheritorOrSelf(javaLangClass, containingClass, true)) return true;\n              }\n            }\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"43b7bdb72342674e9cf8e94d00e41bba160abcbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JavaResolveResult advancedResolve(boolean incompleteCode) {\n\n    final PsiElement psiElement = getElement();\n\n    if (!psiElement.isValid()) return JavaResolveResult.EMPTY;\n\n    final String elementText = psiElement.getText();\n\n    final PsiElement context = getContext();\n    if (context instanceof PsiClass) {\n      if (isStaticClassReference(elementText)) {\n          final PsiClass psiClass = ((PsiClass)context).findInnerClassByName(getCanonicalText(), false);\n          if (psiClass != null) return new ClassCandidateInfo(psiClass, PsiSubstitutor.EMPTY, false, psiElement);\n          return JavaResolveResult.EMPTY;\n      } else if (!myInStaticImport && myJavaClassReferenceSet.isAllowDollarInNames() ) {\n        return JavaResolveResult.EMPTY;        \n      }\n    }\n\n    String qName = elementText.substring(myJavaClassReferenceSet.getReference(0).getRangeInElement().getStartOffset(), getRangeInElement().getEndOffset());\n\n    PsiManager manager = psiElement.getManager();\n    GlobalSearchScope scope = getScope();\n    if (myIndex == myJavaClassReferenceSet.getReferences().length - 1) {\n      final PsiClass aClass = manager.findClass(qName, scope);\n      if (aClass != null) {\n        return new ClassCandidateInfo(aClass, PsiSubstitutor.EMPTY, false, psiElement);\n      } else {\n        final Boolean value = JavaClassReferenceProvider.RESOLVE_ONLY_CLASSES.getValue(getOptions());\n        if (value != null && value.booleanValue()) {\n          return JavaResolveResult.EMPTY;\n        }\n      }\n    }\n    PsiElement resolveResult = manager.findPackage(qName);\n    if (resolveResult == null) {\n      resolveResult = manager.findClass(qName, scope);\n    }\n    if (myInStaticImport && resolveResult == null) {\n      resolveResult = resolveMember(qName, manager, getElement().getResolveScope());\n    }\n    if (resolveResult == null) {\n      PsiFile containingFile = psiElement.getContainingFile();\n\n      if (containingFile instanceof PsiJavaFile) {\n        if (containingFile instanceof JspFile) {\n          containingFile = containingFile.getViewProvider().getPsi(StdLanguages.JAVA);\n          if (containingFile == null) return JavaResolveResult.EMPTY;\n        }\n\n        final ClassResolverProcessor processor = new ClassResolverProcessor(getCanonicalText(), psiElement);\n        containingFile.processDeclarations(processor, PsiSubstitutor.EMPTY, null, psiElement);\n\n        if (processor.getResult().length == 1) {\n          final JavaResolveResult javaResolveResult = processor.getResult()[0];\n\n          if (javaResolveResult != JavaResolveResult.EMPTY && getOptions() != null) {\n            final Boolean value = JavaClassReferenceProvider.RESOLVE_QUALIFIED_CLASS_NAME.getValue(getOptions());\n            final PsiClass psiClass = (PsiClass)javaResolveResult.getElement();\n            if (value != null && value.booleanValue() && psiClass != null) {\n              final String qualifiedName = psiClass.getQualifiedName();\n\n              if (!qName.equals(qualifiedName)) {\n                return JavaResolveResult.EMPTY;\n              }\n            }\n          }\n\n          return javaResolveResult;\n        }\n      }\n    }\n    return resolveResult != null\n           ? new CandidateInfo(resolveResult, PsiSubstitutor.EMPTY, false, false, psiElement)\n           : JavaResolveResult.EMPTY;\n  }","id":79234,"modified_method":"@NotNull\n  public JavaResolveResult advancedResolve(boolean incompleteCode) {\n\n    final PsiElement psiElement = getElement();\n\n    if (!psiElement.isValid()) return JavaResolveResult.EMPTY;\n\n    final String elementText = psiElement.getText();\n\n    final PsiElement context = getContext();\n    if (context instanceof PsiClass) {\n      if (isStaticClassReference(elementText)) {\n          final PsiClass psiClass = ((PsiClass)context).findInnerClassByName(getCanonicalText(), false);\n          if (psiClass != null) return new ClassCandidateInfo(psiClass, PsiSubstitutor.EMPTY, false, psiElement);\n          return JavaResolveResult.EMPTY;\n      } else if (!myInStaticImport && myJavaClassReferenceSet.isAllowDollarInNames() ) {\n        return JavaResolveResult.EMPTY;        \n      }\n    }\n\n    String qName = elementText.substring(myJavaClassReferenceSet.getReference(0).getRangeInElement().getStartOffset(), getRangeInElement().getEndOffset());\n    if (qName.indexOf(\".\") == -1) {\n      final String defaultPackage = JavaClassReferenceProvider.DEFAULT_PACKAGE.getValue(myOptions);\n      if (StringUtil.isNotEmpty(defaultPackage)) {\n        final JavaResolveResult resolveResult = advancedResolveInner(psiElement, defaultPackage + \".\" + qName);\n        if (resolveResult != JavaResolveResult.EMPTY) {\n          return resolveResult;\n        }\n      }\n    }\n    return advancedResolveInner(psiElement, qName);\n  }","commit_id":"2fd1970b6a24e9415fca0f6e180cc616570f64ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected List<PsiElement> getDefaultPackages(PsiElement position) {\n    List<PsiElement> cachedPackages = myDefaultPackageContent.get();\n    if (cachedPackages == null) {\n      final List<PsiElement> psiPackages = new ArrayList<PsiElement>();\n      final PsiManager manager = position.getManager();\n      final PsiPackage rootPackage = manager.findPackage(\"\");\n      if (rootPackage != null) {\n        rootPackage.processDeclarations(new BaseScopeProcessor() {\n          public boolean execute(PsiElement element, PsiSubstitutor substitutor) {\n            psiPackages.add(element);\n            return true;\n          }\n        }, PsiSubstitutor.EMPTY, position, position);\n      }\n      if (myPackagesEraser == null) {\n        myPackagesEraser = new Runnable() {\n          public void run() {\n            myDefaultPackageContent = NULL_REFERENCE;\n          }\n        };\n      }\n      cachedPackages = psiPackages;\n      ((PsiManagerEx)manager).registerWeakRunnableToRunOnChange(myPackagesEraser);\n      myDefaultPackageContent = new SoftReference<List<PsiElement>>(cachedPackages);\n    }\n    return cachedPackages;\n  }","id":79235,"modified_method":"protected List<PsiElement> getDefaultPackages(PsiElement position) {\n    List<PsiElement> cachedPackages = myDefaultPackageContent.get();\n    if (cachedPackages == null) {\n      final List<PsiElement> psiPackages = new ArrayList<PsiElement>();\n      final PsiManager manager = position.getManager();\n      final BaseScopeProcessor processor = new BaseScopeProcessor() {\n        public boolean execute(PsiElement element, PsiSubstitutor substitutor) {\n          psiPackages.add(element);\n          return true;\n        }\n      };\n      final String defPackageName = DEFAULT_PACKAGE.getValue(myOptions);\n      if (StringUtil.isNotEmpty(defPackageName)) {\n        final PsiPackage defaultPackage = manager.findPackage(defPackageName);\n        if (defaultPackage != null) {\n          defaultPackage.processDeclarations(processor, PsiSubstitutor.EMPTY, position, position);\n        }\n      }\n      final PsiPackage rootPackage = manager.findPackage(\"\");\n      if (rootPackage != null) {\n        rootPackage.processDeclarations(processor, PsiSubstitutor.EMPTY, position, position);\n      }\n      if (myPackagesEraser == null) {\n        myPackagesEraser = new Runnable() {\n          public void run() {\n            myDefaultPackageContent = NULL_REFERENCE;\n          }\n        };\n      }\n      cachedPackages = psiPackages;\n      ((PsiManagerEx)manager).registerWeakRunnableToRunOnChange(myPackagesEraser);\n      myDefaultPackageContent = new SoftReference<List<PsiElement>>(cachedPackages);\n    }\n    return cachedPackages;\n  }","commit_id":"2fd1970b6a24e9415fca0f6e180cc616570f64ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processQualifier(GrReferenceExpressionImpl refExpr, ResolverProcessor processor, GrExpression qualifier) {\n      PsiType qualifierType = qualifier.getType();\n      if (qualifierType == null) {\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n          if (resolved instanceof PsiPackage) {\n            if (!resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr)) return;\n          }\n        }\n      } else {\n        if (qualifierType instanceof PsiIntersectionType) {\n          for (PsiType conjunct : ((PsiIntersectionType) qualifierType).getConjuncts()) {\n            processClassQualifierType(refExpr, processor, conjunct);\n          }\n        } else {\n          processClassQualifierType(refExpr, processor, qualifierType);\n          if (qualifier instanceof GrReferenceExpression) {\n            PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n            if (resolved instanceof PsiClass) { //omitted .class\n              PsiClass javaLangClass = PsiUtil.getJavaLangClass(resolved, refExpr.getResolveScope());\n              if (javaLangClass != null) {\n                javaLangClass.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr);\n              }\n            }\n          }\n        }\n      }\n    }","id":79236,"modified_method":"private void processQualifier(GrReferenceExpressionImpl refExpr, ResolverProcessor processor, GrExpression qualifier) {\n      PsiType qualifierType = qualifier.getType();\n      if (qualifierType == null) {\n        if (qualifier instanceof GrReferenceExpression) {\n          PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n          if (resolved instanceof PsiPackage) {\n            if (!resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, null, refExpr)) return;\n          }\n        }\n      } else {\n        if (qualifierType instanceof PsiIntersectionType) {\n          for (PsiType conjunct : ((PsiIntersectionType) qualifierType).getConjuncts()) {\n            processClassQualifierType(refExpr, processor, conjunct);\n          }\n        } else {\n          processClassQualifierType(refExpr, processor, qualifierType);\n          if (qualifier instanceof GrReferenceExpression) {\n            PsiElement resolved = ((GrReferenceExpression) qualifier).resolve();\n            if (resolved instanceof PsiClass) { //omitted .class\n              PsiClass javaLangClass = PsiUtil.getJavaLangClass(resolved, refExpr.getResolveScope());\n              if (javaLangClass != null) {\n                PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n                PsiTypeParameter[] typeParameters = javaLangClass.getTypeParameters();\n                if (typeParameters.length == 1) {\n                  substitutor = substitutor.put(typeParameters[0], qualifierType);\n                }\n                javaLangClass.processDeclarations(processor, substitutor, null, refExpr);\n              }\n            }\n          }\n        }\n      }\n    }","commit_id":"33223f0d1f87b6d3883085d62da02b6f8c80f432","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static CredentialsProvider createCredentialsProvider(@NotNull GithubAuthData auth) {\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    // Basic authentication\n    GithubAuthData.BasicAuth basicAuth = auth.getBasicAuth();\n    if (basicAuth != null) {\n      provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(basicAuth.getLogin(), basicAuth.getPassword()));\n    }\n\n    if (auth.isUseProxy()) {\n      HttpConfigurable.getInstance().setProxyCredentials(provider);\n    }\n\n    return provider;\n  }","id":79237,"modified_method":"@NotNull\n  private static CredentialsProvider createCredentialsProvider(@NotNull GithubAuthData auth) {\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    // Basic authentication\n    GithubAuthData.BasicAuth basicAuth = auth.getBasicAuth();\n    if (basicAuth != null) {\n      provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(basicAuth.getLogin(), basicAuth.getPassword()));\n    }\n\n    if (auth.isUseProxy()) {\n      HttpConfigurable.getInstance().setProxyCredentialsIfEnabled(provider, auth.getHost());\n    }\n\n    return provider;\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static RequestConfig createRequestConfig(@NotNull GithubAuthData auth) {\n    RequestConfig.Builder builder = RequestConfig.custom();\n\n    int timeout = GithubSettings.getInstance().getConnectionTimeout();\n    builder\n      .setConnectTimeout(timeout)\n      .setSocketTimeout(timeout);\n\n    if (auth.isUseProxy()) {\n      HttpConfigurable.getInstance().setProxy(builder);\n    }\n\n    return builder.build();\n  }","id":79238,"modified_method":"@NotNull\n  private static RequestConfig createRequestConfig(@NotNull GithubAuthData auth) {\n    RequestConfig.Builder builder = RequestConfig.custom();\n\n    int timeout = GithubSettings.getInstance().getConnectionTimeout();\n    builder\n      .setConnectTimeout(timeout)\n      .setSocketTimeout(timeout);\n\n    if (auth.isUseProxy()) {\n      HttpConfigurable.getInstance().setProxyIfEnabled(builder, auth.getHost());\n    }\n\n    return builder.build();\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public CredentialsProvider setProxyCredentials(@NotNull CredentialsProvider provider, boolean useProxy) {\n    if (useProxy && PROXY_AUTHENTICATION) {\n      String ntlmUserPassword = PROXY_LOGIN.replace('\\\\', '/') + \":\" + getPlainProxyPassword();\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT, AuthScope.ANY_REALM, AuthSchemes.NTLM), new NTCredentials(ntlmUserPassword));\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT), new UsernamePasswordCredentials(PROXY_LOGIN, getPlainProxyPassword()));\n    }\n\n    return provider;\n  }","id":79239,"modified_method":"@NotNull\n  public CredentialsProvider setProxyCredentials(@NotNull CredentialsProvider provider, boolean useProxy) {\n    if (useProxy) setProxyCredentials(provider);\n    return provider;\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public RequestConfig.Builder setProxy(@NotNull RequestConfig.Builder builder) {\n    return setProxy(builder, USE_HTTP_PROXY);\n  }","id":79240,"modified_method":"@NotNull\n  public RequestConfig.Builder setProxy(@NotNull RequestConfig.Builder builder) {\n    if (USE_HTTP_PROXY) {\n      builder.setProxy(new HttpHost(PROXY_HOST, PROXY_PORT));\n    }\n    return builder;\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public CredentialsProvider setProxyCredentials(@NotNull CredentialsProvider provider) {\n    return setProxyCredentials(provider, USE_HTTP_PROXY);\n  }","id":79241,"modified_method":"@NotNull\n  public CredentialsProvider setProxyCredentials(@NotNull CredentialsProvider provider) {\n    if (USE_HTTP_PROXY && PROXY_AUTHENTICATION) {\n      String ntlmUserPassword = PROXY_LOGIN.replace('\\\\', '/') + \":\" + getPlainProxyPassword();\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT, AuthScope.ANY_REALM, AuthSchemes.NTLM), new NTCredentials(ntlmUserPassword));\n      provider.setCredentials(new AuthScope(PROXY_HOST, PROXY_PORT), new UsernamePasswordCredentials(PROXY_LOGIN, getPlainProxyPassword()));\n    }\n    return provider;\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public RequestConfig.Builder setProxy(@NotNull RequestConfig.Builder builder, boolean useProxy) {\n    if (useProxy) {\n      builder.setProxy(new HttpHost(PROXY_HOST, PROXY_PORT));\n    }\n\n    return builder;\n  }","id":79242,"modified_method":"@NotNull\n  public RequestConfig.Builder setProxy(@NotNull RequestConfig.Builder builder, boolean useProxy) {\n    if (useProxy) setProxy(builder);\n    return builder;\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private CredentialsProvider createCredentialsProvider() {\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    // Basic authentication\n    if (isUseHttpAuthentication()) {\n      provider.setCredentials(BASIC_AUTH_SCOPE, new UsernamePasswordCredentials(getUsername(), getPassword()));\n    }\n    // Proxy authentication\n    HttpConfigurable.getInstance().setProxyCredentials(provider, isUseProxy());\n\n    return provider;\n  }","id":79243,"modified_method":"@NotNull\n  private CredentialsProvider createCredentialsProvider() {\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    // Basic authentication\n    if (isUseHttpAuthentication()) {\n      provider.setCredentials(BASIC_AUTH_SCOPE, new UsernamePasswordCredentials(getUsername(), getPassword()));\n    }\n    // Proxy authentication\n    if (isUseProxy()) HttpConfigurable.getInstance().setProxyCredentialsIfEnabled(provider, getUrl());\n\n    return provider;\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected RequestConfig createRequestConfig() {\n    TaskSettings tasksSettings = TaskSettings.getInstance();\n    RequestConfig.Builder builder = RequestConfig.custom()\n      .setConnectTimeout(3000)\n      .setSocketTimeout(tasksSettings.CONNECTION_TIMEOUT);\n    HttpConfigurable.getInstance().setProxy(builder, isUseProxy());\n\n    return builder.build();\n  }","id":79244,"modified_method":"@NotNull\n  protected RequestConfig createRequestConfig() {\n    TaskSettings tasksSettings = TaskSettings.getInstance();\n    RequestConfig.Builder builder = RequestConfig.custom()\n      .setConnectTimeout(3000)\n      .setSocketTimeout(tasksSettings.CONNECTION_TIMEOUT);\n    if (isUseProxy()) HttpConfigurable.getInstance().setProxyIfEnabled(builder, getUrl());\n\n    return builder.build();\n  }","commit_id":"7c8377934c3c433b75ef79c7bc28dddb8cc4b21c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static RequestConfig createRequestConfig(@NotNull GithubAuthData auth) {\n    RequestConfig.Builder builder = RequestConfig.custom();\n\n    int timeout = GithubSettings.getInstance().getConnectionTimeout();\n    builder\n      .setConnectTimeout(timeout)\n      .setSocketTimeout(timeout);\n\n    final HttpConfigurable proxySettings = HttpConfigurable.getInstance();\n    boolean useProxy = auth.isUseProxy() && proxySettings.USE_HTTP_PROXY;\n\n    proxySettings.setProxy(builder, useProxy);\n\n    return builder.build();\n  }","id":79245,"modified_method":"@NotNull\n  private static RequestConfig createRequestConfig(@NotNull GithubAuthData auth) {\n    RequestConfig.Builder builder = RequestConfig.custom();\n\n    int timeout = GithubSettings.getInstance().getConnectionTimeout();\n    builder\n      .setConnectTimeout(timeout)\n      .setSocketTimeout(timeout);\n\n    if (auth.isUseProxy()) {\n      HttpConfigurable.getInstance().setProxy(builder);\n    }\n\n    return builder.build();\n  }","commit_id":"c33f57957c7dfac14828c8728670c9e2dbd79396","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static CredentialsProvider createCredentialsProvider(@NotNull GithubAuthData auth) {\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    // Basic authentication\n    GithubAuthData.BasicAuth basicAuth = auth.getBasicAuth();\n    if (basicAuth != null) {\n      provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(basicAuth.getLogin(), basicAuth.getPassword()));\n    }\n\n    final HttpConfigurable proxySettings = HttpConfigurable.getInstance();\n    //proxySettings.USE_HTTP_PROXY\n    boolean useProxy = auth.isUseProxy() && proxySettings.USE_HTTP_PROXY;\n\n    proxySettings.setProxyCredentials(provider, useProxy);\n\n    return provider;\n  }","id":79246,"modified_method":"@NotNull\n  private static CredentialsProvider createCredentialsProvider(@NotNull GithubAuthData auth) {\n    CredentialsProvider provider = new BasicCredentialsProvider();\n    // Basic authentication\n    GithubAuthData.BasicAuth basicAuth = auth.getBasicAuth();\n    if (basicAuth != null) {\n      provider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(basicAuth.getLogin(), basicAuth.getPassword()));\n    }\n\n    if (auth.isUseProxy()) {\n      HttpConfigurable.getInstance().setProxyCredentials(provider);\n    }\n\n    return provider;\n  }","commit_id":"c33f57957c7dfac14828c8728670c9e2dbd79396","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSendViaGET() throws Exception\n    {\n        Latch latch = new Latch();\n        setupAssertIncomingMessage(HttpConstants.METHOD_GET, latch);\n        \n        String testMessage = getTestMessage(Locale.JAPAN);\n        String encodedPayload = URLEncoder.encode(testMessage, \"ISO-2022-JP\");\n        String url = String.format(\"http://localhost:%1d/get?%2s=%3s\",\n            getPorts().get(0), HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY, encodedPayload);\n        \n        GetMethod method = new GetMethod(url);\n        method.addRequestHeader(HttpConstants.HEADER_CONTENT_TYPE, CONTENT_TYPE_HEADER);\n        int status = new HttpClient().executeMethod(method);\n        assertEquals(HttpConstants.SC_OK, status);\n        \n        assertTrue(latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS));\n        String expected = testMessage + \" Received\";\n        String response = method.getResponseBodyAsString();\n        assertEquals(expected, response);\n        \n        Header responseContentType = method.getResponseHeader(HttpConstants.HEADER_CONTENT_TYPE);\n        assertEquals(\"text/plain;charset=EUC-JP\", responseContentType.getValue());\n    }","id":79247,"modified_method":"public void testSendViaGET() throws Exception\n    {\n        Latch latch = new Latch();\n        setupAssertIncomingMessage(HttpConstants.METHOD_GET, latch, PLAIN_CONTENT_TYPE_HEADER);\n\n        String testMessage = getTestMessage(Locale.JAPAN);\n        String encodedPayload = URLEncoder.encode(testMessage, \"ISO-2022-JP\");\n        String url = String.format(\"http://localhost:%1d/get?%2s=%3s\",\n            getPorts().get(0), HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY, encodedPayload);\n\n        GetMethod method = new GetMethod(url);\n        method.addRequestHeader(HttpConstants.HEADER_CONTENT_TYPE, PLAIN_CONTENT_TYPE_HEADER);\n        int status = new HttpClient().executeMethod(method);\n        assertEquals(HttpConstants.SC_OK, status);\n\n        assertTrue(latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS));\n        String expected = testMessage + \" Received\";\n        String response = method.getResponseBodyAsString();\n        assertEquals(expected, response);\n\n        Header responseContentType = method.getResponseHeader(HttpConstants.HEADER_CONTENT_TYPE);\n        assertEquals(\"text/plain;charset=EUC-JP\", responseContentType.getValue());\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"private void setupAssertIncomingMessage(String method, final Latch latch) throws Exception\n    {\n        FunctionalTestComponent ftc = getFunctionalTestComponent(\"testReceive\" + method);\n        ftc.setEventCallback(new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object serviceComponent) throws Exception\n            {\n                MuleMessage message = context.getMessage();\n\n                Assert.assertEquals(CONTENT_TYPE_HEADER,\n                    message.getInboundProperty(HttpConstants.HEADER_CONTENT_TYPE, null));\n                Assert.assertEquals(\"ISO-2022-JP\", message.getEncoding());\n\n                Object payload = message.getPayload();\n                if (payload instanceof String)\n                {\n                    assertEquals(getTestMessage(Locale.JAPAN), payload);\n                }\n                else\n                {\n                    fail();\n                }\n\n                latch.countDown();\n            }\n        });\n    }","id":79248,"modified_method":"private void setupAssertIncomingMessage(String method, final Latch latch,\n        final String expectedContentTypeHeader) throws Exception\n    {\n        FunctionalTestComponent ftc = getFunctionalTestComponent(\"testReceive\" + method);\n        ftc.setEventCallback(new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object serviceComponent) throws Exception\n            {\n                MuleMessage message = context.getMessage();\n\n                Assert.assertEquals(expectedContentTypeHeader,\n                    message.getInboundProperty(HttpConstants.HEADER_CONTENT_TYPE, null));\n                Assert.assertEquals(\"ISO-2022-JP\", message.getEncoding());\n\n                Object payload = message.getPayload();\n                if (payload instanceof String)\n                {\n                    assertEquals(getTestMessage(Locale.JAPAN), payload);\n                }\n                else\n                {\n                    fail();\n                }\n\n                latch.countDown();\n            }\n        });\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSendViaPOST() throws Exception\n    {\n        Object payload = getTestMessage(Locale.JAPAN);\n        \n        Map<String, Object> messageProperties = new HashMap<String, Object>();\n        messageProperties.put(MuleProperties.MULE_ENCODING_PROPERTY, \"ISO-2022-JP\");\n        \n        doTestSend(HttpConstants.METHOD_POST, payload, messageProperties);\n    }","id":79249,"modified_method":"public void testSendViaPOST() throws Exception\n    {\n        Object payload = getTestMessage(Locale.JAPAN);\n\n        Map<String, Object> messageProperties = new HashMap<String, Object>();\n        messageProperties.put(MuleProperties.MULE_ENCODING_PROPERTY, \"ISO-2022-JP\");\n\n        doTestSend(HttpConstants.METHOD_POST, payload, messageProperties, PLAIN_CONTENT_TYPE_HEADER);\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"private void doTestSend(String method, Object messagePayload, Map<String, Object> messageProperties) throws Exception\n    {\n        Latch latch = new Latch();\n\n        setupAssertIncomingMessage(method, latch);\n\n        MuleClient client = new MuleClient(muleContext);\n        MuleMessage reply = client.send(\"vm://sendBy\" + method, messagePayload, messageProperties);\n\n        assertTrue(latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS));\n        assertNotNull(reply);\n        assertEquals(CONTENT_TYPE_HEADER, reply.getInvocationProperty(HttpConstants.HEADER_CONTENT_TYPE));\n        assertEquals(\"EUC-JP\", reply.getEncoding());\n        assertEquals(getTestMessage(Locale.JAPAN) + \" Received\", reply.getPayloadAsString());\n    }","id":79250,"modified_method":"private void doTestSend(String method, Object messagePayload, Map<String, Object> messageProperties,\n        String expectedContentTypeHeader) throws Exception\n    {\n        Latch latch = new Latch();\n\n        setupAssertIncomingMessage(method, latch, expectedContentTypeHeader);\n\n        MuleClient client = new MuleClient(muleContext);\n        MuleMessage reply = client.send(\"vm://sendBy\" + method, messagePayload, messageProperties);\n\n        assertTrue(latch.await(RECEIVE_TIMEOUT, TimeUnit.MILLISECONDS));\n        assertNotNull(reply);\n        assertEquals(expectedContentTypeHeader, reply.getInvocationProperty(HttpConstants.HEADER_CONTENT_TYPE));\n        assertEquals(\"EUC-JP\", reply.getEncoding());\n        assertEquals(getTestMessage(Locale.JAPAN) + \" Received\", reply.getPayloadAsString());\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addQueryStringToParameterMap(String queryString, Map<String, Object> paramMap,\n        String outputEncoding) throws UnsupportedEncodingException\n    {\n        String[] pairs = queryString.split(\"&\");\n        for (String pair : pairs)\n        {\n            String[] nameValue = pair.split(\"=\");\n            if (nameValue.length == 2)\n            {\n                String key = URLDecoder.decode(nameValue[0], outputEncoding);\n                String value = URLDecoder.decode(nameValue[1], outputEncoding);\n                addToParameterMap(paramMap, key, value);\n            }\n        }\n    }","id":79251,"modified_method":"protected void addQueryStringToParameterMap(String queryString, Map<String, Object> paramMap,\n        String outputEncoding) throws Exception\n    {\n        String[] pairs = queryString.split(\"&\");\n        for (String pair : pairs)\n        {\n            String[] nameValue = pair.split(\"=\");\n            if (nameValue.length == 2)\n            {\n                URLCodec codec = new URLCodec(outputEncoding);\n                String key = codec.decode(nameValue[0]);\n                String value = codec.decode(nameValue[1]);\n                addToParameterMap(paramMap, key, value);\n            }\n        }\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Object transformMessage(MuleMessage msg, String outputEncoding) throws TransformerException\n    {\n        String method = detectHttpMethod(msg);\n        try\n        {\n            // TODO It makes testing much harder if we use the endpoint on the\n            // transformer since we need to create correct message types and\n            // endpoints\n            // URI uri = getEndpoint().getEndpointURI().getUri();\n            final URI uri = getURI(msg);\n            HttpMethod httpMethod;\n\n            if (HttpConstants.METHOD_GET.equals(method))\n            {\n                httpMethod = createGetMethod(msg, outputEncoding);\n            }\n            else if (HttpConstants.METHOD_POST.equalsIgnoreCase(method))\n            {\n                httpMethod = createPostMethod(msg, outputEncoding);\n            }\n            else if (HttpConstants.METHOD_PUT.equalsIgnoreCase(method))\n            {\n                final PutMethod putMethod = new PutMethod(uri.toString());\n\n                Object payload = msg.getPayload();\n                setupEntityMethod(payload, outputEncoding, msg, putMethod);\n\n                httpMethod = putMethod;\n            }\n            else if (HttpConstants.METHOD_DELETE.equalsIgnoreCase(method))\n            {\n                httpMethod = new DeleteMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_HEAD.equalsIgnoreCase(method))\n            {\n                httpMethod = new HeadMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_OPTIONS.equalsIgnoreCase(method))\n            {\n                httpMethod = new OptionsMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_TRACE.equalsIgnoreCase(method))\n            {\n                httpMethod = new TraceMethod(uri.toString());\n            }\n            else\n            {\n                throw new TransformerException(HttpMessages.unsupportedMethod(method));\n            }\n\n            // Allow the user to set HttpMethodParams as an object on the message\n            final HttpMethodParams params = (HttpMethodParams) msg.removeProperty(\n                HttpConnector.HTTP_PARAMS_PROPERTY, PropertyScope.OUTBOUND);\n            if (params != null)\n            {\n                httpMethod.setParams(params);\n            }\n            else\n            {\n                // TODO we should probably set other properties here\n                final String httpVersion = msg.getOutboundProperty(HttpConnector.HTTP_VERSION_PROPERTY,\n                    HttpConstants.HTTP11);\n                if (HttpConstants.HTTP10.equals(httpVersion))\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_0);\n                }\n                else\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_1);\n                }\n            }\n\n            setHeaders(httpMethod, msg);\n\n            return httpMethod;\n        }\n        catch (final Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","id":79252,"modified_method":"@Override\n    public Object transformMessage(MuleMessage msg, String outputEncoding) throws TransformerException\n    {\n        String method = detectHttpMethod(msg);\n        try\n        {\n            HttpMethod httpMethod;\n\n            if (HttpConstants.METHOD_GET.equals(method))\n            {\n                httpMethod = createGetMethod(msg, outputEncoding);\n            }\n            else if (HttpConstants.METHOD_POST.equalsIgnoreCase(method))\n            {\n                httpMethod = createPostMethod(msg, outputEncoding);\n            }\n            else if (HttpConstants.METHOD_PUT.equalsIgnoreCase(method))\n            {\n                httpMethod = createPutMethod(msg, outputEncoding);\n            }\n            else if (HttpConstants.METHOD_DELETE.equalsIgnoreCase(method))\n            {\n                httpMethod = createDeleteMethod(msg);\n            }\n            else if (HttpConstants.METHOD_HEAD.equalsIgnoreCase(method))\n            {\n                httpMethod = createHeadMethod(msg);\n            }\n            else if (HttpConstants.METHOD_OPTIONS.equalsIgnoreCase(method))\n            {\n                httpMethod = createOptionsMethod(msg);\n            }\n            else if (HttpConstants.METHOD_TRACE.equalsIgnoreCase(method))\n            {\n                httpMethod = createTraceMethod(msg);\n            }\n            else\n            {\n                throw new TransformerException(HttpMessages.unsupportedMethod(method));\n            }\n\n            // Allow the user to set HttpMethodParams as an object on the message\n            final HttpMethodParams params = (HttpMethodParams) msg.removeProperty(\n                HttpConnector.HTTP_PARAMS_PROPERTY, PropertyScope.OUTBOUND);\n            if (params != null)\n            {\n                httpMethod.setParams(params);\n            }\n            else\n            {\n                // TODO we should probably set other properties here\n                final String httpVersion = msg.getOutboundProperty(HttpConnector.HTTP_VERSION_PROPERTY,\n                    HttpConstants.HTTP11);\n                if (HttpConstants.HTTP10.equals(httpVersion))\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_0);\n                }\n                else\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_1);\n                }\n            }\n\n            setHeaders(httpMethod, msg);\n\n            return httpMethod;\n        }\n        catch (final Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected HttpMethod createPostMethod(MuleMessage msg, String outputEncoding) throws Exception\n    {\n        final Object src = msg.getPayload();\n        // TODO It makes testing much harder if we use the endpoint on the\n        // transformer since we need to create correct message types and endpoints\n        // URI uri = getEndpoint().getEndpointURI().getUri();\n        final URI uri = getURI(msg);\n        final PostMethod postMethod = new PostMethod(uri.toString());\n        String paramName = msg.getOutboundProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, null);\n        if (paramName == null)\n        {\n            paramName = msg.getInvocationProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY);\n        }\n\n        if (src instanceof Map)\n        {\n            for (final Iterator iterator = ((Map) src).entrySet().iterator(); iterator.hasNext();)\n            {\n                final Map.Entry entry = (Map.Entry) iterator.next();\n                postMethod.addParameter(entry.getKey().toString(), entry.getValue().toString());\n            }\n        }\n        else if (paramName != null)\n        {\n            postMethod.addParameter(paramName, src.toString());\n\n        }\n        else\n        {\n            setupEntityMethod(src, outputEncoding, msg, postMethod);\n        }\n\n        return postMethod;\n    }","id":79253,"modified_method":"protected HttpMethod createPostMethod(MuleMessage msg, String outputEncoding) throws Exception\n    {\n        URI uri = getURI(msg);\n        PostMethod postMethod = new PostMethod(uri.toString());\n\n        String bodyParameterName = getBodyParameterName(msg);\n        Object src = msg.getPayload();\n        if (src instanceof Map)\n        {\n            for (Map.Entry<?, ?> entry : ((Map<?, ?>) src).entrySet())\n            {\n                postMethod.addParameter(entry.getKey().toString(), entry.getValue().toString());\n            }\n        }\n        else if (bodyParameterName != null)\n        {\n            postMethod.addParameter(bodyParameterName, src.toString());\n\n        }\n        else\n        {\n            setupEntityMethod(src, outputEncoding, msg, postMethod);\n        }\n\n        // if a content type was specified on the endpoint, use it\n        String outgoingContentType = msg.getInvocationProperty(HttpConstants.HEADER_CONTENT_TYPE);\n        if (outgoingContentType != null)\n        {\n            postMethod.setRequestHeader(HttpConstants.HEADER_CONTENT_TYPE, outgoingContentType);\n        }\n\n        return postMethod;\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void setupEntityMethod(Object src,\n                                     String encoding,\n                                     MuleMessage msg,\n                                     EntityEnclosingMethod postMethod)\n        throws UnsupportedEncodingException, TransformerException\n    {\n        // Dont set a POST payload if the body is a Null Payload.\n        // This way client calls\n        // can control if a POST body is posted explicitly\n        if (!(msg.getPayload() instanceof NullPayload))\n        {\n            String mimeType = (String) msg.getProperty(HttpConstants.HEADER_CONTENT_TYPE,\n                PropertyScope.OUTBOUND);\n            if (mimeType == null)\n            {\n                mimeType = (getEndpoint() != null ? getEndpoint().getMimeType() : null);\n            }\n            if (mimeType == null)\n            {\n                mimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n                logger.info(\"Content-Type not set on outgoing request, defaulting to: \" + mimeType);\n            }\n\n            if (encoding != null && !\"UTF-8\".equals(encoding.toUpperCase())\n                && mimeType.indexOf(\"charset\") == -1)\n            {\n                mimeType += \"; charset=\" + encoding;\n            }\n\n            // Ensure that we have a cached representation of the message if we're\n            // using HTTP 1.0\n            final String httpVersion = msg.getOutboundProperty(HttpConnector.HTTP_VERSION_PROPERTY,\n                HttpConstants.HTTP11);\n            if (HttpConstants.HTTP10.equals(httpVersion))\n            {\n                try\n                {\n                    src = msg.getPayloadAsBytes();\n                }\n                catch (final Exception e)\n                {\n                    throw new TransformerException(this, e);\n                }\n            }\n\n            if (msg.getOutboundAttachmentNames() != null && msg.getOutboundAttachmentNames().size() > 0)\n            {\n                try\n                {\n                    postMethod.setRequestEntity(createMultiPart(msg, postMethod));\n                    return;\n                }\n                catch (final Exception e)\n                {\n                    throw new TransformerException(this, e);\n                }\n            }\n            if (src instanceof String)\n            {\n\n                postMethod.setRequestEntity(new StringRequestEntity(src.toString(), mimeType, encoding));\n                return;\n            }\n\n            if (src instanceof InputStream)\n            {\n                postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream) src, mimeType));\n            }\n            else if (src instanceof byte[])\n            {\n                postMethod.setRequestEntity(new ByteArrayRequestEntity((byte[]) src, mimeType));\n            }\n            else if (src instanceof OutputHandler)\n            {\n                final MuleEvent event = RequestContext.getEvent();\n                postMethod.setRequestEntity(new StreamPayloadRequestEntity((OutputHandler) src, event));\n            }\n            else\n            {\n                final byte[] buffer = SerializationUtils.serialize((Serializable) src);\n                postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer, mimeType));\n            }\n        }\n        else if (msg.getOutboundAttachmentNames() != null && msg.getOutboundAttachmentNames().size() > 0)\n        {\n            try\n            {\n                postMethod.setRequestEntity(createMultiPart(msg, postMethod));\n            }\n            catch (final Exception e)\n            {\n                throw new TransformerException(this, e);\n            }\n        }\n    }","id":79254,"modified_method":"protected void setupEntityMethod(Object src, String encoding, MuleMessage msg,\n        EntityEnclosingMethod postMethod) throws UnsupportedEncodingException, TransformerException\n    {\n        // Dont set a POST payload if the body is a Null Payload.\n        // This way client calls can control if a POST body is posted explicitly\n        if (!(msg.getPayload() instanceof NullPayload))\n        {\n            String outboundMimeType = (String) msg.getProperty(HttpConstants.HEADER_CONTENT_TYPE,\n                PropertyScope.OUTBOUND);\n            if (outboundMimeType == null)\n            {\n                outboundMimeType = (getEndpoint() != null ? getEndpoint().getMimeType() : null);\n            }\n            if (outboundMimeType == null)\n            {\n                logger.info(\"Content-Type not set on outgoing request, defaulting to: \" + outboundMimeType);\n                outboundMimeType = HttpConstants.DEFAULT_CONTENT_TYPE;\n            }\n\n            if (encoding != null && !\"UTF-8\".equals(encoding.toUpperCase())\n                && outboundMimeType.indexOf(\"charset\") == -1)\n            {\n                outboundMimeType += \"; charset=\" + encoding;\n            }\n\n            // Ensure that we have a cached representation of the message if we're\n            // using HTTP 1.0\n            final String httpVersion = msg.getOutboundProperty(HttpConnector.HTTP_VERSION_PROPERTY,\n                HttpConstants.HTTP11);\n            if (HttpConstants.HTTP10.equals(httpVersion))\n            {\n                try\n                {\n                    src = msg.getPayloadAsBytes();\n                }\n                catch (final Exception e)\n                {\n                    throw new TransformerException(this, e);\n                }\n            }\n\n            if (msg.getOutboundAttachmentNames() != null && msg.getOutboundAttachmentNames().size() > 0)\n            {\n                try\n                {\n                    postMethod.setRequestEntity(createMultiPart(msg, postMethod));\n                    return;\n                }\n                catch (final Exception e)\n                {\n                    throw new TransformerException(this, e);\n                }\n            }\n            if (src instanceof String)\n            {\n                postMethod.setRequestEntity(new StringRequestEntity(src.toString(), outboundMimeType, encoding));\n                return;\n            }\n\n            if (src instanceof InputStream)\n            {\n                postMethod.setRequestEntity(new InputStreamRequestEntity((InputStream) src, outboundMimeType));\n            }\n            else if (src instanceof byte[])\n            {\n                postMethod.setRequestEntity(new ByteArrayRequestEntity((byte[]) src, outboundMimeType));\n            }\n            else if (src instanceof OutputHandler)\n            {\n                final MuleEvent event = RequestContext.getEvent();\n                postMethod.setRequestEntity(new StreamPayloadRequestEntity((OutputHandler) src, event));\n            }\n            else\n            {\n                final byte[] buffer = SerializationUtils.serialize((Serializable) src);\n                postMethod.setRequestEntity(new ByteArrayRequestEntity(buffer, outboundMimeType));\n            }\n        }\n        else if (msg.getOutboundAttachmentNames() != null && msg.getOutboundAttachmentNames().size() > 0)\n        {\n            try\n            {\n                postMethod.setRequestEntity(createMultiPart(msg, postMethod));\n            }\n            catch (Exception e)\n            {\n                throw new TransformerException(this, e);\n            }\n        }\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected URI getURI(MuleMessage message) throws URISyntaxException, TransformerException\n    {\n        final String endpoint = message.getOutboundProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpoint == null)\n        {\n            throw new TransformerException(\n                HttpMessages.eventPropertyNotSetCannotProcessRequest(MuleProperties.MULE_ENDPOINT_PROPERTY),\n                this);\n        }\n        return new URI(endpoint);\n    }","id":79255,"modified_method":"protected URI getURI(MuleMessage message) throws URISyntaxException, TransformerException\n    {\n        String endpointAddress = message.getOutboundProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, null);\n        if (endpointAddress == null)\n        {\n            throw new TransformerException(\n                HttpMessages.eventPropertyNotSetCannotProcessRequest(MuleProperties.MULE_ENDPOINT_PROPERTY),\n                this);\n        }\n        return new URI(endpointAddress);\n    }","commit_id":"5f7803f1e8fb8e437041bcbf8d5790c48f3f0ecd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getMethodOrOperationName(MuleEvent event) throws DispatchException\n    {\n        // People can specify a CXF operation, which may in fact be different\n        // than the method name. If that's not found, we'll default back to the\n        // mule method property.\n        String method = event.getMessage().getInvocationProperty(CxfConstants.OPERATION);\n\n        if (method == null)\n        {\n            method = event.getMessage().getInvocationProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        }\n\n        if (method == null)\n        {\n            method = operation;\n        }\n\n        if (method == null && proxy)\n        {\n            return \"invoke\";\n        }\n\n        return method;\n    }","id":79256,"modified_method":"protected String getMethodOrOperationName(MuleEvent event) throws DispatchException\n    {\n        // People can specify a CXF operation, which may in fact be different\n        // than the method name. If that's not found, we'll default back to the\n        // mule method property.\n        String method = event.getMessage().getInvocationProperty(CxfConstants.OPERATION);\n\n        if (method == null)\n        {\n            Object muleMethodProperty = event.getMessage().getInvocationProperty(MuleProperties.MULE_METHOD_PROPERTY);\n\n            if (muleMethodProperty != null)\n            {\n                if (muleMethodProperty instanceof Method)\n                {\n                    method = ((Method) muleMethodProperty).getName();\n                }\n                else\n                {\n                    method = muleMethodProperty.toString();\n                }\n            }\n        }\n\n        if (method == null)\n        {\n            method = operation;\n        }\n\n        if (method == null && proxy)\n        {\n            return \"invoke\";\n        }\n\n        return method;\n    }","commit_id":"53cc7a465c03cd3e354b0595b56041500876cea1","url":"https://github.com/mulesoft/mule"},{"original_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        // If the endpoint has a logical name, use it, otherwise use the URI.\n        String inboundEndpoint = endpoint.getName();\n\n        if (StringUtils.isBlank(inboundEndpoint))\n        {\n            // URI\n            inboundEndpoint = endpoint.getEndpointURI().getUri().toString();\n        }\n        event.getMessage().setOutboundProperty(MuleProperties.MULE_ORIGINATING_ENDPOINT_PROPERTY, inboundEndpoint);\n        return event;\n    }","id":79257,"modified_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        // If the endpoint has a logical name, use it, otherwise use the URI.\n        String inboundEndpoint = endpoint.getName();\n\n        if (StringUtils.isBlank(inboundEndpoint))\n        {\n            // URI\n            inboundEndpoint = endpoint.getEndpointURI().getUri().toString();\n        }\n        event.getMessage().setProperty(MuleProperties.MULE_ORIGINATING_ENDPOINT_PROPERTY, inboundEndpoint, PropertyScope.INBOUND);\n        return event;\n    }","commit_id":"b6b05a8b43a56ee4e59c8c18da4a75cfc32f0f3f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Object processAction(MuleEvent event) throws Exception\n    {\n        // An object representing the new state of the process\n        Object process;\n\n        // Create a map of process variables based on the message properties.\n        Map processVariables = new HashMap();\n        if (event != null)\n        {\n            populateProcessVariables(event, processVariables, PropertyScope.INVOCATION);\n            populateProcessVariables(event, processVariables, PropertyScope.OUTBOUND);\n\n            Object payload = event.getMessage().getPayload();\n            if (payload != null && !(payload instanceof NullPayload))\n            {\n                // Store the message's payload as a process variable.\n                processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING, payload);\n\n                // Store the endpoint on which the message was received as a process\n                // variable.\n                String originatingEndpoint = event.getMessage().getOutboundProperty(MuleProperties.MULE_ORIGINATING_ENDPOINT_PROPERTY);\n                if (StringUtils.isNotEmpty(originatingEndpoint))\n                {\n                    processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING_SOURCE,\n                        originatingEndpoint);\n                }\n            }\n        }\n\n        // Retrieve the parameters\n        Object processType = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_TYPE);\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_TYPE);\n\n        // TODO MULE-1220 The processId for BPM is sort of like a session and so we could probably use\n        // Mule's SessionHandler interface for managing this.  \n        Object processId;\n        String processIdField = connector.getProcessIdField();\n\n        //TODO this is redundent but I'm not sure what the correct behaviour is\n        if (StringUtils.isNotEmpty(processIdField))\n        {\n            processId = event.getMessage().getInvocationProperty(processIdField);\n        }\n        // If processId is explicitly set for the message, this overrides the\n        // processIdField.\n        processId = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_ID);\n        if (processId == null)\n        {\n            processId = event.getMessage().getInboundProperty(ProcessConnector.PROPERTY_PROCESS_ID); \n        }\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_ID);\n\n        // Default action is \"advance\"\n        String action = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_ACTION, ProcessConnector.ACTION_ADVANCE);\n        processVariables.remove(ProcessConnector.PROPERTY_ACTION);\n\n        Object transition = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_TRANSITION);\n        processVariables.remove(ProcessConnector.PROPERTY_TRANSITION);\n\n        // Decode the URI, for example:\n        // bpm://testProcess/4561?action=advance\n        String temp;\n        temp = event.getEndpoint().getEndpointURI().getHost();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            processType = temp;\n        }\n        temp = event.getEndpoint().getEndpointURI().getPath();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            // Strip the leading \"/\" from the path.\n            if (temp.startsWith(\"/\"))\n            {\n                temp = StringUtils.right(temp, temp.length() - 1);\n            }\n            // If there are any remaining \"/\", we don't know what to do with them.\n            if (temp.indexOf(\"/\") != -1)\n            {\n                throw new IllegalArgumentException(\"Unexpected format in the path of the URL: \" + temp);\n            }\n            processId = temp;\n        }\n\n        // //////////////////////////////////////////////////////////////////////\n\n        // Start a new process.\n        if (processId == null || action.equals(ProcessConnector.ACTION_START))\n        {\n            if (processType != null)\n            {\n                process = connector.getBpms().startProcess(processType, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"New process started, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process type is missing, cannot start a new process.\");\n            }\n        }\n\n        // Don't advance the process, just update the process variables.\n        else if (action.equals(ProcessConnector.ACTION_UPDATE))\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().updateProcess(processId, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process variables updated, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot update process.\");\n            }\n        }\n\n        // Abort the running process (end abnormally).\n        else if (action.equals(ProcessConnector.ACTION_ABORT))\n        {\n            if (processId != null)\n            {\n                connector.getBpms().abortProcess(processId);\n                process = NullPayload.getInstance();\n                logger.info(\"Process aborted, ID = \" + processId);\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot abort process.\");\n            }\n        }\n\n        // Advance the already-running process one step.\n        else\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().advanceProcess(processId, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process advanced, ID = \" + connector.getBpms().getId(process)\n                                    + \", new state = \" + connector.getBpms().getState(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot advance process.\");\n            }\n        }\n\n        return process;\n    }","id":79258,"modified_method":"protected Object processAction(MuleEvent event) throws Exception\n    {\n        // An object representing the new state of the process\n        Object process;\n\n        // Create a map of process variables based on the message properties.\n        Map processVariables = new HashMap();\n        if (event != null)\n        {\n            populateProcessVariables(event, processVariables, PropertyScope.INVOCATION);\n            populateProcessVariables(event, processVariables, PropertyScope.OUTBOUND);\n\n            Object payload = event.getMessage().getPayload();\n            if (payload != null && !(payload instanceof NullPayload))\n            {\n                // Store the message's payload as a process variable.\n                processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING, payload);\n\n                // Store the endpoint on which the message was received as a process variable.\n                String originatingEndpoint = event.getMessage().getInboundProperty(MuleProperties.MULE_ORIGINATING_ENDPOINT_PROPERTY);\n                if (StringUtils.isNotEmpty(originatingEndpoint))\n                {\n                    processVariables.put(ProcessConnector.PROCESS_VARIABLE_INCOMING_SOURCE, originatingEndpoint);\n                }\n            }\n        }\n\n        // Retrieve the parameters\n        Object processType = event.getMessage().getSessionProperty(ProcessConnector.PROPERTY_PROCESS_TYPE);\n        if (processType == null)\n        {\n            processType = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_TYPE);\n        }\n        if (processType == null)\n        {\n            processType = event.getMessage().getInboundProperty(ProcessConnector.PROPERTY_PROCESS_TYPE);\n        }\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_TYPE);\n\n        // TODO MULE-1220 The processId for BPM is sort of like a session and so we could probably use\n        // Mule's SessionHandler interface for managing this.  \n        Object processId;\n        String processIdField = connector.getProcessIdField();\n\n        //TODO this is redundent but I'm not sure what the correct behaviour is\n        if (StringUtils.isNotEmpty(processIdField))\n        {\n            processId = event.getMessage().getInvocationProperty(processIdField);\n        }\n        // If processId is explicitly set for the message, this overrides the\n        // processIdField.\n        processId = event.getMessage().getSessionProperty(ProcessConnector.PROPERTY_PROCESS_ID);\n        if (processId == null)\n        {\n            processId = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_ID); \n        }\n        if (processId == null)\n        {\n            processId = event.getMessage().getInboundProperty(ProcessConnector.PROPERTY_PROCESS_ID); \n        }\n        processVariables.remove(ProcessConnector.PROPERTY_PROCESS_ID);\n\n        // Default action is \"advance\"\n        String action = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_ACTION, ProcessConnector.ACTION_ADVANCE);\n        processVariables.remove(ProcessConnector.PROPERTY_ACTION);\n\n        Object transition = event.getMessage().getInvocationProperty(ProcessConnector.PROPERTY_TRANSITION);\n        processVariables.remove(ProcessConnector.PROPERTY_TRANSITION);\n\n        // Decode the URI, for example:\n        // bpm://testProcess/4561?action=advance\n        String temp;\n        temp = event.getEndpoint().getEndpointURI().getHost();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            processType = temp;\n        }\n        temp = event.getEndpoint().getEndpointURI().getPath();\n        if (StringUtils.isNotEmpty(temp))\n        {\n            // Strip the leading \"/\" from the path.\n            if (temp.startsWith(\"/\"))\n            {\n                temp = StringUtils.right(temp, temp.length() - 1);\n            }\n            // If there are any remaining \"/\", we don't know what to do with them.\n            if (temp.indexOf(\"/\") != -1)\n            {\n                throw new IllegalArgumentException(\"Unexpected format in the path of the URL: \" + temp);\n            }\n            processId = temp;\n        }\n\n        // //////////////////////////////////////////////////////////////////////\n\n        logger.debug(\"Message received: payload = \" + event.getMessage().getPayload().getClass().getName() + \" processType = \" + processType + \" processId = \" + processId + \" action = \" + action);\n        \n        // Start a new process.\n        if (processId == null || action.equals(ProcessConnector.ACTION_START))\n        {\n            if (processType != null)\n            {\n                process = connector.getBpms().startProcess(processType, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"New process started, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process type is missing, cannot start a new process.\");\n            }\n        }\n\n        // Don't advance the process, just update the process variables.\n        else if (action.equals(ProcessConnector.ACTION_UPDATE))\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().updateProcess(processId, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process variables updated, ID = \" + connector.getBpms().getId(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot update process.\");\n            }\n        }\n\n        // Abort the running process (end abnormally).\n        else if (action.equals(ProcessConnector.ACTION_ABORT))\n        {\n            if (processId != null)\n            {\n                connector.getBpms().abortProcess(processId);\n                process = NullPayload.getInstance();\n                logger.info(\"Process aborted, ID = \" + processId);\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot abort process.\");\n            }\n        }\n\n        // Advance the already-running process one step.\n        else\n        {\n            if (processId != null)\n            {\n                process = connector.getBpms().advanceProcess(processId, transition, processVariables);\n                if ((process != null) && logger.isInfoEnabled())\n                {\n                    logger.info(\"Process advanced, ID = \" + connector.getBpms().getId(process)\n                                    + \", new state = \" + connector.getBpms().getState(process));\n                }\n            }\n            else\n            {\n                throw new IllegalArgumentException(\"Process ID is missing, cannot advance process.\");\n            }\n        }\n\n        return process;\n    }","commit_id":"b6b05a8b43a56ee4e59c8c18da4a75cfc32f0f3f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Performs a synchronous action on the BPMS.\n     * \n     * @return an object representing the new state of the process\n     */\n    @Override\n    public MuleMessage doSend(MuleEvent event) throws Exception\n    {\n        Object process = processAction(event);\n\n        if (process != null)\n        {\n            MuleMessage msg = new DefaultMuleMessage(process, connector.getMuleContext());\n            msg.setProperty(ProcessConnector.PROPERTY_PROCESS_ID, connector.getBpms().getId(process), PropertyScope.INVOCATION);\n            return msg;\n        }\n        else\n        {\n            throw new DispatchException(\n                MessageFactory.createStaticMessage(\"Synchronous process invocation must return the new process state.\"),\n                event, this);\n        }\n    }","id":79259,"modified_method":"/**\n     * Performs a synchronous action on the BPMS.\n     * \n     * @return an object representing the new state of the process\n     */\n    @Override\n    public MuleMessage doSend(MuleEvent event) throws Exception\n    {\n        Object process = processAction(event);\n\n        if (process != null)\n        {\n            MuleMessage msg = new DefaultMuleMessage(process, connector.getMuleContext());\n            msg.setProperty(ProcessConnector.PROPERTY_PROCESS_ID, connector.getBpms().getId(process), PropertyScope.SESSION);\n            return msg;\n        }\n        else\n        {\n            throw new DispatchException(\n                MessageFactory.createStaticMessage(\"Synchronous process invocation must return the new process state.\"),\n                event, this);\n        }\n    }","commit_id":"b6b05a8b43a56ee4e59c8c18da4a75cfc32f0f3f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected MuleMessage generateEvent(String endpoint, Object payload, Map messageProperties, \n        MessageExchangePattern exchangePattern) throws MuleException\n    {\n        MuleMessage message;\n        if (payload instanceof MuleMessage)\n        {\n            message = (MuleMessage) payload;\n        }\n        else\n        {\n            message = createMuleMessage(payload, this.endpoint.getEncoding());\n        }\n        message.addProperties(messageProperties);\n\n        //TODO should probably cache this\n        EndpointBuilder endpointBuilder = connector.getMuleContext().getRegistry().lookupEndpointFactory().getEndpointBuilder(endpoint);\n        endpointBuilder.setExchangePattern(exchangePattern);\n        OutboundEndpoint ep = endpointBuilder.buildOutboundEndpoint();\n       \n        DefaultMuleEvent event = new DefaultMuleEvent(message, ep, new DefaultMuleSession(flowConstruct, connector.getMuleContext()));\n        MuleEvent resultEvent = ep.process(event);\n        \n        MuleMessage response = null;\n        if (resultEvent != null)\n        {\n            response = resultEvent.getMessage();\n            if (response.getExceptionPayload() != null)\n            {\n                throw new ConnectorException(MessageFactory.createStaticMessage(\"Unable to send or route message\"), getConnector(), response.getExceptionPayload().getRootException());\n            }\n        }\n        \n        return response;\n    }","id":79260,"modified_method":"protected MuleMessage generateEvent(String endpoint, Object payload, Map messageProperties, MessageExchangePattern exchangePattern) throws MuleException\n    {\n        MuleMessage message;\n        if (payload instanceof MuleMessage)\n        {\n            message = (MuleMessage) payload;\n        }\n        else\n        {\n            message = createMuleMessage(payload, this.endpoint.getEncoding());\n        }\n        message.addProperties(messageProperties, PropertyScope.INBOUND);\n        message.addProperties(messageProperties, PropertyScope.INVOCATION);\n\n        //TODO should probably cache this\n        EndpointBuilder endpointBuilder = connector.getMuleContext().getRegistry().lookupEndpointFactory().getEndpointBuilder(endpoint);\n        endpointBuilder.setExchangePattern(exchangePattern);\n        OutboundEndpoint ep = endpointBuilder.buildOutboundEndpoint();\n       \n        DefaultMuleEvent event = new DefaultMuleEvent(message, ep, new DefaultMuleSession(flowConstruct, connector.getMuleContext()));\n\n        // Set correlation properties in SESSION scope so that they get propagated to response messages.\n        RequestContext.setEvent(event);\n        if (messageProperties.get(ProcessConnector.PROPERTY_PROCESS_TYPE) != null)\n        {\n            event.getMessage().setSessionProperty(ProcessConnector.PROPERTY_PROCESS_TYPE, messageProperties.get(ProcessConnector.PROPERTY_PROCESS_TYPE));\n        }\n        if (messageProperties.get(ProcessConnector.PROPERTY_PROCESS_ID) != null)\n        {\n            event.getMessage().setSessionProperty(ProcessConnector.PROPERTY_PROCESS_ID, messageProperties.get(ProcessConnector.PROPERTY_PROCESS_ID));\n        }\n        \n        MuleEvent resultEvent = ep.process(event);\n        \n        MuleMessage response = null;\n        if (resultEvent != null)\n        {\n            response = resultEvent.getMessage();\n            if (response.getExceptionPayload() != null)\n            {\n                throw new ConnectorException(MessageFactory.createStaticMessage(\"Unable to send or route message\"), getConnector(), response.getExceptionPayload().getRootException());\n            }\n        }\n        \n        return response;\n    }","commit_id":"b6b05a8b43a56ee4e59c8c18da4a75cfc32f0f3f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSimpleProcessWithParameters() throws Exception\n    {\n        MuleMessage response;\n        Object process;\n        BPMS bpms = connector.getBpms();\n        MuleClient client = new MuleClient(muleContext);\n        try\n        {\n            // Create a new process.\n            response = client.send(\"bpm://?\" +\n                                   ProcessConnector.PROPERTY_ACTION + \"=\" + ProcessConnector.ACTION_START +\n                                   \"&\" + ProcessConnector.PROPERTY_PROCESS_TYPE + \"=simple\", \"data\", null);\n            process = response.getPayload();\n\n            String processId = response.getInvocationProperty(ProcessConnector.PROPERTY_PROCESS_ID);\n            // The process should be started and in a wait state.\n            assertNotNull(processId);\n            assertEquals(\"dummyState\", bpms.getState(process));\n\n            // Advance the process one step.\n            response = client.send(\"bpm://?\" +\n                                   ProcessConnector.PROPERTY_ACTION + \"=\" + ProcessConnector.ACTION_ADVANCE +\n                                   \"&\" + ProcessConnector.PROPERTY_PROCESS_TYPE + \"=simple&\" +\n                                   ProcessConnector.PROPERTY_PROCESS_ID + \"=\" + processId, \"data\", null);\n            process = response.getPayload();\n\n            // The process should have ended.\n            assertTrue(bpms.hasEnded(process));\n        }\n        finally\n        {\n            client.dispose();\n        }\n    }","id":79261,"modified_method":"public void testSimpleProcessWithParameters() throws Exception\n    {\n        MuleMessage response;\n        Object process;\n        BPMS bpms = connector.getBpms();\n        MuleClient client = new MuleClient(muleContext);\n        try\n        {\n            // Create a new process.\n            response = client.send(\"bpm://?\" +\n                                   ProcessConnector.PROPERTY_ACTION + \"=\" + ProcessConnector.ACTION_START +\n                                   \"&\" + ProcessConnector.PROPERTY_PROCESS_TYPE + \"=simple\", \"data\", null);\n            process = response.getPayload();\n\n            // The process should be started and in a wait state.\n            Object processId = bpms.getId(process);\n            assertNotNull(processId);\n            assertEquals(\"dummyState\", bpms.getState(process));\n\n            // Advance the process one step.\n            response = client.send(\"bpm://?\" +\n                                   ProcessConnector.PROPERTY_ACTION + \"=\" + ProcessConnector.ACTION_ADVANCE +\n                                   \"&\" + ProcessConnector.PROPERTY_PROCESS_TYPE + \"=simple&\" +\n                                   ProcessConnector.PROPERTY_PROCESS_ID + \"=\" + processId, \"data\", null);\n            process = response.getPayload();\n\n            // The process should have ended.\n            assertTrue(bpms.hasEnded(process));\n        }\n        finally\n        {\n            client.dispose();\n        }\n    }","commit_id":"b6b05a8b43a56ee4e59c8c18da4a75cfc32f0f3f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testVariables() throws Exception\n    {\n        MuleClient client = new MuleClient(muleContext);\n        try\n        {\n            Map<String, Object> props = new HashMap<String, Object>();\n            props.put(\"foo\", \"bar\");\n            MuleMessage response = client.send(\"bpm://variables\", \"data\", props);\n            String processId = (String)bpms.getId(response.getPayload());\n            assertNotNull(processId);\n\n            response = client.request(\"vm://queueA\", 3000);\n            assertNotNull(response);\n            assertEquals(\"bar\", response.getOutboundProperty(\"foo\"));\n            assertEquals(0.75, response.getOutboundProperty(\"fraction\"));\n\n            // Advance the process\n            props = new HashMap<String, Object>();\n            props.put(\"straw\", \"berry\");\n            props.put(\"time\", new Date());\n            response = client.send(\"bpm://variables/\" + processId, \"data\", props);\n\n            response = client.request(\"vm://queueB\", 3000);\n            assertNotNull(response);\n            assertEquals(\"bar\", response.getOutboundProperty(\"foo\"));\n            assertEquals(0.75, response.getOutboundProperty(\"fraction\"));\n            assertEquals(\"berry\", response.getOutboundProperty(\"straw\"));\n            final Object o = response.getOutboundProperty(\"time\");\n            assertTrue(o instanceof Date);\n        }\n        finally\n        {\n            client.dispose();\n        }\n    }","id":79262,"modified_method":"public void testVariables() throws Exception\n    {\n        MuleClient client = new MuleClient(muleContext);\n        try\n        {\n            Map<String, Object> props = new HashMap<String, Object>();\n            props.put(\"foo\", \"bar\");\n            MuleMessage response = client.send(\"bpm://variables\", \"data\", props);\n            String processId = (String)bpms.getId(response.getPayload());\n            assertNotNull(processId);\n\n            response = client.request(\"vm://queueA\", 3000);\n            assertNotNull(response);\n            assertEquals(\"bar\", response.getInboundProperty(\"foo\"));\n            assertEquals(0.75, response.getInboundProperty(\"fraction\"));\n\n            // Advance the process\n            props = new HashMap<String, Object>();\n            props.put(\"straw\", \"berry\");\n            props.put(\"time\", new Date());\n            response = client.send(\"bpm://variables/\" + processId, \"data\", props);\n            \n            response = client.request(\"vm://queueB\", 3000);\n            assertNotNull(response);\n            assertEquals(\"bar\", response.getInboundProperty(\"foo\"));\n            assertEquals(0.75, response.getInboundProperty(\"fraction\"));\n            assertEquals(\"berry\", response.getInboundProperty(\"straw\"));\n            final Object o = response.getInboundProperty(\"time\");\n            assertTrue(o instanceof Date);\n        }\n        finally\n        {\n            client.dispose();\n        }\n    }","commit_id":"b6b05a8b43a56ee4e59c8c18da4a75cfc32f0f3f","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public SNode resolve(SNode contextNode, String refText) {\n    SModelReference targetModelReference = model.getSModelReference();\n    // hack for [model]node construction, remove it \n    if (refText.startsWith(\"[\")) {\n      String[] modelNameAndTheRest = refText.split(\"]\");\n      if (modelNameAndTheRest.length > 1 || (modelNameAndTheRest.length == 1 && refText.endsWith(\"]\"))) {\n        refText = refText.substring(refText.indexOf(\"]\") + 1).trim();\n        String modelName = modelNameAndTheRest[0].substring(1).trim();\n        if (modelName.length() > 0) {\n          //  model: either current output or java_stub \n          if (!(modelName.equals(model.getLongName()))) {\n            //  external java_stub \n            String stereo = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);\n            Iterable<IModule> modules = model.getModelDescriptor().getModule().getScope().getVisibleModules();\n            SModelId id = StubMigrationHelper.convertModelUIDInScope(stereo + \"#\" + modelName, Sequence.fromIterable(modules).translate(new ITranslator2<IModule, SModelDescriptor>() {\n              public Iterable<SModelDescriptor> translate(IModule it) {\n                return it.getOwnModelDescriptors();\n              }\n            }));\n            targetModelReference = new SModelReference(new SModelFqName(modelName, stereo), id);\n          }\n        }\n      }\n    }\n    // end of hack \n\n    // todo: CRAP, rewrite it! \n    String classname = refText;\n    int dotIndex = classname.lastIndexOf(\".\");\n    if (dotIndex >= 0) {\n      // try local nested classes \n      List<SNode> localClassifiers = getClassifiersByRefName(model, classname);\n      if (ListSequence.fromList(localClassifiers).count() >= 1) {\n        return ListSequence.fromList(localClassifiers).first();\n      }\n\n      if (classname.contains(\"$\")) {\n        // search everywhere \n        String package_ = classname.substring(0, dotIndex);\n        classname = classname.substring(dotIndex + 1).replace('$', '.');\n        return resolveClass(package_, null, classname);\n      } else {\n        String[] parts = classname.split(\"\\\\.\");\n        for (int sizeOfClassifier = 1; sizeOfClassifier <= parts.length; sizeOfClassifier++) {\n          String packageName = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(parts)).take(parts.length - sizeOfClassifier), \".\");\n          String className = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(parts)).skip(parts.length - sizeOfClassifier), \".\");\n          SNode resolved = resolveClass(packageName, null, className);\n          if (resolved != null) {\n            return resolved;\n          }\n        }\n      }\n      // search everywhere \n      String package_ = classname.substring(0, dotIndex);\n      classname = classname.substring(dotIndex + 1).replace('$', '.');\n\n      return resolveClass(package_, null, classname);\n    }\n\n    if (targetModelReference.getSModelId() != null) {\n      SModelDescriptor targetModel = scope.getModelDescriptor(targetModelReference);\n      if (targetModel == null) {\n        return null;\n      }\n      return ListSequence.fromList(getClassifiersByRefName(targetModel.getSModel(), classname)).first();\n    }\n    SModelFqName modelname = targetModelReference.getSModelFqName();\n    return resolveClass(modelname.getLongName(), modelname.getStereotype(), classname);\n  }","id":79263,"modified_method":"@Override\n  public SNode resolve(SNode contextNode, String refText) {\n    SModelReference targetModelReference = null;\n    // hack for [model]node construction, remove it \n    if (refText.startsWith(\"[\")) {\n      String[] modelNameAndTheRest = refText.split(\"]\");\n      if (modelNameAndTheRest.length > 1 || (modelNameAndTheRest.length == 1 && refText.endsWith(\"]\"))) {\n        refText = refText.substring(refText.indexOf(\"]\") + 1).trim();\n        String modelName = modelNameAndTheRest[0].substring(1).trim();\n        if (modelName.length() > 0) {\n          //  model: either current output or java_stub \n          if (!(modelName.equals(model.getLongName()))) {\n            //  external java_stub \n            String stereo = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);\n            Iterable<IModule> modules = model.getModelDescriptor().getModule().getScope().getVisibleModules();\n            SModelId id = StubMigrationHelper.convertModelUIDInScope(stereo + \"#\" + modelName, Sequence.fromIterable(modules).translate(new ITranslator2<IModule, SModelDescriptor>() {\n              public Iterable<SModelDescriptor> translate(IModule it) {\n                return it.getOwnModelDescriptors();\n              }\n            }));\n            targetModelReference = new SModelReference(new SModelFqName(modelName, stereo), id);\n          }\n        }\n      }\n    }\n    // end of hack \n\n    SModel targetModel = null;\n    if (targetModelReference != null && targetModelReference.getSModelId() != null) {\n      targetModel = check_npo0wh_a0a0g0c(scope.getModelDescriptor(targetModelReference));\n    }\n\n    // todo: CRAP, rewrite it! \n    String classname = refText;\n    int dotIndex = classname.lastIndexOf(\".\");\n    if (dotIndex >= 0) {\n      // try local nested classes \n      List<SNode> localClassifiers = getClassifiersByRefName((targetModel != null ?\n        targetModel :\n        model\n      ), classname);\n      if (ListSequence.fromList(localClassifiers).count() >= 1) {\n        return ListSequence.fromList(localClassifiers).first();\n      }\n\n      if (classname.contains(\"$\")) {\n        // search everywhere \n        String package_ = classname.substring(0, dotIndex);\n        classname = classname.substring(dotIndex + 1).replace('$', '.');\n        return resolveClass(package_, null, classname);\n      } else {\n        String[] parts = classname.split(\"\\\\.\");\n        for (int sizeOfClassifier = 1; sizeOfClassifier <= parts.length; sizeOfClassifier++) {\n          String packageName = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(parts)).take(parts.length - sizeOfClassifier), \".\");\n          String className = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(parts)).skip(parts.length - sizeOfClassifier), \".\");\n          SNode resolved = resolveClass(packageName, null, className);\n          if (resolved != null) {\n            return resolved;\n          }\n        }\n      }\n      // search everywhere \n      String package_ = classname.substring(0, dotIndex);\n      classname = classname.substring(dotIndex + 1).replace('$', '.');\n\n      return resolveClass(package_, null, classname);\n    }\n\n    if (targetModel != null) {\n      return ListSequence.fromList(getClassifiersByRefName(targetModel, classname)).first();\n    }\n    SModelFqName modelname = (targetModelReference == null ?\n      model.getSModelFqName() :\n      targetModelReference.getSModelFqName()\n    );\n    return resolveClass(modelname.getLongName(), modelname.getStereotype(), classname);\n  }","commit_id":"817aaa062fb32b35e28a43a25d16e70b84a422b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode resolve(String referenceInfo, SModelReference targetModelReference) {\n      if (targetModelReference.getSModelId() != null) {\n        SModelDescriptor targetModel = this.myScope.getModelDescriptor(targetModelReference);\n        if (targetModel == null) {\n          return null;\n        }\n        return ListSequence.fromList(ClassifiersCache.getInstance(targetModel).getClassifiersByRefName(referenceInfo)).first();\n      }\n\n      Collection<IModule> visibleModules = IterableUtil.asCollection(myScope.getVisibleModules());\n      for (SModelDescriptor model : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {\n        if (visibleModules.contains(model.getModule())) {\n          if (model.getSModelReference().getSModelFqName().equals(targetModelReference.getSModelFqName())) {\n            List<SNode> classifiers = ClassifiersCache.getInstance(model).getClassifiersByRefName(referenceInfo);\n            if (ListSequence.fromList(classifiers).isNotEmpty()) {\n              return ListSequence.fromList(classifiers).first();\n            }\n          }\n        }\n      }\n      return null;\n    }","id":79264,"modified_method":"public SNode resolve(String referenceInfo, SModelReference targetModelReference) {\n      if (targetModelReference.getSModelId() != null) {\n        SModelDescriptor targetModel = this.myScope.getModelDescriptor(targetModelReference);\n        if (targetModel == null) {\n          return null;\n        }\n        return ListSequence.fromList(ClassifiersCache.getInstance(targetModel).getClassifiersByRefName(referenceInfo)).first();\n      }\n\n      Collection<IModule> visibleModules = IterableUtil.asCollection(myScope.getVisibleModules());\n\n      List<SNode> classifiers = new ArrayList<SNode>();\n      for (SModelDescriptor model : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {\n        if (!(visibleModules.contains(model.getModule()))) {\n          continue;\n        }\n        if (!(model.getSModelReference().getSModelFqName().equals(targetModelReference.getSModelFqName()))) {\n          continue;\n        }\n\n        ListSequence.fromList(classifiers).addSequence(ListSequence.fromList(ClassifiersCache.getInstance(model).getClassifiersByRefName(referenceInfo)));\n      }\n\n      if (ListSequence.fromList(classifiers).isEmpty()) {\n        return null;\n      }\n      if (ListSequence.fromList(classifiers).count() > 1) {\n        final StringBuilder warn = new StringBuilder();\n        warn.append(\"reference can't be resolved: \");\n        warn.append(referenceInfo);\n        warn.append(\" in \");\n        warn.append(myModel.getLongName());\n        warn.append(\" can reference nodes from models: \");\n        ListSequence.fromList(classifiers).visitAll(new IVisitor<SNode>() {\n          public void visit(SNode it) {\n            warn.append(SNodeOperations.getModel(it).getSModelReference()).append(\"; \");\n          }\n        });\n\n        if (log.isWarnEnabled()) {\n          log.warn(warn);\n        }\n        return null;\n      }\n      return ListSequence.fromList(classifiers).getElement(0);\n    }","commit_id":"5f18b192d173d23bbf1b71760c45e9abde304f6d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode resolve(String referenceInfo, SModelReference targetModelReference) {\n      SModelDescriptor targetModel = this.myScope.getModelDescriptor(targetModelReference);\n      if (targetModel == null) {\n        return null;\n      }\n      List<SNode> classifiers = ClassifiersCache.getInstance(targetModel).getClassifiersByRefName(referenceInfo);\n      if (ListSequence.fromList(classifiers).isNotEmpty()) {\n        return ListSequence.fromList(classifiers).first();\n      }\n      return null;\n    }","id":79265,"modified_method":"public SNode resolve(String referenceInfo, SModelReference targetModelReference) {\n      if (targetModelReference.getSModelId() != null) {\n        SModelDescriptor targetModel = this.myScope.getModelDescriptor(targetModelReference);\n        if (targetModel == null) {\n          return null;\n        }\n        return ListSequence.fromList(ClassifiersCache.getInstance(targetModel).getClassifiersByRefName(referenceInfo)).first();\n      }\n\n      Collection<IModule> visibleModules = IterableUtil.asCollection(myScope.getVisibleModules());\n      for (SModelDescriptor model : ListSequence.fromList(SModelRepository.getInstance().getModelDescriptors())) {\n        if (visibleModules.contains(model.getModule())) {\n          if (model.getSModelReference().getSModelFqName().equals(targetModelReference.getSModelFqName())) {\n            List<SNode> classifiers = ClassifiersCache.getInstance(model).getClassifiersByRefName(referenceInfo);\n            if (ListSequence.fromList(classifiers).isNotEmpty()) {\n              return ListSequence.fromList(classifiers).first();\n            }\n          }\n        }\n      }\n      return null;\n    }","commit_id":"24ff073ebf849829bb3d1b98f7c6c286043122fd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void createIndex( String labelName, String propertyName )\n    {\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().indexFor( label( labelName ) ).on( propertyName ).create();\n            tx.success();\n        }\n        awaitIndexes();\n    }","id":79266,"modified_method":"private Consumer<GraphDatabaseService> index( String label, String prop )\n    {\n        return db -> db.schema().indexFor( Label.label( label ) ).on( prop ).create();\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldListSchemaRulesByClass()\n    {\n        // Given\n        createIndex( LABEL1, PROP1 );\n        createUniquenessConstraint( LABEL2, PROP1 );\n\n        // When\n        Set<UniquePropertyConstraintRule> listedRules = asSet(\n                storage.schemaRules( UniquePropertyConstraintRule.class ) );\n\n        // Then\n        Set<UniquePropertyConstraintRule> expectedRules = new HashSet<>();\n        expectedRules.add( uniquenessConstraintRule( 0, labelId( LABEL2 ), propId( PROP1 ), 0 ) );\n\n        assertEquals( expectedRules, listedRules );\n    }","id":79267,"modified_method":"@Test\n    public void shouldListSchemaRulesByClass()\n    {\n        // Given\n        createSchema(\n                index( LABEL1, PROP1 ),\n                uniquenessConstraint( LABEL2, PROP1 ) );\n\n        // When\n        Set<UniquePropertyConstraintRule> listedRules = asSet(\n                storage.schemaRules( UniquePropertyConstraintRule.class ) );\n\n        // Then\n        Set<UniquePropertyConstraintRule> expectedRules = new HashSet<>();\n        expectedRules.add( uniquenessConstraintRule( 0, labelId( LABEL2 ), propId( PROP1 ), 0 ) );\n\n        assertEquals( expectedRules, listedRules );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createUniquenessConstraint( String labelName, String propertyName )\n    {\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().constraintFor( label( labelName ) ).assertPropertyIsUnique( propertyName ).create();\n            tx.success();\n        }\n        awaitIndexes();\n    }","id":79268,"modified_method":"private Consumer<GraphDatabaseService> uniquenessConstraint( String label, String prop )\n    {\n        return db -> db.schema().constraintFor( Label.label( label ) ).assertPropertyIsUnique( prop ).create();\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReturnIndexRuleForLabelAndProperty()\n    {\n        // Given\n        createIndex( LABEL1, PROP1 );\n        createIndex( LABEL1, PROP2 );\n        createIndex( LABEL2, PROP1 );\n\n        // When\n        IndexRule rule = storage.indexRule( labelId( LABEL1 ), propId( PROP1 ) );\n\n        // Then\n        assertNotNull( rule );\n        assertEquals( labelId( LABEL1 ), rule.getLabel() );\n        assertEquals( propId( PROP1 ), rule.getPropertyKey() );\n        assertEquals( SchemaRule.Kind.INDEX_RULE, rule.getKind() );\n    }","id":79269,"modified_method":"@Test\n    public void shouldReturnIndexRuleForLabelAndProperty()\n    {\n        // Given\n        createSchema(\n                index( LABEL1, PROP1 ),\n                index( LABEL1, PROP2 ),\n                index( LABEL2, PROP1 ) );\n\n        // When\n        IndexRule rule = storage.indexRule( labelId( LABEL1 ), propId( PROP1 ) );\n\n        // Then\n        assertNotNull( rule );\n        assertEquals( labelId( LABEL1 ), rule.getLabel() );\n        assertEquals( propId( PROP1 ), rule.getPropertyKey() );\n        assertEquals( SchemaRule.Kind.INDEX_RULE, rule.getKind() );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldListAllSchemaRulesForNodes()\n    {\n        // Given\n        createIndex( LABEL2, PROP1 );\n        createUniquenessConstraint( LABEL1, PROP1 );\n\n        // When\n        Set<NodePropertyConstraintRule> listedRules = asSet( storage.schemaRulesForNodes( value -> value, NodePropertyConstraintRule.class, labelId( LABEL1 ),\n                Predicates.<NodePropertyConstraintRule>alwaysTrue() ) );\n\n        // Then\n        Set<NodePropertyConstraintRule> expectedRules = new HashSet<>();\n        expectedRules.add( uniquenessConstraintRule( 1, labelId( LABEL1 ), propId( PROP1 ), 0 ) );\n\n        assertEquals( expectedRules, listedRules );\n    }","id":79270,"modified_method":"@Test\n    public void shouldListAllSchemaRulesForNodes()\n    {\n        // Given\n        createSchema(\n                index( LABEL2, PROP1 ),\n                uniquenessConstraint( LABEL1, PROP1 ) );\n\n        // When\n        Set<NodePropertyConstraintRule> listedRules = asSet( storage.schemaRulesForNodes( value -> value, NodePropertyConstraintRule.class, labelId( LABEL1 ),\n                Predicates.<NodePropertyConstraintRule>alwaysTrue() ) );\n\n        // Then\n        Set<NodePropertyConstraintRule> expectedRules = new HashSet<>();\n        expectedRules.add( uniquenessConstraintRule( 1, labelId( LABEL1 ), propId( PROP1 ), 0 ) );\n\n        assertEquals( expectedRules, listedRules );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReturnCorrectUniquenessRuleForLabelAndProperty()\n            throws SchemaRuleNotFoundException, DuplicateSchemaRuleException\n    {\n        // Given\n        createUniquenessConstraint( LABEL1, PROP1 );\n        createUniquenessConstraint( LABEL2, PROP1 );\n\n        // When\n        UniquePropertyConstraintRule rule = storage.uniquenessConstraint( labelId( LABEL1 ), propId( PROP1 ) );\n\n        // Then\n        assertNotNull( rule );\n        assertEquals( labelId( LABEL1 ), rule.getLabel() );\n        assertEquals( propId( PROP1 ), rule.getPropertyKey() );\n        assertEquals( SchemaRule.Kind.UNIQUENESS_CONSTRAINT, rule.getKind() );\n    }","id":79271,"modified_method":"@Test\n    public void shouldReturnCorrectUniquenessRuleForLabelAndProperty()\n            throws SchemaRuleNotFoundException, DuplicateSchemaRuleException\n    {\n        // Given\n        createSchema(\n                uniquenessConstraint( LABEL1, PROP1 ),\n                uniquenessConstraint( LABEL2, PROP1 ) );\n\n        // When\n        UniquePropertyConstraintRule rule = storage.uniquenessConstraint( labelId( LABEL1 ), propId( PROP1 ) );\n\n        // Then\n        assertNotNull( rule );\n        assertEquals( labelId( LABEL1 ), rule.getLabel() );\n        assertEquals( propId( PROP1 ), rule.getPropertyKey() );\n        assertEquals( SchemaRule.Kind.UNIQUENESS_CONSTRAINT, rule.getKind() );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldListIndexRulesForLabelPropertyAndKind()\n    {\n        // Given\n        createUniquenessConstraint( LABEL1, PROP1 );\n        createIndex( LABEL1, PROP2 );\n\n        // When\n        IndexRule rule = storage.indexRule( labelId( LABEL1 ), propId( PROP1 ), IndexRuleKind.CONSTRAINT );\n\n        // Then\n        assertNotNull( rule );\n        assertEquals( labelId( LABEL1 ), rule.getLabel() );\n        assertEquals( propId( PROP1 ), rule.getPropertyKey() );\n        assertEquals( SchemaRule.Kind.CONSTRAINT_INDEX_RULE, rule.getKind() );\n    }","id":79272,"modified_method":"@Test\n    public void shouldListIndexRulesForLabelPropertyAndKind()\n    {\n        // Given\n        createSchema(\n                uniquenessConstraint( LABEL1, PROP1 ),\n                index( LABEL1, PROP2 ) );\n\n        // When\n        IndexRule rule = storage.indexRule( labelId( LABEL1 ), propId( PROP1 ), IndexRuleKind.CONSTRAINT );\n\n        // Then\n        assertNotNull( rule );\n        assertEquals( labelId( LABEL1 ), rule.getLabel() );\n        assertEquals( propId( PROP1 ), rule.getPropertyKey() );\n        assertEquals( SchemaRule.Kind.CONSTRAINT_INDEX_RULE, rule.getKind() );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReturnNullIfIndexRuleForLabelAndPropertyDoesNotExist()\n    {\n        // Given\n        createIndex( LABEL1, PROP1 );\n\n        // When\n        IndexRule rule = storage.indexRule( labelId( LABEL1 ), propId( PROP2 ) );\n\n        // Then\n        assertNull( rule );\n    }","id":79273,"modified_method":"@Test\n    public void shouldReturnNullIfIndexRuleForLabelAndPropertyDoesNotExist()\n    {\n        // Given\n        createSchema(\n                index( LABEL1, PROP1 ) );\n\n        // When\n        IndexRule rule = storage.indexRule( labelId( LABEL1 ), propId( PROP2 ) );\n\n        // Then\n        assertNull( rule );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldListAllIndexRules()\n    {\n        // Given\n        createIndex( LABEL1, PROP1 );\n        createIndex( LABEL1, PROP2 );\n        createUniquenessConstraint( LABEL2, PROP1 );\n\n        // When\n        Set<IndexRule> listedRules = asSet( storage.allIndexRules() );\n\n        // Then\n        Set<IndexRule> expectedRules = new HashSet<>();\n        expectedRules.add( new IndexRule( 0, labelId( LABEL1 ), propId( PROP1 ), PROVIDER_DESCRIPTOR, null ) );\n        expectedRules.add( new IndexRule( 1, labelId( LABEL1 ), propId( PROP2 ), PROVIDER_DESCRIPTOR, null ) );\n        expectedRules.add( new IndexRule( 2, labelId( LABEL2 ), propId( PROP1 ), PROVIDER_DESCRIPTOR, 0L ) );\n\n        assertEquals( expectedRules, listedRules );\n    }","id":79274,"modified_method":"@Test\n    public void shouldListAllIndexRules()\n    {\n        // Given\n        createSchema(\n                index( LABEL1, PROP1 ),\n                index( LABEL1, PROP2 ),\n                uniquenessConstraint( LABEL2, PROP1 ) );\n\n        // When\n        Set<IndexRule> listedRules = asSet( storage.allIndexRules() );\n\n        // Then\n        Set<IndexRule> expectedRules = new HashSet<>();\n        expectedRules.add( new IndexRule( 0, labelId( LABEL1 ), propId( PROP1 ), PROVIDER_DESCRIPTOR, null ) );\n        expectedRules.add( new IndexRule( 1, labelId( LABEL1 ), propId( PROP2 ), PROVIDER_DESCRIPTOR, null ) );\n        expectedRules.add( new IndexRule( 2, labelId( LABEL2 ), propId( PROP1 ), PROVIDER_DESCRIPTOR, 0L ) );\n\n        assertEquals( expectedRules, listedRules );\n    }","commit_id":"7bf58e4787e47d9ff07a0ed6fb210bd8887c4314","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Retrieve the ReportPlugin instances referenced in the specified POM.\n     */\n    private List getReportPluginsForProject( final MavenProject project )\n    {\n        List reportPlugins = project.getReportPlugins();\n\n        if ( ( project.getReporting() == null ) || !project.getReporting().isExcludeDefaults() )\n        {\n            if ( reportPlugins == null )\n            {\n                reportPlugins = new ArrayList();\n            }\n            else\n            {\n                reportPlugins = new ArrayList( reportPlugins );\n            }\n\n            for ( Iterator i = defaultReports.iterator(); i.hasNext(); )\n            {\n                String report = (String) i.next();\n\n                StringTokenizer tok = new StringTokenizer( report, \":\" );\n                if ( tok.countTokens() != 2 )\n                {\n                    logger.warn( \"Invalid default report ignored: '\" + report + \"' (must be groupId:artifactId)\" );\n                }\n                else\n                {\n                    String groupId = tok.nextToken();\n                    String artifactId = tok.nextToken();\n\n                    boolean found = false;\n                    for ( Iterator j = reportPlugins.iterator(); j.hasNext() && !found; )\n                    {\n                        ReportPlugin reportPlugin = (ReportPlugin) j.next();\n                        if ( reportPlugin.getGroupId().equals( groupId )\n                                        && reportPlugin.getArtifactId().equals( artifactId ) )\n                        {\n                            found = true;\n                        }\n                    }\n\n                    if ( !found )\n                    {\n                        ReportPlugin reportPlugin = new ReportPlugin();\n                        reportPlugin.setGroupId( groupId );\n                        reportPlugin.setArtifactId( artifactId );\n                        reportPlugins.add( reportPlugin );\n                    }\n                }\n            }\n        }\n\n        return reportPlugins;\n    }","id":79275,"modified_method":"/**\n     * Retrieve the ReportPlugin instances referenced in the specified POM.\n     */\n    private List getReportPluginsForProject( final MavenProject project )\n    {\n        List reportPlugins = project.getReportPlugins();\n\n        if ( ( project.getReporting() == null ) || !project.getReporting().isExcludeDefaults() )\n        {\n            if ( reportPlugins == null )\n            {\n                reportPlugins = new ArrayList();\n            }\n            else\n            {\n                reportPlugins = new ArrayList( reportPlugins );\n            }\n\n            for ( Iterator i = defaultReports.iterator(); i.hasNext(); )\n            {\n                String report = (String) i.next();\n\n                StringTokenizer tok = new StringTokenizer( report, \":\" );\n                int count = tok.countTokens();\n                if ( count != 2 && count != 3 )\n                {\n                    logger.warn( \"Invalid default report ignored: '\" + report + \"' (must be groupId:artifactId[:version])\" );\n                }\n                else\n                {\n                    String groupId = tok.nextToken();\n                    String artifactId = tok.nextToken();\n                    String version = tok.hasMoreTokens() ? tok.nextToken() : null;\n\n                    boolean found = false;\n                    for ( Iterator j = reportPlugins.iterator(); j.hasNext() && !found; )\n                    {\n                        ReportPlugin reportPlugin = (ReportPlugin) j.next();\n                        if ( reportPlugin.getGroupId().equals( groupId )\n                                        && reportPlugin.getArtifactId().equals( artifactId ) )\n                        {\n                            found = true;\n                        }\n                    }\n\n                    if ( !found )\n                    {\n                        ReportPlugin reportPlugin = new ReportPlugin();\n                        reportPlugin.setGroupId( groupId );\n                        reportPlugin.setArtifactId( artifactId );\n                        reportPlugin.setVersion( version );\n                        reportPlugins.add( reportPlugin );\n                    }\n                }\n            }\n        }\n\n        return reportPlugins;\n    }","commit_id":"9811be2c3e521ddc12f11952fdab75c786eab89f","url":"https://github.com/apache/maven"},{"original_method":"public void handle() {\n\t\tString msg = null;\n\t\tString domain = null;\n\t\tString opcode = null;\n\t\tboolean canContinue = false;\n\t\tStringTokenizer tok;\n\t\tProperties props;\n\n\t\tthis.thread.setName(\"SAMv3Handler \" + _id);\n\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t_log.debug(\"SAMv3 handling started\");\n\n\t\ttry {\n\t\t\tInputStream in = getClientSocket().socket().getInputStream();\n\n\t\t\twhile (true) {\n\t\t\t\tif (shouldStop()) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Stop request found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tString line = DataHelper.readLine(in) ;\n\t\t\t\tif (line==null) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Connection closed by client (line read : null)\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmsg = line.trim();\n\n\t\t\t\tif (_log.shouldLog(Log.DEBUG)) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"New message received: [\" + msg + \"]\");\n\t\t\t\t}\n\n\t\t\t\tif(msg.equals(\"\")) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Ignoring newline\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttok = new StringTokenizer(msg, \" \");\n\t\t\t\tif (tok.countTokens() < 2) {\n\t\t\t\t\t// This is not a correct message, for sure\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Error in message format\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdomain = tok.nextToken();\n\t\t\t\topcode = tok.nextToken();\n\t\t\t\tif (_log.shouldLog(Log.DEBUG)) {\n\t\t\t\t\t_log.debug(\"Parsing (domain: \\\"\" + domain\n\t\t\t\t\t\t\t+ \"\\\"; opcode: \\\"\" + opcode + \"\\\")\");\n\t\t\t\t}\n\t\t\t\tprops = SAMUtils.parseParams(tok);\n\n\t\t\t\tif (domain.equals(\"STREAM\")) {\n\t\t\t\t\tcanContinue = execStreamMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"SESSION\")) {\n\t\t\t\t\tif (i2cpProps != null)\n\t\t\t\t\t\tprops.putAll(i2cpProps); // make sure we've got the i2cp settings\n\t\t\t\t\tcanContinue = execSessionMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"DEST\")) {\n\t\t\t\t\tcanContinue = execDestMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"NAMING\")) {\n\t\t\t\t\tcanContinue = execNamingMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"DATAGRAM\")) {\n\t\t\t\t\t// TODO not yet overridden, ID is ignored, most recent DATAGRAM session is used\n\t\t\t\t\tcanContinue = execDatagramMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"RAW\")) {\n\t\t\t\t\t// TODO not yet overridden, ID is ignored, most recent RAW session is used\n\t\t\t\t\tcanContinue = execRawMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"AUTH\")) {\n\t\t\t\t\tcanContinue = execAuthMessage(opcode, props);\n\t\t\t\t} else {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Unrecognized message domain: \\\"\"\n\t\t\t\t\t\t\t+ domain + \"\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!canContinue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t_log.debug(\"Caught IOException for message [\" + msg + \"]\", e);\n\t\t} catch (Exception e) {\n\t\t\t_log.error(\"Unexpected exception for message [\" + msg + \"]\", e);\n\t\t} finally {\n\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t_log.debug(\"Stopping handler\");\n\t\t\t\n\t\t\tif (!this.stolenSocket)\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tcloseClientSocket();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tif (_log.shouldWarn())\n\t\t\t\t\t\t_log.warn(\"Error closing socket\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (streamForwardingSocket) \n\t\t\t{\n\t\t\t\tif (this.getStreamSession()!=null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t((SAMv3StreamSession)streamSession).stopForwardingIncoming();\n\t\t\t\t\t} catch (SAMException e) {\n\t\t\t\t\t\tif (_log.shouldWarn())\n\t\t\t\t\t\t\t_log.warn(\"Error while stopping forwarding connections\", e);\n\t\t\t\t\t} catch (InterruptedIOException e) {\n\t\t\t\t\t\tif (_log.shouldWarn())\n\t\t\t\t\t\t\t_log.warn(\"Interrupted while stopping forwarding connections\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie();\n\t\t}\n\t}","id":79276,"modified_method":"public void handle() {\n\t\tString msg = null;\n\t\tString domain = null;\n\t\tString opcode = null;\n\t\tboolean canContinue = false;\n\t\tStringTokenizer tok;\n\t\tProperties props;\n\n\t\tthis.thread.setName(\"SAMv3Handler \" + _id);\n\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t_log.debug(\"SAMv3 handling started\");\n\n\t\ttry {\n\t\t\tInputStream in = getClientSocket().socket().getInputStream();\n\n\t\t\twhile (true) {\n\t\t\t\tif (shouldStop()) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Stop request found\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tString line = DataHelper.readLine(in) ;\n\t\t\t\tif (line==null) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Connection closed by client (line read : null)\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmsg = line.trim();\n\n\t\t\t\tif (_log.shouldLog(Log.DEBUG)) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"New message received: [\" + msg + \"]\");\n\t\t\t\t}\n\n\t\t\t\tif(msg.equals(\"\")) {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Ignoring newline\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttok = new StringTokenizer(msg, \" \");\n\t\t\t\tint count = tok.countTokens();\n\t\t\t\tif (count <= 0) {\n\t\t\t\t\t// This is not a correct message, for sure\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Ignoring whitespace\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdomain = tok.nextToken();\n\t\t\t\t// these may not have a second token\n\t\t\t\tif (domain.equals(\"PING\")) {\n\t\t\t\t\texecPingMessage(tok);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (domain.equals(\"PONG\")) {\n\t\t\t\t\texecPongMessage(tok);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (count <= 1) {\n\t\t\t\t\t// This is not a correct message, for sure\n\t\t\t\t\tif (writeString(domain + \" STATUS RESULT=I2P_ERROR MESSAGE=\\\"command not specified\\\"\\n\"))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topcode = tok.nextToken();\n\t\t\t\tif (_log.shouldLog(Log.DEBUG)) {\n\t\t\t\t\t_log.debug(\"Parsing (domain: \\\"\" + domain\n\t\t\t\t\t\t\t+ \"\\\"; opcode: \\\"\" + opcode + \"\\\")\");\n\t\t\t\t}\n\t\t\t\tprops = SAMUtils.parseParams(tok);\n\n\t\t\t\tif (domain.equals(\"STREAM\")) {\n\t\t\t\t\tcanContinue = execStreamMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"SESSION\")) {\n\t\t\t\t\tif (i2cpProps != null)\n\t\t\t\t\t\tprops.putAll(i2cpProps); // make sure we've got the i2cp settings\n\t\t\t\t\tcanContinue = execSessionMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"DEST\")) {\n\t\t\t\t\tcanContinue = execDestMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"NAMING\")) {\n\t\t\t\t\tcanContinue = execNamingMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"DATAGRAM\")) {\n\t\t\t\t\t// TODO not yet overridden, ID is ignored, most recent DATAGRAM session is used\n\t\t\t\t\tcanContinue = execDatagramMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"RAW\")) {\n\t\t\t\t\t// TODO not yet overridden, ID is ignored, most recent RAW session is used\n\t\t\t\t\tcanContinue = execRawMessage(opcode, props);\n\t\t\t\t} else if (domain.equals(\"AUTH\")) {\n\t\t\t\t\tcanContinue = execAuthMessage(opcode, props);\n\t\t\t\t} else {\n\t\t\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t\t\t_log.debug(\"Unrecognized message domain: \\\"\"\n\t\t\t\t\t\t\t+ domain + \"\\\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!canContinue) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t_log.debug(\"Caught IOException for message [\" + msg + \"]\", e);\n\t\t} catch (Exception e) {\n\t\t\t_log.error(\"Unexpected exception for message [\" + msg + \"]\", e);\n\t\t} finally {\n\t\t\tif (_log.shouldLog(Log.DEBUG))\n\t\t\t\t_log.debug(\"Stopping handler\");\n\t\t\t\n\t\t\tif (!this.stolenSocket)\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\tcloseClientSocket();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tif (_log.shouldWarn())\n\t\t\t\t\t\t_log.warn(\"Error closing socket\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (streamForwardingSocket) \n\t\t\t{\n\t\t\t\tif (this.getStreamSession()!=null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t((SAMv3StreamSession)streamSession).stopForwardingIncoming();\n\t\t\t\t\t} catch (SAMException e) {\n\t\t\t\t\t\tif (_log.shouldWarn())\n\t\t\t\t\t\t\t_log.warn(\"Error while stopping forwarding connections\", e);\n\t\t\t\t\t} catch (InterruptedIOException e) {\n\t\t\t\t\t\tif (_log.shouldWarn())\n\t\t\t\t\t\t\t_log.warn(\"Interrupted while stopping forwarding connections\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie();\n\t\t}\n\t}","commit_id":"9b2d416154d5995edb9df571651e9260d9a13597","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n\t\t\ttry {\n\t\t\t\tString header = DataHelper.readLine(is).trim();\n\t\t\t\tStringTokenizer tok = new StringTokenizer(header, \" \");\n\t\t\t\tif (tok.countTokens() < 3) {\n\t\t\t\t\t// This is not a correct message, for sure\n\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString version = tok.nextToken();\n\t\t\t\tif (!version.startsWith(\"3\")) {\n\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString nick = tok.nextToken();\n\t\t\t\tString dest = tok.nextToken();\n\n\t\t\t\tbyte[] data = new byte[is.available()];\n\t\t\t\tis.read(data);\n\t\t\t\tSessionRecord rec = sSessionsHash.get(nick);\n\t\t\t\tif (rec!=null) {\n\t\t\t\t\tProperties sprops = rec.getProps();\n\t\t\t\t\tString pr = sprops.getProperty(\"PROTOCOL\");\n\t\t\t\t\tString fp = sprops.getProperty(\"FROM_PORT\");\n\t\t\t\t\tString tp = sprops.getProperty(\"TO_PORT\");\n\t\t\t\t\twhile (tok.hasMoreTokens()) {\n\t\t\t\t\t\tString t = tok.nextToken();\n\t\t\t\t\t\tif (t.startsWith(\"PROTOCOL=\"))\n\t\t\t\t\t\t\tpr = t.substring(\"PROTOTCOL=\".length());\n\t\t\t\t\t\telse if (t.startsWith(\"FROM_PORT=\"))\n\t\t\t\t\t\t\tfp = t.substring(\"FROM_PORT=\".length());\n\t\t\t\t\t\telse if (t.startsWith(\"TO_PORT=\"))\n\t\t\t\t\t\t\ttp = t.substring(\"TO_PORT=\".length());\n\t\t\t\t\t}\n\t\t\t\t\tint proto = I2PSession.PROTO_UNSPECIFIED;\n\t\t\t\t\tint fromPort = I2PSession.PORT_UNSPECIFIED;\n\t\t\t\t\tint toPort = I2PSession.PORT_UNSPECIFIED;\n\t\t\t\t\tif (pr != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tproto = Integer.parseInt(pr);\n\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fp != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfromPort = Integer.parseInt(fp);\n\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tp != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttoPort = Integer.parseInt(tp);\n\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trec.getHandler().session.sendBytes(dest,data, proto, fromPort, toPort);\n\t\t\t\t} else {\n\t\t\t\t\twarn(\"Dropping datagram, no session for \" + nick);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\twarn(\"Error handling datagram\", e);\n\t\t\t}\n\t\t}","id":79277,"modified_method":"public void run() {\n\t\t\ttry {\n\t\t\t\tString header = DataHelper.readLine(is).trim();\n\t\t\t\tStringTokenizer tok = new StringTokenizer(header, \" \");\n\t\t\t\tif (tok.countTokens() < 3) {\n\t\t\t\t\t// This is not a correct message, for sure\n\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString version = tok.nextToken();\n\t\t\t\tif (!version.startsWith(\"3.\")) {\n\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString nick = tok.nextToken();\n\t\t\t\tString dest = tok.nextToken();\n\n\t\t\t\tSessionRecord rec = sSessionsHash.get(nick);\n\t\t\t\tif (rec!=null) {\n\t\t\t\t\tProperties sprops = rec.getProps();\n\t\t\t\t\tString pr = sprops.getProperty(\"PROTOCOL\");\n\t\t\t\t\tString fp = sprops.getProperty(\"FROM_PORT\");\n\t\t\t\t\tString tp = sprops.getProperty(\"TO_PORT\");\n\t\t\t\t\twhile (tok.hasMoreTokens()) {\n\t\t\t\t\t\tString t = tok.nextToken();\n\t\t\t\t\t\tif (t.startsWith(\"PROTOCOL=\"))\n\t\t\t\t\t\t\tpr = t.substring(\"PROTOTCOL=\".length());\n\t\t\t\t\t\telse if (t.startsWith(\"FROM_PORT=\"))\n\t\t\t\t\t\t\tfp = t.substring(\"FROM_PORT=\".length());\n\t\t\t\t\t\telse if (t.startsWith(\"TO_PORT=\"))\n\t\t\t\t\t\t\ttp = t.substring(\"TO_PORT=\".length());\n\t\t\t\t\t}\n\t\t\t\t\tint proto = I2PSession.PROTO_UNSPECIFIED;\n\t\t\t\t\tint fromPort = I2PSession.PORT_UNSPECIFIED;\n\t\t\t\t\tint toPort = I2PSession.PORT_UNSPECIFIED;\n\t\t\t\t\tif (pr != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tproto = Integer.parseInt(pr);\n\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fp != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfromPort = Integer.parseInt(fp);\n\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tp != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttoPort = Integer.parseInt(tp);\n\t\t\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t\t\twarn(\"Bad datagram header received\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO too many allocations and copies. One here and one in Listener above.\n\t\t\t\t\tbyte[] data = new byte[is.available()];\n\t\t\t\t\tis.read(data);\n\t\t\t\t\trec.getHandler().session.sendBytes(dest,data, proto, fromPort, toPort);\n\t\t\t\t} else {\n\t\t\t\t\twarn(\"Dropping datagram, no session for \" + nick);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\twarn(\"Error handling datagram\", e);\n\t\t\t}\n\t\t}","commit_id":"9b2d416154d5995edb9df571651e9260d9a13597","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected PortletURL getDynamicPortletURL(\n\t\t\tlong plid, int status, HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tLayout layout = LayoutLocalServiceUtil.getLayout(plid);\n\n\t\tlong groupId = layout.getGroupId();\n\n\t\tlong displayPortlet = PortalUtil.getPlidFromPortletId(\n\t\t\tgroupId, PortletKeys.KNOWLEDGE_BASE_DISPLAY);\n\n\t\tString portletId = PortletKeys.KNOWLEDGE_BASE_ARTICLE_DEFAULT_INSTANCE;\n\n\t\tif (displayPortlet > 0) {\n\t\t\tportletId = PortletKeys.KNOWLEDGE_BASE_DISPLAY;\n\t\t}\n\n\t\tPortletURL portletURL = getKBArticleURL(plid, portletId, request);\n\n\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\tportletURL.setParameter(\"status\", String.valueOf(status));\n\t\t}\n\n\t\tif (_PORTLET_ADD_DEFAULT_RESOURCE_CHECK_ENABLED) {\n\t\t\tString token = AuthTokenUtil.getToken(request, plid, portletId);\n\n\t\t\tportletURL.setParameter(\"p_p_auth\", token);\n\t\t}\n\n\t\tportletURL.setPortletMode(PortletMode.VIEW);\n\n\t\tif (displayPortlet == 0) {\n\t\t\tportletURL.setWindowState(LiferayWindowState.MAXIMIZED);\n\t\t}\n\n\t\treturn portletURL;\n\t}","id":79278,"modified_method":"protected PortletURL getDynamicPortletURL(\n\t\t\tlong plid, int status, HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tLayout layout = LayoutLocalServiceUtil.getLayout(plid);\n\n\t\tlong selPlid = PortalUtil.getPlidFromPortletId(\n\t\t\tlayout.getGroupId(), PortletKeys.KNOWLEDGE_BASE_DISPLAY);\n\n\t\tString portletId = PortletKeys.KNOWLEDGE_BASE_ARTICLE_DEFAULT_INSTANCE;\n\n\t\tif (selPlid != LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\t\t\tportletId = PortletKeys.KNOWLEDGE_BASE_DISPLAY;\n\t\t}\n\n\t\tPortletURL portletURL = getKBArticleURL(plid, portletId, request);\n\n\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\tportletURL.setParameter(\"status\", String.valueOf(status));\n\t\t}\n\n\t\tif (_PORTLET_ADD_DEFAULT_RESOURCE_CHECK_ENABLED) {\n\t\t\tString token = AuthTokenUtil.getToken(request, plid, portletId);\n\n\t\t\tportletURL.setParameter(\"p_p_auth\", token);\n\t\t}\n\n\t\tportletURL.setPortletMode(PortletMode.VIEW);\n\n\t\tif (selPlid == LayoutConstants.DEFAULT_PARENT_LAYOUT_ID) {\n\t\t\tportletURL.setWindowState(LiferayWindowState.MAXIMIZED);\n\t\t}\n\n\t\treturn portletURL;\n\t}","commit_id":"01e1d5eb1fe620da8b61e22d889b5104aa914260","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getEntryURL(\n\t\t\tFileVersion fileVersion, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = serviceContext.getThemeDisplay();\n\n\t\tUser user = themeDisplay.getUser();\n\n\t\tGroup group = user.getGroup();\n\n\t\tlong portletPlid = PortalUtil.getPlidFromPortletId(\n\t\t\tgroup.getGroupId(), true, PortletKeys.DOCUMENT_LIBRARY);\n\n\t\tPortletURL portletURL = null;\n\n\t\tif (portletPlid != 0) {\n\t\t\tportletURL = PortletURLFactoryUtil.create(\n\t\t\t\tserviceContext.getLiferayPortletRequest(),\n\t\t\t\tPortletKeys.DOCUMENT_LIBRARY, portletPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\t\t}\n\t\telse {\n\t\t\tLiferayPortletResponse liferayPortletResponse =\n\t\t\t\tserviceContext.getLiferayPortletResponse();\n\n\t\t\tportletURL = liferayPortletResponse.createRenderURL(\n\t\t\t\tPortletKeys.DOCUMENT_LIBRARY);\n\t\t}\n\n\t\t_setPortletURLWindowState(portletURL, WindowState.NORMAL);\n\n\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/document_library/view_file_entry\");\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"fileEntryId\", String.valueOf(fileVersion.getFileEntryId()));\n\n\t\treturn portletURL.toString();\n\t}","id":79279,"modified_method":"protected String getEntryURL(\n\t\t\tFileVersion fileVersion, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tlong plid = serviceContext.getPlid();\n\n\t\tlong controlPanelPlid = PortalUtil.getControlPanelPlid(\n\t\t\tserviceContext.getCompanyId());\n\n\t\tif (plid == controlPanelPlid) {\n\t\t\tplid = PortalUtil.getPlidFromPortletId(\n\t\t\t\tfileVersion.getGroupId(), PortletKeys.DOCUMENT_LIBRARY);\n\t\t}\n\n\t\tif (plid == LayoutConstants.DEFAULT_PLID) {\n\t\t\tplid = controlPanelPlid;\n\t\t}\n\n\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\trequest, PortletKeys.DOCUMENT_LIBRARY, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/document_library/view_file_entry\");\n\t\tportletURL.setParameter(\n\t\t\t\"fileEntryId\", String.valueOf(fileVersion.getFileEntryId()));\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"ea37455cfb4d03813ccd3098b17ba801de2ee1e4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getTitleText(\n\t\t\tLocale locale, String className, long classPK, String title)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNotNull(title)) {\n\t\t\treturn title;\n\t\t}\n\n\t\tif (className.equals(BookmarksFolder.class.getName())) {\n\t\t\treturn BookmarksFolderLocalServiceUtil.getBookmarksFolder(classPK).getName();\n\t\t}\n\t\telse if (className.equals(BlogsEntry.class.getName())) {\n\t\t\ttitle = \"Blog at \";\n\t\t}\n\t\telse if (className.equals(Layout.class.getName())) {\n\t\t\treturn LayoutLocalServiceUtil.getLayout(classPK).getName(locale);\n\t\t}\n\t\telse if (className.equals(MBCategory.class.getName())) {\n\t\t\ttitle = \"Message Board at \";\n\t\t}\n\t\telse if (className.equals(WikiNode.class.getName())) {\n\t\t\treturn WikiNodeLocalServiceUtil.getWikiNode(classPK).getName();\n\t\t}\n\n\t\ttry {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(classPK);\n\n\t\t\ttitle += group.getDescriptiveName(locale);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = String.valueOf(classPK);\n\t\t}\n\n\t\treturn title;\n\t}","id":79280,"modified_method":"public static String getTitleText(\n\t\t\tLocale locale, String className, long classPK, String title)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNotNull(title)) {\n\t\t\treturn title;\n\t\t}\n\n\t\tif (className.equals(BlogsEntry.class.getName())) {\n\t\t\ttitle = \"Blog at \";\n\t\t}\n\t\telse if (className.equals(BookmarksFolder.class.getName())) {\n\t\t\tBookmarksFolder bookmarksFolder =\n\t\t\t\tBookmarksFolderLocalServiceUtil.getBookmarksFolder(classPK);\n\n\t\t\treturn bookmarksFolder.getName();\n\t\t}\n\t\telse if (className.equals(Layout.class.getName())) {\n\t\t\tLayout layout = LayoutLocalServiceUtil.getLayout(classPK);\n\n\t\t\treturn layout.getName(locale);\n\t\t}\n\t\telse if (className.equals(MBCategory.class.getName())) {\n\t\t\ttitle = \"Message Board at \";\n\t\t}\n\t\telse if (className.equals(WikiNode.class.getName())) {\n\t\t\tWikiNode wikiNode = WikiNodeLocalServiceUtil.getWikiNode(classPK);\n\n\t\t\treturn wikiNode.getName();\n\t\t}\n\n\t\ttry {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(classPK);\n\n\t\t\ttitle += group.getDescriptiveName(locale);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = String.valueOf(classPK);\n\t\t}\n\n\t\treturn title;\n\t}","commit_id":"08a792187ad0e64724ab3f58c9ee7e3ce5e17328","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static String getAssetURLViewInContext(\n\t\t\tThemeDisplay themeDisplay, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (className.equals(BlogsEntry.class.getName())) {\n\t\t\treturn PortalUtil.getLayoutFullURL(classPK, PortletKeys.BLOGS);\n\t\t}\n\n\t\tif (className.equals(Layout.class.getName())) {\n\t\t\treturn PortalUtil.getLayoutFullURL(\n\t\t\t\tLayoutLocalServiceUtil.getLayout(classPK), themeDisplay);\n\t\t}\n\n\t\tif (className.equals(MBCategory.class.getName())) {\n\t\t\treturn PortalUtil.getLayoutFullURL(\n\t\t\t\tclassPK, PortletKeys.MESSAGE_BOARDS);\n\t\t}\n\n\t\tif (className.equals(WikiNode.class.getName())) {\n\t\t\tlong wikiPlid;\n\n\t\t\twikiPlid = PortalUtil.getPlidFromPortletId(themeDisplay.getScopeGroupId(), PortletKeys.WIKI);\n\t\t\tif (wikiPlid == 0) {\n\t\t\t\twikiPlid = PortalUtil.getPlidFromPortletId(themeDisplay.getScopeGroupId(), PortletKeys.WIKI_DISPLAY);\n\t\t\t}\n\t\t\tLayout wikiLayout = null;\n\t\t\tif (wikiPlid != 0) {\n\t\t\t\twikiLayout = LayoutLocalServiceUtil.getLayout(wikiPlid);\n\n\t\t\t\tString layoutFullURL = PortalUtil.getLayoutFullURL(wikiLayout, themeDisplay);\n\n\t\t\t\tStringBuilder wikiNodeURL = new StringBuilder();\n\n\t\t\t\twikiNodeURL.append(layoutFullURL);\n\t\t\t\twikiNodeURL.append(Portal.FRIENDLY_URL_SEPARATOR);\n\t\t\t\twikiNodeURL.append(\"wiki\");\n\t\t\t\twikiNodeURL.append(StringPool.SLASH);\n\t\t\t\twikiNodeURL.append(classPK);\n\t\t\t\twikiNodeURL.append(StringPool.SLASH);\n\t\t\t\twikiNodeURL.append(\"all_pages\");\n\n\t\t\t\treturn wikiNodeURL.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":79281,"modified_method":"public static String getAssetURLViewInContext(\n\t\t\tThemeDisplay themeDisplay, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (className.equals(BlogsEntry.class.getName())) {\n\t\t\treturn PortalUtil.getLayoutFullURL(classPK, PortletKeys.BLOGS);\n\t\t}\n\n\t\tif (className.equals(Layout.class.getName())) {\n\t\t\treturn PortalUtil.getLayoutFullURL(\n\t\t\t\tLayoutLocalServiceUtil.getLayout(classPK), themeDisplay);\n\t\t}\n\n\t\tif (className.equals(MBCategory.class.getName())) {\n\t\t\treturn PortalUtil.getLayoutFullURL(\n\t\t\t\tclassPK, PortletKeys.MESSAGE_BOARDS);\n\t\t}\n\n\t\tif (className.equals(WikiNode.class.getName())) {\n\t\t\tlong plid = PortalUtil.getPlidFromPortletId(\n\t\t\t\tthemeDisplay.getScopeGroupId(), PortletKeys.WIKI);\n\n\t\t\tif (plid == 0) {\n\t\t\t\tplid = PortalUtil.getPlidFromPortletId(\n\t\t\t\t\tthemeDisplay.getScopeGroupId(), PortletKeys.WIKI_DISPLAY);\n\t\t\t}\n\n\t\t\tif (plid == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tLayout layout = LayoutLocalServiceUtil.getLayout(plid);\n\n\t\t\tString layoutFullURL = PortalUtil.getLayoutFullURL(\n\t\t\t\tlayout, themeDisplay);\n\n\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\tsb.append(layoutFullURL);\n\t\t\tsb.append(Portal.FRIENDLY_URL_SEPARATOR);\n\t\t\tsb.append(\"wiki/\");\n\t\t\tsb.append(classPK);\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"08a792187ad0e64724ab3f58c9ee7e3ce5e17328","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void nodeDeleted(@NotNull ASTNode parent, @NotNull final ASTNode child) {\n    PsiElement psiParent = parent.getPsi();\n    PsiElement psiChild = myIsPhysicalScope ? child.getPsi() : null;\n\n    if (psiParent != null && psiChild != null) {\n      PsiTreeChangeEventImpl event = new PsiTreeChangeEventImpl(myPsiManager);\n      event.setParent(psiParent);\n      event.setChild(psiChild);\n      myPsiManager.beforeChildRemoval(event);\n    }\n\n    myEvent.addElementaryChange(child, ChangeInfoImpl.create(ChangeInfo.REMOVED, child));\n    ((TreeElement)child).rawRemove();\n    ((CompositeElement)parent).subtreeChanged();\n\n    if (DEBUG) {\n      DebugUtil.checkTreeStructure(parent);\n    }\n  }","id":79282,"modified_method":"public void nodeDeleted(@NotNull ASTNode parent, @NotNull final ASTNode child) {\n    PsiElement psiParent = parent.getPsi();\n    PsiElement psiChild = myIsPhysicalScope ? child.getPsi() : null;\n\n    if (psiParent != null && psiChild != null) {\n      PsiTreeChangeEventImpl event = new PsiTreeChangeEventImpl(myPsiManager);\n      event.setParent(psiParent);\n      event.setChild(psiChild);\n      myPsiManager.beforeChildRemoval(event);\n    }\n\n    myEvent.addElementaryChange(child, ChangeInfoImpl.create(ChangeInfo.REMOVED, child));\n    ((TreeElement)child).rawRemove();\n    ((CompositeElement)parent).subtreeChanged();\n\n    DebugUtil.checkTreeStructureIfConfigured(parent);\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void nodeInserted(@NotNull final ASTNode oldParent, @NotNull ASTNode node, final int pos) {\n    ASTNode anchor = null;\n    for (int i = 0; i < pos; i++) {\n      anchor = anchor == null ? oldParent.getFirstChildNode() : anchor.getTreeNext();\n    }\n\n    ((TreeElement)node).rawRemove();\n    if (anchor != null) {\n      ((TreeElement)anchor).rawInsertAfterMe((TreeElement)node);\n    }\n    else {\n      if (oldParent.getFirstChildNode() != null) {\n        ((TreeElement)oldParent.getFirstChildNode()).rawInsertBeforeMe((TreeElement)node);\n      }\n      else {\n        ((CompositeElement)oldParent).rawAddChildren((TreeElement)node);\n      }\n    }\n\n    myEvent.addElementaryChange(node, ChangeInfoImpl.create(ChangeInfo.ADD, node));\n    ((TreeElement)node).clearCaches();\n    ((CompositeElement)oldParent).subtreeChanged();\n\n    if (DEBUG) {\n      DebugUtil.checkTreeStructure(oldParent);\n    }\n  }","id":79283,"modified_method":"public void nodeInserted(@NotNull final ASTNode oldParent, @NotNull ASTNode node, final int pos) {\n    ASTNode anchor = null;\n    for (int i = 0; i < pos; i++) {\n      anchor = anchor == null ? oldParent.getFirstChildNode() : anchor.getTreeNext();\n    }\n\n    ((TreeElement)node).rawRemove();\n    if (anchor != null) {\n      ((TreeElement)anchor).rawInsertAfterMe((TreeElement)node);\n    }\n    else {\n      if (oldParent.getFirstChildNode() != null) {\n        ((TreeElement)oldParent.getFirstChildNode()).rawInsertBeforeMe((TreeElement)node);\n      }\n      else {\n        ((CompositeElement)oldParent).rawAddChildren((TreeElement)node);\n      }\n    }\n\n    myEvent.addElementaryChange(node, ChangeInfoImpl.create(ChangeInfo.ADD, node));\n    ((TreeElement)node).clearCaches();\n    ((CompositeElement)oldParent).subtreeChanged();\n\n    DebugUtil.checkTreeStructureIfConfigured(oldParent);\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void nodeReplaced(@NotNull ASTNode oldNode, @NotNull ASTNode newNode) {\n    if (oldNode instanceof FileElement && newNode instanceof FileElement) {\n      BlockSupportImpl.replaceFileElement(myFile, (FileElement)oldNode, (FileElement)newNode, myPsiManager);\n    }\n    else {\n      final ASTNode parent = oldNode.getTreeParent();\n      assert parent != null : \"old:\" + oldNode + \" new:\" + newNode;\n\n      TreeUtil.ensureParsed(oldNode);\n\n      final PsiElement psiParent = parent.getPsi();\n      final PsiElement psiChild = myIsPhysicalScope ? oldNode.getPsi() : null;\n      if (psiParent != null && psiChild != null) {\n        final PsiTreeChangeEventImpl event = new PsiTreeChangeEventImpl(myPsiManager);\n        event.setParent(psiParent);\n        event.setChild(psiChild);\n        myPsiManager.beforeChildReplacement(event);\n      }\n\n      ((TreeElement)newNode).rawRemove();\n      ((TreeElement)oldNode).rawReplaceWithList((TreeElement)newNode);\n\n      final ReplaceChangeInfoImpl change = (ReplaceChangeInfoImpl)ChangeInfoImpl.create(ChangeInfo.REPLACE, newNode);\n\n      change.setReplaced(oldNode);\n      myEvent.addElementaryChange(newNode, change);\n      ((TreeElement)newNode).clearCaches();\n      if (!(newNode instanceof FileElement)) {\n        ((CompositeElement)newNode.getTreeParent()).subtreeChanged();\n      }\n\n      if (DEBUG) {\n        DebugUtil.checkTreeStructure(parent);\n      }\n    }\n  }","id":79284,"modified_method":"public void nodeReplaced(@NotNull ASTNode oldNode, @NotNull ASTNode newNode) {\n    if (oldNode instanceof FileElement && newNode instanceof FileElement) {\n      BlockSupportImpl.replaceFileElement(myFile, (FileElement)oldNode, (FileElement)newNode, myPsiManager);\n    }\n    else {\n      final ASTNode parent = oldNode.getTreeParent();\n      assert parent != null : \"old:\" + oldNode + \" new:\" + newNode;\n\n      TreeUtil.ensureParsed(oldNode);\n\n      final PsiElement psiParent = parent.getPsi();\n      final PsiElement psiChild = myIsPhysicalScope ? oldNode.getPsi() : null;\n      if (psiParent != null && psiChild != null) {\n        final PsiTreeChangeEventImpl event = new PsiTreeChangeEventImpl(myPsiManager);\n        event.setParent(psiParent);\n        event.setChild(psiChild);\n        myPsiManager.beforeChildReplacement(event);\n      }\n\n      ((TreeElement)newNode).rawRemove();\n      ((TreeElement)oldNode).rawReplaceWithList((TreeElement)newNode);\n\n      final ReplaceChangeInfoImpl change = (ReplaceChangeInfoImpl)ChangeInfoImpl.create(ChangeInfo.REPLACE, newNode);\n\n      change.setReplaced(oldNode);\n      myEvent.addElementaryChange(newNode, change);\n      ((TreeElement)newNode).clearCaches();\n      if (!(newNode instanceof FileElement)) {\n        ((CompositeElement)newNode.getTreeParent()).subtreeChanged();\n      }\n\n      DebugUtil.checkTreeStructureIfConfigured(parent);\n    }\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int toBuffer(ASTNode element, char[] buffer, int offset, TokenSet skipTypes) {\n    if (element instanceof ForeignLeafPsiElement ||\n        skipTypes != null && skipTypes.contains(element.getElementType())) {\n      return offset;\n    }\n\n    if (element instanceof LeafElement) {\n      return ((LeafElement)element).copyTo(buffer, offset);\n    }\n\n    if (element instanceof LazyParseableElement) {\n      LazyParseableElement lpe = (LazyParseableElement)element;\n      int lpeResult = lpe.copyTo(buffer, offset);\n      if (lpeResult > 0) return lpeResult;\n    }\n\n    int curOffset = offset;\n    for (TreeElement child = (TreeElement)element.getFirstChildNode(); child != null; child = child.getTreeNext()) {\n      curOffset = toBuffer(child, buffer, curOffset, skipTypes);\n    }\n    return curOffset;\n  }","id":79285,"modified_method":"public static int toBuffer(@NotNull final ASTNode element, @Nullable final char[] buffer, int offset, @Nullable final TokenSet skipTypes) {\n    final int[] result = {offset};\n\n    ((TreeElement)element).acceptTree(new RecursiveTreeElementWalkingVisitor(false) {\n      @Override\n      public void visitLeaf(LeafElement element) {\n        if (element instanceof ForeignLeafPsiElement ||\n            skipTypes != null && skipTypes.contains(element.getElementType())) {\n          return;\n        }\n\n        result[0] = element.copyTo(buffer, result[0]);\n      }\n\n      @Override\n      public void visitComposite(CompositeElement composite) {\n        if (element instanceof LazyParseableElement) {\n          LazyParseableElement lpe = (LazyParseableElement)element;\n          int lpeResult = lpe.copyTo(buffer, result[0]);\n          if (lpeResult > 0) {\n            result[0] = lpeResult;\n            return;\n          }\n        }\n\n        super.visitComposite(composite);\n      }\n    });\n\n    return result[0];\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void checkTreeStructure(@NotNull ASTNode anyElement) {\n    ASTNode root = anyElement;\n    while (root.getTreeParent() != null) {\n      root = root.getTreeParent();\n    }\n    if (root instanceof CompositeElement) {\n      synchronized (PsiLock.LOCK) {\n        checkSubtree((CompositeElement)root);\n      }\n    }\n  }","id":79286,"modified_method":"public static void checkTreeStructure(@Nullable ASTNode anyElement) {\n    if (anyElement == null) return;\n    ASTNode root = anyElement;\n    while (root.getTreeParent() != null) {\n      root = root.getTreeParent();\n    }\n    if (root instanceof CompositeElement) {\n      synchronized (PsiLock.LOCK) {\n        checkSubtree((CompositeElement)root);\n      }\n    }\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<HighlightInfo> doTest(final long maxMillis) throws Exception {\n    @NonNls String filePath = LightAdvHighlightingTest.BASE_PATH + \"/\" + getTestName(false) + \".java\";\n    configureByFile(filePath);\n\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n    getFile().getText(); //to load text\n    CodeInsightTestFixtureImpl.ensureIndexesUpToDate(getProject());\n\n    final List<HighlightInfo> infos = new ArrayList<HighlightInfo>();\n    PlatformTestUtil.assertTiming(\"Performance failed\", maxMillis, new Runnable() {\n      @Override\n      public void run() {\n        infos.clear();\n        DaemonCodeAnalyzerImpl.getInstance(getProject()).restart();\n        List<HighlightInfo> h = doHighlighting();\n        infos.addAll(h);\n      }\n    });\n    return DaemonAnalyzerTestCase.filter(infos, HighlightSeverity.ERROR);\n  }","id":79287,"modified_method":"private List<HighlightInfo> doTest(final long maxMillis) throws Exception {\n    @NonNls String filePath = LightAdvHighlightingTest.BASE_PATH + \"/\" + getTestName(false) + \".java\";\n    configureByFile(filePath);\n\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n    getFile().getText(); //to load text\n    CodeInsightTestFixtureImpl.ensureIndexesUpToDate(getProject());\n\n    final List<HighlightInfo> infos = new ArrayList<HighlightInfo>();\n    PlatformTestUtil.assertTiming(\"Performance failed\", maxMillis, new Runnable() {\n      @Override\n      public void run() {\n        infos.clear();\n        DaemonCodeAnalyzer.getInstance(getProject()).restart();\n        List<HighlightInfo> h = doHighlighting();\n        infos.addAll(h);\n      }\n    });\n    return DaemonAnalyzerTestCase.filter(infos, HighlightSeverity.ERROR);\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getTextSkipWhiteSpaceAndComments(final ASTNode element) {\n    int length = AstBufferUtil.toBuffer(element, null, 0, StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n    char[] buffer = new char[length];\n    AstBufferUtil.toBuffer(element, buffer, 0, StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n    return new String(buffer);\n  }","id":79288,"modified_method":"public static String getTextSkipWhiteSpaceAndComments(final ASTNode element) {\n    return AstBufferUtil.getTextSkippingTokens(element, StdTokenSets.WHITE_SPACE_OR_COMMENT_BIT_SET);\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ASTNode parseContents(ASTNode chameleon) {\n    final CharTable table = SharedImplUtil.findCharTableByTree(chameleon);\n    final FileElement treeElement = new DummyHolder(((TreeElement)chameleon).getManager(), null, table).getTreeElement();\n    final PsiFile file = (PsiFile)TreeUtil.getFileElement((TreeElement)chameleon).getPsi();\n    PsiFile originalFile = file.getOriginalFile();\n\n    final TemplateLanguageFileViewProvider viewProvider = (TemplateLanguageFileViewProvider)originalFile.getViewProvider();\n\n    final Language language = viewProvider.getTemplateDataLanguage();\n    final CharSequence chars = chameleon.getChars();\n\n    final Lexer baseLexer = createBaseLexer(viewProvider);\n    final CharSequence templateText = createTemplateText(chars, baseLexer);\n    final PsiFile templateFile = createFromText(language, templateText, file.getManager());\n\n    final TreeElement parsed = ((PsiFileImpl)templateFile).calcTreeElement();\n    Lexer langLexer = LanguageParserDefinitions.INSTANCE.forLanguage(language).createLexer(file.getProject());\n    final Lexer lexer = new MergingLexerAdapter(\n      new TemplateBlackAndWhiteLexer(createBaseLexer(viewProvider), langLexer, myTemplateElementType, myOuterElementType),\n      TokenSet.create(myTemplateElementType, myOuterElementType));\n    lexer.start(chars);\n    insertOuters(parsed, lexer, table);\n\n    if (parsed != null) {\n      final TreeElement element = parsed.getFirstChildNode();\n      if (element != null) {\n        treeElement.rawAddChildren(element);\n      }\n    }\n\n    treeElement.clearCaches();\n    treeElement.subtreeChanged();\n    return treeElement.getFirstChildNode();\n  }","id":79289,"modified_method":"public ASTNode parseContents(ASTNode chameleon) {\n    final CharTable table = SharedImplUtil.findCharTableByTree(chameleon);\n    final FileElement treeElement = new DummyHolder(((TreeElement)chameleon).getManager(), null, table).getTreeElement();\n    final PsiFile file = (PsiFile)TreeUtil.getFileElement((TreeElement)chameleon).getPsi();\n    PsiFile originalFile = file.getOriginalFile();\n\n    final TemplateLanguageFileViewProvider viewProvider = (TemplateLanguageFileViewProvider)originalFile.getViewProvider();\n\n    final Language language = viewProvider.getTemplateDataLanguage();\n    final CharSequence chars = chameleon.getChars();\n\n    final Lexer baseLexer = createBaseLexer(viewProvider);\n    final CharSequence templateText = createTemplateText(chars, baseLexer);\n    final PsiFile templateFile = createFromText(language, templateText, file.getManager());\n\n    final TreeElement parsed = ((PsiFileImpl)templateFile).calcTreeElement();\n    Lexer langLexer = LanguageParserDefinitions.INSTANCE.forLanguage(language).createLexer(file.getProject());\n    final Lexer lexer = new MergingLexerAdapter(\n      new TemplateBlackAndWhiteLexer(createBaseLexer(viewProvider), langLexer, myTemplateElementType, myOuterElementType),\n      TokenSet.create(myTemplateElementType, myOuterElementType));\n    lexer.start(chars);\n    insertOuters(parsed, lexer, table);\n\n    if (parsed != null) {\n      final TreeElement element = parsed.getFirstChildNode();\n      if (element != null) {\n        ((CompositeElement)parsed).rawRemoveAllChildren();\n        treeElement.rawAddChildren(element);\n      }\n    }\n\n    treeElement.clearCaches();\n    treeElement.subtreeChanged();\n    TreeElement childNode = treeElement.getFirstChildNode();\n\n    DebugUtil.checkTreeStructureIfConfigured(parsed);\n    DebugUtil.checkTreeStructureIfConfigured(treeElement);\n    DebugUtil.checkTreeStructureIfConfigured(chameleon);\n    DebugUtil.checkTreeStructureIfConfigured(file.getNode());\n    DebugUtil.checkTreeStructureIfConfigured(originalFile.getNode());\n\n    return childNode;\n  }","commit_id":"b376e297db4355e92c738395a696b911682f6989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<BundleRevision> createLocalizationRevisionList(BundleRevision br)\n    {\n        // If the revision is a fragment, then we actually need\n        // to search its host and associated fragments for its\n        // localization information. So, check to see if there\n        // are any hosts and then use the one with the highest\n        // version instead of the fragment itself. If there are\n        // no hosts, but the revision is a fragment, then just\n        // search the revision itself.\n        if (Util.isFragment(br))\n        {\n            if (br.getWiring() != null)\n            {\n                List<BundleWire> hostWires = br.getWiring().getRequiredWires(null);\n                if ((hostWires != null) && (hostWires.size() > 0))\n                {\n                    br = hostWires.get(0).getProviderWiring().getRevision();\n                    for (int hostIdx = 1; hostIdx < hostWires.size(); hostIdx++)\n                    {\n                        if (br.getVersion().compareTo(\n                            hostWires.get(hostIdx).getProviderWiring().getRevision().getVersion()) < 0)\n                        {\n                            br = hostWires.get(hostIdx).getProviderWiring().getRevision();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Create a list of the revision and any attached fragment revisions.\n        List<BundleRevision> result = new ArrayList<BundleRevision>();\n        result.add(br);\n        List<BundleRevision> fragments = ((BundleWiringImpl) br.getWiring()).getFragments();\n        if (fragments != null)\n        {\n            result.addAll(fragments);\n        }\n        return result;\n    }","id":79290,"modified_method":"private static List<BundleRevision> createLocalizationRevisionList(BundleRevision br)\n    {\n        // If the revision is a fragment, then we actually need\n        // to search its host and associated fragments for its\n        // localization information. So, check to see if there\n        // are any hosts and then use the one with the highest\n        // version instead of the fragment itself. If there are\n        // no hosts, but the revision is a fragment, then just\n        // search the revision itself.\n        if (Util.isFragment(br))\n        {\n            if (br.getWiring() != null)\n            {\n                List<BundleWire> hostWires = br.getWiring().getRequiredWires(null);\n                if ((hostWires != null) && (hostWires.size() > 0))\n                {\n                    br = hostWires.get(0).getProviderWiring().getRevision();\n                    for (int hostIdx = 1; hostIdx < hostWires.size(); hostIdx++)\n                    {\n                        if (br.getVersion().compareTo(\n                            hostWires.get(hostIdx).getProviderWiring().getRevision().getVersion()) < 0)\n                        {\n                            br = hostWires.get(hostIdx).getProviderWiring().getRevision();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Create a list of the revision and any attached fragment revisions.\n        List<BundleRevision> result = new ArrayList<BundleRevision>();\n        result.add(br);\n        BundleWiring wiring = br.getWiring();\n        if (wiring != null)\n        {\n// TODO: OSGi R4.3 - Technically, I think we can get the fragments using standard\n//       R4.3 API once we get everything implemented.\n            List<BundleRevision> fragments = ((BundleWiringImpl) wiring).getFragments();\n            if (fragments != null)\n            {\n                result.addAll(fragments);\n            }\n        }\n        return result;\n    }","commit_id":"6d4764b68341891fcdc5749804f48ecc5c52d35f","url":"https://github.com/apache/felix"},{"original_method":"public synchronized List<BundleWire> getProvidedWires(\n        BundleRevision revision, String namespace)\n    {\n        List<BundleWire> providedWires = new ArrayList<BundleWire>();\n\n        Map<BundleCapability, Set<BundleWire>> providedCaps =\n            m_dependentsMap.get(revision);\n        if (providedCaps != null)\n        {\n            // The wires are supposed to be in declared capability order, so\n            // get the capability list from the revision's wiring, which is\n            // in declared order (including fragments), and use it to create\n            // the provided wire list in declared order.\n            List<BundleCapability> resolvedCaps =\n                revision.getWiring().getCapabilities(namespace);\n            for (BundleCapability resolvedCap : resolvedCaps)\n            {\n                Set<BundleWire> dependentWires = providedCaps.get(resolvedCap);\n                if (dependentWires != null)\n                {\n                    providedWires.addAll(dependentWires);\n                }\n            }\n        }\n\n        return providedWires;\n    }","id":79291,"modified_method":"public synchronized List<BundleWire> getProvidedWires(\n        BundleRevision revision, String namespace)\n    {\n        List<BundleWire> providedWires = new ArrayList<BundleWire>();\n\n        Map<BundleCapability, Set<BundleWire>> providedCaps =\n            m_dependentsMap.get(revision);\n        if (providedCaps != null)\n        {\n            // The wires are supposed to be in declared capability order, so\n            // get the capability list from the revision's wiring, which is\n            // in declared order (including fragments), and use it to create\n            // the provided wire list in declared order.\n            BundleWiring wiring = revision.getWiring();\n            if (wiring != null)\n            {\n                List<BundleCapability> resolvedCaps = wiring.getCapabilities(namespace);\n                for (BundleCapability resolvedCap : resolvedCaps)\n                {\n                    Set<BundleWire> dependentWires = providedCaps.get(resolvedCap);\n                    if (dependentWires != null)\n                    {\n                        providedWires.addAll(dependentWires);\n                    }\n                }\n            }\n        }\n\n        return providedWires;\n    }","commit_id":"f632c43261fe33f0e0c07f2539b1eed3ac604810","url":"https://github.com/apache/felix"},{"original_method":"public synchronized Set<Bundle> getDependentBundles(Bundle bundle)\n    {\n        Set<Bundle> result = new HashSet<Bundle>();\n\n        List<BundleRevision> revisions = bundle.adapt(BundleRevisions.class).getRevisions();\n        for (BundleRevision revision : revisions)\n        {\n// TODO: OSGi R4.3 - This is sort of a hack. We need to special case fragments,\n//       since their dependents are their hosts.\n            if (Util.isFragment(revision))\n            {\n                if (revision.getWiring() != null)\n                {\n                    for (BundleWire wire : revision.getWiring().getRequiredWires(null))\n                    {\n                        result.add(wire.getProviderWiring().getBundle());\n                    }\n                }\n            }\n            else\n            {\n                Map<BundleCapability, Set<BundleWire>> caps =\n                    m_dependentsMap.get(revision);\n                if (caps != null)\n                {\n                    for (Entry<BundleCapability, Set<BundleWire>> entry : caps.entrySet())\n                    {\n                        for (BundleWire dependentWire : entry.getValue())\n                        {\n// TODO: OSGi R4.4 - Eventually we won't need to use the impl type here,\n//       since the plan is to standardize on this method for the OBR spec.\n                            result.add(((BundleWireImpl) dependentWire)\n                                .getRequirer().getBundle());\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }","id":79292,"modified_method":"public synchronized Set<Bundle> getDependentBundles(Bundle bundle)\n    {\n        Set<Bundle> result = new HashSet<Bundle>();\n\n        List<BundleRevision> revisions = bundle.adapt(BundleRevisions.class).getRevisions();\n        for (BundleRevision revision : revisions)\n        {\n// TODO: OSGi R4.3 - This is sort of a hack. We need to special case fragments,\n//       since their dependents are their hosts.\n            if (Util.isFragment(revision))\n            {\n                BundleWiring wiring = revision.getWiring();\n                if (wiring != null)\n                {\n                    for (BundleWire bw : wiring.getRequiredWires(null))\n                    {\n                        result.add(((BundleWireImpl) bw).getProvider().getBundle());\n                    }\n                }\n            }\n            else\n            {\n                Map<BundleCapability, Set<BundleWire>> caps =\n                    m_dependentsMap.get(revision);\n                if (caps != null)\n                {\n                    for (Entry<BundleCapability, Set<BundleWire>> entry : caps.entrySet())\n                    {\n                        for (BundleWire dependentWire : entry.getValue())\n                        {\n// TODO: OSGi R4.4 - Eventually we won't need to use the impl type here,\n//       since the plan is to standardize on this method for the OBR spec.\n                            result.add(((BundleWireImpl) dependentWire)\n                                .getRequirer().getBundle());\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }","commit_id":"f632c43261fe33f0e0c07f2539b1eed3ac604810","url":"https://github.com/apache/felix"},{"original_method":"public synchronized void removeDependencies(Bundle bundle)\n    {\n        List<BundleRevision> revs = bundle.adapt(BundleRevisions.class).getRevisions();\n        for (BundleRevision rev : revs)\n        {\n            BundleWiring wiring = rev.getWiring();\n            if (wiring != null)\n            {\n                for (BundleWire wire : wiring.getRequiredWires(null))\n                {\n                    // The provider wiring may already be null if the framework\n                    // is shutting down, so don't worry about updating dependencies\n                    // in that case.\n                    if (wire.getProviderWiring() != null)\n                    {\n                        Map<BundleCapability, Set<BundleWire>> caps =\n                            m_dependentsMap.get(wire.getProviderWiring().getRevision());\n                        if (caps != null)\n                        {\n                            List<BundleCapability> gc = new ArrayList<BundleCapability>();\n                            for (Entry<BundleCapability, Set<BundleWire>> entry\n                                : caps.entrySet())\n                            {\n                                entry.getValue().remove(wire);\n                                if (entry.getValue().isEmpty())\n                                {\n                                    gc.add(entry.getKey());\n                                }\n                            }\n                            for (BundleCapability cap : gc)\n                            {\n                                caps.remove(cap);\n                            }\n                            if (caps.isEmpty())\n                            {\n// TODO: OSGi R4.4 - Eventually we won't need to use the impl type here,\n//       since the plan is to standardize on this method for the OBR spec.\n                                m_dependentsMap.remove(((BundleWireImpl) wire).getProvider());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":79293,"modified_method":"public synchronized void removeDependencies(Bundle bundle)\n    {\n        List<BundleRevision> revs = bundle.adapt(BundleRevisions.class).getRevisions();\n        for (BundleRevision rev : revs)\n        {\n            BundleWiring wiring = rev.getWiring();\n            if (wiring != null)\n            {\n                for (BundleWire bw : wiring.getRequiredWires(null))\n                {\n// TODO: OSGi R4.4 - Eventually we won't need to use the impl type here,\n//       since the plan is to standardize on this method for the OBR spec.\n                    Map<BundleCapability, Set<BundleWire>> caps =\n                        m_dependentsMap.get(((BundleWireImpl) bw).getProvider());\n                    if (caps != null)\n                    {\n                        List<BundleCapability> gc = new ArrayList<BundleCapability>();\n                        for (Entry<BundleCapability, Set<BundleWire>> entry\n                            : caps.entrySet())\n                        {\n                            entry.getValue().remove(bw);\n                            if (entry.getValue().isEmpty())\n                            {\n                                gc.add(entry.getKey());\n                            }\n                        }\n                        for (BundleCapability cap : gc)\n                        {\n                            caps.remove(cap);\n                        }\n                        if (caps.isEmpty())\n                        {\n// TODO: OSGi R4.4 - Eventually we won't need to use the impl type here,\n//       since the plan is to standardize on this method for the OBR spec.\n                            m_dependentsMap.remove(((BundleWireImpl) bw).getProvider());\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"f632c43261fe33f0e0c07f2539b1eed3ac604810","url":"https://github.com/apache/felix"},{"original_method":"private void markResolvedRevisions(Map<BundleRevision, List<ResolverWire>> wireMap)\n        throws ResolveException\n    {\n        // DO THIS IN THREE PASSES:\n        // 1. Aggregate fragments per host.\n        // 2. Attach wires and fragments to hosts.\n        //    -> If fragments fail to attach, then undo.\n        // 3. Mark hosts and fragments as resolved.\n\n        // First pass.\n        if (wireMap != null)\n        {\n            // First pass: Loop through the wire map to find the host wires\n            // for any fragments and map a host to all of its fragments.\n            Map<BundleRevision, List<BundleRevision>> hosts =\n                new HashMap<BundleRevision, List<BundleRevision>>();\n            for (Entry<BundleRevision, List<ResolverWire>> entry : wireMap.entrySet())\n            {\n                BundleRevision revision = entry.getKey();\n                List<ResolverWire> wires = entry.getValue();\n\n                if (Util.isFragment(revision))\n                {\n                    for (Iterator<ResolverWire> itWires = wires.iterator();\n                        itWires.hasNext(); )\n                    {\n                        ResolverWire w = itWires.next();\n                        List<BundleRevision> fragments = hosts.get(w.getProvider());\n                        if (fragments == null)\n                        {\n                            fragments = new ArrayList<BundleRevision>();\n                            hosts.put(w.getProvider(), fragments);\n                        }\n                        fragments.add(w.getRequirer());\n                    }\n                }\n            }\n\n            // Second pass: Loop through the wire map to do three things:\n            // 1) convert resolver wires to bundle wires 2) create wiring\n            // objects for revisions and 3) record dependencies among\n            // revisions. We don't actually set the wirings here because\n            // that indicates that a revision is resolved and we don't want\n            // to mark anything as resolved unless we succussfully create\n            // all wirings.\n            Map<BundleRevision, BundleWiringImpl> wirings =\n                new HashMap<BundleRevision, BundleWiringImpl>(wireMap.size());\n            for (Entry<BundleRevision, List<ResolverWire>> entry : wireMap.entrySet())\n            {\n                BundleRevision revision = entry.getKey();\n                List<ResolverWire> resolverWires = entry.getValue();\n\n                List<BundleWire> bundleWires =\n                    new ArrayList<BundleWire>(resolverWires.size());\n\n                // Loop through resolver wires to calculate the package\n                // space implied by the wires as well as to record the\n                // dependencies.\n                Map<String, BundleRevision> importedPkgs =\n                    new HashMap<String, BundleRevision>();\n                Map<String, List<BundleRevision>> requiredPkgs =\n                    new HashMap<String, List<BundleRevision>>();\n                for (ResolverWire rw : resolverWires)\n                {\n                    BundleWire bw = new BundleWireImpl(\n                        rw.getRequirer(),\n                        rw.getRequirement(),\n                        rw.getProvider(),\n                        rw.getCapability());\n                    bundleWires.add(bw);\n\n                    m_felix.getDependencies().addDependent(bw);\n\n                    if (Util.isFragment(revision))\n                    {\n                        m_felix.getLogger().log(\n                            Logger.LOG_DEBUG,\n                            \"FRAGMENT WIRE: \" + rw.toString());\n                    }\n                    else\n                    {\n                        m_felix.getLogger().log(Logger.LOG_DEBUG, \"WIRE: \" + rw.toString());\n\n                        if (rw.getCapability().getNamespace()\n                            .equals(BundleRevision.PACKAGE_NAMESPACE))\n                        {\n                            importedPkgs.put(\n                                (String) rw.getCapability().getAttributes()\n                                    .get(BundleRevision.PACKAGE_NAMESPACE),\n                                rw.getProvider());\n                        }\n                        else if (rw.getCapability().getNamespace()\n                            .equals(BundleRevision.BUNDLE_NAMESPACE))\n                        {\n                            Set<String> pkgs = calculateExportedAndReexportedPackages(\n                                    rw.getProvider(),\n                                    wireMap,\n                                    new HashSet<String>(),\n                                    new HashSet<BundleRevision>());\n                            for (String pkg : pkgs)\n                            {\n                                List<BundleRevision> revs = requiredPkgs.get(pkg);\n                                if (revs == null)\n                                {\n                                    revs = new ArrayList<BundleRevision>();\n                                    requiredPkgs.put(pkg, revs);\n                                }\n                                revs.add(rw.getProvider());\n                            }\n                        }\n                    }\n                }\n\n                List<BundleRevision> fragments = hosts.get(revision);\n                try\n                {\n                    wirings.put(\n                        revision,\n                        new BundleWiringImpl(\n                            m_felix.getLogger(),\n                            m_felix.getConfig(),\n                            this,\n                            (BundleRevisionImpl) revision,\n                            fragments,\n                            bundleWires,\n                            importedPkgs,\n                            requiredPkgs));\n                }\n                catch (Exception ex)\n                {\n                    // This is a fatal error, so undo everything and\n                    // throw an exception.\n                    for (Entry<BundleRevision, BundleWiringImpl> wiringEntry\n                        : wirings.entrySet())\n                    {\n                        // Dispose of wiring.\n                        try\n                        {\n                            wiringEntry.getValue().dispose();\n                        }\n                        catch (Exception ex2)\n                        {\n                            // We are in big trouble.\n                            RuntimeException rte = new RuntimeException(\n                                \"Unable to clean up resolver failure.\", ex2);\n                            m_felix.getLogger().log(\n                                Logger.LOG_ERROR,\n                                rte.getMessage(), ex2);\n                            throw rte;\n                        }\n                    }\n\n                    ResolveException re = new ResolveException(\n                        \"Unable to resolve \" + revision,\n                        revision, null);\n                    re.initCause(ex);\n                    m_felix.getLogger().log(\n                        Logger.LOG_ERROR,\n                        re.getMessage(), ex);\n                    throw re;\n                }\n            }\n\n            // Third pass: Loop through the wire map to mark revision as resolved\n            // and update the resolver state.\n            for (Entry<BundleRevision, BundleWiringImpl> entry : wirings.entrySet())\n            {\n                BundleRevisionImpl revision = (BundleRevisionImpl) entry.getKey();\n\n                // Mark revision as resolved.\n                revision.resolve(entry.getValue());\n\n                // Update resolver state to remove substituted capabilities.\n                if (!Util.isFragment(revision))\n                {\n                    // Reindex the revision's capabilities since its resolved\n                    // capabilities could be different than its declared ones.\n                    m_resolverState.addRevision(revision);\n                }\n\n                // Update the state of the revision's bundle to resolved as well.\n                markBundleResolved(revision);\n            }\n        }\n    }","id":79294,"modified_method":"private void markResolvedRevisions(Map<BundleRevision, List<ResolverWire>> wireMap)\n        throws ResolveException\n    {\n        // DO THIS IN THREE PASSES:\n        // 1. Aggregate fragments per host.\n        // 2. Attach wires and fragments to hosts.\n        //    -> If fragments fail to attach, then undo.\n        // 3. Mark hosts and fragments as resolved.\n\n        // First pass.\n        if (wireMap != null)\n        {\n            // First pass: Loop through the wire map to find the host wires\n            // for any fragments and map a host to all of its fragments.\n            Map<BundleRevision, List<BundleRevision>> hosts =\n                new HashMap<BundleRevision, List<BundleRevision>>();\n            for (Entry<BundleRevision, List<ResolverWire>> entry : wireMap.entrySet())\n            {\n                BundleRevision revision = entry.getKey();\n                List<ResolverWire> wires = entry.getValue();\n\n                if (Util.isFragment(revision))\n                {\n                    for (Iterator<ResolverWire> itWires = wires.iterator();\n                        itWires.hasNext(); )\n                    {\n                        ResolverWire w = itWires.next();\n                        List<BundleRevision> fragments = hosts.get(w.getProvider());\n                        if (fragments == null)\n                        {\n                            fragments = new ArrayList<BundleRevision>();\n                            hosts.put(w.getProvider(), fragments);\n                        }\n                        fragments.add(w.getRequirer());\n                    }\n                }\n            }\n\n            // Second pass: Loop through the wire map to do three things:\n            // 1) convert resolver wires to bundle wires 2) create wiring\n            // objects for revisions and 3) record dependencies among\n            // revisions. We don't actually set the wirings here because\n            // that indicates that a revision is resolved and we don't want\n            // to mark anything as resolved unless we succussfully create\n            // all wirings.\n            Map<BundleRevision, BundleWiringImpl> wirings =\n                new HashMap<BundleRevision, BundleWiringImpl>(wireMap.size());\n            for (Entry<BundleRevision, List<ResolverWire>> entry : wireMap.entrySet())\n            {\n                BundleRevision revision = entry.getKey();\n                List<ResolverWire> resolverWires = entry.getValue();\n\n                List<BundleWire> bundleWires =\n                    new ArrayList<BundleWire>(resolverWires.size());\n\n                // Loop through resolver wires to calculate the package\n                // space implied by the wires as well as to record the\n                // dependencies.\n                Map<String, BundleRevision> importedPkgs =\n                    new HashMap<String, BundleRevision>();\n                Map<String, List<BundleRevision>> requiredPkgs =\n                    new HashMap<String, List<BundleRevision>>();\n                for (ResolverWire rw : resolverWires)\n                {\n                    BundleWire bw = new BundleWireImpl(\n                        rw.getRequirer(),\n                        rw.getRequirement(),\n                        rw.getProvider(),\n                        rw.getCapability());\n                    bundleWires.add(bw);\n\n                    if (Util.isFragment(revision))\n                    {\n                        m_felix.getLogger().log(\n                            Logger.LOG_DEBUG,\n                            \"FRAGMENT WIRE: \" + rw.toString());\n                    }\n                    else\n                    {\n                        m_felix.getLogger().log(Logger.LOG_DEBUG, \"WIRE: \" + rw.toString());\n\n                        if (rw.getCapability().getNamespace()\n                            .equals(BundleRevision.PACKAGE_NAMESPACE))\n                        {\n                            importedPkgs.put(\n                                (String) rw.getCapability().getAttributes()\n                                    .get(BundleRevision.PACKAGE_NAMESPACE),\n                                rw.getProvider());\n                        }\n                        else if (rw.getCapability().getNamespace()\n                            .equals(BundleRevision.BUNDLE_NAMESPACE))\n                        {\n                            Set<String> pkgs = calculateExportedAndReexportedPackages(\n                                    rw.getProvider(),\n                                    wireMap,\n                                    new HashSet<String>(),\n                                    new HashSet<BundleRevision>());\n                            for (String pkg : pkgs)\n                            {\n                                List<BundleRevision> revs = requiredPkgs.get(pkg);\n                                if (revs == null)\n                                {\n                                    revs = new ArrayList<BundleRevision>();\n                                    requiredPkgs.put(pkg, revs);\n                                }\n                                revs.add(rw.getProvider());\n                            }\n                        }\n                    }\n                }\n\n                List<BundleRevision> fragments = hosts.get(revision);\n                try\n                {\n                    wirings.put(\n                        revision,\n                        new BundleWiringImpl(\n                            m_felix.getLogger(),\n                            m_felix.getConfig(),\n                            this,\n                            (BundleRevisionImpl) revision,\n                            fragments,\n                            bundleWires,\n                            importedPkgs,\n                            requiredPkgs));\n                }\n                catch (Exception ex)\n                {\n                    // This is a fatal error, so undo everything and\n                    // throw an exception.\n                    for (Entry<BundleRevision, BundleWiringImpl> wiringEntry\n                        : wirings.entrySet())\n                    {\n                        // Dispose of wiring.\n                        try\n                        {\n                            wiringEntry.getValue().dispose();\n                        }\n                        catch (Exception ex2)\n                        {\n                            // We are in big trouble.\n                            RuntimeException rte = new RuntimeException(\n                                \"Unable to clean up resolver failure.\", ex2);\n                            m_felix.getLogger().log(\n                                Logger.LOG_ERROR,\n                                rte.getMessage(), ex2);\n                            throw rte;\n                        }\n                    }\n\n                    ResolveException re = new ResolveException(\n                        \"Unable to resolve \" + revision,\n                        revision, null);\n                    re.initCause(ex);\n                    m_felix.getLogger().log(\n                        Logger.LOG_ERROR,\n                        re.getMessage(), ex);\n                    throw re;\n                }\n            }\n\n            // Third pass: Loop through the wire map to mark revision as resolved\n            // and update the resolver state.\n            for (Entry<BundleRevision, BundleWiringImpl> entry : wirings.entrySet())\n            {\n                BundleRevisionImpl revision = (BundleRevisionImpl) entry.getKey();\n\n                // Mark revision as resolved.\n                BundleWiring wiring = entry.getValue();\n                revision.resolve(entry.getValue());\n\n                // Record dependencies.\n                for (BundleWire bw : wiring.getRequiredWires(null))\n                {\n                    m_felix.getDependencies().addDependent(bw);\n                }\n\n                // Update resolver state to remove substituted capabilities.\n                if (!Util.isFragment(revision))\n                {\n                    // Reindex the revision's capabilities since its resolved\n                    // capabilities could be different than its declared ones.\n                    m_resolverState.addRevision(revision);\n                }\n\n                // Update the state of the revision's bundle to resolved as well.\n                markBundleResolved(revision);\n            }\n        }\n    }","commit_id":"f632c43261fe33f0e0c07f2539b1eed3ac604810","url":"https://github.com/apache/felix"},{"original_method":"public URLHandlersBundleURLConnection(URL url, Felix framework)\n        throws IOException\n    {\n        super(url);\n\n        // If this is an attempt to create a connection to the root of\n        // the bundle, then throw an exception since this isn't possible.\n        // We only allow \"/\" as a valid URL so it can be used as context\n        // for creating other URLs.\n        String path = url.getPath();\n        if ((path == null) || (path.length() == 0) || path.equals(\"/\"))\n        {\n            throw new IOException(\"Resource does not exist: \" + url);\n        }\n\n        m_framework = framework;\n\n        // If we don't have a framework instance, try to find\n        // one from the call context.\n        if (m_framework == null)\n        {\n            Object tmp = URLHandlers.getFrameworkFromContext();\n            if (tmp instanceof Felix)\n            {\n                m_framework = (Felix) tmp;\n            }\n        }\n\n        // If there is still no framework, then error.\n        if (m_framework == null)\n        {\n            throw new IOException(\"Unable to find framework for URL: \" + url);\n        }\n        // Verify that the resource pointed to by the URL exists.\n        // The URL is constructed like this:\n        //     bundle://<revision-id>:<bundle-classpath-index>/<resource-path>\n        // Where <revision-id> = <bundle-id>.<revision>\n        long bundleId = Util.getBundleIdFromRevisionId(url.getHost());\n        Bundle bundle = m_framework.getBundle(bundleId);\n        if (bundle == null)\n        {\n            throw new IOException(\"No bundle associated with resource: \" + url);\n        }\n        m_contentTime = bundle.getLastModified();\n\n        // Get the bundle's revisions to find the target revision.\n        BundleRevisions revisions = bundle.adapt(BundleRevisions.class);\n        if ((revisions == null) || revisions.getRevisions().isEmpty())\n        {\n            throw new IOException(\"Resource does not exist: \" + url);\n        }\n\n        // Search for matching revision name.\n        for (BundleRevision br : revisions.getRevisions())\n        {\n            if (((BundleRevisionImpl) br).getId().equals(url.getHost()))\n            {\n                m_targetRevision = br;\n                break;\n            }\n        }\n\n        // If not found, assume the current revision.\n        if (m_targetRevision == null)\n        {\n            m_targetRevision = revisions.getRevisions().get(0);\n        }\n\n        // If the resource cannot be found at the current class path index,\n        // then search them all in order to see if it can be found. This is\n        // necessary since the user might create a resource URL from another\n        // resource URL and not realize they have the wrong class path entry.\n        // Of course, this approach won't work in cases where there are multiple\n        // resources with the same path, since it will always find the first\n        // one on the class path.\n        m_classPathIdx = url.getPort();\n        if (m_classPathIdx < 0)\n        {\n            m_classPathIdx = 0;\n        }\n// TODO: OSGi R4.3 - This is messed up. We need to fix resource lookup.\n        if (!((BundleRevisionImpl) m_targetRevision)\n            .hasInputStream(m_classPathIdx, url.getPath()))\n        {\n            URL newurl = ((BundleWiringImpl)\n                m_targetRevision.getWiring()).getResourceByDelegation(url.getPath());\n            if (newurl == null)\n            {\n                throw new IOException(\"Resource does not exist: \" + url);\n            }\n            m_classPathIdx = newurl.getPort();\n        }\n    }","id":79295,"modified_method":"public URLHandlersBundleURLConnection(URL url, Felix framework)\n        throws IOException\n    {\n        super(url);\n\n        // If this is an attempt to create a connection to the root of\n        // the bundle, then throw an exception since this isn't possible.\n        // We only allow \"/\" as a valid URL so it can be used as context\n        // for creating other URLs.\n        String path = url.getPath();\n        if ((path == null) || (path.length() == 0) || path.equals(\"/\"))\n        {\n            throw new IOException(\"Resource does not exist: \" + url);\n        }\n\n        m_framework = framework;\n\n        // If we don't have a framework instance, try to find\n        // one from the call context.\n        if (m_framework == null)\n        {\n            Object tmp = URLHandlers.getFrameworkFromContext();\n            if (tmp instanceof Felix)\n            {\n                m_framework = (Felix) tmp;\n            }\n        }\n\n        // If there is still no framework, then error.\n        if (m_framework == null)\n        {\n            throw new IOException(\"Unable to find framework for URL: \" + url);\n        }\n        // Verify that the resource pointed to by the URL exists.\n        // The URL is constructed like this:\n        //     bundle://<revision-id>:<bundle-classpath-index>/<resource-path>\n        // Where <revision-id> = <bundle-id>.<revision>\n        long bundleId = Util.getBundleIdFromRevisionId(url.getHost());\n        Bundle bundle = m_framework.getBundle(bundleId);\n        if (bundle == null)\n        {\n            throw new IOException(\"No bundle associated with resource: \" + url);\n        }\n        m_contentTime = bundle.getLastModified();\n\n        // Get the bundle's revisions to find the target revision.\n        BundleRevisions revisions = bundle.adapt(BundleRevisions.class);\n        if ((revisions == null) || revisions.getRevisions().isEmpty())\n        {\n            throw new IOException(\"Resource does not exist: \" + url);\n        }\n\n        // Search for matching revision name.\n        for (BundleRevision br : revisions.getRevisions())\n        {\n            if (((BundleRevisionImpl) br).getId().equals(url.getHost()))\n            {\n                m_targetRevision = br;\n                break;\n            }\n        }\n\n        // If not found, assume the current revision.\n        if (m_targetRevision == null)\n        {\n            m_targetRevision = revisions.getRevisions().get(0);\n        }\n\n        // If the resource cannot be found at the current class path index,\n        // then search them all in order to see if it can be found. This is\n        // necessary since the user might create a resource URL from another\n        // resource URL and not realize they have the wrong class path entry.\n        // Of course, this approach won't work in cases where there are multiple\n        // resources with the same path, since it will always find the first\n        // one on the class path.\n        m_classPathIdx = url.getPort();\n        if (m_classPathIdx < 0)\n        {\n            m_classPathIdx = 0;\n        }\n        if (!((BundleRevisionImpl) m_targetRevision)\n            .hasInputStream(m_classPathIdx, url.getPath()))\n        {\n            BundleWiring wiring = m_targetRevision.getWiring();\n            ClassLoader cl = (wiring != null) ? wiring.getClassLoader() : null;\n            URL newurl = (cl != null) ? cl.getResource(url.getPath()) : null;\n            if (newurl == null)\n            {\n                throw new IOException(\"Resource does not exist: \" + url);\n            }\n            m_classPathIdx = newurl.getPort();\n        }\n    }","commit_id":"4cd37bd2574874cf88ed7674004f3a71da350e93","url":"https://github.com/apache/felix"},{"original_method":"public void onInequalityAdded(RelationBlock inequality) {\n    if (!solvingInProcess) return;\n    if (inequality.isCheckOnly()) { return; }\n    for (Pair<SNode, SNode> pair : inequality.getInputsAndOutputs()) {\n      SNode input = myState.getRepresentative(pair.o1);\n      SNode output = myState.getRepresentative(pair.o2);\n      if (input == null || output == null) continue;\n\n      for (SNode inputVar : TypesUtil.getVariables(input, myState)) {\n        if (TypesUtil.isVariable(inputVar)) {\n          myNodesInc.add(inputVar);\n          myNodesToBlocksInc.addLink(inputVar, inequality);\n        }\n      }\n      for (SNode outputVar : TypesUtil.getVariables(output, myState)) {\n        if (TypesUtil.isVariable(outputVar)) {\n          myNodesInc.add(outputVar);\n          myNodesToBlocksInc.addLink(outputVar, inequality);\n        }\n      }\n      if (input != output) {\n        for (SNode inputVar : TypesUtil.getVariables(input, myState)) {\n          for (SNode outputVar : TypesUtil.getVariables(output, myState)) {\n            addVariablesLinkInc(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n          }\n        }\n      }\n    }\n    SNode left = myState.getRepresentative(inequality.getLeftNode());\n    SNode right = myState.getRepresentative(inequality.getRightNode());\n    if (TypesUtil.isVariable(left)) {\n      mySolvableLeft.add(left);\n    }\n    if (TypesUtil.isVariable(right)) {\n      mySolvableRight.add(right);\n    }\n  }","id":79296,"modified_method":"public void onInequalityAdded(RelationBlock inequality) {\n    if (!solvingInProcess) return;\n    if (inequality.isCheckOnly()) { return; }\n    for (Pair<SNode, SNode> pair : inequality.getInputsAndOutputs()) {\n      SNode input = myState.getRepresentative(pair.o1);\n      SNode output = myState.getRepresentative(pair.o2);\n      if (input == null || output == null) continue;\n\n      final List<SNode> invars = TypesUtil.getVariables(input, myState);\n      for (SNode inputVar : invars) {\n        if (TypesUtil.isVariable(inputVar)) {\n          myNodesInc.add(inputVar);\n          myNodesToBlocksInc.addLink(inputVar, inequality);\n        }\n      }\n      final List<SNode> outvars = TypesUtil.getVariables(output, myState);\n      for (SNode outputVar : outvars) {\n        if (TypesUtil.isVariable(outputVar)) {\n          myNodesInc.add(outputVar);\n          myNodesToBlocksInc.addLink(outputVar, inequality);\n        }\n      }\n      if (input != output) {\n        for (SNode inputVar : invars) {\n          for (SNode outputVar : outvars) {\n            addVariablesLinkInc(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n          }\n        }\n      }\n    }\n    SNode left = myState.getRepresentative(inequality.getLeftNode());\n    SNode right = myState.getRepresentative(inequality.getRightNode());\n    if (TypesUtil.isVariable(left)) {\n      mySolvableLeft.add(left);\n    }\n    if (TypesUtil.isVariable(right)) {\n      mySolvableRight.add(right);\n    }\n  }","commit_id":"269ac5b0b6265d8a43aa6f27d3e2e9f0e0fdddec","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean processEquation(SNode var, SNode type, EquationInfo info) {\n    SNode source = myState.getNodeMaps().getNode(var);\n    for (SNode innerVar : TypesUtil.getVariables(expandNode(type, false))) {\n      if (getRepresentative(innerVar, false).equals(var)){\n        reportRecursiveType(source, info);\n        return false;\n      }\n    }\n    myState.executeOperation(new AddEquationOperation(var, type, source, info));\n    return true;\n  }","id":79297,"modified_method":"private boolean processEquation(SNode var, SNode type, EquationInfo info) {\n    SNode source = myState.getNodeMaps().getNode(var);\n    for (SNode innerVar : TypesUtil.getVariables(type, myState)) {\n      if (getRepresentative(innerVar, false).equals(var)){\n        reportRecursiveType(source, info);\n        return false;\n      }\n    }\n    myState.executeOperation(new AddEquationOperation(var, type, source, info));\n    return true;\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>(1);\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    Set<SNode> emptySet = new HashSet<SNode>(1);\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n\n      List<SNode> variables = TypesUtil.getVariables(myState.expand(inequality.getRightNode()));\n      variables.addAll(TypesUtil.getVariables(myState.expand(inequality.getLeftNode())));\n      if (variables.size() == 0) {\n        Set<InequalityBlock> emptyBlocks = groupsToInequalities.get(emptySet);\n        if (emptyBlocks == null) {\n          emptyBlocks = new HashSet<InequalityBlock>(1);\n          groupsToInequalities.put(emptySet, emptyBlocks);\n        }\n        emptyBlocks.add(inequality);\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>();\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        currentResult.add(var);\n        Set<SNode> varGroup = components.remove(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n          for (SNode var2 : varGroup) {\n            if (!variables.contains(var2)) {\n              components.put(var2, currentResult);\n            }\n          }\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","id":79298,"modified_method":"public Map<Set<SNode>, Set<InequalityBlock>> getInequalityGroups(Set<Block> inequalities) {\n    Map<SNode, Set<SNode>> components = new HashMap<SNode, Set<SNode>>(1);\n    Map<Set<SNode>, Set<InequalityBlock>> groupsToInequalities = new HashMap<Set<SNode>, Set<InequalityBlock>>();\n    Set<SNode> emptySet = new HashSet<SNode>(1);\n    for (Block block : inequalities) {\n      InequalityBlock inequality = (InequalityBlock) block;\n\n      List<SNode> variables = TypesUtil.getVariables(inequality.getRightNode(), myState);\n      variables.addAll(TypesUtil.getVariables(inequality.getLeftNode(), myState));\n      if (variables.size() == 0) {\n        Set<InequalityBlock> emptyBlocks = groupsToInequalities.get(emptySet);\n        if (emptyBlocks == null) {\n          emptyBlocks = new HashSet<InequalityBlock>(1);\n          groupsToInequalities.put(emptySet, emptyBlocks);\n        }\n        emptyBlocks.add(inequality);\n        continue;\n      }\n      Set<SNode> currentResult = new HashSet<SNode>();\n\n      Set<InequalityBlock> currentInequalities = new HashSet<InequalityBlock>();\n      currentInequalities.add(inequality);\n      for (SNode var : variables) {\n        var = myState.getRepresentative(var);\n        currentResult.add(var);\n        Set<SNode> varGroup = components.remove(var);\n        if (varGroup != null) {\n          currentResult.addAll(varGroup);\n          for (SNode var2 : varGroup) {\n            if (!variables.contains(var2)) {\n              components.put(var2, currentResult);\n            }\n          }\n        }\n        components.put(var, currentResult);\n        Set<InequalityBlock> remove = groupsToInequalities.remove(varGroup);\n        if (remove != null) {\n          currentInequalities.addAll(remove);\n        }\n      }\n      groupsToInequalities.put(currentResult, currentInequalities);\n    }\n    return groupsToInequalities;\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initializeMaps(List<RelationBlock> inequalities) {\n    myInputsToOutputs.clear();\n    myNodesToBlocks.clear();\n    myNodes.clear();\n    for (RelationBlock inequality : inequalities) {\n      if (inequality.isCheckOnly()) {\n        continue;\n      }\n      for (Pair<SNode, SNode> pair : inequality.getInputsAndOutputs()) {\n        SNode input = myState.getRepresentative(pair.first);\n        SNode output = myState.getRepresentative(pair.second);\n        if (input != null) {\n          if (TypesUtil.isVariable(input)) {\n            myNodes.add(input);\n          }\n          if (TypesUtil.isVariable(output)) {\n            myNodes.add(output);\n          }\n          if (input != output && output != null) {\n            addVariablesLink(input, output);\n            myNodesToBlocks.addLink(input, inequality);\n            if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {\n              List<SNode> inputVariables = TypesUtil.getVariables(input);\n              List<SNode> outputVariables = TypesUtil.getVariables(output);\n              myNodes.addAll(inputVariables);\n              myNodes.addAll(outputVariables);\n              for (SNode inputVar : inputVariables) {\n                for (SNode outputVar : outputVariables) {\n                  addVariablesLink(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n                }\n              }\n            }\n          }\n          if (output != null) {\n\n            myNodesToBlocks.addLink(output, inequality);\n          }\n        }\n      }\n    }\n  }","id":79299,"modified_method":"private void initializeMaps(List<RelationBlock> inequalities) {\n    myInputsToOutputs.clear();\n    myNodesToBlocks.clear();\n    myNodes.clear();\n    for (RelationBlock inequality : inequalities) {\n      if (inequality.isCheckOnly()) {\n        continue;\n      }\n      for (Pair<SNode, SNode> pair : inequality.getInputsAndOutputs()) {\n        SNode input = myState.getRepresentative(pair.first);\n        SNode output = myState.getRepresentative(pair.second);\n        if (input != null) {\n          if (TypesUtil.isVariable(input)) {\n            myNodes.add(input);\n          }\n          if (TypesUtil.isVariable(output)) {\n            myNodes.add(output);\n          }\n          if (input != output && output != null) {\n            addVariablesLink(input, output);\n            myNodesToBlocks.addLink(input, inequality);\n            if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {\n              List<SNode> inputVariables = TypesUtil.getVariables(input, myState);\n              List<SNode> outputVariables = TypesUtil.getVariables(output, myState);\n              myNodes.addAll(inputVariables);\n              myNodes.addAll(outputVariables);\n              for (SNode inputVar : inputVariables) {\n                for (SNode outputVar : outputVariables) {\n                  addVariablesLink(myState.getRepresentative(inputVar), myState.getRepresentative(outputVar));\n                }\n              }\n            }\n          }\n          if (output != null) {\n\n            myNodesToBlocks.addLink(output, inequality);\n          }\n        }\n      }\n    }\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public List<SNode> getVariables(State state) {\n    List<SNode> variables;\n    if (state == null) {\n      variables = TypesUtil.getVariables(myLeftNode);\n      variables.addAll(TypesUtil.getVariables(myRightNode));\n    } else {\n      variables = TypesUtil.getVariables(state.expand(myLeftNode));\n      variables.addAll(TypesUtil.getVariables(state.expand(myRightNode)));\n    }\n    return variables;\n  }","id":79300,"modified_method":"@Override\n  public List<SNode> getVariables(State state) {\n    List<SNode> variables = TypesUtil.getVariables(myLeftNode, state);\n    variables.addAll(TypesUtil.getVariables(myRightNode, state));\n    return variables;\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void getSliceVars(AbstractOperation diff) {\n    if (diff == null) {\n      return;\n    }\n    if (diff instanceof AddEquationOperation) {\n      AddEquationOperation eq = (AddEquationOperation) diff;\n      SNode child = eq.getChild();\n      SNode parent = eq.getParent();\n      if (myNodes.contains(child)) {\n        myNodes.addAll(TypesUtil.getVariables(parent));\n      }\n      if (myNodes.contains(parent)) {\n        myNodes.addAll(TypesUtil.getVariables(child));\n      }\n    }\n    if (diff instanceof AssignTypeOperation) {\n      AssignTypeOperation typeDifference = (AssignTypeOperation) diff;\n      if (myNodes.contains(typeDifference.getNode()) && TypesUtil.isVariable(typeDifference.getType())) {\n        myNodes.add(typeDifference.getType());\n      }\n    }\n    for (AbstractOperation childDiff : diff.getConsequences()) {\n      getSliceVars(childDiff);\n    }\n  }","id":79301,"modified_method":"private void getSliceVars(AbstractOperation diff) {\n    if (diff == null) {\n      return;\n    }\n    if (diff instanceof AddEquationOperation) {\n      AddEquationOperation eq = (AddEquationOperation) diff;\n      SNode child = eq.getChild();\n      SNode parent = eq.getParent();\n      if (myNodes.contains(child)) {\n        myNodes.addAll(TypesUtil.getVariables(parent, myStateCopy));\n      }\n      if (myNodes.contains(parent)) {\n        myNodes.addAll(TypesUtil.getVariables(child, myStateCopy));\n      }\n    }\n    if (diff instanceof AssignTypeOperation) {\n      AssignTypeOperation typeDifference = (AssignTypeOperation) diff;\n      if (myNodes.contains(typeDifference.getNode()) && TypesUtil.isVariable(typeDifference.getType())) {\n        myNodes.add(typeDifference.getType());\n      }\n    }\n    for (AbstractOperation childDiff : diff.getConsequences()) {\n      getSliceVars(childDiff);\n    }\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> getVariables(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    getVariablesInside(node, result);\n    return result;\n  }","id":79302,"modified_method":"public static List<SNode> getVariables(SNode node, State state) {\n    List<SNode> result = new LinkedList<SNode>();\n    getVariablesInside(node, result, state);\n    return result;\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void getVariablesInside(SNode node, List<SNode> result) {\n    if (node == null) {\n      return;\n    }\n    if (isVariable(node)) {\n      result.add(node);\n      return;\n    }\n    for (SNode child : node.getChildren()) {\n      getVariablesInside(child, result);\n    }\n    for (SNode referent : node.getReferents()) {\n      if (referent != null && isVariable(referent)) {\n        result.add(referent);\n      }\n    }\n  }","id":79303,"modified_method":"private static void getVariablesInside(SNode node, List<SNode> result, State state) {\n    if (node == null) {\n      return;\n    }\n    if (state != null) {\n      node = state.getRepresentative(node);\n    }\n    if (isVariable(node)) {\n      result.add(node);\n      return;\n    }\n    for (SNode child : node.getChildren()) {\n      getVariablesInside(child, result, state);\n    }\n    for (SNode referent : node.getReferents()) {\n      if (state!= null) {\n        referent = state.getRepresentative(referent);\n      }\n      if (referent != null && isVariable(referent)) {\n        result.add(referent);\n      }\n    }\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public List<SNode> getVariables(State state) {\n    return TypesUtil.getVariables(myArgument);\n  }","id":79304,"modified_method":"@Override\n  public List<SNode> getVariables(State state) {\n    return TypesUtil.getVariables(myArgument, state);\n  }","commit_id":"cd3ba789d6c392c827f3d82091711265a3cb7b70","url":"https://github.com/JetBrains/MPS"},{"original_method":"public BaseUpdateableElement(String name, String requestUniqueName, ToadletContext ctx) {\n\t\tthis(name, new String[] {}, new String[] {}, requestUniqueName, ctx);\n\t}","id":79305,"modified_method":"public BaseUpdateableElement(String name, String requestUniqueName, ToadletContext ctx) {\n\t\tthis(name, new String[] {}, new String[] {}, ctx);\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public BaseUpdateableElement(String name, String[] attributeNames, String[] attributeValues, String requestUniqueName, ToadletContext ctx) {\n\t\tsuper(name, attributeNames, attributeValues);\n\t\tthis.ctx = ctx;\n\t}","id":79306,"modified_method":"public BaseUpdateableElement(String name, String[] attributeNames, String[] attributeValues, ToadletContext ctx) {\n\t\tsuper(name, attributeNames, attributeValues);\n\t\tthis.ctx = ctx;\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public BaseUpdateableElement(String name, String attributeName, String attributeValue, String requestUniqueName, ToadletContext ctx) {\n\t\tthis(name, new String[] { attributeName }, new String[] { attributeValue }, requestUniqueName, ctx);\n\t}","id":79307,"modified_method":"public BaseUpdateableElement(String name, String attributeName, String attributeValue, ToadletContext ctx) {\n\t\tthis(name, new String[] { attributeName }, new String[] { attributeValue }, ctx);\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public DefaultUpdateManager(String requestId) {\n\t\tthis.requestId = requestId;\n\t}","id":79308,"modified_method":"public DefaultUpdateManager() {\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void updated(String message) {\n\t\tString elementId = message;\n\t\tFreenetJs.log(\"elementiddecoded:\" + elementId);\n\t\ttry {\n\t\t\tnew RequestBuilder(RequestBuilder.GET, IConnectionManager.dataPath+\"?requestId=\"+requestId+\"&elementId=\"+elementId).sendRequest(null, new UpdaterRequestCallback(elementId));\n\t\t} catch (RequestException re) {\n\t\t\tFreenetJs.log(\"EXCEPTION at DefaultUpdateManager.updated!\");\n\t\t}\n\t}","id":79309,"modified_method":"@Override\n\tpublic void updated(String message) {\n\t\tString elementId = message;\n\t\tFreenetJs.log(\"elementiddecoded:\" + elementId);\n\t\ttry {\n\t\t\tnew RequestBuilder(RequestBuilder.GET, IConnectionManager.dataPath + \"?requestId=\" + FreenetJs.requestId + \"&elementId=\" + elementId).sendRequest(null, new UpdaterRequestCallback(elementId));\n\t\t} catch (RequestException re) {\n\t\t\tFreenetJs.log(\"EXCEPTION at DefaultUpdateManager.updated!\");\n\t\t}\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString requestedMimeType = httprequest.getParam(\"type\");\n\t\t\t\tlong maxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\t\tString location = getLink(newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\tstrm.close();\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/queue/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/downloads/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/config/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/config/node\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\t//first check of httprange before get\n\t\t// only valid number format is checked here\n\t\tString rangeStr = ctx.getHeaders().get(\"range\");\n\t\tif (rangeStr != null) {\n\t\t\ttry {\n\t\t\t\tparseRange(rangeStr);\n\t\t\t} catch (HTTPRangeException e) {\n\t\t\t\tLogger.normal(this, \"Invalid Range Header: \"+rangeStr, e);\n\t\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\n\t\tBucket data = null;\n\t\tString mimeType = null;\n\t\tString referer = sanitizeReferer(ctx);\n\t\tFetchException fe = null;\n\t\t\n\n\t\tMultiValueTable<String,String> headers = ctx.getHeaders();\n\t\tString ua = headers.get(\"user-agent\");\n\t\tString accept = headers.get(\"accept\");\n\t\tFProxyFetchResult fr = null;\n\t\tif(logMINOR) Logger.minor(this, \"UA = \"+ua+\" accept = \"+accept);\n\t\tif(isBrowser(ua) && !ctx.disableProgressPage() && (accept == null || accept.indexOf(\"text/html\") > -1)) {\n\t\t\tFProxyFetchWaiter fetch = null;\n\t\t\ttry {\n\t\t\t\tfetch = fetchTracker.makeFetcher(key, maxSize);\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfe = fr.failed;\n\t\t\t}\n\t\t\tif(fetch != null)\n\t\t\twhile(true) {\n\t\t\tfr = fetch.getResult();\n\t\t\tif(fr.hasData()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\t\t\tdata = fr.data;\n\t\t\t\tmimeType = fr.mimeType;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else if(fr.failed != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Request failed\");\n\t\t\t\tfe = fr.failed;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Still in progress\");\n\t\t\t\t// Still in progress\n\t\t\t\tboolean isJsEnabled=ctx.getContainer().isFProxyJavascriptEnabled() && ua != null && !ua.contains(\"AppleWebKit/\");\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fetchingPageTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tString location = getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\tHTMLNode headNode=page.headNode;\n\t\t\t\tif(isJsEnabled){\n\t\t\t\t\t//If the user has enabled javascript, we add a <noscript> http refresh(if he has disabled it in the browser)\n\t\t\t\t\theadNode.addChild(\"noscript\").addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}else{\n\t\t\t\t\t//If he disabled it, we just put the http refresh meta, without the noscript\n\t\t\t\t\theadNode.addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageBox\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addAttribute(\"id\", \"infoContent\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"filenameLabel\")+ \" \");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/\"+key.toString(false, false), key.getPreferredFilename());\n\t\t\t\tif(fr.mimeType != null) infoboxContent.addChild(\"br\", l10n(\"contentTypeLabel\")+\" \"+fr.mimeType);\n\t\t\t\tif(fr.size > 0) infoboxContent.addChild(\"br\", \"Size: \"+SizeUtil.formatSize(fr.size));\n\t\t\t\tif(core.isAdvancedModeEnabled()) {\n\t\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"blocksDetail\", \n\t\t\t\t\t\t\tnew String[] { \"fetched\", \"required\", \"total\", \"failed\", \"fatallyfailed\" },\n\t\t\t\t\t\t\tnew String[] { Integer.toString(fr.fetchedBlocks), Integer.toString(fr.requiredBlocks), Integer.toString(fr.totalBlocks), Integer.toString(fr.failedBlocks), Integer.toString(fr.fatallyFailedBlocks) }));\n\t\t\t\t}\n\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"timeElapsedLabel\")+\" \"+TimeUtil.formatTime(System.currentTimeMillis() - fr.timeStarted));\n\t\t\t\tlong eta = fr.eta;\n\t\t\t\tif(eta > 0)\n\t\t\t\t\tinfoboxContent.addChild(\"br\", \"ETA: \"+TimeUtil.formatTime(eta));\n\t\t\t\tif(fr.goneToNetwork)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressDownloading\"));\n\t\t\t\telse\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressCheckingStore\"));\n\t\t\t\tif(!fr.finalizedBlocks)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressNotFinalized\"));\n\t\t\t\t\n\t\t\t\tHTMLNode table = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tHTMLNode progressCell = table.addChild(\"tr\").addChild(\"td\", \"class\", \"request-progress\");\n\t\t\t\tif(fr.totalBlocks <= 0)\n\t\t\t\t\tprogressCell.addChild(\"#\", L10n.getString(\"QueueToadlet.unknown\"));\n\t\t\t\telse {\n\t\t\t\t\tprogressCell.addChild(new ProgressBarElement(fetchTracker,key,maxSize,ctx.getUniqueId(),ctx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageOptions\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\t\tHTMLNode ul = infoboxContent.addChild(\"ul\");\n\t\t\t\tul.addChild(\"li\").addChild(\"p\", l10n(\"progressOptionZero\"));\n\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\") });\n\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\tMultiValueTable<String, String> retHeaders = new MultiValueTable<String, String>();\n\t\t\t\t//retHeaders.put(\"Refresh\", \"2; url=\"+location);\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", retHeaders, pageNode.generate());\n\t\t\t\tfr.close();\n\t\t\t\tfetch.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tif(data == null && fe == null) {\n\t\t\tFetchResult result = fetch(key, maxSize, new RequestClient() {\n\t\t\t\tpublic boolean persistent() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic void removeFrom(ObjectContainer container) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t} }); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tmimeType = result.getMimeType();\n\t\t\t} else if(fe != null) throw fe;\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, maxSize != MAX_LENGTH ? \"&max-size=\"+maxSize : \"\", referer, true, ctx, core, fr != null);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg,\n\t\t\t\t\tgetLink(e.newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = option.addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] {'/' + key.toString(), \"get\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplay\") });\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\") });\n\t\t\t\t}\n\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString() + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\")});\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(fr == null && data != null) data.free();\n\t\t\tif(fr != null) fr.close();\n\t\t}\n\t}","id":79310,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString requestedMimeType = httprequest.getParam(\"type\");\n\t\t\t\tlong maxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\t\tString location = getLink(newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\tstrm.close();\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/queue/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/downloads/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/config/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/config/node\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\t//first check of httprange before get\n\t\t// only valid number format is checked here\n\t\tString rangeStr = ctx.getHeaders().get(\"range\");\n\t\tif (rangeStr != null) {\n\t\t\ttry {\n\t\t\t\tparseRange(rangeStr);\n\t\t\t} catch (HTTPRangeException e) {\n\t\t\t\tLogger.normal(this, \"Invalid Range Header: \"+rangeStr, e);\n\t\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\n\t\tBucket data = null;\n\t\tString mimeType = null;\n\t\tString referer = sanitizeReferer(ctx);\n\t\tFetchException fe = null;\n\t\t\n\n\t\tMultiValueTable<String,String> headers = ctx.getHeaders();\n\t\tString ua = headers.get(\"user-agent\");\n\t\tString accept = headers.get(\"accept\");\n\t\tFProxyFetchResult fr = null;\n\t\tif(logMINOR) Logger.minor(this, \"UA = \"+ua+\" accept = \"+accept);\n\t\tif(isBrowser(ua) && !ctx.disableProgressPage() && (accept == null || accept.indexOf(\"text/html\") > -1)) {\n\t\t\tFProxyFetchWaiter fetch = null;\n\t\t\ttry {\n\t\t\t\tfetch = fetchTracker.makeFetcher(key, maxSize);\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfe = fr.failed;\n\t\t\t}\n\t\t\tif(fetch != null)\n\t\t\twhile(true) {\n\t\t\tfr = fetch.getResult();\n\t\t\tif(fr.hasData()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\t\t\tdata = fr.data;\n\t\t\t\tmimeType = fr.mimeType;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else if(fr.failed != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Request failed\");\n\t\t\t\tfe = fr.failed;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Still in progress\");\n\t\t\t\t// Still in progress\n\t\t\t\tboolean isJsEnabled=ctx.getContainer().isFProxyJavascriptEnabled() && ua != null && !ua.contains(\"AppleWebKit/\");\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fetchingPageTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tString location = getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\tHTMLNode headNode=page.headNode;\n\t\t\t\tif(isJsEnabled){\n\t\t\t\t\t//If the user has enabled javascript, we add a <noscript> http refresh(if he has disabled it in the browser)\n\t\t\t\t\theadNode.addChild(\"noscript\").addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}else{\n\t\t\t\t\t//If he disabled it, we just put the http refresh meta, without the noscript\n\t\t\t\t\theadNode.addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageBox\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addAttribute(\"id\", \"infoContent\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"filenameLabel\")+ \" \");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/\"+key.toString(false, false), key.getPreferredFilename());\n\t\t\t\tif(fr.mimeType != null) infoboxContent.addChild(\"br\", l10n(\"contentTypeLabel\")+\" \"+fr.mimeType);\n\t\t\t\tif(fr.size > 0) infoboxContent.addChild(\"br\", \"Size: \"+SizeUtil.formatSize(fr.size));\n\t\t\t\tif(core.isAdvancedModeEnabled()) {\n\t\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"blocksDetail\", \n\t\t\t\t\t\t\tnew String[] { \"fetched\", \"required\", \"total\", \"failed\", \"fatallyfailed\" },\n\t\t\t\t\t\t\tnew String[] { Integer.toString(fr.fetchedBlocks), Integer.toString(fr.requiredBlocks), Integer.toString(fr.totalBlocks), Integer.toString(fr.failedBlocks), Integer.toString(fr.fatallyFailedBlocks) }));\n\t\t\t\t}\n\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"timeElapsedLabel\")+\" \"+TimeUtil.formatTime(System.currentTimeMillis() - fr.timeStarted));\n\t\t\t\tlong eta = fr.eta;\n\t\t\t\tif(eta > 0)\n\t\t\t\t\tinfoboxContent.addChild(\"br\", \"ETA: \"+TimeUtil.formatTime(eta));\n\t\t\t\tif(fr.goneToNetwork)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressDownloading\"));\n\t\t\t\telse\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressCheckingStore\"));\n\t\t\t\tif(!fr.finalizedBlocks)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressNotFinalized\"));\n\t\t\t\t\n\t\t\t\tHTMLNode table = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tHTMLNode progressCell = table.addChild(\"tr\").addChild(\"td\", \"class\", \"request-progress\");\n\t\t\t\tif(fr.totalBlocks <= 0)\n\t\t\t\t\tprogressCell.addChild(\"#\", L10n.getString(\"QueueToadlet.unknown\"));\n\t\t\t\telse {\n\t\t\t\t\tprogressCell.addChild(new ProgressBarElement(fetchTracker,key,maxSize,ctx));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageOptions\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\t\tHTMLNode ul = infoboxContent.addChild(\"ul\");\n\t\t\t\tul.addChild(\"li\").addChild(\"p\", l10n(\"progressOptionZero\"));\n\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\") });\n\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\tMultiValueTable<String, String> retHeaders = new MultiValueTable<String, String>();\n\t\t\t\t//retHeaders.put(\"Refresh\", \"2; url=\"+location);\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", retHeaders, pageNode.generate());\n\t\t\t\tfr.close();\n\t\t\t\tfetch.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tif(data == null && fe == null) {\n\t\t\tFetchResult result = fetch(key, maxSize, new RequestClient() {\n\t\t\t\tpublic boolean persistent() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic void removeFrom(ObjectContainer container) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t} }); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tmimeType = result.getMimeType();\n\t\t\t} else if(fe != null) throw fe;\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, maxSize != MAX_LENGTH ? \"&max-size=\"+maxSize : \"\", referer, true, ctx, core, fr != null);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg,\n\t\t\t\t\tgetLink(e.newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = option.addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] {'/' + key.toString(), \"get\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplay\") });\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\") });\n\t\t\t\t}\n\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString() + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDisk\")});\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(fr == null && data != null) data.free();\n\t\t\tif(fr != null) fr.close();\n\t\t}\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public static void maybeCreateFProxyEtc(NodeClientCore core, Node node, Config config, SimpleToadletServer server, BookmarkManager bookmarks) throws IOException {\n\t\t\n\t\t// FIXME how to change these on the fly when the interface language is changed?\n\t\t\n\t\tHighLevelSimpleClient client = core.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS, true);\n\t\t\n\t\trandom = new byte[32];\n\t\tcore.random.nextBytes(random);\n\t\tFProxyToadlet fproxy = new FProxyToadlet(client, core);\n\t\tcore.setFProxy(fproxy);\n\t\t\n\t\tserver.registerMenu(\"/\", \"FProxyToadlet.categoryBrowsing\", \"FProxyToadlet.categoryTitleBrowsing\", null);\n\t\tserver.registerMenu(\"/downloads/\", \"FProxyToadlet.categoryQueue\", \"FProxyToadlet.categoryTitleQueue\", null);\n\t\tserver.registerMenu(\"/friends/\", \"FProxyToadlet.categoryFriends\", \"FProxyToadlet.categoryTitleFriends\", null);\n\t\tserver.registerMenu(\"/chat/\", \"FProxyToadlet.categoryChat\", \"FProxyToadlet.categoryTitleChat\", null);\n\t\tserver.registerMenu(\"/alerts/\", \"FProxyToadlet.categoryStatus\", \"FProxyToadlet.categoryTitleStatus\", null);\n\t\tserver.registerMenu(\"/seclevels/\", \"FProxyToadlet.categoryConfig\", \"FProxyToadlet.categoryTitleConfig\", null);\n\t\t\n\t\t\n\t\tserver.register(fproxy, \"FProxyToadlet.categoryBrowsing\", \"/\", false, \"FProxyToadlet.welcomeTitle\", \"FProxyToadlet.welcome\", false, null);\n\t\t\n\t\tInsertFreesiteToadlet siteinsert = new InsertFreesiteToadlet(client, core.alerts);\n\t\tserver.register(siteinsert, \"FProxyToadlet.categoryBrowsing\", \"/insertsite/\", true, \"FProxyToadlet.insertFreesiteTitle\", \"FProxyToadlet.insertFreesite\", false, null);\n\t\t\n\t\tUserAlertsToadlet alerts = new UserAlertsToadlet(client, node, core);\n\t\tserver.register(alerts, \"FProxyToadlet.categoryStatus\", \"/alerts/\", true, \"FProxyToadlet.alertsTitle\", \"FProxyToadlet.alerts\", true, null);\n\n\t\t\n\t\tQueueToadlet downloadToadlet = new QueueToadlet(core, core.getFCPServer(), client, false);\n\t\tserver.register(downloadToadlet, \"FProxyToadlet.categoryQueue\", \"/downloads/\", true, \"FProxyToadlet.downloadsTitle\", \"FProxyToadlet.downloads\", false, downloadToadlet);\n\t\tQueueToadlet uploadToadlet = new QueueToadlet(core, core.getFCPServer(), client, true);\n\t\tserver.register(uploadToadlet, \"FProxyToadlet.categoryQueue\", \"/uploads/\", true, \"FProxyToadlet.uploadsTitle\", \"FProxyToadlet.uploads\", false, uploadToadlet);\n\t\t\n\t\tSymlinkerToadlet symlinkToadlet = new SymlinkerToadlet(client, node);\n\t\tserver.register(symlinkToadlet, null, \"/sl/\", true, false);\n\t\t\n\t\tSecurityLevelsToadlet seclevels = new SecurityLevelsToadlet(client, node, core);\n\t\tserver.register(seclevels, \"FProxyToadlet.categoryConfig\", \"/seclevels/\", true, \"FProxyToadlet.seclevelsTitle\", \"FProxyToadlet.seclevels\", true, null);\n\n\t\tPproxyToadlet pproxy = new PproxyToadlet(client, node, core);\n\t\tserver.register(pproxy, \"FProxyToadlet.categoryConfig\", \"/plugins/\", true, \"FProxyToadlet.pluginsTitle\", \"FProxyToadlet.plugins\", true, null);\n\t\t\n\t\tSubConfig[] sc = config.getConfigs();\n\t\tArrays.sort(sc);\n\t\t\n\t\tfor(SubConfig cfg : sc) {\n\t\t\tString prefix = cfg.getPrefix();\n\t\t\tif(prefix.equals(\"security-levels\") || prefix.equals(\"pluginmanager\")) continue;\n\t\t\tConfigToadlet configtoadlet = new ConfigToadlet(client, config, cfg, node, core);\n\t\t\tserver.register(configtoadlet, \"FProxyToadlet.categoryConfig\", \"/config/\"+prefix, true, \"ConfigToadlet.\"+prefix, \"ConfigToadlet.title.\"+prefix, true, configtoadlet);\n\t\t}\n\t\t\n\t\tWelcomeToadlet welcometoadlet = new WelcomeToadlet(client, core, node, bookmarks);\n\t\tserver.register(welcometoadlet, null, \"/welcome/\", true, false);\n\t\t\n\t\t\n\t\tDarknetConnectionsToadlet friendsToadlet = new DarknetConnectionsToadlet(node, core, client);\n\t\tserver.register(friendsToadlet, \"FProxyToadlet.categoryFriends\", \"/friends/\", true, \"FProxyToadlet.friendsTitle\", \"FProxyToadlet.friends\", true, null);\n\t\t\n\t\tDarknetAddRefToadlet addRefToadlet = new DarknetAddRefToadlet(node, core, client);\n\t\tserver.register(addRefToadlet, \"FProxyToadlet.categoryFriends\", \"/addfriend/\", true, \"FProxyToadlet.addFriendTitle\", \"FProxyToadlet.addFriend\", true, null);\n\t\t\n\t\tOpennetConnectionsToadlet opennetToadlet = new OpennetConnectionsToadlet(node, core, client);\n\t\tserver.register(opennetToadlet, \"FProxyToadlet.categoryStatus\", \"/strangers/\", true, \"FProxyToadlet.opennetTitle\", \"FProxyToadlet.opennet\", true, opennetToadlet);\n\t\t\n\t\tChatForumsToadlet chatForumsToadlet = new ChatForumsToadlet(client, core.alerts, node.pluginManager);\n\t\tserver.register(chatForumsToadlet, \"FProxyToadlet.categoryChat\", \"/chat/\", true, \"FProxyToadlet.chatForumsTitle\", \"FProxyToadlet.chatForums\", true, chatForumsToadlet);\n\t\t\n\t\tN2NTMToadlet n2ntmToadlet = new N2NTMToadlet(node, core, client);\n\t\tserver.register(n2ntmToadlet, null, \"/send_n2ntm/\", true, true);\n\t\tLocalFileInsertToadlet localFileInsertToadlet = new LocalFileInsertToadlet(core, client);\n\t\tserver.register(localFileInsertToadlet, null, \"/files/\", true, false);\n\t\t\n\t\tBookmarkEditorToadlet bookmarkEditorToadlet = new BookmarkEditorToadlet(client, core, bookmarks);\n\t\tserver.register(bookmarkEditorToadlet, null, \"/bookmarkEditor/\", true, false);\n\t\t\n\t\tBrowserTestToadlet browsertTestToadlet = new BrowserTestToadlet(client, core);\n\t\tserver.register(browsertTestToadlet, null, \"/test/\", true, false);\n\t\t\t\n\t\tStatisticsToadlet statisticsToadlet = new StatisticsToadlet(node, core, client);\n\t\tserver.register(statisticsToadlet, \"FProxyToadlet.categoryStatus\", \"/stats/\", true, \"FProxyToadlet.statsTitle\", \"FProxyToadlet.stats\", true, null);\n\t\t\n\t\tConnectivityToadlet connectivityToadlet = new ConnectivityToadlet(client, node, core);\n\t\tserver.register(connectivityToadlet, \"FProxyToadlet.categoryStatus\", \"/connectivity/\", true, \"ConnectivityToadlet.connectivityTitle\", \"ConnectivityToadlet.connectivity\", true, null);\n\t\t\n\t\tTranslationToadlet translationToadlet = new TranslationToadlet(client, core);\n\t\tserver.register(translationToadlet, \"FProxyToadlet.categoryConfig\", TranslationToadlet.TOADLET_URL, true, \"TranslationToadlet.title\", \"TranslationToadlet.titleLong\", true, null);\n\t\t\n\t\tFirstTimeWizardToadlet firstTimeWizardToadlet = new FirstTimeWizardToadlet(client, node, core);\n\t\tserver.register(firstTimeWizardToadlet, null, FirstTimeWizardToadlet.TOADLET_URL, true, false);\n\t\t\n\t\tSimpleHelpToadlet simpleHelpToadlet = new SimpleHelpToadlet(client, core);\n\t\tserver.register(simpleHelpToadlet, null, \"/help/\", true, false);\n\t\t\n\t\tPushDataToadlet pushDataToadlet = new PushDataToadlet(client);\n\t\tserver.register(pushDataToadlet, null, pushDataToadlet.path(), true, false);\n\t\t\n\t\tPushNotificationToadlet pushNotificationToadlet = new PushNotificationToadlet(client);\n\t\tserver.register(pushNotificationToadlet, null, pushNotificationToadlet.path(), true, false);\n\t}","id":79311,"modified_method":"public static void maybeCreateFProxyEtc(NodeClientCore core, Node node, Config config, SimpleToadletServer server, BookmarkManager bookmarks) throws IOException {\n\t\t\n\t\t// FIXME how to change these on the fly when the interface language is changed?\n\t\t\n\t\tHighLevelSimpleClient client = core.makeClient(RequestStarter.INTERACTIVE_PRIORITY_CLASS, true);\n\t\t\n\t\trandom = new byte[32];\n\t\tcore.random.nextBytes(random);\n\t\tFProxyToadlet fproxy = new FProxyToadlet(client, core);\n\t\tcore.setFProxy(fproxy);\n\t\t\n\t\tserver.registerMenu(\"/\", \"FProxyToadlet.categoryBrowsing\", \"FProxyToadlet.categoryTitleBrowsing\", null);\n\t\tserver.registerMenu(\"/downloads/\", \"FProxyToadlet.categoryQueue\", \"FProxyToadlet.categoryTitleQueue\", null);\n\t\tserver.registerMenu(\"/friends/\", \"FProxyToadlet.categoryFriends\", \"FProxyToadlet.categoryTitleFriends\", null);\n\t\tserver.registerMenu(\"/chat/\", \"FProxyToadlet.categoryChat\", \"FProxyToadlet.categoryTitleChat\", null);\n\t\tserver.registerMenu(\"/alerts/\", \"FProxyToadlet.categoryStatus\", \"FProxyToadlet.categoryTitleStatus\", null);\n\t\tserver.registerMenu(\"/seclevels/\", \"FProxyToadlet.categoryConfig\", \"FProxyToadlet.categoryTitleConfig\", null);\n\t\t\n\t\t\n\t\tserver.register(fproxy, \"FProxyToadlet.categoryBrowsing\", \"/\", false, \"FProxyToadlet.welcomeTitle\", \"FProxyToadlet.welcome\", false, null);\n\t\t\n\t\tInsertFreesiteToadlet siteinsert = new InsertFreesiteToadlet(client, core.alerts);\n\t\tserver.register(siteinsert, \"FProxyToadlet.categoryBrowsing\", \"/insertsite/\", true, \"FProxyToadlet.insertFreesiteTitle\", \"FProxyToadlet.insertFreesite\", false, null);\n\t\t\n\t\tUserAlertsToadlet alerts = new UserAlertsToadlet(client, node, core);\n\t\tserver.register(alerts, \"FProxyToadlet.categoryStatus\", \"/alerts/\", true, \"FProxyToadlet.alertsTitle\", \"FProxyToadlet.alerts\", true, null);\n\n\t\t\n\t\tQueueToadlet downloadToadlet = new QueueToadlet(core, core.getFCPServer(), client, false);\n\t\tserver.register(downloadToadlet, \"FProxyToadlet.categoryQueue\", \"/downloads/\", true, \"FProxyToadlet.downloadsTitle\", \"FProxyToadlet.downloads\", false, downloadToadlet);\n\t\tQueueToadlet uploadToadlet = new QueueToadlet(core, core.getFCPServer(), client, true);\n\t\tserver.register(uploadToadlet, \"FProxyToadlet.categoryQueue\", \"/uploads/\", true, \"FProxyToadlet.uploadsTitle\", \"FProxyToadlet.uploads\", false, uploadToadlet);\n\t\t\n\t\tSymlinkerToadlet symlinkToadlet = new SymlinkerToadlet(client, node);\n\t\tserver.register(symlinkToadlet, null, \"/sl/\", true, false);\n\t\t\n\t\tSecurityLevelsToadlet seclevels = new SecurityLevelsToadlet(client, node, core);\n\t\tserver.register(seclevels, \"FProxyToadlet.categoryConfig\", \"/seclevels/\", true, \"FProxyToadlet.seclevelsTitle\", \"FProxyToadlet.seclevels\", true, null);\n\n\t\tPproxyToadlet pproxy = new PproxyToadlet(client, node, core);\n\t\tserver.register(pproxy, \"FProxyToadlet.categoryConfig\", \"/plugins/\", true, \"FProxyToadlet.pluginsTitle\", \"FProxyToadlet.plugins\", true, null);\n\t\t\n\t\tSubConfig[] sc = config.getConfigs();\n\t\tArrays.sort(sc);\n\t\t\n\t\tfor(SubConfig cfg : sc) {\n\t\t\tString prefix = cfg.getPrefix();\n\t\t\tif(prefix.equals(\"security-levels\") || prefix.equals(\"pluginmanager\")) continue;\n\t\t\tConfigToadlet configtoadlet = new ConfigToadlet(client, config, cfg, node, core);\n\t\t\tserver.register(configtoadlet, \"FProxyToadlet.categoryConfig\", \"/config/\"+prefix, true, \"ConfigToadlet.\"+prefix, \"ConfigToadlet.title.\"+prefix, true, configtoadlet);\n\t\t}\n\t\t\n\t\tWelcomeToadlet welcometoadlet = new WelcomeToadlet(client, core, node, bookmarks);\n\t\tserver.register(welcometoadlet, null, \"/welcome/\", true, false);\n\t\t\n\t\t\n\t\tDarknetConnectionsToadlet friendsToadlet = new DarknetConnectionsToadlet(node, core, client);\n\t\tserver.register(friendsToadlet, \"FProxyToadlet.categoryFriends\", \"/friends/\", true, \"FProxyToadlet.friendsTitle\", \"FProxyToadlet.friends\", true, null);\n\t\t\n\t\tDarknetAddRefToadlet addRefToadlet = new DarknetAddRefToadlet(node, core, client);\n\t\tserver.register(addRefToadlet, \"FProxyToadlet.categoryFriends\", \"/addfriend/\", true, \"FProxyToadlet.addFriendTitle\", \"FProxyToadlet.addFriend\", true, null);\n\t\t\n\t\tOpennetConnectionsToadlet opennetToadlet = new OpennetConnectionsToadlet(node, core, client);\n\t\tserver.register(opennetToadlet, \"FProxyToadlet.categoryStatus\", \"/strangers/\", true, \"FProxyToadlet.opennetTitle\", \"FProxyToadlet.opennet\", true, opennetToadlet);\n\t\t\n\t\tChatForumsToadlet chatForumsToadlet = new ChatForumsToadlet(client, core.alerts, node.pluginManager);\n\t\tserver.register(chatForumsToadlet, \"FProxyToadlet.categoryChat\", \"/chat/\", true, \"FProxyToadlet.chatForumsTitle\", \"FProxyToadlet.chatForums\", true, chatForumsToadlet);\n\t\t\n\t\tN2NTMToadlet n2ntmToadlet = new N2NTMToadlet(node, core, client);\n\t\tserver.register(n2ntmToadlet, null, \"/send_n2ntm/\", true, true);\n\t\tLocalFileInsertToadlet localFileInsertToadlet = new LocalFileInsertToadlet(core, client);\n\t\tserver.register(localFileInsertToadlet, null, \"/files/\", true, false);\n\t\t\n\t\tBookmarkEditorToadlet bookmarkEditorToadlet = new BookmarkEditorToadlet(client, core, bookmarks);\n\t\tserver.register(bookmarkEditorToadlet, null, \"/bookmarkEditor/\", true, false);\n\t\t\n\t\tBrowserTestToadlet browsertTestToadlet = new BrowserTestToadlet(client, core);\n\t\tserver.register(browsertTestToadlet, null, \"/test/\", true, false);\n\t\t\t\n\t\tStatisticsToadlet statisticsToadlet = new StatisticsToadlet(node, core, client);\n\t\tserver.register(statisticsToadlet, \"FProxyToadlet.categoryStatus\", \"/stats/\", true, \"FProxyToadlet.statsTitle\", \"FProxyToadlet.stats\", true, null);\n\t\t\n\t\tConnectivityToadlet connectivityToadlet = new ConnectivityToadlet(client, node, core);\n\t\tserver.register(connectivityToadlet, \"FProxyToadlet.categoryStatus\", \"/connectivity/\", true, \"ConnectivityToadlet.connectivityTitle\", \"ConnectivityToadlet.connectivity\", true, null);\n\t\t\n\t\tTranslationToadlet translationToadlet = new TranslationToadlet(client, core);\n\t\tserver.register(translationToadlet, \"FProxyToadlet.categoryConfig\", TranslationToadlet.TOADLET_URL, true, \"TranslationToadlet.title\", \"TranslationToadlet.titleLong\", true, null);\n\t\t\n\t\tFirstTimeWizardToadlet firstTimeWizardToadlet = new FirstTimeWizardToadlet(client, node, core);\n\t\tserver.register(firstTimeWizardToadlet, null, FirstTimeWizardToadlet.TOADLET_URL, true, false);\n\t\t\n\t\tSimpleHelpToadlet simpleHelpToadlet = new SimpleHelpToadlet(client, core);\n\t\tserver.register(simpleHelpToadlet, null, \"/help/\", true, false);\n\t\t\n\t\tPushDataToadlet pushDataToadlet = new PushDataToadlet(client);\n\t\tserver.register(pushDataToadlet, null, pushDataToadlet.path(), true, false);\n\t\t\n\t\tPushNotificationToadlet pushNotificationToadlet = new PushNotificationToadlet(client);\n\t\tserver.register(pushNotificationToadlet, null, pushNotificationToadlet.path(), true, false);\n\t\t\n\t\tPushKeepaliveToadlet pushKeepaliveToadlet = new PushKeepaliveToadlet(client);\n\t\tserver.register(pushKeepaliveToadlet, null, pushKeepaliveToadlet.path(), true, false);\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public void onModuleLoad() {\n\n\t\tString requestId = RootPanel.get(\"requestId\").getElement().getAttribute(\"value\");\n\t\tcm = new SharedConnectionManager(new DefaultUpdateManager(requestId));\n\t\tcm.openConnection();\n\t}","id":79312,"modified_method":"public void onModuleLoad() {\n\n\t\trequestId = RootPanel.get(\"requestId\").getElement().getAttribute(\"value\");\n\t\tcm = new SharedConnectionManager(new DefaultUpdateManager());\n\t\tkeepaliveManager = new KeepaliveManager();\n\t\tcm.openConnection();\n\t\tkeepaliveManager.openConnection();\n\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public static void stop() {\n\t\tcm.closeConnection();\n\t}","id":79313,"modified_method":"public static void stop() {\n\t\tcm.closeConnection();\n\t\tkeepaliveManager.closeConnection();\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public ProgressBarElement(FProxyFetchTracker tracker, FreenetURI key, long maxSize, String requestUniqueName, ToadletContext ctx) {\n\t\tsuper(\"div\", \"class\", \"progressbar\", requestUniqueName, ctx);\n\t\tthis.tracker = tracker;\n\t\tthis.key = key;\n\t\tthis.maxSize = maxSize;\n\t\tinit();\n\t\tfetchListener=new NotifierFetchListener(((SimpleToadletServer) ctx.getContainer()).pushDataManager, this);\n\t\ttracker.getFetchInProgress(key, maxSize).addListener(fetchListener);\n\t}","id":79314,"modified_method":"public ProgressBarElement(FProxyFetchTracker tracker, FreenetURI key, long maxSize, ToadletContext ctx) {\n\t\tsuper(\"div\", \"class\", \"progressbar\", ctx);\n\t\tthis.tracker = tracker;\n\t\tthis.key = key;\n\t\tthis.maxSize = maxSize;\n\t\tinit();\n\t\tfetchListener = new NotifierFetchListener(((SimpleToadletServer) ctx.getContainer()).pushDataManager, this);\n\t\ttracker.getFetchInProgress(key, maxSize).addListener(fetchListener);\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void dispose() {\n\t\ttracker.getFetchInProgress(key, maxSize).removeListener(fetchListener);\n\t}","id":79315,"modified_method":"@Override\n\tpublic void dispose() {\n\t\tFProxyFetchInProgress progress = tracker.getFetchInProgress(key, maxSize);\n\t\tif (progress != null) {\n\t\t\tprogress.removeListener(fetchListener);\n\t\t}\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\t\tpublic void run() {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t}","id":79316,"modified_method":"@Override\n\t\tpublic void run() {\n\t\t\tSystem.err.println(\"Cleaner started\");\n\t\t\telementLock.lock();\n\t\t\ttry {\n\t\t\t\tfor (Entry<String, Boolean> entry : new HashMap<String, Boolean>(isKeepaliveReceived).entrySet()) {\n\t\t\t\t\tif (entry.getValue() == false) {\n\t\t\t\t\t\tisKeepaliveReceived.remove(entry.getKey());\n\t\t\t\t\t\tfor (BaseUpdateableElement element : new ArrayList<BaseUpdateableElement>(pages.get(entry.getKey()))) {\n\t\t\t\t\t\t\tpages.get(entry.getKey()).remove(element);\n\t\t\t\t\t\t\tif (pages.get(entry.getKey()).size() == 0) {\n\t\t\t\t\t\t\t\tpages.remove(entry.getKey());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telements.remove(element.getUpdaterId());\n\t\t\t\t\t\t\telement.dispose();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isKeepaliveReceived.size() == 0) {\n\t\t\t\t\t\t\tcleaner.cancel();\n\t\t\t\t\t\t\tcleaner=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.err.println(\"Cleaner has deleted key:\" + entry.getKey());\n\t\t\t\t\t\tSystem.err.println(\"current status:\");\n\t\t\t\t\t\tSystem.err.println(\"awaitingNotifications:\" + awaitingNotifications);\n\t\t\t\t\t\tSystem.err.println(\"pages:\" + pages);\n\t\t\t\t\t\tSystem.err.println(\"elements:\" + elements);\n\t\t\t\t\t\tSystem.err.println(\"isKeepaliveReceived:\" + isKeepaliveReceived);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisKeepaliveReceived.put(entry.getKey(), false);\n\t\t\t\t\t\tSystem.err.println(\"Cleaner has reseted key:\" + entry.getKey());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\telementLock.unlock();\n\t\t\t}\n\t\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public boolean keepAliveReceived(String requestId) {\n\t\telementLock.lock();\n\t\ttry{\n\t\t\tif(lastReceivedKeepalive.containsKey(requestId)==false){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlastReceivedKeepalive.put(requestId,System.currentTimeMillis());\n\t\t\treturn true;\n\t\t}finally{\n\t\t\telementLock.unlock();\n\t\t}\n\t}","id":79317,"modified_method":"public boolean keepAliveReceived(String requestId) {\n\t\telementLock.lock();\n\t\ttry {\n\t\t\tif (isKeepaliveReceived.containsKey(requestId) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tisKeepaliveReceived.put(requestId, true);\n\t\t\treturn true;\n\t\t} finally {\n\t\t\telementLock.unlock();\n\t\t}\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"public void elementRendered(String requestUniqueId, BaseUpdateableElement element) {\n\t\telementLock.lock();\n\t\ttry {\n\t\t\tif (pages.containsKey(requestUniqueId) == false) {\n\t\t\t\tpages.put(requestUniqueId, new ArrayList<BaseUpdateableElement>());\n\t\t\t}\n\t\t\tpages.get(requestUniqueId).add(element);\n\t\t\tif (elements.containsKey(element.getUpdaterId()) == false) {\n\t\t\t\telements.put(element.getUpdaterId(), new ArrayList<String>());\n\t\t\t}\n\t\t\telements.get(element.getUpdaterId()).add(requestUniqueId);\n\t\t} finally {\n\t\t\telementLock.unlock();\n\t\t}\n\t}","id":79318,"modified_method":"public void elementRendered(String requestUniqueId, BaseUpdateableElement element) {\n\t\telementLock.lock();\n\t\ttry {\n\t\t\tif (pages.containsKey(requestUniqueId) == false) {\n\t\t\t\tpages.put(requestUniqueId, new ArrayList<BaseUpdateableElement>());\n\t\t\t}\n\t\t\tpages.get(requestUniqueId).add(element);\n\t\t\tif (elements.containsKey(element.getUpdaterId()) == false) {\n\t\t\t\telements.put(element.getUpdaterId(), new ArrayList<String>());\n\t\t\t}\n\t\t\telements.get(element.getUpdaterId()).add(requestUniqueId);\n\t\t\tisKeepaliveReceived.put(requestUniqueId, true);\n\t\t\tif (cleaner == null) {\n\t\t\t\tint delayInMs = (int) (UpdaterConstants.KEEPALIVE_INTERVAL_SECONDS * 1000 * 2.1);\n\t\t\t\tcleaner=new Timer(false);\n\t\t\t\tcleaner.schedule(new CleanerTimerTask(), delayInMs, delayInMs);\n\t\t\t}\n\t\t} finally {\n\t\t\telementLock.unlock();\n\t\t}\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tString requestId = req.getParam(\"requestId\");\n\t\tString elementId = req.getParam(\"elementId\");\n\t\telementId = elementId.replace(\" \", \"+\");// This is needed, because BASE64 has '+', but it is a HTML escape for ' '\n\t\tBaseUpdateableElement node = ((SimpleToadletServer) ctx.getContainer()).pushDataManager.getRenderedElement(requestId, elementId);\n\t\twriteHTMLReply(ctx, 200, \"OK\", \"SUCCESS:\" + Base64.encodeStandard(node.getUpdaterType().getBytes())+\":\"+Base64.encodeStandard(node.generateChildren().getBytes()));\n\t}","id":79319,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tString requestId = req.getParam(\"requestId\");\n\t\tString elementId = req.getParam(\"elementId\");\n\t\telementId = elementId.replace(\" \", \"+\");// This is needed, because BASE64 has '+', but it is a HTML escape for ' '\n\t\tBaseUpdateableElement node = ((SimpleToadletServer) ctx.getContainer()).pushDataManager.getRenderedElement(requestId, elementId);\n\t\twriteHTMLReply(ctx, 200, \"OK\", UpdaterConstants.SUCCESS+\":\" + Base64.encodeStandard(node.getUpdaterType().getBytes())+\":\"+Base64.encodeStandard(node.generateChildren().getBytes()));\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tPushDataManager.UpdateEvent event = ((SimpleToadletServer) ctx.getContainer()).pushDataManager.getNextNotification();\n\t\tString requestId = event.getRequestId();\n\t\tString elementId = event.getElementId();\n\t\twriteHTMLReply(ctx, 200, \"OK\", \"SUCCESS:\" + Base64.encodeStandard(requestId.getBytes()) + SEPARATOR +elementId);\n\t}","id":79320,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tPushDataManager.UpdateEvent event = ((SimpleToadletServer) ctx.getContainer()).pushDataManager.getNextNotification();\n\t\tString requestId = event.getRequestId();\n\t\tString elementId = event.getElementId();\n\t\twriteHTMLReply(ctx, 200, \"OK\", UpdaterConstants.SUCCESS+\":\" + Base64.encodeStandard(requestId.getBytes()) + SEPARATOR +elementId);\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void updated(String message) {\n\t\tString requestId = Base64.decode(message.substring(0, message.indexOf(DefaultUpdateManager.SEPARATOR)));\n\t\tif (requestId.compareTo(((DefaultUpdateManager) updateManager).requestId) == 0) {\n\t\t\tString msg = message.substring(message.indexOf(DefaultUpdateManager.SEPARATOR) + 1);\n\t\t\tupdateManager.updated(msg);\n\t\t}\n\t\t// TODO Auto-generated method stub\n\n\t}","id":79321,"modified_method":"@Override\n\tpublic void updated(String message) {\n\t\tString requestId = Base64.decode(message.substring(0, message.indexOf(DefaultUpdateManager.SEPARATOR)));\n\t\tif (requestId.compareTo(FreenetJs.requestId) == 0) {\n\t\t\tString msg = message.substring(message.indexOf(DefaultUpdateManager.SEPARATOR) + 1);\n\t\t\tupdateManager.updated(msg);\n\t\t}\n\t\t// TODO Auto-generated method stub\n\n\t}","commit_id":"6e2ea21efed0ace9c6d616ef99dda45b30f4c5db","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tchildren.clear();\n\n\t\tFProxyFetchWaiter waiter = tracker.makeWaiterForFetchInProgress(key, maxSize, fctx);\n\t\tFProxyFetchResult fr = waiter.getResult();\n\t\tif (fr == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tif (fr.isFinished() || fr.hasData() || fr.failed != null) {\n\t\t\t// If finished then we just send a FINISHED text. It will reload the page\n\t\t\tsetContent(UpdaterConstants.FINISHED);\n\t\t} else {\n\t\t\tint total = fr.requiredBlocks;\n\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\tHTMLNode progressBar = addChild(\"div\", \"class\", \"progressbar\");\n\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\n\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t} else {\n\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t}\n\t\t}\n\t\tif (waiter != null) {\n\t\t\ttracker.getFetchInProgress(key, maxSize, fctx).close(waiter);\n\t\t}\n\t\tif (fr != null) {\n\t\t\ttracker.getFetchInProgress(key, maxSize, fctx).close(fr);\n\t\t}\n\t}","id":79322,"modified_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tchildren.clear();\n\n\t\tFProxyFetchInProgress progress = tracker.getFetchInProgress(key, maxSize, fctx);\n\t\tif (progress == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tFProxyFetchWaiter waiter = progress.getWaiter();\n\t\tif (waiter == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tFProxyFetchResult fr = waiter.getResult();\n\t\tif (fr == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tif (fr.isFinished() || fr.hasData() || fr.failed != null) {\n\t\t\t// If finished then we just send a FINISHED text. It will reload the page\n\t\t\tsetContent(UpdaterConstants.FINISHED);\n\t\t} else {\n\t\t\tint total = fr.requiredBlocks;\n\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\tHTMLNode progressBar = addChild(\"div\", \"class\", \"progressbar\");\n\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\n\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t} else {\n\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t}\n\t\t}\n\t\tif (waiter != null) {\n\t\t\tprogress.close(waiter);\n\t\t}\n\t\tif (fr != null) {\n\t\t\tprogress.close(fr);\n\t\t}\n\t}","commit_id":"63fc2271e5fd34cba802369fc1fe164a585746a9","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tchildren.clear();\n\n\t\tFProxyFetchWaiter waiter = tracker.makeWaiterForFetchInProgress(key, maxSize, fctx);\n\t\tFProxyFetchResult fr = waiter.getResult();\n\t\tif (fr == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tif (fr.isFinished() || fr.hasData() || fr.failed != null) {\n\t\t\t// If finished then we just send a FINISHED text. It will reload the page\n\t\t\tsetContent(UpdaterConstants.FINISHED);\n\t\t} else {\n\t\t\tint total = fr.requiredBlocks;\n\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\tHTMLNode progressBar = addChild(\"div\", \"class\", \"progressbar\");\n\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\n\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t} else {\n\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t}\n\t\t}\n\t\tif (waiter != null) {\n\t\t\ttracker.getFetchInProgress(key, maxSize, fctx).close(waiter);\n\t\t}\n\t\tif (fr != null) {\n\t\t\ttracker.getFetchInProgress(key, maxSize, fctx).close(fr);\n\t\t}\n\t}","id":79323,"modified_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tchildren.clear();\n\n\t\tFProxyFetchInProgress progress = tracker.getFetchInProgress(key, maxSize, fctx);\n\t\tif (progress == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tFProxyFetchWaiter waiter = progress.getWaiter();\n\t\tif (waiter == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tFProxyFetchResult fr = waiter.getResult();\n\t\tif (fr == null) {\n\t\t\taddChild(\"div\", \"No fetcher found\");\n\t\t}\n\t\tif (fr.isFinished() || fr.hasData() || fr.failed != null) {\n\t\t\t// If finished then we just send a FINISHED text. It will reload the page\n\t\t\tsetContent(UpdaterConstants.FINISHED);\n\t\t} else {\n\t\t\tint total = fr.requiredBlocks;\n\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\tHTMLNode progressBar = addChild(\"div\", \"class\", \"progressbar\");\n\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\n\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t} else {\n\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + NodeL10n.getBase().getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t}\n\t\t}\n\t\tif (waiter != null) {\n\t\t\tprogress.close(waiter);\n\t\t}\n\t\tif (fr != null) {\n\t\t\tprogress.close(fr);\n\t\t}\n\t}","commit_id":"9b1e4b2c233a298f963096dbd2ec9cd11768b235","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(FetchResult result, ClientGetter state) {\n\t\tprogressPending = null;\n\t\tfinished = true;\n\t\tFCPMessage msg = new DataFoundMessage(result, identifier);\n\t\tBucket data = result.asBucket();\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t// Send all the data at once\n\t\t\t// FIXME there should be other options\n\t\t\ttrySendDataFoundOrGetFailed(msg);\n\t\t\tAllDataMessage m = new AllDataMessage(data, identifier);\n\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\tm.setFreeOnSent();\n\t\t\ttrySendAllDataMessage(m);\n\t\t\tfinish();\n\t\t\treturn;\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t// Do nothing\n\t\t\ttrySendDataFoundOrGetFailed(msg);\n\t\t\tdata.free();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t// Write to temp file, then rename over filename\n\t\t\tFileOutputStream fos;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(tempFile);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tProtocolErrorMessage pm = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_WRITE_FILE, false, null, identifier);\n\t\t\t\ttrySendDataFoundOrGetFailed(pm);\n\t\t\t\tdata.free();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tBucketTools.copyTo(data, fos, data.size());\n\t\t\t} catch (IOException e) {\n\t\t\t\tProtocolErrorMessage pm = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_WRITE_FILE, false, null, identifier);\n\t\t\t\ttrySendDataFoundOrGetFailed(pm);\n\t\t\t\tdata.free();\n\t\t\t\ttry {\n\t\t\t\t\tfos.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfos.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Caught \"+e+\" closing file \"+tempFile, e);\n\t\t\t}\n\t\t\tif(!tempFile.renameTo(targetFile)) {\n\t\t\t\tProtocolErrorMessage pm = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier);\n\t\t\t\ttrySendDataFoundOrGetFailed(pm);\n\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t}\n\t\t\tdata.free();\n\t\t\ttrySendDataFoundOrGetFailed(msg);\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t}","id":79324,"modified_method":"public void onSuccess(FetchResult result, ClientGetter state) {\n\t\tprogressPending = null;\n\t\tFCPMessage msg = new DataFoundMessage(result, identifier);\n\t\tBucket data = result.asBucket();\n\t\tthis.foundDataLength = data.size();\n\t\tthis.foundDataMimeType = result.getMimeType();\n\t\tthis.succeeded = true;\n\t\tfinished = true;\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t\t\t// Send all the data at once\n\t\t\t// FIXME there should be other options\n\t\t\ttrySendDataFoundOrGetFailed();\n\t\t\tAllDataMessage m = new AllDataMessage(data, identifier);\n\t\t\tif(persistenceType == PERSIST_CONNECTION)\n\t\t\t\tm.setFreeOnSent();\n\t\t\ttrySendAllDataMessage(m);\n\t\t\tfinish();\n\t\t\treturn;\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\t// Do nothing\n\t\t\ttrySendDataFoundOrGetFailed();\n\t\t\tdata.free();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\t// Write to temp file, then rename over filename\n\t\t\tFileOutputStream fos;\n\t\t\ttry {\n\t\t\t\tfos = new FileOutputStream(tempFile);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_WRITE_FILE, false, null, identifier);\n\t\t\t\ttrySendDataFoundOrGetFailed();\n\t\t\t\tdata.free();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tBucketTools.copyTo(data, fos, data.size());\n\t\t\t} catch (IOException e) {\n\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_WRITE_FILE, false, null, identifier);\n\t\t\t\ttrySendDataFoundOrGetFailed();\n\t\t\t\tdata.free();\n\t\t\t\ttry {\n\t\t\t\t\tfos.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfos.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Caught \"+e+\" closing file \"+tempFile, e);\n\t\t\t}\n\t\t\tif(!tempFile.renameTo(targetFile)) {\n\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(ProtocolErrorMessage.COULD_NOT_RENAME_FILE, false, null, identifier);\n\t\t\t\ttrySendDataFoundOrGetFailed();\n\t\t\t\t// Don't delete temp file, user might want it.\n\t\t\t}\n\t\t\tdata.free();\n\t\t\ttrySendDataFoundOrGetFailed();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"public void onFailure(FetchException e, ClientGetter state) {\n\t\tfinished = true;\n\t\tLogger.minor(this, \"Caught \"+e, e);\n\t\tFCPMessage msg = new GetFailedMessage(e, identifier);\n\t\ttrySendDataFoundOrGetFailed(msg);\n\t\tfinish();\n\t}","id":79325,"modified_method":"public void onFailure(FetchException e, ClientGetter state) {\n\t\tsucceeded = false;\n\t\tgetFailedMessage = new GetFailedMessage(e, identifier);\n\t\tfinished = true;\n\t\tLogger.minor(this, \"Caught \"+e, e);\n\t\ttrySendDataFoundOrGetFailed();\n\t\tfinish();\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Create a ClientGet from a request serialized to a SimpleFieldSet.\n\t * Can throw, and does minimal verification, as is dealing with data \n\t * supposedly serialized out by the node.\n\t * @throws MalformedURLException \n\t */\n\tpublic ClientGet(SimpleFieldSet fs, FCPClient client2) throws MalformedURLException {\n\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tverbosity = Integer.parseInt(fs.get(\"Verbosity\"));\n\t\tpriorityClass = Short.parseShort(fs.get(\"PriorityClass\"));\n\t\treturnType = ClientGetMessage.parseValidReturnType(fs.get(\"ReturnType\"));\n\t\tpersistenceType = ClientRequest.parsePersistence(fs.get(\"Persistence\"));\n\t\tif(persistenceType == ClientRequest.PERSIST_CONNECTION)\n\t\t\tthrow new IllegalArgumentException(\"Reading persistent get with type CONNECTION !!\");\n\t\tif(!(persistenceType == ClientRequest.PERSIST_FOREVER || persistenceType == ClientRequest.PERSIST_REBOOT))\n\t\t\tthrow new IllegalArgumentException(\"Unknown persistence type \"+ClientRequest.persistenceTypeString(persistenceType));\n\t\tthis.client = client2;\n\t\tthis.origHandler = null;\n\t\tString f = fs.get(\"Filename\");\n\t\tif(f != null)\n\t\t\ttargetFile = new File(f);\n\t\telse\n\t\t\ttargetFile = null;\n\t\tf = fs.get(\"TempFilename\");\n\t\tif(f != null)\n\t\t\ttempFile = new File(f);\n\t\telse\n\t\t\ttempFile = null;\n\t\tclientToken = fs.get(\"ClientToken\");\n\t\tfinished = Fields.stringToBool(fs.get(\"Finished\"), false);\n\t\tboolean ignoreDS = Fields.stringToBool(fs.get(\"IgnoreDS\"), false);\n\t\tboolean dsOnly = Fields.stringToBool(fs.get(\"DSOnly\"), false);\n\t\tint maxRetries = Integer.parseInt(fs.get(\"MaxRetries\"));\n\t\tfctx = new FetcherContext(client.defaultFetchContext, FetcherContext.IDENTICAL_MASK);\n\t\tfctx.eventProducer.addEventListener(this);\n\t\t// ignoreDS\n\t\tfctx.localRequestOnly = dsOnly;\n\t\tfctx.ignoreStore = ignoreDS;\n\t\tfctx.maxNonSplitfileRetries = maxRetries;\n\t\tfctx.maxSplitfileBlockRetries = maxRetries;\n\t\tgetter = new ClientGetter(this, client.node.fetchScheduler, uri, fctx, priorityClass, client);\n\t\tstart();\n\t}","id":79326,"modified_method":"/**\n\t * Create a ClientGet from a request serialized to a SimpleFieldSet.\n\t * Can throw, and does minimal verification, as is dealing with data \n\t * supposedly serialized out by the node.\n\t * @throws MalformedURLException \n\t */\n\tpublic ClientGet(SimpleFieldSet fs, FCPClient client2) throws MalformedURLException {\n\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tverbosity = Integer.parseInt(fs.get(\"Verbosity\"));\n\t\tpriorityClass = Short.parseShort(fs.get(\"PriorityClass\"));\n\t\treturnType = ClientGetMessage.parseValidReturnType(fs.get(\"ReturnType\"));\n\t\tpersistenceType = ClientRequest.parsePersistence(fs.get(\"Persistence\"));\n\t\tif(persistenceType == ClientRequest.PERSIST_CONNECTION)\n\t\t\tthrow new IllegalArgumentException(\"Reading persistent get with type CONNECTION !!\");\n\t\tif(!(persistenceType == ClientRequest.PERSIST_FOREVER || persistenceType == ClientRequest.PERSIST_REBOOT))\n\t\t\tthrow new IllegalArgumentException(\"Unknown persistence type \"+ClientRequest.persistenceTypeString(persistenceType));\n\t\tthis.client = client2;\n\t\tthis.origHandler = null;\n\t\tString f = fs.get(\"Filename\");\n\t\tif(f != null)\n\t\t\ttargetFile = new File(f);\n\t\telse\n\t\t\ttargetFile = null;\n\t\tf = fs.get(\"TempFilename\");\n\t\tif(f != null)\n\t\t\ttempFile = new File(f);\n\t\telse\n\t\t\ttempFile = null;\n\t\tclientToken = fs.get(\"ClientToken\");\n\t\tfinished = Fields.stringToBool(fs.get(\"Finished\"), false);\n\t\tboolean ignoreDS = Fields.stringToBool(fs.get(\"IgnoreDS\"), false);\n\t\tboolean dsOnly = Fields.stringToBool(fs.get(\"DSOnly\"), false);\n\t\tint maxRetries = Integer.parseInt(fs.get(\"MaxRetries\"));\n\t\tfctx = new FetcherContext(client.defaultFetchContext, FetcherContext.IDENTICAL_MASK);\n\t\tfctx.eventProducer.addEventListener(this);\n\t\t// ignoreDS\n\t\tfctx.localRequestOnly = dsOnly;\n\t\tfctx.ignoreStore = ignoreDS;\n\t\tfctx.maxNonSplitfileRetries = maxRetries;\n\t\tfctx.maxSplitfileBlockRetries = maxRetries;\n\t\tsucceeded = Fields.stringToBool(fs.get(\"Succeeded\"), false);\n\t\tif(finished) {\n\t\t\tif(succeeded) {\n\t\t\t\tfoundDataLength = Long.parseLong(fs.get(\"FoundDataLength\"));\n\t\t\t\tfoundDataMimeType = fs.get(\"FoundDataMimeType\");\n\t\t\t\tSimpleFieldSet fs1 = fs.subset(\"PostFetchProtocolError\");\n\t\t\t\tif(fs1 != null)\n\t\t\t\t\tpostFetchProtocolErrorMessage = new ProtocolErrorMessage(fs1);\n\t\t\t} else {\n\t\t\t\tgetFailedMessage = new GetFailedMessage(fs.subset(\"GetFailed\"), false);\n\t\t\t}\n\t\t}\n\t\t\n\t\tgetter = new ClientGetter(this, client.node.fetchScheduler, uri, fctx, priorityClass, client);\n\t\tstart();\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"private void trySendDataFoundOrGetFailed(FCPMessage msg) {\n\t\tif(persistenceType != ClientRequest.PERSIST_CONNECTION) {\n\t\t\tdataFoundOrGetFailedPending = msg;\n\t\t}\n\t\tFCPConnectionHandler conn = client.getConnection();\n\t\tif(conn != null)\n\t\t\tconn.outputHandler.queue(msg);\n\t}","id":79327,"modified_method":"private void trySendDataFoundOrGetFailed() {\n\t\t\n\t\tFCPMessage msg;\n\n\t\tif(postFetchProtocolErrorMessage != null) {\n\t\t\tmsg = postFetchProtocolErrorMessage;\n\t\t} else if(succeeded) {\n\t\t\tmsg = new DataFoundMessage(foundDataLength, foundDataMimeType, identifier);\n\t\t} else {\n\t\t\tmsg = getFailedMessage;\n\t\t}\n\t\t\n\t\tFCPConnectionHandler conn = client.getConnection();\n\t\tif(conn != null)\n\t\t\tconn.outputHandler.queue(msg);\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"public SimpleFieldSet getFieldSet() {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(true); // we will need multi-level later...\n\t\tfs.put(\"Type\", \"GET\");\n\t\tfs.put(\"URI\", uri.toString(false));\n\t\tfs.put(\"Identifier\", identifier);\n\t\tfs.put(\"Verbosity\", Integer.toString(verbosity));\n\t\tfs.put(\"PriorityClass\", Short.toString(priorityClass));\n\t\tfs.put(\"ReturnType\", ClientGetMessage.returnTypeString(returnType));\n\t\tfs.put(\"Persistence\", ClientRequest.persistenceTypeString(persistenceType));\n\t\tfs.put(\"ClientName\", client.name);\n\t\tif(targetFile != null)\n\t\t\tfs.put(\"Filename\", targetFile.getPath());\n\t\tif(tempFile != null)\n\t\t\tfs.put(\"TempFilename\", tempFile.getPath());\n\t\tif(clientToken != null)\n\t\t\tfs.put(\"ClientToken\", clientToken);\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DISK && targetFile != null) {\n\t\t\t// Otherwise we must re-run it anyway as we don't have the data.\n\t\t\t\n\t\t\t// finished => persistence of completion state, pending messages\n\t\t\t//fs.put(\"Finished\", Boolean.toString(finished));\n\t\t}\n\t\tfs.put(\"IgnoreDS\", Boolean.toString(fctx.ignoreStore));\n\t\tfs.put(\"DSOnly\", Boolean.toString(fctx.localRequestOnly));\n\t\tfs.put(\"MaxRetries\", Integer.toString(fctx.maxNonSplitfileRetries));\n\t\treturn fs;\n\t}","id":79328,"modified_method":"public SimpleFieldSet getFieldSet() {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(true); // we will need multi-level later...\n\t\tfs.put(\"Type\", \"GET\");\n\t\tfs.put(\"URI\", uri.toString(false));\n\t\tfs.put(\"Identifier\", identifier);\n\t\tfs.put(\"Verbosity\", Integer.toString(verbosity));\n\t\tfs.put(\"PriorityClass\", Short.toString(priorityClass));\n\t\tfs.put(\"ReturnType\", ClientGetMessage.returnTypeString(returnType));\n\t\tfs.put(\"Persistence\", ClientRequest.persistenceTypeString(persistenceType));\n\t\tfs.put(\"ClientName\", client.name);\n\t\tif(targetFile != null)\n\t\t\tfs.put(\"Filename\", targetFile.getPath());\n\t\tif(tempFile != null)\n\t\t\tfs.put(\"TempFilename\", tempFile.getPath());\n\t\tif(clientToken != null)\n\t\t\tfs.put(\"ClientToken\", clientToken);\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DISK && targetFile != null) {\n\t\t\t// Otherwise we must re-run it anyway as we don't have the data.\n\t\t\t\n\t\t\t// finished => persistence of completion state, pending messages\n\t\t\t//fs.put(\"Finished\", Boolean.toString(finished));\n\t\t}\n\t\tfs.put(\"IgnoreDS\", Boolean.toString(fctx.ignoreStore));\n\t\tfs.put(\"DSOnly\", Boolean.toString(fctx.localRequestOnly));\n\t\tfs.put(\"MaxRetries\", Integer.toString(fctx.maxNonSplitfileRetries));\n\t\tfs.put(\"Finished\", Boolean.toString(finished));\n\t\tfs.put(\"Succeeded\", Boolean.toString(succeeded));\n\t\tif(finished) {\n\t\t\tif(succeeded) {\n\t\t\t\tfs.put(\"FoundDataLength\", Long.toString(foundDataLength));\n\t\t\t\tfs.put(\"FoundDataMimeType\", foundDataMimeType);\n\t\t\t\tif(postFetchProtocolErrorMessage != null) {\n\t\t\t\t\tfs.put(\"PostFetchProtocolError\", postFetchProtocolErrorMessage.getFieldSet());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(getFailedMessage != null) {\n\t\t\t\t\tfs.put(\"GetFailed\", getFailedMessage.getFieldSet(false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn fs;\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"public void sendPendingMessages(FCPConnectionOutputHandler handler, boolean includePersistentRequest) {\n\t\tif(persistenceType == ClientRequest.PERSIST_CONNECTION) {\n\t\t\tLogger.error(this, \"WTF? persistenceType=\"+persistenceType, new Exception(\"error\"));\n\t\t\treturn;\n\t\t}\n\t\tif(includePersistentRequest) {\n\t\t\tFCPMessage msg = new PersistentGet(identifier, uri, verbosity, priorityClass, returnType, persistenceType, targetFile, tempFile, clientToken);\n\t\t\thandler.queue(msg);\n\t\t}\n\t\tif(progressPending != null)\n\t\t\thandler.queue(progressPending);\n\t\tif(dataFoundOrGetFailedPending != null)\n\t\t\thandler.queue(dataFoundOrGetFailedPending);\n\t\tif(allDataPending != null)\n\t\t\thandler.queue(allDataPending);\n\t}","id":79329,"modified_method":"public void sendPendingMessages(FCPConnectionOutputHandler handler, boolean includePersistentRequest) {\n\t\tif(persistenceType == ClientRequest.PERSIST_CONNECTION) {\n\t\t\tLogger.error(this, \"WTF? persistenceType=\"+persistenceType, new Exception(\"error\"));\n\t\t\treturn;\n\t\t}\n\t\tif(includePersistentRequest) {\n\t\t\tFCPMessage msg = new PersistentGet(identifier, uri, verbosity, priorityClass, returnType, persistenceType, targetFile, tempFile, clientToken);\n\t\t\thandler.queue(msg);\n\t\t}\n\t\tif(progressPending != null)\n\t\t\thandler.queue(progressPending);\n\t\tif(finished)\n\t\t\ttrySendDataFoundOrGetFailed();\n\t\tif(allDataPending != null)\n\t\t\thandler.queue(allDataPending);\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"public ClientGetMessage(SimpleFieldSet fs) throws MessageInvalidException {\n\t\tshort defaultPriority;\n\t\tclientToken = fs.get(\"ClientToken\");\n\t\tignoreDS = Fields.stringToBool(fs.get(\"IgnoreDS\"), false);\n\t\tdsOnly = Fields.stringToBool(fs.get(\"DSOnly\"), false);\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null)\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No Identifier\", null);\n\t\ttry {\n\t\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.URI_PARSE_ERROR, e.getMessage(), identifier);\n\t\t}\n\t\tString verbosityString = fs.get(\"Verbosity\");\n\t\tif(verbosityString == null)\n\t\t\tverbosity = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tverbosity = Integer.parseInt(verbosityString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Verbosity field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString returnTypeString = fs.get(\"ReturnType\");\n\t\treturnType = parseReturnType(returnTypeString);\n\t\tif(returnType == RETURN_TYPE_DIRECT) {\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\t// default just below fproxy\n\t\t\tdefaultPriority = RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS;\n\t\t} else if(returnType == RETURN_TYPE_NONE) {\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\tdefaultPriority = RequestStarter.PREFETCH_PRIORITY_CLASS;\n\t\t} else if(returnType == RETURN_TYPE_DISK) {\n\t\t\tdefaultPriority = RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS;\n\t\t\tString filename = fs.get(\"Filename\");\n\t\t\tif(filename == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Missing Filename\", identifier);\n\t\t\tdiskFile = new File(filename);\n\t\t\tString tempFilename = fs.get(\"TempFilename\");\n\t\t\tif(tempFilename == null)\n\t\t\t\ttempFilename = filename + \".freenet-tmp\";\n\t\t\ttempFile = new File(tempFilename);\n\t\t\tif(!diskFile.getAbsoluteFile().getParentFile().equals(tempFile.getAbsoluteFile().getParentFile()))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.FILENAME_AND_TEMP_FILENAME_MUST_BE_IN_SAME_DIR, null, identifier);\n\t\t\tif(diskFile.exists())\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.DISK_TARGET_EXISTS, null, identifier);\n\t\t\ttry {\n\t\t\t\tif(!tempFile.createNewFile())\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, null, identifier);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, e.getMessage(), identifier);\n\t\t\t}\n\t\t} else\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MESSAGE_PARSE_ERROR, \"Unknown return-type\", identifier);\n\t\tString maxSizeString = fs.get(\"MaxSize\");\n\t\tif(maxSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxSize = Long.parseLong(maxSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxTempSizeString = fs.get(\"MaxTempSize\");\n\t\tif(maxTempSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxTempSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxTempSize = Long.parseLong(maxTempSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxRetriesString = fs.get(\"MaxRetries\");\n\t\tif(maxRetriesString == null)\n\t\t\t// default to 0\n\t\t\tmaxRetries = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxRetries = Integer.parseInt(maxRetriesString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tLogger.minor(this, \"max retries=\"+maxRetries);\n\t\tString priorityString = fs.get(\"PriorityClass\");\n\t\tif(priorityString == null) {\n\t\t\t// defaults to the one just below fproxy\n\t\t\tpriorityClass = defaultPriority;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpriorityClass = Short.parseShort(priorityString, 10);\n\t\t\t\tif(priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS || priorityClass > RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_FIELD, \"Valid priorities are from \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" to \"+RequestStarter.MINIMUM_PRIORITY_CLASS, identifier);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing PriorityClass field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString persistenceString = fs.get(\"Persistence\");\n\t\tif(persistenceString == null || persistenceString.equalsIgnoreCase(\"connection\")) {\n\t\t\t// Default: persists until connection loss.\n\t\t\tpersistenceType = ClientRequest.PERSIST_CONNECTION;\n\t\t} else if(persistenceString.equalsIgnoreCase(\"reboot\")) {\n\t\t\t// Reports to client by name; persists over connection loss.\n\t\t\t// Not saved to disk, so dies on reboot.\n\t\t\tpersistenceType = ClientRequest.PERSIST_REBOOT;\n\t\t} else if(persistenceString.equalsIgnoreCase(\"forever\")) {\n\t\t\t// Same as reboot but saved to disk, persists forever.\n\t\t\tpersistenceType = ClientRequest.PERSIST_FOREVER;\n\t\t} else {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Persistence field: \"+persistenceString, identifier);\n\t\t}\n\t}","id":79330,"modified_method":"public ClientGetMessage(SimpleFieldSet fs) throws MessageInvalidException {\n\t\tshort defaultPriority;\n\t\tclientToken = fs.get(\"ClientToken\");\n\t\tignoreDS = Fields.stringToBool(fs.get(\"IgnoreDS\"), false);\n\t\tdsOnly = Fields.stringToBool(fs.get(\"DSOnly\"), false);\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null)\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No Identifier\", null);\n\t\ttry {\n\t\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.URI_PARSE_ERROR, e.getMessage(), identifier);\n\t\t}\n\t\tString verbosityString = fs.get(\"Verbosity\");\n\t\tif(verbosityString == null)\n\t\t\tverbosity = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tverbosity = Integer.parseInt(verbosityString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Verbosity field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString returnTypeString = fs.get(\"ReturnType\");\n\t\treturnType = parseReturnType(returnTypeString);\n\t\tif(returnType == RETURN_TYPE_DIRECT) {\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\t// default just below fproxy\n\t\t\tdefaultPriority = RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS;\n\t\t} else if(returnType == RETURN_TYPE_NONE) {\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\tdefaultPriority = RequestStarter.PREFETCH_PRIORITY_CLASS;\n\t\t} else if(returnType == RETURN_TYPE_DISK) {\n\t\t\tdefaultPriority = RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS;\n\t\t\tString filename = fs.get(\"Filename\");\n\t\t\tif(filename == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Missing Filename\", identifier);\n\t\t\tdiskFile = new File(filename);\n\t\t\tString tempFilename = fs.get(\"TempFilename\");\n\t\t\tif(tempFilename == null)\n\t\t\t\ttempFilename = filename + \".freenet-tmp\";\n\t\t\ttempFile = new File(tempFilename);\n\t\t\tif(!diskFile.getAbsoluteFile().getParentFile().equals(tempFile.getAbsoluteFile().getParentFile()))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.FILENAME_AND_TEMP_FILENAME_MUST_BE_IN_SAME_DIR, null, identifier);\n\t\t\tif(diskFile.exists())\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.DISK_TARGET_EXISTS, null, identifier);\n\t\t\ttry {\n\t\t\t\tif(!tempFile.createNewFile())\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, null, identifier);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, e.getMessage(), identifier);\n\t\t\t}\n\t\t} else\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MESSAGE_PARSE_ERROR, \"Unknown return-type\", identifier);\n\t\tString maxSizeString = fs.get(\"MaxSize\");\n\t\tif(maxSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxSize = Long.parseLong(maxSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxTempSizeString = fs.get(\"MaxTempSize\");\n\t\tif(maxTempSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxTempSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxTempSize = Long.parseLong(maxTempSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxRetriesString = fs.get(\"MaxRetries\");\n\t\tif(maxRetriesString == null)\n\t\t\t// default to 0\n\t\t\tmaxRetries = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxRetries = Integer.parseInt(maxRetriesString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tLogger.minor(this, \"max retries=\"+maxRetries);\n\t\tString priorityString = fs.get(\"PriorityClass\");\n\t\tif(priorityString == null) {\n\t\t\t// defaults to the one just below fproxy\n\t\t\tpriorityClass = defaultPriority;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpriorityClass = Short.parseShort(priorityString, 10);\n\t\t\t\tif(priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS || priorityClass > RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_FIELD, \"Valid priorities are from \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" to \"+RequestStarter.MINIMUM_PRIORITY_CLASS, identifier);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing PriorityClass field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString persistenceString = fs.get(\"Persistence\");\n\t\tif(persistenceString == null || persistenceString.equalsIgnoreCase(\"connection\")) {\n\t\t\t// Default: persists until connection loss.\n\t\t\tpersistenceType = ClientRequest.PERSIST_CONNECTION;\n\t\t} else if(persistenceString.equalsIgnoreCase(\"reboot\")) {\n\t\t\t// Reports to client by name; persists over connection loss.\n\t\t\t// Not saved to disk, so dies on reboot.\n\t\t\tpersistenceType = ClientRequest.PERSIST_REBOOT;\n\t\t} else if(persistenceString.equalsIgnoreCase(\"forever\")) {\n\t\t\t// Same as reboot but saved to disk, persists forever.\n\t\t\tpersistenceType = ClientRequest.PERSIST_FOREVER;\n\t\t\t// FIXME for now we only support returntype=disk if persistenceType=forever.\n\t\t\tif(returnType != RETURN_TYPE_DISK) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.NOT_SUPPORTED, \"PersistenceType=forever implies ReturnType=disk\", identifier);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Persistence field: \"+persistenceString, identifier);\n\t\t}\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Construct from a fieldset. Used in serialization of persistent requests.\n\t * Will need to be made more tolerant of syntax errors if is used in an FCP\n\t * client library. FIXME.\n\t * @param useVerboseFields If true, read in verbose fields (CodeDescription\n\t * etc), if false, reconstruct them from the error code.\n\t * @throws MalformedURLException \n\t */\n\tpublic PutFailedMessage(SimpleFieldSet fs, boolean useVerboseFields) throws MalformedURLException {\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null) throw new NullPointerException();\n\t\tcode = Integer.parseInt(fs.get(\"Code\"));\n\t\t\n\t\tif(useVerboseFields) {\n\t\t\tcodeDescription = fs.get(\"CodeDescription\");\n\t\t\tisFatal = Fields.stringToBool(fs.get(\"Fatal\"), false);\n\t\t\tcodeShortDescription = fs.get(\"ShortCodeDescription\");\n\t\t} else {\n\t\t\tcodeDescription = InserterException.getMessage(code);\n\t\t\tisFatal = InserterException.isFatal(code);\n\t\t\tcodeShortDescription = InserterException.getShortMessage(code);\n\t\t}\n\t\t\n\t\textraDescription = fs.get(\"ExtraDescription\");\n\t\tString euri = fs.get(\"ExpectedURI\");\n\t\texpectedURI = new FreenetURI(euri);\n\t\tSimpleFieldSet trackerSubset = fs.subset(\"Errors\");\n\t\tif(trackerSubset != null) {\n\t\t\ttracker = new FailureCodeTracker(true, trackerSubset);\n\t\t} else {\n\t\t\ttracker = null;\n\t\t}\n\t}","id":79331,"modified_method":"/**\n\t * Construct from a fieldset. Used in serialization of persistent requests.\n\t * Will need to be made more tolerant of syntax errors if is used in an FCP\n\t * client library. FIXME.\n\t * @param useVerboseFields If true, read in verbose fields (CodeDescription\n\t * etc), if false, reconstruct them from the error code.\n\t * @throws MalformedURLException \n\t */\n\tpublic PutFailedMessage(SimpleFieldSet fs, boolean useVerboseFields) throws MalformedURLException {\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null) throw new NullPointerException();\n\t\tcode = Integer.parseInt(fs.get(\"Code\"));\n\t\t\n\t\tif(useVerboseFields) {\n\t\t\tcodeDescription = fs.get(\"CodeDescription\");\n\t\t\tisFatal = Fields.stringToBool(fs.get(\"Fatal\"), false);\n\t\t\tshortCodeDescription = fs.get(\"ShortCodeDescription\");\n\t\t} else {\n\t\t\tcodeDescription = InserterException.getMessage(code);\n\t\t\tisFatal = InserterException.isFatal(code);\n\t\t\tshortCodeDescription = InserterException.getShortMessage(code);\n\t\t}\n\t\t\n\t\textraDescription = fs.get(\"ExtraDescription\");\n\t\tString euri = fs.get(\"ExpectedURI\");\n\t\texpectedURI = new FreenetURI(euri);\n\t\tSimpleFieldSet trackerSubset = fs.subset(\"Errors\");\n\t\tif(trackerSubset != null) {\n\t\t\ttracker = new FailureCodeTracker(true, trackerSubset);\n\t\t} else {\n\t\t\ttracker = null;\n\t\t}\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"public SimpleFieldSet getFieldSet(boolean verbose) {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(false);\n\t\tfs.put(\"Identifier\", identifier);\n\t\tfs.put(\"Code\", Integer.toString(code));\n\t\tif(verbose)\n\t\t\tfs.put(\"CodeDescription\", codeDescription);\n\t\tif(extraDescription != null)\n\t\t\tfs.put(\"ExtraDescription\", extraDescription);\n\t\tif(tracker != null) {\n\t\t\ttracker.copyToFieldSet(fs, \"Errors.\", verbose);\n\t\t}\n\t\tif(verbose)\n\t\t\tfs.put(\"Fatal\", Boolean.toString(isFatal));\n\t\tif(verbose)\n\t\t\tfs.put(\"ShortCodeDescription\", codeShortDescription);\n\t\tif(expectedURI != null)\n\t\t\tfs.put(\"ExpectedURI\", expectedURI.toString());\n\t\treturn fs;\n\t}","id":79332,"modified_method":"public SimpleFieldSet getFieldSet(boolean verbose) {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(false);\n\t\tfs.put(\"Identifier\", identifier);\n\t\tfs.put(\"Code\", Integer.toString(code));\n\t\tif(verbose)\n\t\t\tfs.put(\"CodeDescription\", codeDescription);\n\t\tif(extraDescription != null)\n\t\t\tfs.put(\"ExtraDescription\", extraDescription);\n\t\tif(tracker != null) {\n\t\t\ttracker.copyToFieldSet(fs, \"Errors.\", verbose);\n\t\t}\n\t\tif(verbose)\n\t\t\tfs.put(\"Fatal\", Boolean.toString(isFatal));\n\t\tif(verbose)\n\t\t\tfs.put(\"ShortCodeDescription\", shortCodeDescription);\n\t\tif(expectedURI != null)\n\t\t\tfs.put(\"ExpectedURI\", expectedURI.toString());\n\t\treturn fs;\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"public PutFailedMessage(InserterException e, String identifier) {\n\t\tthis.code = e.getMode();\n\t\tthis.codeDescription = InserterException.getMessage(code);\n\t\tthis.codeShortDescription = InserterException.getShortMessage(code);\n\t\tthis.extraDescription = e.extra;\n\t\tthis.tracker = e.errorCodes;\n\t\tthis.expectedURI = e.uri;\n\t\tthis.identifier = identifier;\n\t\tthis.isFatal = InserterException.isFatal(code);\n\t}","id":79333,"modified_method":"public PutFailedMessage(InserterException e, String identifier) {\n\t\tthis.code = e.getMode();\n\t\tthis.codeDescription = InserterException.getMessage(code);\n\t\tthis.shortCodeDescription = InserterException.getShortMessage(code);\n\t\tthis.extraDescription = e.extra;\n\t\tthis.tracker = e.errorCodes;\n\t\tthis.expectedURI = e.uri;\n\t\tthis.identifier = identifier;\n\t\tthis.isFatal = InserterException.isFatal(code);\n\t}","commit_id":"deadd1f0ae26bf25aaafaaa90efc626a48013605","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * @see org.opencms.xml.A_CmsXmlDocument#initDocument(org.dom4j.Document, java.lang.String, org.opencms.xml.CmsXmlContentDefinition)\n     */\n    @Override\n    protected void initDocument(Document document, String encoding, CmsXmlContentDefinition definition) {\n\n        m_document = document;\n        m_contentDefinition = definition;\n        m_encoding = CmsEncoder.lookupEncoding(encoding, encoding);\n        m_elementLocales = new HashMap<String, Set<Locale>>();\n        m_elementNames = new HashMap<Locale, Set<String>>();\n        m_locales = new HashSet<Locale>();\n        m_cntPages = new HashMap<Locale, CmsContainerPageBean>();\n        clearBookmarks();\n\n        // initialize the bookmarks\n        for (Iterator<Element> itCntPages = CmsXmlGenericWrapper.elementIterator(m_document.getRootElement()); itCntPages.hasNext();) {\n            Element cntPage = itCntPages.next();\n\n            try {\n                Locale locale = CmsLocaleManager.getLocale(cntPage.attribute(\n                    CmsXmlContentDefinition.XSD_ATTRIBUTE_VALUE_LANGUAGE).getValue());\n\n                addLocale(locale);\n\n                List<CmsContainerBean> containers = new ArrayList<CmsContainerBean>();\n                for (Iterator<Element> itCnts = CmsXmlGenericWrapper.elementIterator(\n                    cntPage,\n                    XmlNode.CONTAINER.getName()); itCnts.hasNext();) {\n                    Element container = itCnts.next();\n\n                    // container itself\n                    int cntIndex = CmsXmlUtils.getXpathIndexInt(container.getUniquePath(cntPage));\n                    String cntPath = CmsXmlUtils.createXpathElement(container.getName(), cntIndex);\n                    I_CmsXmlSchemaType cntSchemaType = definition.getSchemaType(container.getName());\n                    I_CmsXmlContentValue cntValue = cntSchemaType.createValue(this, container, locale);\n                    addBookmark(cntPath, locale, true, cntValue);\n                    CmsXmlContentDefinition cntDef = ((CmsXmlNestedContentDefinition)cntSchemaType).getNestedContentDefinition();\n\n                    // name\n                    Element name = container.element(XmlNode.NAME.getName());\n                    createBookmark(name, locale, container, cntPath, cntDef);\n\n                    // type\n                    Element type = container.element(XmlNode.TYPE.getName());\n                    createBookmark(type, locale, container, cntPath, cntDef);\n\n                    List<CmsContainerElementBean> elements = new ArrayList<CmsContainerElementBean>();\n                    // Elements\n                    for (Iterator<Element> itElems = CmsXmlGenericWrapper.elementIterator(\n                        container,\n                        XmlNode.ELEMENT.getName()); itElems.hasNext();) {\n                        Element element = itElems.next();\n\n                        // element itself\n                        int elemIndex = CmsXmlUtils.getXpathIndexInt(element.getUniquePath(container));\n                        String elemPath = CmsXmlUtils.createXpathElement(element.getName(), elemIndex);\n                        I_CmsXmlSchemaType elemSchemaType = cntDef.getSchemaType(element.getName());\n                        I_CmsXmlContentValue elemValue = elemSchemaType.createValue(this, element, locale);\n                        addBookmark(elemPath, locale, true, elemValue);\n                        CmsXmlContentDefinition elemDef = ((CmsXmlNestedContentDefinition)elemSchemaType).getNestedContentDefinition();\n\n                        // uri\n                        Element uri = element.element(XmlNode.URI.getName());\n                        createBookmark(uri, locale, element, elemPath, elemDef);\n                        CmsUUID elementId = new CmsLink(uri.element(CmsXmlPage.NODE_LINK)).getStructureId();\n\n                        // formatter\n                        Element formatter = element.element(XmlNode.FORMATTER.getName());\n                        createBookmark(formatter, locale, element, elemPath, elemDef);\n                        CmsUUID formatterId = new CmsLink(formatter.element(CmsXmlPage.NODE_LINK)).getStructureId();\n\n                        Map<String, String> propertiesMap = new HashMap<String, String>();\n\n                        // Properties\n                        for (Iterator<Element> itProps = CmsXmlGenericWrapper.elementIterator(\n                            element,\n                            XmlNode.PROPERTIES.getName()); itProps.hasNext();) {\n                            Element property = itProps.next();\n\n                            // property itself\n                            int propIndex = CmsXmlUtils.getXpathIndexInt(property.getUniquePath(element));\n                            String propPath = CmsXmlUtils.createXpathElement(property.getName(), propIndex);\n                            I_CmsXmlSchemaType propSchemaType = elemDef.getSchemaType(property.getName());\n                            I_CmsXmlContentValue propValue = propSchemaType.createValue(this, property, locale);\n                            addBookmark(propPath, locale, true, propValue);\n                            CmsXmlContentDefinition propDef = ((CmsXmlNestedContentDefinition)propSchemaType).getNestedContentDefinition();\n\n                            // name\n                            Element propName = property.element(XmlNode.NAME.getName());\n                            createBookmark(propName, locale, property, propPath, propDef);\n\n                            // choice value \n                            Element value = property.element(XmlNode.VALUE.getName());\n                            int valueIndex = CmsXmlUtils.getXpathIndexInt(value.getUniquePath(property));\n                            String valuePath = CmsXmlUtils.createXpathElement(value.getName(), valueIndex);\n                            I_CmsXmlSchemaType valueSchemaType = propDef.getSchemaType(value.getName());\n                            I_CmsXmlContentValue valueValue = propSchemaType.createValue(this, value, locale);\n                            addBookmark(valuePath, locale, true, valueValue);\n                            CmsXmlContentDefinition valueDef = ((CmsXmlNestedContentDefinition)valueSchemaType).getNestedContentDefinition();\n\n                            String val = null;\n                            Element string = value.element(XmlNode.STRING.getName());\n                            if (string != null) {\n                                // string value\n                                createBookmark(string, locale, value, valuePath, valueDef);\n                                val = string.getTextTrim();\n                            } else {\n                                // uri value\n                                Element valueUri = value.element(XmlNode.URI.getName());\n                                createBookmark(valueUri, locale, value, valuePath, valueDef);\n                                val = new CmsLink(valueUri.element(CmsXmlPage.NODE_LINK)).getStructureId().toString(); // uuid\n                            }\n\n                            propertiesMap.put(propName.getTextTrim(), val);\n                        }\n\n                        elements.add(new CmsContainerElementBean(elementId, formatterId, propertiesMap));\n                    }\n\n                    containers.add(new CmsContainerBean(name.getText(), type.getText(), -1, elements));\n                }\n\n                m_cntPages.put(locale, new CmsContainerPageBean(locale, containers));\n            } catch (NullPointerException e) {\n                LOG.error(org.opencms.xml.content.Messages.get().getBundle().key(\n                    org.opencms.xml.content.Messages.LOG_XMLCONTENT_INIT_BOOKMARKS_0), e);\n            }\n        }\n    }","id":79334,"modified_method":"/**\n     * @see org.opencms.xml.A_CmsXmlDocument#initDocument(org.dom4j.Document, java.lang.String, org.opencms.xml.CmsXmlContentDefinition)\n     */\n    @Override\n    protected void initDocument(Document document, String encoding, CmsXmlContentDefinition definition) {\n\n        m_document = document;\n        m_contentDefinition = definition;\n        m_encoding = CmsEncoder.lookupEncoding(encoding, encoding);\n        m_elementLocales = new HashMap<String, Set<Locale>>();\n        m_elementNames = new HashMap<Locale, Set<String>>();\n        m_locales = new HashSet<Locale>();\n        m_cntPages = new HashMap<Locale, CmsContainerPageBean>();\n        clearBookmarks();\n\n        // initialize the bookmarks\n        for (Iterator<Element> itCntPages = CmsXmlGenericWrapper.elementIterator(m_document.getRootElement()); itCntPages.hasNext();) {\n            Element cntPage = itCntPages.next();\n\n            try {\n                Locale locale = CmsLocaleManager.getLocale(cntPage.attribute(\n                    CmsXmlContentDefinition.XSD_ATTRIBUTE_VALUE_LANGUAGE).getValue());\n\n                addLocale(locale);\n\n                List<CmsContainerBean> containers = new ArrayList<CmsContainerBean>();\n                for (Iterator<Element> itCnts = CmsXmlGenericWrapper.elementIterator(\n                    cntPage,\n                    XmlNode.CONTAINER.getName()); itCnts.hasNext();) {\n                    Element container = itCnts.next();\n\n                    // container itself\n                    int cntIndex = CmsXmlUtils.getXpathIndexInt(container.getUniquePath(cntPage));\n                    String cntPath = CmsXmlUtils.createXpathElement(container.getName(), cntIndex);\n                    I_CmsXmlSchemaType cntSchemaType = definition.getSchemaType(container.getName());\n                    I_CmsXmlContentValue cntValue = cntSchemaType.createValue(this, container, locale);\n                    addBookmark(cntPath, locale, true, cntValue);\n                    CmsXmlContentDefinition cntDef = ((CmsXmlNestedContentDefinition)cntSchemaType).getNestedContentDefinition();\n\n                    // name\n                    Element name = container.element(XmlNode.NAME.getName());\n                    createBookmark(name, locale, container, cntPath, cntDef);\n\n                    // type\n                    Element type = container.element(XmlNode.TYPE.getName());\n                    createBookmark(type, locale, container, cntPath, cntDef);\n\n                    List<CmsContainerElementBean> elements = new ArrayList<CmsContainerElementBean>();\n                    // Elements\n                    for (Iterator<Element> itElems = CmsXmlGenericWrapper.elementIterator(\n                        container,\n                        XmlNode.ELEMENT.getName()); itElems.hasNext();) {\n                        Element element = itElems.next();\n\n                        // element itself\n                        int elemIndex = CmsXmlUtils.getXpathIndexInt(element.getUniquePath(container));\n                        String elemPath = CmsXmlUtils.concatXpath(cntPath, CmsXmlUtils.createXpathElement(\n                            element.getName(),\n                            elemIndex));\n                        I_CmsXmlSchemaType elemSchemaType = cntDef.getSchemaType(element.getName());\n                        I_CmsXmlContentValue elemValue = elemSchemaType.createValue(this, element, locale);\n                        addBookmark(elemPath, locale, true, elemValue);\n                        CmsXmlContentDefinition elemDef = ((CmsXmlNestedContentDefinition)elemSchemaType).getNestedContentDefinition();\n\n                        // uri\n                        Element uri = element.element(XmlNode.URI.getName());\n                        createBookmark(uri, locale, element, elemPath, elemDef);\n                        Element uriLink = uri.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID elementId = null;\n                        if (uriLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            elementId = new CmsLink(uriLink).getStructureId();\n                        }\n\n                        // formatter\n                        Element formatter = element.element(XmlNode.FORMATTER.getName());\n                        createBookmark(formatter, locale, element, elemPath, elemDef);\n                        Element formatterLink = formatter.element(CmsXmlPage.NODE_LINK);\n                        CmsUUID formatterId = null;\n                        if (formatterLink == null) {\n                            // this can happen when adding the elements node to the xml content\n                            // it is not dangerous since the link has to be set before saving \n                        } else {\n                            formatterId = new CmsLink(formatterLink).getStructureId();\n                        }\n\n                        Map<String, String> propertiesMap = new HashMap<String, String>();\n\n                        // Properties\n                        for (Iterator<Element> itProps = CmsXmlGenericWrapper.elementIterator(\n                            element,\n                            XmlNode.PROPERTIES.getName()); itProps.hasNext();) {\n                            Element property = itProps.next();\n\n                            // property itself\n                            int propIndex = CmsXmlUtils.getXpathIndexInt(property.getUniquePath(element));\n                            String propPath = CmsXmlUtils.concatXpath(elemPath, CmsXmlUtils.createXpathElement(\n                                property.getName(),\n                                propIndex));\n                            I_CmsXmlSchemaType propSchemaType = elemDef.getSchemaType(property.getName());\n                            I_CmsXmlContentValue propValue = propSchemaType.createValue(this, property, locale);\n                            addBookmark(propPath, locale, true, propValue);\n                            CmsXmlContentDefinition propDef = ((CmsXmlNestedContentDefinition)propSchemaType).getNestedContentDefinition();\n\n                            // name\n                            Element propName = property.element(XmlNode.NAME.getName());\n                            createBookmark(propName, locale, property, propPath, propDef);\n\n                            // choice value \n                            Element value = property.element(XmlNode.VALUE.getName());\n                            int valueIndex = CmsXmlUtils.getXpathIndexInt(value.getUniquePath(property));\n                            String valuePath = CmsXmlUtils.concatXpath(propPath, CmsXmlUtils.createXpathElement(\n                                value.getName(),\n                                valueIndex));\n                            I_CmsXmlSchemaType valueSchemaType = propDef.getSchemaType(value.getName());\n                            I_CmsXmlContentValue valueValue = valueSchemaType.createValue(this, value, locale);\n                            addBookmark(valuePath, locale, true, valueValue);\n                            CmsXmlContentDefinition valueDef = ((CmsXmlNestedContentDefinition)valueSchemaType).getNestedContentDefinition();\n\n                            String val = null;\n                            Element string = value.element(XmlNode.STRING.getName());\n                            if (string != null) {\n                                // string value\n                                createBookmark(string, locale, value, valuePath, valueDef);\n                                val = string.getTextTrim();\n                            } else {\n                                // uri value\n                                Element valueUri = value.element(XmlNode.URI.getName());\n                                createBookmark(valueUri, locale, value, valuePath, valueDef);\n                                Element valueUriLink = valueUri.element(CmsXmlPage.NODE_LINK);\n                                val = new CmsLink(valueUriLink).getStructureId().toString();\n                            }\n\n                            propertiesMap.put(propName.getTextTrim(), val);\n                        }\n                        if (elementId != null) {\n                            elements.add(new CmsContainerElementBean(elementId, formatterId, propertiesMap));\n                        }\n                    }\n\n                    containers.add(new CmsContainerBean(name.getText(), type.getText(), -1, elements));\n                }\n\n                m_cntPages.put(locale, new CmsContainerPageBean(locale, containers));\n            } catch (NullPointerException e) {\n                LOG.error(org.opencms.xml.content.Messages.get().getBundle().key(\n                    org.opencms.xml.content.Messages.LOG_XMLCONTENT_INIT_BOOKMARKS_0), e);\n            }\n        }\n    }","commit_id":"c59346e3f37009afa95c337b7b161555bef9f25e","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private Path unzip(Path zip, Path pluginsDir) throws IOException, UserError {\n        // unzip plugin to a staging temp dir\n\n        final Path target = stagingDirectory(pluginsDir);\n\n        boolean hasEsDir = false;\n        // TODO: we should wrap this in a try/catch and try deleting the target dir on failure?\n        try (ZipInputStream zipInput = new ZipInputStream(Files.newInputStream(zip))) {\n            ZipEntry entry;\n            byte[] buffer = new byte[8192];\n            while ((entry = zipInput.getNextEntry()) != null) {\n                if (entry.getName().startsWith(\"elasticsearch/\") == false) {\n                    // only extract the elasticsearch directory\n                    continue;\n                }\n                hasEsDir = true;\n                Path targetFile = target.resolve(entry.getName().substring(\"elasticsearch/\".length()));\n\n                // Using the entry name as a path can result in an entry outside of the plugin dir, either if the\n                // name starts with the root of the filesystem, or it is a relative entry like ../whatever.\n                // This check attempts to identify both cases by first normalizing the path (which removes foo/..)\n                // and ensuring the normalized entry is still rooted with the target plugin directory.\n                if (targetFile.normalize().startsWith(target) == false) {\n                    throw new IOException(\"Zip contains entry name '\" + entry.getName() + \"' resolving outside of plugin directory\");\n                }\n\n                // be on the safe side: do not rely on that directories are always extracted\n                // before their children (although this makes sense, but is it guaranteed?)\n                Files.createDirectories(targetFile.getParent());\n                if (entry.isDirectory() == false) {\n                    try (OutputStream out = Files.newOutputStream(targetFile)) {\n                        int len;\n                        while ((len = zipInput.read(buffer)) >= 0) {\n                            out.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zipInput.closeEntry();\n            }\n        }\n        Files.delete(zip);\n        if (hasEsDir == false) {\n            IOUtils.rm(target);\n            throw new UserError(ExitCodes.DATA_ERROR, \"`elasticsearch` directory is missing in the plugin zip\");\n        }\n        return target;\n    }","id":79335,"modified_method":"private Path unzip(Path zip, Path pluginsDir) throws IOException, UserError {\n        // unzip plugin to a staging temp dir\n\n        final Path target = stagingDirectory(pluginsDir);\n\n        boolean hasEsDir = false;\n        // TODO: we should wrap this in a try/catch and try deleting the target dir on failure?\n        try (ZipInputStream zipInput = new ZipInputStream(Files.newInputStream(zip))) {\n            ZipEntry entry;\n            byte[] buffer = new byte[8192];\n            while ((entry = zipInput.getNextEntry()) != null) {\n                if (entry.getName().startsWith(\"elasticsearch/\") == false) {\n                    // only extract the elasticsearch directory\n                    continue;\n                }\n                hasEsDir = true;\n                Path targetFile = target.resolve(entry.getName().substring(\"elasticsearch/\".length()));\n\n                // Using the entry name as a path can result in an entry outside of the plugin dir, either if the\n                // name starts with the root of the filesystem, or it is a relative entry like ../whatever.\n                // This check attempts to identify both cases by first normalizing the path (which removes foo/..)\n                // and ensuring the normalized entry is still rooted with the target plugin directory.\n                if (targetFile.normalize().startsWith(target) == false) {\n                    throw new IOException(\"Zip contains entry name '\" + entry.getName() + \"' resolving outside of plugin directory\");\n                }\n\n                // be on the safe side: do not rely on that directories are always extracted\n                // before their children (although this makes sense, but is it guaranteed?)\n                if (!Files.isSymbolicLink(targetFile.getParent())) {\n                    Files.createDirectories(targetFile.getParent());\n                }\n                if (entry.isDirectory() == false) {\n                    try (OutputStream out = Files.newOutputStream(targetFile)) {\n                        int len;\n                        while ((len = zipInput.read(buffer)) >= 0) {\n                            out.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zipInput.closeEntry();\n            }\n        }\n        Files.delete(zip);\n        if (hasEsDir == false) {\n            IOUtils.rm(target);\n            throw new UserError(ExitCodes.DATA_ERROR, \"`elasticsearch` directory is missing in the plugin zip\");\n        }\n        return target;\n    }","commit_id":"f16f65741e426b0e58bdf67673aad474cdd5bc7e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void saveUsersToFile() throws IOException\n    {\n        Path directory = authFile.getParent();\n        Files.createDirectories( directory );\n\n        Path tempFile = Files.createTempFile( directory, authFile.getFileName().toString() + \"-\", \".tmp\" );\n        try\n        {\n            Files.write( tempFile, serialization.serialize( users ) );\n            Files.move( tempFile, authFile, ATOMIC_MOVE, REPLACE_EXISTING );\n        } catch ( Throwable e )\n        {\n            Files.delete( tempFile );\n            throw e;\n        }\n    }","id":79336,"modified_method":"private void saveUsersToFile() throws IOException\n    {\n        Path directory = authFile.getParent();\n        if ( !Files.exists( directory ) )\n        {\n            Files.createDirectories( directory );\n        }\n\n        Path tempFile = Files.createTempFile( directory, authFile.getFileName().toString() + \"-\", \".tmp\" );\n        try\n        {\n            Files.write( tempFile, serialization.serialize( users ) );\n            Files.move( tempFile, authFile, ATOMIC_MOVE, REPLACE_EXISTING );\n        } catch ( Throwable e )\n        {\n            Files.delete( tempFile );\n            throw e;\n        }\n    }","commit_id":"81287f968830dd9e64a22b8d3c0e1afa4eb6b061","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void resyncFolder(long syncAccountId, SyncFile syncFile) {\n\t\tMap<String, Object> parameters = new HashMap<>();\n\n\t\tparameters.put(\"lastAccessTime\", 0);\n\t\tparameters.put(\"parentFolderId\", syncFile.getTypePK());\n\t\tparameters.put(\"repositoryId\", syncFile.getRepositoryId());\n\t\tparameters.put(\"syncFile\", syncFile);\n\n\t\tGetSyncDLObjectUpdateEvent getSyncDLObjectUpdateEvent =\n\t\t\tnew GetSyncDLObjectUpdateEvent(syncAccountId, parameters);\n\n\t\tgetSyncDLObjectUpdateEvent.run();\n\t}","id":79337,"modified_method":"public static void resyncFolder(long syncAccountId, SyncFile syncFile) {\n\t\tMap<String, Object> parameters = new HashMap<>();\n\n\t\tparameters.put(\"lastAccessTime\", -1);\n\t\tparameters.put(\"parentFolderId\", syncFile.getTypePK());\n\t\tparameters.put(\"repositoryId\", syncFile.getRepositoryId());\n\t\tparameters.put(\"syncFile\", syncFile);\n\n\t\tGetSyncDLObjectUpdateEvent getSyncDLObjectUpdateEvent =\n\t\t\tnew GetSyncDLObjectUpdateEvent(syncAccountId, parameters);\n\n\t\tgetSyncDLObjectUpdateEvent.run();\n\t}","commit_id":"a16552abfd97479edaf37ae17d97bab1b33225d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tLong parentFolderId = (Long)getParameterValue(\"parentFolderId\");\n\n\t\tif (parentFolderId != null) {\n\t\t\tsuper.processRequest();\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\t// Refetch for updated last remote sync time\n\n\t\tsyncSite = SyncSiteService.fetchSyncSite(\n\t\t\tsyncSite.getGroupId(), syncSite.getSyncAccountId());\n\n\t\tsyncSite.setState(SyncSite.STATE_IN_PROGRESS);\n\n\t\tSyncSiteService.update(syncSite);\n\n\t\tif (syncSite.getRemoteSyncTime() == -1) {\n\t\t\tString filePathName = syncSite.getFilePathName();\n\n\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(filePathName);\n\n\t\t\tif (syncFile == null) {\n\t\t\t\tFiles.createDirectories(Paths.get(filePathName));\n\n\t\t\t\tSyncFileService.addSyncFile(\n\t\t\t\t\tnull, null, null, filePathName, null, syncSite.getName(), 0,\n\t\t\t\t\tsyncSite.getGroupId(), SyncFile.STATE_SYNCED,\n\t\t\t\t\tsyncSite.getSyncAccountId(), SyncFile.TYPE_SYSTEM, false);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> parameters = getParameters();\n\n\t\tparameters.clear();\n\n\t\tparameters.put(\"lastAccessTime\", syncSite.getRemoteSyncTime());\n\t\tparameters.put(\"max\", 0);\n\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\t\tparameters.put(\"syncSite\", syncSite);\n\n\t\texecutePost(_URL_PATH, parameters);\n\t}","id":79338,"modified_method":"@Override\n\tprotected void processRequest() throws Exception {\n\t\tLong parentFolderId = (Long)getParameterValue(\"parentFolderId\");\n\n\t\tif (parentFolderId != null) {\n\t\t\tsuper.processRequest();\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncSite syncSite = (SyncSite)getParameterValue(\"syncSite\");\n\n\t\t// Refetch for updated last remote sync time\n\n\t\tsyncSite = SyncSiteService.fetchSyncSite(\n\t\t\tsyncSite.getGroupId(), syncSite.getSyncAccountId());\n\n\t\tsyncSite.setState(SyncSite.STATE_IN_PROGRESS);\n\n\t\tSyncSiteService.update(syncSite);\n\n\t\tif (syncSite.getRemoteSyncTime() == -1) {\n\t\t\tString filePathName = syncSite.getFilePathName();\n\n\t\t\tif (!Files.exists(Paths.get(filePathName))) {\n\t\t\t\tFiles.createDirectories(Paths.get(filePathName));\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> parameters = getParameters();\n\n\t\tparameters.clear();\n\n\t\tparameters.put(\"lastAccessTime\", syncSite.getRemoteSyncTime());\n\t\tparameters.put(\"max\", 0);\n\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\t\tparameters.put(\"syncSite\", syncSite);\n\n\t\texecutePost(_URL_PATH, parameters);\n\t}","commit_id":"a16552abfd97479edaf37ae17d97bab1b33225d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processResponse(String response) throws Exception {\n\t\tSet<Long> remoteSyncSiteIds = new HashSet<>();\n\n\t\tif (_remoteSyncSites == null) {\n\t\t\t_remoteSyncSites = JSONUtil.readValue(\n\t\t\t\tresponse, new TypeReference<List<SyncSite>>() {});\n\t\t}\n\n\t\tfor (SyncSite remoteSyncSite : _remoteSyncSites) {\n\t\t\tSyncSite localSyncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\tremoteSyncSite.getGroupId(), getSyncAccountId());\n\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\tgetSyncAccountId());\n\n\t\t\tString remoteSyncSiteName = remoteSyncSite.getName();\n\n\t\t\tif (!FileUtil.isValidFileName(remoteSyncSiteName)) {\n\t\t\t\tremoteSyncSiteName = String.valueOf(\n\t\t\t\t\tremoteSyncSite.getGroupId());\n\t\t\t}\n\n\t\t\tif (localSyncSite == null) {\n\t\t\t\tremoteSyncSite.setFilePathName(\n\t\t\t\t\tFileUtil.getFilePathName(\n\t\t\t\t\t\tsyncAccount.getFilePathName(), remoteSyncSiteName));\n\t\t\t\tremoteSyncSite.setRemoteSyncTime(-1);\n\t\t\t\tremoteSyncSite.setSyncAccountId(getSyncAccountId());\n\n\t\t\t\tSyncSiteService.update(remoteSyncSite);\n\n\t\t\t\tremoteSyncSiteIds.add(remoteSyncSite.getSyncSiteId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString localSyncSiteName = localSyncSite.getName();\n\n\t\t\t\tlocalSyncSite.setDescription(remoteSyncSite.getDescription());\n\t\t\t\tlocalSyncSite.setFriendlyURL(remoteSyncSite.getFriendlyURL());\n\t\t\t\tlocalSyncSite.setName(remoteSyncSite.getName());\n\t\t\t\tlocalSyncSite.setType(remoteSyncSite.getType());\n\t\t\t\tlocalSyncSite.setTypeSettings(remoteSyncSite.getTypeSettings());\n\t\t\t\tlocalSyncSite.setSite(remoteSyncSite.getSite());\n\n\t\t\t\tSyncSiteService.update(localSyncSite);\n\n\t\t\t\tif (!localSyncSiteName.equals(remoteSyncSite.getName())) {\n\t\t\t\t\tSyncSiteService.setFilePathName(\n\t\t\t\t\t\tlocalSyncSite.getSyncSiteId(), remoteSyncSiteName);\n\n\t\t\t\t\tFileUtil.moveFile(\n\t\t\t\t\t\tPaths.get(localSyncSite.getFilePathName()),\n\t\t\t\t\t\tFileUtil.getFilePath(\n\t\t\t\t\t\t\tsyncAccount.getFilePathName(), remoteSyncSiteName));\n\t\t\t\t}\n\n\t\t\t\tremoteSyncSiteIds.add(localSyncSite.getSyncSiteId());\n\t\t\t}\n\t\t}\n\n\t\tList<SyncSite> localSyncSites = SyncSiteService.findSyncSites(\n\t\t\tgetSyncAccountId());\n\n\t\tfor (SyncSite localSyncSite : localSyncSites) {\n\t\t\tif (remoteSyncSiteIds.contains(localSyncSite.getSyncSiteId())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSyncSiteService.deleteSyncSite(localSyncSite.getSyncSiteId());\n\t\t}\n\t}","id":79339,"modified_method":"@Override\n\tpublic void processResponse(String response) throws Exception {\n\t\tSet<Long> remoteSyncSiteIds = new HashSet<>();\n\n\t\tif (_remoteSyncSites == null) {\n\t\t\t_remoteSyncSites = JSONUtil.readValue(\n\t\t\t\tresponse, new TypeReference<List<SyncSite>>() {});\n\t\t}\n\n\t\tfor (SyncSite remoteSyncSite : _remoteSyncSites) {\n\t\t\tSyncSite localSyncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\tremoteSyncSite.getGroupId(), getSyncAccountId());\n\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\tgetSyncAccountId());\n\n\t\t\tString remoteSyncSiteName = remoteSyncSite.getName();\n\n\t\t\tif (!FileUtil.isValidFileName(remoteSyncSiteName)) {\n\t\t\t\tremoteSyncSiteName = String.valueOf(\n\t\t\t\t\tremoteSyncSite.getGroupId());\n\t\t\t}\n\n\t\t\tif (localSyncSite == null) {\n\t\t\t\tremoteSyncSite.setFilePathName(\n\t\t\t\t\tFileUtil.getFilePathName(\n\t\t\t\t\t\tsyncAccount.getFilePathName(), remoteSyncSiteName));\n\t\t\t\tremoteSyncSite.setRemoteSyncTime(-1);\n\t\t\t\tremoteSyncSite.setSyncAccountId(getSyncAccountId());\n\n\t\t\t\tSyncSiteService.update(remoteSyncSite);\n\n\t\t\t\tremoteSyncSiteIds.add(remoteSyncSite.getSyncSiteId());\n\n\t\t\t\tSyncFileService.addSyncFile(\n\t\t\t\t\tnull, null, null, remoteSyncSite.getFilePathName(), null,\n\t\t\t\t\tremoteSyncSite.getName(), 0, remoteSyncSite.getGroupId(),\n\t\t\t\t\tSyncFile.STATE_SYNCED, remoteSyncSite.getSyncAccountId(),\n\t\t\t\t\tSyncFile.TYPE_SYSTEM, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString localSyncSiteName = localSyncSite.getName();\n\n\t\t\t\tlocalSyncSite.setDescription(remoteSyncSite.getDescription());\n\t\t\t\tlocalSyncSite.setFriendlyURL(remoteSyncSite.getFriendlyURL());\n\t\t\t\tlocalSyncSite.setName(remoteSyncSite.getName());\n\t\t\t\tlocalSyncSite.setType(remoteSyncSite.getType());\n\t\t\t\tlocalSyncSite.setTypeSettings(remoteSyncSite.getTypeSettings());\n\t\t\t\tlocalSyncSite.setSite(remoteSyncSite.getSite());\n\n\t\t\t\tSyncSiteService.update(localSyncSite);\n\n\t\t\t\tif (!localSyncSiteName.equals(remoteSyncSite.getName())) {\n\t\t\t\t\tSyncSiteService.setFilePathName(\n\t\t\t\t\t\tlocalSyncSite.getSyncSiteId(), remoteSyncSiteName);\n\n\t\t\t\t\tFileUtil.moveFile(\n\t\t\t\t\t\tPaths.get(localSyncSite.getFilePathName()),\n\t\t\t\t\t\tFileUtil.getFilePath(\n\t\t\t\t\t\t\tsyncAccount.getFilePathName(), remoteSyncSiteName));\n\t\t\t\t}\n\n\t\t\t\tremoteSyncSiteIds.add(localSyncSite.getSyncSiteId());\n\t\t\t}\n\t\t}\n\n\t\tList<SyncSite> localSyncSites = SyncSiteService.findSyncSites(\n\t\t\tgetSyncAccountId());\n\n\t\tfor (SyncSite localSyncSite : localSyncSites) {\n\t\t\tif (remoteSyncSiteIds.contains(localSyncSite.getSyncSiteId())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSyncSiteService.deleteSyncSite(localSyncSite.getSyncSiteId());\n\t\t}\n\t}","commit_id":"a16552abfd97479edaf37ae17d97bab1b33225d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncAccount addSyncAccount(\n\t\t\tString filePathName, String login, int maxConnections,\n\t\t\tString oAuthConsumerKey, String oAuthConsumerSecret,\n\t\t\tboolean oAuthEnabled, String password, int pollInterval,\n\t\t\tSyncSite[] syncSites, SyncUser syncUser, boolean trustSelfSigned,\n\t\t\tString url)\n\t\tthrows Exception {\n\n\t\t// Sync account\n\n\t\tSyncAccount syncAccount = new SyncAccount();\n\n\t\tsyncAccount.setFilePathName(filePathName);\n\t\tsyncAccount.setLogin(login);\n\t\tsyncAccount.setMaxConnections(maxConnections);\n\t\tsyncAccount.setOAuthConsumerKey(oAuthConsumerKey);\n\t\tsyncAccount.setOAuthConsumerSecret(oAuthConsumerSecret);\n\t\tsyncAccount.setOAuthEnabled(oAuthEnabled);\n\t\tsyncAccount.setPassword(Encryptor.encrypt(password));\n\t\tsyncAccount.setPollInterval(pollInterval);\n\t\tsyncAccount.setTrustSelfSigned(trustSelfSigned);\n\t\tsyncAccount.setUrl(url);\n\n\t\t_syncAccountPersistence.create(syncAccount);\n\n\t\t// Sync file\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tPath dataFilePath = Files.createDirectories(filePath.resolve(\".data\"));\n\n\t\tif (OSDetector.isWindows()) {\n\t\t\tFiles.setAttribute(dataFilePath, \"dos:hidden\", true);\n\t\t}\n\n\t\tSyncFileService.addSyncFile(\n\t\t\tnull, null, null, filePathName, null,\n\t\t\tString.valueOf(filePath.getFileName()), 0, 0, SyncFile.STATE_SYNCED,\n\t\t\tsyncAccount.getSyncAccountId(), SyncFile.TYPE_SYSTEM, false);\n\n\t\t// Sync sites\n\n\t\tif (syncSites != null) {\n\t\t\tfor (SyncSite syncSite : syncSites) {\n\t\t\t\tString syncSiteName = syncSite.getName();\n\n\t\t\t\tif (!FileUtil.isValidFileName(syncSiteName)) {\n\t\t\t\t\tsyncSiteName = String.valueOf(syncSite.getGroupId());\n\t\t\t\t}\n\n\t\t\t\tsyncSite.setFilePathName(\n\t\t\t\t\tFileUtil.getFilePathName(\n\t\t\t\t\t\tsyncAccount.getFilePathName(), syncSiteName));\n\n\t\t\t\tsyncSite.setRemoteSyncTime(-1);\n\t\t\t\tsyncSite.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\t\t\tSyncSiteService.update(syncSite);\n\t\t\t}\n\t\t}\n\n\t\t// Sync user\n\n\t\tif (syncUser != null) {\n\t\t\tsyncUser.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\t\tSyncUserService.update(syncUser);\n\t\t}\n\n\t\treturn syncAccount;\n\t}","id":79340,"modified_method":"public static SyncAccount addSyncAccount(\n\t\t\tString filePathName, String login, int maxConnections,\n\t\t\tString oAuthConsumerKey, String oAuthConsumerSecret,\n\t\t\tboolean oAuthEnabled, String password, int pollInterval,\n\t\t\tSyncSite[] syncSites, SyncUser syncUser, boolean trustSelfSigned,\n\t\t\tString url)\n\t\tthrows Exception {\n\n\t\t// Sync account\n\n\t\tSyncAccount syncAccount = new SyncAccount();\n\n\t\tsyncAccount.setFilePathName(filePathName);\n\t\tsyncAccount.setLogin(login);\n\t\tsyncAccount.setMaxConnections(maxConnections);\n\t\tsyncAccount.setOAuthConsumerKey(oAuthConsumerKey);\n\t\tsyncAccount.setOAuthConsumerSecret(oAuthConsumerSecret);\n\t\tsyncAccount.setOAuthEnabled(oAuthEnabled);\n\t\tsyncAccount.setPassword(Encryptor.encrypt(password));\n\t\tsyncAccount.setPollInterval(pollInterval);\n\t\tsyncAccount.setTrustSelfSigned(trustSelfSigned);\n\t\tsyncAccount.setUrl(url);\n\n\t\t_syncAccountPersistence.create(syncAccount);\n\n\t\t// Sync file\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tPath dataFilePath = Files.createDirectories(filePath.resolve(\".data\"));\n\n\t\tif (OSDetector.isWindows()) {\n\t\t\tFiles.setAttribute(dataFilePath, \"dos:hidden\", true);\n\t\t}\n\n\t\tSyncFileService.addSyncFile(\n\t\t\tnull, null, null, filePathName, null,\n\t\t\tString.valueOf(filePath.getFileName()), 0, 0, SyncFile.STATE_SYNCED,\n\t\t\tsyncAccount.getSyncAccountId(), SyncFile.TYPE_SYSTEM, false);\n\n\t\t// Sync sites\n\n\t\tif (syncSites != null) {\n\t\t\tfor (SyncSite syncSite : syncSites) {\n\t\t\t\tString syncSiteName = syncSite.getName();\n\n\t\t\t\tif (!FileUtil.isValidFileName(syncSiteName)) {\n\t\t\t\t\tsyncSiteName = String.valueOf(syncSite.getGroupId());\n\t\t\t\t}\n\n\t\t\t\tsyncSite.setFilePathName(\n\t\t\t\t\tFileUtil.getFilePathName(\n\t\t\t\t\t\tsyncAccount.getFilePathName(), syncSiteName));\n\n\t\t\t\tsyncSite.setRemoteSyncTime(-1);\n\t\t\t\tsyncSite.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\t\t\tSyncSiteService.update(syncSite);\n\n\t\t\t\tSyncFileService.addSyncFile(\n\t\t\t\t\tnull, null, null, syncSite.getFilePathName(), null,\n\t\t\t\t\tsyncSite.getName(), 0, syncSite.getGroupId(),\n\t\t\t\t\tSyncFile.STATE_SYNCED, syncSite.getSyncAccountId(),\n\t\t\t\t\tSyncFile.TYPE_SYSTEM, false);\n\t\t\t}\n\t\t}\n\n\t\t// Sync user\n\n\t\tif (syncUser != null) {\n\t\t\tsyncUser.setSyncAccountId(syncAccount.getSyncAccountId());\n\n\t\t\tSyncUserService.update(syncUser);\n\t\t}\n\n\t\treturn syncAccount;\n\t}","commit_id":"a16552abfd97479edaf37ae17d97bab1b33225d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SyncFile unsyncFolder(String filePathName) throws Exception {\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(filePathName);\n\n\t\tif (syncFile == null) {\n\t\t\treturn addSyncFile(\n\t\t\t\tnull, null, null, filePathName, null, null, 0, 0,\n\t\t\t\tSyncFile.STATE_UNSYNCED, 0, null, false);\n\t\t}\n\n\t\tsetStatuses(syncFile, SyncFile.STATE_UNSYNCED, SyncFile.UI_EVENT_NONE);\n\n\t\treturn syncFile;\n\t}","id":79341,"modified_method":"public static SyncFile unsyncFolder(\n\t\t\tlong syncAccountId, SyncFile targetSyncFile)\n\t\tthrows Exception {\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), syncAccountId,\n\t\t\ttargetSyncFile.getParentFolderId());\n\n\t\tif (parentSyncFile == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString filePathName = FileUtil.getFilePathName(\n\t\t\tparentSyncFile.getFilePathName(),\n\t\t\tFileUtil.getSanitizedFileName(targetSyncFile.getName(), null));\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(filePathName);\n\n\t\tif (sourceSyncFile == null) {\n\t\t\ttargetSyncFile.setFilePathName(filePathName);\n\t\t\ttargetSyncFile.setModifiedTime(0);\n\t\t\ttargetSyncFile.setState(SyncFile.STATE_UNSYNCED);\n\t\t\ttargetSyncFile.setSyncAccountId(syncAccountId);\n\n\t\t\treturn update(targetSyncFile);\n\t\t}\n\n\t\tsourceSyncFile.setModifiedTime(0);\n\n\t\tsetStatuses(\n\t\t\tsourceSyncFile, SyncFile.STATE_UNSYNCED, SyncFile.UI_EVENT_NONE);\n\n\t\treturn sourceSyncFile;\n\t}","commit_id":"a16552abfd97479edaf37ae17d97bab1b33225d8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@NotNull\n  public String getNamespace() {\n    String namespace = myNamespace;\n    if (namespace == null) {\n      myNamespace = namespace = getNamespaceByPrefix(getNamespacePrefix());\n    }\n    return namespace;\n  }","id":79342,"modified_method":"@NotNull\n  public String getNamespace() {\n    return getNamespaceByPrefix(getNamespacePrefix());\n  }","commit_id":"a93437caa863496e3c25742b9bddfb8700b4796e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clearCaches() {\n    myName = null;\n    myNamespace = null;\n    myNamespaceMap = null;\n    myAttributes = null;\n    myAttributeValueMap = null;\n    myHaveNamespaceDeclarations = false;\n    myValue = null;\n    myTags = null;\n    myNSDescriptorsMap = null;\n    super.clearCaches();\n  }","id":79343,"modified_method":"public void clearCaches() {\n    myName = null;\n    myNamespaceMap = null;\n    myAttributes = null;\n    myAttributeValueMap = null;\n    myHaveNamespaceDeclarations = false;\n    myValue = null;\n    myTags = null;\n    myNSDescriptorsMap = null;\n    super.clearCaches();\n  }","commit_id":"a93437caa863496e3c25742b9bddfb8700b4796e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getNamespace() {\n    return getNamespaceByPrefix(getNamespacePrefix());\n  }","id":79344,"modified_method":"@NotNull\n  public String getNamespace() {\n    String namespace = myNamespace;\n    if (namespace == null) {\n      myNamespace = namespace = getNamespaceByPrefix(getNamespacePrefix());\n    }\n    return namespace;\n  }","commit_id":"bead8b83def062982defa70df45cc1d6b4f47c4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clearCaches() {\n    myName = null;\n    myNamespaceMap = null;\n    myAttributes = null;\n    myAttributeValueMap = null;\n    myHaveNamespaceDeclarations = false;\n    myValue = null;\n    myTags = null;\n    myNSDescriptorsMap = null;\n    super.clearCaches();\n  }","id":79345,"modified_method":"public void clearCaches() {\n    myName = null;\n    myNamespace = null;\n    myNamespaceMap = null;\n    myAttributes = null;\n    myAttributeValueMap = null;\n    myHaveNamespaceDeclarations = false;\n    myValue = null;\n    myTags = null;\n    myNSDescriptorsMap = null;\n    super.clearCaches();\n  }","commit_id":"bead8b83def062982defa70df45cc1d6b4f47c4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clearCaches() {\n    myName = null;\n    myNamespaceMap = null;\n    myNamespace = null;\n    myAttributes = null;\n    myAttributeValueMap = null;\n    myHaveNamespaceDeclarations = false;\n    myValue = null;\n    myTags = null;\n    myNSDescriptorsMap = null;\n    super.clearCaches();\n  }","id":79346,"modified_method":"public void clearCaches() {\n    myName = null;\n    myNamespaceMap = null;\n    myAttributes = null;\n    myAttributeValueMap = null;\n    myHaveNamespaceDeclarations = false;\n    myValue = null;\n    myTags = null;\n    myNSDescriptorsMap = null;\n    super.clearCaches();\n  }","commit_id":"ef811f16ab09aa5749167aaa1cc84cb8ee651132","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getNamespace() {\n    if(myNamespace != null) return myNamespace;\n    final String namespace = getNamespaceByPrefix(getNamespacePrefix());\n    return myNamespace = (namespace != null ? namespace : XmlUtil.EMPTY_URI);\n  }","id":79347,"modified_method":"public String getNamespace() {\n    return getNamespaceByPrefix(getNamespacePrefix());\n  }","commit_id":"ef811f16ab09aa5749167aaa1cc84cb8ee651132","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected byte[] getEncryptedContentEncryptionKey(byte[] theCek) {\n        return keyEncryptionAlgo.getEncryptedContentEncryptionKey(headers, theCek);\n    }","id":79348,"modified_method":"protected byte[] getEncryptedContentEncryptionKey(byte[] theCek) {\n        return getKeyEncryptionAlgo().getEncryptedContentEncryptionKey(headers, theCek);\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"protected AlgorithmParameterSpec getAlgorithmParameterSpec(byte[] theIv) {\n        return contentEncryptionAlgo.getAlgorithmParameterSpec(theIv);\n    }","id":79349,"modified_method":"protected AlgorithmParameterSpec getAlgorithmParameterSpec(byte[] theIv) {\n        return getContentEncryptionAlgorithm().getAlgorithmParameterSpec(theIv);\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"private JweEncryptionInternal getInternalState(JweHeaders jweHeaders) {\n        byte[] theCek = getContentEncryptionKey();\n        String contentEncryptionAlgoJavaName = Algorithm.toJavaName(headers.getContentEncryptionAlgorithm());\n        KeyProperties keyProps = new KeyProperties(contentEncryptionAlgoJavaName);\n        keyProps.setCompressionSupported(compressionRequired(headers));\n        \n        byte[] theIv = contentEncryptionAlgo.getInitVector();\n        AlgorithmParameterSpec specParams = getAlgorithmParameterSpec(theIv);\n        keyProps.setAlgoSpec(specParams);\n        byte[] jweContentEncryptionKey = getEncryptedContentEncryptionKey(theCek);\n        \n        JweHeaders theHeaders = headers;\n        if (jweHeaders != null) {\n            if (jweHeaders.getKeyEncryptionAlgorithm() != null \n                && !keyEncryptionAlgo.getAlgorithm().equals(jweHeaders.getKeyEncryptionAlgorithm())\n                || jweHeaders.getAlgorithm() != null \n                    && !contentEncryptionAlgo.getAlgorithm().equals(jweHeaders.getAlgorithm())) {\n                throw new SecurityException();\n            }\n            theHeaders = new JweHeaders(theHeaders.asMap());\n            theHeaders.asMap().putAll(jweHeaders.asMap());\n        }\n        byte[] additionalEncryptionParam = getAAD(theHeaders);\n        keyProps.setAdditionalData(additionalEncryptionParam);\n        \n        \n        JweEncryptionInternal state = new JweEncryptionInternal();\n        state.theHeaders = theHeaders;\n        state.jweContentEncryptionKey = jweContentEncryptionKey;\n        state.keyProps = keyProps;\n        state.secretKey = theCek; \n        state.theIv = theIv;\n        return state;\n    }","id":79350,"modified_method":"private JweEncryptionInternal getInternalState(JweHeaders jweHeaders) {\n        byte[] theCek = getContentEncryptionKey();\n        String contentEncryptionAlgoJavaName = Algorithm.toJavaName(headers.getContentEncryptionAlgorithm());\n        KeyProperties keyProps = new KeyProperties(contentEncryptionAlgoJavaName);\n        keyProps.setCompressionSupported(compressionRequired(headers));\n        \n        byte[] theIv = getContentEncryptionAlgorithm().getInitVector();\n        AlgorithmParameterSpec specParams = getAlgorithmParameterSpec(theIv);\n        keyProps.setAlgoSpec(specParams);\n        byte[] jweContentEncryptionKey = getEncryptedContentEncryptionKey(theCek);\n        \n        JweHeaders theHeaders = headers;\n        if (jweHeaders != null) {\n            if (jweHeaders.getKeyEncryptionAlgorithm() != null \n                && !getKeyAlgorithm().equals(jweHeaders.getKeyEncryptionAlgorithm())\n                || jweHeaders.getAlgorithm() != null \n                    && !getContentAlgorithm().equals(jweHeaders.getAlgorithm())) {\n                throw new SecurityException();\n            }\n            theHeaders = new JweHeaders(theHeaders.asMap());\n            theHeaders.asMap().putAll(jweHeaders.asMap());\n        }\n        byte[] additionalEncryptionParam = getAAD(theHeaders);\n        keyProps.setAdditionalData(additionalEncryptionParam);\n        \n        \n        JweEncryptionInternal state = new JweEncryptionInternal();\n        state.theHeaders = theHeaders;\n        state.jweContentEncryptionKey = jweContentEncryptionKey;\n        state.keyProps = keyProps;\n        state.secretKey = theCek; \n        state.theIv = theIv;\n        return state;\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public String getContentAlgorithm() {\n        return contentEncryptionAlgo.getAlgorithm();\n    }","id":79351,"modified_method":"@Override\n    public String getContentAlgorithm() {\n        return getContentEncryptionAlgorithm().getAlgorithm();\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public String getKeyAlgorithm() {\n        return keyEncryptionAlgo.getAlgorithm();\n    }","id":79352,"modified_method":"@Override\n    public String getKeyAlgorithm() {\n        return getKeyEncryptionAlgo().getAlgorithm();\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"protected byte[] getProvidedContentEncryptionKey() {\n        return contentEncryptionAlgo.getContentEncryptionKey(headers);\n    }","id":79353,"modified_method":"protected byte[] getProvidedContentEncryptionKey() {\n        return getContentEncryptionAlgorithm().getContentEncryptionKey(headers);\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"protected byte[] getAAD(JweHeaders theHeaders) {\n        return contentEncryptionAlgo.getAdditionalAuthenticationData(writer.headersToJson(theHeaders));\n    }","id":79354,"modified_method":"protected byte[] getAAD(JweHeaders theHeaders) {\n        return getContentEncryptionAlgorithm().getAdditionalAuthenticationData(writer.headersToJson(theHeaders));\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"public DirectKeyJweDecryption(Key contentDecryptionKey, \n                                  JoseHeadersReader reader,\n                                  ContentDecryptionAlgorithm cipherProps) {    \n        super(reader, \n              new DirectKeyDecryptionAlgorithm(contentDecryptionKey),\n              cipherProps);\n    }","id":79355,"modified_method":"public DirectKeyJweDecryption(Key contentDecryptionKey, \n                                  JoseHeadersReader reader,\n                                  ContentDecryptionAlgorithm cipherProps) {    \n        this(reader, \n              new DirectKeyDecryptionAlgorithm(contentDecryptionKey),\n              cipherProps);\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"public DirectKeyJweEncryption(JweHeaders headers, ContentEncryptionAlgorithm ceAlgo) {\n        super(headers, ceAlgo, new DirectKeyEncryptionAlgorithm());\n    }","id":79356,"modified_method":"public DirectKeyJweEncryption(JweHeaders headers, ContentEncryptionAlgorithm ceAlgo) {\n        this(headers, ceAlgo, new DirectKeyEncryptionAlgorithm());\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testECDHESDirectKeyEncryption() throws Exception {\n        ECPrivateKey alicePrivateKey = \n            CryptoUtils.getECPrivateKey(JsonWebKey.EC_CURVE_P256, \n                                        \"0_NxaRPUMQoAJt50Gz8YiTr8gRTwyEaCumd-MToTmIo\");\n        ECPublicKey alicePublicKey = \n            CryptoUtils.getECPublicKey(JsonWebKey.EC_CURVE_P256, \n                                       \"gI0GAILBdu7T53akrFmMyGcsF3n5dO7MmwNBHKW5SV0\",\n                                       \"SLW_xSffzlPWrHEVI30DHM_4egVwt3NQqeUD7nMFpps\");\n        \n        ECPublicKey bobPublicKey = \n            CryptoUtils.getECPublicKey(JsonWebKey.EC_CURVE_P256, \n                                       \"weNJy2HscCSM6AEDTDg04biOvhFhyyWvOHQfeF_PxMQ\",\n                                       \"e8lnCO-AlStT-NJVX-crhB7QRYhiix03illJOVAOyck\");\n        \n        byte[] apuBytes = StringUtils.toBytesUTF8(\"Alice\");\n        byte[] apvBytes = StringUtils.toBytesUTF8(\"Bob\");\n        \n        byte[] derivedKey = JweUtils.getECDHKey(alicePrivateKey, bobPublicKey, apuBytes, apvBytes, \n                                                Algorithm.A128GCM.getJwtName(), Algorithm.A128GCM.getKeySizeBits());\n        assertEquals(\"VqqN6vgjbSBcIijNcacQGg\", Base64UrlUtility.encode(derivedKey));\n        \n        JweHeaders headers = new JweHeaders();\n        headers.setAlgorithm(JoseConstants.ECDH_ES_DIRECT_ALGO);\n        headers.setContentEncryptionAlgorithm(Algorithm.A128GCM.getJwtName());\n        headers.setHeader(\"apu\", Base64UrlUtility.encode(apuBytes));\n        headers.setHeader(\"apv\", Base64UrlUtility.encode(apvBytes));\n        headers.setJsonWebKey(\"epv\", JwkUtils.fromECPublicKey(alicePublicKey, JsonWebKey.EC_CURVE_P256));\n        \n        byte[] derivedKey2 = calculateDerivedKeyFromHeaders(headers,\n                                                            headers.getContentEncryptionAlgorithm(),\n                                                            Algorithm.A128GCM.getKeySizeBits());\n        assertTrue(Arrays.equals(derivedKey2, derivedKey));\n    }","id":79357,"modified_method":"@Test\n    public void testECDHESDirectKeyEncryption() throws Exception {\n        ECPrivateKey bobPrivateKey = \n            CryptoUtils.getECPrivateKey(JsonWebKey.EC_CURVE_P256, \n                                        \"VEmDZpDXXK8p8N0Cndsxs924q6nS1RXFASRl6BfUqdw\");\n        \n        final ECPublicKey bobPublicKey = \n            CryptoUtils.getECPublicKey(JsonWebKey.EC_CURVE_P256, \n                                       \"weNJy2HscCSM6AEDTDg04biOvhFhyyWvOHQfeF_PxMQ\",\n                                       \"e8lnCO-AlStT-NJVX-crhB7QRYhiix03illJOVAOyck\");\n        JweEncryptionProvider jweOut = \n            new EcdhDirectKeyJweEncryption(bobPublicKey, \n                                           JsonWebKey.EC_CURVE_P256, \n                                           \"Alice\", \n                                           \"Bob\", \n                                           Algorithm.A128GCM.getJwtName());\n    \n        String jweOutput = jweOut.encrypt(\"Hello\".getBytes(), null);\n        JweDecryptionProvider jweIn = \n            new EcdhDirectKeyJweDecryption(bobPrivateKey, Algorithm.A128GCM.getJwtName());\n        assertEquals(\"Hello\", jweIn.decrypt(jweOutput).getContentText());\n    }","commit_id":"8ea1ea3f82df3fd5a08b74fca48393ff3c86f7e4","url":"https://github.com/apache/cxf"},{"original_method":"private String encryptContent(String content, boolean createIfException) throws Exception {\n        RSAPublicKey publicKey = CryptoUtils.getRSAPublicKey(RSA_MODULUS_ENCODED_A1, \n                                                             RSA_PUBLIC_EXPONENT_ENCODED_A1);\n        SecretKey key = createSecretKey(createIfException);\n        String jwtKeyName = null;\n        if (key == null) {\n            // the encryptor will generate it\n            jwtKeyName = Algorithm.A128GCM.getJwtName();\n        } else {\n            jwtKeyName = Algorithm.toJwtName(key.getAlgorithm(), key.getEncoded().length * 8);\n        }\n        RSAJweEncryption encryptor = new RSAJweEncryption(publicKey, \n                                                          Algorithm.RSA_OAEP.getJwtName(),\n                                                        key, \n                                                        jwtKeyName, \n                                                        INIT_VECTOR_A1);\n        return encryptor.encrypt(content.getBytes(\"UTF-8\"), null);\n    }","id":79358,"modified_method":"private String encryptContent(String content, boolean createIfException) throws Exception {\n        RSAPublicKey publicKey = CryptoUtils.getRSAPublicKey(RSA_MODULUS_ENCODED_A1, \n                                                             RSA_PUBLIC_EXPONENT_ENCODED_A1);\n        SecretKey key = createSecretKey(createIfException);\n        String jwtKeyName = null;\n        if (key == null) {\n            // the encryptor will generate it\n            jwtKeyName = Algorithm.A128GCM.getJwtName();\n        } else {\n            jwtKeyName = Algorithm.toJwtName(key.getAlgorithm(), key.getEncoded().length * 8);\n        }\n        JweEncryptionProvider encryptor = new WrappedKeyJweEncryption(\n                                                        new JweHeaders(Algorithm.RSA_OAEP.getJwtName(), jwtKeyName),  \n                                                        key.getEncoded(), \n                                                        INIT_VECTOR_A1,\n                                                        new RSAOaepKeyEncryptionAlgorithm(publicKey, \n                                                            Algorithm.RSA_OAEP.getJwtName()));\n        return encryptor.encrypt(content.getBytes(\"UTF-8\"), null);\n    }","commit_id":"8bc72ec088209f7ec6261ad0fea660b0dbff5a56","url":"https://github.com/apache/cxf"},{"original_method":"private void decrypt(String jweContent, String plainContent, boolean unwrap) throws Exception {\n        RSAPrivateKey privateKey = CryptoUtils.getRSAPrivateKey(RSA_MODULUS_ENCODED_A1, \n                                                                RSA_PRIVATE_EXPONENT_ENCODED_A1);\n        RSAJweDecryption decryptor = new RSAJweDecryption(privateKey, unwrap);\n        String decryptedText = decryptor.decrypt(jweContent).getContentText();\n        assertEquals(decryptedText, plainContent);\n    }","id":79359,"modified_method":"private void decrypt(String jweContent, String plainContent, boolean unwrap) throws Exception {\n        RSAPrivateKey privateKey = CryptoUtils.getRSAPrivateKey(RSA_MODULUS_ENCODED_A1, \n                                                                RSA_PRIVATE_EXPONENT_ENCODED_A1);\n        JweDecryptionProvider decryptor = new WrappedKeyJweDecryption(new RSAOaepKeyDecryptionAlgorithm(privateKey));\n        String decryptedText = decryptor.decrypt(jweContent).getContentText();\n        assertEquals(decryptedText, plainContent);\n    }","commit_id":"8bc72ec088209f7ec6261ad0fea660b0dbff5a56","url":"https://github.com/apache/cxf"},{"original_method":"protected JweEncryptionProvider getInitializedEncryptionProvider() {\n        if (encryptionProvider != null) {\n            return encryptionProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_ENCRYPTION_OUT_PROPS, RSSEC_ENCRYPTION_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            KeyEncryptionAlgorithm keyEncryptionProvider = null;\n            String keyEncryptionAlgo = null;\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(CryptoUtils.RSSEC_KEY_STORE_TYPE))) {\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, JsonWebKey.KEY_OPER_ENCRYPT);\n                keyEncryptionAlgo = jwk.getAlgorithm();\n                // TODO: Put it into some factory code\n                if (JsonWebKey.KEY_TYPE_RSA.equals(jwk.getKeyType())) {\n                    keyEncryptionProvider = new RSAOaepKeyEncryptionAlgorithm(jwk.toRSAPublicKey());\n                } else if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n                    SecretKey key = jwk.toSecretKey();\n                    if (Algorithm.isAesKeyWrap(keyEncryptionAlgo)) {\n                        keyEncryptionProvider = new AesWrapKeyEncryptionAlgorithm(key, keyEncryptionAlgo);\n                    } else if (Algorithm.isAesGcmKeyWrap(keyEncryptionAlgo)) {\n                        keyEncryptionProvider = new AesGcmWrapKeyEncryptionAlgorithm(key, keyEncryptionAlgo);\n                    }\n                } else {\n                    // TODO: support elliptic curve keys\n                }\n                \n            } else {\n                keyEncryptionProvider = new RSAOaepKeyEncryptionAlgorithm(\n                    (RSAPublicKey)CryptoUtils.loadPublicKey(m, props));\n            }\n            if (keyEncryptionProvider == null) {\n                throw new SecurityException();\n            }\n            if (keyEncryptionAlgo == null) {\n                keyEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_KEY_ALGO_PROP);\n            }\n            String contentEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP);\n            JweHeaders headers = new JweHeaders(keyEncryptionAlgo, contentEncryptionAlgo);\n            String compression = props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP);\n            if (compression != null) {\n                headers.setZipAlgorithm(compression);\n            }\n            boolean isAesHmac = Algorithm.isAesCbcHmac(contentEncryptionAlgo);\n            if (isAesHmac) { \n                return new AesCbcHmacJweEncryption(\n                    keyEncryptionAlgo, contentEncryptionAlgo, keyEncryptionProvider);\n            } else {\n                return new WrappedKeyJweEncryption(headers, keyEncryptionProvider);\n            }\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","id":79360,"modified_method":"protected JweEncryptionProvider getInitializedEncryptionProvider() {\n        if (encryptionProvider != null) {\n            return encryptionProvider;    \n        } \n        Message m = JAXRSUtils.getCurrentMessage();\n        String propLoc = \n            (String)MessageUtils.getContextualProperty(m, RSSEC_ENCRYPTION_OUT_PROPS, RSSEC_ENCRYPTION_PROPS);\n        if (propLoc == null) {\n            throw new SecurityException();\n        }\n        Bus bus = m.getExchange().getBus();\n        try {\n            KeyEncryptionAlgorithm keyEncryptionProvider = null;\n            String keyEncryptionAlgo = null;\n            Properties props = ResourceUtils.loadProperties(propLoc, bus);\n            if (JwkUtils.JWK_KEY_STORE_TYPE.equals(props.get(CryptoUtils.RSSEC_KEY_STORE_TYPE))) {\n                JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, JsonWebKey.KEY_OPER_ENCRYPT);\n                keyEncryptionAlgo = jwk.getAlgorithm();\n                // TODO: Put it into some factory code\n                if (JsonWebKey.KEY_TYPE_RSA.equals(jwk.getKeyType())) {\n                    keyEncryptionProvider = new RSAOaepKeyEncryptionAlgorithm(jwk.toRSAPublicKey(),\n                                                getKeyEncryptionAlgo(props, keyEncryptionAlgo));\n                } else if (JsonWebKey.KEY_TYPE_OCTET.equals(jwk.getKeyType())) {\n                    SecretKey key = jwk.toSecretKey();\n                    if (Algorithm.isAesKeyWrap(keyEncryptionAlgo)) {\n                        keyEncryptionProvider = new AesWrapKeyEncryptionAlgorithm(key, keyEncryptionAlgo);\n                    } else if (Algorithm.isAesGcmKeyWrap(keyEncryptionAlgo)) {\n                        keyEncryptionProvider = new AesGcmWrapKeyEncryptionAlgorithm(key, keyEncryptionAlgo);\n                    }\n                } else {\n                    // TODO: support elliptic curve keys\n                }\n                \n            } else {\n                keyEncryptionProvider = new RSAOaepKeyEncryptionAlgorithm(\n                    (RSAPublicKey)CryptoUtils.loadPublicKey(m, props), \n                    getKeyEncryptionAlgo(props, keyEncryptionAlgo));\n            }\n            if (keyEncryptionProvider == null) {\n                throw new SecurityException();\n            }\n            \n            String contentEncryptionAlgo = props.getProperty(JSON_WEB_ENCRYPTION_CEK_ALGO_PROP);\n            JweHeaders headers = new JweHeaders(getKeyEncryptionAlgo(props, keyEncryptionAlgo), \n                                                contentEncryptionAlgo);\n            String compression = props.getProperty(JSON_WEB_ENCRYPTION_ZIP_ALGO_PROP);\n            if (compression != null) {\n                headers.setZipAlgorithm(compression);\n            }\n            boolean isAesHmac = Algorithm.isAesCbcHmac(contentEncryptionAlgo);\n            if (isAesHmac) { \n                return new AesCbcHmacJweEncryption(\n                    keyEncryptionAlgo, contentEncryptionAlgo, keyEncryptionProvider);\n            } else {\n                return new WrappedKeyJweEncryption(headers, keyEncryptionProvider);\n            }\n        } catch (SecurityException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new SecurityException(ex);\n        }\n    }","commit_id":"8bc72ec088209f7ec6261ad0fea660b0dbff5a56","url":"https://github.com/apache/cxf"},{"original_method":"protected Attachments getAttachmentsForDocument(Document doc, int start, int number) throws XWikiException\n    {\n        Attachments attachments = objectFactory.createAttachments();\n\n        List<com.xpn.xwiki.api.Attachment> xwikiAttachments = doc.getAttachmentList();\n\n        RangeIterable<com.xpn.xwiki.api.Attachment> ri =\n            new RangeIterable<com.xpn.xwiki.api.Attachment>(xwikiAttachments, start, number);\n\n        for (com.xpn.xwiki.api.Attachment xwikiAttachment : ri) {\n            URL url =\n                Utils\n                    .getXWikiContext(componentManager)\n                    .getURLFactory()\n                    .createAttachmentURL(xwikiAttachment.getFilename(), doc.getSpace(), doc.getName(), \"download\",\n                        null, doc.getWiki(), Utils.getXWikiContext(componentManager));\n            String attachmentXWikiAbsoluteUrl = url.toString();\n            String attachmentXWikiRelativeUrl =\n                Utils.getXWikiContext(componentManager).getURLFactory()\n                    .getURL(url, Utils.getXWikiContext(componentManager));\n\n            attachments.getAttachments().add(\n                DomainObjectFactory.createAttachment(objectFactory, uriInfo.getBaseUri(), xwikiAttachment,\n                    attachmentXWikiRelativeUrl, attachmentXWikiAbsoluteUrl, Utils.getXWikiApi(componentManager)));\n        }\n\n        return attachments;\n    }","id":79361,"modified_method":"protected Attachments getAttachmentsForDocument(Document doc, int start, int number, Boolean withPrettyNames) throws XWikiException\n    {\n        Attachments attachments = objectFactory.createAttachments();\n\n        List<com.xpn.xwiki.api.Attachment> xwikiAttachments = doc.getAttachmentList();\n\n        RangeIterable<com.xpn.xwiki.api.Attachment> ri =\n            new RangeIterable<com.xpn.xwiki.api.Attachment>(xwikiAttachments, start, number);\n\n        for (com.xpn.xwiki.api.Attachment xwikiAttachment : ri) {\n            URL url =\n                Utils\n                    .getXWikiContext(componentManager)\n                    .getURLFactory()\n                    .createAttachmentURL(xwikiAttachment.getFilename(), doc.getSpace(), doc.getName(), \"download\",\n                        null, doc.getWiki(), Utils.getXWikiContext(componentManager));\n            String attachmentXWikiAbsoluteUrl = url.toString();\n            String attachmentXWikiRelativeUrl =\n                Utils.getXWikiContext(componentManager).getURLFactory()\n                    .getURL(url, Utils.getXWikiContext(componentManager));\n\n            attachments.getAttachments().add(\n                DomainObjectFactory.createAttachment(objectFactory, uriInfo.getBaseUri(), xwikiAttachment,\n                    attachmentXWikiRelativeUrl, attachmentXWikiAbsoluteUrl, Utils.getXWikiApi(componentManager), withPrettyNames));\n        }\n\n        return attachments;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected AttachmentInfo storeAttachment(Document doc, String attachmentName, byte[] content) throws XWikiException\n    {\n        boolean alreadyExisting = false;\n\n        XWikiDocument xwikiDocument =\n            Utils.getXWiki(componentManager).getDocument(doc.getPrefixedFullName(),\n                Utils.getXWikiContext(componentManager));\n        XWikiAttachment xwikiAttachment = xwikiDocument.getAttachment(attachmentName);\n        if (xwikiAttachment == null) {\n            xwikiAttachment = new XWikiAttachment();\n            xwikiDocument.getAttachmentList().add(xwikiAttachment);\n        } else {\n            alreadyExisting = true;\n        }\n\n        xwikiAttachment.setContent(content);\n        xwikiAttachment.setAuthor(Utils.getXWikiUser(componentManager));\n        xwikiAttachment.setFilename(attachmentName);\n        xwikiAttachment.setDoc(xwikiDocument);\n\n        Utils.getXWiki(componentManager).saveDocument(xwikiDocument, Utils.getXWikiContext(componentManager));\n\n        URL url =\n            Utils\n                .getXWikiContext(componentManager)\n                .getURLFactory()\n                .createAttachmentURL(attachmentName, doc.getSpace(), doc.getName(), \"download\", null, doc.getWiki(),\n                    Utils.getXWikiContext(componentManager));\n        String attachmentXWikiAbsoluteUrl = url.toString();\n        String attachmentXWikiRelativeUrl =\n            Utils.getXWikiContext(componentManager).getURLFactory()\n                .getURL(url, Utils.getXWikiContext(componentManager));\n\n        Attachment attachment =\n            DomainObjectFactory.createAttachment(objectFactory, uriInfo.getBaseUri(), new com.xpn.xwiki.api.Attachment(\n                doc, xwikiAttachment, Utils.getXWikiContext(componentManager)), attachmentXWikiRelativeUrl,\n                attachmentXWikiAbsoluteUrl, Utils.getXWikiApi(componentManager));\n\n        return new AttachmentInfo(attachment, alreadyExisting);\n    }","id":79362,"modified_method":"protected AttachmentInfo storeAttachment(Document doc, String attachmentName, byte[] content) throws XWikiException\n    {\n        boolean alreadyExisting = false;\n\n        XWikiDocument xwikiDocument =\n            Utils.getXWiki(componentManager).getDocument(doc.getPrefixedFullName(),\n                Utils.getXWikiContext(componentManager));\n        XWikiAttachment xwikiAttachment = xwikiDocument.getAttachment(attachmentName);\n        if (xwikiAttachment == null) {\n            xwikiAttachment = new XWikiAttachment();\n            xwikiDocument.getAttachmentList().add(xwikiAttachment);\n        } else {\n            alreadyExisting = true;\n        }\n\n        xwikiAttachment.setContent(content);\n        xwikiAttachment.setAuthor(Utils.getXWikiUser(componentManager));\n        xwikiAttachment.setFilename(attachmentName);\n        xwikiAttachment.setDoc(xwikiDocument);\n\n        Utils.getXWiki(componentManager).saveDocument(xwikiDocument, Utils.getXWikiContext(componentManager));\n\n        URL url =\n            Utils\n                .getXWikiContext(componentManager)\n                .getURLFactory()\n                .createAttachmentURL(attachmentName, doc.getSpace(), doc.getName(), \"download\", null, doc.getWiki(),\n                    Utils.getXWikiContext(componentManager));\n        String attachmentXWikiAbsoluteUrl = url.toString();\n        String attachmentXWikiRelativeUrl =\n            Utils.getXWikiContext(componentManager).getURLFactory()\n                .getURL(url, Utils.getXWikiContext(componentManager));\n\n        Attachment attachment =\n            DomainObjectFactory.createAttachment(objectFactory, uriInfo.getBaseUri(), new com.xpn.xwiki.api.Attachment(\n                doc, xwikiAttachment, Utils.getXWikiContext(componentManager)), attachmentXWikiRelativeUrl,\n                attachmentXWikiAbsoluteUrl, Utils.getXWikiApi(componentManager), false);\n\n        return new AttachmentInfo(attachment, alreadyExisting);\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieves the attachments by filtering them.\n     * \n     * @param wikiName The virtual wiki.\n     * @param name Name filter (include only attachments that matches this name)\n     * @param page Page filter (include only attachments are attached to a page matches this string)\n     * @param space Space filter (include only attachments are attached to a page in a space matching this string)\n     * @param author Author filter (include only attachments from an author who matches this string)\n     * @param types A comma separated list of string that will be matched against the actual mime type of the\n     *            attachments.\n     * @param start\n     * @param number\n     * @return The list of the retrieved attachments.\n     * @throws QueryException\n     */\n    public Attachments getAttachments(String wikiName, String name, String page, String space, String author,\n        String types, Integer start, Integer number) throws QueryException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        Attachments attachments = objectFactory.createAttachments();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n\n            Map<String, String> filters = new HashMap<String, String>();\n            if (!name.equals(\"\")) {\n                filters.put(\"name\", name);\n            }\n            if (!page.equals(\"\")) {\n                filters.put(\"page\", name);\n            }\n            if (!space.equals(\"\")) {\n                filters.put(\"space\", space);\n            }\n            if (!author.equals(\"\")) {\n                filters.put(\"author\", author);\n            }\n\n            /* Build the query */\n            Formatter f = new Formatter();\n            f.format(\"select doc.space, doc.name, doc.version, attachment from XWikiDocument as doc, XWikiAttachment as attachment where (attachment.docId=doc.id \");\n\n            if (filters.keySet().size() > 0) {\n                for (String param : filters.keySet()) {\n                    if (param.equals(\"name\")) {\n                        f.format(\" and upper(attachment.filename) like :name \");\n                    }\n                    if (param.equals(\"page\")) {\n                        f.format(\" and upper(doc.fullName) like :page \");\n                    }\n                    if (param.equals(\"space\")) {\n                        f.format(\" and upper(doc.space) like :space \");\n                    }\n\n                    if (param.equals(\"author\")) {\n                        f.format(\" and upper(attachment.author) like :author \");\n                    }\n                }\n            }\n\n            f.format(\")\");\n\n            String queryString = f.toString();\n\n            /* Execute the query by filling the parameters */\n            Query query = queryManager.createQuery(queryString, Query.XWQL).setLimit(number).setOffset(start);\n            for (String param : filters.keySet()) {\n                query.bindValue(param, String.format(\"%%%s%%\", filters.get(param).toUpperCase()));\n            }\n\n            List<Object> queryResult = null;\n            queryResult = query.execute();\n\n            Set<String> acceptedMimeTypes = new HashSet<String>();\n            if (!types.equals(\"\")) {\n                String[] acceptedMimetypesArray = types.split(\",\");\n                for (String type : acceptedMimetypesArray) {\n                    acceptedMimeTypes.add(type);\n                }\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n                String pageSpace = (String) fields[0];\n                String pageName = (String) fields[1];\n                String pageId = Utils.getPageId(wikiName, pageSpace, pageName);\n                String pageVersion = (String) fields[2];\n                XWikiAttachment xwikiAttachment = (XWikiAttachment) fields[3];\n\n                String mimeType = xwikiAttachment.getMimeType(Utils.getXWikiContext(componentManager));\n\n                boolean add = true;\n\n                /* Check the mime type filter */\n                if (acceptedMimeTypes.size() > 0) {\n                    add = false;\n\n                    for (String type : acceptedMimeTypes) {\n                        if (mimeType.toUpperCase().contains(type.toUpperCase())) {\n                            add = true;\n                            break;\n                        }\n                    }\n                }\n\n                if (add) {\n                    /*\n                     * We manufacture attachments in place because we don't have all the data for calling the\n                     * DomainObjectFactory method (doing so would require to retrieve an actual Document)\n                     */\n                    Attachment attachment = objectFactory.createAttachment();\n                    attachment.setId(String.format(\"%s@%s\", pageId, xwikiAttachment.getFilename()));\n                    attachment.setName(xwikiAttachment.getFilename());\n                    attachment.setSize(xwikiAttachment.getFilesize());\n                    attachment.setMimeType(mimeType);\n                    attachment.setAuthor(xwikiAttachment.getAuthor());\n                    attachment.setAuthorName(Utils.getAuthorName(xwikiAttachment.getAuthor(), componentManager));\n                    \n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(xwikiAttachment.getDate());\n                    attachment.setDate(calendar);\n\n                    attachment.setPageId(pageId);\n                    attachment.setPageVersion(pageVersion);\n                    attachment.setVersion(xwikiAttachment.getVersion());\n\n                    URL absoluteUrl =\n                        Utils\n                            .getXWikiContext(componentManager)\n                            .getURLFactory()\n                            .createAttachmentURL(xwikiAttachment.getFilename(), pageSpace, pageName, \"download\", null,\n                                wikiName, Utils.getXWikiContext(componentManager));\n                    attachment.setXwikiAbsoluteUrl(absoluteUrl.toString());\n                    attachment.setXwikiRelativeUrl(Utils.getXWikiContext(componentManager).getURLFactory()\n                        .getURL(absoluteUrl, Utils.getXWikiContext(componentManager)));\n\n                    String baseUri = uriInfo.getBaseUri().toString();\n\n                    String pageUri =\n                        UriBuilder.fromUri(baseUri).path(PageResource.class).build(wikiName, pageSpace, pageName)\n                            .toString();\n                    Link pageLink = objectFactory.createLink();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    attachment.getLinks().add(pageLink);\n\n                    String attachmentUri =\n                        UriBuilder.fromUri(baseUri).path(AttachmentResource.class)\n                            .build(wikiName, pageSpace, pageName, xwikiAttachment.getFilename()).toString();\n                    Link attachmentLink = objectFactory.createLink();\n                    attachmentLink.setHref(attachmentUri);\n                    attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n                    attachment.getLinks().add(attachmentLink);\n\n                    attachments.getAttachments().add(attachment);\n                }\n            }\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n\n        return attachments;\n    }","id":79363,"modified_method":"/**\n     * Retrieves the attachments by filtering them.\n     * \n     * @param wikiName The virtual wiki.\n     * @param name Name filter (include only attachments that matches this name)\n     * @param page Page filter (include only attachments are attached to a page matches this string)\n     * @param space Space filter (include only attachments are attached to a page in a space matching this string)\n     * @param author Author filter (include only attachments from an author who matches this string)\n     * @param types A comma separated list of string that will be matched against the actual mime type of the\n     *            attachments.\n     * @param start\n     * @param number\n     * @return The list of the retrieved attachments.\n     * @throws QueryException\n     */\n    public Attachments getAttachments(String wikiName, String name, String page, String space, String author,\n        String types, Integer start, Integer number, Boolean withPrettyNames) throws QueryException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        Attachments attachments = objectFactory.createAttachments();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n\n            Map<String, String> filters = new HashMap<String, String>();\n            if (!name.equals(\"\")) {\n                filters.put(\"name\", name);\n            }\n            if (!page.equals(\"\")) {\n                filters.put(\"page\", name);\n            }\n            if (!space.equals(\"\")) {\n                filters.put(\"space\", space);\n            }\n            if (!author.equals(\"\")) {\n                filters.put(\"author\", author);\n            }\n\n            /* Build the query */\n            Formatter f = new Formatter();\n            f.format(\"select doc.space, doc.name, doc.version, attachment from XWikiDocument as doc, XWikiAttachment as attachment where (attachment.docId=doc.id \");\n\n            if (filters.keySet().size() > 0) {\n                for (String param : filters.keySet()) {\n                    if (param.equals(\"name\")) {\n                        f.format(\" and upper(attachment.filename) like :name \");\n                    }\n                    if (param.equals(\"page\")) {\n                        f.format(\" and upper(doc.fullName) like :page \");\n                    }\n                    if (param.equals(\"space\")) {\n                        f.format(\" and upper(doc.space) like :space \");\n                    }\n\n                    if (param.equals(\"author\")) {\n                        f.format(\" and upper(attachment.author) like :author \");\n                    }\n                }\n            }\n\n            f.format(\")\");\n\n            String queryString = f.toString();\n\n            /* Execute the query by filling the parameters */\n            Query query = queryManager.createQuery(queryString, Query.XWQL).setLimit(number).setOffset(start);\n            for (String param : filters.keySet()) {\n                query.bindValue(param, String.format(\"%%%s%%\", filters.get(param).toUpperCase()));\n            }\n\n            List<Object> queryResult = null;\n            queryResult = query.execute();\n\n            Set<String> acceptedMimeTypes = new HashSet<String>();\n            if (!types.equals(\"\")) {\n                String[] acceptedMimetypesArray = types.split(\",\");\n                for (String type : acceptedMimetypesArray) {\n                    acceptedMimeTypes.add(type);\n                }\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n                String pageSpace = (String) fields[0];\n                String pageName = (String) fields[1];\n                String pageId = Utils.getPageId(wikiName, pageSpace, pageName);\n                String pageVersion = (String) fields[2];\n                XWikiAttachment xwikiAttachment = (XWikiAttachment) fields[3];\n\n                String mimeType = xwikiAttachment.getMimeType(Utils.getXWikiContext(componentManager));\n\n                boolean add = true;\n\n                /* Check the mime type filter */\n                if (acceptedMimeTypes.size() > 0) {\n                    add = false;\n\n                    for (String type : acceptedMimeTypes) {\n                        if (mimeType.toUpperCase().contains(type.toUpperCase())) {\n                            add = true;\n                            break;\n                        }\n                    }\n                }\n\n                if (add) {\n                    /*\n                     * We manufacture attachments in place because we don't have all the data for calling the\n                     * DomainObjectFactory method (doing so would require to retrieve an actual Document)\n                     */\n                    Attachment attachment = objectFactory.createAttachment();\n                    attachment.setId(String.format(\"%s@%s\", pageId, xwikiAttachment.getFilename()));\n                    attachment.setName(xwikiAttachment.getFilename());\n                    attachment.setSize(xwikiAttachment.getFilesize());\n                    attachment.setMimeType(mimeType);\n                    attachment.setAuthor(xwikiAttachment.getAuthor());\n                    if (withPrettyNames)\n                        attachment.setAuthorName(Utils.getAuthorName(xwikiAttachment.getAuthor(), componentManager));\n                    \n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(xwikiAttachment.getDate());\n                    attachment.setDate(calendar);\n\n                    attachment.setPageId(pageId);\n                    attachment.setPageVersion(pageVersion);\n                    attachment.setVersion(xwikiAttachment.getVersion());\n\n                    URL absoluteUrl =\n                        Utils\n                            .getXWikiContext(componentManager)\n                            .getURLFactory()\n                            .createAttachmentURL(xwikiAttachment.getFilename(), pageSpace, pageName, \"download\", null,\n                                wikiName, Utils.getXWikiContext(componentManager));\n                    attachment.setXwikiAbsoluteUrl(absoluteUrl.toString());\n                    attachment.setXwikiRelativeUrl(Utils.getXWikiContext(componentManager).getURLFactory()\n                        .getURL(absoluteUrl, Utils.getXWikiContext(componentManager)));\n\n                    String baseUri = uriInfo.getBaseUri().toString();\n\n                    String pageUri =\n                        UriBuilder.fromUri(baseUri).path(PageResource.class).build(wikiName, pageSpace, pageName)\n                            .toString();\n                    Link pageLink = objectFactory.createLink();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    attachment.getLinks().add(pageLink);\n\n                    String attachmentUri =\n                        UriBuilder.fromUri(baseUri).path(AttachmentResource.class)\n                            .build(wikiName, pageSpace, pageName, xwikiAttachment.getFilename()).toString();\n                    Link attachmentLink = objectFactory.createLink();\n                    attachmentLink.setHref(attachmentUri);\n                    attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n                    attachment.getLinks().add(attachmentLink);\n\n                    attachments.getAttachments().add(attachment);\n                }\n            }\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n\n        return attachments;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start) throws QueryException,\n        IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc where doc.space = :space and ( \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc where ( \");\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        f.format(\"upper(doc.fullName) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"upper(doc.title) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return result;\n            }\n\n            if (hasProgrammingRights) {\n                f.format(\") order by doc.fullName asc\");\n            } else {\n                f.format(\") and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by doc.fullName asc\");\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).setOffset(start).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .setOffset(start).execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":79364,"modified_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, Boolean withPrettyNames) throws QueryException,\n        IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc where doc.space = :space and ( \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc where ( \");\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        f.format(\"upper(doc.fullName) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"upper(doc.title) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return result;\n            }\n\n            if (hasProgrammingRights) {\n                f.format(\") order by doc.fullName asc\");\n            } else {\n                f.format(\") and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by doc.fullName asc\");\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).setOffset(start).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .setOffset(start).execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    if (withPrettyNames)\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param queryLanguage\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchQuery(String keywords, String queryLanguage, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, boolean distinct) throws QueryException,\n        IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null || keywords.trim().startsWith(\"select\")) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n            if (distinct)\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc \"\n                    + keywords);\n            else\n                f.format(\"select doc.fullName, doc.space, doc.name, doc.language from XWikiDocument as doc \" + keywords);\n\n            String query = f.toString();\n            if (space != null)\n                query.replace(\"where \", \"where doc.space=:space and \");\n\n            if (!hasProgrammingRights) {\n                query\n                    .replace(\"where \",\n                        \"where doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' and \");\n            }\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, queryLanguage).bindValue(\"space\", space).setLimit(number)\n                        .setOffset(start).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, queryLanguage).setLimit(number).setOffset(start).execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String language = (String) fields[3];\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"page\");\n                    searchResult.setId(pageId);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setAuthor(doc.getAuthor());\n                    searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":79365,"modified_method":"/**\n     * Search for query using xwql, hql, lucene. Limit the search only to Pages. Search for keyword\n     * \n     * @param query\n     * @param queryType\n     * @param wikiName\n     * @param wikis\n     * @param hasProgrammingRights\n     * @param order\n     * @param distinct\n     * @param number\n     * @param start\n     * @param withPrettyNames \n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchQuery(String query, String queryType, String wikiName, String wikis,\n        boolean hasProgrammingRights, String order, boolean distinct, int number, int start, Boolean withPrettyNames) throws QueryException,\n        IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n   \n            if (QueryType.LUCENE.equals(queryType)) {\n                result.addAll(searchLucene(query, wikiName, wikis, hasProgrammingRights, order, number, start, withPrettyNames));\n                } else {\n                    result.addAll(searchDatabaseQuery(query, QueryType.XWQL.equals(queryType) ? Query.XWQL : Query.HQL, \n                        wikiName, hasProgrammingRights, distinct, number, start, withPrettyNames));\n                }\n            return result;\n        } finally {\n                Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Objects.\n     * \n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start) throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            if (hasProgrammingRights) {\n                f.format(\" order by doc.fullName asc\");\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by doc.fullName asc\");\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaceName, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n\n                    String pageUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(PageResource.class)\n                            .build(wikiName, spaceName, pageName).toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(ObjectResource.class)\n                            .build(wikiName, spaceName, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":79366,"modified_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Objects.\n     * \n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, Boolean withPrettyNames) throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            if (hasProgrammingRights) {\n                f.format(\" order by doc.fullName asc\");\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by doc.fullName asc\");\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceName = (String) fields[1];\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaceName, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n\n                if (Utils.getXWikiApi(componentManager).hasAccessLevel(\"view\", pageId)) {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    if (withPrettyNames)\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthor(), componentManager));\n\n                    String pageUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(PageResource.class)\n                            .build(wikiName, spaceName, pageName).toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri =\n                        UriBuilder.fromUri(uriInfo.getBaseUri()).path(ObjectResource.class)\n                            .build(wikiName, spaceName, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchLucene(String keywords, String defaultWikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String searchWikis, String order) throws QueryException,\n        IllegalArgumentException, UriBuilderException, XWikiException\n    {\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            LOGGER.error(\"HERE\");\n\n            if (keywords == null) {\n                return result;\n            }\n\n            if (!hasProgrammingRights) {\n                if (space != null)\n                    keywords = \"(\" + keywords + \") AND space:\" + space;\n                else\n                    keywords +=\n                        \" AND NOT space:XWiki AND NOT space:Admin and NOT space:Panels and NOT space:WebPreferences\";\n            } else if (space != null) {\n                keywords = \"(\" + keywords + \") AND space:\" + space;\n            }\n\n            LOGGER.error(\"Query is: \" + keywords);\n\n            try {\n                XWikiContext context = Utils.getXWikiContext(componentManager);\n                LucenePlugin lucene = (LucenePlugin) Utils.getXWiki(componentManager).getPlugin(\"lucene\", context);\n                SearchResults luceneSearchResults =\n                    lucene.getSearchResults(keywords, order, (searchWikis == null) ? defaultWikiName : searchWikis, \"\",\n                        context);\n                List<com.xpn.xwiki.plugin.lucene.SearchResult> luceneResults =\n                    luceneSearchResults.getResults(start, (number == -1) ? 20 : number);\n                for (com.xpn.xwiki.plugin.lucene.SearchResult luceneSearchResult : luceneResults) {\n                    String wikiName = luceneSearchResult.getWiki();\n                    String spaceName = luceneSearchResult.getSpace();\n                    String pageName = luceneSearchResult.getName();\n                    String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(luceneSearchResult.getType().equals(LucenePlugin.DOCTYPE_WIKIPAGE) ? \"page\"\n                        : \"file\");\n                    searchResult.setId(luceneSearchResult.getId());\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    if (luceneSearchResult.equals(LucenePlugin.DOCTYPE_ATTACHMENT))\n                        searchResult.setFilename(luceneSearchResult.getFilename());\n                    searchResult.setScore(luceneSearchResult.getScore());\n                    searchResult.setAuthor(luceneSearchResult.getAuthor());\n                    searchResult.setAuthorName(Utils.getAuthorName(luceneSearchResult.getAuthor(), componentManager));\n\n                    String language = luceneSearchResult.getLanguage();\n                    if (language.equals(\"default\"))\n                        language = \"\";\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n                    result.add(searchResult);\n                }\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Error performing lucene search\", e);\n            }\n\n            return result;\n        } finally {\n            // Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":79367,"modified_method":"/**\n     * Search for keyword in the given scopes. Limit the search only to Pages. Search for keyword\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws QueryException\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> searchLucene(String query, String defaultWikiName, String wikis,\n        boolean hasProgrammingRights, String order, int number, int start, Boolean withPrettyNames) throws QueryException,\n        IllegalArgumentException, UriBuilderException, XWikiException\n    {\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            LOGGER.error(\"HERE\");\n\n            if (query == null) {\n                return result;\n            }\n\n            if (!hasProgrammingRights) {\n                query += \" AND NOT space:XWiki AND NOT space:Admin AND NOT space:Panels AND NOT name:WebPreferences\";\n            }\n\n            LOGGER.error(\"Query is: \" + query);\n\n            try {\n                XWikiContext context = Utils.getXWikiContext(componentManager);\n                LucenePlugin lucene = (LucenePlugin) Utils.getXWiki(componentManager).getPlugin(\"lucene\", context);\n                SearchResults luceneSearchResults =\n                    lucene.getSearchResults(query, order, (wikis == null) ? defaultWikiName : wikis, \"\",\n                        context);\n                List<com.xpn.xwiki.plugin.lucene.SearchResult> luceneResults =\n                    luceneSearchResults.getResults(start, (number == -1) ? 20 : number);\n                for (com.xpn.xwiki.plugin.lucene.SearchResult luceneSearchResult : luceneResults) {\n                    String wikiName = luceneSearchResult.getWiki();\n                    String spaceName = luceneSearchResult.getSpace();\n                    String pageName = luceneSearchResult.getName();\n                    String pageFullName = Utils.getPageFullName(wikiName, spaceName, pageName);\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(luceneSearchResult.getType().equals(LucenePlugin.DOCTYPE_WIKIPAGE) ? \"page\"\n                        : \"file\");\n                    searchResult.setId(luceneSearchResult.getId());\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceName);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    if (luceneSearchResult.equals(LucenePlugin.DOCTYPE_ATTACHMENT))\n                        searchResult.setFilename(luceneSearchResult.getFilename());\n                    searchResult.setScore(luceneSearchResult.getScore());\n                    searchResult.setAuthor(luceneSearchResult.getAuthor());\n                    if (withPrettyNames)\n                        searchResult.setAuthorName(Utils.getAuthorName(luceneSearchResult.getAuthor(), componentManager));\n\n                    String language = luceneSearchResult.getLanguage();\n                    if (language.equals(\"default\"))\n                        language = \"\";\n\n                    String pageUri = null;\n                    try {\n                        if (StringUtils.isBlank(language)) {\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"))\n                                    .toString();\n                        } else {\n                            searchResult.setLanguage(language);\n                            pageUri =\n                                UriBuilder\n                                    .fromUri(this.uriInfo.getBaseUri())\n                                    .path(PageTranslationResource.class)\n                                    .buildFromEncoded(URLEncoder.encode(wikiName, \"UTF-8\"),\n                                        URLEncoder.encode(spaceName, \"UTF-8\"), URLEncoder.encode(pageName, \"UTF-8\"),\n                                        language).toString();\n                        }\n                    } catch (UnsupportedEncodingException ex) {\n                        // This should never happen, UTF-8 is always valid.\n                    }\n\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n                    result.add(searchResult);\n                }\n            } catch (Exception e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Error performing lucene search\", e);\n            }\n\n            return result;\n        } finally {\n            // Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Search for keyword in the given scopes. See {@link SearchScope} for more information.\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @return\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws QueryException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> search(List<SearchScope> searchScopes, String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, boolean distinct, String searchWikis, String order)\n        throws IllegalArgumentException, UriBuilderException, QueryException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            result.addAll(searchPages(searchScopes, keywords, wikiName, space, hasProgrammingRights, number, start));\n\n            if (searchScopes.contains(SearchScope.SPACES)) {\n                result.addAll(searchSpaces(keywords, wikiName, hasProgrammingRights, number, start));\n            }\n\n            if (searchScopes.contains(SearchScope.OBJECTS)) {\n                result.addAll(searchObjects(keywords, wikiName, space, hasProgrammingRights, number, start));\n            }\n\n            if (searchScopes.contains(SearchScope.XWQL)) {\n                result.addAll(searchQuery(keywords, Query.XWQL, wikiName, space, hasProgrammingRights, number, start,\n                    distinct));\n            }\n\n            if (searchScopes.contains(SearchScope.HQL)) {\n                result.addAll(searchQuery(keywords, Query.HQL, wikiName, space, hasProgrammingRights, number, start,\n                    distinct));\n            }\n\n            if (searchScopes.contains(SearchScope.LUCENE)) {\n                result.addAll(searchLucene(keywords, wikiName, space, hasProgrammingRights, number, start, searchWikis,\n                    order));\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","id":79368,"modified_method":"/**\n     * Search for keyword in the given scopes. See {@link SearchScope} for more information.\n     * \n     * @param searchScopes\n     * @param keywords\n     * @param wikiName\n     * @param space\n     * @param hasProgrammingRights\n     * @param number\n     * @param withPrettyNames true if the users are displayed with their full name\n     * @return\n     * @throws IllegalArgumentException\n     * @throws UriBuilderException\n     * @throws QueryException\n     * @throws XWikiException\n     */\n    protected List<SearchResult> search(List<SearchScope> searchScopes, String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, boolean distinct, String order, Boolean withPrettyNames)\n        throws IllegalArgumentException, UriBuilderException, QueryException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getDatabase();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            result.addAll(searchPages(searchScopes, keywords, wikiName, space, hasProgrammingRights, number, start, withPrettyNames));\n\n            if (searchScopes.contains(SearchScope.SPACES)) {\n                result.addAll(searchSpaces(keywords, wikiName, hasProgrammingRights, number, start));\n            }\n\n            if (searchScopes.contains(SearchScope.OBJECTS)) {\n                result.addAll(searchObjects(keywords, wikiName, space, hasProgrammingRights, number, start, withPrettyNames));\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setDatabase(database);\n        }\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static ObjectSummary createObjectSummary(ObjectFactory objectFactory, URI baseUri,\n        XWikiContext xwikiContext, Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi) throws XWikiException\n    {\n        ObjectSummary objectSummary = objectFactory.createObjectSummary();\n        fillObjectSummary(objectSummary, objectFactory, baseUri, doc, xwikiObject, xwikiApi);\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.OBJECT);\n        objectSummary.getLinks().add(objectLink);\n\n        String propertiesUri;\n\n        if (useVersion) {\n            propertiesUri =\n                UriBuilder\n                    .fromUri(baseUri)\n                    .path(ObjectPropertiesAtPageVersionResource.class)\n                    .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion(), xwikiObject.getClassName(),\n                        xwikiObject.getNumber()).toString();\n        } else {\n            propertiesUri =\n                UriBuilder\n                    .fromUri(baseUri)\n                    .path(ObjectPropertiesResource.class)\n                    .build(doc.getWiki(), doc.getSpace(), doc.getName(), xwikiObject.getClassName(),\n                        xwikiObject.getNumber()).toString();\n        }\n\n        Link propertyLink = objectFactory.createLink();\n        propertyLink.setHref(propertiesUri);\n        propertyLink.setRel(Relations.PROPERTIES);\n        objectSummary.getLinks().add(propertyLink);\n\n        return objectSummary;\n    }","id":79369,"modified_method":"public static ObjectSummary createObjectSummary(ObjectFactory objectFactory, URI baseUri,\n        XWikiContext xwikiContext, Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        ObjectSummary objectSummary = objectFactory.createObjectSummary();\n        fillObjectSummary(objectSummary, objectFactory, baseUri, doc, xwikiObject, xwikiApi, withPrettyNames);\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.OBJECT);\n        objectSummary.getLinks().add(objectLink);\n\n        String propertiesUri;\n\n        if (useVersion) {\n            propertiesUri =\n                UriBuilder\n                    .fromUri(baseUri)\n                    .path(ObjectPropertiesAtPageVersionResource.class)\n                    .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion(), xwikiObject.getClassName(),\n                        xwikiObject.getNumber()).toString();\n        } else {\n            propertiesUri =\n                UriBuilder\n                    .fromUri(baseUri)\n                    .path(ObjectPropertiesResource.class)\n                    .build(doc.getWiki(), doc.getSpace(), doc.getName(), xwikiObject.getClassName(),\n                        xwikiObject.getNumber()).toString();\n        }\n\n        Link propertyLink = objectFactory.createLink();\n        propertyLink.setHref(propertiesUri);\n        propertyLink.setRel(Relations.PROPERTIES);\n        objectSummary.getLinks().add(propertyLink);\n\n        return objectSummary;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Object createObject(ObjectFactory objectFactory, URI baseUri, XWikiContext xwikiContext,\n        Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi) throws XWikiException\n    {\n        Object object = objectFactory.createObject();\n        fillObjectSummary(object, objectFactory, baseUri, doc, xwikiObject, xwikiApi);\n\n        BaseClass xwikiClass = xwikiObject.getXClass(xwikiContext);\n\n        for (java.lang.Object propertyClassObject : xwikiClass.getProperties()) {\n            com.xpn.xwiki.objects.classes.PropertyClass propertyClass =\n                (com.xpn.xwiki.objects.classes.PropertyClass) propertyClassObject;\n\n            Property property = objectFactory.createProperty();\n\n            for (java.lang.Object o : propertyClass.getProperties()) {\n                BaseProperty baseProperty = (BaseProperty) o;\n                Attribute attribute = objectFactory.createAttribute();\n                attribute.setName(baseProperty.getName());\n\n                /* Check for null values in order to prevent NPEs */\n                if (baseProperty.getValue() != null) {\n                    attribute.setValue(baseProperty.getValue().toString());\n                } else {\n                    attribute.setValue(\"\");\n                }\n\n                property.getAttributes().add(attribute);\n            }\n\n            if (propertyClass instanceof ListClass) {\n                ListClass listClass = (ListClass) propertyClass;\n\n                List allowedValueList = listClass.getList(xwikiContext);\n\n                if (!allowedValueList.isEmpty()) {\n                    Formatter f = new Formatter();\n                    for (int i = 0; i < allowedValueList.size(); i++) {\n                        if (i != allowedValueList.size() - 1) {\n                            f.format(\"%s,\", allowedValueList.get(i).toString());\n                        } else {\n                            f.format(\"%s\", allowedValueList.get(i).toString());\n                        }\n                    }\n\n                    Attribute attribute = objectFactory.createAttribute();\n                    attribute.setName(Constants.ALLOWED_VALUES_ATTRIBUTE_NAME);\n                    attribute.setValue(f.toString());\n                    property.getAttributes().add(attribute);\n                }\n            }\n\n            property.setName(propertyClass.getName());\n            property.setType(propertyClass.getClassType());\n            if (xwikiObject.get(propertyClass.getName()) != null) {\n                property.setValue(xwikiObject.get(propertyClass.getName()).toFormString());\n            } else {\n                property.setValue(\"\");\n            }\n\n            String propertyUri;\n\n            if (useVersion) {\n                propertyUri =\n                    UriBuilder\n                        .fromUri(baseUri)\n                        .path(ObjectPropertyAtPageVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion(),\n                            xwikiObject.getClassName(), xwikiObject.getNumber(), propertyClass.getName()).toString();\n            } else {\n                propertyUri =\n                    UriBuilder\n                        .fromUri(baseUri)\n                        .path(ObjectPropertyResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), xwikiObject.getClassName(),\n                            xwikiObject.getNumber(), propertyClass.getName()).toString();\n            }\n            Link propertyLink = objectFactory.createLink();\n            propertyLink.setHref(propertyUri);\n            propertyLink.setRel(Relations.SELF);\n            property.getLinks().add(propertyLink);\n\n            object.getProperties().add(property);\n\n        }\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.SELF);\n        object.getLinks().add(objectLink);\n\n        return object;\n    }","id":79370,"modified_method":"public static Object createObject(ObjectFactory objectFactory, URI baseUri, XWikiContext xwikiContext,\n        Document doc, BaseObject xwikiObject, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        Object object = objectFactory.createObject();\n        fillObjectSummary(object, objectFactory, baseUri, doc, xwikiObject, xwikiApi, withPrettyNames);\n\n        BaseClass xwikiClass = xwikiObject.getXClass(xwikiContext);\n\n        for (java.lang.Object propertyClassObject : xwikiClass.getProperties()) {\n            com.xpn.xwiki.objects.classes.PropertyClass propertyClass =\n                (com.xpn.xwiki.objects.classes.PropertyClass) propertyClassObject;\n\n            Property property = objectFactory.createProperty();\n\n            for (java.lang.Object o : propertyClass.getProperties()) {\n                BaseProperty baseProperty = (BaseProperty) o;\n                Attribute attribute = objectFactory.createAttribute();\n                attribute.setName(baseProperty.getName());\n\n                /* Check for null values in order to prevent NPEs */\n                if (baseProperty.getValue() != null) {\n                    attribute.setValue(baseProperty.getValue().toString());\n                } else {\n                    attribute.setValue(\"\");\n                }\n\n                property.getAttributes().add(attribute);\n            }\n\n            if (propertyClass instanceof ListClass) {\n                ListClass listClass = (ListClass) propertyClass;\n\n                List allowedValueList = listClass.getList(xwikiContext);\n\n                if (!allowedValueList.isEmpty()) {\n                    Formatter f = new Formatter();\n                    for (int i = 0; i < allowedValueList.size(); i++) {\n                        if (i != allowedValueList.size() - 1) {\n                            f.format(\"%s,\", allowedValueList.get(i).toString());\n                        } else {\n                            f.format(\"%s\", allowedValueList.get(i).toString());\n                        }\n                    }\n\n                    Attribute attribute = objectFactory.createAttribute();\n                    attribute.setName(Constants.ALLOWED_VALUES_ATTRIBUTE_NAME);\n                    attribute.setValue(f.toString());\n                    property.getAttributes().add(attribute);\n                }\n            }\n\n            property.setName(propertyClass.getName());\n            property.setType(propertyClass.getClassType());\n            if (xwikiObject.get(propertyClass.getName()) != null) {\n                property.setValue(xwikiObject.get(propertyClass.getName()).toFormString());\n            } else {\n                property.setValue(\"\");\n            }\n\n            String propertyUri;\n\n            if (useVersion) {\n                propertyUri =\n                    UriBuilder\n                        .fromUri(baseUri)\n                        .path(ObjectPropertyAtPageVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion(),\n                            xwikiObject.getClassName(), xwikiObject.getNumber(), propertyClass.getName()).toString();\n            } else {\n                propertyUri =\n                    UriBuilder\n                        .fromUri(baseUri)\n                        .path(ObjectPropertyResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), xwikiObject.getClassName(),\n                            xwikiObject.getNumber(), propertyClass.getName()).toString();\n            }\n            Link propertyLink = objectFactory.createLink();\n            propertyLink.setHref(propertyUri);\n            propertyLink.setRel(Relations.SELF);\n            property.getLinks().add(propertyLink);\n\n            object.getProperties().add(property);\n\n        }\n\n        Link objectLink = getObjectLink(objectFactory, baseUri, doc, xwikiObject, useVersion, Relations.SELF);\n        object.getLinks().add(objectLink);\n\n        return object;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static PageSummary createPageSummary(ObjectFactory objectFactory, URI baseUri, Document doc, XWiki xwikiApi)\n        throws XWikiException\n    {\n        PageSummary pageSummary = objectFactory.createPageSummary();\n        fillPageSummary(pageSummary, objectFactory, baseUri, doc, false, xwikiApi);\n\n        String pageUri =\n            UriBuilder.fromUri(baseUri).path(PageResource.class).build(doc.getWiki(), doc.getSpace(), doc.getName())\n                .toString();\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        pageSummary.getLinks().add(pageLink);\n\n        return pageSummary;\n    }","id":79371,"modified_method":"public static PageSummary createPageSummary(ObjectFactory objectFactory, URI baseUri, Document doc, XWiki xwikiApi, Boolean withPrettyNames)\n        throws XWikiException\n    {\n        PageSummary pageSummary = objectFactory.createPageSummary();\n        fillPageSummary(pageSummary, objectFactory, baseUri, doc, false, xwikiApi, withPrettyNames);\n\n        String pageUri =\n            UriBuilder.fromUri(baseUri).path(PageResource.class).build(doc.getWiki(), doc.getSpace(), doc.getName())\n                .toString();\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        pageSummary.getLinks().add(pageLink);\n\n        return pageSummary;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static HistorySummary createHistorySummary(ObjectFactory objectFactory, URI baseUri, String wikiName,\n        String spaceName, String pageName, String language, Version version, String modifier, Date modified)\n    {\n        HistorySummary historySummary = objectFactory.createHistorySummary();\n\n        String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n\n        historySummary.setPageId(pageId);\n        historySummary.setWiki(wikiName);\n        historySummary.setSpace(spaceName);\n        historySummary.setName(pageName);\n        historySummary.setVersion(version.toString());\n        historySummary.setMajorVersion(version.at(0));\n        historySummary.setMinorVersion(version.at(1));\n        historySummary.setModifier(modifier);\n        historySummary.setLanguage(language);\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(modified);\n        historySummary.setModified(calendar);\n\n        if (language == null) {\n            String pageUri =\n                UriBuilder.fromUri(baseUri).path(PageVersionResource.class)\n                    .build(wikiName, spaceName, pageName, version).toString();\n            Link pageLink = objectFactory.createLink();\n            pageLink.setHref(pageUri);\n            pageLink.setRel(Relations.PAGE);\n            historySummary.getLinks().add(pageLink);\n        } else {\n            String pageUri =\n                UriBuilder.fromUri(baseUri).path(PageTranslationVersionResource.class)\n                    .build(wikiName, spaceName, pageName, language, version).toString();\n            Link pageLink = objectFactory.createLink();\n            pageLink.setHref(pageUri);\n            pageLink.setRel(Relations.PAGE);\n            historySummary.getLinks().add(pageLink);\n        }\n\n        return historySummary;\n    }","id":79372,"modified_method":"public static HistorySummary createHistorySummary(ObjectFactory objectFactory, URI baseUri, String wikiName,\n        String spaceName, String pageName, String language, Version version, String modifier, Date modified, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        HistorySummary historySummary = objectFactory.createHistorySummary();\n\n        String pageId = Utils.getPageId(wikiName, spaceName, pageName);\n\n        historySummary.setPageId(pageId);\n        historySummary.setWiki(wikiName);\n        historySummary.setSpace(spaceName);\n        historySummary.setName(pageName);\n        historySummary.setVersion(version.toString());\n        historySummary.setMajorVersion(version.at(0));\n        historySummary.setMinorVersion(version.at(1));\n        historySummary.setModifier(modifier);\n        if (withPrettyNames)\n            historySummary.setModifierName(xwikiApi.getUserName(modifier, false));\n\n        historySummary.setLanguage(language);\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(modified);\n        historySummary.setModified(calendar);\n\n        if (language == null) {\n            String pageUri =\n                UriBuilder.fromUri(baseUri).path(PageVersionResource.class)\n                    .build(wikiName, spaceName, pageName, version).toString();\n            Link pageLink = objectFactory.createLink();\n            pageLink.setHref(pageUri);\n            pageLink.setRel(Relations.PAGE);\n            historySummary.getLinks().add(pageLink);\n        } else {\n            String pageUri =\n                UriBuilder.fromUri(baseUri).path(PageTranslationVersionResource.class)\n                    .build(wikiName, spaceName, pageName, language, version).toString();\n            Link pageLink = objectFactory.createLink();\n            pageLink.setHref(pageUri);\n            pageLink.setRel(Relations.PAGE);\n            historySummary.getLinks().add(pageLink);\n        }\n\n        return historySummary;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static void fillObjectSummary(ObjectSummary objectSummary, ObjectFactory objectFactory, URI baseUri,\n        Document doc, BaseObject xwikiObject, XWiki xwikiApi) throws XWikiException\n    {\n        objectSummary.setId(String.format(\"%s:%s\", doc.getPrefixedFullName(), xwikiObject.getGuid()));\n        objectSummary.setGuid(xwikiObject.getGuid());\n        objectSummary.setPageId(doc.getPrefixedFullName());\n        objectSummary.setPageVersion(doc.getVersion());\n        objectSummary.setPageAuthor(doc.getAuthor());\n        objectSummary.setPageAuthorName(xwikiApi.getUserName(doc.getAuthor(), false));\n        objectSummary.setWiki(doc.getWiki());\n        objectSummary.setSpace(doc.getSpace());\n        objectSummary.setPageName(doc.getName());\n        objectSummary.setClassName(xwikiObject.getClassName());\n        objectSummary.setNumber(xwikiObject.getNumber());\n\n        String[] propertyNames = xwikiObject.getPropertyNames();\n        if (propertyNames.length > 0) {\n            objectSummary.setHeadline(xwikiObject.get(propertyNames[0]).toFormString());\n        }\n\n    }","id":79373,"modified_method":"private static void fillObjectSummary(ObjectSummary objectSummary, ObjectFactory objectFactory, URI baseUri,\n        Document doc, BaseObject xwikiObject, XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        \n        \n        objectSummary.setId(String.format(\"%s:%s\", doc.getPrefixedFullName(), xwikiObject.getGuid()));\n        objectSummary.setGuid(xwikiObject.getGuid());\n        objectSummary.setPageId(doc.getPrefixedFullName());\n        objectSummary.setPageVersion(doc.getVersion());\n        objectSummary.setPageAuthor(doc.getAuthor());       \n        if (withPrettyNames)\n            objectSummary.setPageAuthorName(xwikiApi.getUserName(doc.getAuthor(), false));\n        objectSummary.setWiki(doc.getWiki());\n        objectSummary.setSpace(doc.getSpace());\n        objectSummary.setPageName(doc.getName());\n        objectSummary.setClassName(xwikiObject.getClassName());\n        objectSummary.setNumber(xwikiObject.getNumber());\n\n        String[] propertyNames = xwikiObject.getPropertyNames();\n        if (propertyNames.length > 0) {\n            objectSummary.setHeadline(xwikiObject.get(propertyNames[0]).toFormString());\n        }\n\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static void fillAttachment(Attachment attachment, ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi)\n    {\n        Document doc = xwikiAttachment.getDocument();\n\n        attachment.setId(String.format(\"%s@%s\", doc.getPrefixedFullName(), xwikiAttachment.getFilename()));\n        attachment.setName(xwikiAttachment.getFilename());\n        attachment.setSize(xwikiAttachment.getFilesize());\n        attachment.setVersion(xwikiAttachment.getVersion());\n        attachment.setPageId(doc.getPrefixedFullName());\n        attachment.setPageVersion(doc.getVersion());\n        attachment.setMimeType(xwikiAttachment.getMimeType());\n        attachment.setAuthor(xwikiAttachment.getAuthor());\n        attachment.setAuthorName(xwikiApi.getUserName(xwikiAttachment.getAuthor(), false));\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(xwikiAttachment.getDate());\n        attachment.setDate(calendar);\n\n        attachment.setXwikiRelativeUrl(xwikiRelativeUrl);\n        attachment.setXwikiAbsoluteUrl(xwikiAbsoluteUrl);\n\n        String pageUri =\n            UriBuilder.fromUri(baseUri).path(PageResource.class).build(doc.getWiki(), doc.getSpace(), doc.getName())\n                .toString();\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        attachment.getLinks().add(pageLink);\n    }","id":79374,"modified_method":"private static void fillAttachment(Attachment attachment, ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        Document doc = xwikiAttachment.getDocument();\n\n        attachment.setId(String.format(\"%s@%s\", doc.getPrefixedFullName(), xwikiAttachment.getFilename()));\n        attachment.setName(xwikiAttachment.getFilename());\n        attachment.setSize(xwikiAttachment.getFilesize());\n        attachment.setVersion(xwikiAttachment.getVersion());\n        attachment.setPageId(doc.getPrefixedFullName());\n        attachment.setPageVersion(doc.getVersion());\n        attachment.setMimeType(xwikiAttachment.getMimeType());\n        attachment.setAuthor(xwikiAttachment.getAuthor());\n        if (withPrettyNames)\n            attachment.setAuthorName(xwikiApi.getUserName(xwikiAttachment.getAuthor(), false));\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(xwikiAttachment.getDate());\n        attachment.setDate(calendar);\n\n        attachment.setXwikiRelativeUrl(xwikiRelativeUrl);\n        attachment.setXwikiAbsoluteUrl(xwikiAbsoluteUrl);\n\n        String pageUri =\n            UriBuilder.fromUri(baseUri).path(PageResource.class).build(doc.getWiki(), doc.getSpace(), doc.getName())\n                .toString();\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        attachment.getLinks().add(pageLink);\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Page createPage(ObjectFactory objectFactory, URI baseUri, URI self, Document doc, boolean useVersion,\n        XWiki xwikiApi) throws XWikiException\n    {\n        Page page = objectFactory.createPage();\n        fillPageSummary(page, objectFactory, baseUri, doc, useVersion, xwikiApi);\n\n        page.setVersion(doc.getVersion());\n        page.setMajorVersion(doc.getRCSVersion().at(0));\n        page.setMinorVersion(doc.getRCSVersion().at(1));\n        page.setLanguage(doc.getLanguage());\n        page.setCreator(doc.getCreator());\n        page.setCreatorName(xwikiApi.getUserName(doc.getCreator(), false));\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(doc.getCreationDate());\n        page.setCreated(calendar);\n\n        page.setModifier(doc.getContentAuthor());\n\n        calendar = Calendar.getInstance();\n        calendar.setTime(doc.getContentUpdateDate());\n        page.setModified(calendar);\n\n        page.setContent(doc.getContent());\n\n        if (self != null) {\n            Link pageLink = objectFactory.createLink();\n            pageLink.setHref(self.toString());\n            pageLink.setRel(Relations.SELF);\n            page.getLinks().add(pageLink);\n        }\n\n        com.xpn.xwiki.api.Class xwikiClass = doc.getxWikiClass();\n        if (xwikiClass != null) {\n            String classUri =\n                UriBuilder.fromUri(baseUri).path(ClassResource.class).build(doc.getWiki(), xwikiClass.getName())\n                    .toString();\n            Link classLink = objectFactory.createLink();\n            classLink.setHref(classUri);\n            classLink.setRel(Relations.CLASS);\n            page.getLinks().add(classLink);\n        }\n\n        return page;\n    }","id":79375,"modified_method":"public static Page createPage(ObjectFactory objectFactory, URI baseUri, URI self, Document doc, boolean useVersion,\n        XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        Page page = objectFactory.createPage();\n        fillPageSummary(page, objectFactory, baseUri, doc, useVersion, xwikiApi, withPrettyNames);\n\n        page.setVersion(doc.getVersion());\n        page.setMajorVersion(doc.getRCSVersion().at(0));\n        page.setMinorVersion(doc.getRCSVersion().at(1));\n        page.setLanguage(doc.getLanguage());\n        page.setCreator(doc.getCreator());\n        if (withPrettyNames)\n            page.setCreatorName(xwikiApi.getUserName(doc.getCreator(), false));\n\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(doc.getCreationDate());\n        page.setCreated(calendar);\n\n        page.setModifier(doc.getContentAuthor());\n        if (withPrettyNames)\n            page.setModifierName(xwikiApi.getUserName(doc.getContentAuthor(), false));\n            \n\n        calendar = Calendar.getInstance();\n        calendar.setTime(doc.getContentUpdateDate());\n        page.setModified(calendar);\n\n        page.setContent(doc.getContent());\n\n        if (self != null) {\n            Link pageLink = objectFactory.createLink();\n            pageLink.setHref(self.toString());\n            pageLink.setRel(Relations.SELF);\n            page.getLinks().add(pageLink);\n        }\n\n        com.xpn.xwiki.api.Class xwikiClass = doc.getxWikiClass();\n        if (xwikiClass != null) {\n            String classUri =\n                UriBuilder.fromUri(baseUri).path(ClassResource.class).build(doc.getWiki(), xwikiClass.getName())\n                    .toString();\n            Link classLink = objectFactory.createLink();\n            classLink.setHref(classUri);\n            classLink.setRel(Relations.CLASS);\n            page.getLinks().add(classLink);\n        }\n\n        return page;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static void fillPageSummary(PageSummary pageSummary, ObjectFactory objectFactory, URI baseUri,\n        Document doc, boolean useVersion, XWiki xwikiApi) throws XWikiException\n    {\n        pageSummary.setWiki(doc.getWiki());\n        pageSummary.setFullName(doc.getFullName());\n        pageSummary.setId(doc.getPrefixedFullName());\n        pageSummary.setSpace(doc.getSpace());\n        pageSummary.setName(doc.getName());\n        pageSummary.setTitle(doc.getDisplayTitle());\n        pageSummary.setXwikiRelativeUrl(doc.getURL(\"view\"));\n        pageSummary.setXwikiAbsoluteUrl(doc.getExternalURL(\"view\"));\n        pageSummary.setTranslations(createTranslations(objectFactory, baseUri, doc));\n        pageSummary.setSyntax(doc.getSyntaxId());\n        pageSummary.setVersion(doc.getVersion());\n        pageSummary.setAuthor(doc.getAuthor());\n        pageSummary.setAuthorName(xwikiApi.getUserName(doc.getAuthor(), false));\n\n        Document parent = Utils.getParentDocument(doc, xwikiApi);\n        pageSummary.setParent(doc.getParent());\n        // parentId must not be set if the parent document does not exist.\n        if (parent != null && !parent.isNew()) {\n            pageSummary.setParentId(parent.getPrefixedFullName());\n        } else {\n            pageSummary.setParentId(\"\");\n        }\n\n        String spaceUri =\n            UriBuilder.fromUri(baseUri).path(SpaceResource.class).build(doc.getWiki(), doc.getSpace()).toString();\n        Link spaceLink = objectFactory.createLink();\n        spaceLink.setHref(spaceUri);\n        spaceLink.setRel(Relations.SPACE);\n        pageSummary.getLinks().add(spaceLink);\n\n        if (parent != null) {\n            String parentUri =\n                UriBuilder.fromUri(baseUri).path(PageResource.class)\n                    .build(parent.getWiki(), parent.getSpace(), parent.getName()).toString();\n            Link parentLink = objectFactory.createLink();\n            parentLink.setHref(parentUri);\n            parentLink.setRel(Relations.PARENT);\n            pageSummary.getLinks().add(parentLink);\n        }\n\n        String historyUri =\n            UriBuilder.fromUri(baseUri).path(PageHistoryResource.class)\n                .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n        Link historyLink = objectFactory.createLink();\n        historyLink.setHref(historyUri);\n        historyLink.setRel(Relations.HISTORY);\n        pageSummary.getLinks().add(historyLink);\n\n        if (!doc.getChildren().isEmpty()) {\n            String pageChildrenUri =\n                UriBuilder.fromUri(baseUri).path(PageChildrenResource.class)\n                    .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            Link pageChildrenLink = objectFactory.createLink();\n            pageChildrenLink.setHref(pageChildrenUri);\n            pageChildrenLink.setRel(Relations.CHILDREN);\n            pageSummary.getLinks().add(pageChildrenLink);\n        }\n\n        if (!doc.getComments().isEmpty()) {\n            String commentsUri;\n            if (useVersion) {\n                commentsUri =\n                    UriBuilder.fromUri(baseUri).path(CommentsVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion()).toString();\n            } else {\n                commentsUri =\n                    UriBuilder.fromUri(baseUri).path(CommentsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            }\n\n            Link commentsLink = objectFactory.createLink();\n            commentsLink.setHref(commentsUri);\n            commentsLink.setRel(Relations.COMMENTS);\n            pageSummary.getLinks().add(commentsLink);\n        }\n\n        if (!doc.getAttachmentList().isEmpty()) {\n            String attachmentsUri;\n            if (useVersion) {\n                attachmentsUri =\n                    UriBuilder.fromUri(baseUri).path(AttachmentsAtPageVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion()).toString();\n            } else {\n                attachmentsUri =\n                    UriBuilder.fromUri(baseUri).path(AttachmentsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            }\n\n            Link attachmentsLink = objectFactory.createLink();\n            attachmentsLink.setHref(attachmentsUri);\n            attachmentsLink.setRel(Relations.ATTACHMENTS);\n            pageSummary.getLinks().add(attachmentsLink);\n        }\n\n        if (!doc.getxWikiObjects().keySet().isEmpty()) {\n            String objectsUri;\n\n            if (useVersion) {\n                objectsUri =\n                    UriBuilder.fromUri(baseUri).path(ObjectsAtPageVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion()).toString();\n            } else {\n                objectsUri =\n                    UriBuilder.fromUri(baseUri).path(ObjectsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            }\n            Link objectsLink = objectFactory.createLink();\n            objectsLink.setHref(objectsUri);\n            objectsLink.setRel(Relations.OBJECTS);\n            pageSummary.getLinks().add(objectsLink);\n        }\n\n        com.xpn.xwiki.api.Object tagsObject = doc.getObject(\"XWiki.TagClass\", 0);\n        if (tagsObject != null) {\n            if (tagsObject.getProperty(\"tags\") != null) {\n                String tagsUri =\n                    UriBuilder.fromUri(baseUri).path(PageTagsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n                Link tagsLink = objectFactory.createLink();\n                tagsLink.setHref(tagsUri);\n                tagsLink.setRel(Relations.TAGS);\n                pageSummary.getLinks().add(tagsLink);\n            }\n        }\n\n        String syntaxesUri = UriBuilder.fromUri(baseUri).path(SyntaxesResource.class).build().toString();\n        Link syntaxesLink = objectFactory.createLink();\n        syntaxesLink.setHref(syntaxesUri);\n        syntaxesLink.setRel(Relations.SYNTAXES);\n        pageSummary.getLinks().add(syntaxesLink);\n    }","id":79376,"modified_method":"private static void fillPageSummary(PageSummary pageSummary, ObjectFactory objectFactory, URI baseUri,\n        Document doc, boolean useVersion, XWiki xwikiApi, Boolean withPrettyNames) throws XWikiException\n    {\n        pageSummary.setWiki(doc.getWiki());\n        pageSummary.setFullName(doc.getFullName());\n        pageSummary.setId(doc.getPrefixedFullName());\n        pageSummary.setSpace(doc.getSpace());\n        pageSummary.setName(doc.getName());\n        pageSummary.setTitle(doc.getDisplayTitle());\n        pageSummary.setXwikiRelativeUrl(doc.getURL(\"view\"));\n        pageSummary.setXwikiAbsoluteUrl(doc.getExternalURL(\"view\"));\n        pageSummary.setTranslations(createTranslations(objectFactory, baseUri, doc));\n        pageSummary.setSyntax(doc.getSyntaxId());\n        pageSummary.setVersion(doc.getVersion());\n        pageSummary.setAuthor(doc.getAuthor());\n        if (withPrettyNames)\n            pageSummary.setAuthorName(xwikiApi.getUserName(doc.getAuthor(), false));\n\n        Document parent = Utils.getParentDocument(doc, xwikiApi);\n        pageSummary.setParent(doc.getParent());\n        // parentId must not be set if the parent document does not exist.\n        if (parent != null && !parent.isNew()) {\n            pageSummary.setParentId(parent.getPrefixedFullName());\n        } else {\n            pageSummary.setParentId(\"\");\n        }\n\n        String spaceUri =\n            UriBuilder.fromUri(baseUri).path(SpaceResource.class).build(doc.getWiki(), doc.getSpace()).toString();\n        Link spaceLink = objectFactory.createLink();\n        spaceLink.setHref(spaceUri);\n        spaceLink.setRel(Relations.SPACE);\n        pageSummary.getLinks().add(spaceLink);\n\n        if (parent != null) {\n            String parentUri =\n                UriBuilder.fromUri(baseUri).path(PageResource.class)\n                    .build(parent.getWiki(), parent.getSpace(), parent.getName()).toString();\n            Link parentLink = objectFactory.createLink();\n            parentLink.setHref(parentUri);\n            parentLink.setRel(Relations.PARENT);\n            pageSummary.getLinks().add(parentLink);\n        }\n\n        String historyUri =\n            UriBuilder.fromUri(baseUri).path(PageHistoryResource.class)\n                .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n        Link historyLink = objectFactory.createLink();\n        historyLink.setHref(historyUri);\n        historyLink.setRel(Relations.HISTORY);\n        pageSummary.getLinks().add(historyLink);\n\n        if (!doc.getChildren().isEmpty()) {\n            String pageChildrenUri =\n                UriBuilder.fromUri(baseUri).path(PageChildrenResource.class)\n                    .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            Link pageChildrenLink = objectFactory.createLink();\n            pageChildrenLink.setHref(pageChildrenUri);\n            pageChildrenLink.setRel(Relations.CHILDREN);\n            pageSummary.getLinks().add(pageChildrenLink);\n        }\n\n        if (!doc.getComments().isEmpty()) {\n            String commentsUri;\n            if (useVersion) {\n                commentsUri =\n                    UriBuilder.fromUri(baseUri).path(CommentsVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion()).toString();\n            } else {\n                commentsUri =\n                    UriBuilder.fromUri(baseUri).path(CommentsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            }\n\n            Link commentsLink = objectFactory.createLink();\n            commentsLink.setHref(commentsUri);\n            commentsLink.setRel(Relations.COMMENTS);\n            pageSummary.getLinks().add(commentsLink);\n        }\n\n        if (!doc.getAttachmentList().isEmpty()) {\n            String attachmentsUri;\n            if (useVersion) {\n                attachmentsUri =\n                    UriBuilder.fromUri(baseUri).path(AttachmentsAtPageVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion()).toString();\n            } else {\n                attachmentsUri =\n                    UriBuilder.fromUri(baseUri).path(AttachmentsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            }\n\n            Link attachmentsLink = objectFactory.createLink();\n            attachmentsLink.setHref(attachmentsUri);\n            attachmentsLink.setRel(Relations.ATTACHMENTS);\n            pageSummary.getLinks().add(attachmentsLink);\n        }\n\n        if (!doc.getxWikiObjects().keySet().isEmpty()) {\n            String objectsUri;\n\n            if (useVersion) {\n                objectsUri =\n                    UriBuilder.fromUri(baseUri).path(ObjectsAtPageVersionResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName(), doc.getVersion()).toString();\n            } else {\n                objectsUri =\n                    UriBuilder.fromUri(baseUri).path(ObjectsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n            }\n            Link objectsLink = objectFactory.createLink();\n            objectsLink.setHref(objectsUri);\n            objectsLink.setRel(Relations.OBJECTS);\n            pageSummary.getLinks().add(objectsLink);\n        }\n\n        com.xpn.xwiki.api.Object tagsObject = doc.getObject(\"XWiki.TagClass\", 0);\n        if (tagsObject != null) {\n            if (tagsObject.getProperty(\"tags\") != null) {\n                String tagsUri =\n                    UriBuilder.fromUri(baseUri).path(PageTagsResource.class)\n                        .build(doc.getWiki(), doc.getSpace(), doc.getName()).toString();\n                Link tagsLink = objectFactory.createLink();\n                tagsLink.setHref(tagsUri);\n                tagsLink.setRel(Relations.TAGS);\n                pageSummary.getLinks().add(tagsLink);\n            }\n        }\n\n        String syntaxesUri = UriBuilder.fromUri(baseUri).path(SyntaxesResource.class).build().toString();\n        Link syntaxesLink = objectFactory.createLink();\n        syntaxesLink.setHref(syntaxesUri);\n        syntaxesLink.setRel(Relations.SYNTAXES);\n        pageSummary.getLinks().add(syntaxesLink);\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Attachment createAttachment(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi)\n    {\n        Attachment attachment = objectFactory.createAttachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl, xwikiApi);\n\n        String attachmentUri = createAttachmentUri(baseUri, xwikiAttachment, xwikiAttachment.getDocument(), false);\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","id":79377,"modified_method":"public static Attachment createAttachment(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        Attachment attachment = objectFactory.createAttachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl, xwikiApi, withPrettyNames);\n\n        String attachmentUri = createAttachmentUri(baseUri, xwikiAttachment, xwikiAttachment.getDocument(), false);\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Attachment createAttachmentAtVersion(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi)\n    {\n        Attachment attachment = new Attachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl, xwikiApi);\n\n        Document doc = xwikiAttachment.getDocument();\n\n        String attachmentUri = createAttachmentUri(baseUri, xwikiAttachment, doc, true);\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","id":79378,"modified_method":"public static Attachment createAttachmentAtVersion(ObjectFactory objectFactory, URI baseUri,\n        com.xpn.xwiki.api.Attachment xwikiAttachment, String xwikiRelativeUrl, String xwikiAbsoluteUrl, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        Attachment attachment = new Attachment();\n\n        fillAttachment(attachment, objectFactory, baseUri, xwikiAttachment, xwikiRelativeUrl, xwikiAbsoluteUrl, xwikiApi, withPrettyNames);\n\n        Document doc = xwikiAttachment.getDocument();\n\n        String attachmentUri = createAttachmentUri(baseUri, xwikiAttachment, doc, true);\n\n        Link attachmentLink = objectFactory.createLink();\n        attachmentLink.setHref(attachmentUri);\n        attachmentLink.setRel(Relations.ATTACHMENT_DATA);\n        attachment.getLinks().add(attachmentLink);\n\n        return attachment;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Wiki createWiki(ObjectFactory objectFactory, URI baseUri, String wikiName)\n    {\n        Wiki wiki = objectFactory.createWiki().withId(wikiName).withName(wikiName);\n\n        String spacesUri = UriBuilder.fromUri(baseUri).path(SpacesResource.class).build(wikiName).toString();\n        Link spacesLink = objectFactory.createLink();\n        spacesLink.setHref(spacesUri);\n        spacesLink.setRel(Relations.SPACES);\n        wiki.getLinks().add(spacesLink);\n\n        String classesUri = UriBuilder.fromUri(baseUri).path(ClassesResource.class).build(wikiName).toString();\n        Link classesLink = objectFactory.createLink();\n        classesLink.setHref(classesUri);\n        classesLink.setRel(Relations.CLASSES);\n        wiki.getLinks().add(classesLink);\n\n        String modificationsUri =\n            UriBuilder.fromUri(baseUri).path(ModificationsResource.class).build(wikiName).toString();\n        Link modificationsLink = objectFactory.createLink();\n        modificationsLink.setHref(modificationsUri);\n        modificationsLink.setRel(Relations.MODIFICATIONS);\n        wiki.getLinks().add(modificationsLink);\n\n        String searchUri = UriBuilder.fromUri(baseUri).path(WikiSearchResource.class).build(wikiName).toString();\n        Link searchLink = objectFactory.createLink();\n        searchLink.setHref(searchUri);\n        searchLink.setRel(Relations.SEARCH);\n        wiki.getLinks().add(searchLink);\n\n        return wiki;\n    }","id":79379,"modified_method":"public static Wiki createWiki(ObjectFactory objectFactory, URI baseUri, String wikiName)\n    {\n        Wiki wiki = objectFactory.createWiki().withId(wikiName).withName(wikiName);\n\n        String spacesUri = UriBuilder.fromUri(baseUri).path(SpacesResource.class).build(wikiName).toString();\n        Link spacesLink = objectFactory.createLink();\n        spacesLink.setHref(spacesUri);\n        spacesLink.setRel(Relations.SPACES);\n        wiki.getLinks().add(spacesLink);\n\n        String classesUri = UriBuilder.fromUri(baseUri).path(ClassesResource.class).build(wikiName).toString();\n        Link classesLink = objectFactory.createLink();\n        classesLink.setHref(classesUri);\n        classesLink.setRel(Relations.CLASSES);\n        wiki.getLinks().add(classesLink);\n\n        String modificationsUri =\n            UriBuilder.fromUri(baseUri).path(ModificationsResource.class).build(wikiName).toString();\n        Link modificationsLink = objectFactory.createLink();\n        modificationsLink.setHref(modificationsUri);\n        modificationsLink.setRel(Relations.MODIFICATIONS);\n        wiki.getLinks().add(modificationsLink);\n\n        String searchUri = UriBuilder.fromUri(baseUri).path(WikiSearchResource.class).build(wikiName).toString();\n        Link searchLink = objectFactory.createLink();\n        searchLink.setHref(searchUri);\n        searchLink.setRel(Relations.SEARCH);\n        wiki.getLinks().add(searchLink);\n\n        String queryUri = UriBuilder.fromUri(baseUri).path(WikiSearchQueryResource.class).build(wikiName).toString();\n        Link queryLink = objectFactory.createLink();\n        queryLink.setHref(queryUri);\n        queryLink.setRel(Relations.QUERY);\n        wiki.getLinks().add(queryLink);\n\n        return wiki;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Comment createComment(ObjectFactory objectFactory, URI baseUri, Document doc,\n        com.xpn.xwiki.api.Object xwikiComment, XWiki xwikiApi)\n    {\n        Comment comment = objectFactory.createComment();\n        comment.setId(xwikiComment.getNumber());\n\n        com.xpn.xwiki.api.Property property = xwikiComment.getProperty(\"author\");\n        if (property != null) {\n            comment.setAuthor((String) property.getValue());\n            comment.setAuthorName(xwikiApi.getUserName((String) property.getValue(), false));\n        }\n\n        property = xwikiComment.getProperty(\"date\");\n        if (property != null) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.setTime((Date) property.getValue());\n            comment.setDate(calendar);\n        }\n\n        property = xwikiComment.getProperty(\"highlight\");\n        if (property != null) {\n            comment.setHighlight((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"comment\");\n        if (property != null) {\n            comment.setText((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"replyto\");\n        if (property != null) {\n            comment.setReplyTo((Integer) property.getValue());\n        }\n\n        String pageUri =\n            UriBuilder.fromUri(baseUri).path(PageResource.class).build(doc.getWiki(), doc.getSpace(), doc.getName())\n                .toString();\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        comment.getLinks().add(pageLink);\n\n        return comment;\n    }","id":79380,"modified_method":"public static Comment createComment(ObjectFactory objectFactory, URI baseUri, Document doc,\n        com.xpn.xwiki.api.Object xwikiComment, XWiki xwikiApi, Boolean withPrettyNames)\n    {\n        Comment comment = objectFactory.createComment();\n        comment.setId(xwikiComment.getNumber());\n\n        com.xpn.xwiki.api.Property property = xwikiComment.getProperty(\"author\");\n        if (property != null) {\n            comment.setAuthor((String) property.getValue());\n            if (withPrettyNames)\n                comment.setAuthorName(xwikiApi.getUserName((String) property.getValue(), false));\n        }\n\n        property = xwikiComment.getProperty(\"date\");\n        if (property != null) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.setTime((Date) property.getValue());\n            comment.setDate(calendar);\n        }\n\n        property = xwikiComment.getProperty(\"highlight\");\n        if (property != null) {\n            comment.setHighlight((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"comment\");\n        if (property != null) {\n            comment.setText((String) property.getValue());\n        }\n\n        property = xwikiComment.getProperty(\"replyto\");\n        if (property != null) {\n            comment.setReplyTo((Integer) property.getValue());\n        }\n\n        String pageUri =\n            UriBuilder.fromUri(baseUri).path(PageResource.class).build(doc.getWiki(), doc.getSpace(), doc.getName())\n                .toString();\n        Link pageLink = objectFactory.createLink();\n        pageLink.setHref(pageUri);\n        pageLink.setRel(Relations.PAGE);\n        comment.getLinks().add(pageLink);\n\n        return comment;\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Response putPage(DocumentInfo documentInfo, Page page) throws XWikiException\n    {\n        Document doc = documentInfo.getDocument();\n\n        boolean save = false;\n\n        if (page.getContent() != null) {\n            doc.setContent(page.getContent());\n            save = true;\n        }\n\n        if (page.getTitle() != null) {\n            doc.setTitle(page.getTitle());\n            save = true;\n        }\n\n        if (page.getParent() != null) {\n            doc.setParent(page.getParent());\n            save = true;\n        }\n\n        if (page.getSyntax() != null) {\n            if (Utils.getXWiki(componentManager).getConfiguredSyntaxes().contains(page.getSyntax())) {\n                doc.setSyntaxId(page.getSyntax());\n                save = true;\n            }\n        }\n\n        if (save) {\n            doc.save();\n\n            page =\n                DomainObjectFactory.createPage(objectFactory, uriInfo.getBaseUri(), uriInfo.getAbsolutePath(), doc,\n                    false, Utils.getXWikiApi(componentManager));\n\n            if (documentInfo.isCreated()) {\n                return Response.created(uriInfo.getAbsolutePath()).entity(page).build();\n            } else {\n                return Response.status(Status.ACCEPTED).entity(page).build();\n            }\n        } else {\n            return Response.status(Status.NOT_MODIFIED).build();\n        }\n    }","id":79381,"modified_method":"public Response putPage(DocumentInfo documentInfo, Page page) throws XWikiException\n    {\n        Document doc = documentInfo.getDocument();\n\n        boolean save = false;\n\n        if (page.getContent() != null) {\n            doc.setContent(page.getContent());\n            save = true;\n        }\n\n        if (page.getTitle() != null) {\n            doc.setTitle(page.getTitle());\n            save = true;\n        }\n\n        if (page.getParent() != null) {\n            doc.setParent(page.getParent());\n            save = true;\n        }\n\n        if (page.getSyntax() != null) {\n            if (Utils.getXWiki(componentManager).getConfiguredSyntaxes().contains(page.getSyntax())) {\n                doc.setSyntaxId(page.getSyntax());\n                save = true;\n            }\n        }\n\n        if (save) {\n            doc.save();\n\n            page =\n                DomainObjectFactory.createPage(objectFactory, uriInfo.getBaseUri(), uriInfo.getAbsolutePath(), doc,\n                    false, Utils.getXWikiApi(componentManager), false);\n\n            if (documentInfo.isCreated()) {\n                return Response.created(uriInfo.getAbsolutePath()).entity(page).build();\n            } else {\n                return Response.status(Status.ACCEPTED).entity(page).build();\n            }\n        } else {\n            return Response.status(Status.NOT_MODIFIED).build();\n        }\n    }","commit_id":"bd49bcc84e1dec3d20b57e970c293a459524d2e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void processEquation(SNode var, SNode type, EquationInfo info) {\n    SNode parent = type;\n    SNode child = var;\n    SNode source = myState.getNodeMaps().getNode(child);\n    myState.executeOperation(new EquationAddedOperation(child, parent, source, info));\n  }","id":79382,"modified_method":"private void processEquation(SNode var, SNode type, EquationInfo info) {\n    SNode source = myState.getNodeMaps().getNode(var);\n    myState.executeOperation(new EquationAddedOperation(var, type, source, info));\n  }","commit_id":"f5b59ae3cb6614110d68f1cf18a5ee269270dd06","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEquation(SNode left, SNode right, EquationInfo info) {\n    SNode lRepresentative = getRepresentative(left);\n    SNode rRepresentative = getRepresentative(right);\n    if (lRepresentative == null || rRepresentative == null || lRepresentative.equals(rRepresentative)) {\n      return;\n    }\n    if (TypesUtil.isVariable(lRepresentative) || TypesUtil.isVariable(rRepresentative)) {\n      processEquation(lRepresentative, rRepresentative, info);\n      return;\n    }\n    if (!compareTypes(lRepresentative, rRepresentative, info)) {\n      myState.getNodeMaps().reportEquationBroken(info, lRepresentative, rRepresentative);\n    }\n  }","id":79383,"modified_method":"public void addEquation(SNode left, SNode right, EquationInfo info) {\n    SNode lRepresentative = getRepresentative(left);\n    SNode rRepresentative = getRepresentative(right);\n    if (lRepresentative == null || rRepresentative == null || lRepresentative.equals(rRepresentative)) {\n      return;\n    }\n    if (TypesUtil.isVariable(lRepresentative)) {\n      processEquation(lRepresentative, rRepresentative, info);\n      return;\n    }\n    if (TypesUtil.isVariable(rRepresentative)) {\n      processEquation(rRepresentative, lRepresentative, info);\n      return;\n    }\n    if (!compareTypes(lRepresentative, rRepresentative, info)) {\n      myState.getNodeMaps().reportEquationBroken(info, lRepresentative, rRepresentative);\n    }\n  }","commit_id":"f5b59ae3cb6614110d68f1cf18a5ee269270dd06","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void expandAll() {\n    for (SNode node : myNodesToTypes.keySet()) {\n      SNode var = myNodesToTypes.get(node);\n      SNode type = myState.getEquations().expandNode(var);\n      updateNodeToType(node, type, null);\n    }\n  }","id":79384,"modified_method":"public void expandAll() {\n    for (SNode node : new HashSet<SNode>(myNodesToTypes.keySet())) {\n      SNode var = myNodesToTypes.get(node);\n      SNode type = myState.getEquations().expandNode(var);\n      updateNodeToType(node, type, null);\n    }\n  }","commit_id":"f5b59ae3cb6614110d68f1cf18a5ee269270dd06","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void doUndo(State state) {\n    state.getNodeMaps().assignNodeType(myNode, myOldType);\n  }","id":79385,"modified_method":"@Override\n  public void doUndo(State state) {\n    state.getNodeMaps().assignNodeTypeDontChangeSource(myNode, myOldType);\n  }","commit_id":"f5b59ae3cb6614110d68f1cf18a5ee269270dd06","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean iteration(List<RelationBlock> inequalities) {\n    initializeMaps(inequalities);\n    if (myNodes.size() == 0) {\n      return false;\n    }\n    for (Block block : myState.getBlocks(BlockKind.WHEN_CONCRETE)) {\n      SNode node = myState.getRepresentative(((WhenConcreteBlock) block).getArgument());\n      if (myNodes.contains(node) && myInputsToOutputs.getBySecond(node).isEmpty()) {\n        if (solveRelationsForNode(node)) {\n          return true;\n        }\n      }\n    }\n    List<SNode> sortedNodes = sort(myInputsToOutputs, myNodes);\n    for (SNode node: sortedNodes) {\n      if (solveRelationsForNode(node)) {\n       return true;\n      }\n    }\n    //last chance\n    for (RelationBlock inequality : inequalities) {\n     // if (inequality.processReplacementRules()) {\n        myState.executeOperation(new RemoveBlockOperation(inequality));\n        return true;\n     // }\n    }\n    return false;\n  }","id":79386,"modified_method":"private boolean iteration(List<RelationBlock> inequalities) {\n    initializeMaps(inequalities);\n    if (myNodes.size() == 0) {\n      return false;\n    }\n    for (Block block : myState.getBlocks(BlockKind.WHEN_CONCRETE)) {\n      SNode node = myState.getRepresentative(((WhenConcreteBlock) block).getArgument());\n      if (myNodes.contains(node) && myInputsToOutputs.getBySecond(node).isEmpty()) {\n        if (solveRelationsForNode(node)) {\n          return true;\n        }\n      }\n    }\n    while (myNodes.size() > 0) {\n      SNode current = getNodeWithNoInput(myInputsToOutputs, myNodes);\n      if (solveRelationsForNode(current)) {\n       return true;\n      }\n      myNodes.remove(current);\n      myInputsToOutputs.clearFirst(current);\n    }\n    //last chance\n    for (RelationBlock inequality : inequalities) {\n      myState.executeOperation(new RemoveBlockOperation(inequality));\n      return true;\n    }\n    return false;\n  }","commit_id":"f33abb9c8288bb0b315c1ba3a45fd1454cdd0654","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SNode getNodeWithNoInput(ManyToManyMap<SNode, SNode> inputsToOutputs, Set<SNode> unsorted) {\n    for (SNode node : unsorted) {\n      if (inputsToOutputs.getBySecond(node).isEmpty()) {\n        return node;\n      }\n    }\n    /*\n    System.out.println(\"cycle\");\n    for (SNode node: unsorted) {\n      System.out.println(node);\n    }\n    */\n    return unsorted.iterator().next();\n  }","id":79387,"modified_method":"private SNode getNodeWithNoInput(ManyToManyMap<SNode, SNode> inputsToOutputs, Set<SNode> unsorted) {\n    for (SNode node : unsorted) {\n      if (inputsToOutputs.getBySecond(node).isEmpty()) {\n        return node;\n      }\n    }\n\n    System.out.println(\"cycle\");\n    for (SNode node: unsorted) {\n      System.out.println(node);\n    }\n    printAll();\n\n    return unsorted.iterator().next();\n  }","commit_id":"f33abb9c8288bb0b315c1ba3a45fd1454cdd0654","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addVariablesLink(SNode input, SNode output) {\n    if (TypesUtil.isVariable(input) && TypesUtil.isVariable(output)) {\n      myInputsToOutputs.addLink(input, output);\n    }\n  }","id":79388,"modified_method":"private void addVariablesLink(SNode input, SNode output) {\n    if (!TypesUtil.isVariable(input)) return;\n    if (!TypesUtil.isVariable(output)) return;\n    if (input == output) return;\n    if (input.getName().equals(output.getName())) {\n      System.out.println(\"Variable \" + input.getName());\n    }\n    myInputsToOutputs.addLink(input, output);\n  }","commit_id":"f33abb9c8288bb0b315c1ba3a45fd1454cdd0654","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void upgradeBusinessMetadataDatasetSpec() {\n    DatasetSpecification oldBusinessMetadataSpec =\n      datasetInstanceManager.get(DefaultMetadataStore.BUSINESS_METADATA_INSTANCE_ID);\n    if (oldBusinessMetadataSpec == null) {\n      LOG.info(\"Business Metadata Dataset not found. No upgrade necessary.\");\n      return;\n    }\n    // Updating the type in the spec using Gson. Doing choosing this option over two others:\n    // 1. Build a new DatasetSpecification using the DatasetSpecification Builder: This seems clean, but because\n    // of the namespacing logic in the builder, you would need to change names of the embedded datasets first,\n    // leading to unnecessary complex logic for this temporary code.\n    // 2. Add a DatasetSpecification.changeType: This is probably the cleanest option, however, we would have to\n    // add a new public static method to an API class, again for this temporary use-case. Maybe we can do this\n    // later if we see this as a more frequent pattern.\n    // For now, update the type using Gson, and deserialize the updated JsonObject as a new DatasetSpecification.\n    Gson gson = new Gson();\n    JsonObject jsonObject = gson.toJsonTree(oldBusinessMetadataSpec, DatasetSpecification.class).getAsJsonObject();\n    jsonObject.addProperty(\"type\", MetadataDataset.class.getName());\n    DatasetSpecification newBusinessMetadataSpec = gson.fromJson(jsonObject, DatasetSpecification.class);\n    datasetInstanceManager.delete(DefaultMetadataStore.BUSINESS_METADATA_INSTANCE_ID);\n    datasetInstanceManager.add(Id.Namespace.SYSTEM, newBusinessMetadataSpec);\n    LOG.info(\"Found old Business Metadata Dataset Spec {}. Upgraded it to new spec {}.\",\n             oldBusinessMetadataSpec, newBusinessMetadataSpec);\n  }","id":79389,"modified_method":"private void upgradeBusinessMetadataDatasetSpec() {\n    DatasetSpecification oldBusinessMetadataSpec =\n      datasetInstanceManager.get(DefaultMetadataStore.BUSINESS_METADATA_INSTANCE_ID);\n    if (oldBusinessMetadataSpec == null) {\n      LOG.info(\"Business Metadata Dataset not found. No upgrade necessary.\");\n      return;\n    }\n    // Updating the type in the spec using Gson. Doing choosing this option over two others:\n    // 1. Build a new DatasetSpecification using the DatasetSpecification Builder: This seems clean, but because\n    // of the namespacing logic in the builder, you would need to change names of the embedded datasets first,\n    // leading to unnecessary complex logic for this temporary code.\n    // 2. Add a DatasetSpecification.changeType: This is probably the cleanest option, however, we would have to\n    // add a new public static method to an API class, again for this temporary use-case. Maybe we can do this\n    // later if we see this as a more frequent pattern.\n    // For now, update the type using Gson, and deserialize the updated JsonObject as a new DatasetSpecification.\n    Gson gson = new Gson();\n    // change the dataset type name since in 3.3  it changed to MetadataDataset\n    JsonObject jsonObject = gson.toJsonTree(oldBusinessMetadataSpec, DatasetSpecification.class).getAsJsonObject();\n    jsonObject.addProperty(\"type\", MetadataDataset.class.getName());\n    // change the columnsToIndex to 'i' since in 3.3 we index column 'i'\n    JsonObject metadataIndexObject = jsonObject.get(\"datasetSpecs\").getAsJsonObject()\n      .get(\"metadata_index\").getAsJsonObject();\n    JsonObject properties = metadataIndexObject.get(\"properties\").getAsJsonObject();\n    properties.addProperty(\"columnsToIndex\", \"i\");\n    JsonObject dProperties = metadataIndexObject.get(\"datasetSpecs\").getAsJsonObject().get(\"d\").getAsJsonObject()\n      .get(\"properties\").getAsJsonObject();\n    JsonObject iProperties = metadataIndexObject.get(\"datasetSpecs\").getAsJsonObject().get(\"i\").getAsJsonObject()\n      .get(\"properties\").getAsJsonObject();\n    dProperties.addProperty(\"columnsToIndex\", \"i\");\n    iProperties.addProperty(\"columnsToIndex\", \"i\");\n\n    LOG.info(\"The new Business Metadata Dataset Spec being written is {}\", new Gson().toJson(jsonObject));\n    DatasetSpecification newBusinessMetadataSpec = gson.fromJson(jsonObject, DatasetSpecification.class);\n    datasetInstanceManager.delete(DefaultMetadataStore.BUSINESS_METADATA_INSTANCE_ID);\n    datasetInstanceManager.add(Id.Namespace.SYSTEM, newBusinessMetadataSpec);\n    LOG.info(\"Found old Business Metadata Dataset Spec {}. Upgraded it to new spec {}.\",\n             oldBusinessMetadataSpec, newBusinessMetadataSpec);\n  }","commit_id":"86fc120face5f4bf28093214a98c261f014427b1","url":"https://github.com/caskdata/cdap"},{"original_method":"private void performUpgrade() throws Exception {\n    performCoprocessorUpgrade();\n\n    LOG.info(\"Upgrading schedules...\");\n    datasetBasedTimeScheduleStore.upgrade();\n\n    LOG.info(\"Upgrading Business Metadata Dataset...\");\n    upgradeBusinessMetadataDatasetSpec();\n\n    LOG.info(\"Upgrading stream state store table ...\");\n    streamStateStoreUpgrader.upgrade();\n  }","id":79390,"modified_method":"private void performUpgrade() throws Exception {\n    performCoprocessorUpgrade();\n\n    LOG.info(\"Upgrading schedules...\");\n    datasetBasedTimeScheduleStore.upgrade();\n\n    LOG.info(\"Upgrading Business Metadata Dataset Specification...\");\n    upgradeBusinessMetadataDatasetSpec();\n\n    LOG.info(\"Upgrading Business Metadata Dataset...\");\n    metadataStore.upgrade();\n\n    LOG.info(\"Upgrading stream state store table ...\");\n    streamStateStoreUpgrader.upgrade();\n  }","commit_id":"86fc120face5f4bf28093214a98c261f014427b1","url":"https://github.com/caskdata/cdap"},{"original_method":"public UpgradeTool() throws Exception {\n    this.cConf = CConfiguration.create();\n    this.hConf = HBaseConfiguration.create();\n    this.injector = init();\n    this.txService = injector.getInstance(TransactionService.class);\n    this.zkClientService = injector.getInstance(ZKClientService.class);\n    this.dsFramework = injector.getInstance(DatasetFramework.class);\n    this.mdsDatasetsRegistry = injector.getInstance(Key.get(MDSDatasetsRegistry.class,\n                                                            Names.named(\"mdsDatasetsRegistry\")));\n    this.datasetBasedTimeScheduleStore = injector.getInstance(DatasetBasedTimeScheduleStore.class);\n    this.streamStateStoreUpgrader = injector.getInstance(StreamStateStoreUpgrader.class);\n    this.dsUpgrade = injector.getInstance(DatasetUpgrader.class);\n    this.dsSpecUpgrader = injector.getInstance(DatasetSpecificationUpgrader.class);\n    this.queueAdmin = injector.getInstance(QueueAdmin.class);\n    this.datasetInstanceManager =\n      injector.getInstance(Key.get(DatasetInstanceManager.class, Names.named(\"datasetInstanceManager\")));\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        try {\n          UpgradeTool.this.stop();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to upgrade\", e);\n        }\n      }\n    });\n  }","id":79391,"modified_method":"public UpgradeTool() throws Exception {\n    this.cConf = CConfiguration.create();\n    this.hConf = HBaseConfiguration.create();\n    this.injector = init();\n    this.txService = injector.getInstance(TransactionService.class);\n    this.zkClientService = injector.getInstance(ZKClientService.class);\n    this.dsFramework = injector.getInstance(DatasetFramework.class);\n    this.mdsDatasetsRegistry = injector.getInstance(Key.get(MDSDatasetsRegistry.class,\n                                                            Names.named(\"mdsDatasetsRegistry\")));\n    this.datasetBasedTimeScheduleStore = injector.getInstance(DatasetBasedTimeScheduleStore.class);\n    this.metadataStore = injector.getInstance(MetadataStore.class);\n    this.streamStateStoreUpgrader = injector.getInstance(StreamStateStoreUpgrader.class);\n    this.dsUpgrade = injector.getInstance(DatasetUpgrader.class);\n    this.dsSpecUpgrader = injector.getInstance(DatasetSpecificationUpgrader.class);\n    this.queueAdmin = injector.getInstance(QueueAdmin.class);\n    this.datasetInstanceManager =\n      injector.getInstance(Key.get(DatasetInstanceManager.class, Names.named(\"datasetInstanceManager\")));\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        try {\n          UpgradeTool.this.stop();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to upgrade\", e);\n        }\n      }\n    });\n  }","commit_id":"86fc120face5f4bf28093214a98c261f014427b1","url":"https://github.com/caskdata/cdap"},{"original_method":"private Injector init() throws Exception {\n    return Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new LocationRuntimeModule().getDistributedModules(),\n      new ZKClientModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      Modules.override(new DataSetsModules().getDistributedModules()).with(\n        new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(DatasetFramework.class).to(InMemoryDatasetFramework.class).in(Scopes.SINGLETON);\n            install(new FactoryModuleBuilder()\n                      .implement(DatasetDefinitionRegistry.class, DefaultDatasetDefinitionRegistry.class)\n                      .build(DatasetDefinitionRegistryFactory.class));\n            // Upgrade tool does not need to record lineage for now.\n            bind(LineageWriter.class).to(NoOpLineageWriter.class);\n            // No need to do anything with Metadata store for now.\n            bind(MetadataStore.class).to(NoOpMetadataStore.class);\n          }\n        }\n      ),\n      new ViewAdminModules().getDistributedModules(),\n      new StreamAdminModules().getDistributedModules(),\n      new NotificationFeedClientModule(),\n      new TwillModule(),\n      new ExploreClientModule(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new ServiceStoreModules().getDistributedModules(),\n      new SystemDatasetRuntimeModule().getDistributedModules(),\n      // don't need real notifications for upgrade, so use the in-memory implementations\n      new NotificationServiceRuntimeModule().getInMemoryModules(),\n      new KafkaClientModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          install(new DataFabricDistributedModule());\n          // the DataFabricDistributedModule needs MetricsCollectionService binding and since Upgrade tool does not do\n          // anything with Metrics we just bind it to NoOpMetricsCollectionService\n          bind(MetricsCollectionService.class).to(NoOpMetricsCollectionService.class).in(Scopes.SINGLETON);\n          bind(MetricDatasetFactory.class).to(DefaultMetricDatasetFactory.class).in(Scopes.SINGLETON);\n          bind(MetricStore.class).to(DefaultMetricStore.class);\n        }\n\n        @Provides\n        @Singleton\n        @Named(\"mdsDatasetsRegistry\")\n        @SuppressWarnings(\"unused\")\n        public MDSDatasetsRegistry getMDSDatasetsRegistry(TransactionSystemClientService txClient,\n                                                          @Named(\"datasetMDS\") DatasetFramework framework) {\n          return new MDSDatasetsRegistry(txClient, framework);\n        }\n\n        @Provides\n        @Singleton\n        @Named(\"datasetInstanceManager\")\n        @SuppressWarnings(\"unused\")\n        public DatasetInstanceManager getDatasetInstanceManager(@Named(\"mdsDatasetsRegistry\")\n                                                                MDSDatasetsRegistry mdsDatasetsRegistry) {\n          return new DatasetInstanceManager(mdsDatasetsRegistry);\n        }\n\n        // This is needed because the LocalApplicationManager\n        // expects a dsframework injection named datasetMDS\n        @Provides\n        @Singleton\n        @Named(\"datasetMDS\")\n        @SuppressWarnings(\"unused\")\n        public DatasetFramework getInDsFramework(DatasetFramework dsFramework) {\n          return dsFramework;\n        }\n\n      });\n  }","id":79392,"modified_method":"private Injector init() throws Exception {\n    return Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new LocationRuntimeModule().getDistributedModules(),\n      new ZKClientModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      Modules.override(new DataSetsModules().getDistributedModules()).with(\n        new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(DatasetFramework.class).to(InMemoryDatasetFramework.class).in(Scopes.SINGLETON);\n            // the DataSetsModules().getDistributedModules() binds to RemoteDatasetFramework so override that to\n            // InMemoryDatasetFramework\n            bind(DatasetFramework.class)\n              .annotatedWith(Names.named(DataSetsModules.BASIC_DATASET_FRAMEWORK))\n              .to(InMemoryDatasetFramework.class);\n            install(new FactoryModuleBuilder()\n                      .implement(DatasetDefinitionRegistry.class, DefaultDatasetDefinitionRegistry.class)\n                      .build(DatasetDefinitionRegistryFactory.class));\n            // Upgrade tool does not need to record lineage for now.\n            bind(LineageWriter.class).to(NoOpLineageWriter.class);\n          }\n        }\n      ),\n      new ViewAdminModules().getDistributedModules(),\n      new StreamAdminModules().getDistributedModules(),\n      new NotificationFeedClientModule(),\n      new TwillModule(),\n      new ExploreClientModule(),\n      new AppFabricServiceRuntimeModule().getDistributedModules(),\n      new ProgramRunnerRuntimeModule().getDistributedModules(),\n      new ServiceStoreModules().getDistributedModules(),\n      new SystemDatasetRuntimeModule().getDistributedModules(),\n      // don't need real notifications for upgrade, so use the in-memory implementations\n      new NotificationServiceRuntimeModule().getInMemoryModules(),\n      new KafkaClientModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          install(new DataFabricDistributedModule());\n          // the DataFabricDistributedModule needs MetricsCollectionService binding and since Upgrade tool does not do\n          // anything with Metrics we just bind it to NoOpMetricsCollectionService\n          bind(MetricsCollectionService.class).to(NoOpMetricsCollectionService.class).in(Scopes.SINGLETON);\n          bind(MetricDatasetFactory.class).to(DefaultMetricDatasetFactory.class).in(Scopes.SINGLETON);\n          bind(MetricStore.class).to(DefaultMetricStore.class);\n        }\n\n        @Provides\n        @Singleton\n        @Named(\"mdsDatasetsRegistry\")\n        @SuppressWarnings(\"unused\")\n        public MDSDatasetsRegistry getMDSDatasetsRegistry(TransactionSystemClientService txClient,\n                                                          @Named(\"datasetMDS\") DatasetFramework framework) {\n          return new MDSDatasetsRegistry(txClient, framework);\n        }\n\n        @Provides\n        @Singleton\n        @Named(\"datasetInstanceManager\")\n        @SuppressWarnings(\"unused\")\n        public DatasetInstanceManager getDatasetInstanceManager(@Named(\"mdsDatasetsRegistry\")\n                                                                MDSDatasetsRegistry mdsDatasetsRegistry) {\n          return new DatasetInstanceManager(mdsDatasetsRegistry);\n        }\n\n        // This is needed because the LocalApplicationManager\n        // expects a dsframework injection named datasetMDS\n        @Provides\n        @Singleton\n        @Named(\"datasetMDS\")\n        @SuppressWarnings(\"unused\")\n        public DatasetFramework getInDsFramework(DatasetFramework dsFramework) {\n          return dsFramework;\n        }\n\n      });\n  }","commit_id":"86fc120face5f4bf28093214a98c261f014427b1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Sets up a {@link DatasetFramework} instance for standalone usage.  NOTE: should NOT be used by applications!!!\n   */\n  private void initializeDSFramework(CConfiguration cConf,\n                                     DatasetFramework datasetFramework,\n                                     boolean includeNewDatasets) throws IOException, DatasetManagementException {\n    // dataset service\n    DatasetMetaTableUtil.setupDatasets(datasetFramework);\n    if (includeNewDatasets) {\n      // artifact and metadata datasets were added in 3.2\n      ArtifactStore.setupDatasets(datasetFramework);\n      DefaultMetadataStore.setupDatasets(datasetFramework);\n      LineageStore.setupDatasets(datasetFramework);\n    }\n    // app metadata\n    DefaultStore.setupDatasets(datasetFramework);\n    // config store\n    DefaultConfigStore.setupDatasets(datasetFramework);\n    // logs metadata\n    LogSaverTableUtil.setupDatasets(datasetFramework);\n    // scheduler metadata\n    ScheduleStoreTableUtil.setupDatasets(datasetFramework);\n\n    // metrics data\n    DefaultMetricDatasetFactory factory = new DefaultMetricDatasetFactory(cConf, datasetFramework);\n    DefaultMetricDatasetFactory.setupDatasets(factory);\n\n    // Usage registry\n    UsageRegistry.setupDatasets(datasetFramework);\n  }","id":79393,"modified_method":"/**\n   * Sets up a {@link DatasetFramework} instance for standalone usage.  NOTE: should NOT be used by applications!!!\n   */\n  private void initializeDSFramework(CConfiguration cConf,\n                                     DatasetFramework datasetFramework,\n                                     boolean includeNewDatasets) throws IOException, DatasetManagementException {\n    // dataset service\n    DatasetMetaTableUtil.setupDatasets(datasetFramework);\n    // artifacts\n    ArtifactStore.setupDatasets(datasetFramework);\n    // metadata and lineage\n    DefaultMetadataStore.setupDatasets(datasetFramework);\n    LineageStore.setupDatasets(datasetFramework);\n    // app metadata\n    DefaultStore.setupDatasets(datasetFramework);\n    // config store\n    DefaultConfigStore.setupDatasets(datasetFramework);\n    // logs metadata\n    LogSaverTableUtil.setupDatasets(datasetFramework);\n    // scheduler metadata\n    ScheduleStoreTableUtil.setupDatasets(datasetFramework);\n\n    // metrics data\n    DefaultMetricDatasetFactory factory = new DefaultMetricDatasetFactory(cConf, datasetFramework);\n    DefaultMetricDatasetFactory.setupDatasets(factory);\n\n    // Usage registry\n    UsageRegistry.setupDatasets(datasetFramework);\n  }","commit_id":"86fc120face5f4bf28093214a98c261f014427b1","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized int removeEntries(String wordHash, String[] urlHashes, boolean deleteComplete) {\r\n        int removed = ramCache.removeEntries(wordHash, urlHashes, deleteComplete);\r\n        if (removed == urlHashes.length) return removed;\r\n        plasmaWordIndexEntryContainer container = assortmentCluster.removeFromAll(wordHash, -1);\r\n        if (container != null) {\r\n            removed += container.removeEntries(wordHash, urlHashes, deleteComplete);\r\n            if (container.size() != 0) this.addEntries(container, System.currentTimeMillis(), false);\r\n        }\r\n        if (removed == urlHashes.length) return removed;\r\n        removed += backend.removeEntries(wordHash, urlHashes, deleteComplete);\r\n        return removed;\r\n    }","id":79394,"modified_method":"public int removeEntries(String wordHash, String[] urlHashes, boolean deleteComplete) {\r\n        int removed;\r\n        boolean addedEntryToRamCache = false;\r\n        synchronized (this) {\r\n            removed = ramCache.removeEntries(wordHash, urlHashes, deleteComplete);\r\n            if (removed == urlHashes.length) return removed;\r\n            plasmaWordIndexEntryContainer container = assortmentCluster.removeFromAll(wordHash, -1);\r\n            if (container != null) {\r\n                removed += container.removeEntries(wordHash, urlHashes, deleteComplete);\r\n                if (container.size() != 0) {\r\n                    ramCache.addEntries(container, System.currentTimeMillis(), false);\r\n                    addedEntryToRamCache = true;\r\n                }\r\n            }\r\n            if (removed != urlHashes.length) {\r\n                removed += backend.removeEntries(wordHash, urlHashes, deleteComplete);\r\n            }\r\n        }\r\n        if (addedEntryToRamCache) flushControl();\r\n        return removed;\r\n    }","commit_id":"cbcf7418efcd2240d66086686dd32e69af5ef47b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized void flushCacheSome() {\r\n        ramCache.shiftK2W();\r\n        int flushCount = ramCache.wSize() / 500;\r\n        if (flushCount > 70) flushCount = 70;\r\n        if (flushCount < 5) flushCount = 5;\r\n        flushCache(flushCount);\r\n    }","id":79395,"modified_method":"public void flushCacheSome() {\r\n        synchronized (this) { ramCache.shiftK2W(); }\r\n        int flushCount = ramCache.wSize() / 500;\r\n        if (flushCount > 70) flushCount = 70;\r\n        if (flushCount < 5) flushCount = 5;\r\n        flushCache(flushCount);\r\n    }","commit_id":"cbcf7418efcd2240d66086686dd32e69af5ef47b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized void flushCache(int count) {\r\n        for (int i = 0; i < count; i++) {\r\n            if (ramCache.wSize() == 0) break;\r\n            flushCache(ramCache.bestFlushWordHash());\r\n            try {Thread.sleep(10);} catch (InterruptedException e) {}\r\n        }\r\n    }","id":79396,"modified_method":"public void flushCache(int count) {\r\n        for (int i = 0; i < count; i++) {\r\n            if (ramCache.wSize() == 0) break;\r\n            synchronized (this) { flushCache(ramCache.bestFlushWordHash()); }\r\n            try {Thread.sleep(10);} catch (InterruptedException e) {}\r\n        }\r\n    }","commit_id":"cbcf7418efcd2240d66086686dd32e69af5ef47b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized int addPageIndex(URL url, String urlHash, Date urlModified, int size, plasmaParserDocument document, plasmaCondenser condenser, String language, char doctype, int outlinksSame, int outlinksOther) {\r\n        // this is called by the switchboard to put in a new page into the index\r\n        // use all the words in one condenser object to simultanous create index entries\r\n        \r\n        // iterate over all words\r\n        Iterator i = condenser.words();\r\n        Map.Entry wentry;\r\n        String word;\r\n        plasmaWordIndexEntry ientry;\r\n        plasmaCondenser.wordStatProp wprop;\r\n        String wordHash;\r\n        int urlLength = url.toString().length();\r\n        int urlComps = htmlFilterContentScraper.urlComps(url.toString()).length;\r\n        \r\n        while (i.hasNext()) {\r\n            wentry = (Map.Entry) i.next();\r\n            word = (String) wentry.getKey();\r\n            wprop = (plasmaCondenser.wordStatProp) wentry.getValue();\r\n            // if ((s.length() > 4) && (c > 1)) System.out.println(\"# \" + s + \":\" + c);\r\n            wordHash = plasmaWordIndexEntry.word2hash(word);\r\n            ientry = new plasmaWordIndexEntry(urlHash,\r\n                                              urlLength, urlComps, (document == null) ? urlLength : document.longTitle.length(),\r\n                                             wprop.count,\r\n                                             condenser.RESULT_SIMI_WORDS,\r\n                                             condenser.RESULT_SIMI_SENTENCES,\r\n                                             wprop.posInText,\r\n                                             wprop.posInPhrase,\r\n                                             wprop.numOfPhrase,\r\n                                             0,\r\n                                             size,\r\n                                             urlModified.getTime(),\r\n                                             System.currentTimeMillis(),\r\n                                             condenser.RESULT_WORD_ENTROPHY,\r\n                                             language,\r\n                                             doctype,\r\n                                             outlinksSame, outlinksOther,\r\n                                             true);\r\n            addEntry(wordHash, ientry, System.currentTimeMillis(), false);\r\n        }\r\n        // System.out.println(\"DEBUG: plasmaSearch.addPageIndex: added \" +\r\n        // condenser.getWords().size() + \" words, flushed \" + c + \" entries\");\r\n        return condenser.RESULT_SIMI_WORDS;\r\n    }","id":79397,"modified_method":"public int addPageIndex(URL url, String urlHash, Date urlModified, int size, plasmaParserDocument document, plasmaCondenser condenser, String language, char doctype, int outlinksSame, int outlinksOther) {\r\n        // this is called by the switchboard to put in a new page into the index\r\n        // use all the words in one condenser object to simultanous create index entries\r\n        \r\n        // iterate over all words\r\n        Iterator i = condenser.words();\r\n        Map.Entry wentry;\r\n        String word;\r\n        plasmaWordIndexEntry ientry;\r\n        plasmaCondenser.wordStatProp wprop;\r\n        String wordHash;\r\n        int urlLength = url.toString().length();\r\n        int urlComps = htmlFilterContentScraper.urlComps(url.toString()).length;\r\n        \r\n        while (i.hasNext()) {\r\n            wentry = (Map.Entry) i.next();\r\n            word = (String) wentry.getKey();\r\n            wprop = (plasmaCondenser.wordStatProp) wentry.getValue();\r\n            // if ((s.length() > 4) && (c > 1)) System.out.println(\"# \" + s + \":\" + c);\r\n            wordHash = plasmaWordIndexEntry.word2hash(word);\r\n            ientry = new plasmaWordIndexEntry(urlHash,\r\n                                              urlLength, urlComps, (document == null) ? urlLength : document.longTitle.length(),\r\n                                             wprop.count,\r\n                                             condenser.RESULT_SIMI_WORDS,\r\n                                             condenser.RESULT_SIMI_SENTENCES,\r\n                                             wprop.posInText,\r\n                                             wprop.posInPhrase,\r\n                                             wprop.numOfPhrase,\r\n                                             0,\r\n                                             size,\r\n                                             urlModified.getTime(),\r\n                                             System.currentTimeMillis(),\r\n                                             condenser.RESULT_WORD_ENTROPHY,\r\n                                             language,\r\n                                             doctype,\r\n                                             outlinksSame, outlinksOther,\r\n                                             true);\r\n            addEntry(wordHash, ientry, System.currentTimeMillis(), false);\r\n        }\r\n        // System.out.println(\"DEBUG: plasmaSearch.addPageIndex: added \" +\r\n        // condenser.getWords().size() + \" words, flushed \" + c + \" entries\");\r\n        return condenser.RESULT_SIMI_WORDS;\r\n    }","commit_id":"cbcf7418efcd2240d66086686dd32e69af5ef47b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized int tryRemoveURLs(String urlHash) {\r\n        // this tries to delete an index from the cache that has this\r\n        // urlHash assigned. This can only work if the entry is really fresh\r\n        // and can be found in the RAM cache\r\n        // this returns the number of deletion that had been possible\r\n        return ramCache.tryRemoveURLs(urlHash);\r\n    }","id":79398,"modified_method":"public int tryRemoveURLs(String urlHash) {\r\n        // this tries to delete an index from the cache that has this\r\n        // urlHash assigned. This can only work if the entry is really fresh\r\n        // and can be found in the RAM cache\r\n        // this returns the number of deletion that had been possible\r\n        return ramCache.tryRemoveURLs(urlHash);\r\n    }","commit_id":"cbcf7418efcd2240d66086686dd32e69af5ef47b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void flushControl() {\r\n        // check for forced flush\r\n        ramCache.shiftK2W();\r\n        while (ramCache.maxURLinWCache() > plasmaWordIndexCache.wCacheReferenceLimit) {\r\n            flushCache(1);\r\n        }\r\n        if (ramCache.wSize() > ramCache.getMaxWordCount()) {\r\n            while (ramCache.wSize() + 500 > ramCache.getMaxWordCount()) {\r\n                flushCache(1);\r\n            }\r\n        }\r\n    }","id":79399,"modified_method":"public void flushControl() {\r\n        // check for forced flush\r\n        synchronized (this) { ramCache.shiftK2W(); }\r\n        while (ramCache.maxURLinWCache() > plasmaWordIndexCache.wCacheReferenceLimit) {\r\n            flushCache(1);\r\n        }\r\n        if (ramCache.wSize() > ramCache.getMaxWordCount()) {\r\n            while (ramCache.wSize() + 500 > ramCache.getMaxWordCount()) {\r\n                flushCache(1);\r\n            }\r\n        }\r\n    }","commit_id":"cbcf7418efcd2240d66086686dd32e69af5ef47b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void close(int waitingBoundSeconds) {\r\n        synchronized (ramCache) {\r\n            ramCache.close(waitingBoundSeconds);\r\n            if (useCollectionIndex) collections.close(-1);\r\n            assortmentCluster.close(-1);\r\n            backend.close(10);\r\n        }\r\n    }","id":79400,"modified_method":"public void close(int waitingBoundSeconds) {\r\n        synchronized (this) {\r\n            ramCache.close(waitingBoundSeconds);\r\n            if (useCollectionIndex) collections.close(-1);\r\n            assortmentCluster.close(-1);\r\n            backend.close(10);\r\n        }\r\n    }","commit_id":"8f3f4ab0eb39cb00ab918455f32d4f16a38cccb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void flushCache(int count) {\r\n        if (count <= 0) return;\r\n        synchronized (ramCache) {\r\n            busyCacheFlush = true;\r\n            String wordHash;\r\n            System.out.println(\"DEBUG-Started flush of \" + count + \" entries from RAM to DB\");\r\n            long start = System.currentTimeMillis();\r\n            for (int i = 0; i < count; i++) { // possible position of outOfMemoryError ?\r\n                if (ramCache.wSize() == 0) break;\r\n                wordHash = ramCache.bestFlushWordHash();\r\n                \r\n                // flush the wordHash\r\n                indexContainer c = ramCache.deleteContainer(wordHash);\r\n                if (c != null) {\r\n                    if (useCollectionIndex) {\r\n                        indexContainer feedback = collections.addEntries(c, c.updated(), false);\r\n                        if (feedback != null) {\r\n                            throw new RuntimeException(\"indexCollectionRI shall not return feedback entries; feedback = \" + feedback.toString());\r\n                        }\r\n                    } else {\r\n                        indexContainer feedback = assortmentCluster.addEntries(c, c.updated(), false);\r\n                        if (feedback != null) {\r\n                            backend.addEntries(feedback, System.currentTimeMillis(), true);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // pause to next loop to give other processes a chance to use IO\r\n                try {Thread.sleep(8);} catch (InterruptedException e) {}\r\n            }\r\n            System.out.println(\"DEBUG-Finished flush of \" + count + \" entries from RAM to DB in \" + (System.currentTimeMillis() - start) + \" milliseconds\");\r\n            busyCacheFlush = false;\r\n        }\r\n    }","id":79401,"modified_method":"public void flushCache(int count) {\r\n        if (count <= 0) return;\r\n        busyCacheFlush = true;\r\n        String wordHash;\r\n        System.out.println(\"DEBUG-Started flush of \" + count + \" entries from RAM to DB\");\r\n        long start = System.currentTimeMillis();\r\n        for (int i = 0; i < count; i++) { // possible position of outOfMemoryError ?\r\n            if (ramCache.wSize() == 0) break;\r\n            synchronized (this) {\r\n                wordHash = ramCache.bestFlushWordHash();\r\n                \r\n                // flush the wordHash\r\n                indexContainer c = ramCache.deleteContainer(wordHash);\r\n                if (c != null) {\r\n                    if (useCollectionIndex) {\r\n                        indexContainer feedback = collections.addEntries(c, c.updated(), false);\r\n                        if (feedback != null) {\r\n                            throw new RuntimeException(\"indexCollectionRI shall not return feedback entries; feedback = \" + feedback.toString());\r\n                        }\r\n                    } else {\r\n                        indexContainer feedback = assortmentCluster.addEntries(c, c.updated(), false);\r\n                        if (feedback != null) {\r\n                            backend.addEntries(feedback, System.currentTimeMillis(), true);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // pause to next loop to give other processes a chance to use IO\r\n                try {this.wait(8);} catch (InterruptedException e) {}\r\n            }\r\n        }\r\n        System.out.println(\"DEBUG-Finished flush of \" + count + \" entries from RAM to DB in \" + (System.currentTimeMillis() - start) + \" milliseconds\");\r\n        busyCacheFlush = false;\r\n    }","commit_id":"8f3f4ab0eb39cb00ab918455f32d4f16a38cccb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void flushControl() {\r\n        // check for forced flush\r\n        synchronized (ramCache) {\r\n            ramCache.shiftK2W();\r\n            flushCache(ramCache.maxURLinWCache() - ramCache.wCacheReferenceLimit);\r\n            if (ramCache.wSize() > ramCache.getMaxWordCount()) {\r\n                flushCache(ramCache.wSize() + 500 - ramCache.getMaxWordCount());\r\n            }\r\n        }\r\n    }","id":79402,"modified_method":"public void flushControl() {\r\n        // check for forced flush\r\n        synchronized (this) { ramCache.shiftK2W(); }\r\n        flushCache(ramCache.maxURLinWCache() - ramCache.wCacheReferenceLimit);\r\n        if (ramCache.wSize() > ramCache.getMaxWordCount()) {\r\n            flushCache(ramCache.wSize() + 500 - ramCache.getMaxWordCount());\r\n        }\r\n    }","commit_id":"8f3f4ab0eb39cb00ab918455f32d4f16a38cccb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void flushCacheSome() {\r\n        synchronized (ramCache) { ramCache.shiftK2W(); }\r\n        int flushCount = ramCache.wSize() / 420;\r\n        if (flushCount > 100) flushCount = 100;\r\n        if (flushCount < 10) flushCount = Math.min(10, ramCache.wSize());\r\n        flushCache(flushCount);\r\n    }","id":79403,"modified_method":"public void flushCacheSome() {\r\n        synchronized (this) { ramCache.shiftK2W(); }\r\n        int flushCount = ramCache.wSize() / 420;\r\n        if (flushCount > 100) flushCount = 100;\r\n        if (flushCount < 10) flushCount = Math.min(10, ramCache.wSize());\r\n        flushCache(flushCount);\r\n    }","commit_id":"8f3f4ab0eb39cb00ab918455f32d4f16a38cccb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n   * {@inheritDoc}\n   */\n  @Nullable\n  protected GitLineHandler createHandler(final Project project, final List<VirtualFile> gitRoots, final VirtualFile defaultRoot) {\n    final GithubRebaseDialog dialog = new GithubRebaseDialog(project, gitRoots, defaultRoot);\n    dialog.configure(myParent);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return null;\n    }\n    return dialog.handler();\n  }","id":79404,"modified_method":"/**\n   * {@inheritDoc}\n   */\n  @Nullable\n  protected GitLineHandler createHandler(final Project project, final List<VirtualFile> gitRoots, final VirtualFile defaultRoot) {\n    final GithubRebaseDialog dialog = new GithubRebaseDialog(project, gitRoots, defaultRoot);\n    dialog.configure(myOriginName);\n    dialog.show();\n    if (!dialog.isOK()) {\n      return null;\n    }\n    return dialog.handler();\n  }","commit_id":"52952457778c0e4169c6b7d91a95abf2751da45f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setRebaseOrigin(final String parent) {\n    myParent = parent;\n  }","id":79405,"modified_method":"public void setRebaseOrigin(final String originName) {\n    myOriginName = originName;\n  }","commit_id":"52952457778c0e4169c6b7d91a95abf2751da45f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (!GithubUtil.checkCredentials(project)){\n      Messages.showErrorDialog(project, \"Cannot login with GitHub credentials. Please configure them in File | Settings | GitHub\", CANNOT_PERFORM_GITHUB_REBASE);\n      return;\n    }\n\n    final VirtualFile root = project.getBaseDir();\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (!gitDetected) {\n      Messages.showErrorDialog(project, \"Cannot find any git repository configured for the project\", CANNOT_PERFORM_GITHUB_REBASE);\n      return;\n    }\n\n    try {\n      // Check that given repository is properly configured git repository\n      final GitRemote githubRemote = GithubUtil.accessToGithubWithModalProgress(project, new Computable<GitRemote>(){\n        @Override\n        public GitRemote compute() {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Reading branches information\");\n          return GithubUtil.getGithubBoundRepository(project);\n        }\n      });\n      final List<GitRemote> gitRemotes = GitRemote.list(project, root);\n      LOG.assertTrue(githubRemote != null);\n\n      final String pushUrl = githubRemote.pushUrl();\n      final String login = GithubSettings.getInstance().getLogin();\n      final int index = pushUrl.lastIndexOf(login);\n      if (index == -1) {\n        Messages.showErrorDialog(project, \"Github remote repository doesn't seem to be your own repository: \" + pushUrl,\n                                 CANNOT_PERFORM_GITHUB_REBASE);\n        return;\n      }\n      String repoName = pushUrl.substring(index + login.length() + 1);\n      if (repoName.endsWith(\".git\")) {\n        repoName = repoName.substring(0, repoName.length() - 4);\n      }\n\n      final RepositoryInfo repositoryInfo = GithubUtil.getDetailedRepositoryInfo(project, login, repoName);\n      if (repositoryInfo == null) {\n        Messages\n          .showErrorDialog(project, \"Github repository doesn't seem to be your own repository: \" + pushUrl, CANNOT_PERFORM_GITHUB_REBASE);\n        return;\n      }\n\n      if (!repositoryInfo.isFork()) {\n        Messages.showErrorDialog(project, \"Github repository '\" + repoName + \"' is not a forked one\", CANNOT_PERFORM_GITHUB_REBASE);\n        return;\n      }\n\n      final String parent = repositoryInfo.getParent();\n      LOG.assertTrue(parent != null, \"Parent repository not found!\");\n      final String parentRepoSuffix = parent + \".git\";\n      final String parentRepoUrl = \"git://github.com/\" + parentRepoSuffix;\n\n      // Check that corresponding remote branch is configured for the fork origin repo\n      boolean remoteForParentSeen = false;\n      for (GitRemote gitRemote : gitRemotes) {\n        final String fetchUrl = gitRemote.fetchUrl();\n        if (fetchUrl.endsWith(parent + \".git\")) {\n          remoteForParentSeen = true;\n          break;\n        }\n      }\n      if (!remoteForParentSeen){\n        final int result = Messages.showYesNoDialog(project, \"It is necessary to have '\" +\n                                                             parentRepoUrl +\n                                                             \"' as a configured remote. Add remote?\", \"Github Rebase\",\n                                                    Messages.getQuestionIcon());\n        if (result != Messages.OK){\n          return;\n        }\n\n        GithubUtil.accessToGithubWithModalProgress(project, new Runnable() {\n          public void run() {\n            try {\n              LOG.info(\"Adding GitHub parent as a remote host\");\n              ProgressManager.getInstance().getProgressIndicator().setText(\"Adding GitHub parent as a remote host\");\n              final GitSimpleHandler addRemoteHandler = new GitSimpleHandler(project, root, GitCommand.REMOTE);\n              addRemoteHandler.setNoSSH(true);\n              addRemoteHandler.setSilent(true);\n              final String remoteName = parent.substring(0, parent.lastIndexOf('/'));\n              addRemoteHandler.addParameters(\"add\", remoteName, parentRepoUrl);\n              addRemoteHandler.run();\n              if (addRemoteHandler.getExitCode() != 0) {\n                showErrorMessageInEDT(project, \"Failed to add GitHub remote: '\" + parentRepoUrl + \"'\");\n                return;\n              }\n\n              LOG.info(\"Updating remotes\");\n              ProgressManager.getInstance().getProgressIndicator().setText(\"Updating remotes\");\n              final GitSimpleHandler updateRemotesHandler = new GitSimpleHandler(project, root, GitCommand.REMOTE);\n              updateRemotesHandler.setNoSSH(true);\n              updateRemotesHandler.setSilent(true);\n              updateRemotesHandler.addParameters(\"update\");\n              updateRemotesHandler.run();\n              if (updateRemotesHandler.getExitCode() != 0) {\n                showErrorMessageInEDT(project, \"Failed to update remotes\");\n                return;\n              }\n            }\n            catch (VcsException e1) {\n              final String message = \"Error happened during git operation: \" + e1.getMessage();\n              showErrorMessageInEDT(project, message);\n              return;\n            }\n          }\n        });\n      }\n\n      BasicAction.saveAll();\n      final GithubRebase action = (GithubRebase) ActionManager.getInstance().getAction(\"Github.Rebase.Internal\");\n      action.setRebaseOrigin(parent);\n      final AnActionEvent actionEvent =\n        new AnActionEvent(e.getInputEvent(), e.getDataContext(), e.getPlace(), e.getPresentation(), e.getActionManager(), e.getModifiers());\n      action.actionPerformed(actionEvent);\n    }\n    catch (VcsException e1) {\n      Messages.showErrorDialog(project, \"Error happened during git operation: \" + e1.getMessage(), CANNOT_PERFORM_GITHUB_REBASE);\n      return;\n    }\n  }","id":79406,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (!GithubUtil.checkCredentials(project)){\n      Messages.showErrorDialog(project, \"Cannot login with GitHub credentials. Please configure them in File | Settings | GitHub\", CANNOT_PERFORM_GITHUB_REBASE);\n      return;\n    }\n\n    final VirtualFile root = project.getBaseDir();\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (!gitDetected) {\n      Messages.showErrorDialog(project, \"Cannot find any git repository configured for the project\", CANNOT_PERFORM_GITHUB_REBASE);\n      return;\n    }\n\n    try {\n      // Check that given repository is properly configured git repository\n      final GitRemote githubRemote = GithubUtil.accessToGithubWithModalProgress(project, new Computable<GitRemote>(){\n        @Override\n        public GitRemote compute() {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Reading branches information\");\n          return GithubUtil.getGithubBoundRepository(project);\n        }\n      });\n      final List<GitRemote> gitRemotes = GitRemote.list(project, root);\n      LOG.assertTrue(githubRemote != null);\n\n      final String pushUrl = githubRemote.pushUrl();\n      final String login = GithubSettings.getInstance().getLogin();\n      final int index = pushUrl.lastIndexOf(login);\n      if (index == -1) {\n        Messages.showErrorDialog(project, \"Github remote repository doesn't seem to be your own repository: \" + pushUrl,\n                                 CANNOT_PERFORM_GITHUB_REBASE);\n        return;\n      }\n      String repoName = pushUrl.substring(index + login.length() + 1);\n      if (repoName.endsWith(\".git\")) {\n        repoName = repoName.substring(0, repoName.length() - 4);\n      }\n\n      final RepositoryInfo repositoryInfo = GithubUtil.getDetailedRepositoryInfo(project, login, repoName);\n      if (repositoryInfo == null) {\n        Messages\n          .showErrorDialog(project, \"Github repository doesn't seem to be your own repository: \" + pushUrl, CANNOT_PERFORM_GITHUB_REBASE);\n        return;\n      }\n\n      if (!repositoryInfo.isFork()) {\n        Messages.showErrorDialog(project, \"Github repository '\" + repoName + \"' is not a forked one\", CANNOT_PERFORM_GITHUB_REBASE);\n        return;\n      }\n\n      final String parent = repositoryInfo.getParent();\n      LOG.assertTrue(parent != null, \"Parent repository not found!\");\n      final String parentRepoSuffix = parent + \".git\";\n      final String parentRepoUrl = \"git://github.com/\" + parentRepoSuffix;\n\n      // Check that corresponding remote branch is configured for the fork origin repo\n      final Ref<String> remoteForForkParentRepo = new Ref<String>();\n      for (GitRemote gitRemote : gitRemotes) {\n        final String fetchUrl = gitRemote.fetchUrl();\n        if (fetchUrl.endsWith(parent + \".git\")) {\n          remoteForForkParentRepo.set(gitRemote.name());\n          break;\n        }\n      }\n      if (remoteForForkParentRepo.isNull()){\n        final int result = Messages.showYesNoDialog(project, \"It is necessary to have '\" +\n                                                             parentRepoUrl +\n                                                             \"' as a configured remote. Add remote?\", \"Github Rebase\",\n                                                    Messages.getQuestionIcon());\n        if (result != Messages.OK){\n          return;\n        }\n\n        GithubUtil.accessToGithubWithModalProgress(project, new Runnable() {\n          public void run() {\n            try {\n              LOG.info(\"Adding GitHub parent as a remote host\");\n              ProgressManager.getInstance().getProgressIndicator().setText(\"Adding GitHub parent as a remote host\");\n              final GitSimpleHandler addRemoteHandler = new GitSimpleHandler(project, root, GitCommand.REMOTE);\n              addRemoteHandler.setNoSSH(true);\n              addRemoteHandler.setSilent(true);\n\n              remoteForForkParentRepo.set(\"upstream\");\n              addRemoteHandler.addParameters(\"add\", remoteForForkParentRepo.get(), parentRepoUrl);\n              addRemoteHandler.run();\n              if (addRemoteHandler.getExitCode() != 0) {\n                showErrorMessageInEDT(project, \"Failed to add GitHub remote: '\" + parentRepoUrl + \"'\");\n                return;\n              }\n\n              LOG.info(\"Updating remotes\");\n              ProgressManager.getInstance().getProgressIndicator().setText(\"Updating remotes\");\n              final GitSimpleHandler updateRemotesHandler = new GitSimpleHandler(project, root, GitCommand.REMOTE);\n              updateRemotesHandler.setNoSSH(true);\n              updateRemotesHandler.setSilent(true);\n              updateRemotesHandler.addParameters(\"update\");\n              updateRemotesHandler.run();\n              if (updateRemotesHandler.getExitCode() != 0) {\n                showErrorMessageInEDT(project, \"Failed to update remotes\");\n                return;\n              }\n            }\n            catch (VcsException e1) {\n              final String message = \"Error happened during git operation: \" + e1.getMessage();\n              showErrorMessageInEDT(project, message);\n              return;\n            }\n          }\n        });\n      }\n\n      BasicAction.saveAll();\n      final GithubRebase action = (GithubRebase) ActionManager.getInstance().getAction(\"Github.Rebase.Internal\");\n      action.setRebaseOrigin(remoteForForkParentRepo.get());\n      final AnActionEvent actionEvent =\n        new AnActionEvent(e.getInputEvent(), e.getDataContext(), e.getPlace(), e.getPresentation(), e.getActionManager(), e.getModifiers());\n      action.actionPerformed(actionEvent);\n    }\n    catch (VcsException e1) {\n      Messages.showErrorDialog(project, \"Error happened during git operation: \" + e1.getMessage(), CANNOT_PERFORM_GITHUB_REBASE);\n      return;\n    }\n  }","commit_id":"52952457778c0e4169c6b7d91a95abf2751da45f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configure(final String parent) {\n    setTitle(\"Rebase GitHub\");\n\n    myShowRemoteBranchesCheckBox.setSelected(true);\n    myShowRemoteBranchesCheckBox.getParent().remove(myShowRemoteBranchesCheckBox);\n    myGitRootComboBox.setEnabled(false);\n    myLocalBranches.clear();\n    final String originName = parent.substring(0, parent.lastIndexOf('/'));\n    final ArrayList<GitBranch> remoteCopy = new ArrayList<GitBranch>();\n    remoteCopy.addAll(myRemoteBranches);\n    myRemoteBranches.clear();\n    final String filter = \"/\" + originName + \"/\";\n    for (GitBranch branch : remoteCopy) {\n      if (branch.getFullName().contains(filter)){\n        myRemoteBranches.add(branch);\n      }\n    }\n    updateOntoFrom();\n\n    // Preselect remote master\n    final String preselected = \"/\" + originName + \"/master\";\n    for (GitBranch remoteBranch : myRemoteBranches) {\n      final String branchFullName = remoteBranch.getFullName();\n      if (branchFullName.endsWith(preselected)){\n        myOntoComboBox.setSelectedItem(remoteBranch);\n        GitUIUtil.getTextField(myOntoComboBox).setText(branchFullName);\n        break;\n      }\n    }\n  }","id":79407,"modified_method":"public void configure(final String originName) {\n    setTitle(\"Rebase GitHub\");\n\n    myShowRemoteBranchesCheckBox.setSelected(true);\n    myShowRemoteBranchesCheckBox.getParent().remove(myShowRemoteBranchesCheckBox);\n    myGitRootComboBox.setEnabled(false);\n    myLocalBranches.clear();\n    final ArrayList<GitBranch> remoteCopy = new ArrayList<GitBranch>();\n    remoteCopy.addAll(myRemoteBranches);\n    myRemoteBranches.clear();\n    final String filter = \"/\" + originName + \"/\";\n    for (GitBranch branch : remoteCopy) {\n      if (branch.getFullName().contains(filter)){\n        myRemoteBranches.add(branch);\n      }\n    }\n    updateOntoFrom();\n\n    // Preselect remote master\n    GitBranch remoteBranch = null;\n    String currentLocalBranchName = null;\n    try {\n      final GitBranch currentBranch = GitBranch.current(myProject, gitRoot());\n      if (currentBranch != null) {\n        currentLocalBranchName = currentBranch.getName();\n      }\n    }\n    catch (VcsException e) {\n      // Do noting;\n    }\n\n    if (currentLocalBranchName != null) {\n      // try to find corresponding remote branch\n      remoteBranch = findBranch(\"/\" + originName + \"/\" + currentLocalBranchName);\n    }\n    if (remoteBranch == null) {\n      //  else use master\n      remoteBranch = findBranch(\"/\" + originName + \"/master\");\n    }\n\n    if (remoteBranch != null) {\n      myOntoComboBox.setSelectedItem(remoteBranch);\n      GitUIUtil.getTextField(myOntoComboBox).setText(remoteBranch.getFullName());\n    }\n  }","commit_id":"52952457778c0e4169c6b7d91a95abf2751da45f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static GitRemote findGitHubRemoteBranch(final Project project, final VirtualFile root) {\n    try {\n      // Check that given repository is properly configured git repository\n      final String host = GithubSettings.getInstance().getHost();\n      final List<GitRemote> gitRemotes = GitRemote.list(project, root);\n      for (GitRemote gitRemote : gitRemotes) {\n        final String pushUrl = gitRemote.pushUrl();\n        if (pushUrl.contains(host)) {\n          return gitRemote;\n        }\n      }\n    } catch (VcsException e){\n      // ignore\n    }\n    return null;\n  }","id":79408,"modified_method":"@Nullable\n  public static GitRemote findGitHubRemoteBranch(final Project project, final VirtualFile root) {\n    // i.e. find origin which points on my github repo\n    try {\n      // Check that given repository is properly configured git repository\n      final GithubSettings githubSettings = GithubSettings.getInstance();\n      final String host = githubSettings.getHost();\n      final String username = githubSettings.getLogin();\n\n      final String userRepoMarkerSSHProtocol = host + \":\" + username + \"/\";\n      final String userRepoMarkerOtherProtocols = host + \"/\" + username + \"/\";\n\n      final List<GitRemote> gitRemotes = GitRemote.list(project, root);\n      for (GitRemote gitRemote : gitRemotes) {\n        final String pushUrl = gitRemote.pushUrl();\n        if (pushUrl.contains(userRepoMarkerSSHProtocol) || pushUrl.contains(userRepoMarkerOtherProtocols)) {\n          return gitRemote;\n        }\n      }\n    } catch (VcsException e){\n      // ignore\n    }\n    return null;\n  }","commit_id":"52952457778c0e4169c6b7d91a95abf2751da45f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SymbolicRefs getRefs() throws VcsException {\n    final SymbolicRefs refs = new SymbolicRefs();\n    loadAllTags(refs.getTags());\n    final List<GitBranch> allBranches = new ArrayList<GitBranch>();\n    final GitBranch current = GitBranch.list(myProject, myRoot, true, true, allBranches, null);\n    for (GitBranch branch : allBranches) {\n      if (branch.isRemote()) {\n        String name = branch.getName();\n        name = name.startsWith(\"remotes/\") ? name.substring(\"remotes/\".length()) : name;\n        refs.addRemote(name);\n      } else {\n        refs.addLocal(branch.getName());\n      }\n    }\n    refs.setCurrent(current);\n    if (current != null) {\n      GitBranch tracked = current.tracked(myProject, myRoot);\n      String fullName = tracked.getFullName();\n      fullName = fullName.startsWith(GitBranch.REFS_REMOTES_PREFIX) ? fullName.substring(GitBranch.REFS_REMOTES_PREFIX.length()) : fullName;\n      refs.setTrackedRemote(fullName);\n    }\n    refs.setUsername(GitConfigUtil.getValue(myProject, myRoot, GitConfigUtil.USER_NAME));\n    // todo\n    /*GitStashUtils.loadStashStack(myProject, myRoot, new Consumer<StashInfo>() {\n      @Override\n      public void consume(StashInfo stashInfo) {\n\n      }\n    });*/\n    return refs;\n  }","id":79409,"modified_method":"public SymbolicRefs getRefs() throws VcsException {\n    final SymbolicRefs refs = new SymbolicRefs();\n    loadAllTags(refs.getTags());\n    final List<GitBranch> allBranches = new ArrayList<GitBranch>();\n    final GitBranch current = GitBranch.list(myProject, myRoot, true, true, allBranches, null);\n    for (GitBranch branch : allBranches) {\n      if (branch.isRemote()) {\n        String name = branch.getName();\n        name = name.startsWith(\"remotes/\") ? name.substring(\"remotes/\".length()) : name;\n        refs.addRemote(name);\n      } else {\n        refs.addLocal(branch.getName());\n      }\n    }\n    refs.setCurrent(current);\n    if (current != null) {\n      GitBranch tracked = current.tracked(myProject, myRoot);\n      String fullName = tracked == null ? null : tracked.getFullName();\n      fullName = fullName != null && fullName.startsWith(GitBranch.REFS_REMOTES_PREFIX) ? fullName.substring(GitBranch.REFS_REMOTES_PREFIX.length()) : fullName;\n      refs.setTrackedRemote(fullName);\n    }\n    refs.setUsername(GitConfigUtil.getValue(myProject, myRoot, GitConfigUtil.USER_NAME));\n    // todo\n    /*GitStashUtils.loadStashStack(myProject, myRoot, new Consumer<StashInfo>() {\n      @Override\n      public void consume(StashInfo stashInfo) {\n\n      }\n    });*/\n    return refs;\n  }","commit_id":"d2656029c5afa360db99426bcd34ecfb186ae525","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getMessage(AuditEvent event) {\n    try {\n      return event.getMessage();\n\n    } catch (Exception e) {\n      // checkstyle can throw a NullPointer if the message is not set\n      return null;\n    }\n  }","id":79410,"modified_method":"static String getMessage(AuditEvent event) {\n    try {\n      return event.getMessage();\n\n    } catch (Exception e) {\n      // checkstyle can throw a NullPointer if the message is not set\n      return null;\n    }\n  }","commit_id":"f2f539eb1725cadcb71c977eb0d199c65c0cbc88","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private String getRuleKey(AuditEvent event) {\n    String key = null;\n    try {\n      key = event.getModuleId();\n    } catch (Exception e) {\n      // checkstyle throws a NullPointer if the message is not set\n    }\n    if (StringUtils.isBlank(key)) {\n      try {\n        key = event.getSourceName();\n      } catch (Exception e) {\n        // checkstyle can throw a NullPointer if the message is not set\n      }\n    }\n    return key;\n  }","id":79411,"modified_method":"static String getRuleKey(AuditEvent event) {\n    String key = null;\n    try {\n      key = event.getModuleId();\n    } catch (Exception e) {\n      // checkstyle throws a NullPointer if the message is not set\n    }\n    if (StringUtils.isBlank(key)) {\n      try {\n        key = event.getSourceName();\n      } catch (Exception e) {\n        // checkstyle can throw a NullPointer if the message is not set\n      }\n    }\n    return key;\n  }","commit_id":"f2f539eb1725cadcb71c977eb0d199c65c0cbc88","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private int getLineId(AuditEvent event) {\n    try {\n      return event.getLine();\n\n    } catch (Exception e) {\n      // checkstyle can throw a NullPointer if the message is not set\n      return 0;\n    }\n  }","id":79412,"modified_method":"static Integer getLineId(AuditEvent event) {\n    try {\n      int line = event.getLine();\n      // checkstyle returns 0 if there is no relation to a file content, but we use null\n      return line == 0 ? null : line;\n\n    } catch (Exception e) {\n      // checkstyle can throw a NullPointerException if the message is not set\n      return null;\n    }\n  }","commit_id":"f2f539eb1725cadcb71c977eb0d199c65c0cbc88","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void doFileEvents( List<AuditEvent> eventList, String filename )\n    {\n        for ( AuditEvent event : eventList )\n        {\n            SeverityLevel level = event.getSeverityLevel();\n\n            if ( ( getSeverityLevel() != null ) && !( getSeverityLevel() != level ) )\n            {\n                continue;\n            }\n\n            sink.tableRow();\n\n            sink.tableCell();\n            iconTool.iconSeverity( level.getName(), IconTool.TEXT_SIMPLE );\n            sink.tableCell_();\n\n            sink.tableCell();\n            String ruleName = getRuleName( event );\n            if ( ruleName != null )\n            {\n                sink.text( ruleName );\n            }\n            sink.tableCell_();\n\n            sink.tableCell();\n            sink.text( event.getMessage() );\n            sink.tableCell_();\n\n            sink.tableCell();\n            if ( getXrefLocation() != null )\n            {\n                sink.link( getXrefLocation() + \"/\" + filename.replaceAll( \"\\\\.java$\", \".html\" ) + \"#L\"\n                    + event.getLine() );\n                sink.text( String.valueOf( event.getLine() ) );\n                sink.link_();\n            }\n            else\n            {\n                sink.text( String.valueOf( event.getLine() ) );\n            }\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n    }","id":79413,"modified_method":"private void doFileEvents( List<AuditEvent> eventList, String filename )\n    {\n        for ( AuditEvent event : eventList )\n        {\n            SeverityLevel level = event.getSeverityLevel();\n\n            if ( ( getSeverityLevel() != null ) && !( getSeverityLevel() != level ) )\n            {\n                continue;\n            }\n\n            sink.tableRow();\n\n            sink.tableCell();\n            iconTool.iconSeverity( level.getName(), IconTool.TEXT_SIMPLE );\n            sink.tableCell_();\n\n            sink.tableCell();\n            String ruleName = getRuleName( event );\n            if ( ruleName != null )\n            {\n                sink.text( ruleName );\n            }\n            sink.tableCell_();\n\n            sink.tableCell();\n            sink.text( event.getMessage() );\n            sink.tableCell_();\n\n            sink.tableCell();\n\n            int line = event.getLine();\n            if ( getXrefLocation() != null && line != 0 )\n            {\n                sink.link( getXrefLocation() + \"/\" + filename.replaceAll( \"\\\\.java$\", \".html\" ) + \"#L\"\n                    + line );\n                sink.text( String.valueOf( line ) );\n                sink.link_();\n            }\n            else if ( line != 0 )\n            {\n                sink.text( String.valueOf( line ) );\n            }\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n    }","commit_id":"fed7e82de07eeb53be1b20b876cb67751c041ef6","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void doFileEvents( List<AuditEvent> eventList, String filename )\n    {\n        for ( AuditEvent event : eventList )\n        {\n            SeverityLevel level = event.getSeverityLevel();\n\n            if ( ( getSeverityLevel() != null ) && !getSeverityLevel().equals( level ) )\n            {\n                continue;\n            }\n\n            sink.tableRow();\n\n            sink.tableCell();\n\n            if ( SeverityLevel.INFO.equals( level ) )\n            {\n                iconInfo();\n            }\n            else if ( SeverityLevel.WARNING.equals( level ) )\n            {\n                iconWarning();\n            }\n            else if ( SeverityLevel.ERROR.equals( level ) )\n            {\n                iconError();\n            }\n\n            sink.tableCell_();\n\n            sink.tableCell();\n            sink.text( event.getMessage() );\n            sink.tableCell_();\n\n            sink.tableCell();\n            if ( getXrefLocation() != null )\n            {\n                sink\n                    .link(\n                        getXrefLocation() + \"/\" + filename.replaceAll( \"\\\\.java$\", \".html\" ) + \"#L\" + event.getLine() );\n            }\n            sink.text( String.valueOf( event.getLine() ) );\n            if ( getXrefLocation() != null )\n            {\n                sink.link_();\n            }\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n    }","id":79414,"modified_method":"private void doFileEvents( List<AuditEvent> eventList, String filename )\n    {\n        for ( AuditEvent event : eventList )\n        {\n            SeverityLevel level = event.getSeverityLevel();\n\n            if ( ( getSeverityLevel() != null ) && !getSeverityLevel().equals( level ) )\n            {\n                continue;\n            }\n\n            sink.tableRow();\n\n            sink.tableCell();\n\n            if ( SeverityLevel.INFO.equals( level ) )\n            {\n                iconInfo();\n            }\n            else if ( SeverityLevel.WARNING.equals( level ) )\n            {\n                iconWarning();\n            }\n            else if ( SeverityLevel.ERROR.equals( level ) )\n            {\n                iconError();\n            }\n\n            sink.tableCell_();\n\n            sink.tableCell();\n            sink.text( event.getMessage() );\n            sink.tableCell_();\n\n            sink.tableCell();\n\n            int line = event.getLine();\n            if ( getXrefLocation() != null )\n            {\n                sink\n                    .link(\n                        getXrefLocation() + \"/\" + filename.replaceAll( \"\\\\.java$\", \".html\" ) + \"#L\" + line );\n            }\n            if ( line != 0 )\n            {\n                sink.text( String.valueOf( event.getLine() ) );\n            }\n            if ( getXrefLocation() != null )\n            {\n                sink.link_();\n            }\n            sink.tableCell_();\n\n            sink.tableRow_();\n        }\n    }","commit_id":"9a9f6ea64274ca612fdf8b48365a8055b0fc605c","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void init(Graph graph, NodeLayeredOrder order) {\n    myPosInLayer = new int[graph.getNumNodes()];\n    myNumLayer = new int[graph.getNumNodes()];\n    for (int layer = 0; layer < order.getNumLayers(); layer++) {\n      List<Integer> layerOrder = order.getIntOrder(layer);\n      for (int pos = 0; pos < ListSequence.fromList(layerOrder).count(); pos++) {\n        myPosInLayer[ListSequence.fromList(layerOrder).getElement(pos)] = pos;\n        myNumLayer[ListSequence.fromList(layerOrder).getElement(pos)] = layer;\n      }\n    }\n    badEdges = SetSequence.fromSet(new HashSet<Edge>());\n    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {\n      SetSequence.fromSet(badEdges).addSequence(SetSequence.fromSet(findBadEdgesInLayer(order.getOrder(layer))));\n    }\n  }","id":79415,"modified_method":"public void init(Graph graph, NodeLayeredOrder order) {\n    myPosInLayer = new NodeMap<Integer>(graph);\n    myNumLayer = new NodeMap<Integer>(graph);\n    for (int layer = 0; layer < order.getNumLayers(); layer++) {\n      List<Node> layerOrder = order.getOrder(layer);\n      for (int pos = 0; pos < ListSequence.fromList(layerOrder).count(); pos++) {\n        MapSequence.fromMap(myPosInLayer).put(ListSequence.fromList(layerOrder).getElement(pos), pos);\n        MapSequence.fromMap(myNumLayer).put(ListSequence.fromList(layerOrder).getElement(pos), layer);\n      }\n    }\n    badEdges = SetSequence.fromSet(new HashSet<Edge>());\n    for (int layer = 0; layer < order.getNumLayers() - 1; layer++) {\n      SetSequence.fromSet(badEdges).addSequence(SetSequence.fromSet(findBadEdgesInLayer(order.getOrder(layer))));\n    }\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"private int tryToAddRoot(int index, int[] roots, Edge edge, int curConnectedPos) {\n    int medianIndex = edge.getSource().getIndex();\n    if (!(SetSequence.fromSet(badEdges).contains(edge)) && myPosInLayer[medianIndex] > curConnectedPos) {\n      roots[index] = roots[medianIndex];\n      curConnectedPos = myPosInLayer[medianIndex];\n    }\n    return curConnectedPos;\n  }","id":79416,"modified_method":"private int tryToAddRoot(Node node, Map<Node, Node> roots, Edge edge, int curConnectedPos) {\n    Node medianNode = edge.getSource();\n    if (!(SetSequence.fromSet(badEdges).contains(edge)) && MapSequence.fromMap(myPosInLayer).get(medianNode) > curConnectedPos) {\n      MapSequence.fromMap(roots).put(node, MapSequence.fromMap(roots).get(medianNode));\n      curConnectedPos = MapSequence.fromMap(myPosInLayer).get(medianNode);\n    }\n    return curConnectedPos;\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Graph createBlockGraph(NodeLayeredOrder order, int[] roots) {\n    Graph blockGraph = new Graph();\n    myRoots = MapSequence.fromMap(new HashMap<Integer, Node>());\n    for (int layer = 0; layer < order.getNumLayers(); layer++) {\n      Node prevBlock = null;\n      for (int index : ListSequence.fromList(order.getIntOrder(layer))) {\n        if (roots[index] == index) {\n          MapSequence.fromMap(myRoots).put(index, blockGraph.addNode());\n        }\n        Node currentBlock = MapSequence.fromMap(myRoots).get(roots[index]);\n        if (prevBlock != null) {\n          prevBlock.addEdgeTo(currentBlock);\n        }\n        prevBlock = currentBlock;\n      }\n    }\n    return blockGraph;\n  }","id":79417,"modified_method":"public Graph createBlockGraph(NodeLayeredOrder order, Map<Node, Node> roots) {\n    Graph blockGraph = new Graph();\n    myBlocks = MapSequence.fromMap(new HashMap<Node, Node>());\n    for (int layer = 0; layer < order.getNumLayers(); layer++) {\n      Node prevBlock = null;\n      for (Node node : ListSequence.fromList(order.getOrder(layer))) {\n        if (MapSequence.fromMap(roots).get(node) == node) {\n          MapSequence.fromMap(myBlocks).put(node, blockGraph.addNode());\n        }\n        Node currentBlock = MapSequence.fromMap(myBlocks).get(MapSequence.fromMap(roots).get(node));\n        if (prevBlock != null) {\n          prevBlock.addEdgeTo(currentBlock);\n        }\n        prevBlock = currentBlock;\n      }\n    }\n    return blockGraph;\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Map<Node, Point> placeCoordinates(Graph graph, NodeLayeredOrder order) {\n    this.init(graph, order);\n    int[] roots = computeBlocks(order);\n    Graph blockGraph = this.createBlockGraph(order, roots);\n    /*\n      NodeLayers layers = new BlockGraphProcessor().process(blockGraph);\n    */\n    NodeLayers layers = new NewBlockGraphProcessor().process(blockGraph);\n    Map<Node, Point> coord = MapSequence.fromMap(new HashMap<Node, Point>());\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      int index = node.getIndex();\n      MapSequence.fromMap(coord).put(node, new Point(layers.get(MapSequence.fromMap(myRoots).get(roots[index])), myNumLayer[index]));\n    }\n    return coord;\n  }","id":79418,"modified_method":"public Map<Node, Point> placeCoordinates(Graph graph, NodeLayeredOrder order) {\n    this.init(graph, order);\n    Map<Node, Node> roots = computeBlocks(order);\n    Graph blockGraph = this.createBlockGraph(order, roots);\n    /*\n      NodeLayers layers = new BlockGraphProcessor().process(blockGraph);\n    */\n    NodeLayers layers = new NewBlockGraphProcessor().process(blockGraph);\n    Map<Node, Point> coord = MapSequence.fromMap(new HashMap<Node, Point>());\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      MapSequence.fromMap(coord).put(node, new Point(layers.get(MapSequence.fromMap(myBlocks).get(MapSequence.fromMap(roots).get(node))), MapSequence.fromMap(myNumLayer).get(node)));\n    }\n    return coord;\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"private int getOppositePos(Node dummyNode) {\n    return myPosInLayer[ListSequence.fromList(dummyNode.getOutEdges()).getElement(0).getTarget().getIndex()];\n  }","id":79419,"modified_method":"private int getOppositePos(Node dummyNode) {\n    return MapSequence.fromMap(myPosInLayer).get(ListSequence.fromList(dummyNode.getOutEdges()).getElement(0).getTarget());\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int[] computeBlocks(NodeLayeredOrder order) {\n    Graph graph = order.getGraph();\n    int[] roots = new int[graph.getNumNodes()];\n    for (int i = 0; i < roots.length; i++) {\n      roots[i] = i;\n    }\n    for (int layer = 1; layer < order.getNumLayers(); layer++) {\n      int curConnectedPos = -1;\n      for (int index : ListSequence.fromList(order.getIntOrder(layer))) {\n        Node node = graph.getNode(index);\n        List<Edge> sortedByPos = ListSequence.fromList(node.getInEdges()).sort(new Comparator<Edge>() {\n          public int compare(Edge a, Edge b) {\n            int aSourceIndex = a.getSource().getIndex();\n            int bSourceIndex = b.getSource().getIndex();\n            return myPosInLayer[aSourceIndex] - myPosInLayer[bSourceIndex];\n          }\n        }, true).toListSequence();\n        Edge medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count() - 1) / 2);\n        if (roots[index] == index) {\n          curConnectedPos = this.tryToAddRoot(index, roots, medianEdge, curConnectedPos);\n        }\n        medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count()) / 2);\n        if (roots[index] == index) {\n          curConnectedPos = this.tryToAddRoot(index, roots, medianEdge, curConnectedPos);\n        }\n      }\n    }\n    return roots;\n  }","id":79420,"modified_method":"public Map<Node, Node> computeBlocks(NodeLayeredOrder order) {\n    Graph graph = order.getGraph();\n    Map<Node, Node> roots = new NodeMap<Node>(graph);\n    for (Node node : ListSequence.fromList(graph.getNodes())) {\n      MapSequence.fromMap(roots).put(node, node);\n    }\n    for (int layer = 1; layer < order.getNumLayers(); layer++) {\n      int curConnectedPos = -1;\n      for (Node node : ListSequence.fromList(order.getOrder(layer))) {\n        List<Edge> sortedByPos = ListSequence.fromList(node.getInEdges()).sort(new Comparator<Edge>() {\n          public int compare(Edge a, Edge b) {\n            Node aSource = a.getSource();\n            Node bSource = b.getSource();\n            return MapSequence.fromMap(myPosInLayer).get(aSource) - MapSequence.fromMap(myPosInLayer).get(bSource);\n          }\n        }, true).toListSequence();\n        Edge medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count() - 1) / 2);\n        if (MapSequence.fromMap(roots).get(node) == node) {\n          curConnectedPos = this.tryToAddRoot(node, roots, medianEdge, curConnectedPos);\n        }\n        medianEdge = ListSequence.fromList(sortedByPos).getElement((ListSequence.fromList(sortedByPos).count()) / 2);\n        if (MapSequence.fromMap(roots).get(node) == node) {\n          curConnectedPos = this.tryToAddRoot(node, roots, medianEdge, curConnectedPos);\n        }\n      }\n    }\n    return roots;\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Set<Edge> findBadEdgesInLayer(List<Node> layerOrder) {\n    Set<Edge> badEdges = SetSequence.fromSet(new HashSet<Edge>());\n    int closestInnerEdgePos = -1;\n    for (int i = 0; i < ListSequence.fromList(layerOrder).count(); i++) {\n      Node node = ListSequence.fromList(layerOrder).getElement(i);\n      if (isInnerDummy(node)) {\n        closestInnerEdgePos = getOppositePos(node);\n      } else {\n        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {\n          int targetPos = myPosInLayer[edge.getTarget().getIndex()];\n          if (targetPos < closestInnerEdgePos) {\n            SetSequence.fromSet(badEdges).addElement(edge);\n          }\n        }\n      }\n    }\n    closestInnerEdgePos = ListSequence.fromList(layerOrder).count() + 1;\n    for (int i = ListSequence.fromList(layerOrder).count() - 1; i >= 0; i--) {\n      Node node = ListSequence.fromList(layerOrder).getElement(i);\n      if (isInnerDummy(node)) {\n        closestInnerEdgePos = getOppositePos(node);\n      } else {\n        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {\n          int targetPos = myPosInLayer[edge.getTarget().getIndex()];\n          if (targetPos > closestInnerEdgePos) {\n            SetSequence.fromSet(badEdges).addElement(edge);\n          }\n        }\n      }\n    }\n    return badEdges;\n  }","id":79421,"modified_method":"private Set<Edge> findBadEdgesInLayer(List<Node> layerOrder) {\n    Set<Edge> badEdges = SetSequence.fromSet(new HashSet<Edge>());\n    int closestInnerEdgePos = -1;\n    for (int i = 0; i < ListSequence.fromList(layerOrder).count(); i++) {\n      Node node = ListSequence.fromList(layerOrder).getElement(i);\n      if (isInnerDummy(node)) {\n        closestInnerEdgePos = getOppositePos(node);\n      } else {\n        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {\n          int targetPos = MapSequence.fromMap(myPosInLayer).get(edge.getTarget());\n          if (targetPos < closestInnerEdgePos) {\n            SetSequence.fromSet(badEdges).addElement(edge);\n          }\n        }\n      }\n    }\n    closestInnerEdgePos = ListSequence.fromList(layerOrder).count() + 1;\n    for (int i = ListSequence.fromList(layerOrder).count() - 1; i >= 0; i--) {\n      Node node = ListSequence.fromList(layerOrder).getElement(i);\n      if (isInnerDummy(node)) {\n        closestInnerEdgePos = getOppositePos(node);\n      } else {\n        for (Edge edge : ListSequence.fromList(node.getOutEdges())) {\n          int targetPos = MapSequence.fromMap(myPosInLayer).get(edge.getTarget());\n          if (targetPos > closestInnerEdgePos) {\n            SetSequence.fromSet(badEdges).addElement(edge);\n          }\n        }\n      }\n    }\n    return badEdges;\n  }","commit_id":"2f6af549fb4c6cbd9ae9cfdae45c37156480c433","url":"https://github.com/JetBrains/MPS"},{"original_method":"POSElement(String token) {\n    this.tokens = new String[] {token};\n  }","id":79422,"modified_method":"POSElement(String[] tokens, boolean caseSensitive, String[] exceptions) {\n    this.tokens = tokens;\n    this.exceptions = exceptions;\n    this.caseSensitive = caseSensitive;\n  }","commit_id":"3b4b4c8fef6e7b9c4ff71fbbce4c1573505867e7","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"POSElement(String[] tokens) {\n    this.tokens = tokens;\n  }","id":79423,"modified_method":"POSElement(String[] tokens, String[] exceptions) {\n    this(tokens, false, exceptions);\n  }","commit_id":"3b4b4c8fef6e7b9c4ff71fbbce4c1573505867e7","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean matchToken(AnalyzedToken token) {\n    for (int i = 0; i < tokens.length; i++) {\n      if (tokens[i].equals(token.getPOSTag()))\n        return true;\n    }\n    return false;\n  }","id":79424,"modified_method":"boolean matchToken(AnalyzedToken token) {\n    boolean match = false;\n    for (int i = 0; i < tokens.length; i++) {\n      if (tokens[i].equals(token.getPOSTag())) {\n        match = true;\n        break;\n      }\n    }\n    if (exceptions != null) {\n      for (int i = 0; i < exceptions.length; i++) {\n        boolean tmpMatch;\n        if (caseSensitive)\n          tmpMatch = exceptions[i].equals(token.getToken());\n        else\n          tmpMatch = exceptions[i].equalsIgnoreCase(token.getToken());\n        if (tmpMatch) {\n          return false;\n        }\n      }\n    }\n    return match;\n  }","commit_id":"3b4b4c8fef6e7b9c4ff71fbbce4c1573505867e7","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private Element[] getPatternElements(String pattern) {\n    List elements = new ArrayList();\n    pattern = pattern.replaceAll(\"[\\\\(\\\\)]\", \"\");       // just ignore parentheses\n    String[] parts = pattern.split(\"\\\\s+\");\n    for (int i = 0; i < parts.length; i++) {\n      String element = parts[i];\n      boolean negation = false;\n      if (element.startsWith(\"^\")) {\n        negation = true;\n        element = element.substring(1);     // cut off \"^\"\n      }\n      if (element.startsWith(\"\\\"\") && !element.endsWith(\"\\\"\") || element.endsWith(\"\\\"\") && !element.startsWith(\"\\\"\")) {\n        throw new IllegalArgumentException(\"Invalid pattern '\" + pattern + \"': unbalanced quote\");\n      }\n      if (element.startsWith(\"\\\"\") && element.endsWith(\"\\\"\")) {         // cut off quotes\n        element = element.substring(1, element.length()-1);\n        String tokenParts[] = element.split(\"\\\\|\");\n        StringElement stringElement = new StringElement(tokenParts, caseSensitive); \n        stringElement.setNegation(negation);\n        elements.add(stringElement);\n      } else if (element.toUpperCase().equals(element)) {\n        // all-uppercase = POS tag (except: see above)\n        String tokenParts[] = element.split(\"\\\\|\");\n        POSElement posElement = new POSElement(tokenParts);\n        posElement.setNegation(negation);\n        elements.add(posElement);\n      } else {\n        throw new IllegalArgumentException(\"Unknown type \" + element + \" in pattern: \" + pattern);\n      }\n    }\n    return (Element[])elements.toArray(new Element[0]);\n  }","id":79425,"modified_method":"private Element[] getPatternElements(String pattern) {\n    List elements = new ArrayList();\n    pattern = pattern.replaceAll(\"[\\\\(\\\\)]\", \"\");       // just ignore parentheses\n    String[] parts = pattern.split(\"\\\\s+\");\n    for (int i = 0; i < parts.length; i++) {\n      String element = parts[i];\n      boolean negation = false;\n      if (element.startsWith(\"^\")) {\n        negation = true;\n        element = element.substring(1);     // cut off \"^\"\n      }\n      if (element.startsWith(\"\\\"\") && !element.endsWith(\"\\\"\") || element.endsWith(\"\\\"\") && !element.startsWith(\"\\\"\")) {\n        throw new IllegalArgumentException(\"Invalid pattern '\" + pattern + \"': unbalanced quote\");\n      }\n      if (element.startsWith(\"\\\"\") && element.endsWith(\"\\\"\")) {         // cut off quotes\n        element = element.substring(1, element.length()-1);\n        String tokenParts[] = element.split(\"\\\\|\");\n        StringElement stringElement = new StringElement(tokenParts, caseSensitive); \n        stringElement.setNegation(negation);\n        elements.add(stringElement);\n      } else if (Character.isUpperCase(element.charAt(0))) {\n        // uppercase = POS tag (except: see above)\n        String tokenParts[];\n        String exceptions[] = null;\n        POSElement posElement;\n        if (element.indexOf(\"^\") != -1) {\n          tokenParts = element.substring(0, element.indexOf(\"^\")).split(\"\\\\|\");\n          exceptions = element.substring(element.indexOf(\"^\")+1).split(\"\\\\|\");\n        } else {\n          tokenParts = element.split(\"\\\\|\");\n        }\n        posElement = new POSElement(tokenParts, caseSensitive, exceptions);\n        posElement.setNegation(negation);\n        elements.add(posElement);\n      } else {\n        throw new IllegalArgumentException(\"Unknown type \" + element + \" in pattern: \" + pattern);\n      }\n    }\n    return (Element[])elements.toArray(new Element[0]);\n  }","commit_id":"3b4b4c8fef6e7b9c4ff71fbbce4c1573505867e7","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testNegation() throws IOException {\n    PatternRule pr;\n    RuleMatch[] matches;\n\n    pr = makePatternRule(\"\\\"one\\\" ^\\\"two\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one four.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"\\\"one\\\" ^\\\"two|three\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one three.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one four.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"SENT_START ^\\\"One\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"One two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Two three.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"\\\"One\\\" ^CD\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"One two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"One walk.\"));\n    assertEquals(1, matches.length);\n  }","id":79426,"modified_method":"public void testNegation() throws IOException {\n    PatternRule pr;\n    RuleMatch[] matches;\n\n    pr = makePatternRule(\"\\\"one\\\" ^\\\"two\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one four.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"\\\"one\\\" ^\\\"two|three\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one three.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Here's one four.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"SENT_START ^\\\"One\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"One two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Two three.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"\\\"One\\\" ^CD\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"One two.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"One walk.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"CD^one \\\"foo\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"One foo.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Two foo.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"CD^one|three|five \\\"foo\\\"\");\n    matches = pr.match(langTool.getAnalyzedSentence(\"One foo.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Three foo.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Five foo.\"));\n    assertEquals(0, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"Eight foo.\"));\n    assertEquals(1, matches.length);\n\n    pr = makePatternRule(\"CD^one \\\"foo\\\"\", true);\n    matches = pr.match(langTool.getAnalyzedSentence(\"One foo.\"));\n    assertEquals(1, matches.length);\n    matches = pr.match(langTool.getAnalyzedSentence(\"the one foo.\"));\n    assertEquals(0, matches.length);\n  }","commit_id":"3b4b4c8fef6e7b9c4ff71fbbce4c1573505867e7","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public VirulentWound(UUID ownerId) {\r\n        super(ownerId, 57, \"Virulent Wound\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{B}\");\r\n        this.expansionSetCode = \"MBS\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        this.getSpellAbility().addEffect(new VirulentWoundEffect());\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n    }","id":79427,"modified_method":"public VirulentWound(UUID ownerId) {\r\n        super(ownerId, 57, \"Virulent Wound\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{B}\");\r\n        this.expansionSetCode = \"MBS\";\r\n\r\n        this.color.setBlack(true);\r\n\r\n        // Put a -1/-1 counter on target creature.\r\n        this.getSpellAbility().addEffect(new AddCountersTargetEffect(CounterType.M1M1.createInstance(), Outcome.UnboostCreature));\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n        // When that creature dies this turn, its controller gets a poison counter.\r\n        this.getSpellAbility().addEffect(new VirulentWoundEffect());\r\n    }","commit_id":"878f5dc7c131c397db235312126ee71db77acf92","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n        if (permanent != null) {\r\n            permanent.addCounters(CounterType.M1M1.createInstance(), game);\r\n\r\n            DelayedTriggeredAbility delayedAbility = new VirulentWoundDelayedTriggeredAbility(permanent.getId());\r\n            delayedAbility.setSourceId(source.getSourceId());\r\n            delayedAbility.setControllerId(source.getControllerId());\r\n            game.addDelayedTriggeredAbility(delayedAbility);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":79428,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        DelayedTriggeredAbility delayedAbility = new VirulentWoundDelayedTriggeredAbility(source.getFirstTarget());\r\n        delayedAbility.setSourceId(source.getSourceId());\r\n        delayedAbility.setControllerId(source.getControllerId());\r\n        game.addDelayedTriggeredAbility(delayedAbility);\r\n        return true;\r\n    }","commit_id":"878f5dc7c131c397db235312126ee71db77acf92","url":"https://github.com/magefree/mage"},{"original_method":"public VirulentWoundDelayedTriggeredAbility(UUID target) {\r\n        super(new VirulentWoundDelayedEffect(target));\r\n        this.target = target;\r\n    }","id":79429,"modified_method":"public VirulentWoundDelayedTriggeredAbility(UUID target) {\r\n        super(new VirulentWoundDelayedEffect(target), Duration.EndOfTurn);\r\n        this.target = target;\r\n    }","commit_id":"878f5dc7c131c397db235312126ee71db77acf92","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getFirstTarget());\n        if (player == null) {\n            return false;\n        }\n        if (player.searchLibrary(target, game)) {\n            if (target.getTargets().size() > 0) {\n                Cards cards = new CardsImpl(target.getTargets());\n                player.revealCards(\"Quiet Speculation\", cards, game);\n                player.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);\n            }\n            player.shuffleLibrary(source, game);\n            return true;\n        }\n        player.shuffleLibrary(source, game);\n        return false;\n    }","id":79430,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        UUID targetPlayerID = source.getFirstTarget();\n        if (controller.searchLibrary(target, game, targetPlayerID)) {\n            if (target.getTargets().size() > 0) {\n                Cards cards = new CardsImpl(target.getTargets());\n                controller.revealCards(\"Quiet Speculation\", cards, game);\n                controller.moveCards(cards, Zone.GRAVEYARD, source, game);\n            }\n            controller.shuffleLibrary(source, game);\n            return true;\n        }\n        controller.shuffleLibrary(source, game);\n        return false;\n    }","commit_id":"f1343dd03f0c1480971265d9f0fca092d93ecdb4","url":"https://github.com/magefree/mage"},{"original_method":"public DawnglareInvokerEffect() {\r\n        super(Outcome.Tap);\r\n        staticText = \"Tap all creatures target player controls.\";\r\n    }","id":79431,"modified_method":"public DawnglareInvokerEffect() {\r\n        super(Outcome.Tap);\r\n        staticText = \"Tap all creatures target player controls\";\r\n    }","commit_id":"d46678f95f944f317b6136f9b41888f1a303057e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n        if (player != null) {\r\n            List<Permanent> allCreatures = game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game);\r\n            for (Permanent creature : allCreatures) {\r\n                creature.tap(game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":79432,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if (source.getFirstTarget() == null) {\r\n            return false;\r\n        }\r\n\r\n        FilterCreaturePermanent filter = new FilterCreaturePermanent();\r\n        filter.add(new ControllerIdPredicate(source.getFirstTarget()));\r\n\r\n        List<Permanent> creatures = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);\r\n        for (Permanent creature : creatures) {\r\n            creature.tap(game);\r\n        }\r\n        return true;\r\n    }","commit_id":"d46678f95f944f317b6136f9b41888f1a303057e","url":"https://github.com/magefree/mage"},{"original_method":"public DivineReckoning(UUID ownerId) {\r\n        super(ownerId, 10, \"Divine Reckoning\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{W}{W}\");\r\n        this.expansionSetCode = \"ISD\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Each player chooses a creature he or she controls. Destroy the rest.\r\n        this.getSpellAbility().addEffect(new DivineReckoningEffect());\r\n\r\n        // Flashback {5}{W}{W}\r\n        this.addAbility(new FlashbackAbility(new ManaCostsImpl(\"{5}{W}{W}\"), Constants.TimingRule.INSTANT));\r\n    }","id":79433,"modified_method":"public DivineReckoning(UUID ownerId) {\r\n        super(ownerId, 10, \"Divine Reckoning\", Rarity.RARE, new CardType[]{CardType.SORCERY}, \"{2}{W}{W}\");\r\n        this.expansionSetCode = \"ISD\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Each player chooses a creature he or she controls. Destroy the rest.\r\n        this.getSpellAbility().addEffect(new DivineReckoningEffect());\r\n\r\n        // Flashback {5}{W}{W}\r\n        this.addAbility(new FlashbackAbility(new ManaCostsImpl(\"{5}{W}{W}\"), Constants.TimingRule.SORCERY));\r\n    }","commit_id":"d46678f95f944f317b6136f9b41888f1a303057e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void visitPyStarImportElement(PyStarImportElement node) {\n      super.visitPyStarImportElement(node);\n      if (CythonLanguageDialect._isDisabledFor(node) || MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      myAllImports.add(node);\n    }","id":79434,"modified_method":"@Override\n    public void visitPyStarImportElement(PyStarImportElement node) {\n      super.visitPyStarImportElement(node);\n      if (MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      myAllImports.add(node);\n    }","commit_id":"1031ce108508b7d422745e4caa1cc37fbfd4d4db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyImportElement(PyImportElement node) {\n      super.visitPyImportElement(node);\n      if (CythonLanguageDialect._isDisabledFor(node) || MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      final PyFromImportStatement fromImport = PsiTreeUtil.getParentOfType(node, PyFromImportStatement.class);\n      if (fromImport == null || !fromImport.isFromFuture()) {\n        myAllImports.add(node);\n      }\n    }","id":79435,"modified_method":"@Override\n    public void visitPyImportElement(PyImportElement node) {\n      super.visitPyImportElement(node);\n      if (MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      final PyFromImportStatement fromImport = PsiTreeUtil.getParentOfType(node, PyFromImportStatement.class);\n      if (fromImport == null || !fromImport.isFromFuture()) {\n        myAllImports.add(node);\n      }\n    }","commit_id":"1031ce108508b7d422745e4caa1cc37fbfd4d4db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyElement(final PyElement node) {\n      super.visitPyElement(node);\n      if (CythonLanguageDialect._isDisabledFor(node) || MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      if (node instanceof PyReferenceOwner) {\n        final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(myTypeEvalContext);\n        processReference(node, ((PyReferenceOwner)node).getReference(resolveContext));\n      }\n      else {\n        for (final PsiReference reference : node.getReferences()) {\n          processReference(node, reference);\n        }\n      }\n    }","id":79436,"modified_method":"@Override\n    public void visitPyElement(final PyElement node) {\n      super.visitPyElement(node);\n      if (MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      if (node instanceof PyReferenceOwner) {\n        final PyResolveContext resolveContext = PyResolveContext.noImplicits().withTypeEvalContext(myTypeEvalContext);\n        processReference(node, ((PyReferenceOwner)node).getReference(resolveContext));\n      }\n      else {\n        for (final PsiReference reference : node.getReferences()) {\n          processReference(node, reference);\n        }\n      }\n    }","commit_id":"8c5f6b323bcb6644a53ce7a5054ee840137f9a3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyTargetExpression(PyTargetExpression node) {\n      if (CythonLanguageDialect._isDisabledFor(node) || MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      checkSlots(node);\n    }","id":79437,"modified_method":"@Override\n    public void visitPyTargetExpression(PyTargetExpression node) {\n      if (MakoLanguage._isDisabledFor(node)) {\n        return;\n      }\n      checkSlots(node);\n    }","commit_id":"8c5f6b323bcb6644a53ce7a5054ee840137f9a3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerUnresolvedReferenceProblem(final PyElement node, final PsiReference reference, HighlightSeverity severity) {\n      final StringBuilder description_buf = new StringBuilder(\"\"); // TODO: clear description_buf logic. maybe a flag is needed instead.\n      final String text = reference.getElement().getText();\n      final String ref_text = reference.getRangeInElement().substring(text); // text of the part we're working with\n      final PsiElement element = reference.getElement();\n      final boolean ref_is_importable = PythonReferenceImporter.isImportable(element);\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      if (ref_text.length() <= 0) return; // empty text, nothing to highlight\n      final String refname = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : ref_text;\n      if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression refex = (PyReferenceExpression)element;\n        if (myIgnoredIdentifiers.contains(refname) || PyNames.COMPARISON_OPERATORS.contains(refname)) {\n          return;\n        }\n        if (CythonLanguageDialect.isInsideCythonFile(element) && CythonNames.BUILTINS.contains(text)) {\n          return;\n        }\n        if (refex.getQualifier() != null) {\n          final PyClassType object_type = PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname)) return;\n\n        }\n        else {\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (refname.equals(\"with\")) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));\n            }\n          }\n          PyClass containedClass = PsiTreeUtil.getParentOfType(node, PyClass.class);\n          if (containedClass != null) {\n            for (PyTargetExpression target : containedClass.getInstanceAttributes()) {\n              if (Comparing.strEqual(node.getName(), target.getName())) {\n                actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n              }\n            }\n            for (PyStatement statement : containedClass.getStatementList().getStatements()) {\n              if (statement instanceof PyAssignmentStatement) {\n                if (((PyAssignmentStatement)statement).getLeftHandSideExpression().getText().equals(refex.getText())) {\n                  PyExpression callexpr = ((PyAssignmentStatement)statement).getAssignedValue();\n                  if (callexpr instanceof PyCallExpression) {\n                    PyType type = myTypeEvalContext.getType(callexpr);\n                    if (type != null && type instanceof PyClassType) {\n                      String name = ((PyCallExpression)callexpr).getCallee().getText();\n                      if (name != null && name.equals(\"property\"))\n                        actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n                    }\n                  }\n                }\n              }\n            }\n            for (PyFunction method : containedClass.getMethods()) {\n              if (method.getName().equals(refex.getText())) {\n                actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n              }\n            }\n          }\n          PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n          if (callExpression != null)\n            actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, refex));\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refname)) return;\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.WEAK_WARNING;\n          String errmsg = PyBundle.message(\"INSP.module.$0.not.found\", ref_text);\n          description_buf.append(errmsg);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof DocStringParameterReference) {\n        if (myIgnoredIdentifiers.contains(reference.getCanonicalText()))\n          return;\n      }\n      if (reference instanceof PsiReferenceEx) {\n        final String s = ((PsiReferenceEx)reference).getUnresolvedDescription();\n        if (s != null) description_buf.append(s);\n      }\n      if (description_buf.length() == 0) {\n        boolean marked_qualified = false;\n        if (element instanceof PyQualifiedExpression) {\n          final PyQualifiedExpression qexpr = (PyQualifiedExpression)element;\n          if (PyNames.COMPARISON_OPERATORS.contains(qexpr.getReferencedName())) {\n            return;\n          }\n          final PyExpression qualifier = qexpr.getQualifier();\n          if (qualifier != null) {\n            PyType qtype = myTypeEvalContext.getType(qualifier);\n            if (qtype != null) {\n              if (qtype instanceof PyNoneType || qtype instanceof PyTypeReference ||\n                  (qtype instanceof PyUnionType && ((PyUnionType) qtype).isWeak())) {\n                // this almost always means that we don't know the type, so don't show an error in this case\n                return;\n              }\n              if (qtype instanceof PyClassType) {\n                PyClass cls = ((PyClassType)qtype).getPyClass();\n                if (cls != null) {\n                  if (overridesGetAttr(cls)) {\n                    return;\n                  }\n                  if (cls.findProperty(ref_text) != null) {\n                    return; // a property exists but accessor is not found; other inspections handle this\n                  }\n                  if (! PyBuiltinCache.getInstance(node).hasInBuiltins(cls)) {\n                    if (element.getParent() instanceof PyCallExpression) {\n                      actions.add(new AddMethodQuickFix(ref_text, (PyClassType)qtype));\n                    }\n                    else if (!(reference instanceof PyOperatorReferenceImpl)) {\n                      actions.add(new AddFieldQuickFix(ref_text, cls, \"None\"));\n                    }\n                  }\n                }\n                if (reference instanceof PyOperatorReferenceImpl) {\n                  description_buf.append(PyBundle.message(\"INSP.unresolved.operator.ref\",\n                                                          qtype.getName(), refname,\n                                                          ((PyOperatorReferenceImpl)reference).getReadableOperatorName()));\n                }\n                else {\n                  description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", ref_text, qtype.getName()));\n                }\n                marked_qualified = true;\n              }\n              else if (qtype instanceof PyModuleType) {\n                PsiFile file = ((PyModuleType)qtype).getModule();\n                if (file instanceof PyFile) {\n                  actions.add(new AddFunctionQuickFix(ref_text, (PyFile)file));\n                }\n              }\n              else {\n                description_buf.append(PyBundle.message(\"INSP.cannot.find.$0.in.$1\", ref_text, qtype.getName()));\n                marked_qualified = true;\n              }\n            }\n          }\n        }\n        if (! marked_qualified) {\n          description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0\", ref_text));\n          if (ref_text.equals(\"true\") || ref_text.equals(\"false\"))\n            actions.add(new UnresolvedRefTrueFalseQuickFix(element));\n\n          // look in other imported modules for this whole name\n          if (ref_is_importable) {\n            AutoImportQuickFix importFix = PythonReferenceImporter.proposeImportFix(node, reference, ref_text);\n            if (importFix != null) {\n              // if the context doesn't look like a function call and we only found imports of functions, suggest auto-import\n              // as a quickfix but no popup balloon (PY-2312)\n              if ((isCall(node) || !importFix.hasOnlyFunctions()) && PyCodeInsightSettings.getInstance().SHOW_IMPORT_POPUP) {\n                final AutoImportHintAction autoImportHintAction = new AutoImportHintAction(importFix);\n                actions.add(autoImportHintAction);\n              }\n              else {\n                actions.add(importFix);\n              }\n            }\n          }\n\n          if (ref_text.length() > 2 && Character.isUpperCase(ref_text.charAt(0)) && !Character.isUpperCase(ref_text.charAt(1)) &&\n              PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class) == null) {\n            PsiElement anchor = element;\n            if (element instanceof PyQualifiedExpression) {\n              final PyExpression qexpr = ((PyQualifiedExpression)element).getQualifier();\n              if (qexpr != null) {\n                final PyType type = myTypeEvalContext.getType(qexpr);\n                if (type instanceof PyModuleType) {\n                  anchor = ((PyModuleType) type).getModule();\n                }\n                else {\n                  anchor = null;\n                }\n              }\n              if (anchor != null) {\n                actions.add(new CreateClassQuickFix(ref_text, anchor));\n              }\n            }\n          }\n        }\n      }\n      String description = description_buf.toString();\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      /*\n      else if (severity == HighlightSeverity.ERROR) {\n        hl_type = ProblemHighlightType.ERROR;\n      }\n      */\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      if (GenerateBinaryStubsFix.isApplicable(reference)) {\n        actions.add(new GenerateBinaryStubsFix(reference));\n      }\n      actions.add(new AddIgnoredIdentifierFix(ref_text));\n      addPluginQuickFixes(reference, actions);\n\n      PsiElement point = node.getLastChild(); // usually the identifier at the end of qual ref\n      if (point == null) point = node;\n      TextRange range = reference.getRangeInElement().shiftRight(-point.getStartOffsetInParent());\n      registerProblem(point, description, hl_type, null, range, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","id":79438,"modified_method":"private void registerUnresolvedReferenceProblem(final PyElement node, final PsiReference reference, HighlightSeverity severity) {\n      final StringBuilder description_buf = new StringBuilder(\"\"); // TODO: clear description_buf logic. maybe a flag is needed instead.\n      final String text = reference.getElement().getText();\n      final String ref_text = reference.getRangeInElement().substring(text); // text of the part we're working with\n      final PsiElement element = reference.getElement();\n      final boolean ref_is_importable = PythonReferenceImporter.isImportable(element);\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      if (ref_text.length() <= 0) return; // empty text, nothing to highlight\n      final String refname = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : ref_text;\n      if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression refex = (PyReferenceExpression)element;\n        if (myIgnoredIdentifiers.contains(refname) || PyNames.COMPARISON_OPERATORS.contains(refname)) {\n          return;\n        }\n        if (CythonLanguageDialect.isInsideCythonFile(element) && CythonNames.BUILTINS.contains(text)) {\n          return;\n        }\n        if (refex.getQualifier() != null) {\n          final PyClassType object_type = PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname)) return;\n\n        }\n        else {\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (refname.equals(\"with\")) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));\n            }\n          }\n          PyClass containedClass = PsiTreeUtil.getParentOfType(node, PyClass.class);\n          if (containedClass != null) {\n            for (PyTargetExpression target : containedClass.getInstanceAttributes()) {\n              if (Comparing.strEqual(node.getName(), target.getName())) {\n                actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n              }\n            }\n            for (PyStatement statement : containedClass.getStatementList().getStatements()) {\n              if (statement instanceof PyAssignmentStatement) {\n                if (((PyAssignmentStatement)statement).getLeftHandSideExpression().getText().equals(refex.getText())) {\n                  PyExpression callexpr = ((PyAssignmentStatement)statement).getAssignedValue();\n                  if (callexpr instanceof PyCallExpression) {\n                    PyType type = myTypeEvalContext.getType(callexpr);\n                    if (type != null && type instanceof PyClassType) {\n                      String name = ((PyCallExpression)callexpr).getCallee().getText();\n                      if (name != null && name.equals(\"property\"))\n                        actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n                    }\n                  }\n                }\n              }\n            }\n            for (PyFunction method : containedClass.getMethods()) {\n              if (method.getName().equals(refex.getText())) {\n                actions.add(new UnresolvedReferenceAddSelfQuickFix(refex));\n              }\n            }\n          }\n          PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n          if (callExpression != null)\n            actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, refex));\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refname)) return;\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.WEAK_WARNING;\n          String errmsg = PyBundle.message(\"INSP.module.$0.not.found\", ref_text);\n          description_buf.append(errmsg);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof DocStringParameterReference) {\n        if (myIgnoredIdentifiers.contains(reference.getCanonicalText()))\n          return;\n      }\n      if (reference instanceof PsiReferenceEx) {\n        final String s = ((PsiReferenceEx)reference).getUnresolvedDescription();\n        if (s != null) description_buf.append(s);\n      }\n      if (description_buf.length() == 0) {\n        boolean marked_qualified = false;\n        if (element instanceof PyQualifiedExpression) {\n          final PyQualifiedExpression qexpr = (PyQualifiedExpression)element;\n          if (PyNames.COMPARISON_OPERATORS.contains(qexpr.getReferencedName())) {\n            return;\n          }\n          final PyExpression qualifier = qexpr.getQualifier();\n          if (qualifier != null) {\n            PyType qtype = myTypeEvalContext.getType(qualifier);\n            if (qtype != null) {\n              if (qtype instanceof PyNoneType || qtype instanceof PyTypeReference ||\n                  (qtype instanceof PyUnionType && ((PyUnionType) qtype).isWeak())) {\n                // this almost always means that we don't know the type, so don't show an error in this case\n                return;\n              }\n              if (qtype instanceof PyClassType) {\n                PyClass cls = ((PyClassType)qtype).getPyClass();\n                if (cls != null) {\n                  if (overridesGetAttr(cls)) {\n                    return;\n                  }\n                  if (cls.findProperty(ref_text) != null) {\n                    return; // a property exists but accessor is not found; other inspections handle this\n                  }\n                  if (! PyBuiltinCache.getInstance(node).hasInBuiltins(cls)) {\n                    if (element.getParent() instanceof PyCallExpression) {\n                      actions.add(new AddMethodQuickFix(ref_text, (PyClassType)qtype));\n                    }\n                    else if (!(reference instanceof PyOperatorReferenceImpl)) {\n                      actions.add(new AddFieldQuickFix(ref_text, cls, \"None\"));\n                    }\n                  }\n                }\n                if (reference instanceof PyOperatorReferenceImpl) {\n                  description_buf.append(PyBundle.message(\"INSP.unresolved.operator.ref\",\n                                                          qtype.getName(), refname,\n                                                          ((PyOperatorReferenceImpl)reference).getReadableOperatorName()));\n                }\n                else {\n                  description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", ref_text, qtype.getName()));\n                }\n                marked_qualified = true;\n              }\n              else if (qtype instanceof PyModuleType) {\n                PsiFile file = ((PyModuleType)qtype).getModule();\n                if (file instanceof PyFile) {\n                  actions.add(new AddFunctionQuickFix(ref_text, (PyFile)file));\n                }\n              }\n              else if (qtype instanceof CythonType && reference instanceof PyOperatorReferenceImpl) {\n                return;\n              }\n              else {\n                description_buf.append(PyBundle.message(\"INSP.cannot.find.$0.in.$1\", ref_text, qtype.getName()));\n                marked_qualified = true;\n              }\n            }\n          }\n        }\n        if (! marked_qualified) {\n          description_buf.append(PyBundle.message(\"INSP.unresolved.ref.$0\", ref_text));\n          if (ref_text.equals(\"true\") || ref_text.equals(\"false\"))\n            actions.add(new UnresolvedRefTrueFalseQuickFix(element));\n\n          // look in other imported modules for this whole name\n          if (ref_is_importable) {\n            AutoImportQuickFix importFix = PythonReferenceImporter.proposeImportFix(node, reference, ref_text);\n            if (importFix != null) {\n              // if the context doesn't look like a function call and we only found imports of functions, suggest auto-import\n              // as a quickfix but no popup balloon (PY-2312)\n              if ((isCall(node) || !importFix.hasOnlyFunctions()) && PyCodeInsightSettings.getInstance().SHOW_IMPORT_POPUP) {\n                final AutoImportHintAction autoImportHintAction = new AutoImportHintAction(importFix);\n                actions.add(autoImportHintAction);\n              }\n              else {\n                actions.add(importFix);\n              }\n            }\n          }\n\n          if (ref_text.length() > 2 && Character.isUpperCase(ref_text.charAt(0)) && !Character.isUpperCase(ref_text.charAt(1)) &&\n              PsiTreeUtil.getParentOfType(element, PyImportStatementBase.class) == null) {\n            PsiElement anchor = element;\n            if (element instanceof PyQualifiedExpression) {\n              final PyExpression qexpr = ((PyQualifiedExpression)element).getQualifier();\n              if (qexpr != null) {\n                final PyType type = myTypeEvalContext.getType(qexpr);\n                if (type instanceof PyModuleType) {\n                  anchor = ((PyModuleType) type).getModule();\n                }\n                else {\n                  anchor = null;\n                }\n              }\n              if (anchor != null) {\n                actions.add(new CreateClassQuickFix(ref_text, anchor));\n              }\n            }\n          }\n        }\n      }\n      String description = description_buf.toString();\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      /*\n      else if (severity == HighlightSeverity.ERROR) {\n        hl_type = ProblemHighlightType.ERROR;\n      }\n      */\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      if (GenerateBinaryStubsFix.isApplicable(reference)) {\n        actions.add(new GenerateBinaryStubsFix(reference));\n      }\n      actions.add(new AddIgnoredIdentifierFix(ref_text));\n      addPluginQuickFixes(reference, actions);\n\n      PsiElement point = node.getLastChild(); // usually the identifier at the end of qual ref\n      if (point == null) point = node;\n      TextRange range = reference.getRangeInElement().shiftRight(-point.getStartOffsetInParent());\n      registerProblem(point, description, hl_type, null, range, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","commit_id":"8c5f6b323bcb6644a53ce7a5054ee840137f9a3a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** note - lang change is handled in CSSHelper but we still need to save it here */\n    private void saveChanges() {\n        if (_config == null)\n            return;\n        String oldTheme = _context.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        boolean ok;\n        if (_config.equals(\"default\")) // obsolete\n            ok = _context.router().saveConfig(CSSHelper.PROP_THEME_NAME, null);\n        else\n            ok = _context.router().saveConfig(CSSHelper.PROP_THEME_NAME, _config);\n        if (ok) {\n            if (_universalTheming)\n                ok = _context.router().saveConfig(CSSHelper.PROP_UNIVERSAL_THEMING, \"true\");\n            else\n                ok = _context.router().saveConfig(CSSHelper.PROP_UNIVERSAL_THEMING, null);\n        }\n        if (ok) {\n            if (!oldTheme.equals(_config))\n                addFormNotice(_(\"Theme change saved.\") +\n                              \" <a href=\\\"configui\\\">\" +\n                              _(\"Refresh the page to view.\") +\n                              \"<\/a>\");\n        } else {\n            addFormError(_(\"Error saving the configuration (applied but not saved) - please see the error logs.\"));\n        }\n    }","id":79439,"modified_method":"/** note - lang change is handled in CSSHelper but we still need to save it here */\n    private void saveChanges() {\n        if (_config == null)\n            return;\n        Map<String, String> changes = new HashMap();\n        List<String> removes = new ArrayList();\n        String oldTheme = _context.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        if (_config.equals(\"default\")) // obsolete\n            removes.add(CSSHelper.PROP_THEME_NAME);\n        else\n            changes.put(CSSHelper.PROP_THEME_NAME, _config);\n        if (_universalTheming)\n            changes.put(CSSHelper.PROP_UNIVERSAL_THEMING, \"true\");\n        else\n            removes.add(CSSHelper.PROP_UNIVERSAL_THEMING);\n        boolean ok = _context.router().saveConfig(changes, removes);\n        if (ok) {\n            if (!oldTheme.equals(_config))\n                addFormNotice(_(\"Theme change saved.\") +\n                              \" <a href=\\\"configui\\\">\" +\n                              _(\"Refresh the page to view.\") +\n                              \"<\/a>\");\n        } else {\n            addFormError(_(\"Error saving the configuration (applied but not saved) - please see the error logs.\"));\n        }\n    }","commit_id":"d147db3382b44bbcbe9ec7c1c3cba5368883b6c1","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String getTheme(String userAgent) {\n        String url = BASE_THEME_PATH;\n        if (userAgent != null && userAgent.contains(\"MSIE\")) {\n            url += FORCE + \"/\";\n        } else {\n            // This is the first thing to use _context on most pages\n            if (_context == null)\n                throw new IllegalStateException(\"No contexts. This is usually because the router is either starting up or shutting down.\");\n            String theme = _context.getProperty(PROP_THEME_NAME, DEFAULT_THEME);\n            url += theme + \"/\";\n        }\n        return url;\n    }","id":79440,"modified_method":"public String getTheme(String userAgent) {\n        String url = BASE_THEME_PATH;\n        if (userAgent != null && userAgent.contains(\"MSIE\")) {\n            url += FORCE + \"/\";\n        } else {\n            // This is the first thing to use _context on most pages\n            if (_context == null)\n                throw new IllegalStateException(\"No contexts. This is usually because the router is either starting up or shutting down.\");\n            String theme = _context.readConfigFile(THEME_CONFIG_FILE).getProperty(PROP_THEME_NAME, DEFAULT_THEME);\n            url += theme + \"/\";\n        }\n        return url;\n    }","commit_id":"5d5a3b80e55df799c399049892759f2e055d8811","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** note - lang change is handled in CSSHelper but we still need to save it here */\n    private void saveChanges() {\n        if (_config == null)\n            return;\n        String oldTheme = _context.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        boolean ok;\n        if (_config.equals(\"default\")) // obsolete\n            ok = _context.router().saveConfig(CSSHelper.PROP_THEME_NAME, null);\n        else\n            ok = _context.router().saveConfig(CSSHelper.PROP_THEME_NAME, _config);\n        if (ok) {\n            if (!oldTheme.equals(_config))\n                addFormNotice(_(\"Theme change saved.\") +\n                              \" <a href=\\\"configui\\\">\" +\n                              _(\"Refresh the page to view.\") +\n                              \"<\/a>\");\n        } else {\n            addFormError(_(\"Error saving the configuration (applied but not saved) - please see the error logs.\"));\n        }\n    }","id":79441,"modified_method":"/** note - lang change is handled in CSSHelper but we still need to save it here */\n    private void saveChanges() {\n        if (_config == null)\n            return;\n        Properties props = _context.readConfigFile(CSSHelper.THEME_CONFIG_FILE);\n        String oldTheme = props.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        boolean ok;\n        if (_config.equals(\"default\")) // obsolete\n            props.put(CSSHelper.PROP_THEME_NAME, null);\n        else\n            props.put(CSSHelper.PROP_THEME_NAME, _config);\n        ok = _context.writeConfigFile(\"themes.config\", props);\n        if (ok) {\n            if (!oldTheme.equals(_config))\n                addFormNotice(_(\"Theme change saved.\") +\n                              \" <a href=\\\"configui\\\">\" +\n                              _(\"Refresh the page to view.\") +\n                              \"<\/a>\");\n        } else {\n            addFormError(_(\"Error saving the configuration (applied but not saved) - please see the error logs.\"));\n        }\n    }","commit_id":"5d5a3b80e55df799c399049892759f2e055d8811","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String getSettings() {\n        StringBuilder buf = new StringBuilder(512);\n        String current = _context.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        Set<String> themes = themeSet();\n        for (String theme : themes) {\n            buf.append(\"<input type=\\\"radio\\\" class=\\\"optbox\\\" name=\\\"theme\\\" \");\n            if (theme.equals(current))\n                buf.append(\"checked=\\\"checked\\\" \");\n            buf.append(\"value=\\\"\").append(theme).append(\"\\\">\").append(_(theme)).append(\"<br>\\n\");\n        }\n        return buf.toString();\n    }","id":79442,"modified_method":"public String getSettings() {\n        StringBuilder buf = new StringBuilder(512);\n        String current = _context.readConfigFile(CSSHelper.THEME_CONFIG_FILE).getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        Set<String> themes = themeSet();\n        for (String theme : themes) {\n            buf.append(\"<input type=\\\"radio\\\" class=\\\"optbox\\\" name=\\\"theme\\\" \");\n            if (theme.equals(current))\n                buf.append(\"checked=\\\"checked\\\" \");\n            buf.append(\"value=\\\"\").append(theme).append(\"\\\">\").append(_(theme)).append(\"<br>\\n\");\n        }\n        return buf.toString();\n    }","commit_id":"5d5a3b80e55df799c399049892759f2e055d8811","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override public boolean isCacheable() {\n        for (DocSet set : sets) {\n            if (!set.isCacheable()) {\n                return false;\n            }\n        }\n        return true;\n    }","id":79443,"modified_method":"@Override public boolean isCacheable() {\n        // not cacheable, the reason is that by default, when constructing the filter, it is not cacheable,\n        // so if someone wants it to be cacheable, we might as well construct a cached version of the result\n        return false;\n//        for (DocSet set : sets) {\n//            if (!set.isCacheable()) {\n//                return false;\n//            }\n//        }\n//        return true;\n    }","commit_id":"ca67c12de50a4f0f3891214d869f2d5f8b379915","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        if (filters.size() == 1) {\n            return DocSets.convert(reader, filters.get(0).getDocIdSet(reader));\n        }\n        List<DocSet> sets = Lists.newArrayListWithExpectedSize(filters.size());\n        for (Filter filter : filters) {\n            sets.add(DocSets.convert(reader, filter.getDocIdSet(reader)));\n        }\n        return new AndDocSet(sets);\n    }","id":79444,"modified_method":"@Override public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        if (filters.size() == 1) {\n            return filters.get(0).getDocIdSet(reader);\n        }\n        List sets = Lists.newArrayListWithExpectedSize(filters.size());\n        boolean allAreDocSet = true;\n        for (Filter filter : filters) {\n            DocIdSet set = filter.getDocIdSet(reader);\n            if (!(set instanceof DocSet)) {\n                allAreDocSet = false;\n            }\n            sets.add(set);\n        }\n        if (allAreDocSet) {\n            return new AndDocSet(sets);\n        }\n        return new AndDocIdSet(sets);\n    }","commit_id":"ca67c12de50a4f0f3891214d869f2d5f8b379915","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public boolean isCacheable() {\n        return set.isCacheable();\n    }","id":79445,"modified_method":"@Override public boolean isCacheable() {\n        // not cacheable, the reason is that by default, when constructing the filter, it is not cacheable,\n        // so if someone wants it to be cacheable, we might as well construct a cached version of the result\n        return false;\n//        return set.isCacheable();\n    }","commit_id":"ca67c12de50a4f0f3891214d869f2d5f8b379915","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        return new NotDocSet(DocSets.convert(reader, filter.getDocIdSet(reader)), reader.maxDoc());\n    }","id":79446,"modified_method":"@Override public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        DocIdSet set = filter.getDocIdSet(reader);\n        if (set instanceof DocSet) {\n            return new NotDocSet((DocSet) set, reader.maxDoc());\n        }\n        return new NotDocIdSet(set, reader.maxDoc());\n    }","commit_id":"ca67c12de50a4f0f3891214d869f2d5f8b379915","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public boolean get(int doc) throws IOException {\n        for (DocSet s : sets) {\n            if (s.get(doc)) return true;\n        }\n        return false;\n    }","id":79447,"modified_method":"@Override public boolean get(int doc) throws IOException {\n        // not cacheable, the reason is that by default, when constructing the filter, it is not cacheable,\n        // so if someone wants it to be cacheable, we might as well construct a cached version of the result\n        return false;\n//        for (DocSet s : sets) {\n//            if (s.get(doc)) return true;\n//        }\n//        return false;\n    }","commit_id":"ca67c12de50a4f0f3891214d869f2d5f8b379915","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        if (filters.size() == 1) {\n            return DocSets.convert(reader, filters.get(0).getDocIdSet(reader));\n        }\n        List<DocSet> sets = Lists.newArrayListWithExpectedSize(filters.size());\n        for (Filter filter : filters) {\n            sets.add(DocSets.convert(reader, filter.getDocIdSet(reader)));\n        }\n        return new OrDocSet(sets);\n    }","id":79448,"modified_method":"@Override public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        if (filters.size() == 1) {\n            return filters.get(0).getDocIdSet(reader);\n        }\n        List sets = Lists.newArrayListWithExpectedSize(filters.size());\n        boolean allAreDocSet = true;\n        for (Filter filter : filters) {\n            DocIdSet set = filter.getDocIdSet(reader);\n            if (!(set instanceof DocSet)) {\n                allAreDocSet = false;\n            }\n            sets.add(set);\n        }\n        if (allAreDocSet) {\n            return new OrDocSet(sets);\n        }\n        return new OrDocIdSet(sets);\n    }","commit_id":"ca67c12de50a4f0f3891214d869f2d5f8b379915","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public CountDownConsumer(int countDown, @NotNull AsyncPromise<Void> promise) {\n    this.countDown = countDown;\n    this.promise = promise;\n  }","id":79449,"modified_method":"public CountDownConsumer(int countDown, @NotNull AsyncPromise<T> promise, @Nullable T totalResult) {\n    this.countDown = countDown;\n    this.promise = promise;\n    this.totalResult = totalResult;\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void consume(Void t) {\n    if (--countDown == 0) {\n      promise.setResult(null);\n    }\n  }","id":79450,"modified_method":"@Override\n  public void consume(T t) {\n    if (--countDown == 0) {\n      promise.setResult(totalResult);\n    }\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static Promise<Void> all(@NotNull Collection<Promise<?>> promises) {\n    if (promises.isEmpty()) {\n      return DONE;\n    }\n\n    final AsyncPromise<Void> totalPromise = new AsyncPromise<Void>();\n    Consumer done = new CountDownConsumer(promises.size(), totalPromise);\n    Consumer<Throwable> rejected = new Consumer<Throwable>() {\n      @Override\n      public void consume(Throwable error) {\n        if (totalPromise.state == AsyncPromise.State.PENDING) {\n          totalPromise.setError(error);\n        }\n      }\n    };\n\n    for (Promise<?> promise : promises) {\n      //noinspection unchecked\n      promise.done(done);\n      promise.rejected(rejected);\n    }\n    return totalPromise;\n  }","id":79451,"modified_method":"@NotNull\n  public static Promise<Void> all(@NotNull Collection<Promise<?>> promises) {\n    return all(promises, null);\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AsyncResult<Content> loadContent(@NotNull final Condition<XValueGroup> groupContentResolveCondition, @NotNull final Condition<VariableView> valueSubContentResolveCondition) {\n    assert content == null;\n\n    final AsyncResult<Content> compoundResult = new AsyncResult<Content>();\n    content = new Content();\n    result.doWhenDone(new Consumer<XValueChildrenList>() {\n      @Override\n      public void consume(XValueChildrenList children) {\n        ActionCallback.Chunk chunk = new ActionCallback.Chunk();\n        resolveGroups(children.getTopGroups(), content.topGroups, chunk);\n\n        for (int i = 0; i < children.size(); i++) {\n          XValue value = children.getValue(i);\n          TestValueNode node = new TestValueNode();\n          node.myName = children.getName(i);\n          value.computePresentation(node, XValuePlace.TREE);\n          content.values.add(node);\n          chunk.add(node.getResult());\n\n          // myHasChildren could be not computed yet\n          if (value instanceof VariableView && ((VariableView)value).getValue() instanceof ObjectValue && valueSubContentResolveCondition.value((VariableView)value)) {\n            chunk.add(node.loadChildren(value));\n          }\n        }\n\n        resolveGroups(children.getBottomGroups(), content.bottomGroups, chunk);\n\n        chunk.create().doWhenDone(new Runnable() {\n          @Override\n          public void run() {\n            compoundResult.setDone(content);\n          }\n        }).notifyWhenRejected(compoundResult);\n      }\n\n      private void resolveGroups(@NotNull List<XValueGroup> valueGroups, @NotNull List<TestCompositeNode> resultNodes, @NotNull ActionCallback.Chunk chunk) {\n        for (XValueGroup group : valueGroups) {\n          TestCompositeNode node = new TestCompositeNode(group);\n          boolean computeChildren = groupContentResolveCondition.value(group);\n          if (computeChildren) {\n            group.computeChildren(node);\n          }\n          resultNodes.add(node);\n          if (computeChildren) {\n            chunk.add(node.loadContent(Conditions.<XValueGroup>alwaysFalse(), valueSubContentResolveCondition));\n          }\n        }\n      }\n    }).notifyWhenRejected(compoundResult);\n    return compoundResult;\n  }","id":79452,"modified_method":"@NotNull\n  public Promise<Content> loadContent(@NotNull final Condition<XValueGroup> groupContentResolveCondition, @NotNull final Condition<VariableView> valueSubContentResolveCondition) {\n    assert content == null;\n\n    content = new Content();\n    return result.then(new AsyncFunction<XValueChildrenList, Content>() {\n      private void resolveGroups(@NotNull List<XValueGroup> valueGroups, @NotNull List<TestCompositeNode> resultNodes, @NotNull List<Promise<?>> promises) {\n        for (XValueGroup group : valueGroups) {\n          TestCompositeNode node = new TestCompositeNode(group);\n          boolean computeChildren = groupContentResolveCondition.value(group);\n          if (computeChildren) {\n            group.computeChildren(node);\n          }\n          resultNodes.add(node);\n          if (computeChildren) {\n            promises.add(node.loadContent(Conditions.<XValueGroup>alwaysFalse(), valueSubContentResolveCondition));\n          }\n        }\n      }\n\n      @NotNull\n      @Override\n      public Promise<Content> fun(XValueChildrenList list) {\n        List<Promise<?>> promises = new ArrayList<Promise<?>>();\n        resolveGroups(children.getTopGroups(), content.topGroups, promises);\n\n        for (int i = 0; i < children.size(); i++) {\n          XValue value = children.getValue(i);\n          TestValueNode node = new TestValueNode();\n          node.myName = children.getName(i);\n          value.computePresentation(node, XValuePlace.TREE);\n          content.values.add(node);\n          promises.add(node.getResult());\n\n          // myHasChildren could be not computed yet\n          if (value instanceof VariableView && ((VariableView)value).getValue() instanceof ObjectValue && valueSubContentResolveCondition.value((VariableView)value)) {\n            promises.add(node.loadChildren(value));\n          }\n        }\n\n        resolveGroups(children.getBottomGroups(), content.bottomGroups, promises);\n\n        return Promise.all(promises, content);\n      }\n    });\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void tooManyChildren(int remaining) {\n    result.setDone(children);\n  }","id":79453,"modified_method":"@Override\n  public void tooManyChildren(int remaining) {\n    result.setResult(children);\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void addChildren(@NotNull XValueChildrenList children, boolean last) {\n    for (XValueGroup group : children.getTopGroups()) {\n      this.children.addTopGroup(group);\n    }\n    for (int i = 0; i < children.size(); i++) {\n      this.children.add(children.getName(i), children.getValue(i));\n    }\n    for (XValueGroup group : children.getBottomGroups()) {\n      this.children.addBottomGroup(group);\n    }\n\n    if (last) {\n      result.setDone(this.children);\n    }\n  }","id":79454,"modified_method":"@Override\n  public void addChildren(@NotNull XValueChildrenList children, boolean last) {\n    for (XValueGroup group : children.getTopGroups()) {\n      this.children.addTopGroup(group);\n    }\n    for (int i = 0; i < children.size(); i++) {\n      this.children.add(children.getName(i), children.getValue(i));\n    }\n    for (XValueGroup group : children.getBottomGroups()) {\n      this.children.addBottomGroup(group);\n    }\n\n    if (last) {\n      result.setResult(this.children);\n    }\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AsyncResult<XValueChildrenList> getResult() {\n    return result;\n  }","id":79455,"modified_method":"@NotNull\n  public Promise<XValueChildrenList> getResult() {\n    return result;\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setErrorMessage(@NotNull String errorMessage) {\n    result.reject(errorMessage);\n  }","id":79456,"modified_method":"@Override\n  public void setErrorMessage(@NotNull String errorMessage) {\n    result.setError(Promise.createError(errorMessage));\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AsyncResult<XTestValueNode> getResult() {\n    return result;\n  }","id":79457,"modified_method":"@NotNull\n  public Promise<XTestValueNode> getResult() {\n    return result;\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public AsyncResult<Content> loadChildren(@NotNull XValue value) {\n    TestCompositeNode childrenNode = new TestCompositeNode();\n    value.computeChildren(childrenNode);\n    return childrenNode.loadContent(Conditions.<XValueGroup>alwaysFalse(), Conditions.<VariableView>alwaysFalse()).doWhenDone(new Consumer<Content>() {\n      @Override\n      public void consume(Content content) {\n        children = content;\n      }\n    });\n  }","id":79458,"modified_method":"@NotNull\n  public Promise<Content> loadChildren(@NotNull XValue value) {\n    TestCompositeNode childrenNode = new TestCompositeNode();\n    value.computeChildren(childrenNode);\n    return childrenNode.loadContent(Conditions.<XValueGroup>alwaysFalse(), Conditions.<VariableView>alwaysFalse())\n      .done(new Consumer<Content>() {\n        @Override\n        public void consume(Content content) {\n          children = content;\n        }\n      });\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void applyPresentation(@Nullable Icon icon, @NotNull XValuePresentation valuePresentation, boolean hasChildren) {\n    super.applyPresentation(icon, valuePresentation, hasChildren);\n\n    result.setDone(this);\n  }","id":79459,"modified_method":"@Override\n  public void applyPresentation(@Nullable Icon icon, @NotNull XValuePresentation valuePresentation, boolean hasChildren) {\n    super.applyPresentation(icon, valuePresentation, hasChildren);\n\n    result.setResult(this);\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void close(@Nullable String message, @NotNull ConnectionStatus status) {\n    if (!closed.compareAndSet(false, true)) {\n      return;\n    }\n\n    opened.setError(Promise.createError(\"closed\"));\n    setState(status, message);\n    Disposer.dispose(this, false);\n  }","id":79460,"modified_method":"public final void close(@Nullable String message, @NotNull ConnectionStatus status) {\n    if (!closed.compareAndSet(false, true)) {\n      return;\n    }\n\n    if (opened.getState() == Promise.State.PENDING) {\n      opened.setError(Promise.createError(\"closed\"));\n    }\n    setState(status, message);\n    Disposer.dispose(this, false);\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Promise<Void> detachAndClose() {\n    opened.setError(Promise.createError(\"detached and closed\"));\n\n    Vm currentVm = vm;\n    Promise<Void> callback;\n    if (currentVm == null) {\n      callback = Promise.DONE;\n    }\n    else {\n      vm = null;\n      callback = currentVm.getAttachStateManager().detach();\n    }\n    close(null, ConnectionStatus.DISCONNECTED);\n    return callback;\n  }","id":79461,"modified_method":"@NotNull\n  public Promise<Void> detachAndClose() {\n    if (opened.getState() == Promise.State.PENDING) {\n      opened.setError(Promise.createError(\"detached and closed\"));\n    }\n\n    Vm currentVm = vm;\n    Promise<Void> callback;\n    if (currentVm == null) {\n      callback = Promise.DONE;\n    }\n    else {\n      vm = null;\n      callback = currentVm.getAttachStateManager().detach();\n    }\n    close(null, ConnectionStatus.DISCONNECTED);\n    return callback;\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void addListener(@NotNull SocketConnectionListener listener, @NotNull Disposable parentDisposable) {\n    connectionDispatcher.addListener(listener, parentDisposable);\n  }","id":79462,"modified_method":"@Override\n  public void addListener(@NotNull SocketConnectionListener listener) {\n    connectionDispatcher.addListener(listener);\n  }","commit_id":"216e32ca0c1c580d3cb2c4272709159dbdb036f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Package[] getPackages() {\r\n        Package[] pkgs = new Package[this.pkgRegistryMap.size()];\r\n        int i = 0;\r\n        String errors = getErrors().toString();\r\n        for ( PackageRegistry pkgRegistry : this.pkgRegistryMap.values() ) {\r\n            Package pkg = pkgRegistry.getPackage();\r\n            pkg.getDialectRuntimeRegistry().reloadDirty();\r\n            pkg.setError( errors );\r\n            pkgs[i++] = pkg;\r\n        }\r\n\r\n        return pkgs;\r\n    }","id":79463,"modified_method":"public Package[] getPackages() {\r\n        Package[] pkgs = new Package[this.pkgRegistryMap.size()];\r\n        int i = 0;\r\n        String errors = null;\r\n        if (!getErrors().isEmpty()) {\r\n        \terrors = getErrors().toString();\r\n        }\r\n        for ( PackageRegistry pkgRegistry : this.pkgRegistryMap.values() ) {\r\n            Package pkg = pkgRegistry.getPackage();\r\n            pkg.getDialectRuntimeRegistry().reloadDirty();\r\n            if (errors != null) {\r\n            \tpkg.setError( errors );\r\n            }\r\n            pkgs[i++] = pkg;\r\n        }\r\n\r\n        return pkgs;\r\n    }","commit_id":"cb627dada6c4b9094049772c1890c4d8e3506536","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public int available() throws IOException\n\t\t{\n\t\t\tSWC_LOG.trace(\"available()\");\n\n\t\t\treturn m_stream.available();\n\t\t}","id":79464,"modified_method":"public int available() throws IOException\n\t\t{\n            if (SWC_LOG.isDebugEnabled()) {\n                SWC_LOG.debug(\"available()\");\n            }\n\t\t\treturn m_stream.available();\n\t\t}","commit_id":"9d3c63cfaff3ef975289c786b1b98944f6efb335","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void close() throws IOException\n\t\t{\n\t\t\tSWC_LOG.trace(\"close()\");\n\n\t\t\tif (m_stream != null) m_stream.close();\n\t\t\tm_stream = null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (null != m_result)\n\t\t\t\t{\n\t\t\t\t\tm_result.close();\n\t\t\t\t}\n\t\t\t\tm_result = null;\n\t\t\t}\n\t\t\tcatch (SQLException any)\n\t\t\t{\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (null != m_pstmt)\n\t\t\t\t{\n\t\t\t\t\tm_pstmt.close();\n\t\t\t\t}\n\t\t\t\tm_pstmt = null;\n\t\t\t}\n\t\t\tcatch (SQLException any)\n\t\t\t{\n\t\t\t}\n\n\t\t\tif (null != m_conn)\n\t\t\t{\n\t\t\t\treturnConnection(m_conn);\n\t\t\t\tm_conn = null;\n\t\t\t}\n\t\t}","id":79465,"modified_method":"public void close() throws IOException {\n            if (SWC_LOG.isDebugEnabled()) {\n                SWC_LOG.debug(\"close()\");\n            }\n            try {\n                if (m_stream != null) {\n                    m_stream.close();\n                }\n                m_stream = null;\n            } catch (Exception e) {\n            }\n            try {\n                if (null != m_result) {\n                    m_result.close();\n                }\n                m_result = null;\n            } catch (Exception e) {\n            }\n            try {\n                if (null != m_pstmt) {\n                    m_pstmt.close();\n                }\n                m_pstmt = null;\n            } catch (Exception e) {\n            }\n            if (null != m_conn) {\n                returnConnection(m_conn);\n                m_conn = null;\n            }\n        }","commit_id":"9d3c63cfaff3ef975289c786b1b98944f6efb335","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean markSupported()\n\t\t{\n\t\t\tSWC_LOG.trace(\"markSupported()\");\n\n\t\t\treturn m_stream.markSupported();\n\t\t}","id":79466,"modified_method":"public boolean markSupported()\n\t\t{\n            if (SWC_LOG.isDebugEnabled()) {\n                SWC_LOG.debug(\"markSupported()\");\n            }\n\t\t\treturn m_stream.markSupported();\n\t\t}","commit_id":"9d3c63cfaff3ef975289c786b1b98944f6efb335","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public synchronized void reset() throws IOException\n\t\t{\n\t\t\tSWC_LOG.trace(\"reset()\");\n\n\t\t\tm_stream.reset();\n\t\t}","id":79467,"modified_method":"public synchronized void reset() throws IOException\n\t\t{\n            if (SWC_LOG.isDebugEnabled()) {\n                SWC_LOG.debug(\"reset()\");\n            }\n\t\t\tm_stream.reset();\n\t\t}","commit_id":"9d3c63cfaff3ef975289c786b1b98944f6efb335","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected void finalize()\n\t\t{\n\t\t\tSWC_LOG.debug(\"finalize()\");\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tclose();\n\t\t\t}\n\t\t\tcatch (IOException any)\n\t\t\t{\n\t\t\t\tLOG.error(any.getMessage(), any);\n\t\t\t}\n\t\t}","id":79468,"modified_method":"protected void finalize() {\n            if (SWC_LOG.isDebugEnabled()) {\n                SWC_LOG.debug(\"finalize()\");\n            }\n            try {\n                close();\n            } catch (IOException any) {\n                LOG.error(any.getMessage(), any);\n            }\n        }","commit_id":"9d3c63cfaff3ef975289c786b1b98944f6efb335","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public int read() throws IOException\n\t\t{\n\t\t\tSWC_LOG.trace(\"read()\");\n\n\t\t\treturn m_stream.read();\n\t\t}","id":79469,"modified_method":"public int read() throws IOException\n\t\t{\n            if (SWC_LOG.isDebugEnabled()) {\n                SWC_LOG.debug(\"read()\");\n            }\n\t\t\treturn m_stream.read();\n\t\t}","commit_id":"9d3c63cfaff3ef975289c786b1b98944f6efb335","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private List<SNode> createOutputNodesForTemplateNodeWithMacro(NodeMacro nodeMacro, SNode templateNode, SNode inputNode, int nodeMacrosToSkip, boolean registerTopOutput) throws DismissTopMappingRuleException {\n    GenerationTracer generationTracer = myGenerator.getGeneratorSessionContext().getGenerationTracer();\n    List<SNode> outputNodes = new ArrayList<SNode>();\n    String mappingName = GeneratorUtil.getMappingName(nodeMacro, null);\n\n    if (nodeMacro instanceof LoopMacro) {\n      // $LOOP$\n      List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n      for (SNode newInputNode : newInputNodes) {\n        generationTracer.pushInputNode(newInputNode);\n        try {\n          boolean inputChanged = (newInputNode != inputNode);\n          if (inputChanged) {\n            pushInputHistory(inputNode, mappingName);\n          }\n          List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n          if (inputChanged) {\n            popInputHistory();\n          } else if (registerTopOutput) {\n            myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n          }\n        } finally {\n          generationTracer.closeInputNode(newInputNode);\n        }\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof CopySrcNodeMacro || nodeMacro instanceof CopySrcListMacro) {\n      // $COPY-SRC$ / $COPY-SRCL$\n      List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n      for (SNode newInputNode : newInputNodes) {\n        List<SNode> _outputNodes = copyNodeFromInputNode(mappingName, templateNode, newInputNode);\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof IfMacro) {\n      // $IF$\n      List<SNode> _outputNodes = null;\n      if (MacroUtil.checkConditionForIfMacro(inputNode, (IfMacro) nodeMacro, myGenerator)) {\n        _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, inputNode, nodeMacrosToSkip + 1, false);\n      } else {\n        // alternative consequence\n        RuleConsequence altConsequence = ((IfMacro) nodeMacro).getAlternativeConsequence();\n        if (altConsequence != null) {\n          Pair<SNode, String> nodeAndMappingName = GeneratorUtil.getTemplateNodeFromRuleConsequence(altConsequence, inputNode, nodeMacro.getNode(), myGenerator);\n          if (nodeAndMappingName == null) {\n            myGenerator.showErrorMessage(inputNode, null, nodeMacro.getNode(), \"error processing $IF$/alternative\");\n            return null;\n          }\n          SNode altTemplateNode = nodeAndMappingName.o1;\n          if (nodeAndMappingName.o2 != null) {\n            mappingName = nodeAndMappingName.o2;\n          }\n          _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, altTemplateNode, inputNode, false);\n        }\n      }\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      if (registerTopOutput) {\n        myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof MapSrcNodeMacro || nodeMacro instanceof MapSrcListMacro) {\n      // $MAP-SRC$ or $MAP-SRCL$\n      MapSrcMacro_MapperFunction macro_mapperFunction;\n      String mapperId; // old\n      if (nodeMacro instanceof MapSrcNodeMacro) {\n        macro_mapperFunction = ((MapSrcNodeMacro) nodeMacro).getMapperFunction();\n        mapperId = ((MapSrcNodeMacro) nodeMacro).getSourceNodeMapperId();\n      } else {\n        macro_mapperFunction = ((MapSrcListMacro) nodeMacro).getMapperFunction();\n        mapperId = ((MapSrcListMacro) nodeMacro).getSourceNodeMapperId();\n      }\n\n      List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n      for (SNode newInputNode : newInputNodes) {\n        generationTracer.pushInputNode(newInputNode);\n        try {\n          if (mapperId != null || macro_mapperFunction != null) {\n            SNode childToReplaceLater = SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(), myOutputModel, myGenerator.getScope(), false);\n            generationTracer.pushOutputNodeToReplaceLater(childToReplaceLater);\n            outputNodes.add(childToReplaceLater);\n            // execute the 'mapper' function later\n            myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(nodeMacro, childToReplaceLater, newInputNode, myGenerator);\n          } else {\n            boolean inputChanged = (newInputNode != inputNode);\n            if (inputChanged) {\n              pushInputHistory(inputNode, mappingName);\n            }\n            List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n            if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n            if (inputChanged) {\n              popInputHistory();\n            } else if (registerTopOutput) {\n              myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n            }\n          }\n        } finally {\n          generationTracer.closeInputNode(newInputNode);\n        }\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof SwitchMacro) {\n      // $SWITCH$\n      TemplateSwitch templateSwitch = ((SwitchMacro) nodeMacro).getTemplateSwitch();\n      if (templateSwitch == null) {\n        myGenerator.showErrorMessage(inputNode, nodeMacro.getNode(), \"error processing $SWITCH$ - bad TemplateSwitch reference\");\n        return null;\n      }\n\n      SNode newInputNode = MacroUtil.getNewInputNode(nodeMacro, inputNode, myGenerator);\n      if (newInputNode != null) {\n        generationTracer.pushInputNode(newInputNode);\n        generationTracer.pushSwitch(templateSwitch.getNode());\n\n        RuleConsequence consequenceForCase = (RuleConsequence) myGenerator.getConsequenceForSwitchCase(newInputNode, templateSwitch);\n        SNode templateNodeForCase = null;\n        if (consequenceForCase != null) {\n          Pair<SNode, String> nodeAndMappingName = GeneratorUtil.getTemplateNodeFromRuleConsequence(consequenceForCase, newInputNode, nodeMacro.getNode(), myGenerator);\n          if (nodeAndMappingName == null) {\n            myGenerator.showErrorMessage(newInputNode, nodeMacro.getNode(), consequenceForCase.getNode(), \"error processing $SWITCH$\");\n            return null;\n          }\n          templateNodeForCase = nodeAndMappingName.o1;\n          if (nodeAndMappingName.o2 != null) {\n            mappingName = nodeAndMappingName.o2;\n          }\n        } else {\n          // for back compatibility\n          generationTracer.pushRule(templateSwitch.getNode());\n          TemplateDeclaration templateForSwitchCase = myGenerator.getTemplateForSwitchCase_deprecated(newInputNode, templateSwitch);\n          if (templateForSwitchCase != null) {\n            TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(templateForSwitchCase, newInputNode, nodeMacro.getNode(), myGenerator);\n            if (fragment != null) {\n              mappingName = GeneratorUtil.getMappingName(fragment, mappingName);\n              templateNodeForCase = fragment.getParent().getNode();\n            }\n          }\n        }\n\n        boolean inputChanged = (newInputNode != inputNode);\n        if (inputChanged) {\n          pushInputHistory(inputNode, mappingName);\n        }\n        List<SNode> _outputNodes;\n        if (templateNodeForCase != null) {\n          _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, templateNodeForCase, newInputNode, inputChanged);\n        } else {\n          // no switch-case found for the inputNode - continue with templateNode under the $switch$\n          _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n        }\n\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        if (inputChanged) {\n          popInputHistory();\n        } else if (registerTopOutput) {\n          myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n        }\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof IncludeMacro) {\n      // $INCLUDE$\n      IncludeMacro includeMacro = (IncludeMacro) nodeMacro;\n      SNode newInputNode = MacroUtil.getNewInputNode(nodeMacro, inputNode, myGenerator);\n      if (newInputNode != null) {\n        generationTracer.pushInputNode(newInputNode);\n        TemplateDeclaration includeTemplate = includeMacro.getIncludeTemplate();\n        if (includeTemplate == null) {\n          myGenerator.showErrorMessage(newInputNode, null, nodeMacro.getNode(), \"error processing $INCLIDE$ : no 'include template'\");\n          return null;\n        }\n        generationTracer.pushTemplateNode(includeTemplate.getNode());\n        TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(includeTemplate, newInputNode, nodeMacro.getNode(), myGenerator);\n        if (fragment == null) {\n          myGenerator.showErrorMessage(newInputNode, null, nodeMacro.getNode(), \"error processing $INCLIDE$\");\n          return null;\n        }\n        SNode templateForInclude = fragment.getParent().getNode();\n        mappingName = GeneratorUtil.getMappingName(fragment, mappingName);\n        boolean inputChanged = (newInputNode != inputNode);\n        if (inputChanged) {\n          pushInputHistory(inputNode, mappingName);\n        }\n        List<SNode> _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, templateForInclude, newInputNode, inputChanged);\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        if (inputChanged) {\n          popInputHistory();\n        } else if (registerTopOutput) {\n          myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n        }\n      } // for (SNode newInputNode : newInputNodes)\n      return outputNodes;\n    }\n\n    // $$\n    List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n    for (SNode newInputNode : newInputNodes) {\n      generationTracer.pushInputNode(newInputNode);\n      try {\n        boolean inputChanged = (newInputNode != inputNode);\n        if (inputChanged) {\n          pushInputHistory(inputNode, mappingName);\n        }\n        List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        if (inputChanged) {\n          popInputHistory();\n        } else if (registerTopOutput) {\n          myGenerator.addTopOutputNodesByInputNode(inputNode, outputNodes);\n        }\n      } finally {\n        generationTracer.closeInputNode(newInputNode);\n      }\n    }\n    return outputNodes;\n  }","id":79470,"modified_method":"private List<SNode> createOutputNodesForTemplateNodeWithMacro(NodeMacro nodeMacro, SNode templateNode, SNode inputNode, int nodeMacrosToSkip, boolean registerTopOutput) throws DismissTopMappingRuleException {\n    GenerationTracer generationTracer = myGenerator.getGeneratorSessionContext().getGenerationTracer();\n    List<SNode> outputNodes = new ArrayList<SNode>();\n    String mappingName = GeneratorUtil.getMappingName(nodeMacro, null);\n\n    if (nodeMacro instanceof LoopMacro) {\n      // $LOOP$\n      List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != inputNode);\n        if (inputChanged) {\n          pushInputHistory(inputNode, mappingName);\n          generationTracer.pushInputNode(newInputNode);\n        }\n        try {\n          List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n          if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n          if (registerTopOutput && !inputChanged) {\n            myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n          }\n        } finally {\n          if (inputChanged) {\n            popInputHistory();\n            generationTracer.closeInputNode(newInputNode);\n          }\n        }\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof CopySrcNodeMacro || nodeMacro instanceof CopySrcListMacro) {\n      // $COPY-SRC$ / $COPY-SRCL$\n      List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n      for (SNode newInputNode : newInputNodes) {\n        List<SNode> _outputNodes = copyNodeFromInputNode(mappingName, templateNode, newInputNode);\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof IfMacro) {\n      // $IF$\n      List<SNode> _outputNodes = null;\n      if (MacroUtil.checkConditionForIfMacro(inputNode, (IfMacro) nodeMacro, myGenerator)) {\n        _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, inputNode, nodeMacrosToSkip + 1, false);\n      } else {\n        // alternative consequence\n        RuleConsequence altConsequence = ((IfMacro) nodeMacro).getAlternativeConsequence();\n        if (altConsequence != null) {\n          Pair<SNode, String> nodeAndMappingName = GeneratorUtil.getTemplateNodeFromRuleConsequence(altConsequence, inputNode, nodeMacro.getNode(), myGenerator);\n          if (nodeAndMappingName == null) {\n            myGenerator.showErrorMessage(inputNode, null, nodeMacro.getNode(), \"error processing $IF$/alternative\");\n            return null;\n          }\n          SNode altTemplateNode = nodeAndMappingName.o1;\n          if (nodeAndMappingName.o2 != null) {\n            mappingName = nodeAndMappingName.o2;\n          }\n          _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, altTemplateNode, inputNode, false);\n        }\n      }\n      if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n      if (registerTopOutput) {\n        myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof MapSrcNodeMacro || nodeMacro instanceof MapSrcListMacro) {\n      // $MAP-SRC$ or $MAP-SRCL$\n      MapSrcMacro_MapperFunction macro_mapperFunction;\n      String mapperId; // old\n      if (nodeMacro instanceof MapSrcNodeMacro) {\n        macro_mapperFunction = ((MapSrcNodeMacro) nodeMacro).getMapperFunction();\n        mapperId = ((MapSrcNodeMacro) nodeMacro).getSourceNodeMapperId();\n      } else {\n        macro_mapperFunction = ((MapSrcListMacro) nodeMacro).getMapperFunction();\n        mapperId = ((MapSrcListMacro) nodeMacro).getSourceNodeMapperId();\n      }\n\n      List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n      for (SNode newInputNode : newInputNodes) {\n        boolean inputChanged = (newInputNode != inputNode);\n        if (inputChanged) {\n          pushInputHistory(newInputNode, mappingName);\n          generationTracer.pushInputNode(newInputNode);\n        }\n        try {\n          if (mapperId != null || macro_mapperFunction != null) {\n            SNode childToReplaceLater = SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(), myOutputModel, myGenerator.getScope(), false);\n            generationTracer.pushOutputNodeToReplaceLater(childToReplaceLater);\n            outputNodes.add(childToReplaceLater);\n            // execute the 'mapper' function later\n            // !!! new input node is in history\n            myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(nodeMacro, childToReplaceLater, newInputNode, myGenerator);\n          } else {\n            List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n            if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n            if (registerTopOutput && !inputChanged) {\n              myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n            }\n          }\n        } finally {\n          if (inputChanged) {\n            popInputHistory();\n            generationTracer.closeInputNode(newInputNode);\n          }\n        }\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof SwitchMacro) {\n      // $SWITCH$\n      TemplateSwitch templateSwitch = ((SwitchMacro) nodeMacro).getTemplateSwitch();\n      if (templateSwitch == null) {\n        myGenerator.showErrorMessage(inputNode, nodeMacro.getNode(), \"error processing $SWITCH$ - bad TemplateSwitch reference\");\n        return null;\n      }\n\n      SNode newInputNode = MacroUtil.getNewInputNode(nodeMacro, inputNode, myGenerator);\n      if (newInputNode == null) {\n        return outputNodes; // skip template\n      }\n\n      boolean inputChanged = (newInputNode != inputNode);\n      if (inputChanged) {\n        pushInputHistory(inputNode, mappingName);\n        generationTracer.pushInputNode(newInputNode);\n      }\n      generationTracer.pushSwitch(templateSwitch.getNode());\n\n      try {\n        RuleConsequence consequenceForCase = (RuleConsequence) myGenerator.getConsequenceForSwitchCase(newInputNode, templateSwitch);\n        SNode templateNodeForCase = null;\n        if (consequenceForCase != null) {\n          Pair<SNode, String> nodeAndMappingName = GeneratorUtil.getTemplateNodeFromRuleConsequence(consequenceForCase, newInputNode, nodeMacro.getNode(), myGenerator);\n          if (nodeAndMappingName == null) {\n            myGenerator.showErrorMessage(newInputNode, nodeMacro.getNode(), consequenceForCase.getNode(), \"error processing $SWITCH$\");\n            return null;\n          }\n          templateNodeForCase = nodeAndMappingName.o1;\n          if (nodeAndMappingName.o2 != null) {\n            mappingName = nodeAndMappingName.o2;\n          }\n        } else {\n          // for back compatibility\n          generationTracer.pushRule(templateSwitch.getNode());\n          TemplateDeclaration templateForSwitchCase = myGenerator.getTemplateForSwitchCase_deprecated(newInputNode, templateSwitch);\n          if (templateForSwitchCase != null) {\n            TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(templateForSwitchCase, newInputNode, nodeMacro.getNode(), myGenerator);\n            if (fragment != null) {\n              mappingName = GeneratorUtil.getMappingName(fragment, mappingName);\n              templateNodeForCase = fragment.getParent().getNode();\n            }\n          }\n        }\n\n        List<SNode> _outputNodes;\n        if (templateNodeForCase != null) {\n          _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, templateNodeForCase, newInputNode, inputChanged);\n        } else {\n          // no switch-case found for the inputNode - continue with templateNode under the $switch$\n          _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n        }\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        if (registerTopOutput && !inputChanged) {\n          myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          popInputHistory();\n          generationTracer.closeInputNode(newInputNode);\n        }\n      }\n      return outputNodes;\n\n    } else if (nodeMacro instanceof IncludeMacro) {\n      // $INCLUDE$\n      SNode newInputNode = MacroUtil.getNewInputNode(nodeMacro, inputNode, myGenerator);\n      if (newInputNode == null) {\n        return outputNodes; // skip template\n      }\n\n      IncludeMacro includeMacro = (IncludeMacro) nodeMacro;\n      TemplateDeclaration includeTemplate = includeMacro.getIncludeTemplate();\n      if (includeTemplate == null) {\n        myGenerator.showErrorMessage(newInputNode, null, nodeMacro.getNode(), \"error processing $INCLIDE$ : no 'include template'\");\n        return null;\n      }\n      TemplateFragment fragment = GeneratorUtil.getFragmentFromTemplate(includeTemplate, newInputNode, nodeMacro.getNode(), myGenerator);\n      if (fragment == null) {\n        myGenerator.showErrorMessage(newInputNode, null, nodeMacro.getNode(), \"error processing $INCLIDE$\");\n        return null;\n      }\n\n      boolean inputChanged = (newInputNode != inputNode);\n      if (inputChanged) {\n        pushInputHistory(inputNode, mappingName);\n        generationTracer.pushInputNode(newInputNode);\n      }\n      generationTracer.pushTemplateNode(includeTemplate.getNode());\n\n      try {\n        SNode templateForInclude = fragment.getParent().getNode();\n        mappingName = GeneratorUtil.getMappingName(fragment, mappingName);\n        List<SNode> _outputNodes = createOutputNodesForExternalTemplateNode(mappingName, templateForInclude, newInputNode, inputChanged);\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        if (registerTopOutput && !inputChanged) {\n          myGenerator.addTopOutputNodesByInputNode(inputNode, _outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          popInputHistory();\n          generationTracer.closeInputNode(newInputNode);\n        }\n      }\n\n      return outputNodes;\n    }\n\n    // $$\n    List<SNode> newInputNodes = MacroUtil.getNewInputNodes(nodeMacro, inputNode, myGenerator);\n    for (SNode newInputNode : newInputNodes) {\n      boolean inputChanged = (newInputNode != inputNode);\n      if (inputChanged) {\n        pushInputHistory(inputNode, mappingName);\n        generationTracer.pushInputNode(newInputNode);\n      }\n      try {\n        List<SNode> _outputNodes = createOutputNodesForTemplateNode(mappingName, templateNode, newInputNode, nodeMacrosToSkip + 1, inputChanged);\n        if (_outputNodes != null) outputNodes.addAll(_outputNodes);\n        if (registerTopOutput && !inputChanged) {\n          myGenerator.addTopOutputNodesByInputNode(inputNode, outputNodes);\n        }\n      } finally {\n        if (inputChanged) {\n          popInputHistory();\n          generationTracer.closeInputNode(newInputNode);\n        }\n      }\n    }\n    return outputNodes;\n  }","commit_id":"f718c6b2a9cdeef417593fdaffa08f117d733e0c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    ContentManager contentManager = ContentManagerUtil.getContentManagerFromContext(e.getDataContext(), true);\n    if (contentManager != null && contentManager.canCloseContents()) {\n      contentManager.removeContent(contentManager.getSelectedContent());\n    }\n  }","id":79471,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    ContentManager contentManager = ContentManagerUtil.getContentManagerFromContext(e.getDataContext(), true);\n    if (contentManager != null && contentManager.canCloseContents()) {\n      final Content selectedContent = contentManager.getSelectedContent();\n      if (selectedContent != null && selectedContent.isCloseable()) {\n        contentManager.removeContent(selectedContent);\n      }\n    }\n  }","commit_id":"7fcda20bc94e91204fe9e09795bea13f20824076","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks if the log is initialized.\n   * TODO Temporary method until the old Git log is switched off and removed\n   */\n  public boolean isReady() {\n    return myDataHolder != null && myUi != null;\n  }","id":79472,"modified_method":"/**\n   * Checks if the log is initialized.\n   * TODO Temporary method until the old Git log is switched off and removed\n   */\n  public boolean isReady() {\n    return myLogManager.getDataHolder() != null && myLogManager.getLogUi() != null;\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public List<Hash> getSelectedCommits() {\n    List<Hash> hashes = ContainerUtil.newArrayList();\n    JBTable table = myUi.getTable();\n    for (int row : table.getSelectedRows()) {\n      Hash hash = ((AbstractVcsLogTableModel)table.getModel()).getHashAtRow(row);\n      if (hash != null) {\n        hashes.add(hash);\n      }\n    }\n    return hashes;\n  }","id":79473,"modified_method":"@Override\n  @NotNull\n  public List<Hash> getSelectedCommits() {\n    List<Hash> hashes = ContainerUtil.newArrayList();\n    JBTable table = myLogManager.getLogUi().getTable();\n    for (int row : table.getSelectedRows()) {\n      Hash hash = ((AbstractVcsLogTableModel)table.getModel()).getHashAtRow(row);\n      if (hash != null) {\n        hashes.add(hash);\n      }\n    }\n    return hashes;\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VcsLogImpl(VcsLogManager vcsLogManager) {\n    myDataHolder = vcsLogManager.getDataHolder();\n    myUi = vcsLogManager.getLogUi();\n  }","id":79474,"modified_method":"public VcsLogImpl(VcsLogManager vcsLogManager) {\n    myLogManager = vcsLogManager;\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public VcsFullCommitDetails getDetailsIfAvailable(@NotNull final Hash hash) {\n    return myDataHolder.getCommitDetailsGetter().getCommitDataIfAvailable(hash);\n  }","id":79475,"modified_method":"@Override\n  @Nullable\n  public VcsFullCommitDetails getDetailsIfAvailable(@NotNull final Hash hash) {\n    return myLogManager.getDataHolder().getCommitDetailsGetter().getCommitDataIfAvailable(hash);\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected VcsLogManager(@NotNull Project project, @NotNull ProjectLevelVcsManager vcsManagerInitializedFirst,\n                          @NotNull VcsLogObjectsFactory logObjectsFactory, @NotNull VcsLogSettings settings,\n                          @NotNull VcsLogUiProperties uiProperties) {\n    super(project);\n    myVcsManager = vcsManagerInitializedFirst;\n    myLogObjectsFactory = logObjectsFactory;\n    mySettings = settings;\n    myUiProperties = uiProperties;\n  }","id":79476,"modified_method":"public VcsLogManager(@NotNull Project project, @NotNull ProjectLevelVcsManager vcsManager,\n                       @NotNull VcsLogObjectsFactory logObjectsFactory, @NotNull VcsLogSettings settings,\n                       @NotNull VcsLogUiProperties uiProperties) {\n    myProject = project;\n    myVcsManager = vcsManager;\n    myLogObjectsFactory = logObjectsFactory;\n    mySettings = settings;\n    myUiProperties = uiProperties;\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Map<VirtualFile, VcsLogProvider> findLogProviders() {\n    Map<VirtualFile, VcsLogProvider> logProviders = ContainerUtil.newHashMap();\n    VcsLogProvider[] allLogProviders = Extensions.getExtensions(LOG_PROVIDER_EP, myProject);\n    for (AbstractVcs vcs : myVcsManager.getAllActiveVcss()) {\n      for (VcsLogProvider provider : allLogProviders) {\n        if (provider.getSupportedVcs().equals(vcs.getKeyInstanceMethod())) {\n          for (VirtualFile root : myVcsManager.getRootsUnderVcs(vcs)) {\n            logProviders.put(root, provider);\n          }\n          break;\n        }\n      }\n    }\n    return logProviders;\n  }","id":79477,"modified_method":"@NotNull\n  public Map<VirtualFile, VcsLogProvider> findLogProviders() {\n    Map<VirtualFile, VcsLogProvider> logProviders = ContainerUtil.newHashMap();\n    VcsLogProvider[] allLogProviders = Extensions.getExtensions(LOG_PROVIDER_EP, myProject);\n    for (AbstractVcs vcs : myVcsManager.getAllActiveVcss()) {\n      for (VcsLogProvider provider : allLogProviders) {\n        if (provider.getSupportedVcs().equals(vcs.getKeyInstanceMethod())) {\n          for (VirtualFile root : myVcsManager.getRootsUnderVcs(vcs)) {\n            logProviders.put(root, provider);\n          }\n          break;\n        }\n      }\n    }\n    return logProviders;\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PostponeableLogRefresher(@NotNull Project project, @NotNull VcsLogDataHolder dataHolder, @NotNull Content contentPane) {\n      myDataHolder = dataHolder;\n      myContentPane = contentPane;\n      myToolWindowManager = (ToolWindowManagerImpl)ToolWindowManager.getInstance(project);\n      myToolWindow = (ToolWindowImpl)myToolWindowManager.getToolWindow(TOOLWINDOW_ID);\n\n      Disposer.register(myToolWindow.getContentManager(), this);\n\n      myPostponedEventsListener = new MyRefreshPostponedEventsListener();\n      myToolWindow.getContentManager().addContentManagerListener(myPostponedEventsListener);\n      myToolWindowManager.addToolWindowManagerListener(myPostponedEventsListener);\n    }","id":79478,"modified_method":"public PostponeableLogRefresher(@NotNull Project project, @NotNull VcsLogDataHolder dataHolder) {\n      myDataHolder = dataHolder;\n      myToolWindowManager = (ToolWindowManagerImpl)ToolWindowManager.getInstance(project);\n      myToolWindow = (ToolWindowImpl)myToolWindowManager.getToolWindow(TOOLWINDOW_ID);\n\n      Disposer.register(myToolWindow.getContentManager(), this);\n\n      myPostponedEventsListener = new MyRefreshPostponedEventsListener();\n      myToolWindow.getContentManager().addContentManagerListener(myPostponedEventsListener);\n      myToolWindowManager.addToolWindowManagerListener(myPostponedEventsListener);\n    }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void initComponent() {\n    super.initComponent();\n\n    if (!Registry.is(\"git.new.log\")) {\n      return;\n    }\n\n    ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n      public void run() {\n        ChangesViewContentManager changesView = (ChangesViewContentManager)ChangesViewContentManager.getInstance(myProject);\n        changesView.executeWhenInitialized(new DumbAwareRunnable() {\n          @Override\n          public void run() {\n            UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n              @Override\n              public void run() {\n                final Map<VirtualFile, VcsLogProvider> logProviders = findLogProviders();\n                if (logProviders.isEmpty()) {\n                  return;\n                }\n\n                final VcsLogContainer mainPanel = new VcsLogContainer(myProject);\n                final Content content = new ContentImpl(mainPanel, \"Log\", true);\n                ChangesViewContentI changesView = ChangesViewContentManager.getInstance(myProject);\n                changesView.addContent(content);\n                content.setCloseable(false);\n\n                VcsLogDataHolder.init(myProject, myLogObjectsFactory, logProviders, mySettings, new Consumer<VcsLogDataHolder>() {\n                  @Override\n                  public void consume(VcsLogDataHolder vcsLogDataHolder) {\n                    Disposer.register(myProject, vcsLogDataHolder);\n                    VcsLogUI logUI = new VcsLogUI(vcsLogDataHolder, myProject, mySettings,\n                                                  new VcsLogColorManagerImpl(logProviders.keySet()), myUiProperties);\n                    myLogDataHolder = vcsLogDataHolder;\n                    myUi = logUI;\n                    mainPanel.init(logUI.getMainFrame().getMainComponent());\n                    myLogRefresher = new PostponeableLogRefresher(myProject, vcsLogDataHolder, content);\n                    refreshLogOnVcsEvents(logProviders);\n                  }\n                });\n              }\n            });\n          }\n        });\n      }\n    });\n  }","id":79479,"modified_method":"@NotNull\n  public JComponent initContent() {\n    final Map<VirtualFile, VcsLogProvider> logProviders = findLogProviders();\n    final VcsLogContainer mainPanel = new VcsLogContainer(myProject);\n\n    VcsLogDataHolder.init(myProject, myLogObjectsFactory, logProviders, mySettings, new Consumer<VcsLogDataHolder>() {\n      @Override\n      public void consume(VcsLogDataHolder vcsLogDataHolder) {\n        VcsLogUI logUI = new VcsLogUI(vcsLogDataHolder, myProject, mySettings,\n                                      new VcsLogColorManagerImpl(logProviders.keySet()), myUiProperties);\n        myLogDataHolder = vcsLogDataHolder;\n        myUi = logUI;\n        mainPanel.init(logUI.getMainFrame().getMainComponent());\n        myLogRefresher = new PostponeableLogRefresher(myProject, vcsLogDataHolder);\n        refreshLogOnVcsEvents(logProviders);\n      }\n    });\n    return mainPanel;\n  }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isOurContentPaneShowing() {\n      return myToolWindowManager.isToolWindowRegistered(TOOLWINDOW_ID) &&\n             myToolWindow.isVisible() && myContentPane.equals(myToolWindow.getContentManager().getSelectedContent());\n    }","id":79480,"modified_method":"private boolean isOurContentPaneShowing() {\n      if (myToolWindowManager.isToolWindowRegistered(TOOLWINDOW_ID) && myToolWindow.isVisible()) {\n        Content content = myToolWindow.getContentManager().getSelectedContent();\n        return content != null && content.getTabName().equals(TAB_NAME);\n      }\n      return false;\n    }","commit_id":"a9eacb0f76a28b72595598d366002c2c7cd27b30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void selectContent(final String tabName) {\n    for(Content content: myContentManager.getContents()) {\n      if (content.getDisplayName().equals(tabName)) {\n        myContentManager.setSelectedContent(content);\n        break;\n      }\n    }\n  }","id":79481,"modified_method":"public void selectContent(@NotNull String tabName) {\n    selectContent(tabName, false);\n  }","commit_id":"d65ba3dff91b48fd319a08c54a1bbfeffda71c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isContentSelected(final Content content) {\n    return Comparing.equal(content, myContentManager.getSelectedContent());\n  }","id":79482,"modified_method":"public boolean isContentSelected(@NotNull String contentName) {\n    Content selectedContent = myContentManager.getSelectedContent();\n    if (selectedContent == null) return false;\n    return Comparing.equal(contentName, selectedContent.getTabName());\n  }","commit_id":"d65ba3dff91b48fd319a08c54a1bbfeffda71c4b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(@NotNull AnActionEvent e) {\n    Project project = e.getProject();\n    assert project != null;\n\n    ContentManager contentManager = getContentManager(project);\n    if (contentManager == null) return;\n    TabbedContent tabbedContent = getTabbedContent(contentManager);\n    if (tabbedContent == null) return;\n\n    if (tabbedContent.getTabs().size() > 1) {\n      JComponent component = tabbedContent.getComponent();\n      tabbedContent.removeContent(component);\n      contentManager.setSelectedContent(tabbedContent, true, true);\n    }\n    else {\n      contentManager.removeContent(tabbedContent, true);\n    }\n  }","id":79483,"modified_method":"public void actionPerformed(@NotNull AnActionEvent e) {\n    Project project = e.getProject();\n    assert project != null;\n\n    ContentManager contentManager = getContentManager(project);\n    if (contentManager == null) return;\n    Content selectedContent = getTabbedContent(contentManager);\n    if (selectedContent != null) {\n      ContentUtilEx.closeContentTab(contentManager, selectedContent);\n    }\n  }","commit_id":"ab4bf66646bd2c98c11b6739e8e9728068b7fa96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static TabbedContent getTabbedContent(@NotNull ContentManager contentManager) {\n    TabbedContent tabbedContent = ContentUtilEx.findTabbedContent(contentManager, VcsLogContentProvider.TAB_NAME);\n    if (tabbedContent != contentManager.getSelectedContent()) return null;\n    return tabbedContent;\n  }","id":79484,"modified_method":"@Nullable\n  private static Content getTabbedContent(@NotNull ContentManager contentManager) {\n    Content content = contentManager.getSelectedContent();\n    if (content != null) {\n      if (ContentUtilEx.isContentTab(content, VcsLogContentProvider.TAB_NAME)) return content;\n    }\n    return null;\n  }","commit_id":"ab4bf66646bd2c98c11b6739e8e9728068b7fa96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * This method is responsible for updating the ipinterface table entry for a\n     * specific interface.\n     * \n     * @param dbc\n     *            Database Connection.\n     * @param now\n     *            Date/time to be associated with the update.\n     * @param node\n     *            Node entry for the node being rescanned.\n     * @param dbIpIfEntry\n     *            interface entry of the updating interface.\n     * @param snmpc\n     *            SNMP collector or null if SNMP not supported.\n     * @param isNewIpEntry\n     *            if dbIpIfEntry is a new entry.\n     * @param isReparented\n     *            if dbIpIfEntry is reparented.\n     * @param doesSnmp\n     *            if node supports SNMP.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the ipinterface table.\n     */\n    private void updateInterfaceInfo(Connection dbc, Date now, DbNodeEntry node,\n            DbIpInterfaceEntry dbIpIfEntry, DbIpInterfaceEntry currIpIfEntry,\n            boolean isNewIpEntry, boolean isReparented)\n    throws SQLException {\n        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();\n\n        InetAddress ifaddr = dbIpIfEntry.getIfAddress();\n\n        /*\n         * Clone the existing database entry so we have access to the values\n         * of the database fields associated with the interface in the event\n         * that something has changed.\n         */\n        DbIpInterfaceEntry originalIpIfEntry = DbIpInterfaceEntry.clone(dbIpIfEntry);\n\n        // Update any fields which have changed\n        dbIpIfEntry.setLastPoll(now);\n        dbIpIfEntry.updateHostname(currIpIfEntry.getHostname());\n        dbIpIfEntry.updateManagedState(currIpIfEntry.getManagedState());\n        dbIpIfEntry.updateStatus(currIpIfEntry.getStatus());\n        dbIpIfEntry.updatePrimaryState(currIpIfEntry.getPrimaryState());\n        \n        /*\n         * XXX Note: the ifIndex will not be updated if updateIfIndex(-1)\n         * is called.  In other words, an ifIndex of a value other than -1\n         * (non-null in the database) will never change to -1 (which is null\n         * in the database) by calling updateIfIndex.  setIfIndex does work,\n         * however if m_useIfIndexAsKey is set in the DbIpInterfaceEntry,\n         * no entries (or at least not the right entry) will be updated\n         * because the WHERE clause for the UPDATE will be referring to the\n         * *new* ifIndex.\n         */\n        dbIpIfEntry.updateIfIndex(currIpIfEntry.getIfIndex());\n\n        /*\n         * Set event flags\n         * NOTE: Must set these flags prior to call to\n         * DbIpInterfaceEntry.store()\n         * method which will cause the change map to be cleared.\n         */\n        boolean ifIndexChangedFlag = false;\n        boolean ipHostnameChangedFlag = false;\n\n        if (dbIpIfEntry.hasIfIndexChanged()) {\n            ifIndexChangedFlag = true;\n        }\n\n        if (dbIpIfEntry.hasHostnameChanged()) {\n            ipHostnameChangedFlag = true;\n        }\n\n        // Update the database\n        dbIpIfEntry.store(dbc);\n\n        /*\n         * If the interface was not already in the database under\n         * the node being rescanned or some other node send a\n         * nodeGainedInterface event.\n         */\n        if (isNewIpEntry && !isReparented) {\n            createNodeGainedInterfaceEvent(dbIpIfEntry);\n        }\n\n        // InterfaceIndexChanged event\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateInterfaceInfo: ifIndex changed: \"\n                      + ifIndexChangedFlag);\n        }\n        if (ifIndexChangedFlag) {\n            createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry);\n            m_ifIndexOnNodeChangedFlag = true;\n        }\n\n        // IPHostNameChanged event\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateInterfaceInfo: hostname changed: \"\n                      + ipHostnameChangedFlag);\n        }\n        if (ipHostnameChangedFlag) {\n            createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry);\n        }\n        \n        if (isNewIpEntry) {\n            /*\n             * If it's new, the packageIpListMap needs to be rebuilt,\n             * polling status rechecked, and ismanaged updated if necessary\n             */\n            boolean ipToBePolled = false;\n            final String ifaddrString = str(ifaddr);\n\t\t\tlog().debug(\"updateInterfaceInfo: rebuilding PackageIpListMap for \"\n                      + \"new interface \" + ifaddrString);\n            PollerConfigFactory.getInstance().rebuildPackageIpListMap();\n            org.opennms.netmgt.config.poller.Package ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n            if (ipPkg != null) {\n                ipToBePolled = true;\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateInterfaceInfo: interface \" + ifaddrString + \" to be polled: \" + ipToBePolled);\n            }\n            if (ipToBePolled) {\n                final DBUtils d = new DBUtils(getClass());\n                try {\n                    PreparedStatement stmt = dbc.prepareStatement(SQL_DB_UPDATE_ISMANAGED);\n                    d.watch(stmt);\n                    stmt.setString(1, new String(new char[] { DbIpInterfaceEntry.STATE_MANAGED }));\n                    stmt.setLong(2, dbIpIfEntry.getNodeId());\n                    stmt.setString(3, ifaddrString);\n                    stmt.executeUpdate();\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"updateInterfaceInfo: updated managed state \"\n                                  + \"for new interface \"\n                                  + ifaddrString + \" on node \"\n                                  + dbIpIfEntry.getNodeId() + \" to managed\");\n                    }\n                } finally {\n                    d.cleanUp();\n                }\n            }\n        }\n    }","id":79485,"modified_method":"/**\n     * This method is responsible for updating the ipinterface table entry for a\n     * specific interface.\n     * \n     * @param dbc\n     *            Database Connection.\n     * @param now\n     *            Date/time to be associated with the update.\n     * @param node\n     *            Node entry for the node being rescanned.\n     * @param dbIpIfEntry\n     *            interface entry of the updating interface.\n     * @param snmpc\n     *            SNMP collector or null if SNMP not supported.\n     * @param isNewIpEntry\n     *            if dbIpIfEntry is a new entry.\n     * @param isReparented\n     *            if dbIpIfEntry is reparented.\n     * @param doesSnmp\n     *            if node supports SNMP.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the ipinterface table.\n     */\n    private void updateInterfaceInfo(Connection dbc, Date now, DbNodeEntry node,\n            DbIpInterfaceEntry dbIpIfEntry, DbIpInterfaceEntry currIpIfEntry,\n            boolean isNewIpEntry, boolean isReparented)\n    throws SQLException {\n        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();\n\n        InetAddress ifaddr = dbIpIfEntry.getIfAddress();\n\n        /*\n         * Clone the existing database entry so we have access to the values\n         * of the database fields associated with the interface in the event\n         * that something has changed.\n         */\n        DbIpInterfaceEntry originalIpIfEntry = DbIpInterfaceEntry.clone(dbIpIfEntry);\n\n        // Update any fields which have changed\n        dbIpIfEntry.setLastPoll(now);\n        dbIpIfEntry.updateHostname(currIpIfEntry.getHostname());\n        dbIpIfEntry.updateManagedState(currIpIfEntry.getManagedState());\n        dbIpIfEntry.updateStatus(currIpIfEntry.getStatus());\n        dbIpIfEntry.updatePrimaryState(currIpIfEntry.getPrimaryState());\n        \n        /*\n         * XXX Note: the ifIndex will not be updated if updateIfIndex(-1)\n         * is called.  In other words, an ifIndex of a value other than -1\n         * (non-null in the database) will never change to -1 (which is null\n         * in the database) by calling updateIfIndex.  setIfIndex does work,\n         * however if m_useIfIndexAsKey is set in the DbIpInterfaceEntry,\n         * no entries (or at least not the right entry) will be updated\n         * because the WHERE clause for the UPDATE will be referring to the\n         * *new* ifIndex.\n         */\n        dbIpIfEntry.updateIfIndex(currIpIfEntry.getIfIndex());\n\n        /*\n         * Set event flags\n         * NOTE: Must set these flags prior to call to\n         * DbIpInterfaceEntry.store()\n         * method which will cause the change map to be cleared.\n         */\n        boolean ifIndexChangedFlag = false;\n        boolean ipHostnameChangedFlag = false;\n\n        if (dbIpIfEntry.hasIfIndexChanged()) {\n            ifIndexChangedFlag = true;\n        }\n\n        if (dbIpIfEntry.hasHostnameChanged()) {\n            ipHostnameChangedFlag = true;\n        }\n\n        // Update the database\n        dbIpIfEntry.store(dbc);\n\n        /*\n         * If the interface was not already in the database under\n         * the node being rescanned or some other node send a\n         * nodeGainedInterface event.\n         */\n        if (isNewIpEntry && !isReparented) {\n            createNodeGainedInterfaceEvent(dbIpIfEntry);\n        }\n\n        // InterfaceIndexChanged event\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateInterfaceInfo: ifIndex changed: \"\n                      + ifIndexChangedFlag);\n        }\n        if (ifIndexChangedFlag) {\n            m_eventList.add(createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry));\n            m_ifIndexOnNodeChangedFlag = true;\n        }\n\n        // IPHostNameChanged event\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateInterfaceInfo: hostname changed: \"\n                      + ipHostnameChangedFlag);\n        }\n        if (ipHostnameChangedFlag) {\n            m_eventList.add(createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry));\n        }\n        \n        if (isNewIpEntry) {\n            /*\n             * If it's new, the packageIpListMap needs to be rebuilt,\n             * polling status rechecked, and ismanaged updated if necessary\n             */\n            boolean ipToBePolled = false;\n            final String ifaddrString = str(ifaddr);\n\t\t\tlog().debug(\"updateInterfaceInfo: rebuilding PackageIpListMap for \"\n                      + \"new interface \" + ifaddrString);\n            PollerConfigFactory.getInstance().rebuildPackageIpListMap();\n            org.opennms.netmgt.config.poller.Package ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n            if (ipPkg != null) {\n                ipToBePolled = true;\n            }\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateInterfaceInfo: interface \" + ifaddrString + \" to be polled: \" + ipToBePolled);\n            }\n            if (ipToBePolled) {\n                final DBUtils d = new DBUtils(RescanProcessor.class);\n                try {\n                    PreparedStatement stmt = dbc.prepareStatement(SQL_DB_UPDATE_ISMANAGED);\n                    d.watch(stmt);\n                    stmt.setString(1, new String(new char[] { DbIpInterfaceEntry.STATE_MANAGED }));\n                    stmt.setLong(2, dbIpIfEntry.getNodeId());\n                    stmt.setString(3, ifaddrString);\n                    stmt.executeUpdate();\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"updateInterfaceInfo: updated managed state \"\n                                  + \"for new interface \"\n                                  + ifaddrString + \" on node \"\n                                  + dbIpIfEntry.getNodeId() + \" to managed\");\n                    }\n                } finally {\n                    d.cleanUp();\n                }\n            }\n        }\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a suspendPollingService event\n     * and adding it to the event list.\n     * \n     * @param nodeEntry\n     *            Entry of node for which a service is to be polled\n     * @param ifEntry\n     *            Entry of interface which a service is to be polled\n     * @param svcName\n     *            Service name\n     */\n    private void createSuspendPollingServiceEvent(final DbNodeEntry nodeEntry, final DbIpInterfaceEntry ifEntry, final String svcName) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        final EventBuilder bldr = serviceEventBuilder(EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI, ifEntry.getNodeId(), ifAddress, svcName);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n        \n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"suspendPollingServiceEvent: Created suspendPollingService event for nodeid: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress + \" service: \" + svcName);\n        }\n    }","id":79486,"modified_method":"/**\n     * This method is responsible for generating a suspendPollingService event\n     * and adding it to the event list.\n     * \n     * @param nodeEntry\n     *            Entry of node for which a service is to be polled\n     * @param ifEntry\n     *            Entry of interface which a service is to be polled\n     * @param svcName\n     *            Service name\n     * @return \n     */\n    private static Event createSuspendPollingServiceEvent(final DbNodeEntry nodeEntry, final DbIpInterfaceEntry ifEntry, final String svcName) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        final EventBuilder bldr = serviceEventBuilder(EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI, ifEntry.getNodeId(), ifAddress, svcName);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n        \n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"suspendPollingServiceEvent: Created suspendPollingService event for nodeid: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress + \" service: \" + svcName);\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is where all the work of the class is done.\n     */\n    public void run() {\n        // perform rescan of the node\n        DbNodeEntry dbNodeEntry = getNode();\n        \n        if (dbNodeEntry == null) {\n            return;\n        }\n        \n        if (dbNodeEntry.getForeignSource() != null) {\n            log().info(\"Skipping rescan of node \"+getNodeId()+\" since it was imported with foreign source \"+dbNodeEntry.getForeignSource());\n            return;\n        }\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"start rescanning node: \" + getNodeId());\n        }\n\n        DbIpInterfaceEntry[] dbInterfaces = getInterfaces(dbNodeEntry);\n        \n        if (dbInterfaces == null) {\n            log().debug(\"no interfaces found in the database to rescan for node: \"\n                      + getNodeId());\n            return;\n        }\n\n        // this indicates whether or not we found an iface the responds to snmp\n        boolean doesSnmp = true;\n        \n        IpAddrTable ipAddTable = null;\n        List<InetAddress> prevAddrList = null;\n        boolean snmpcAgree = false;\n        boolean gotSnmpc = false;\n        Map<String, IfCollector> collectorMap =\n            new HashMap<String, IfCollector>();\n        Map<String, IfCollector> nonSnmpCollectorMap =\n            new HashMap<String, IfCollector>();\n        Set<InetAddress> probedAddrs = new HashSet<InetAddress>();\n\n        boolean gotSnmpCollection = false;\n        DbIpInterfaceEntry oldPrimarySnmpInterface =\n            DbNodeEntry.getPrimarySnmpInterface(dbInterfaces);\n        if (oldPrimarySnmpInterface != null) {\n            gotSnmpCollection =\n                scanPrimarySnmpInterface(oldPrimarySnmpInterface, collectorMap,\n                                         probedAddrs);\n        }\n\n        if (!gotSnmpCollection) {\n            /*\n             * Run collector for each retrieved interface and add result\n             * to a collector map.\n             */\n            for (int i = 0; i < dbInterfaces.length; i++) {\n                log().info(\"run: Running collector for interface \"+i+\" of \"+dbInterfaces.length);\n                final InetAddress ifaddr = dbInterfaces[i].getIfAddress();\n                final String ifaddrString = str(ifaddr);\n\n                /*\n                 * collect the information from the interface.\n                 * NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.\n                 */\n\t\t\t\tif (!scannableInterface(dbInterfaces, ifaddr)) {\n                    log().debug(\"run: skipping scan of address: \"+ifaddrString);\n                    continue;\n                }\n\n\t\t\t\tif (ifaddrString == null) {\n\t\t\t\t\tlog().debug(\"run: unable to scan inet address: \" + ifaddr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n                if (log().isDebugEnabled()) {\n                    log().debug(\"running collection for \" + ifaddrString);\n                }\n\n                IfCollector collector = new IfCollector(m_pluginManager, ifaddr, true, probedAddrs);\n                collector.run();\n\n                IfSnmpCollector snmpc = collector.getSnmpCollector();\n                if (snmpc != null) {\n                    gotSnmpc = true;\n                }\n                if (snmpc != null && snmpc.hasIpAddrTable()\n                        && snmpc.getIfIndex(snmpc.getCollectorTargetAddress()) != -1) {\n                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {\n                        collectorMap.put(ifaddrString, collector);\n                        gotSnmpCollection = true;\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"SNMP data collected via \"\n                                      + ifaddrString);\n                            log().debug(\"Adding \" + ifaddrString\n                                      + \" to collectorMap for node: \"\n                                      + getNodeId());\n                        }\n                        snmpcAgree = false;\n                        break;\n                    } else if (ipAddTable == null) {\n                        snmpcAgree = true;\n                        collectorMap.put(ifaddrString, collector);\n                        ipAddTable = snmpc.getIpAddrTable();\n                        prevAddrList = ipAddTable.getIpAddresses();\n\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"SNMP data collected via \"\n                                      + ifaddrString\n                                      + \" does not agree with database.  \"\n                                      + \"Tentatively adding to the \"\n                                      + \"collectorMap and continuing\");\n                            for(InetAddress a : prevAddrList) {\n                                log().debug(\"IP address in list = \" + a);\n                            }\n                        }\n                    } else if (ipAddTable != null && snmpcAgree == true) {\n                        ipAddTable = snmpc.getIpAddrTable();\n                        List<InetAddress> addrList = ipAddTable.getIpAddresses();\n\n                        boolean listMatch = true;\n                        String jstring = null;\n                        String kstring = null;\n                        Iterator<InetAddress> j = prevAddrList.iterator();\n                        Iterator<InetAddress> k = addrList.iterator();\n                        while (j.hasNext()) {\n                            jstring = j.next().toString();\n                            if (k.hasNext()) {\n                                kstring = k.next().toString();\n                                if (jstring.equals(kstring)) {\n                                    if (log().isDebugEnabled()) {\n                                        log().debug(jstring + \" = \" + kstring);\n                                    }\n                                } else {\n                                    if (log().isDebugEnabled()) {\n                                        log().debug(jstring + \" != \" + kstring);\n                                    }\n                                    listMatch = false;\n                                }\n                            } else {\n                                listMatch = false;\n                            }\n                        }\n                        if (k.hasNext()) {\n                            listMatch = false;\n                        }\n                        if (listMatch) {\n                            log().debug(\"Current and previous address lists match\");\n                        } else {\n                            log().debug(\"Current and previous address lists \"\n                                      + \"DO NOT match\");\n                            snmpcAgree = false;\n                        }\n                        collector.deleteSnmpCollector();\n                    }\n                    if (snmpcAgree == false) {\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"SNMP data collected via \"\n                                      + ifaddrString\n                                      + \" does not agree with database or with \"\n                                      + \"other interface(s) on this node.\");\n                        }\n                    }\n                } else {\n                    /*\n                     * Build a non-SNMP collectorMap, skipping 127.*.*.*\n                     * and 0.0.0.0\n                     */\n                    nonSnmpCollectorMap.put(ifaddrString, collector);\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"Adding \" + ifaddrString\n                                  + \" to nonSnmpCollectorMap for node: \"\n                                  + getNodeId());\n                    }\n                }\n            }\n        }\n\n        if (!gotSnmpCollection && snmpcAgree == false) {\n            /*\n             * We didn't get a collection from a primary snmp interface,\n             * and we didn't get a collection that agrees with the db, and\n             * multiple interface collections don't agree with each other.\n             * First check for lame SNMP host, otherwise use the\n             * nonSnmpCollectorMap and set doesSnmp = false\n             */\n            collectorMap = nonSnmpCollectorMap;\n            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {\n                doesSnmp = true;\n                if (log().isDebugEnabled()) {\n                    log().debug(\"node \" + getNodeId()\n                              + \" appears to be a lame SNMP host... \"\n                              + \"Proceeding\");\n                }\n            } else {\n                doesSnmp = false;\n                if (log().isDebugEnabled()) {\n                    if (gotSnmpc == false) {\n                        log().debug(\"Could not collect SNMP data for node: \"\n                                  + getNodeId());\n                    } else {\n                        log().debug(\"Not using SNMP data for node: \"\n                                  + getNodeId() + \".  \"\n                                  + \"Collection does not agree with database.\");\n                    }\n                }\n            }\n        } else if (snmpcAgree == true) {\n            /*\n             * We didn't get a collection from a primary snmp interface,\n             * and we didn't get a collection that agrees with the db, but\n             * all collections we DID get agree with each other.\n             * May want to create an event here\n             */\n            if (log().isDebugEnabled()) {\n                log().debug(\"SNMP collection for node: \"\n                          + getNodeId()\n                          + \" does not agree with database, but there is no \"\n                          + \"conflict among the interfaces on this node which \"\n                          + \"respond to SNMP. Proceeding...\");\n            }\n            createSnmpConflictsWithDbEvent(dbNodeEntry);\n        }\n\n        // Update the database\n        Date now = null;\n        Connection dbc = null;\n        boolean updateCompleted = false;\n        try {\n            /*\n             * Synchronize on the Capsd sync lock so we can check if\n             * the interface is already in the database and perform\n             * the necessary inserts in one atomic operation\n             *\t\n             * The SuspectEventProcessor class is also synchronizing on this\n             * lock prior to performing database inserts or updates.\n             */\n            log().debug(\"Waiting for capsd dbLock to process \"\n                      + getNodeId());\n            synchronized (Capsd.getDbSyncLock()) {\n                log().debug(\"Got capsd dbLock. processing \"\n                          + getNodeId());\n                // Get database connection\n                dbc = DataSourceFactory.getInstance().getConnection();\n\n                /*\n                 * There is a slight possibility that the node being rescanned\n                 * has been deleted (due to reparenting) by another thread\n                 * between the time this rescan was started and the database\n                 * sync lock was grabbed. Verify that the current nodeid is\n                 * still valid (ie, not deleted) before continuing.\n                 */\n                if (!isNodeDeleted(dbc, getNodeId())) {\n                    // Update interface information\n                    now = new Date();\n                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap,\n                                     doesSnmp);\n                    \n                    if (doesSnmp) {\n                        InetAddress oldPriIf = null;\n                        if (oldPrimarySnmpInterface != null) {\n                            oldPriIf = oldPrimarySnmpInterface.getIfAddress();\n                        }\n                        InetAddress newSnmpPrimaryIf =\n                            updatePrimarySnmpInterface(dbc, dbNodeEntry,\n                                                       collectorMap, oldPriIf);\n\n                            updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf,\n                                       dbInterfaces, collectorMap);\n                    }\n                    updateCompleted = true;\n                    createRescanCompletedEvent(dbNodeEntry);\n                }\n            }\n        } catch (Throwable t) {\n            log().error(\"Error updating records for node ID \" + getNodeId() + \": \" + t, t);\n        } finally {\n            // Finished with the database connection, close it.\n            try {\n                if (dbc != null) {\n                    dbc.close();\n                }\n            } catch (SQLException e) {\n                log().error(\"Error closing connection: \" + e, e);\n            }\n            \n            // Remove the node we just scanned from the tracker set\n            synchronized (m_queuedRescanTracker) {\n                m_queuedRescanTracker.remove(getNodeId());\n            }\n        }\n\n        // Send events associcatd with the rescan\n        if (updateCompleted) {\n            // Send all events created during rescan process to eventd\n            for (Event event : m_eventList) {\n                try {\n                    EventIpcManagerFactory.getIpcManager().sendNow(event);\n                } catch (Throwable t) {\n                    log().warn(\"run: unexpected throwable exception caught \"\n                             + \"while sending event: \" + t, t);\n                }\n            }\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug((m_forceRescan ? \"Forced r\" : \"R\") + \"escan \"\n                      + \"for node w/ nodeid \" + getNodeId()\n                      + \" completed.\");\n        }\n    }","id":79487,"modified_method":"/**\n     * This is where all the work of the class is done.\n     */\n    public void run() {\n        // perform rescan of the node\n        DbNodeEntry dbNodeEntry = getNode();\n        \n        if (dbNodeEntry == null) {\n            return;\n        }\n        \n        if (dbNodeEntry.getForeignSource() != null) {\n            log().info(\"Skipping rescan of node \"+getNodeId()+\" since it was imported with foreign source \"+dbNodeEntry.getForeignSource());\n            return;\n        }\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"start rescanning node: \" + getNodeId());\n        }\n\n        DbIpInterfaceEntry[] dbInterfaces = getInterfaces(dbNodeEntry);\n        \n        if (dbInterfaces == null) {\n            log().debug(\"no interfaces found in the database to rescan for node: \"\n                      + getNodeId());\n            return;\n        }\n\n        // this indicates whether or not we found an iface the responds to snmp\n        boolean doesSnmp = true;\n        \n        IpAddrTable ipAddTable = null;\n        List<InetAddress> prevAddrList = null;\n        boolean snmpcAgree = false;\n        boolean gotSnmpc = false;\n        Map<String, IfCollector> collectorMap =\n            new HashMap<String, IfCollector>();\n        Map<String, IfCollector> nonSnmpCollectorMap =\n            new HashMap<String, IfCollector>();\n        Set<InetAddress> probedAddrs = new HashSet<InetAddress>();\n\n        boolean gotSnmpCollection = false;\n        DbIpInterfaceEntry oldPrimarySnmpInterface =\n            DbNodeEntry.getPrimarySnmpInterface(dbInterfaces);\n        if (oldPrimarySnmpInterface != null) {\n            gotSnmpCollection =\n                scanPrimarySnmpInterface(oldPrimarySnmpInterface, collectorMap,\n                                         probedAddrs);\n        }\n\n        if (!gotSnmpCollection) {\n            /*\n             * Run collector for each retrieved interface and add result\n             * to a collector map.\n             */\n            for (int i = 0; i < dbInterfaces.length; i++) {\n                log().info(\"run: Running collector for interface \"+i+\" of \"+dbInterfaces.length);\n                final InetAddress ifaddr = dbInterfaces[i].getIfAddress();\n                final String ifaddrString = str(ifaddr);\n\n                /*\n                 * collect the information from the interface.\n                 * NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.\n                 */\n\t\t\t\tif (!scannableInterface(dbInterfaces, ifaddr)) {\n                    log().debug(\"run: skipping scan of address: \"+ifaddrString);\n                    continue;\n                }\n\n\t\t\t\tif (ifaddrString == null) {\n\t\t\t\t\tlog().debug(\"run: unable to scan inet address: \" + ifaddr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n                if (log().isDebugEnabled()) {\n                    log().debug(\"running collection for \" + ifaddrString);\n                }\n\n                IfCollector collector = new IfCollector(m_pluginManager, ifaddr, true, probedAddrs);\n                collector.run();\n\n                IfSnmpCollector snmpc = collector.getSnmpCollector();\n                if (snmpc != null) {\n                    gotSnmpc = true;\n                }\n                if (snmpc != null && snmpc.hasIpAddrTable()\n                        && snmpc.getIfIndex(snmpc.getCollectorTargetAddress()) != -1) {\n                    if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc)) {\n                        collectorMap.put(ifaddrString, collector);\n                        gotSnmpCollection = true;\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"SNMP data collected via \"\n                                      + ifaddrString);\n                            log().debug(\"Adding \" + ifaddrString\n                                      + \" to collectorMap for node: \"\n                                      + getNodeId());\n                        }\n                        snmpcAgree = false;\n                        break;\n                    } else if (ipAddTable == null) {\n                        snmpcAgree = true;\n                        collectorMap.put(ifaddrString, collector);\n                        ipAddTable = snmpc.getIpAddrTable();\n                        prevAddrList = ipAddTable.getIpAddresses();\n\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"SNMP data collected via \"\n                                      + ifaddrString\n                                      + \" does not agree with database.  \"\n                                      + \"Tentatively adding to the \"\n                                      + \"collectorMap and continuing\");\n                            for(InetAddress a : prevAddrList) {\n                                log().debug(\"IP address in list = \" + a);\n                            }\n                        }\n                    } else if (ipAddTable != null && snmpcAgree == true) {\n                        ipAddTable = snmpc.getIpAddrTable();\n                        List<InetAddress> addrList = ipAddTable.getIpAddresses();\n\n                        boolean listMatch = true;\n                        String jstring = null;\n                        String kstring = null;\n                        Iterator<InetAddress> j = prevAddrList.iterator();\n                        Iterator<InetAddress> k = addrList.iterator();\n                        while (j.hasNext()) {\n                            jstring = j.next().toString();\n                            if (k.hasNext()) {\n                                kstring = k.next().toString();\n                                if (jstring.equals(kstring)) {\n                                    if (log().isDebugEnabled()) {\n                                        log().debug(jstring + \" = \" + kstring);\n                                    }\n                                } else {\n                                    if (log().isDebugEnabled()) {\n                                        log().debug(jstring + \" != \" + kstring);\n                                    }\n                                    listMatch = false;\n                                }\n                            } else {\n                                listMatch = false;\n                            }\n                        }\n                        if (k.hasNext()) {\n                            listMatch = false;\n                        }\n                        if (listMatch) {\n                            log().debug(\"Current and previous address lists match\");\n                        } else {\n                            log().debug(\"Current and previous address lists \"\n                                      + \"DO NOT match\");\n                            snmpcAgree = false;\n                        }\n                        collector.deleteSnmpCollector();\n                    }\n                    if (snmpcAgree == false) {\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"SNMP data collected via \"\n                                      + ifaddrString\n                                      + \" does not agree with database or with \"\n                                      + \"other interface(s) on this node.\");\n                        }\n                    }\n                } else {\n                    /*\n                     * Build a non-SNMP collectorMap, skipping 127.*.*.*\n                     * and 0.0.0.0\n                     */\n                    nonSnmpCollectorMap.put(ifaddrString, collector);\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"Adding \" + ifaddrString\n                                  + \" to nonSnmpCollectorMap for node: \"\n                                  + getNodeId());\n                    }\n                }\n            }\n        }\n\n        if (!gotSnmpCollection && snmpcAgree == false) {\n            /*\n             * We didn't get a collection from a primary snmp interface,\n             * and we didn't get a collection that agrees with the db, and\n             * multiple interface collections don't agree with each other.\n             * First check for lame SNMP host, otherwise use the\n             * nonSnmpCollectorMap and set doesSnmp = false\n             */\n            collectorMap = nonSnmpCollectorMap;\n            if (nonSnmpCollectorMap.size() == 1 && gotSnmpc) {\n                doesSnmp = true;\n                if (log().isDebugEnabled()) {\n                    log().debug(\"node \" + getNodeId()\n                              + \" appears to be a lame SNMP host... \"\n                              + \"Proceeding\");\n                }\n            } else {\n                doesSnmp = false;\n                if (log().isDebugEnabled()) {\n                    if (gotSnmpc == false) {\n                        log().debug(\"Could not collect SNMP data for node: \"\n                                  + getNodeId());\n                    } else {\n                        log().debug(\"Not using SNMP data for node: \"\n                                  + getNodeId() + \".  \"\n                                  + \"Collection does not agree with database.\");\n                    }\n                }\n            }\n        } else if (snmpcAgree == true) {\n            /*\n             * We didn't get a collection from a primary snmp interface,\n             * and we didn't get a collection that agrees with the db, but\n             * all collections we DID get agree with each other.\n             * May want to create an event here\n             */\n            if (log().isDebugEnabled()) {\n                log().debug(\"SNMP collection for node: \"\n                          + getNodeId()\n                          + \" does not agree with database, but there is no \"\n                          + \"conflict among the interfaces on this node which \"\n                          + \"respond to SNMP. Proceeding...\");\n            }\n            m_eventList.add(createSnmpConflictsWithDbEvent(dbNodeEntry));\n        }\n\n        // Update the database\n        Date now = null;\n        Connection dbc = null;\n        boolean updateCompleted = false;\n        try {\n            /*\n             * Synchronize on the Capsd sync lock so we can check if\n             * the interface is already in the database and perform\n             * the necessary inserts in one atomic operation\n             *\t\n             * The SuspectEventProcessor class is also synchronizing on this\n             * lock prior to performing database inserts or updates.\n             */\n            log().debug(\"Waiting for capsd dbLock to process \"\n                      + getNodeId());\n            synchronized (Capsd.getDbSyncLock()) {\n                log().debug(\"Got capsd dbLock. processing \"\n                          + getNodeId());\n                // Get database connection\n                dbc = DataSourceFactory.getInstance().getConnection();\n\n                /*\n                 * There is a slight possibility that the node being rescanned\n                 * has been deleted (due to reparenting) by another thread\n                 * between the time this rescan was started and the database\n                 * sync lock was grabbed. Verify that the current nodeid is\n                 * still valid (ie, not deleted) before continuing.\n                 */\n                if (!isNodeDeleted(dbc, getNodeId())) {\n                    // Update interface information\n                    now = new Date();\n                    updateInterfaces(dbc, now, dbNodeEntry, collectorMap,\n                                     doesSnmp);\n                    \n                    if (doesSnmp) {\n                        InetAddress oldPriIf = null;\n                        if (oldPrimarySnmpInterface != null) {\n                            oldPriIf = oldPrimarySnmpInterface.getIfAddress();\n                        }\n                        InetAddress newSnmpPrimaryIf =\n                            updatePrimarySnmpInterface(dbc, dbNodeEntry,\n                                                       collectorMap, oldPriIf);\n\n                            updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf,\n                                       dbInterfaces, collectorMap);\n                    }\n                    updateCompleted = true;\n                    m_eventList.add(createRescanCompletedEvent(dbNodeEntry));\n                }\n            }\n        } catch (Throwable t) {\n            log().error(\"Error updating records for node ID \" + getNodeId() + \": \" + t, t);\n        } finally {\n            // Finished with the database connection, close it.\n            try {\n                if (dbc != null) {\n                    dbc.close();\n                }\n            } catch (SQLException e) {\n                log().error(\"Error closing connection: \" + e, e);\n            }\n            \n            // Remove the node we just scanned from the tracker set\n            synchronized (m_queuedRescanTracker) {\n                m_queuedRescanTracker.remove(getNodeId());\n            }\n        }\n\n        // Send events associcatd with the rescan\n        if (updateCompleted) {\n            // Send all events created during rescan process to eventd\n            for (Event event : m_eventList) {\n                try {\n                    EventIpcManagerFactory.getIpcManager().sendNow(event);\n                } catch (Throwable t) {\n                    log().warn(\"run: unexpected throwable exception caught \"\n                             + \"while sending event: \" + t, t);\n                }\n            }\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug((m_forceRescan ? \"Forced r\" : \"R\") + \"escan \"\n                      + \"for node w/ nodeid \" + getNodeId()\n                      + \" completed.\");\n        }\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for reparenting an interface's database table\n     * entries under its new node identifier. The following tables are updated:\n     * \n     * ipInterface snmpInterface ifServices\n     * \n     * @param dbc\n     *            Database connection\n     * @param ifAddr\n     *            Interface to be reparented.\n     * @param newNodeId\n     *            Interface's new node identifier\n     * @param oldNodeId\n     *            Interfaces' old node identifier\n     * \n     * @throws SQLException\n     *             if a database error occurs during reparenting.\n     */\n    private void reparentInterface(Connection dbc, InetAddress ifAddr, int ifIndex, int newNodeId, int oldNodeId) throws SQLException {\n        String ipaddr = str(ifAddr);\n        final DBUtils d = new DBUtils(getClass());\n\n        try {\n            PreparedStatement ifLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE_LOOKUP);\n            d.watch(ifLookupStmt);\n            PreparedStatement ifDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE_DELETE);\n            d.watch(ifDeleteStmt);\n            PreparedStatement ipInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE);\n            d.watch(ipInterfaceStmt);\n            PreparedStatement snmpIfLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_LOOKUP);\n            d.watch(snmpIfLookupStmt);\n            PreparedStatement snmpIfDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_DELETE);\n            d.watch(snmpIfDeleteStmt);\n            PreparedStatement snmpInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_INTERFACE);\n            d.watch(snmpInterfaceStmt);\n            PreparedStatement ifServicesLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES_LOOKUP);\n            d.watch(ifServicesLookupStmt);\n            PreparedStatement ifServicesDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES_DELETE);\n            d.watch(ifServicesDeleteStmt);\n            PreparedStatement ifServicesStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES);\n            d.watch(ifServicesStmt);\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"reparentInterface: reparenting address/ifIndex/nodeID: \" + ipaddr + \"/\" + ifIndex + \"/\" + newNodeId);\n            }\n\n\n            /*\n             * SNMP interface\n             *\n             * NOTE: Only reparent SNMP interfaces if we have valid ifIndex\n             */\n            if (ifIndex < 1) {\n                log().debug(\"reparentInterface: don't have a valid ifIndex, skipping snmpInterface table reparenting.\");\n            } else {\n                /*\n                 * NOTE: Now that the snmpInterface table is uniquely keyed\n                 * by nodeId and ifIndex we must only reparent the\n                 * old entry if there isn't already an entry with\n                 * the same nodeid/ifindex pairing. If it can't\n                 * be reparented it will be deleted.\n                 */\n\n                /*\n                 * Look for matching nodeid/ifindex for the entry to be\n                 * reparented\n                 */\n                boolean alreadyExists = false;\n                snmpIfLookupStmt.setInt(1, newNodeId);\n                snmpIfLookupStmt.setInt(2, ifIndex);\n                ResultSet rs = snmpIfLookupStmt.executeQuery();\n                d.watch(rs);\n                if (rs.next()) {\n                    /*\n                     * Looks like we got a match so just delete\n                     * the entry from the old node\n                     */\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" already exists under new node \" + newNodeId + \" in snmpinterface table, deleting from under old node \" + oldNodeId);\n                    }\n                    alreadyExists = true;\n\n                    snmpIfDeleteStmt.setInt(1, oldNodeId);\n                    snmpIfDeleteStmt.setInt(2, ifIndex);\n\n                    snmpIfDeleteStmt.executeUpdate();\n                }\n\n                if (alreadyExists == false) {\n                    /*\n                     * Update the 'snmpinterface' table entry so that this\n                     * interface's nodeID is set to the value of reparentNodeID\n                     */\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" does not yet exist under new node \" + newNodeId + \" in snmpinterface table, reparenting.\");\n                    }\n                    \n                    snmpInterfaceStmt.setInt(1, newNodeId);\n                    snmpInterfaceStmt.setInt(2, oldNodeId);\n                    snmpInterfaceStmt.setString(3, ipaddr);\n                    snmpInterfaceStmt.setInt(4, ifIndex);\n\n                    // execute and log\n                    snmpInterfaceStmt.executeUpdate();\n                }\n            }\n\n            // Look for matching nodeid/ifindex for the entry to be reparented\n            boolean ifAlreadyExists = false;\n            ifLookupStmt.setInt(1, newNodeId);\n            ifLookupStmt.setString(2, ipaddr);\n            ResultSet rs = ifLookupStmt.executeQuery();\n            d.watch(rs);\n            if (rs.next()) {\n                /*\n                 * Looks like we got a match so just delete\n                 * the entry from the old node\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" already exists under new node \" + newNodeId + \" in ipinterface table, deleting from under old node \" + oldNodeId);\n                }\n                ifAlreadyExists = true;\n\n                ifDeleteStmt.setInt(1, oldNodeId);\n                ifDeleteStmt.setString(2, ipaddr);\n\n                ifDeleteStmt.executeUpdate();\n            }\n\n            if (ifAlreadyExists == false) {\n                /*\n                 * Update the 'ipinterface' table entry so that this\n                 * interface's nodeID is set to the value of reparentNodeID\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" does not yet exist under new node \" + newNodeId + \" in ipinterface table, reparenting.\");\n                }\n\n                ipInterfaceStmt.setInt(1, newNodeId);\n                ipInterfaceStmt.setInt(2, oldNodeId);\n                ipInterfaceStmt.setString(3, ipaddr);\n\n                // execute and log\n                ipInterfaceStmt.executeUpdate();\n            }\n            \n            // Look for matching nodeid/ifindex for the entry to be reparented\n            boolean ifsAlreadyExists = false;\n            ifServicesLookupStmt.setInt(1, newNodeId);\n            ifServicesLookupStmt.setString(2, ipaddr);\n            ifServicesLookupStmt.setInt(3, ifIndex);\n            rs = ifServicesLookupStmt.executeQuery();\n            d.watch(rs);\n            if (rs.next()) {\n                /*\n                 * Looks like we got a match so just delete\n                 * the entry from the old node\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" already exists under new node \" + newNodeId + \" in ifservices table, deleting from under old node \" + oldNodeId);\n                }\n                ifsAlreadyExists = true;\n\n                ifServicesDeleteStmt.setInt(1, oldNodeId);\n                ifServicesDeleteStmt.setString(2, ipaddr);\n\n                ifServicesDeleteStmt.executeUpdate();\n            }\n\n            if (ifsAlreadyExists == false) {\n                /*\n                 * Update the 'snmpinterface' table entry so that this\n                 * interface's nodeID is set to the value of reparentNodeID\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" does not yet exist under new node \" + newNodeId + \" in ifservices table, reparenting.\");\n                }\n\n                /*\n                 * Update the 'nodeID' field of all 'ifservices' table entries\n                 * for the reparented interfaces.\n                 */\n                ifServicesStmt.setInt(1, newNodeId);\n                ifServicesStmt.setInt(2, oldNodeId);\n                ifServicesStmt.setString(3, ipaddr);\n\n                // execute and log\n                ifServicesStmt.executeUpdate();\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"reparentInterface: reparented \" + ipaddr + \" : ifIndex: \" + ifIndex + \" : oldNodeID: \" + oldNodeId + \" newNodeID: \" + newNodeId);\n            }\n        } catch (SQLException sqlE) {\n            log().error(\"SQLException while reparenting addr/ifindex/nodeid \" + ipaddr + \"/\" + ifIndex + \"/\" + oldNodeId);\n            throw sqlE;\n        } finally {\n            d.cleanUp();\n        }\n    }","id":79488,"modified_method":"/**\n     * This method is responsible for reparenting an interface's database table\n     * entries under its new node identifier. The following tables are updated:\n     * \n     * ipInterface snmpInterface ifServices\n     * \n     * @param dbc\n     *            Database connection\n     * @param ifAddr\n     *            Interface to be reparented.\n     * @param newNodeId\n     *            Interface's new node identifier\n     * @param oldNodeId\n     *            Interfaces' old node identifier\n     * \n     * @throws SQLException\n     *             if a database error occurs during reparenting.\n     */\n    private static void reparentInterface(Connection dbc, InetAddress ifAddr, int ifIndex, int newNodeId, int oldNodeId) throws SQLException {\n        String ipaddr = str(ifAddr);\n        final DBUtils d = new DBUtils(RescanProcessor.class);\n\n        try {\n            PreparedStatement ifLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE_LOOKUP);\n            d.watch(ifLookupStmt);\n            PreparedStatement ifDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE_DELETE);\n            d.watch(ifDeleteStmt);\n            PreparedStatement ipInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE);\n            d.watch(ipInterfaceStmt);\n            PreparedStatement snmpIfLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_LOOKUP);\n            d.watch(snmpIfLookupStmt);\n            PreparedStatement snmpIfDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_DELETE);\n            d.watch(snmpIfDeleteStmt);\n            PreparedStatement snmpInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_INTERFACE);\n            d.watch(snmpInterfaceStmt);\n            PreparedStatement ifServicesLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES_LOOKUP);\n            d.watch(ifServicesLookupStmt);\n            PreparedStatement ifServicesDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES_DELETE);\n            d.watch(ifServicesDeleteStmt);\n            PreparedStatement ifServicesStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES);\n            d.watch(ifServicesStmt);\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"reparentInterface: reparenting address/ifIndex/nodeID: \" + ipaddr + \"/\" + ifIndex + \"/\" + newNodeId);\n            }\n\n\n            /*\n             * SNMP interface\n             *\n             * NOTE: Only reparent SNMP interfaces if we have valid ifIndex\n             */\n            if (ifIndex < 1) {\n                log().debug(\"reparentInterface: don't have a valid ifIndex, skipping snmpInterface table reparenting.\");\n            } else {\n                /*\n                 * NOTE: Now that the snmpInterface table is uniquely keyed\n                 * by nodeId and ifIndex we must only reparent the\n                 * old entry if there isn't already an entry with\n                 * the same nodeid/ifindex pairing. If it can't\n                 * be reparented it will be deleted.\n                 */\n\n                /*\n                 * Look for matching nodeid/ifindex for the entry to be\n                 * reparented\n                 */\n                boolean alreadyExists = false;\n                snmpIfLookupStmt.setInt(1, newNodeId);\n                snmpIfLookupStmt.setInt(2, ifIndex);\n                ResultSet rs = snmpIfLookupStmt.executeQuery();\n                d.watch(rs);\n                if (rs.next()) {\n                    /*\n                     * Looks like we got a match so just delete\n                     * the entry from the old node\n                     */\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" already exists under new node \" + newNodeId + \" in snmpinterface table, deleting from under old node \" + oldNodeId);\n                    }\n                    alreadyExists = true;\n\n                    snmpIfDeleteStmt.setInt(1, oldNodeId);\n                    snmpIfDeleteStmt.setInt(2, ifIndex);\n\n                    snmpIfDeleteStmt.executeUpdate();\n                }\n\n                if (alreadyExists == false) {\n                    /*\n                     * Update the 'snmpinterface' table entry so that this\n                     * interface's nodeID is set to the value of reparentNodeID\n                     */\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" does not yet exist under new node \" + newNodeId + \" in snmpinterface table, reparenting.\");\n                    }\n                    \n                    snmpInterfaceStmt.setInt(1, newNodeId);\n                    snmpInterfaceStmt.setInt(2, oldNodeId);\n                    snmpInterfaceStmt.setString(3, ipaddr);\n                    snmpInterfaceStmt.setInt(4, ifIndex);\n\n                    // execute and log\n                    snmpInterfaceStmt.executeUpdate();\n                }\n            }\n\n            // Look for matching nodeid/ifindex for the entry to be reparented\n            boolean ifAlreadyExists = false;\n            ifLookupStmt.setInt(1, newNodeId);\n            ifLookupStmt.setString(2, ipaddr);\n            ResultSet rs = ifLookupStmt.executeQuery();\n            d.watch(rs);\n            if (rs.next()) {\n                /*\n                 * Looks like we got a match so just delete\n                 * the entry from the old node\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" already exists under new node \" + newNodeId + \" in ipinterface table, deleting from under old node \" + oldNodeId);\n                }\n                ifAlreadyExists = true;\n\n                ifDeleteStmt.setInt(1, oldNodeId);\n                ifDeleteStmt.setString(2, ipaddr);\n\n                ifDeleteStmt.executeUpdate();\n            }\n\n            if (ifAlreadyExists == false) {\n                /*\n                 * Update the 'ipinterface' table entry so that this\n                 * interface's nodeID is set to the value of reparentNodeID\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" does not yet exist under new node \" + newNodeId + \" in ipinterface table, reparenting.\");\n                }\n\n                ipInterfaceStmt.setInt(1, newNodeId);\n                ipInterfaceStmt.setInt(2, oldNodeId);\n                ipInterfaceStmt.setString(3, ipaddr);\n\n                // execute and log\n                ipInterfaceStmt.executeUpdate();\n            }\n            \n            // Look for matching nodeid/ifindex for the entry to be reparented\n            boolean ifsAlreadyExists = false;\n            ifServicesLookupStmt.setInt(1, newNodeId);\n            ifServicesLookupStmt.setString(2, ipaddr);\n            ifServicesLookupStmt.setInt(3, ifIndex);\n            rs = ifServicesLookupStmt.executeQuery();\n            d.watch(rs);\n            if (rs.next()) {\n                /*\n                 * Looks like we got a match so just delete\n                 * the entry from the old node\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" already exists under new node \" + newNodeId + \" in ifservices table, deleting from under old node \" + oldNodeId);\n                }\n                ifsAlreadyExists = true;\n\n                ifServicesDeleteStmt.setInt(1, oldNodeId);\n                ifServicesDeleteStmt.setString(2, ipaddr);\n\n                ifServicesDeleteStmt.executeUpdate();\n            }\n\n            if (ifsAlreadyExists == false) {\n                /*\n                 * Update the 'snmpinterface' table entry so that this\n                 * interface's nodeID is set to the value of reparentNodeID\n                 */\n                if (log().isDebugEnabled()) {\n                    log().debug(\"reparentInterface: interface with ifindex \" + ifIndex + \" does not yet exist under new node \" + newNodeId + \" in ifservices table, reparenting.\");\n                }\n\n                /*\n                 * Update the 'nodeID' field of all 'ifservices' table entries\n                 * for the reparented interfaces.\n                 */\n                ifServicesStmt.setInt(1, newNodeId);\n                ifServicesStmt.setInt(2, oldNodeId);\n                ifServicesStmt.setString(3, ipaddr);\n\n                // execute and log\n                ifServicesStmt.executeUpdate();\n            }\n\n            if (log().isDebugEnabled()) {\n                log().debug(\"reparentInterface: reparented \" + ipaddr + \" : ifIndex: \" + ifIndex + \" : oldNodeID: \" + oldNodeId + \" newNodeID: \" + newNodeId);\n            }\n        } catch (SQLException sqlE) {\n            log().error(\"SQLException while reparenting addr/ifindex/nodeid \" + ipaddr + \"/\" + ifIndex + \"/\" + oldNodeId);\n            throw sqlE;\n        } finally {\n            d.cleanUp();\n        }\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible to delete any interface associated with the\n     * duplicate node, delete any entry left in ifservices table and\n     * snmpinterface table for the duplicate node, and make the node as\n     * 'deleted'.\n     * \n     * @param dbc\n     *            Database Connection\n     * @param duplicateNode\n     *            Duplicate node to delete.\n     * \n     */\n    private void deleteDuplicateNode(Connection dbc, DbNodeEntry duplicateNode) throws SQLException {\n\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            PreparedStatement ifStmt = dbc.prepareStatement(SQL_DB_DELETE_DUP_INTERFACE);\n            d.watch(ifStmt);\n            PreparedStatement svcStmt = dbc.prepareStatement(SQL_DB_DELETE_DUP_SERVICES);\n            d.watch(svcStmt);\n            PreparedStatement snmpStmt = dbc.prepareStatement(SQL_DB_DELETE_DUP_SNMPINTERFACE);\n            d.watch(snmpStmt);\n            ifStmt.setInt(1, duplicateNode.getNodeId());\n            svcStmt.setInt(1, duplicateNode.getNodeId());\n            snmpStmt.setInt(1, duplicateNode.getNodeId());\n\n            ifStmt.executeUpdate();\n            svcStmt.executeUpdate();\n            snmpStmt.executeUpdate();\n\n            duplicateNode.setNodeType(DbNodeEntry.NODE_TYPE_DELETED);\n            duplicateNode.store(dbc);\n        } catch (SQLException sqlE) {\n            log().error(\"deleteDuplicateNode  SQLException while deleting duplicate node: \" + duplicateNode.getNodeId());\n            throw sqlE;\n        } finally {\n            d.cleanUp();\n        }\n\n    }","id":79489,"modified_method":"/**\n     * This method is responsible to delete any interface associated with the\n     * duplicate node, delete any entry left in ifservices table and\n     * snmpinterface table for the duplicate node, and make the node as\n     * 'deleted'.\n     * \n     * @param dbc\n     *            Database Connection\n     * @param duplicateNode\n     *            Duplicate node to delete.\n     * \n     */\n    private static void deleteDuplicateNode(Connection dbc, DbNodeEntry duplicateNode) throws SQLException {\n\n        final DBUtils d = new DBUtils(RescanProcessor.class);\n        try {\n            PreparedStatement ifStmt = dbc.prepareStatement(SQL_DB_DELETE_DUP_INTERFACE);\n            d.watch(ifStmt);\n            PreparedStatement svcStmt = dbc.prepareStatement(SQL_DB_DELETE_DUP_SERVICES);\n            d.watch(svcStmt);\n            PreparedStatement snmpStmt = dbc.prepareStatement(SQL_DB_DELETE_DUP_SNMPINTERFACE);\n            d.watch(snmpStmt);\n            ifStmt.setInt(1, duplicateNode.getNodeId());\n            svcStmt.setInt(1, duplicateNode.getNodeId());\n            snmpStmt.setInt(1, duplicateNode.getNodeId());\n\n            ifStmt.executeUpdate();\n            svcStmt.executeUpdate();\n            snmpStmt.executeUpdate();\n\n            duplicateNode.setNodeType(DbNodeEntry.NODE_TYPE_DELETED);\n            duplicateNode.store(dbc);\n        } catch (SQLException sqlE) {\n            log().error(\"deleteDuplicateNode  SQLException while deleting duplicate node: \" + duplicateNode.getNodeId());\n            throw sqlE;\n        } finally {\n            d.cleanUp();\n        }\n\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n        }\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            final String addr = str(currPrimarySnmpIf);\n\t\t\tIfCollector primaryIfc = addr == null? null : collectorMap.get(addr);\n            if (primaryIfc == null) {\n                for (IfCollector tmp : collectorMap.values()) {\n                    if (tmp.getSnmpCollector() != null) {\n                        primaryIfc = tmp;\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String sysName = sysgrp.getSysName();\n                if (sysName != null && sysName.length() > 0) {\n                    currNodeEntry.setSystemName(sysName);\n                }\n\n                // sysDescription\n                String sysDescr = sysgrp.getSysDescr();\n                if (sysDescr != null && sysDescr.length() > 0) {\n                    currNodeEntry.setSystemDescription(sysDescr);\n                }\n\n                // sysLocation\n                String sysLocation = sysgrp.getSysLocation();\n                if (sysLocation != null && sysLocation.length() > 0) {\n                    currNodeEntry.setSystemLocation(sysLocation);\n                }\n\n                // sysContact\n                String sysContact = sysgrp.getSysContact();\n                if (sysContact != null && sysContact.length() > 0) {\n                    currNodeEntry.setSystemContact(sysContact);\n                }\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","id":79490,"modified_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n        }\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            final String addr = str(currPrimarySnmpIf);\n\t\t\tIfCollector primaryIfc = addr == null? null : collectorMap.get(addr);\n            if (primaryIfc == null) {\n                for (IfCollector tmp : collectorMap.values()) {\n                    if (tmp.getSnmpCollector() != null) {\n                        primaryIfc = tmp;\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String sysName = sysgrp.getSysName();\n                if (sysName != null && sysName.length() > 0) {\n                    currNodeEntry.setSystemName(sysName);\n                }\n\n                // sysDescription\n                String sysDescr = sysgrp.getSysDescr();\n                if (sysDescr != null && sysDescr.length() > 0) {\n                    currNodeEntry.setSystemDescription(sysDescr);\n                }\n\n                // sysLocation\n                String sysLocation = sysgrp.getSysLocation();\n                if (sysLocation != null && sysLocation.length() > 0) {\n                    currNodeEntry.setSystemLocation(sysLocation);\n                }\n\n                // sysContact\n                String sysContact = sysgrp.getSysContact();\n                if (sysContact != null && sysContact.length() > 0) {\n                    currNodeEntry.setSystemContact(sysContact);\n                }\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            m_eventList.add(createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry));\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            m_eventList.add(createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry));\n        }\n\n        return dbNodeEntry;\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a duplicateIpAddress event and\n     * adding it to the event list.\n     * \n     * @param ifEntry\n     *            Entry of new interface.\n     */\n    private void createDuplicateIpAddressEvent(final DbIpInterfaceEntry ifEntry) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateIpAddressEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress);\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.DUPLICATE_IPINTERFACE_EVENT_UEI, ifEntry.getNodeId(), ifAddress);\n\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add discovery method\n        bldr.addParam(EventConstants.PARM_METHOD, \"icmp\");\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateIpAddressEvent: successfully created duplicateIpAddress event for nodeid: \" + ifEntry.getNodeId());\n        }\n    }","id":79491,"modified_method":"/**\n     * This method is responsible for generating a duplicateIpAddress event and\n     * adding it to the event list.\n     * \n     * @param ifEntry\n     *            Entry of new interface.\n\t * @return \n     */\n    private static Event createDuplicateIpAddressEvent(final DbIpInterfaceEntry ifEntry) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateIpAddressEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress);\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.DUPLICATE_IPINTERFACE_EVENT_UEI, ifEntry.getNodeId(), ifAddress);\n\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add discovery method\n        bldr.addParam(EventConstants.PARM_METHOD, \"icmp\");\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateIpAddressEvent: successfully created duplicateIpAddress event for nodeid: \" + ifEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a nodeGainedInterface event and\n     * adding it to the event list.\n     * \n     * @param ifEntry\n     *            Entry of new interface.\n     */\n    private void createNodeGainedInterfaceEvent(DbIpInterfaceEntry ifEntry) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedInterfaceEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress);\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI, ifEntry.getNodeId(), ifAddress);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add discovery method\n        bldr.addParam(EventConstants.PARM_METHOD, \"icmp\");\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedInterfaceEvent: successfully created nodeGainedInterface event for nodeid: \" + ifEntry.getNodeId());\n        }\n    }","id":79492,"modified_method":"/**\n     * This method is responsible for generating a nodeGainedInterface event and\n     * adding it to the event list.\n     * \n     * @param ifEntry\n     *            Entry of new interface.\n     * @return \n     */\n    private static Event createNodeGainedInterfaceEvent(DbIpInterfaceEntry ifEntry) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedInterfaceEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress);\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI, ifEntry.getNodeId(), ifAddress);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add discovery method\n        bldr.addParam(EventConstants.PARM_METHOD, \"icmp\");\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedInterfaceEvent: successfully created nodeGainedInterface event for nodeid: \" + ifEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Determines if any SNMP data collection related events need to be\n     * generated based upon the results of the current rescan. If necessary will\n     * generate one of the following events: 'reinitializePrimarySnmpInterface'\n     * 'primarySnmpInterfaceChanged'\n     * \n     * @param nodeEntry\n     *            DbNodeEntry object of the node being rescanned.\n     * @param oldPriIf\n     *            Previous primary SNMP interface (from the DB).\n     * @param primarySnmpIf\n     *            Primary SNMP interface as determined by the current rescan.\n     */\n    private void generateSnmpDataCollectionEvents(DbNodeEntry nodeEntry, InetAddress oldPriIf, InetAddress primarySnmpIf) {\n        /*\n         * NOTE: If SNMP service was not previously supported on this node\n         * then oldPriIf will be null. If this is the case\n         * then no need to generate primarySnmpInterfaceChanged event,\n         * the nodeGainedService event generated due to the addition of\n         * SNMP is sufficient.\n         */\n        boolean reInit = true;\n        if (oldPriIf == null && primarySnmpIf != null) {\n            reInit = false;\n            log().debug(\"generateSnmpDataCollectionEvents: Either SNMP support was recently enabled on this node, or node doesn't support ipAddrTable MIB.\");\n            createPrimarySnmpInterfaceChangedEvent(nodeEntry.getNodeId(), primarySnmpIf, null);\n        } else {\n            /*\n             * A PrimarySnmpInterfaceChanged event is generated if the scan\n             * found a different primary SNMP interface than what is stored\n             * in the database.\n             */\n            if (primarySnmpIf != null && !oldPriIf.equals(primarySnmpIf)) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"generateSnmpDataCollectionEvents: primary SNMP interface has changed.  Was: \" + str(oldPriIf) + \" Is: \" + str(primarySnmpIf));\n                }\n                createPrimarySnmpInterfaceChangedEvent(nodeEntry.getNodeId(), primarySnmpIf, oldPriIf);\n                reInit = false;\n            }\n        }\n\n        /*\n         * An interface map is built by the SNMP poller when the primary\n         * SNMP interface is initialized by the service monitor. This map\n         * is used to associate each interface on the node with its\n         * ifIndex and ifLabel for purposes of performing data collection\n         * and storage. If an ifIndex has changed for one or more\n         * interfaces or if a new interface was added to the node then\n         * the primary SNMP interface must be reinitialized so that this\n         * interface map can be rebuilt with the new information.\n         */\n        if (reInit && (m_ifIndexOnNodeChangedFlag || m_snmpIfTableChangedFlag)) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"generateSnmpDataCollectionEvents: Generating reinitializeSnmpInterface event for interface \" + str(primarySnmpIf));\n            }\n            createReinitializePrimarySnmpInterfaceEvent(nodeEntry.getNodeId(), primarySnmpIf);\n        }\n    }","id":79493,"modified_method":"/**\n     * Determines if any SNMP data collection related events need to be\n     * generated based upon the results of the current rescan. If necessary will\n     * generate one of the following events: 'reinitializePrimarySnmpInterface'\n     * 'primarySnmpInterfaceChanged'\n     * \n     * @param nodeEntry\n     *            DbNodeEntry object of the node being rescanned.\n     * @param oldPriIf\n     *            Previous primary SNMP interface (from the DB).\n     * @param primarySnmpIf\n     *            Primary SNMP interface as determined by the current rescan.\n     */\n    private void generateSnmpDataCollectionEvents(DbNodeEntry nodeEntry, InetAddress oldPriIf, InetAddress primarySnmpIf) {\n        /*\n         * NOTE: If SNMP service was not previously supported on this node\n         * then oldPriIf will be null. If this is the case\n         * then no need to generate primarySnmpInterfaceChanged event,\n         * the nodeGainedService event generated due to the addition of\n         * SNMP is sufficient.\n         */\n        boolean reInit = true;\n        if (oldPriIf == null && primarySnmpIf != null) {\n            reInit = false;\n            log().debug(\"generateSnmpDataCollectionEvents: Either SNMP support was recently enabled on this node, or node doesn't support ipAddrTable MIB.\");\n            m_eventList.add(createPrimarySnmpInterfaceChangedEvent(nodeEntry.getNodeId(), primarySnmpIf, null));\n        } else {\n            /*\n             * A PrimarySnmpInterfaceChanged event is generated if the scan\n             * found a different primary SNMP interface than what is stored\n             * in the database.\n             */\n            if (primarySnmpIf != null && !oldPriIf.equals(primarySnmpIf)) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"generateSnmpDataCollectionEvents: primary SNMP interface has changed.  Was: \" + str(oldPriIf) + \" Is: \" + str(primarySnmpIf));\n                }\n                m_eventList.add(createPrimarySnmpInterfaceChangedEvent(nodeEntry.getNodeId(), primarySnmpIf, oldPriIf));\n                reInit = false;\n            }\n        }\n\n        /*\n         * An interface map is built by the SNMP poller when the primary\n         * SNMP interface is initialized by the service monitor. This map\n         * is used to associate each interface on the node with its\n         * ifIndex and ifLabel for purposes of performing data collection\n         * and storage. If an ifIndex has changed for one or more\n         * interfaces or if a new interface was added to the node then\n         * the primary SNMP interface must be reinitialized so that this\n         * interface map can be rebuilt with the new information.\n         */\n        if (reInit && (m_ifIndexOnNodeChangedFlag || m_snmpIfTableChangedFlag)) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"generateSnmpDataCollectionEvents: Generating reinitializeSnmpInterface event for interface \" + str(primarySnmpIf));\n            }\n            m_eventList.add(createReinitializePrimarySnmpInterfaceEvent(nodeEntry.getNodeId(), primarySnmpIf));\n        }\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a duplicateNodeDeleted event\n     * and adding it to the event list.\n     * \n     * @param deletedNode\n     *            Entry of duplciate node which was deleted.\n     */\n    private void createDuplicateNodeDeletedEvent(DbNodeEntry deletedNode) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateNodeDeletedEvent: delete nodeid: \" + deletedNode.getNodeId());\n        }\n\n        EventBuilder bldr = nodeEventBuilder(EventConstants.DUP_NODE_DELETED_EVENT_UEI, deletedNode.getNodeId());\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateNodeDeletedEvent: successfully created duplicateNodeDeleted event for nodeid: \" + deletedNode.getNodeId());\n        }\n    }","id":79494,"modified_method":"/**\n     * This method is responsible for generating a duplicateNodeDeleted event\n     * and adding it to the event list.\n     * \n     * @param deletedNode\n     *            Entry of duplciate node which was deleted.\n     * @return \n     */\n    private static Event createDuplicateNodeDeletedEvent(DbNodeEntry deletedNode) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateNodeDeletedEvent: delete nodeid: \" + deletedNode.getNodeId());\n        }\n\n        EventBuilder bldr = nodeEventBuilder(EventConstants.DUP_NODE_DELETED_EVENT_UEI, deletedNode.getNodeId());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createDuplicateNodeDeletedEvent: successfully created duplicateNodeDeleted event for nodeid: \" + deletedNode.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating an ipHostNameChanged event and\n     * adding it to the event list.\n     * \n     * @param updatedEntry\n     *            updated IP interface database entry\n     * @param originalEntry\n     *            original IP interface database entry\n     */\n    private void createIpHostNameChangedEvent(final DbIpInterfaceEntry updatedEntry, final DbIpInterfaceEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createIpHostNameChangedEvent: nodeId: \" + updatedEntry.getNodeId() + \" oldHostName: \" + originalEntry.getHostname() + \" newHostName: \" + updatedEntry.getHostname());\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_IP_HOSTNAME_CHANGED_EVENT_UEI, updatedEntry.getNodeId(), str(updatedEntry.getIfAddress()));\n        \n        // Add old IP Hostname\n        if (originalEntry.getHostname() != null) {\n            bldr.addParam(EventConstants.PARM_OLD_IP_HOSTNAME, originalEntry.getHostname());\n        }\n\n        // Add new IP Hostname\n        if (updatedEntry.getHostname() != null) {\n            bldr.addParam(EventConstants.PARM_IP_HOSTNAME, updatedEntry.getHostname());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createIpHostNameChangedEvent: successfully created ipHostNameChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n    }","id":79495,"modified_method":"/**\n     * This method is responsible for generating an ipHostNameChanged event and\n     * adding it to the event list.\n     * \n     * @param updatedEntry\n     *            updated IP interface database entry\n     * @param originalEntry\n     *            original IP interface database entry\n     * @return \n     */\n    private static Event createIpHostNameChangedEvent(final DbIpInterfaceEntry updatedEntry, final DbIpInterfaceEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createIpHostNameChangedEvent: nodeId: \" + updatedEntry.getNodeId() + \" oldHostName: \" + originalEntry.getHostname() + \" newHostName: \" + updatedEntry.getHostname());\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_IP_HOSTNAME_CHANGED_EVENT_UEI, updatedEntry.getNodeId(), str(updatedEntry.getIfAddress()));\n        \n        // Add old IP Hostname\n        if (originalEntry.getHostname() != null) {\n            bldr.addParam(EventConstants.PARM_OLD_IP_HOSTNAME, originalEntry.getHostname());\n        }\n\n        // Add new IP Hostname\n        if (updatedEntry.getHostname() != null) {\n            bldr.addParam(EventConstants.PARM_IP_HOSTNAME, updatedEntry.getHostname());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createIpHostNameChangedEvent: successfully created ipHostNameChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a primarySnmpInterfaceChanged\n     * event and adding it to the event list.\n     * \n     * @param nodeId\n     *            Nodeid of node being rescanned.\n     * @param newPrimaryIf\n     *            new primary SNMP interface address\n     * @param oldPrimaryIf\n     *            old primary SNMP interface address\n     */\n    private void createPrimarySnmpInterfaceChangedEvent(final int nodeId, final InetAddress newPrimaryIf, final InetAddress oldPrimaryIf) {\n        String oldPrimaryAddr = null;\n        if (oldPrimaryIf != null) {\n            oldPrimaryAddr = str(oldPrimaryIf);\n        }\n\n        String newPrimaryAddr = null;\n        if (newPrimaryIf != null) {\n            newPrimaryAddr = str(newPrimaryIf);\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createPrimarySnmpInterfaceChangedEvent: nodeId: \" + nodeId + \"oldPrimarySnmpIf: '\" + oldPrimaryAddr + \"' newPrimarySnmpIf: '\" + newPrimaryAddr + \"'\");\n        }\n\n        final EventBuilder bldr = serviceEventBuilder(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI, nodeId, newPrimaryAddr, \"SNMP\");\n\n        if (oldPrimaryAddr != null) {\n            bldr.addParam(EventConstants.PARM_OLD_PRIMARY_SNMP_ADDRESS, oldPrimaryAddr);\n        }\n\n        if (newPrimaryAddr != null) {\n            bldr.addParam(EventConstants.PARM_NEW_PRIMARY_SNMP_ADDRESS, newPrimaryAddr);\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createPrimarySnmpInterfaceChangedEvent: successfully created primarySnmpInterfaceChanged event for nodeid: \" + nodeId);\n        }\n    }","id":79496,"modified_method":"/**\n     * This method is responsible for generating a primarySnmpInterfaceChanged\n     * event and adding it to the event list.\n     * \n     * @param nodeId\n     *            Nodeid of node being rescanned.\n     * @param newPrimaryIf\n     *            new primary SNMP interface address\n     * @param oldPrimaryIf\n     *            old primary SNMP interface address\n     * @return \n     */\n    private static Event createPrimarySnmpInterfaceChangedEvent(final int nodeId, final InetAddress newPrimaryIf, final InetAddress oldPrimaryIf) {\n        String oldPrimaryAddr = null;\n        if (oldPrimaryIf != null) {\n            oldPrimaryAddr = str(oldPrimaryIf);\n        }\n\n        String newPrimaryAddr = null;\n        if (newPrimaryIf != null) {\n            newPrimaryAddr = str(newPrimaryIf);\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createPrimarySnmpInterfaceChangedEvent: nodeId: \" + nodeId + \"oldPrimarySnmpIf: '\" + oldPrimaryAddr + \"' newPrimarySnmpIf: '\" + newPrimaryAddr + \"'\");\n        }\n\n        final EventBuilder bldr = serviceEventBuilder(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI, nodeId, newPrimaryAddr, \"SNMP\");\n\n        if (oldPrimaryAddr != null) {\n            bldr.addParam(EventConstants.PARM_OLD_PRIMARY_SNMP_ADDRESS, oldPrimaryAddr);\n        }\n\n        if (newPrimaryAddr != null) {\n            bldr.addParam(EventConstants.PARM_NEW_PRIMARY_SNMP_ADDRESS, newPrimaryAddr);\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createPrimarySnmpInterfaceChangedEvent: successfully created primarySnmpInterfaceChanged event for nodeid: \" + nodeId);\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a nodeInfoChanged event and\n     * adding it to the event list.\n     * \n     * @param updatedEntry\n     *            Updated node entry object\n     * @param originalEntry\n     *            Original node entry object\n     */\n    private void createNodeInfoChangedEvent(DbNodeEntry updatedEntry, DbNodeEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeInfoChangedEvent: nodeId: \" + updatedEntry.getNodeId());\n        }\n\n        EventBuilder bldr = nodeEventBuilder(EventConstants.NODE_INFO_CHANGED_EVENT_UEI, updatedEntry.getNodeId());\n\n        // SysOID\n        if (updatedEntry.getSystemOID() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSOID, updatedEntry.getSystemOID());\n        }\n\n        // SysName\n        if (updatedEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, updatedEntry.getSystemName());\n        }\n\n        // SysDescription\n        if (updatedEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, updatedEntry.getSystemDescription());\n        }\n\n        // SysLocation\n        if (updatedEntry.getSystemLocation() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSLOCATION, updatedEntry.getSystemLocation());\n        }\n\n        // SysContact\n        if (updatedEntry.getSystemContact() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSCONTACT, updatedEntry.getSystemContact());\n        }\n\n        // NetBIOS name\n        if (updatedEntry.getNetBIOSName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_NETBIOS_NAME, updatedEntry.getNetBIOSName());\n        }\n\n        // Domain name\n        if (updatedEntry.getDomainName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_DOMAIN_NAME, updatedEntry.getDomainName());\n        }\n\n        // Operating System\n        if (updatedEntry.getOS() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_OPERATING_SYSTEM, updatedEntry.getOS());\n        }\n\n        // / Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeInfoChangedEvent: successfully created nodeInfoChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n    }","id":79497,"modified_method":"/**\n     * This method is responsible for generating a nodeInfoChanged event and\n     * adding it to the event list.\n     * \n     * @param updatedEntry\n     *            Updated node entry object\n     * @param originalEntry\n     *            Original node entry object\n     */\n    private static Event createNodeInfoChangedEvent(DbNodeEntry updatedEntry, DbNodeEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeInfoChangedEvent: nodeId: \" + updatedEntry.getNodeId());\n        }\n\n        EventBuilder bldr = nodeEventBuilder(EventConstants.NODE_INFO_CHANGED_EVENT_UEI, updatedEntry.getNodeId());\n\n        // SysOID\n        if (updatedEntry.getSystemOID() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSOID, updatedEntry.getSystemOID());\n        }\n\n        // SysName\n        if (updatedEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, updatedEntry.getSystemName());\n        }\n\n        // SysDescription\n        if (updatedEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, updatedEntry.getSystemDescription());\n        }\n\n        // SysLocation\n        if (updatedEntry.getSystemLocation() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSLOCATION, updatedEntry.getSystemLocation());\n        }\n\n        // SysContact\n        if (updatedEntry.getSystemContact() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSCONTACT, updatedEntry.getSystemContact());\n        }\n\n        // NetBIOS name\n        if (updatedEntry.getNetBIOSName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_NETBIOS_NAME, updatedEntry.getNetBIOSName());\n        }\n\n        // Domain name\n        if (updatedEntry.getDomainName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_DOMAIN_NAME, updatedEntry.getDomainName());\n        }\n\n        // Operating System\n        if (updatedEntry.getOS() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_OPERATING_SYSTEM, updatedEntry.getOS());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeInfoChangedEvent: successfully created nodeInfoChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a interfaceReparented event and\n     * adding it to the event list.\n     * \n     * @param newNode\n     *            Entry of node under which the interface was added.\n     * @param oldNodeId\n     *            Node identifier of node from which the interface was removed.\n     * @param reparentedIf\n     *            Reparented interface\n     */\n    private void createInterfaceReparentedEvent(final DbNodeEntry newNode, final int oldNodeId, final InetAddress reparentedIf) {\n        final String reparentedAddress = str(reparentedIf);\n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceReparentedEvent: ifAddr: \" + reparentedAddress + \" oldNodeId: \" + oldNodeId + \" newNodeId: \" + newNode.getNodeId());\n        }\n\n        \n        EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_REPARENTED_EVENT_UEI, newNode.getNodeId(), reparentedAddress);\n\n        // Add old node id\n        bldr.addParam(EventConstants.PARM_OLD_NODEID, oldNodeId);\n\n        // Add new node id\n        bldr.addParam(EventConstants.PARM_NEW_NODEID, newNode.getNodeId());\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, reparentedIf.getHostName());\n\n        // Add node label and node label source\n        if (newNode.getLabel() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_LABEL, newNode.getLabel());\n            bldr.addParam(EventConstants.PARM_NODE_LABEL_SOURCE, newNode.getLabelSource());\n        }\n\n        // Add nodeSysName\n        if (newNode.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, newNode.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (newNode.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, newNode.getSystemDescription());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceReparentedEvent: successfully created interfaceReparented event for nodeid/interface: \" + newNode.getNodeId() + \"/\" + reparentedAddress);\n        }\n    }","id":79498,"modified_method":"/**\n     * This method is responsible for generating a interfaceReparented event and\n     * adding it to the event list.\n     * \n     * @param newNode\n     *            Entry of node under which the interface was added.\n     * @param oldNodeId\n     *            Node identifier of node from which the interface was removed.\n     * @param reparentedIf\n     *            Reparented interface\n     * @return \n     */\n    private static Event createInterfaceReparentedEvent(final DbNodeEntry newNode, final int oldNodeId, final InetAddress reparentedIf) {\n        final String reparentedAddress = str(reparentedIf);\n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceReparentedEvent: ifAddr: \" + reparentedAddress + \" oldNodeId: \" + oldNodeId + \" newNodeId: \" + newNode.getNodeId());\n        }\n\n        \n        EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_REPARENTED_EVENT_UEI, newNode.getNodeId(), reparentedAddress);\n\n        // Add old node id\n        bldr.addParam(EventConstants.PARM_OLD_NODEID, oldNodeId);\n\n        // Add new node id\n        bldr.addParam(EventConstants.PARM_NEW_NODEID, newNode.getNodeId());\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, reparentedIf.getHostName());\n\n        // Add node label and node label source\n        if (newNode.getLabel() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_LABEL, newNode.getLabel());\n            bldr.addParam(EventConstants.PARM_NODE_LABEL_SOURCE, newNode.getLabelSource());\n        }\n\n        // Add nodeSysName\n        if (newNode.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, newNode.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (newNode.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, newNode.getSystemDescription());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceReparentedEvent: successfully created interfaceReparented event for nodeid/interface: \" + newNode.getNodeId() + \"/\" + reparentedAddress);\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the status of services for an\n     * interface during a forced rescan\n     * \n     * @param node\n     *            Node entry for the node being rescanned\n     * @param dbIpIfEntry\n     *            interface entry of the updating interface\n     * @param dbSupportedServices\n     *            services on the updating interface\n     * \n     * @throws SQLException\n     *             if there is a problem updating the snmpInterface table.\n     */\n    private void updateServicesOnForcedRescan(DbNodeEntry node, DbIpInterfaceEntry dbIpIfEntry, DbIfServiceEntry[] dbSupportedServices) throws SQLException {\n        /*\n         * Now process previously existing protocols to update polling status.\n         * Additional checks on forced rescan for existing services go here.\n         * Specifically, has service been forced managed/unmanaged or has\n         * polling status changed?\n         */\n\n        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();\n        CapsdConfig cFactory = CapsdConfigFactory.getInstance();\n        InetAddress ifaddr = dbIpIfEntry.getIfAddress();\n        org.opennms.netmgt.config.poller.Package ipPkg = null;\n\n        boolean ipToBePolled = false;\n        final String ifaddrString = str(ifaddr);\n        ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n        if (ipPkg != null) {\n            ipToBePolled = true;\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateServicesOnForcedRescan: Checking status of existing services on host \" + ifaddr);\n        }\n\n        // Get service names from database\n        java.sql.Connection ctest = null;\n        ResultSet rs = null;\n        Map<Integer, String> serviceNames = new HashMap<Integer, String>();\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            ctest = DataSourceFactory.getInstance().getConnection();\n            d.watch(ctest);\n            PreparedStatement loadStmt = ctest.prepareStatement(SQL_RETRIEVE_SERVICE_IDS);\n            d.watch(loadStmt);\n\n            // go ahead and load the service table\n            rs = loadStmt.executeQuery();\n            d.watch(rs);\n            while (rs.next()) {\n                Integer id = new Integer(rs.getInt(1));\n                String name = rs.getString(2);\n                serviceNames.put(id, name);\n            }\n        } catch (Throwable t) {\n            log().error(\"Error reading services table\", t);\n        } finally {\n            d.cleanUp();\n        }\n\n        for (int i = 0; i < dbSupportedServices.length; i++) {\n            Integer id = dbSupportedServices[i].getServiceId();\n            String sn = (serviceNames.get(id)).toString();\n\n            DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.get(node.getNodeId(), ifaddr, dbSupportedServices[i].getServiceId());\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateServicesOnForcedRescan: old status for nodeId \" + node.getNodeId() + \", ifaddr \" + ifaddr + \", serviceId \" + dbSupportedServices[i].getServiceId() + \" = \" + ifSvcEntry.getStatus());\n            }\n\n            // now fill in the entry\n\n            boolean svcChangeToActive = false;\n            boolean svcChangeToNotPolled = false;\n            boolean svcChangeToForced = false;\n            if (!cFactory.isAddressUnmanaged(ifaddr)) {\n                boolean svcToBePolled = false;\n                if (ipToBePolled) {\n                    if (ipPkg == null) {\n                        ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n                    }\n                    if (ipPkg != null) {\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"updateServicesOnForcedRescan: Is service to be polled for package = \" + ipPkg.getName() + \", service = \" + sn);\n                        }\n                        svcToBePolled = pollerCfgFactory.isPolled(sn, ipPkg);\n                        if (!svcToBePolled) {\n                            if (log().isDebugEnabled()) {\n                                log().debug(\"updateServicesOnForcedRescan: Is service to be polled for ifaddr = \" + ifaddrString + \", service = \" + sn);\n                            }\n                            svcToBePolled = pollerCfgFactory.isPolled(ifaddrString, sn);\n                        }\n                        if (!svcToBePolled) {\n                            log().debug(\"updateServicesOnForcedRescan: Service not to be polled\");\n                        }\n                    } else {\n                        log().debug(\"updateServicesOnForcedRescan: No poller package found\");\n                    }\n                } else {\n                    log().debug(\"updateServicesOnForcedRescan: Service not polled because interface is not polled\");\n                        \n                }\n\n                if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_FORCED) {\n                    if (svcToBePolled) {\n                        // Do nothing\n                        log().debug(\"updateServicesOnForcedRescan: status = FORCED. No action taken.\");\n                    } else {\n                        // change the status to \"N\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                        svcChangeToNotPolled = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = FORCED. Changed to NOT_POLLED\");\n                    }\n                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_SUSPEND) {\n                    if (svcToBePolled) {\n                        // change the status to \"F\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_FORCED);\n                        svcChangeToForced = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = SUSPEND. Changed to FORCED\");\n                    } else {\n                        // change the status to \"N\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                        svcChangeToNotPolled = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = SUSPEND. Changed to NOT_POLLED\");\n                    }\n                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_RESUME) {\n                    if (svcToBePolled) {\n                        // change the status to \"A\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);\n                        svcChangeToActive = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = RESUME. Changed to ACTIVE\");\n                    } else {\n                        // change the status to \"N\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                        svcChangeToNotPolled = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = RESUME. Changed to NOT_POLLED\");\n                    }\n                } else if (svcToBePolled && ifSvcEntry.getStatus() != DbIfServiceEntry.STATUS_ACTIVE) {\n                    // set the status to \"A\"\n                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);\n                    svcChangeToActive = true;\n                    log().debug(\"updateServicesOnForcedRescan: New status = ACTIVE\");\n                } else if (!svcToBePolled && ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_ACTIVE) {\n                    // set the status to \"N\"\n                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                    svcChangeToNotPolled = true;\n                    log().debug(\"updateServicesOnForcedRescan: New status = NOT_POLLED\");\n                } else {\n                    log().debug(\"updateServicesOnForcedRescan: Status Unchanged\");\n                }\n            }\n\n            if (svcChangeToActive) {\n                ifSvcEntry.store();\n                createResumePollingServiceEvent(node, dbIpIfEntry, sn);\n            } else if (svcChangeToNotPolled || svcChangeToForced) {\n                ifSvcEntry.store();\n                createSuspendPollingServiceEvent(node, dbIpIfEntry, sn);\n            }\n        }\n    }","id":79499,"modified_method":"/**\n     * This method is responsible for updating the status of services for an\n     * interface during a forced rescan\n     * \n     * @param node\n     *            Node entry for the node being rescanned\n     * @param dbIpIfEntry\n     *            interface entry of the updating interface\n     * @param dbSupportedServices\n     *            services on the updating interface\n     * \n     * @throws SQLException\n     *             if there is a problem updating the snmpInterface table.\n     */\n    private void updateServicesOnForcedRescan(DbNodeEntry node, DbIpInterfaceEntry dbIpIfEntry, DbIfServiceEntry[] dbSupportedServices) throws SQLException {\n        /*\n         * Now process previously existing protocols to update polling status.\n         * Additional checks on forced rescan for existing services go here.\n         * Specifically, has service been forced managed/unmanaged or has\n         * polling status changed?\n         */\n\n        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();\n        CapsdConfig cFactory = CapsdConfigFactory.getInstance();\n        InetAddress ifaddr = dbIpIfEntry.getIfAddress();\n        org.opennms.netmgt.config.poller.Package ipPkg = null;\n\n        boolean ipToBePolled = false;\n        final String ifaddrString = str(ifaddr);\n        ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n        if (ipPkg != null) {\n            ipToBePolled = true;\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateServicesOnForcedRescan: Checking status of existing services on host \" + ifaddr);\n        }\n\n        // Get service names from database\n        java.sql.Connection ctest = null;\n        ResultSet rs = null;\n        Map<Integer, String> serviceNames = new HashMap<Integer, String>();\n        final DBUtils d = new DBUtils(RescanProcessor.class);\n        try {\n            ctest = DataSourceFactory.getInstance().getConnection();\n            d.watch(ctest);\n            PreparedStatement loadStmt = ctest.prepareStatement(SQL_RETRIEVE_SERVICE_IDS);\n            d.watch(loadStmt);\n\n            // go ahead and load the service table\n            rs = loadStmt.executeQuery();\n            d.watch(rs);\n            while (rs.next()) {\n                Integer id = new Integer(rs.getInt(1));\n                String name = rs.getString(2);\n                serviceNames.put(id, name);\n            }\n        } catch (Throwable t) {\n            log().error(\"Error reading services table\", t);\n        } finally {\n            d.cleanUp();\n        }\n\n        for (int i = 0; i < dbSupportedServices.length; i++) {\n            Integer id = dbSupportedServices[i].getServiceId();\n            String sn = (serviceNames.get(id)).toString();\n\n            DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.get(node.getNodeId(), ifaddr, dbSupportedServices[i].getServiceId());\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateServicesOnForcedRescan: old status for nodeId \" + node.getNodeId() + \", ifaddr \" + ifaddr + \", serviceId \" + dbSupportedServices[i].getServiceId() + \" = \" + ifSvcEntry.getStatus());\n            }\n\n            // now fill in the entry\n\n            boolean svcChangeToActive = false;\n            boolean svcChangeToNotPolled = false;\n            boolean svcChangeToForced = false;\n            if (!cFactory.isAddressUnmanaged(ifaddr)) {\n                boolean svcToBePolled = false;\n                if (ipToBePolled) {\n                    if (ipPkg == null) {\n                        ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n                    }\n                    if (ipPkg != null) {\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"updateServicesOnForcedRescan: Is service to be polled for package = \" + ipPkg.getName() + \", service = \" + sn);\n                        }\n                        svcToBePolled = pollerCfgFactory.isPolled(sn, ipPkg);\n                        if (!svcToBePolled) {\n                            if (log().isDebugEnabled()) {\n                                log().debug(\"updateServicesOnForcedRescan: Is service to be polled for ifaddr = \" + ifaddrString + \", service = \" + sn);\n                            }\n                            svcToBePolled = pollerCfgFactory.isPolled(ifaddrString, sn);\n                        }\n                        if (!svcToBePolled) {\n                            log().debug(\"updateServicesOnForcedRescan: Service not to be polled\");\n                        }\n                    } else {\n                        log().debug(\"updateServicesOnForcedRescan: No poller package found\");\n                    }\n                } else {\n                    log().debug(\"updateServicesOnForcedRescan: Service not polled because interface is not polled\");\n                        \n                }\n\n                if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_FORCED) {\n                    if (svcToBePolled) {\n                        // Do nothing\n                        log().debug(\"updateServicesOnForcedRescan: status = FORCED. No action taken.\");\n                    } else {\n                        // change the status to \"N\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                        svcChangeToNotPolled = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = FORCED. Changed to NOT_POLLED\");\n                    }\n                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_SUSPEND) {\n                    if (svcToBePolled) {\n                        // change the status to \"F\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_FORCED);\n                        svcChangeToForced = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = SUSPEND. Changed to FORCED\");\n                    } else {\n                        // change the status to \"N\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                        svcChangeToNotPolled = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = SUSPEND. Changed to NOT_POLLED\");\n                    }\n                } else if (ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_RESUME) {\n                    if (svcToBePolled) {\n                        // change the status to \"A\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);\n                        svcChangeToActive = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = RESUME. Changed to ACTIVE\");\n                    } else {\n                        // change the status to \"N\"\n                        ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                        svcChangeToNotPolled = true;\n                        log().debug(\"updateServicesOnForcedRescan: status = RESUME. Changed to NOT_POLLED\");\n                    }\n                } else if (svcToBePolled && ifSvcEntry.getStatus() != DbIfServiceEntry.STATUS_ACTIVE) {\n                    // set the status to \"A\"\n                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_ACTIVE);\n                    svcChangeToActive = true;\n                    log().debug(\"updateServicesOnForcedRescan: New status = ACTIVE\");\n                } else if (!svcToBePolled && ifSvcEntry.getStatus() == DbIfServiceEntry.STATUS_ACTIVE) {\n                    // set the status to \"N\"\n                    ifSvcEntry.updateStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                    svcChangeToNotPolled = true;\n                    log().debug(\"updateServicesOnForcedRescan: New status = NOT_POLLED\");\n                } else {\n                    log().debug(\"updateServicesOnForcedRescan: Status Unchanged\");\n                }\n            }\n\n            if (svcChangeToActive) {\n                ifSvcEntry.store();\n                m_eventList.add(createResumePollingServiceEvent(node, dbIpIfEntry, sn));\n            } else if (svcChangeToNotPolled || svcChangeToForced) {\n                ifSvcEntry.store();\n                m_eventList.add(createSuspendPollingServiceEvent(node, dbIpIfEntry, sn));\n            }\n        }\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a\n     * reinitializePrimarySnmpInterface event and adding it to the event list.\n     * \n     * @param nodeId\n     *            Nodeid of node being rescanned.\n     * @param primarySnmpIf\n     *            Primary SNMP interface address.\n     */\n    private void createReinitializePrimarySnmpInterfaceEvent(final int nodeId, final InetAddress primarySnmpIf) {\n        final String primaryAddress = str(primarySnmpIf);\n        \n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"reinitializePrimarySnmpInterface: nodeId: \" + nodeId + \" interface: \" + primaryAddress);\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI, nodeId, primaryAddress);\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createReinitializePrimarySnmpInterfaceEvent: successfully created reinitializePrimarySnmpInterface event for interface: \" + primaryAddress);\n        }\n    }","id":79500,"modified_method":"/**\n     * This method is responsible for generating a\n     * reinitializePrimarySnmpInterface event and adding it to the event list.\n     * \n     * @param nodeId\n     *            Nodeid of node being rescanned.\n     * @param primarySnmpIf\n     *            Primary SNMP interface address.\n     * @return \n     */\n    private static Event createReinitializePrimarySnmpInterfaceEvent(final int nodeId, final InetAddress primarySnmpIf) {\n        final String primaryAddress = str(primarySnmpIf);\n        \n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"reinitializePrimarySnmpInterface: nodeId: \" + nodeId + \" interface: \" + primaryAddress);\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI, nodeId, primaryAddress);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createReinitializePrimarySnmpInterfaceEvent: successfully created reinitializePrimarySnmpInterface event for interface: \" + primaryAddress);\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a resumePollingService event\n     * and adding it to the event list.\n     * \n     * @param nodeEntry\n     *            Entry of node for which a service is to be polled\n     * @param ifEntry\n     *            Entry of interface which a service is to be polled\n     * @param svcName\n     *            Service name\n     */\n    private void createResumePollingServiceEvent(final DbNodeEntry nodeEntry, final DbIpInterfaceEntry ifEntry, final String svcName) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n        \n        final EventBuilder bldr = serviceEventBuilder(EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI, ifEntry.getNodeId(), ifAddress, svcName);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"resumePollingServiceEvent: Created resumePollingService event for nodeid: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress + \" service: \" + svcName);\n        }\n    }","id":79501,"modified_method":"/**\n     * This method is responsible for generating a resumePollingService event\n     * and adding it to the event list.\n     * \n     * @param nodeEntry\n     *            Entry of node for which a service is to be polled\n     * @param ifEntry\n     *            Entry of interface which a service is to be polled\n     * @param svcName\n     *            Service name\n     * @return \n     */\n    private static Event createResumePollingServiceEvent(final DbNodeEntry nodeEntry, final DbIpInterfaceEntry ifEntry, final String svcName) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n        \n        final EventBuilder bldr = serviceEventBuilder(EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI, ifEntry.getNodeId(), ifAddress, svcName);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"resumePollingServiceEvent: Created resumePollingService event for nodeid: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress + \" service: \" + svcName);\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the ifservices table entry for a\n     * specific interface.\n     * \n     * @param dbc\n     *            Database Connection.\n     * @param node\n     *            Node entry for the node being rescanned.\n     * @param dbIpIfEntry\n     *            interface entry of the updating interface.\n     * @param isNewIpEntry\n     *            if the dbIpIfEntry is a new entry.\n     * @param protocols\n     *            Protocols supported by the interface.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the ifservices table.\n     */\n    private void updateServiceInfo(Connection dbc, DbNodeEntry node, DbIpInterfaceEntry dbIpIfEntry, boolean isNewIpEntry, List<SupportedProtocol> protocols) throws SQLException {\n        CapsdConfig cFactory = CapsdConfigFactory.getInstance();\n        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();\n        org.opennms.netmgt.config.poller.Package ipPkg = null;\n\n        InetAddress ifaddr = dbIpIfEntry.getIfAddress();\n\n        // Retrieve from the database the interface's service list\n        DbIfServiceEntry[] dbSupportedServices = dbIpIfEntry.getServices(dbc);\n\n        int ifIndex = dbIpIfEntry.getIfIndex();\n\n        if (log().isDebugEnabled()) {\n            if (ifIndex == -1) {\n                log().debug(\"updateServiceInfo: Retrieving interface's service list from database for host \" + dbIpIfEntry.getHostname());\n            } else {\n                log().debug(\"updateServiceInfo: Retrieving interface's service list from database for host \" + dbIpIfEntry.getHostname() + \" ifindex \" + ifIndex);\n            }\n        }\n        \n        /*\n         * add newly supported protocols\n         *\t\t\n         * NOTE!!!!!: (reference internal bug# 201)\n         * If the ip is 'managed', the service can still be 'not polled'\n         * based on the poller configuration - at this point the ip is already\n         * in the database, so package filter evaluation should go through OK\n         */\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateServiceInfo: Checking for new services on host \"\n                      + dbIpIfEntry.getHostname());\n        }\n\n        Iterator<SupportedProtocol> iproto = protocols.iterator();\n        while (iproto.hasNext()) {\n            SupportedProtocol p = iproto.next();\n            Number sid = m_capsdDbSyncer.getServiceId(p.getProtocolName());\n\n            /*\n             * Only adding newly supported services so check against the service\n             * list retrieved from the database\n             */\n            boolean found = false;\n            for (int i = 0; i < dbSupportedServices.length && !found; i++) {\n                if (dbSupportedServices[i].getServiceId() == sid.intValue()) {\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());\n\n                // now fill in the entry\n                final String ifaddrString = str(ifaddr);\n\t\t\t\tif (cFactory.isAddressUnmanaged(ifaddr)) {\n                    ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);\n                } else {\n                    ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n                    if (ipPkg == null) {\n                    \tifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                    } else if (isServicePolledLocally(ifaddrString, p.getProtocolName(), ipPkg)) {\n                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);\n                    } else if (isServicePolled(ifaddrString, p.getProtocolName(), ipPkg)) {\n                        ifSvcEntry.setStatus(DbIpInterfaceEntry.STATE_REMOTE);\n                    } else {\n                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                    }\n                }\n\n                /*\n                 * Set qualifier if available. Currently the qualifier field\n                 * is used to store the port at which the protocol was found.\n                 */\n                if (p.getQualifiers() != null && p.getQualifiers().get(\"port\") != null) {\n                    try {\n                        Integer port = (Integer) p.getQualifiers().get(\"port\");\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"updateServiceInfo: got a port qualifier: \" + port + \" for service: \" + p.getProtocolName());\n                        }\n                        ifSvcEntry.setQualifier(port.toString());\n                    } catch (ClassCastException ccE) {\n                        // Do nothing\n                    }\n                }\n\n                ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);\n                ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);\n\n                if (ifIndex != -1) {\n                    ifSvcEntry.setIfIndex(ifIndex);\n                }\n\n                ifSvcEntry.store();\n\n                if (log().isDebugEnabled()) {\n                    log().debug(\"updateIfServices: update service: \" + p.getProtocolName() + \" for interface:\" + ifaddrString + \" on node:\" + node.getNodeId());\n                }\n\n                // Generate nodeGainedService event\n                createNodeGainedServiceEvent(node, dbIpIfEntry, p.getProtocolName());\n\n                /*\n                 * If this interface already existed in the database and SNMP\n                 * service has been gained then create interfaceSupportsSNMP\n                 * event\n                 */\n                if (!isNewIpEntry && p.getProtocolName().equalsIgnoreCase(\"SNMP\")) {\n                    createInterfaceSupportsSNMPEvent(dbIpIfEntry);\n                }\n            }\n            // Update the supported services list\n            dbSupportedServices = dbIpIfEntry.getServices(dbc);\n        } // end while(more protocols)\n        \n        if (m_forceRescan) {\n            updateServicesOnForcedRescan(node, dbIpIfEntry, dbSupportedServices);\n        }\n    }","id":79502,"modified_method":"/**\n     * This method is responsible for updating the ifservices table entry for a\n     * specific interface.\n     * \n     * @param dbc\n     *            Database Connection.\n     * @param node\n     *            Node entry for the node being rescanned.\n     * @param dbIpIfEntry\n     *            interface entry of the updating interface.\n     * @param isNewIpEntry\n     *            if the dbIpIfEntry is a new entry.\n     * @param protocols\n     *            Protocols supported by the interface.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the ifservices table.\n     */\n    private void updateServiceInfo(Connection dbc, DbNodeEntry node, DbIpInterfaceEntry dbIpIfEntry, boolean isNewIpEntry, List<SupportedProtocol> protocols) throws SQLException {\n        CapsdConfig cFactory = CapsdConfigFactory.getInstance();\n        PollerConfig pollerCfgFactory = PollerConfigFactory.getInstance();\n        org.opennms.netmgt.config.poller.Package ipPkg = null;\n\n        InetAddress ifaddr = dbIpIfEntry.getIfAddress();\n\n        // Retrieve from the database the interface's service list\n        DbIfServiceEntry[] dbSupportedServices = dbIpIfEntry.getServices(dbc);\n\n        int ifIndex = dbIpIfEntry.getIfIndex();\n\n        if (log().isDebugEnabled()) {\n            if (ifIndex == -1) {\n                log().debug(\"updateServiceInfo: Retrieving interface's service list from database for host \" + dbIpIfEntry.getHostname());\n            } else {\n                log().debug(\"updateServiceInfo: Retrieving interface's service list from database for host \" + dbIpIfEntry.getHostname() + \" ifindex \" + ifIndex);\n            }\n        }\n        \n        /*\n         * add newly supported protocols\n         *\t\t\n         * NOTE!!!!!: (reference internal bug# 201)\n         * If the ip is 'managed', the service can still be 'not polled'\n         * based on the poller configuration - at this point the ip is already\n         * in the database, so package filter evaluation should go through OK\n         */\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateServiceInfo: Checking for new services on host \"\n                      + dbIpIfEntry.getHostname());\n        }\n\n        Iterator<SupportedProtocol> iproto = protocols.iterator();\n        while (iproto.hasNext()) {\n            SupportedProtocol p = iproto.next();\n            Number sid = m_capsdDbSyncer.getServiceId(p.getProtocolName());\n\n            /*\n             * Only adding newly supported services so check against the service\n             * list retrieved from the database\n             */\n            boolean found = false;\n            for (int i = 0; i < dbSupportedServices.length && !found; i++) {\n                if (dbSupportedServices[i].getServiceId() == sid.intValue()) {\n                    found = true;\n                }\n            }\n\n            if (!found) {\n                DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());\n\n                // now fill in the entry\n                final String ifaddrString = str(ifaddr);\n\t\t\t\tif (cFactory.isAddressUnmanaged(ifaddr)) {\n                    ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);\n                } else {\n                    ipPkg = ifaddrString == null? null : pollerCfgFactory.getFirstPackageMatch(ifaddrString);\n                    if (ipPkg == null) {\n                    \tifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                    } else if (isServicePolledLocally(ifaddrString, p.getProtocolName(), ipPkg)) {\n                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);\n                    } else if (isServicePolled(ifaddrString, p.getProtocolName(), ipPkg)) {\n                        ifSvcEntry.setStatus(DbIpInterfaceEntry.STATE_REMOTE);\n                    } else {\n                        ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);\n                    }\n                }\n\n                /*\n                 * Set qualifier if available. Currently the qualifier field\n                 * is used to store the port at which the protocol was found.\n                 */\n                if (p.getQualifiers() != null && p.getQualifiers().get(\"port\") != null) {\n                    try {\n                        Integer port = (Integer) p.getQualifiers().get(\"port\");\n                        if (log().isDebugEnabled()) {\n                            log().debug(\"updateServiceInfo: got a port qualifier: \" + port + \" for service: \" + p.getProtocolName());\n                        }\n                        ifSvcEntry.setQualifier(port.toString());\n                    } catch (ClassCastException ccE) {\n                        // Do nothing\n                    }\n                }\n\n                ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);\n                ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);\n\n                if (ifIndex != -1) {\n                    ifSvcEntry.setIfIndex(ifIndex);\n                }\n\n                ifSvcEntry.store();\n\n                if (log().isDebugEnabled()) {\n                    log().debug(\"updateIfServices: update service: \" + p.getProtocolName() + \" for interface:\" + ifaddrString + \" on node:\" + node.getNodeId());\n                }\n\n                // Generate nodeGainedService event\n                m_eventList.add(createNodeGainedServiceEvent(node, dbIpIfEntry, p.getProtocolName()));\n\n                /*\n                 * If this interface already existed in the database and SNMP\n                 * service has been gained then create interfaceSupportsSNMP\n                 * event\n                 */\n                if (!isNewIpEntry && p.getProtocolName().equalsIgnoreCase(\"SNMP\")) {\n                    m_eventList.add(createInterfaceSupportsSNMPEvent(dbIpIfEntry));\n                }\n            }\n            // Update the supported services list\n            dbSupportedServices = dbIpIfEntry.getServices(dbc);\n        } // end while(more protocols)\n        \n        if (m_forceRescan) {\n            updateServicesOnForcedRescan(node, dbIpIfEntry, dbSupportedServices);\n        }\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the ipInterface table entry for a\n     * specific interface.\n     * \n     * @param dbc\n     *            Database Connection\n     * @param now\n     *            Date/time to be associated with the update.\n     * @param node\n     *            Node entry for the node being rescanned\n     * @param target\n     *            Target interface (from IfCollector.getTarget())\n     * @param ifaddr\n     *            Interface being updated.\n     * @param protocols\n     *            Protocols supported by the interface.\n     * @param snmpc\n     *            SNMP collector or null if SNMP not supported.\n     * @param doesSnmp\n     *            Indicates that the interface supports SNMP\n     * \n     * @throws SQLException\n     *             if there is a problem updating the ipInterface table.\n     */\n    private void updateInterface(Connection dbc, Date now, DbNodeEntry node,\n            InetAddress target, InetAddress ifaddr, List<SupportedProtocol> protocols,\n            IfSnmpCollector snmpc, boolean doesSnmp) throws SQLException {\n        /*\n         * Reparenting\n         *\n         * This sub-interface was not previously associated with this node. If\n         * the sub-interface is already associated with another node we must do\n         * one of the following:\n         *\n         * 1. If the target interface (the one being rescanned) appears to be an\n         * interface alias all of the interfaces under the sub-interface's node\n         * will be reparented under the nodeid of the target interface.\n         *\n         * 2. If however the interface is not an alias, only the sub-interface\n         * will be reparented under the nodeid of the interface being rescanned.\n         *\n         * In the reparenting process, the database ipinterface, snmpinterface\n         * and ifservices table entries associated with the reparented interface\n         * will be \"updated\" to reflect the new nodeid. If the old node has\n         * no remaining interfaces following the reparenting it will be marked\n         * as deleted.\n         */\n\n        /*\n         * Special case: Need to skip interface reparenting for '0.0.0.0'\n         * interfaces as well as loopback interfaces ('127.*.*.*').\n         */\n        final String ifaddrString = str(ifaddr);\n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"updateInterface: updating interface \"\n                      + ifaddrString + \"(targetIf=\"\n                      + str(target) + \")\");\n            if (doesSnmp) {\n                log().debug(\"updateInterface: the SNMP collection passed in is \"\n                          + \"collected via\"\n                          + (snmpc ==  null ? \"No SnmpCollection passed in (snmpc == null)\" : str(snmpc.getCollectorTargetAddress())));\n            }\n        }\n\n        boolean reparentFlag = false;\n        boolean newIpIfEntry = false;\n        int ifIndex = -1;\n\n        DbIpInterfaceEntry dbIpIfEntry =\n            DbIpInterfaceEntry.get(dbc,node.getNodeId(), ifaddr);\n\n        if (doesSnmp && snmpc != null && snmpc.hasIpAddrTable()) {\n            // Attempt to load IP Interface entry from the database\n            ifIndex = snmpc.getIfIndex(ifaddr);\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateInterface: interface = \"\n                          + ifaddrString + \" ifIndex = \" + ifIndex\n                          + \". Checking for this address on other nodes.\");\n            }\n\n            /*\n             * the updating interface may have already existed in the\n             * ipinterface table with different\n             * nodeIds. If it exist in a different node, verify if all the\n             * interfaces on that node\n             * are contained in the snmpc of the updating interface. If they\n             * are, reparent all\n             * the interfaces on that node to the node of the updating\n             * interface, otherwise, just add\n             * the interface to the updating node.\n             */\n            // Verify that SNMP collection contains ipAddrTable entries\n            IpAddrTable ipAddrTable = null;\n            ipAddrTable = snmpc.getIpAddrTable();\n\n            if (ipAddrTable == null) {\n                log().error(\"updateInterface: null ipAddrTable in the SNMP \"\n                          + \"collection\");\n            } else {\n                if (ifaddrString.equals(\"0.0.0.0\") || ifaddr.isLoopbackAddress()) {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"updateInterface: Skipping address from \"\n                                  + \"snmpc ipAddrTable \"\n                                  + ifaddrString);\n                    }\n                } else {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"updateInterface: Checking address from \"\n                                  + \"snmpc ipAddrTable \"\n                                  + ifaddrString);\n                    }\n                    \n                    PreparedStatement stmt = null;\n                    final DBUtils d = new DBUtils(getClass());\n                    try {\n                        stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_OTHER_NODES);\n                        d.watch(stmt);\n                        stmt.setString(1, ifaddrString);\n                        stmt.setInt(2, node.getNodeId());\n                        \n                        ResultSet rs = stmt.executeQuery();\n                        d.watch(rs);\n                        while (rs.next()) {\n                            int existingNodeId = rs.getInt(1);\n                            if (log().isDebugEnabled()) {\n                                log().debug(\"updateInterface: ckecking for \"\n                                          + ifaddrString\n                                          + \" on existing nodeid  \"\n                                          + existingNodeId);\n                            }\n                            \n                            DbNodeEntry suspectNodeEntry = DbNodeEntry.get(dbc, existingNodeId);\n                            if (suspectNodeEntry == null) {\n                                // This can happen if a node has been deleted.\n                                continue;\n                            }\n                            \n                            /*\n                             * Retrieve list of interfaces associated with the\n                             * old node\n                             */\n                            DbIpInterfaceEntry[] tmpIfArray = suspectNodeEntry.getInterfaces(dbc);\n                            \n                            /*\n                             * Verify if the suspectNodeEntry is a duplicate\n                             * node\n                             */\n                            if (areDbInterfacesInSnmpCollection(tmpIfArray, snmpc)) {\n                                /*\n                                 * Reparent each interface under the targets'\n                                 * nodeid\n                                 */\n                                for (int i = 0; i < tmpIfArray.length; i++) {\n                                    InetAddress addr = tmpIfArray[i].getIfAddress();\n                                    int index = snmpc.getIfIndex(addr);\n                                    \n                                    // Skip non-IP or loopback interfaces\n                                    final String addrString = str(addr);\n\t\t\t\t\t\t\t\t\tif (addrString == null || addrString.equals(\"0.0.0.0\") || addr.isLoopbackAddress()) {\n                                        continue;\n                                    }\n                                    \n                                    if (log().isDebugEnabled()) {\n                                        log().debug(\"updateInterface: \"\n                                                  + \"reparenting interface \"\n                                                  + addrString\n                                                  + \" under node: \"\n                                                  + node.getNodeId()\n                                                  + \" from existing node: \"\n                                                  + existingNodeId);\n                                    }\n                                    \n                                    reparentInterface(dbc, addr, index, node.getNodeId(), existingNodeId);\n                                    \n                                    // Create interfaceReparented event\n                                    createInterfaceReparentedEvent(node, existingNodeId, addr);\n                                }\n                                \n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"updateInterface: interface \"\n                                              + ifaddrString\n                                              + \" is added to node: \"\n                                              + node.getNodeId()\n                                              + \" by reparenting from existing \"\n                                              + \"node: \" + existingNodeId);\n                                }\n                                dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr);\n                                reparentFlag = true;\n                                \n                                // delete duplicate node after reparenting.\n                                deleteDuplicateNode(dbc, suspectNodeEntry);\n                                createDuplicateNodeDeletedEvent(suspectNodeEntry);\n                            }\n                        }\n                    }\n                    \n                    catch (SQLException e) {\n                        log().error(\"SQLException while updating interface: \" + ifaddrString + \" on nodeid: \" + node.getNodeId());\n                        throw e;\n                    } finally {\n                        d.cleanUp();\n                    }\n                }\n            }\n        }\n\n        /*\n         * if no reparenting occured on the updating interface, add it to the\n         * updating node.\n         */\n        if (dbIpIfEntry == null) {\n            /*\n             * Interface not found with this nodeId so create new interface\n             * entry\n             */\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateInterface: interface \" + ifaddr + \" ifIndex \"\n                          + ifIndex + \" not in database under nodeid \"\n                          + node.getNodeId()\n                          + \", creating new interface object.\");\n            }\n\n            /*\n             * If doesSnmp is set to true, the dbIpIfEntry must not be stored\n             * to the database until the corresponding DbSnmpInterfaceEntry is\n             * stored.\n             */\n            if (ifIndex == -1 && !doesSnmp) {\n                dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(),\n                                                        ifaddr);\n            } else {\n                dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(),\n                                                        ifaddr, ifIndex);\n                /*\n                 * XXX uh, what????? - dj@opennms.org\n                 * This wasn't getting done for some reason, so do it explicitly\n                 */\n                dbIpIfEntry.setIfIndex(ifIndex);\n            }\n\n            if (isDuplicateInterface(dbc, ifaddr, node.getNodeId())) {\n                createDuplicateIpAddressEvent(dbIpIfEntry);\n            }\n            newIpIfEntry = true;\n        }\n        \n        DbIpInterfaceEntry currIpIfEntry =\n            getNewDbIpInterfaceEntry(node, snmpc, doesSnmp, ifaddr);\n\n        /*\n         * XXX Note that updateSnmpInfo only gets called if doesSnmp is\n         * true, but a new dbIpIfEntry with an ifIndex might have been\n         * create()ed above if ifIndex != -1 || doesSnmp.  This might be\n         * a problem if doesSnmp is false but ifIndex != -1, as the ipInterface\n         * entry will point an snmpInterface entry that might not exist.\n         */\n        if (doesSnmp && snmpc != null) {\n            // update SNMP info if available\n            updateSnmpInfo(dbc, node, snmpc, currIpIfEntry.getIfAddress(),\n                           currIpIfEntry.getIfIndex());\n        }\n\n        // update ipinterface for the updating interface\n        updateInterfaceInfo(dbc, now, node, dbIpIfEntry, currIpIfEntry,\n                            newIpIfEntry, reparentFlag);\n\n        // update IfServices for the updating interface\n        updateServiceInfo(dbc, node, dbIpIfEntry, newIpIfEntry, protocols);\n\n    }","id":79503,"modified_method":"/**\n     * This method is responsible for updating the ipInterface table entry for a\n     * specific interface.\n     * \n     * @param dbc\n     *            Database Connection\n     * @param now\n     *            Date/time to be associated with the update.\n     * @param node\n     *            Node entry for the node being rescanned\n     * @param target\n     *            Target interface (from IfCollector.getTarget())\n     * @param ifaddr\n     *            Interface being updated.\n     * @param protocols\n     *            Protocols supported by the interface.\n     * @param snmpc\n     *            SNMP collector or null if SNMP not supported.\n     * @param doesSnmp\n     *            Indicates that the interface supports SNMP\n     * \n     * @throws SQLException\n     *             if there is a problem updating the ipInterface table.\n     */\n    private void updateInterface(Connection dbc, Date now, DbNodeEntry node,\n            InetAddress target, InetAddress ifaddr, List<SupportedProtocol> protocols,\n            IfSnmpCollector snmpc, boolean doesSnmp) throws SQLException {\n        /*\n         * Reparenting\n         *\n         * This sub-interface was not previously associated with this node. If\n         * the sub-interface is already associated with another node we must do\n         * one of the following:\n         *\n         * 1. If the target interface (the one being rescanned) appears to be an\n         * interface alias all of the interfaces under the sub-interface's node\n         * will be reparented under the nodeid of the target interface.\n         *\n         * 2. If however the interface is not an alias, only the sub-interface\n         * will be reparented under the nodeid of the interface being rescanned.\n         *\n         * In the reparenting process, the database ipinterface, snmpinterface\n         * and ifservices table entries associated with the reparented interface\n         * will be \"updated\" to reflect the new nodeid. If the old node has\n         * no remaining interfaces following the reparenting it will be marked\n         * as deleted.\n         */\n\n        /*\n         * Special case: Need to skip interface reparenting for '0.0.0.0'\n         * interfaces as well as loopback interfaces ('127.*.*.*').\n         */\n        final String ifaddrString = str(ifaddr);\n\t\tif (log().isDebugEnabled()) {\n            log().debug(\"updateInterface: updating interface \"\n                      + ifaddrString + \"(targetIf=\"\n                      + str(target) + \")\");\n            if (doesSnmp) {\n                log().debug(\"updateInterface: the SNMP collection passed in is \"\n                          + \"collected via\"\n                          + (snmpc ==  null ? \"No SnmpCollection passed in (snmpc == null)\" : str(snmpc.getCollectorTargetAddress())));\n            }\n        }\n\n        boolean reparentFlag = false;\n        boolean newIpIfEntry = false;\n        int ifIndex = -1;\n\n        DbIpInterfaceEntry dbIpIfEntry =\n            DbIpInterfaceEntry.get(dbc,node.getNodeId(), ifaddr);\n\n        if (doesSnmp && snmpc != null && snmpc.hasIpAddrTable()) {\n            // Attempt to load IP Interface entry from the database\n            ifIndex = snmpc.getIfIndex(ifaddr);\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateInterface: interface = \"\n                          + ifaddrString + \" ifIndex = \" + ifIndex\n                          + \". Checking for this address on other nodes.\");\n            }\n\n            /*\n             * the updating interface may have already existed in the\n             * ipinterface table with different\n             * nodeIds. If it exist in a different node, verify if all the\n             * interfaces on that node\n             * are contained in the snmpc of the updating interface. If they\n             * are, reparent all\n             * the interfaces on that node to the node of the updating\n             * interface, otherwise, just add\n             * the interface to the updating node.\n             */\n            // Verify that SNMP collection contains ipAddrTable entries\n            IpAddrTable ipAddrTable = null;\n            ipAddrTable = snmpc.getIpAddrTable();\n\n            if (ipAddrTable == null) {\n                log().error(\"updateInterface: null ipAddrTable in the SNMP \"\n                          + \"collection\");\n            } else {\n                if (ifaddrString.equals(\"0.0.0.0\") || ifaddr.isLoopbackAddress()) {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"updateInterface: Skipping address from \"\n                                  + \"snmpc ipAddrTable \"\n                                  + ifaddrString);\n                    }\n                } else {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"updateInterface: Checking address from \"\n                                  + \"snmpc ipAddrTable \"\n                                  + ifaddrString);\n                    }\n                    \n                    PreparedStatement stmt = null;\n                    final DBUtils d = new DBUtils(RescanProcessor.class);\n                    try {\n                        stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_OTHER_NODES);\n                        d.watch(stmt);\n                        stmt.setString(1, ifaddrString);\n                        stmt.setInt(2, node.getNodeId());\n                        \n                        ResultSet rs = stmt.executeQuery();\n                        d.watch(rs);\n                        while (rs.next()) {\n                            int existingNodeId = rs.getInt(1);\n                            if (log().isDebugEnabled()) {\n                                log().debug(\"updateInterface: ckecking for \"\n                                          + ifaddrString\n                                          + \" on existing nodeid  \"\n                                          + existingNodeId);\n                            }\n                            \n                            DbNodeEntry suspectNodeEntry = DbNodeEntry.get(dbc, existingNodeId);\n                            if (suspectNodeEntry == null) {\n                                // This can happen if a node has been deleted.\n                                continue;\n                            }\n                            \n                            /*\n                             * Retrieve list of interfaces associated with the\n                             * old node\n                             */\n                            DbIpInterfaceEntry[] tmpIfArray = suspectNodeEntry.getInterfaces(dbc);\n                            \n                            /*\n                             * Verify if the suspectNodeEntry is a duplicate\n                             * node\n                             */\n                            if (areDbInterfacesInSnmpCollection(tmpIfArray, snmpc)) {\n                                /*\n                                 * Reparent each interface under the targets'\n                                 * nodeid\n                                 */\n                                for (int i = 0; i < tmpIfArray.length; i++) {\n                                    InetAddress addr = tmpIfArray[i].getIfAddress();\n                                    int index = snmpc.getIfIndex(addr);\n                                    \n                                    // Skip non-IP or loopback interfaces\n                                    final String addrString = str(addr);\n\t\t\t\t\t\t\t\t\tif (addrString == null || addrString.equals(\"0.0.0.0\") || addr.isLoopbackAddress()) {\n                                        continue;\n                                    }\n                                    \n                                    if (log().isDebugEnabled()) {\n                                        log().debug(\"updateInterface: \"\n                                                  + \"reparenting interface \"\n                                                  + addrString\n                                                  + \" under node: \"\n                                                  + node.getNodeId()\n                                                  + \" from existing node: \"\n                                                  + existingNodeId);\n                                    }\n                                    \n                                    reparentInterface(dbc, addr, index, node.getNodeId(), existingNodeId);\n                                    \n                                    // Create interfaceReparented event\n                                    createInterfaceReparentedEvent(node, existingNodeId, addr);\n                                }\n                                \n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"updateInterface: interface \"\n                                              + ifaddrString\n                                              + \" is added to node: \"\n                                              + node.getNodeId()\n                                              + \" by reparenting from existing \"\n                                              + \"node: \" + existingNodeId);\n                                }\n                                dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr);\n                                reparentFlag = true;\n                                \n                                // delete duplicate node after reparenting.\n                                deleteDuplicateNode(dbc, suspectNodeEntry);\n                                createDuplicateNodeDeletedEvent(suspectNodeEntry);\n                            }\n                        }\n                    }\n                    \n                    catch (SQLException e) {\n                        log().error(\"SQLException while updating interface: \" + ifaddrString + \" on nodeid: \" + node.getNodeId());\n                        throw e;\n                    } finally {\n                        d.cleanUp();\n                    }\n                }\n            }\n        }\n\n        /*\n         * if no reparenting occurred on the updating interface, add it to the\n         * updating node.\n         */\n        if (dbIpIfEntry == null) {\n            /*\n             * Interface not found with this nodeId so create new interface\n             * entry\n             */\n            if (log().isDebugEnabled()) {\n                log().debug(\"updateInterface: interface \" + ifaddr + \" ifIndex \"\n                          + ifIndex + \" not in database under nodeid \"\n                          + node.getNodeId()\n                          + \", creating new interface object.\");\n            }\n\n            /*\n             * If doesSnmp is set to true, the dbIpIfEntry must not be stored\n             * to the database until the corresponding DbSnmpInterfaceEntry is\n             * stored.\n             */\n            if (ifIndex == -1 && !doesSnmp) {\n                dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(),\n                                                        ifaddr);\n            } else {\n                dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(),\n                                                        ifaddr, ifIndex);\n                /*\n                 * XXX uh, what????? - dj@opennms.org\n                 * This wasn't getting done for some reason, so do it explicitly\n                 */\n                dbIpIfEntry.setIfIndex(ifIndex);\n            }\n\n            if (isDuplicateInterface(dbc, ifaddr, node.getNodeId())) {\n                m_eventList.add(createDuplicateIpAddressEvent(dbIpIfEntry));\n            }\n            newIpIfEntry = true;\n        }\n        \n        DbIpInterfaceEntry currIpIfEntry =\n            getNewDbIpInterfaceEntry(node, snmpc, doesSnmp, ifaddr);\n\n        /*\n         * XXX Note that updateSnmpInfo only gets called if doesSnmp is\n         * true, but a new dbIpIfEntry with an ifIndex might have been\n         * create()ed above if ifIndex != -1 || doesSnmp.  This might be\n         * a problem if doesSnmp is false but ifIndex != -1, as the ipInterface\n         * entry will point an snmpInterface entry that might not exist.\n         */\n        if (doesSnmp && snmpc != null) {\n            // update SNMP info if available\n            updateSnmpInfo(dbc, node, snmpc, currIpIfEntry.getIfAddress(),\n                           currIpIfEntry.getIfIndex());\n        }\n\n        // update ipinterface for the updating interface\n        updateInterfaceInfo(dbc, now, node, dbIpIfEntry, currIpIfEntry,\n                            newIpIfEntry, reparentFlag);\n\n        // update IfServices for the updating interface\n        updateServiceInfo(dbc, node, dbIpIfEntry, newIpIfEntry, protocols);\n\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a nodeGainedService event and\n     * adding it to the event list.\n     * \n     * @param nodeEntry\n     *            Entry of node which has gained a service\n     * @param ifEntry\n     *            Entry of interface which has gained a service\n     * @param svcName\n     *            Service name\n     */\n    private void createNodeGainedServiceEvent(final DbNodeEntry nodeEntry, final DbIpInterfaceEntry ifEntry, final String svcName) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedServiceEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress + \" service: \" + svcName);\n        }\n\n        EventBuilder bldr = serviceEventBuilder(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI, ifEntry.getNodeId(), ifAddress, svcName);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedServiceEvent: successfully created nodeGainedService event for nodeid: \" + ifEntry.getNodeId());\n        }\n    }","id":79504,"modified_method":"/**\n     * This method is responsible for generating a nodeGainedService event and\n     * adding it to the event list.\n     * \n     * @param nodeEntry\n     *            Entry of node which has gained a service\n     * @param ifEntry\n     *            Entry of interface which has gained a service\n     * @param svcName\n     *            Service name\n     * @return \n     */\n    private static Event createNodeGainedServiceEvent(final DbNodeEntry nodeEntry, final DbIpInterfaceEntry ifEntry, final String svcName) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedServiceEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress + \" service: \" + svcName);\n        }\n\n        EventBuilder bldr = serviceEventBuilder(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI, ifEntry.getNodeId(), ifAddress, svcName);\n\n        // Add ip host name\n        bldr.addParam(EventConstants.PARM_IP_HOSTNAME, ifEntry.getHostname() == null ? \"\" : ifEntry.getHostname());\n\n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeGainedServiceEvent: successfully created nodeGainedService event for nodeid: \" + ifEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private InetAddress updatePrimarySnmpInterface(Connection dbc, DbNodeEntry dbNodeEntry, Map<String, IfCollector> collectorMap, InetAddress oldPriIf) throws SQLException {\n        /*\n         * Now that all interfaces have been added to the\n         * database we can update the 'primarySnmpInterface'\n         * field of the ipInterface table. Necessary because\n         * the IP address must already be in the database\n         * to evaluate against a filter rule.\n         *\n         * First create a list of eligible loopback interfaces\n         * and a list of all eligible interfaces. Test in the\n         * following order:\n         * \n         * 1) strict = true (interface must be part of a Collectd\n         * package) and loopback.\n         * \n         * 2) strict = true and all eligible interfaces.\n         * strict = false and loopback.\n         * \n         * 4) strict = false and all eligible interfaces.\n         */\n        boolean strict = true;\n        CollectdConfigFactory.getInstance().rebuildPackageIpListMap();\n        IfSnmpCollector snmpc = findSnmpCollector(collectorMap);\n        List<InetAddress> snmpLBAddresses = buildLBSnmpAddressList(collectorMap, snmpc);\n        List<InetAddress> snmpAddresses = buildSnmpAddressList(collectorMap, snmpc);\n        \n        // first set the value of issnmpprimary for secondaries\n        Iterator<InetAddress> iter = snmpAddresses.iterator();\n        while(iter.hasNext()) {\n            InetAddress addr = iter.next();\n            final String addrString = str(addr);\n\t\t\tif (CollectdConfigFactory.getInstance().isServiceCollectionEnabled(addrString, \"SNMP\")) {\n                final DBUtils d = new DBUtils(getClass());\n                try {\n                    PreparedStatement stmt = dbc.prepareStatement(\"UPDATE ipInterface SET isSnmpPrimary='S' WHERE nodeId=? AND ipAddr=? AND isManaged!='D'\");\n                    d.watch(stmt);\n                    stmt.setInt(1, dbNodeEntry.getNodeId());\n                    stmt.setString(2, addrString);\n                    stmt.executeUpdate();\n                    log().debug(\"updatePrimarySnmpInterface: updated \" + addrString + \" to secondary.\");\n                } finally {\n                    d.cleanUp();\n                }\n            }\n        }\n        \n        InetAddress newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses, strict);\n        String psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + \" loopback addresses\";\n\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses, strict);\n            psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + \" addresses\";\n        }\n\n        strict = false;\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses, strict);\n            psiType = \"DB loopback addresses\";\n        }\n\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses, strict);\n            psiType = \"DB addresses\";\n        }\n\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = snmpc.getCollectorTargetAddress();\n            psiType = \"SNMP collector target address\";\n        }\n\n        if (newSnmpPrimaryIf != null) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"updatePrimarySnmpInterface: primary SNMP interface is: \" + newSnmpPrimaryIf + \", selected from \" + psiType);\n            }\n            SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newSnmpPrimaryIf, oldPriIf);\n        } else {\n            log().debug(\"SuspectEventProcessor: Unable to determine a primary SNMP interface\");\n        }   \n        \n        /*\n         * Now that we've identified the new primary SNMP\n         * interface we can determine if it is necessary to\n         * generate certain SNMP data collection related\n         * events\n         */\n        generateSnmpDataCollectionEvents(dbNodeEntry, oldPriIf, newSnmpPrimaryIf);\n        return newSnmpPrimaryIf;\n    }","id":79505,"modified_method":"private InetAddress updatePrimarySnmpInterface(Connection dbc, DbNodeEntry dbNodeEntry, Map<String, IfCollector> collectorMap, InetAddress oldPriIf) throws SQLException {\n        /*\n         * Now that all interfaces have been added to the\n         * database we can update the 'primarySnmpInterface'\n         * field of the ipInterface table. Necessary because\n         * the IP address must already be in the database\n         * to evaluate against a filter rule.\n         *\n         * First create a list of eligible loopback interfaces\n         * and a list of all eligible interfaces. Test in the\n         * following order:\n         * \n         * 1) strict = true (interface must be part of a Collectd\n         * package) and loopback.\n         * \n         * 2) strict = true and all eligible interfaces.\n         * strict = false and loopback.\n         * \n         * 4) strict = false and all eligible interfaces.\n         */\n        boolean strict = true;\n        CollectdConfigFactory.getInstance().rebuildPackageIpListMap();\n        IfSnmpCollector snmpc = findSnmpCollector(collectorMap);\n        List<InetAddress> snmpLBAddresses = buildLBSnmpAddressList(collectorMap, snmpc);\n        List<InetAddress> snmpAddresses = buildSnmpAddressList(collectorMap, snmpc);\n        \n        // first set the value of issnmpprimary for secondaries\n        Iterator<InetAddress> iter = snmpAddresses.iterator();\n        while(iter.hasNext()) {\n            InetAddress addr = iter.next();\n            final String addrString = str(addr);\n\t\t\tif (CollectdConfigFactory.getInstance().isServiceCollectionEnabled(addrString, \"SNMP\")) {\n                final DBUtils d = new DBUtils(RescanProcessor.class);\n                try {\n                    PreparedStatement stmt = dbc.prepareStatement(\"UPDATE ipInterface SET isSnmpPrimary='S' WHERE nodeId=? AND ipAddr=? AND isManaged!='D'\");\n                    d.watch(stmt);\n                    stmt.setInt(1, dbNodeEntry.getNodeId());\n                    stmt.setString(2, addrString);\n                    stmt.executeUpdate();\n                    log().debug(\"updatePrimarySnmpInterface: updated \" + addrString + \" to secondary.\");\n                } finally {\n                    d.cleanUp();\n                }\n            }\n        }\n        \n        InetAddress newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses, strict);\n        String psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + \" loopback addresses\";\n\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses, strict);\n            psiType = ConfigFileConstants.getFileName(ConfigFileConstants.COLLECTD_CONFIG_FILE_NAME) + \" addresses\";\n        }\n\n        strict = false;\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses, strict);\n            psiType = \"DB loopback addresses\";\n        }\n\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = CapsdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses, strict);\n            psiType = \"DB addresses\";\n        }\n\n        if (newSnmpPrimaryIf == null) {\n            newSnmpPrimaryIf = snmpc.getCollectorTargetAddress();\n            psiType = \"SNMP collector target address\";\n        }\n\n        if (newSnmpPrimaryIf != null) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"updatePrimarySnmpInterface: primary SNMP interface is: \" + newSnmpPrimaryIf + \", selected from \" + psiType);\n            }\n            SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newSnmpPrimaryIf, oldPriIf);\n        } else {\n            log().debug(\"SuspectEventProcessor: Unable to determine a primary SNMP interface\");\n        }   \n        \n        /*\n         * Now that we've identified the new primary SNMP\n         * interface we can determine if it is necessary to\n         * generate certain SNMP data collection related\n         * events\n         */\n        generateSnmpDataCollectionEvents(dbNodeEntry, oldPriIf, newSnmpPrimaryIf);\n        return newSnmpPrimaryIf;\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a rescanCompleted event and\n     * adding it to the event list.\n     *\n     * @param nodeEntry Entry of node which was rescanned\n     */\n    private void createRescanCompletedEvent(DbNodeEntry nodeEntry) {\n        \n        EventBuilder bldr = nodeEventBuilder(EventConstants.RESCAN_COMPLETED_EVENT_UEI, nodeEntry.getNodeId());\n\n        // Add node label\n        bldr.addParam(EventConstants.PARM_NODE_LABEL, nodeEntry.getLabel() == null ? \"\" : nodeEntry.getLabel());\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"rescanCompletedEvent: Created rescanCompletedEvent for nodeid: \" + nodeEntry.getNodeId());\n        }\n    }","id":79506,"modified_method":"/**\n     * This method is responsible for generating a rescanCompleted event and\n     * adding it to the event list.\n     *\n     * @param nodeEntry Entry of node which was rescanned\n     * @return \n     */\n    private static Event createRescanCompletedEvent(DbNodeEntry nodeEntry) {\n        \n        EventBuilder bldr = nodeEventBuilder(EventConstants.RESCAN_COMPLETED_EVENT_UEI, nodeEntry.getNodeId());\n\n        // Add node label\n        bldr.addParam(EventConstants.PARM_NODE_LABEL, nodeEntry.getLabel() == null ? \"\" : nodeEntry.getLabel());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"rescanCompletedEvent: Created rescanCompletedEvent for nodeid: \" + nodeEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a snmpConflictsWithDb event and\n     * adding it to the event list.\n     *\n     * @param nodeEntry Entry of node for which a conflict exits\n     */\n    private void createSnmpConflictsWithDbEvent(DbNodeEntry nodeEntry) {\n        \n        EventBuilder bldr = nodeEventBuilder(EventConstants.SNMP_CONFLICTS_WITH_DB_EVENT_UEI, nodeEntry.getNodeId());\n\n        // Add node label\n        bldr.addParam(EventConstants.PARM_NODE_LABEL, nodeEntry.getLabel() == null ? \"\" : nodeEntry.getLabel());\n\n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"snmpConflictsWithDbEvent: Created snmpConflictsWithDbEvent for nodeid: \" + nodeEntry.getNodeId());\n        }\n    }","id":79507,"modified_method":"/**\n     * This method is responsible for generating a snmpConflictsWithDb event and\n     * adding it to the event list.\n     *\n     * @param nodeEntry Entry of node for which a conflict exits\n     * @return \n     */\n    private static Event createSnmpConflictsWithDbEvent(DbNodeEntry nodeEntry) {\n        \n        EventBuilder bldr = nodeEventBuilder(EventConstants.SNMP_CONFLICTS_WITH_DB_EVENT_UEI, nodeEntry.getNodeId());\n\n        // Add node label\n        bldr.addParam(EventConstants.PARM_NODE_LABEL, nodeEntry.getLabel() == null ? \"\" : nodeEntry.getLabel());\n\n        // Add nodeSysName\n        if (nodeEntry.getSystemName() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSNAME, nodeEntry.getSystemName());\n        }\n\n        // Add nodeSysDescription\n        if (nodeEntry.getSystemDescription() != null) {\n            bldr.addParam(EventConstants.PARM_NODE_SYSDESCRIPTION, nodeEntry.getSystemDescription());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"snmpConflictsWithDbEvent: Created snmpConflictsWithDbEvent for nodeid: \" + nodeEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Utility method used to determine if the specified node has been marked as\n     * deleted in the node table.\n     * \n     * @param dbc\n     *            Database connection.\n     * @param nodeId\n     *            Node identifier to check\n     * \n     * @return TRUE if node has been marked as deleted, FALSE otherwise.\n     */\n    private boolean isNodeDeleted(Connection dbc, int nodeId) throws SQLException {\n        boolean nodeDeleted = false;\n\n        /*\n         * Prepare & execute the SQL statement to retrieve the 'nodetype' field\n         * from the node table for the specified nodeid.\n         */\n        PreparedStatement stmt = null;\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_NODE_TYPE);\n            d.watch(stmt);\n            stmt.setInt(1, nodeId);\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n            rs.next();\n            String nodeTypeStr = rs.getString(1);\n            if (!rs.wasNull()) {\n                char nodeType = nodeTypeStr.charAt(0);\n                if (nodeType == DbNodeEntry.NODE_TYPE_DELETED) {\n                    nodeDeleted = true;\n                }\n            }\n        } finally {\n            d.cleanUp();\n        }\n\n        return nodeDeleted;\n    }","id":79508,"modified_method":"/**\n     * Utility method used to determine if the specified node has been marked as\n     * deleted in the node table.\n     * \n     * @param dbc\n     *            Database connection.\n     * @param nodeId\n     *            Node identifier to check\n     * \n     * @return TRUE if node has been marked as deleted, FALSE otherwise.\n     */\n    private static boolean isNodeDeleted(Connection dbc, int nodeId) throws SQLException {\n        boolean nodeDeleted = false;\n\n        /*\n         * Prepare & execute the SQL statement to retrieve the 'nodetype' field\n         * from the node table for the specified nodeid.\n         */\n        PreparedStatement stmt = null;\n        final DBUtils d = new DBUtils(RescanProcessor.class);\n        try {\n            stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_NODE_TYPE);\n            d.watch(stmt);\n            stmt.setInt(1, nodeId);\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n            rs.next();\n            String nodeTypeStr = rs.getString(1);\n            if (!rs.wasNull()) {\n                char nodeType = nodeTypeStr.charAt(0);\n                if (nodeType == DbNodeEntry.NODE_TYPE_DELETED) {\n                    nodeDeleted = true;\n                }\n            }\n        } finally {\n            d.cleanUp();\n        }\n\n        return nodeDeleted;\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a nodeLabelChanged event and\n     * adding it to the event list.\n     * \n     * @param updatedEntry\n     *            Updated node entry object\n     * @param originalEntry\n     *            Original node entry object\n     */\n    private void createNodeLabelChangedEvent(DbNodeEntry updatedEntry, DbNodeEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeLabelChangedEvent: nodeId: \" + updatedEntry.getNodeId() + \" oldLabel: '\" + originalEntry.getLabel() + \"' oldSource: '\" + originalEntry.getLabelSource() + \"' newLabel: '\" + updatedEntry.getLabel() + \"' newLabelSource: '\" + updatedEntry.getLabelSource() + \"'\");\n        }\n\n        EventBuilder bldr = nodeEventBuilder(EventConstants.NODE_LABEL_CHANGED_EVENT_UEI, updatedEntry.getNodeId());\n\n        if (originalEntry.getLabel() != null) {\n            bldr.addParam(EventConstants.PARM_OLD_NODE_LABEL, originalEntry.getLabel());\n            bldr.addParam(EventConstants.PARM_OLD_NODE_LABEL_SOURCE, originalEntry.getLabelSource());\n        }\n\n        if (updatedEntry.getLabel() != null) {\n            bldr.addParam(EventConstants.PARM_NEW_NODE_LABEL, updatedEntry.getLabel());\n            bldr.addParam(EventConstants.PARM_NEW_NODE_LABEL_SOURCE, updatedEntry.getLabelSource());\n        }\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeLabelChangedEvent: successfully created nodeLabelChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n    }","id":79509,"modified_method":"/**\n     * This method is responsible for generating a nodeLabelChanged event and\n     * adding it to the event list.\n     * \n     * @param updatedEntry\n     *            Updated node entry object\n     * @param originalEntry\n     *            Original node entry object\n     */\n    private static Event createNodeLabelChangedEvent(DbNodeEntry updatedEntry, DbNodeEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeLabelChangedEvent: nodeId: \" + updatedEntry.getNodeId() + \" oldLabel: '\" + originalEntry.getLabel() + \"' oldSource: '\" + originalEntry.getLabelSource() + \"' newLabel: '\" + updatedEntry.getLabel() + \"' newLabelSource: '\" + updatedEntry.getLabelSource() + \"'\");\n        }\n\n        EventBuilder bldr = nodeEventBuilder(EventConstants.NODE_LABEL_CHANGED_EVENT_UEI, updatedEntry.getNodeId());\n\n        if (originalEntry.getLabel() != null) {\n            bldr.addParam(EventConstants.PARM_OLD_NODE_LABEL, originalEntry.getLabel());\n            bldr.addParam(EventConstants.PARM_OLD_NODE_LABEL_SOURCE, originalEntry.getLabelSource());\n        }\n\n        if (updatedEntry.getLabel() != null) {\n            bldr.addParam(EventConstants.PARM_NEW_NODE_LABEL, updatedEntry.getLabel());\n            bldr.addParam(EventConstants.PARM_NEW_NODE_LABEL_SOURCE, updatedEntry.getLabelSource());\n        }\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createNodeLabelChangedEvent: successfully created nodeLabelChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a interfaceIndexChanged event\n     * and adding it to the event list.\n     * \n     * @param updatedEntry\n     *            updated IP interface database entry\n     * @param originalEntry\n     *            original IP interface database entry\n     */\n    private void createInterfaceIndexChangedEvent(final DbIpInterfaceEntry updatedEntry, final DbIpInterfaceEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceIndexChangedEvent: nodeId: \" + updatedEntry.getNodeId() + \" oldIfIndex: \" + originalEntry.getIfIndex() + \" newIfIndex: \" + updatedEntry.getIfIndex());\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_INDEX_CHANGED_EVENT_UEI, updatedEntry.getNodeId(), str(updatedEntry.getIfAddress()));\n\n        bldr.addParam(EventConstants.PARM_OLD_IFINDEX, originalEntry.getIfIndex());\n        bldr.addParam(EventConstants.PARM_NEW_IFINDEX, updatedEntry.getIfIndex());\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceIndexChangedEvent: successfully created interfaceIndexChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n    }","id":79510,"modified_method":"/**\n     * This method is responsible for generating a interfaceIndexChanged event\n     * and adding it to the event list.\n     * \n     * @param updatedEntry\n     *            updated IP interface database entry\n     * @param originalEntry\n     *            original IP interface database entry\n     * @return \n     */\n    private static Event createInterfaceIndexChangedEvent(final DbIpInterfaceEntry updatedEntry, final DbIpInterfaceEntry originalEntry) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceIndexChangedEvent: nodeId: \" + updatedEntry.getNodeId() + \" oldIfIndex: \" + originalEntry.getIfIndex() + \" newIfIndex: \" + updatedEntry.getIfIndex());\n        }\n\n        EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_INDEX_CHANGED_EVENT_UEI, updatedEntry.getNodeId(), str(updatedEntry.getIfAddress()));\n\n        bldr.addParam(EventConstants.PARM_OLD_IFINDEX, originalEntry.getIfIndex());\n        bldr.addParam(EventConstants.PARM_NEW_IFINDEX, updatedEntry.getIfIndex());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceIndexChangedEvent: successfully created interfaceIndexChanged event for nodeid: \" + updatedEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method verify if an ipaddress is existing in other node except in\n     * the updating node.\n     * \n     * @param dbc\n     *            Database Connection\n     * @param ifaddr\n     *            Ip address being verified.\n     * @param nodeId\n     *            Node Id of the node being rescanned\n     * \n     */\n    private boolean isDuplicateInterface(Connection dbc, InetAddress ifaddr, int nodeId) throws SQLException {\n\n        boolean duplicate = false;\n\n        PreparedStatement stmt = null;\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_OTHER_NODES);\n            d.watch(stmt);\n            stmt.setString(1, str(ifaddr));\n            stmt.setInt(2, nodeId);\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n            while (rs.next()) {\n                duplicate = true;\n            }\n            return duplicate;\n        } catch (SQLException sqlE) {\n            log().error(\"isDuplicateInterface: SQLException while updating interface: \" + str(ifaddr) + \" on nodeid: \" + nodeId);\n            throw sqlE;\n        } finally {\n            d.cleanUp();\n        }\n\n    }","id":79511,"modified_method":"/**\n     * This method verify if an ipaddress is existing in other node except in\n     * the updating node.\n     * \n     * @param dbc\n     *            Database Connection\n     * @param ifaddr\n     *            Ip address being verified.\n     * @param nodeId\n     *            Node Id of the node being rescanned\n     * \n     */\n    private static boolean isDuplicateInterface(Connection dbc, InetAddress ifaddr, int nodeId) throws SQLException {\n\n        boolean duplicate = false;\n\n        PreparedStatement stmt = null;\n        final DBUtils d = new DBUtils(RescanProcessor.class);\n        try {\n            stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_OTHER_NODES);\n            d.watch(stmt);\n            stmt.setString(1, str(ifaddr));\n            stmt.setInt(2, nodeId);\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n            while (rs.next()) {\n                duplicate = true;\n            }\n            return duplicate;\n        } catch (SQLException sqlE) {\n            log().error(\"isDuplicateInterface: SQLException while updating interface: \" + str(ifaddr) + \" on nodeid: \" + nodeId);\n            throw sqlE;\n        } finally {\n            d.cleanUp();\n        }\n\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for generating a interfaceSupportsSNMPEvent\n     * event and adding it to the event list.\n     * \n     * @param ifEntry\n     *            Entry of interface which has gained a service\n     */\n    private void createInterfaceSupportsSNMPEvent(final DbIpInterfaceEntry ifEntry) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceSupportsSNMPEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress);\n        }\n        \n        final EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_SUPPORTS_SNMP_EVENT_UEI, ifEntry.getNodeId(), ifAddress);\n\n        // Add event to the list of events to be sent out.\n        m_eventList.add(bldr.getEvent());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"interfaceSupportsSNMPEvent: successfully created interfaceSupportsSNMPEvent event for nodeid: \" + ifEntry.getNodeId());\n        }\n    }","id":79512,"modified_method":"/**\n     * This method is responsible for generating a interfaceSupportsSNMPEvent\n     * event and adding it to the event list.\n     * \n     * @param ifEntry\n     *            Entry of interface which has gained a service\n     * @return \n     */\n    private static Event createInterfaceSupportsSNMPEvent(final DbIpInterfaceEntry ifEntry) {\n        final String ifAddress = str(ifEntry.getIfAddress());\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"createInterfaceSupportsSNMPEvent: nodeId: \" + ifEntry.getNodeId() + \" interface: \" + ifAddress);\n        }\n        \n        final EventBuilder bldr = interfaceEventBuilder(EventConstants.INTERFACE_SUPPORTS_SNMP_EVENT_UEI, ifEntry.getNodeId(), ifAddress);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"interfaceSupportsSNMPEvent: successfully created interfaceSupportsSNMPEvent event for nodeid: \" + ifEntry.getNodeId());\n        }\n\n        // Add event to the list of events to be sent out.\n        return bldr.getEvent();\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Test for bug #2448.\n     */\n    public void testBadSnmpIfSpeed() {\n        int nodeId = 1;\n        int ifIndex = 10;\n        \n        RescanProcessor.setQueuedRescansTracker(new HashSet<Integer>());\n        RescanProcessor processor = new RescanProcessor(nodeId, false, null, null);\n        \n        IfTableEntry ifTableEntry = new IfTableEntry();\n        ifTableEntry.storeResult(new SnmpResult(SnmpObjId.get(\".1.3.6.1.2.1.2.2.1.5\"), new SnmpInstId(\"0\"), new MockSnmpValue.StringSnmpValue(\"\")));\n        DbSnmpInterfaceEntry dbSnmpInterfaceEntry = DbSnmpInterfaceEntry.create(nodeId, ifIndex);\n        processor.updateSpeed(ifIndex, ifTableEntry, null, dbSnmpInterfaceEntry);\n        \n        assertEquals(\"DbSnmpInterfaceEntry ifSpeed value\", 0, dbSnmpInterfaceEntry.getSpeed());\n    }","id":79513,"modified_method":"/**\n     * Test for bug #2448.\n     */\n    public void testBadSnmpIfSpeed() {\n        int nodeId = 1;\n        int ifIndex = 10;\n        \n        RescanProcessor.setQueuedRescansTracker(new HashSet<Integer>());\n        \n        IfTableEntry ifTableEntry = new IfTableEntry();\n        ifTableEntry.storeResult(new SnmpResult(SnmpObjId.get(\".1.3.6.1.2.1.2.2.1.5\"), new SnmpInstId(\"0\"), new MockSnmpValue.StringSnmpValue(\"\")));\n        DbSnmpInterfaceEntry dbSnmpInterfaceEntry = DbSnmpInterfaceEntry.create(nodeId, ifIndex);\n        RescanProcessor.updateSpeed(ifIndex, ifTableEntry, null, dbSnmpInterfaceEntry);\n        \n        assertEquals(\"DbSnmpInterfaceEntry ifSpeed value\", 0, dbSnmpInterfaceEntry.getSpeed());\n    }","commit_id":"9ce53a1dd99093fd38b104b598f6147cb30e2d5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Iterable<SNode> getExternalReferences(final SNode node) {\n    return ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", false, new String[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return !(ListSequence.fromList(SNodeOperations.getAncestors(SLinkOperations.getTarget(it, \"variableDeclaration\", false), null, false)).contains(node));\n      }\n    });\n  }","id":79514,"modified_method":"private Iterable<SNode> getExternalReferences(final SNode node) {\n    Iterable<SNode> result = ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.ParameterReference\", false, new String[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return !(ListSequence.fromList(SNodeOperations.getAncestors(SLinkOperations.getTarget(it, \"variableDeclaration\", false), null, false)).contains(node));\n      }\n    });\n    result = Sequence.fromIterable(result).concat(ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.LocalVariableReference\", false, new String[]{})).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return !(ListSequence.fromList(SNodeOperations.getAncestors(SLinkOperations.getTarget(it, \"variableDeclaration\", false), null, false)).contains(node));\n      }\n    }));\n    return result;\n  }","commit_id":"8aad35761ddce1f1470c832ec4e81dc24edcd5b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(AnActionEvent event) {\n    removeAll();\n\n    SModelDescriptor modelDescriptor = event.getData(MPSDataKeys.CONTEXT_MODEL);\n    if (modelDescriptor == null) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    IScope scope = event.getData(MPSDataKeys.SCOPE);\n    IOperationContext context = event.getData(MPSDataKeys.OPERATION_CONTEXT);\n    Integer selectedItemsCount = event.getData(MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE);\n    TreeNode treeNode = event.getData(MPSDataKeys.LOGICAL_VIEW_NODE);\n\n    boolean isStubModel = SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n    boolean singleItemSelected = selectedItemsCount != null && selectedItemsCount == 1;\n    if (scope == null || context == null || isStubModel || !singleItemSelected) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    setEnabledState(event.getPresentation(), true);\n\n    if (!(treeNode instanceof PackageNode)) {\n      myPackage = null;\n    } else {\n      final PackageNode node = (PackageNode) treeNode;\n      myPackage = node.getPackage();\n    }\n\n    List<Language> modelLanguages = modelDescriptor.getSModel().getLanguages(scope);\n    if (modelLanguages.size() == 0) {\n      add(new BaseAction(\"<NO LANGUAGES>\") {\n        protected void doExecute(AnActionEvent e) {\n        }\n      });\n      //add(new AddLanguageImport_Action());\n    }\n\n    LanguageAspect aspect = Language.getModelAspect(modelDescriptor);\n    if (aspect != null) {\n      ModuleReference ref = aspect.getMainLanguage();\n      Language lang = scope.getLanguage(ref);\n      modelLanguages.remove(lang);\n\n      for (ConceptDeclaration conceptDeclaration : lang.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n\n      addSeparator();\n    }\n\n\n    Collections.sort(modelLanguages, new ToStringComparator());\n\n    List<Language> languagesWithRoots = new ArrayList<Language>();\n    for (final Language language : modelLanguages) {\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          languagesWithRoots.add(language);\n          break;\n        }\n      }\n    }\n\n    boolean plain = myPlain || (languagesWithRoots.size() == 1 && aspect == null);\n\n    for (final Language language : languagesWithRoots) {\n      String name = language.getNamespace();\n      Icon icon = IconManager.getIconForNamespace(language.getNamespace());\n      BaseGroup langRootsGroup;\n\n      if (!plain) {\n        langRootsGroup = new BaseGroup(name, name, icon);\n        langRootsGroup.setPopup(true);\n      } else {\n        langRootsGroup = this;\n      }\n\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          langRootsGroup.add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n      if (!plain) {\n        this.add(langRootsGroup);\n      } else {\n        this.addSeparator();\n      }\n    }\n  }","id":79515,"modified_method":"public void doUpdate(AnActionEvent event) {\n    removeAll();\n\n    SModelDescriptor modelDescriptor = event.getData(MPSDataKeys.CONTEXT_MODEL);\n    if (modelDescriptor == null) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    IScope scope = event.getData(MPSDataKeys.SCOPE);\n    IOperationContext context = event.getData(MPSDataKeys.OPERATION_CONTEXT);\n    Integer selectedItemsCount = event.getData(MPSDataKeys.LOGICAL_VIEW_SELECTION_SIZE);\n    TreeNode treeNode = event.getData(MPSDataKeys.LOGICAL_VIEW_NODE);\n\n    boolean isStubModel = SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n    boolean singleItemSelected = selectedItemsCount != null && selectedItemsCount == 1;\n    if (scope == null || context == null || isStubModel || !singleItemSelected) {\n      setEnabledState(event.getPresentation(), false);\n      return;\n    }\n\n    setEnabledState(event.getPresentation(), true);\n\n    if (!(treeNode instanceof PackageNode)) {\n      myPackage = null;\n    } else {\n      final PackageNode node = (PackageNode) treeNode;\n      myPackage = node.getPackage();\n    }\n\n    List<Language> modelLanguages = modelDescriptor.getSModel().getLanguages(scope);\n    if (modelLanguages.size() == 0) {\n      add(new AddLanguageImport_Action());\n    }\n\n    LanguageAspect aspect = Language.getModelAspect(modelDescriptor);\n    if (aspect != null) {\n      ModuleReference ref = aspect.getMainLanguage();\n      Language lang = scope.getLanguage(ref);\n      modelLanguages.remove(lang);\n\n      for (ConceptDeclaration conceptDeclaration : lang.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n\n      addSeparator();\n    }\n\n\n    Collections.sort(modelLanguages, new ToStringComparator());\n\n    List<Language> languagesWithRoots = new ArrayList<Language>();\n    for (final Language language : modelLanguages) {\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          languagesWithRoots.add(language);\n          break;\n        }\n      }\n    }\n\n    boolean plain = myPlain || (languagesWithRoots.size() == 1 && aspect == null);\n\n    for (final Language language : languagesWithRoots) {\n      String name = language.getNamespace();\n      Icon icon = IconManager.getIconForNamespace(language.getNamespace());\n      BaseGroup langRootsGroup;\n\n      if (!plain) {\n        langRootsGroup = new BaseGroup(name, name, icon);\n        langRootsGroup.setPopup(true);\n      } else {\n        langRootsGroup = this;\n      }\n\n      for (ConceptDeclaration conceptDeclaration : language.getConceptDeclarations()) {\n        if (ModelConstraintsManager.getInstance().canBeRoot(context, NameUtil.nodeFQName(conceptDeclaration), modelDescriptor.getSModel())) {\n          langRootsGroup.add(new NewRootNodeAction(new SNodePointer(conceptDeclaration), modelDescriptor));\n        }\n      }\n      if (!plain) {\n        this.add(langRootsGroup);\n      } else {\n        this.addSeparator();\n      }\n    }\n  }","commit_id":"8aad35761ddce1f1470c832ec4e81dc24edcd5b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean isAbblicable(SNode node) {\n    return SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.Expression\") && (SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false) != null);\n  }","id":79516,"modified_method":"public static boolean isApplicable(SNode node) {\n    return SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.Expression\") && (SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false) != null);\n  }","commit_id":"8aad35761ddce1f1470c832ec4e81dc24edcd5b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event) {\n    return IntroduceConstantRefactoring.isAbblicable(IntroduceConstant_Action.this.node);\n  }","id":79517,"modified_method":"public boolean isApplicable(AnActionEvent event) {\n    return IntroduceConstantRefactoring.isApplicable(IntroduceConstant_Action.this.node);\n  }","commit_id":"8aad35761ddce1f1470c832ec4e81dc24edcd5b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void virtual_appendName_1368030936106665465(SNode thisNode, SNode parent, StringBuilder sb) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(thisNode), \"jetbrains.mps.build.structure.BuildProject\")) {\n      sb.append(SPropertyOperations.getString(SNodeOperations.cast(SNodeOperations.getParent(thisNode), \"jetbrains.mps.build.structure.BuildProject\"), \"name\"));\n      sb.append(\".\");\n    }\n    sb.append(\"default\");\n  }","id":79518,"modified_method":"public static void virtual_appendName_1368030936106665465(SNode thisNode, SNode parent, StringBuilder sb) {\n    sb.append(\"/\");\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected Map<String, ReferenceConstraintsDescriptor> getNotDefaultReferences() {\n    Map<String, ReferenceConstraintsDescriptor> references = new HashMap();\n    references.put(\"target\", new BaseReferenceConstraintsDescriptor(\"target\", this) {\n      @Override\n      public boolean hasOwnScopeProvider() {\n        return true;\n      }\n\n      @Nullable\n      @Override\n      public ReferenceScopeProvider getScopeProvider() {\n        return new BaseScopeProvider() {\n          @Override\n          public boolean hasPresentation() {\n            return true;\n          }\n\n          @Override\n          public String getPresentation(final IOperationContext operationContext, final ReferencePresentationContext _context) {\n            SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n            String target = null;\n            if ((contextProject != null)) {\n              Scope importedArtifactsScope = ScopeUtil.getVisibleArtifactsScope(contextProject);\n              if (importedArtifactsScope != null && !(importedArtifactsScope instanceof ModelPlusImportedScope)) {\n                target = importedArtifactsScope.getReferenceText(_context.getContextNode(), _context.getParameterNode());\n              }\n            }\n            if (target == null) {\n              target = BaseConcept_Behavior.call_getPresentation_1213877396640(_context.getParameterNode());\n            }\n            return (_context.getSmartReference() ?\n              \"import \" + target :\n              target\n            );\n          }\n\n          @Override\n          public SNodePointer getSearchScopeValidatorNode() {\n            return breakingNode_cl5pbm_a0a2a0a0a1a0b0a1a0;\n          }\n\n          @Override\n          public Scope createScope(final IOperationContext operationContext, final ReferenceConstraintsContext _context) {\n            {\n              SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n              if ((contextProject != null)) {\n                return new FilteringScope(ScopeUtil.getVisibleArtifactsScope(contextProject)) {\n                  @Override\n                  public boolean isExcluded(SNode node) {\n                    return !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.structure.BuildLayout_Container\"));\n                  }\n                };\n              }\n              return new ModelPlusImportedScope(_context.getModel(), false, operationContext.getScope(), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n            }\n          }\n        };\n      }\n    });\n    return references;\n  }","id":79519,"modified_method":"@Override\n  protected Map<String, ReferenceConstraintsDescriptor> getNotDefaultReferences() {\n    Map<String, ReferenceConstraintsDescriptor> references = new HashMap();\n    references.put(\"target\", new BaseReferenceConstraintsDescriptor(\"target\", this) {\n      @Override\n      public boolean hasOwnScopeProvider() {\n        return true;\n      }\n\n      @Nullable\n      @Override\n      public ReferenceScopeProvider getScopeProvider() {\n        return new BaseScopeProvider() {\n          @Override\n          public boolean hasPresentation() {\n            return true;\n          }\n\n          @Override\n          public String getPresentation(final IOperationContext operationContext, final ReferencePresentationContext _context) {\n            SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n            String target = null;\n            if ((contextProject != null)) {\n              Scope importedArtifactsScope = ScopeUtil.getVisibleArtifactsScope(contextProject, true);\n              if (importedArtifactsScope != null && !(importedArtifactsScope instanceof ModelPlusImportedScope)) {\n                target = importedArtifactsScope.getReferenceText(_context.getContextNode(), _context.getParameterNode());\n              }\n            }\n            if (target == null) {\n              target = BaseConcept_Behavior.call_getPresentation_1213877396640(_context.getParameterNode());\n            }\n            return (_context.getSmartReference() ?\n              \"import \" + target :\n              target\n            );\n          }\n\n          @Override\n          public SNodePointer getSearchScopeValidatorNode() {\n            return breakingNode_cl5pbm_a0a2a0a0a1a0b0a1a0;\n          }\n\n          @Override\n          public Scope createScope(final IOperationContext operationContext, final ReferenceConstraintsContext _context) {\n            {\n              SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n              if ((contextProject != null)) {\n                return new FilteringScope(ScopeUtil.getVisibleArtifactsScope(contextProject, true)) {\n                  @Override\n                  public boolean isExcluded(SNode node) {\n                    return !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.structure.BuildLayout_Container\"));\n                  }\n                };\n              }\n              return new ModelPlusImportedScope(_context.getModel(), false, operationContext.getScope(), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n            }\n          }\n        };\n      }\n    });\n    return references;\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected Map<String, ReferenceConstraintsDescriptor> getNotDefaultReferences() {\n    Map<String, ReferenceConstraintsDescriptor> references = new HashMap();\n    references.put(\"target\", new BaseReferenceConstraintsDescriptor(\"target\", this) {\n      @Override\n      public boolean hasOwnScopeProvider() {\n        return true;\n      }\n\n      @Nullable\n      @Override\n      public ReferenceScopeProvider getScopeProvider() {\n        return new BaseScopeProvider() {\n          @Override\n          public boolean hasPresentation() {\n            return true;\n          }\n\n          @Override\n          public String getPresentation(final IOperationContext operationContext, final ReferencePresentationContext _context) {\n            SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n            String target = null;\n            if ((_context.getContextNode() != null)) {\n              Scope importedArtifactsScope = ScopeUtil.getVisibleArtifactsScope(contextProject);\n              if (importedArtifactsScope != null && !(importedArtifactsScope instanceof ModelPlusImportedScope)) {\n                target = importedArtifactsScope.getReferenceText(_context.getContextNode(), _context.getParameterNode());\n              }\n            }\n            if (target == null) {\n              target = BaseConcept_Behavior.call_getPresentation_1213877396640(_context.getParameterNode());\n            }\n            return (_context.getSmartReference() ?\n              \"import \" + target :\n              target\n            );\n          }\n\n          @Override\n          public SNodePointer getSearchScopeValidatorNode() {\n            return breakingNode_gjnfdd_a0a2a0a0a1a0b0a1a0;\n          }\n\n          @Override\n          public Scope createScope(final IOperationContext operationContext, final ReferenceConstraintsContext _context) {\n            {\n              SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n              if ((contextProject != null)) {\n                return ScopeUtil.getVisibleArtifactsScope(contextProject);\n              }\n              return new EmptyScope();\n            }\n          }\n        };\n      }\n    });\n    return references;\n  }","id":79520,"modified_method":"@Override\n  protected Map<String, ReferenceConstraintsDescriptor> getNotDefaultReferences() {\n    Map<String, ReferenceConstraintsDescriptor> references = new HashMap();\n    references.put(\"target\", new BaseReferenceConstraintsDescriptor(\"target\", this) {\n      @Override\n      public boolean hasOwnScopeProvider() {\n        return true;\n      }\n\n      @Nullable\n      @Override\n      public ReferenceScopeProvider getScopeProvider() {\n        return new BaseScopeProvider() {\n          @Override\n          public boolean hasPresentation() {\n            return true;\n          }\n\n          @Override\n          public String getPresentation(final IOperationContext operationContext, final ReferencePresentationContext _context) {\n            SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n            String target = null;\n            if ((_context.getContextNode() != null)) {\n              Scope importedArtifactsScope = ScopeUtil.getVisibleArtifactsScope(contextProject, false);\n              if (importedArtifactsScope != null && !(importedArtifactsScope instanceof ModelPlusImportedScope)) {\n                target = importedArtifactsScope.getReferenceText(_context.getContextNode(), _context.getParameterNode());\n              }\n            }\n            if (target == null) {\n              target = BaseConcept_Behavior.call_getPresentation_1213877396640(_context.getParameterNode());\n            }\n            return (_context.getSmartReference() ?\n              \"import \" + target :\n              target\n            );\n          }\n\n          @Override\n          public SNodePointer getSearchScopeValidatorNode() {\n            return breakingNode_gjnfdd_a0a2a0a0a1a0b0a1a0;\n          }\n\n          @Override\n          public Scope createScope(final IOperationContext operationContext, final ReferenceConstraintsContext _context) {\n            {\n              SNode contextProject = SNodeOperations.getAncestor(_context.getContextNode(), \"jetbrains.mps.build.structure.BuildProject\", true, false);\n              if ((contextProject != null)) {\n                return ScopeUtil.getVisibleArtifactsScope(contextProject, false);\n              }\n              return new EmptyScope();\n            }\n          }\n        };\n      }\n    });\n    return references;\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public VisibleJarsScope(VisibleArtifacts artifacts) {\n      super(new ScopeUtil.VisibleArtifactsScope(artifacts));\n    }","id":79521,"modified_method":"public VisibleJarsScope(VisibleArtifacts artifacts) {\n      super(new ScopeUtil.VisibleArtifactsScope(artifacts, false));\n    }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public VisibleJarFoldersScope(VisibleArtifacts artifacts) {\n      super(new ScopeUtil.VisibleArtifactsScope(artifacts));\n    }","id":79522,"modified_method":"public VisibleJarFoldersScope(VisibleArtifacts artifacts) {\n      super(new ScopeUtil.VisibleArtifactsScope(artifacts, false));\n    }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public VisibleArtifactsScope(VisibleArtifacts artifacts) {\n      this.artifacts = artifacts;\n    }","id":79523,"modified_method":"public VisibleArtifactsScope(VisibleArtifacts artifacts, boolean includeLayoutRoots) {\n      this.artifacts = artifacts;\n      this.includeLayoutRoots = includeLayoutRoots;\n    }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope getVisibleJarFoldersScope(SNode project) {\n    if (SNodeOperations.getModel(project).isTransient()) {\n      IModule transientModule = SNodeOperations.getModel(project).getModelDescriptor().getModule();\n      return new ModelPlusImportedScope(SNodeOperations.getModel(project), false, transientModule.getScope(), \"jetbrains.mps.build.structure.BuildSource_SingleFolder\");\n    }\n    VisibleArtifacts artifacts = new VisibleArtifacts(project, null);\n    artifacts.collect();\n    return new ScopeUtil.VisibleJarFoldersScope(artifacts);\n  }","id":79524,"modified_method":"public static Scope getVisibleJarFoldersScope(SNode project) {\n    if (SNodeOperations.getModel(project).isTransient()) {\n      IModule transientModule = SNodeOperations.getModel(project).getModelDescriptor().getModule();\n      return new ModelPlusImportedScope(SNodeOperations.getModel(project), false, transientModule.getScope(), \"jetbrains.mps.build.structure.BuildSource_SingleFolder\");\n    }\n    return new ScopeUtil.VisibleJarFoldersScope(VisibleArtifacts.createFor(project));\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope getVisibleArtifactsScope(SNode project) {\n    if (SNodeOperations.getModel(project).isTransient()) {\n      IModule transientModule = SNodeOperations.getModel(project).getModelDescriptor().getModule();\n      return new ModelPlusImportedScope(SNodeOperations.getModel(project), false, transientModule.getScope(), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n    }\n    VisibleArtifacts artifacts = new VisibleArtifacts(project, null);\n    artifacts.collect();\n    return new ScopeUtil.VisibleArtifactsScope(artifacts);\n  }","id":79525,"modified_method":"public static Scope getVisibleArtifactsScope(SNode project, boolean includeLayoutRoots) {\n    if (SNodeOperations.getModel(project).isTransient()) {\n      IModule transientModule = SNodeOperations.getModel(project).getModelDescriptor().getModule();\n      return new ModelPlusImportedScope(SNodeOperations.getModel(project), false, transientModule.getScope(), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n    }\n    return new ScopeUtil.VisibleArtifactsScope(VisibleArtifacts.createFor(project), includeLayoutRoots);\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SNode> getAllNodes() {\n      return Sequence.fromIterable(artifacts.getArtifacts()).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return BuildLayout_Node_Behavior.call_isFile_1368030936106753986(it) || BuildLayout_Node_Behavior.call_isFolder_1368030936106753980(it);\n        }\n      });\n    }","id":79526,"modified_method":"private Iterable<SNode> getAllNodes() {\n      Iterable<SNode> seq = Sequence.fromIterable(artifacts.getArtifacts()).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return BuildLayout_Node_Behavior.call_isFile_1368030936106753986(it) || BuildLayout_Node_Behavior.call_isFolder_1368030936106753980(it);\n        }\n      });\n      if (includeLayoutRoots) {\n        seq = Sequence.fromIterable(seq).concat(Sequence.fromIterable(artifacts.getLayouts()));\n      }\n      return seq;\n    }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getReferenceText(SNode contextNode, SNode node) {\n      if (node == null || !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.structure.BuildLayout_Node\"))) {\n        return null;\n      }\n\n      String result = getName(SNodeOperations.cast(node, \"jetbrains.mps.build.structure.BuildLayout_Node\"));\n      for (SNode n : getAllNodes()) {\n        if (n == node) {\n          continue;\n        }\n        String name = getName(n);\n        if (name.equals(result)) {\n          // ambiguity \n          return null;\n        }\n      }\n      return result;\n    }","id":79527,"modified_method":"public String getReferenceText(SNode contextNode, SNode node) {\n      if (node == null || !(SNodeOperations.isInstanceOf(node, \"jetbrains.mps.build.structure.BuildLayout_Node\"))) {\n        return null;\n      }\n\n      return getName(SNodeOperations.cast(node, \"jetbrains.mps.build.structure.BuildLayout_Node\"));\n    }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope getVisibleJarsScope(SNode project) {\n    if (SNodeOperations.getModel(project).isTransient()) {\n      IModule transientModule = SNodeOperations.getModel(project).getModelDescriptor().getModule();\n      return new ModelPlusImportedScope(SNodeOperations.getModel(project), false, transientModule.getScope(), \"jetbrains.mps.build.structure.BuildSource_SingleFile\");\n    }\n    VisibleArtifacts artifacts = new VisibleArtifacts(project, null);\n    artifacts.collect();\n    return new ScopeUtil.VisibleJarsScope(artifacts);\n  }","id":79528,"modified_method":"public static Scope getVisibleJarsScope(SNode project) {\n    if (SNodeOperations.getModel(project).isTransient()) {\n      IModule transientModule = SNodeOperations.getModel(project).getModelDescriptor().getModule();\n      return new ModelPlusImportedScope(SNodeOperations.getModel(project), false, transientModule.getScope(), \"jetbrains.mps.build.structure.BuildSource_SingleFile\");\n    }\n    return new ScopeUtil.VisibleJarsScope(VisibleArtifacts.createFor(project));\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildAspect\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildCompositePath\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"head\"}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildCustomWorkflow\", \"jetbrains.mps.build.structure.BuildAspect\", false, new String[]{\"jetbrains.mps.build.structure.BuildAspect\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildDependency\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildExternalDependency\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildExternalLayout\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildLayout_Container\"}, new String[]{}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildExternalLayoutDependency\", \"jetbrains.mps.build.structure.BuildDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildDependency\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{\"layout\"});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileExcludeSelector\", \"jetbrains.mps.build.structure.BuildFileSelector\", false, new String[]{\"jetbrains.mps.build.structure.BuildFileSelector\"}, new String[]{\"pattern\"}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileIncludeSelector\", \"jetbrains.mps.build.structure.BuildFileSelector\", false, new String[]{\"jetbrains.mps.build.structure.BuildFileSelector\"}, new String[]{\"pattern\"}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileIncludesSelector\", \"jetbrains.mps.build.structure.BuildFileSelector\", false, new String[]{\"jetbrains.mps.build.structure.BuildFileSelector\", \"jetbrains.mps.build.structure.BuildFileSelectorInAttribute\"}, new String[]{\"pattern\"}, new String[]{});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileSelector\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileSelectorInAttribute\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFolderMacro\", \"jetbrains.mps.build.structure.BuildMacro\", false, new String[]{\"jetbrains.mps.build.structure.BuildMacro\"}, new String[]{}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFileSet\", \"jetbrains.mps.build.structure.BuildInputResourceSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputResourceSet\"}, new String[]{}, new String[]{});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFiles\", \"jetbrains.mps.build.structure.BuildInputFileSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFileSet\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFolderSet\", \"jetbrains.mps.build.structure.BuildInputResourceSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputResourceSet\"}, new String[]{}, new String[]{});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFolders\", \"jetbrains.mps.build.structure.BuildInputFolderSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFolderSet\"}, new String[]{}, new String[]{});\n      case 17:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputResourceSet\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 18:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputSingleFile\", \"jetbrains.mps.build.structure.BuildInputFileSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFileSet\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\", \"jetbrains.mps.build.structure.BuildSource_SingleFile\"}, new String[]{}, new String[]{});\n      case 19:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputSingleFolder\", \"jetbrains.mps.build.structure.BuildInputFolderSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFolderSet\", \"jetbrains.mps.build.structure.BuildSource_SingleFolder\"}, new String[]{}, new String[]{});\n      case 20:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildJavaPlugin\", \"jetbrains.mps.build.structure.BuildPlugin\", false, new String[]{\"jetbrains.mps.build.structure.BuildPlugin\"}, new String[]{}, new String[]{});\n      case 21:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\"}, new String[]{}, new String[]{});\n      case 22:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildLayout_Container\"}, new String[]{}, new String[]{});\n      case 23:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{});\n      case 24:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CompileOutputOf\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{\"module\"});\n      case 25:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Container\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 26:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 27:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Copy\", \"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{});\n      case 28:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", \"jetbrains.mps.build.structure.BuildLayout_CopyHandler\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyHandler\"}, new String[]{}, new String[]{});\n      case 29:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilterFixCRLF\", \"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\"}, new String[]{\"eol\", \"removeEOF\"}, new String[]{});\n      case 30:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilterReplaceRegex\", \"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\"}, new String[]{\"pattern\", \"flags\"}, new String[]{});\n      case 31:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilterReplaceTokens\", \"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\"}, new String[]{\"key\"}, new String[]{});\n      case 32:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFlattenMapper\", \"jetbrains.mps.build.structure.BuildLayout_CopyMapper\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyMapper\"}, new String[]{}, new String[]{});\n      case 33:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyHandler\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 34:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyMapper\", \"jetbrains.mps.build.structure.BuildLayout_CopyHandler\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyHandler\"}, new String[]{}, new String[]{});\n      case 35:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CustomCopy\", \"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\"}, new String[]{}, new String[]{});\n      case 36:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_EchoProperties\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildStringContainer\"}, new String[]{}, new String[]{});\n      case 37:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_EchoPropertyEntry\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"key\"}, new String[]{});\n      case 38:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_EchoXml\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildStringContainer\"}, new String[]{}, new String[]{});\n      case 39:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_ExportAsJavaLibrary\", \"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\"}, new String[]{}, new String[]{\"library\"});\n      case 40:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_FileSet\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 41:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_FileStub\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\", \"jetbrains.mps.build.structure.BuildSource_SingleFile\"}, new String[]{}, new String[]{});\n      case 42:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Filemode\", \"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\"}, new String[]{\"filemode\", \"dirmode\"}, new String[]{});\n      case 43:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Folder\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\"}, new String[]{}, new String[]{});\n      case 44:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Import\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildExternalDependency\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{\"target\"});\n      case 45:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_ImportContent\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildExternalDependency\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{\"target\"});\n      case 46:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Jar\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\", \"jetbrains.mps.build.structure.BuildSource_SingleFile\"}, new String[]{}, new String[]{});\n      case 47:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildSource_SingleFolder\", \"jetbrains.mps.build.structure.BuildStringContainer\"}, new String[]{}, new String[]{});\n      case 48:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{});\n      case 49:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_PathElement\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 50:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_PureNode\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 51:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Tar\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\"}, new String[]{\"compression\"}, new String[]{});\n      case 52:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\"}, new String[]{}, new String[]{});\n      case 53:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Zip\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\"}, new String[]{}, new String[]{});\n      case 54:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildMacro\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 55:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildNamedLayout\", \"jetbrains.mps.build.structure.BuildAspect\", false, new String[]{\"jetbrains.mps.build.structure.BuildAspect\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildLayout_Container\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{});\n      case 56:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildPlugin\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 57:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildProject\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.ScopeProvider\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{\"internalBaseDirectory\"}, new String[]{});\n      case 58:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildProjectDependency\", \"jetbrains.mps.build.structure.BuildDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildDependency\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{\"script\"});\n      case 59:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 60:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildRelativePath\", \"jetbrains.mps.build.structure.BuildSourcePath\", false, new String[]{\"jetbrains.mps.build.structure.BuildSourcePath\"}, new String[]{}, new String[]{});\n      case 61:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourceMacroRelativePath\", \"jetbrains.mps.build.structure.BuildRelativePath\", false, new String[]{\"jetbrains.mps.build.structure.BuildRelativePath\"}, new String[]{}, new String[]{\"macro\"});\n      case 62:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourcePath\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 63:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourceProjectRelativePath\", \"jetbrains.mps.build.structure.BuildRelativePath\", false, new String[]{\"jetbrains.mps.build.structure.BuildRelativePath\"}, new String[]{}, new String[]{});\n      case 64:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourceSetContainer\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 65:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_CompilablePart\", null, true, new String[]{\"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 66:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 67:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaClassFolder\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\"}, new String[]{}, new String[]{});\n      case 68:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaContentFolder\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"kind\", \"relativePath\"}, new String[]{});\n      case 69:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaContentRoot\", \"jetbrains.mps.build.structure.BuildSource_JavaSources\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaSources\"}, new String[]{}, new String[]{});\n      case 70:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 71:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyExternalJar\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{\"reexport\"}, new String[]{});\n      case 72:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyFileset\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\"}, new String[]{}, new String[]{});\n      case 73:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyJar\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\"}, new String[]{\"reexport\"}, new String[]{});\n      case 74:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyLibrary\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{\"reexport\"}, new String[]{\"library\"});\n      case 75:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyModule\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{\"reexport\"}, new String[]{\"module\"});\n      case 76:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaExternalJarFolderRef\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"folder\"});\n      case 77:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaExternalJarRef\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"jar\"});\n      case 78:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaFiles\", \"jetbrains.mps.build.structure.BuildSource_JavaSources\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaSources\"}, new String[]{}, new String[]{});\n      case 79:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaJar\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\"}, new String[]{}, new String[]{});\n      case 80:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaJars\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.build.structure.BuildSourceSetContainer\"}, new String[]{}, new String[]{});\n      case 81:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibrary\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 82:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryCP\", \"jetbrains.mps.build.structure.BuildSource_JavaLibraryElement\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaLibraryElement\"}, new String[]{}, new String[]{});\n      case 83:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryElement\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 84:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryExternalJar\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{}, new String[]{});\n      case 85:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryExternalJarFolder\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{}, new String[]{});\n      case 86:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaModule\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildSource_CompilablePart\"}, new String[]{}, new String[]{});\n      case 87:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaModuleOptions\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"compileOptions\"});\n      case 88:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaOptions\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\"}, new String[]{\"optionsName\", \"generateDebugInfo\", \"copyResources\", \"heapSize\", \"noWarnings\", \"compiler\"}, new String[]{});\n      case 89:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaResources\", \"jetbrains.mps.build.structure.BuildSource_JavaSources\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaSources\", \"jetbrains.mps.build.structure.BuildSourceSetContainer\"}, new String[]{}, new String[]{});\n      case 90:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaSources\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 91:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_SingleFile\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 92:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_SingleFolder\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 93:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildString\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 94:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildStringContainer\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 95:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildStringNotEmpty\", \"jetbrains.mps.build.structure.BuildString\", false, new String[]{\"jetbrains.mps.build.structure.BuildString\"}, new String[]{}, new String[]{});\n      case 96:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildStringPart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 97:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildTextStringPart\", \"jetbrains.mps.build.structure.BuildStringPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildStringPart\"}, new String[]{\"text\"}, new String[]{});\n      case 98:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildVarRefStringPart\", \"jetbrains.mps.build.structure.BuildStringPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildStringPart\"}, new String[]{}, new String[]{\"macro\"});\n      case 99:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildVariableMacro\", \"jetbrains.mps.build.structure.BuildMacro\", false, new String[]{\"jetbrains.mps.build.structure.BuildMacro\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":79529,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildAspect\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildCompositePath\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"head\"}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildCustomWorkflow\", \"jetbrains.mps.build.structure.BuildAspect\", false, new String[]{\"jetbrains.mps.build.structure.BuildAspect\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildDependency\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildExternalDependency\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildExternalLayout\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildExternalLayoutDependency\", \"jetbrains.mps.build.structure.BuildDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildDependency\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{\"layout\"});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileExcludeSelector\", \"jetbrains.mps.build.structure.BuildFileSelector\", false, new String[]{\"jetbrains.mps.build.structure.BuildFileSelector\"}, new String[]{\"pattern\"}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileIncludeSelector\", \"jetbrains.mps.build.structure.BuildFileSelector\", false, new String[]{\"jetbrains.mps.build.structure.BuildFileSelector\"}, new String[]{\"pattern\"}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileIncludesSelector\", \"jetbrains.mps.build.structure.BuildFileSelector\", false, new String[]{\"jetbrains.mps.build.structure.BuildFileSelector\", \"jetbrains.mps.build.structure.BuildFileSelectorInAttribute\"}, new String[]{\"pattern\"}, new String[]{});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileSelector\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFileSelectorInAttribute\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildFolderMacro\", \"jetbrains.mps.build.structure.BuildMacro\", false, new String[]{\"jetbrains.mps.build.structure.BuildMacro\"}, new String[]{}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFileSet\", \"jetbrains.mps.build.structure.BuildInputResourceSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputResourceSet\"}, new String[]{}, new String[]{});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFiles\", \"jetbrains.mps.build.structure.BuildInputFileSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFileSet\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFolderSet\", \"jetbrains.mps.build.structure.BuildInputResourceSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputResourceSet\"}, new String[]{}, new String[]{});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputFolders\", \"jetbrains.mps.build.structure.BuildInputFolderSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFolderSet\"}, new String[]{}, new String[]{});\n      case 17:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputResourceSet\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 18:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputSingleFile\", \"jetbrains.mps.build.structure.BuildInputFileSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFileSet\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\", \"jetbrains.mps.build.structure.BuildSource_SingleFile\"}, new String[]{}, new String[]{});\n      case 19:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildInputSingleFolder\", \"jetbrains.mps.build.structure.BuildInputFolderSet\", false, new String[]{\"jetbrains.mps.build.structure.BuildInputFolderSet\", \"jetbrains.mps.build.structure.BuildSource_SingleFolder\"}, new String[]{}, new String[]{});\n      case 20:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildJavaPlugin\", \"jetbrains.mps.build.structure.BuildPlugin\", false, new String[]{\"jetbrains.mps.build.structure.BuildPlugin\"}, new String[]{}, new String[]{});\n      case 21:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\"}, new String[]{}, new String[]{});\n      case 22:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildLayout_Container\"}, new String[]{}, new String[]{});\n      case 23:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\"}, new String[]{}, new String[]{});\n      case 24:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CompileOutputOf\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{\"module\"});\n      case 25:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Container\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 26:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 27:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Copy\", \"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{});\n      case 28:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", \"jetbrains.mps.build.structure.BuildLayout_CopyHandler\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyHandler\"}, new String[]{}, new String[]{});\n      case 29:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilterFixCRLF\", \"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\"}, new String[]{\"eol\", \"removeEOF\"}, new String[]{});\n      case 30:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilterReplaceRegex\", \"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\"}, new String[]{\"pattern\", \"flags\"}, new String[]{});\n      case 31:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFilterReplaceTokens\", \"jetbrains.mps.build.structure.BuildLayout_CopyFilter\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyFilter\"}, new String[]{\"key\"}, new String[]{});\n      case 32:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyFlattenMapper\", \"jetbrains.mps.build.structure.BuildLayout_CopyMapper\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyMapper\"}, new String[]{}, new String[]{});\n      case 33:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyHandler\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 34:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CopyMapper\", \"jetbrains.mps.build.structure.BuildLayout_CopyHandler\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_CopyHandler\"}, new String[]{}, new String[]{});\n      case 35:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_CustomCopy\", \"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractCopy\"}, new String[]{}, new String[]{});\n      case 36:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_EchoProperties\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildStringContainer\"}, new String[]{}, new String[]{});\n      case 37:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_EchoPropertyEntry\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"key\"}, new String[]{});\n      case 38:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_EchoXml\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildStringContainer\"}, new String[]{}, new String[]{});\n      case 39:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_ExportAsJavaLibrary\", \"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\"}, new String[]{}, new String[]{\"library\"});\n      case 40:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_FileSet\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 41:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_FileStub\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\", \"jetbrains.mps.build.structure.BuildSource_SingleFile\"}, new String[]{}, new String[]{});\n      case 42:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Filemode\", \"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\"}, new String[]{\"filemode\", \"dirmode\"}, new String[]{});\n      case 43:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Folder\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\"}, new String[]{}, new String[]{});\n      case 44:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Import\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildExternalDependency\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{\"target\"});\n      case 45:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_ImportContent\", \"jetbrains.mps.build.structure.BuildLayout_Node\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.build.structure.BuildExternalDependency\", \"jetbrains.mps.build.structure.BuildLayout_FileSet\"}, new String[]{}, new String[]{\"target\"});\n      case 46:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Jar\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\", \"jetbrains.mps.build.structure.BuildSource_SingleFile\"}, new String[]{}, new String[]{});\n      case 47:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildSource_SingleFolder\", \"jetbrains.mps.build.structure.BuildStringContainer\"}, new String[]{}, new String[]{});\n      case 48:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Node\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{});\n      case 49:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_PathElement\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 50:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_PureNode\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 51:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Tar\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\"}, new String[]{\"compression\"}, new String[]{});\n      case 52:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_TransparentContainer\", \"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_AbstractContainer\"}, new String[]{}, new String[]{});\n      case 53:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildLayout_Zip\", \"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", false, new String[]{\"jetbrains.mps.build.structure.BuildLayout_NamedContainer\", \"jetbrains.mps.build.structure.BuildLayout_ContainerAcceptingFileSet\", \"jetbrains.mps.build.structure.BuildLayout_PureNode\"}, new String[]{}, new String[]{});\n      case 54:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildMacro\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 55:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildNamedLayout\", \"jetbrains.mps.build.structure.BuildAspect\", false, new String[]{\"jetbrains.mps.build.structure.BuildAspect\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildLayout_Container\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{});\n      case 56:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildPlugin\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 57:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildProject\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.ScopeProvider\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{\"internalBaseDirectory\"}, new String[]{});\n      case 58:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildProjectDependency\", \"jetbrains.mps.build.structure.BuildDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildDependency\", \"jetbrains.mps.build.structure.BuildLayout_PathElement\"}, new String[]{}, new String[]{\"script\"});\n      case 59:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 60:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildRelativePath\", \"jetbrains.mps.build.structure.BuildSourcePath\", false, new String[]{\"jetbrains.mps.build.structure.BuildSourcePath\"}, new String[]{}, new String[]{});\n      case 61:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourceMacroRelativePath\", \"jetbrains.mps.build.structure.BuildRelativePath\", false, new String[]{\"jetbrains.mps.build.structure.BuildRelativePath\"}, new String[]{}, new String[]{\"macro\"});\n      case 62:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourcePath\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 63:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourceProjectRelativePath\", \"jetbrains.mps.build.structure.BuildRelativePath\", false, new String[]{\"jetbrains.mps.build.structure.BuildRelativePath\"}, new String[]{}, new String[]{});\n      case 64:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSourceSetContainer\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 65:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_CompilablePart\", null, true, new String[]{\"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 66:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 67:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaClassFolder\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\"}, new String[]{}, new String[]{});\n      case 68:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaContentFolder\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{\"kind\", \"relativePath\"}, new String[]{});\n      case 69:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaContentRoot\", \"jetbrains.mps.build.structure.BuildSource_JavaSources\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaSources\"}, new String[]{}, new String[]{});\n      case 70:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 71:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyExternalJar\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{\"reexport\"}, new String[]{});\n      case 72:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyFileset\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\"}, new String[]{}, new String[]{});\n      case 73:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyJar\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\"}, new String[]{\"reexport\"}, new String[]{});\n      case 74:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyLibrary\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{\"reexport\"}, new String[]{\"library\"});\n      case 75:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaDependencyModule\", \"jetbrains.mps.build.structure.BuildSource_JavaDependency\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaDependency\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{\"reexport\"}, new String[]{\"module\"});\n      case 76:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaExternalJarFolderRef\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"folder\"});\n      case 77:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaExternalJarRef\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"jar\"});\n      case 78:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaFiles\", \"jetbrains.mps.build.structure.BuildSource_JavaSources\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaSources\"}, new String[]{}, new String[]{});\n      case 79:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaJar\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\"}, new String[]{}, new String[]{});\n      case 80:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaJars\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.build.structure.BuildSourceSetContainer\"}, new String[]{}, new String[]{});\n      case 81:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibrary\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 82:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryCP\", \"jetbrains.mps.build.structure.BuildSource_JavaLibraryElement\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaLibraryElement\"}, new String[]{}, new String[]{});\n      case 83:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryElement\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 84:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryExternalJar\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{}, new String[]{});\n      case 85:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaLibraryExternalJarFolder\", \"jetbrains.mps.build.structure.BuildSource_JavaCP\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaCP\", \"jetbrains.mps.build.structure.BuildExternalDependency\"}, new String[]{}, new String[]{});\n      case 86:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaModule\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.build.structure.BuildSource_CompilablePart\"}, new String[]{}, new String[]{});\n      case 87:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaModuleOptions\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"compileOptions\"});\n      case 88:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaOptions\", \"jetbrains.mps.build.structure.BuildProjectPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildProjectPart\"}, new String[]{\"optionsName\", \"generateDebugInfo\", \"copyResources\", \"heapSize\", \"noWarnings\", \"compiler\"}, new String[]{});\n      case 89:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaResources\", \"jetbrains.mps.build.structure.BuildSource_JavaSources\", false, new String[]{\"jetbrains.mps.build.structure.BuildSource_JavaSources\", \"jetbrains.mps.build.structure.BuildSourceSetContainer\"}, new String[]{}, new String[]{});\n      case 90:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_JavaSources\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 91:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_SingleFile\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 92:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildSource_SingleFolder\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 93:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildString\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 94:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildStringContainer\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 95:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildStringNotEmpty\", \"jetbrains.mps.build.structure.BuildString\", false, new String[]{\"jetbrains.mps.build.structure.BuildString\"}, new String[]{}, new String[]{});\n      case 96:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildStringPart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 97:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildTextStringPart\", \"jetbrains.mps.build.structure.BuildStringPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildStringPart\"}, new String[]{\"text\"}, new String[]{});\n      case 98:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildVarRefStringPart\", \"jetbrains.mps.build.structure.BuildStringPart\", false, new String[]{\"jetbrains.mps.build.structure.BuildStringPart\"}, new String[]{}, new String[]{\"macro\"});\n      case 99:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.build.structure.BuildVariableMacro\", \"jetbrains.mps.build.structure.BuildMacro\", false, new String[]{\"jetbrains.mps.build.structure.BuildMacro\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void collect() {\n    for (SNode dep : SLinkOperations.getTargets(project, \"dependencies\", true)) {\n      SNode layoutDependency = SNodeOperations.as(dep, \"jetbrains.mps.build.structure.BuildExternalLayoutDependency\");\n      if (layoutDependency == null) {\n        continue;\n      }\n\n      SNode target = SLinkOperations.getTarget(layoutDependency, \"layout\", false);\n      collectInExternalLayout(layoutDependency, target);\n    }\n    for (SNode dep : SLinkOperations.getTargets(project, \"dependencies\", true)) {\n      SNode projectDependency = SNodeOperations.as(dep, \"jetbrains.mps.build.structure.BuildProjectDependency\");\n      if (projectDependency == null) {\n        continue;\n      }\n\n      SNode target = SLinkOperations.getTarget(projectDependency, \"script\", false);\n      collectInProject(projectDependency, target);\n    }\n  }","id":79530,"modified_method":"public void collect() {\n    for (SNode dep : SLinkOperations.getTargets(project, \"dependencies\", true)) {\n      SNode layoutDependency = SNodeOperations.as(dep, \"jetbrains.mps.build.structure.BuildExternalLayoutDependency\");\n      if (layoutDependency == null) {\n        continue;\n      }\n\n      SNode target = SLinkOperations.getTarget(layoutDependency, \"layout\", false);\n      collectInExternalLayout(layoutDependency, target);\n    }\n    for (SNode dep : SLinkOperations.getTargets(project, \"dependencies\", true)) {\n      SNode projectDependency = SNodeOperations.as(dep, \"jetbrains.mps.build.structure.BuildProjectDependency\");\n      if (projectDependency == null) {\n        continue;\n      }\n\n      SNode target = SLinkOperations.getTarget(projectDependency, \"script\", false);\n      if (target == project) {\n        continue;\n      }\n\n      collectInProject(projectDependency, target);\n    }\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void collectInProject(SNode parent, SNode target) {\n    target = (target != project ?\n      SNodeOperations.as(toOriginalNode(target), \"jetbrains.mps.build.structure.BuildProject\") :\n      project\n    );\n    if (target == null) {\n      return;\n    }\n    assert project == target || !(SNodeOperations.getModel(target).isTransient());\n\n    for (SNode node : SLinkOperations.getTargets(SLinkOperations.getTarget(target, \"layout\", true), \"children\", true)) {\n      collectInLayout(parent, node);\n    }\n  }","id":79531,"modified_method":"protected void collectInProject(SNode parent, SNode target) {\n    target = (target != project ?\n      SNodeOperations.as(toOriginalNode(target), \"jetbrains.mps.build.structure.BuildProject\") :\n      project\n    );\n    if (target == null) {\n      return;\n    }\n    assert project == target || !(SNodeOperations.getModel(target).isTransient());\n\n    ListSequence.fromList(visibleLayouts).addElement(SLinkOperations.getTarget(target, \"layout\", true));\n    if (SLinkOperations.getTarget(target, \"layout\", true) != parent) {\n      parentMap.put(SLinkOperations.getTarget(target, \"layout\", true), parent);\n    }\n    for (SNode node : SLinkOperations.getTargets(SLinkOperations.getTarget(target, \"layout\", true), \"children\", true)) {\n      collectInLayout(parent, node);\n    }\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode parent(SNode node) {\n    return parentMap.get(node);\n  }","id":79532,"modified_method":"public SNode parent(SNode node) {\n    SNode result = parentMap.get(node);\n    if (result == node) {\n      throw new IllegalStateException();\n    }\n    return result;\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectInExternalLayout(SNode parent, SNode target) {\n    target = SNodeOperations.as(toOriginalNode(target), \"jetbrains.mps.build.structure.BuildExternalLayout\");\n    if (target == null) {\n      return;\n    }\n    assert !(SNodeOperations.getModel(target).isTransient());\n\n    for (SNode node : SLinkOperations.getTargets(target, \"children\", true)) {\n      collectInLayout(parent, node);\n    }\n  }","id":79533,"modified_method":"private void collectInExternalLayout(SNode parent, SNode target) {\n    target = SNodeOperations.as(toOriginalNode(target), \"jetbrains.mps.build.structure.BuildExternalLayout\");\n    if (target == null) {\n      return;\n    }\n    assert !(SNodeOperations.getModel(target).isTransient());\n\n    ListSequence.fromList(visibleLayouts).addElement(target);\n    parentMap.put(target, parent);\n    for (SNode node : SLinkOperations.getTargets(target, \"children\", true)) {\n      collectInLayout(parent, node);\n    }\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode toOriginalNode(SNode node) {\n    return DependenciesHelper.getOriginalNode(node, genContext);\n  }","id":79534,"modified_method":"public SNode toOriginalNode(SNode node) {\n    if (node == null) {\n      return null;\n    }\n    return DependenciesHelper.getOriginalNode(node, genContext);\n  }","commit_id":"b7467dc993aec4b8322245855f44027a988546d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_5428983789737856721(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    return ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.as(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:972ae1d5-2beb-44b3-a739-a548d8eb423d(jetbrains.mps.build.mpsautobuild)\", \"5428983789737854526\"), \"entry\", true)).first(), \"jetbrains.mps.build.packaging.structure.ICompositeComponent\"), \"entry\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.packaging.structure.Copy\");\n      }\n    });\n  }","id":79535,"modified_method":"public static Iterable sourceNodesQuery_5428983789737856721(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    Iterable<SNode> seq = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.as(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:972ae1d5-2beb-44b3-a739-a548d8eb423d(jetbrains.mps.build.mpsautobuild)\", \"5428983789737854526\"), \"entry\", true)).first(), \"jetbrains.mps.build.packaging.structure.ICompositeComponent\"), \"entry\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.packaging.structure.Copy\") && !(CompositePathComponent_Behavior.call_getPath_1220983419344(SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.packaging.structure.Copy\"), \"sourcePath\", true), \"compositePathComponent\", true)).contains(\"source_gen\"));\n      }\n    });\n    Sequence.fromIterable(seq).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        System.err.println(CompositePathComponent_Behavior.call_getPath_1220983419344(SLinkOperations.getTarget(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.packaging.structure.Copy\"), \"sourcePath\", true), \"compositePathComponent\", true)));\n      }\n    });\n    return seq;\n  }","commit_id":"b339710112a3ab258360b17602ae4b291cb4dadf","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object execPropertyGet(SNode node, String propertyName, IScope scope) {\n    return SPropertyOperations.getString(node, \"name\") + \".\" + SPropertyOperations.getString(Configuration_Behavior.call_getLayout_1213877261819(node), \"name\");\n  }","id":79536,"modified_method":"public Object execPropertyGet(SNode node, String propertyName, IScope scope) {\n    return SPropertyOperations.getString(node, \"name\") + \"@\" + SPropertyOperations.getString(Configuration_Behavior.call_getLayout_1213877261819(node), \"name\");\n  }","commit_id":"8a5da8d7e87150416e921b4419051101b18fdd29","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor() {\n    this.myConstraints.add(new GenericCall_name_PropertyConstraint());\n    this.myConstraints.add(new StringLiteral_name_PropertyConstraint());\n    this.myConstraints.add(new MultiLineString_name_PropertyConstraint());\n    this.myConstraints.add(new TargetReference_targetDeclaration_ReferentConstraint());\n    this.myConstraints.add(new GenericCall_declaration_ReferentConstraint());\n    this.myConstraints.add(new PathReference_call_ReferentConstraint());\n    this.myConstraints.add(new TagetReferencePropertyValueExpression_declaration_ReferentConstraint());\n    this.myConstraints.add(new Reference_declaration_ReferentConstraint());\n    this.myConstraints.add(new GenericAttribute_attributeDeclaration_ReferentConstraint());\n    this.myConstraints.add(new PropertyReference_propertyDeclaration_ReferentConstraint());\n    this.myConstraints.add(new GenericCall_DefaultSearchScope());\n  }","id":79537,"modified_method":"public ConstraintsDescriptor() {\n    this.myConstraints.add(new GenericCall_name_PropertyConstraint());\n    this.myConstraints.add(new TagetReferencePropertyValueExpression_fullName_PropertyConstraint());\n    this.myConstraints.add(new StringLiteral_name_PropertyConstraint());\n    this.myConstraints.add(new MultiLineString_name_PropertyConstraint());\n    this.myConstraints.add(new TargetReference_targetDeclaration_ReferentConstraint());\n    this.myConstraints.add(new GenericCall_declaration_ReferentConstraint());\n    this.myConstraints.add(new PathReference_call_ReferentConstraint());\n    this.myConstraints.add(new Reference_declaration_ReferentConstraint());\n    this.myConstraints.add(new GenericAttribute_attributeDeclaration_ReferentConstraint());\n    this.myConstraints.add(new PropertyReference_propertyDeclaration_ReferentConstraint());\n    this.myConstraints.add(new GenericCall_DefaultSearchScope());\n  }","commit_id":"8a5da8d7e87150416e921b4419051101b18fdd29","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Iterable sourceNodesQuery_1230222691427(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    final Set<String> existing = SetSequence.<String>fromArray();\n    for(SNode importProject : ListSequence.fromList(SNodeOperations.getDescendants(_context.getNode(), \"jetbrains.mps.buildlanguage.structure.ImportProject\", false))) {\n      SetSequence.fromSet(existing).addElement(SPropertyOperations.getString(SLinkOperations.getTarget(importProject, \"project\", false), \"name\"));\n    }\n    return ListSequence.fromList(SNodeOperations.getDescendants(_context.getNode(), \"jetbrains.mps.buildlanguage.structure.ITargetReference\", false)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return !(SetSequence.fromSet(existing).contains(ITargetReference_Behavior.call_getProjectFileName_1230222765831(it)));\n      }\n\n    }).distinct();\n  }","id":79538,"modified_method":"public static Iterable sourceNodesQuery_1230222691427(final IOperationContext operationContext, final SourceSubstituteMacroNodesContext _context) {\n    final Set<String> existing = SetSequence.<String>fromArray();\n    for(SNode importProject : ListSequence.fromList(SNodeOperations.getDescendants(_context.getNode(), \"jetbrains.mps.buildlanguage.structure.ImportProject\", false))) {\n      SetSequence.fromSet(existing).addElement(SPropertyOperations.getString(SLinkOperations.getTarget(importProject, \"project\", false), \"name\"));\n    }\n    Iterable<SNode> projects = ListSequence.fromList(SNodeOperations.getDescendants(_context.getNode(), \"jetbrains.mps.buildlanguage.structure.ITargetReference\", false)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        boolean b = !(SetSequence.fromSet(existing).contains(ITargetReference_Behavior.call_getProjectFileName_1230222765831(it)));\n        SetSequence.fromSet(existing).addElement(ITargetReference_Behavior.call_getProjectFileName_1230222765831(it));\n        return b;\n      }\n\n    });\n    return projects;\n  }","commit_id":"8a5da8d7e87150416e921b4419051101b18fdd29","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void run()\n    {\n        Thread.currentThread().setName(\"Iv2ExecutionSite: \" + CoreUtils.hsIdToString(m_siteId));\n        if (m_coreBindIds != null) {\n            PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindIds);\n        }\n        initialize(m_startupConfig.m_serializedCatalog, m_startupConfig.m_timestamp);\n        m_startupConfig = null; // release the serializedCatalog bytes.\n        //Maintain a minimum ratio of task log (unrestricted) to live (restricted) transactions\n        final MinimumRatioMaintainer mrm = new MinimumRatioMaintainer(m_taskLogReplayRatio);\n        try {\n            while (m_shouldContinue) {\n                if (m_rejoinState == kStateRunning) {\n                    // Normal operation blocks the site thread on the sitetasker queue.\n                    SiteTasker task = m_scheduler.take();\n                    if (task instanceof TransactionTask) {\n                        m_currentTxnId = ((TransactionTask)task).getTxnId();\n                        m_lastTxnTime = EstTime.currentTimeMillis();\n                    }\n                    task.run(getSiteProcedureConnection());\n                }\n                else {\n                    // Rejoin operation poll and try to do some catchup work. Tasks\n                    // are responsible for logging any rejoin work they might have.\n                    SiteTasker task = null;\n                    boolean didWork = false;\n                    while ((task = m_scheduler.poll()) != null) {\n                        didWork = true;\n                        //If the task log is empty, free to execute the task\n                        //If the mrm says we can do a restricted task, go do it\n                        //Otherwise spin doing unrestricted tasks until we can bail out\n                        //and do the restricted task that was polled\n                        while (!m_rejoinTaskLog.isEmpty() && !mrm.canDoRestricted()) {\n                            replayFromTaskLog(mrm);\n                        }\n                        mrm.didRestricted();\n                        task.runForRejoin(getSiteProcedureConnection(), m_rejoinTaskLog);\n                    }\n                    //If there are no tasks, do task log work\n                    didWork |= replayFromTaskLog(mrm);\n                    if (!didWork) Thread.yield();\n                }\n            }\n        }\n        catch (OutOfMemoryError e)\n        {\n            // Even though OOM should be caught by the Throwable section below,\n            // it sadly needs to be handled seperately. The goal here is to make\n            // sure VoltDB crashes.\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" ran out of Java memory. \" + \"This node will shut down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, e);\n        }\n        catch (Throwable t)\n        {\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" encountered an \" + \"unexpected error and will die, taking this VoltDB node down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, t);\n        }\n        shutdown();\n    }","id":79539,"modified_method":"@Override\n    public void run()\n    {\n        Thread.currentThread().setName(\"Iv2ExecutionSite: \" + CoreUtils.hsIdToString(m_siteId));\n        if (m_coreBindIds != null) {\n            PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindIds);\n        }\n        initialize(m_startupConfig.m_serializedCatalog, m_startupConfig.m_timestamp);\n        m_startupConfig = null; // release the serializedCatalog bytes.\n        //Maintain a minimum ratio of task log (unrestricted) to live (restricted) transactions\n        final MinimumRatioMaintainer mrm = new MinimumRatioMaintainer(m_taskLogReplayRatio);\n        try {\n            while (m_shouldContinue) {\n                if (m_rejoinState == kStateRunning) {\n                    // Normal operation blocks the site thread on the sitetasker queue.\n                    SiteTasker task = m_scheduler.take();\n                    if (task instanceof TransactionTask) {\n                        m_currentTxnId = ((TransactionTask)task).getTxnId();\n                        m_lastTxnTime = EstTime.currentTimeMillis();\n                    }\n                    task.run(getSiteProcedureConnection());\n                } else if (m_rejoinState == kStateReplayingRejoin) {\n                    // Rejoin operation poll and try to do some catchup work. Tasks\n                    // are responsible for logging any rejoin work they might have.\n                    SiteTasker task = m_scheduler.poll();\n                    boolean didWork = false;\n                    if (task != null) {\n                        didWork = true;\n                        //If the task log is empty, free to execute the task\n                        //If the mrm says we can do a restricted task, go do it\n                        //Otherwise spin doing unrestricted tasks until we can bail out\n                        //and do the restricted task that was polled\n                        while (!m_rejoinTaskLog.isEmpty() && !mrm.canDoRestricted()) {\n                            replayFromTaskLog(mrm);\n                        }\n                        mrm.didRestricted();\n                        if (m_rejoinState == kStateRunning) {\n                            task.run(getSiteProcedureConnection());\n                        } else {\n                            task.runForRejoin(getSiteProcedureConnection(), m_rejoinTaskLog);\n                        }\n                    } else {\n                        //If there are no tasks, do task log work\n                        didWork |= replayFromTaskLog(mrm);\n                    }\n                    if (!didWork) Thread.yield();\n                } else {\n                    SiteTasker task = m_scheduler.take();\n                    task.runForRejoin(getSiteProcedureConnection(), m_rejoinTaskLog);\n                }\n            }\n        }\n        catch (OutOfMemoryError e)\n        {\n            // Even though OOM should be caught by the Throwable section below,\n            // it sadly needs to be handled seperately. The goal here is to make\n            // sure VoltDB crashes.\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" ran out of Java memory. \" + \"This node will shut down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, e);\n        }\n        catch (Throwable t)\n        {\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" encountered an \" + \"unexpected error and will die, taking this VoltDB node down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, t);\n        }\n        shutdown();\n    }","commit_id":"8bc0a4e6fffed986d0e8b4c00ac9f6f4c39848ac","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Thread specific initialization */\n    void initialize(String serializedCatalog, long txnId)\n    {\n        if (m_backend == BackendTarget.NONE) {\n            m_hsql = null;\n            m_ee = new MockExecutionEngine();\n        }\n        else if (m_backend == BackendTarget.HSQLDB_BACKEND) {\n            m_hsql = HsqlBackend.initializeHSQLBackend(m_siteId,\n                                                       m_context);\n            m_ee = new MockExecutionEngine();\n        }\n        else {\n            m_hsql = null;\n            m_ee = initializeEE(serializedCatalog, txnId);\n        }\n\n        m_snapshotter = new SnapshotSiteProcessor(new Runnable() {\n            @Override\n            public void run() {\n                m_scheduler.offer(new SnapshotTask());\n            }\n        },\n        m_snapshotPriority,\n        new SnapshotSiteProcessor.IdlePredicate() {\n\n            @Override\n            public boolean idle(long now) {\n                return (now - 5) > m_lastTxnTime;\n            }\n        });\n    }","id":79540,"modified_method":"/** Thread specific initialization */\n    void initialize(String serializedCatalog, long txnId)\n    {\n        if (m_backend == BackendTarget.NONE) {\n            m_hsql = null;\n            m_ee = new MockExecutionEngine();\n        }\n        else if (m_backend == BackendTarget.HSQLDB_BACKEND) {\n            m_hsql = HsqlBackend.initializeHSQLBackend(m_siteId,\n                                                       m_context);\n            m_ee = new MockExecutionEngine();\n        }\n        else {\n            m_hsql = null;\n            m_ee = initializeEE(serializedCatalog, txnId);\n        }\n\n        m_snapshotter = new SnapshotSiteProcessor(new Runnable() {\n            @Override\n            public void run() {\n                m_scheduler.offer(new SnapshotTask());\n            }\n        },\n        m_snapshotPriority,\n        new SnapshotSiteProcessor.IdlePredicate() {\n\n            @Override\n            public boolean idle(long now) {\n                return (now - 5) > m_lastTxnTime;\n            }\n        });\n\n        if (m_rejoinState == kStateRejoining) {\n            initializeForLiveRejoin();\n        }\n    }","commit_id":"22b49eb69c96356ad207e8ca2daca38c81730c1e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void runLoop() throws InterruptedException\n    {\n        SiteTasker task = m_scheduler.poll();\n        if (task != null) {\n            if (task instanceof TransactionTask) {\n                m_currentTxnId = ((TransactionTask)task).getTxnId();\n                m_lastTxnTime = EstTime.currentTimeMillis();\n            }\n            if (m_isRejoining) {\n                task.runForRejoin(getSiteProcedureConnection());\n            }\n            else {\n                task.run(getSiteProcedureConnection());\n            }\n        }\n    }","id":79541,"modified_method":"void runLoop() throws InterruptedException, IOException\n    {\n        SiteTasker task = m_scheduler.poll();\n\n        // Normal runtime operation...\n        if (m_rejoinState == kStateRunning) {\n            if (task != null) {\n                if (task instanceof TransactionTask) {\n                    m_currentTxnId = ((TransactionTask)task).getTxnId();\n                    m_lastTxnTime = EstTime.currentTimeMillis();\n                }\n                task.run(getSiteProcedureConnection());\n            }\n            return;\n        }\n\n        // During live rejoin, the site takes responsibility for\n        // the deferred transaction info base message.\n        // (Cleaner to pass m_rejoinTaskLog to runForRejoin()?)\n        if (task != null) {\n            if (task instanceof TransactionTask) {\n                TransactionInfoBaseMessage tibm = ((TransactionTask)task).m_txn.getNotice();\n                m_rejoinTaskLog.logTask(tibm);\n            }\n            task.runForRejoin(getSiteProcedureConnection());\n        }\n\n        // During the rejoin-catchup period, run some transactions\n        // from the task back log.\n        if (m_rejoinState == kStateReplayingRejoin) {\n            replayFromTaskLog();\n        }\n    }","commit_id":"22b49eb69c96356ad207e8ca2daca38c81730c1e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void setRejoinComplete() {\n        m_isRejoining = false;\n    }","id":79542,"modified_method":"@Override\n    public void setRejoinComplete() {\n        // transition from kStateRejoining to live rejoin replay.\n        // pass through this transition in all cases; if not doing\n        // live rejoin, will transfer to kStateRunning as usual\n        // as the rejoin task log will be empty.\n        assert(m_rejoinState == kStateRejoining);\n        m_rejoinState = kStateReplayingRejoin;\n    }","commit_id":"22b49eb69c96356ad207e8ca2daca38c81730c1e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Create a new execution site and the corresponding EE */\n    public Site(\n            SiteTaskerQueue scheduler,\n            long siteId,\n            BackendTarget backend,\n            CatalogContext context,\n            String serializedCatalog,\n            long txnId,\n            int partitionId,\n            int numPartitions,\n            boolean createForRejoin,\n            int snapshotPriority,\n            InitiatorMailbox initiatorMailbox)\n    {\n        m_siteId = siteId;\n        m_context = context;\n        m_partitionId = partitionId;\n        m_numberOfPartitions = numPartitions;\n        m_scheduler = scheduler;\n        m_backend = backend;\n        m_isRejoining = createForRejoin;\n        m_snapshotPriority = snapshotPriority;\n        // need this later when running in the final thread.\n        m_startupConfig = new StartupConfig(serializedCatalog, txnId);\n        m_lastCommittedTxnId = TxnEgo.makeZero(partitionId).getTxnId();\n        m_lastCommittedSpHandle = TxnEgo.makeZero(partitionId).getTxnId();\n        m_currentTxnId = Long.MIN_VALUE;\n        m_initiatorMailbox = initiatorMailbox;\n    }","id":79543,"modified_method":"/** Create a new execution site and the corresponding EE */\n    public Site(\n            SiteTaskerQueue scheduler,\n            long siteId,\n            BackendTarget backend,\n            CatalogContext context,\n            String serializedCatalog,\n            long txnId,\n            int partitionId,\n            int numPartitions,\n            boolean createForRejoin,\n            int snapshotPriority,\n            InitiatorMailbox initiatorMailbox)\n    {\n        m_siteId = siteId;\n        m_context = context;\n        m_partitionId = partitionId;\n        m_numberOfPartitions = numPartitions;\n        m_scheduler = scheduler;\n        m_backend = backend;\n        m_rejoinState = createForRejoin ? kStateRejoining : kStateRunning;\n        m_snapshotPriority = snapshotPriority;\n        // need this later when running in the final thread.\n        m_startupConfig = new StartupConfig(serializedCatalog, txnId);\n        m_lastCommittedTxnId = TxnEgo.makeZero(partitionId).getTxnId();\n        m_lastCommittedSpHandle = TxnEgo.makeZero(partitionId).getTxnId();\n        m_currentTxnId = Long.MIN_VALUE;\n        m_initiatorMailbox = initiatorMailbox;\n    }","commit_id":"22b49eb69c96356ad207e8ca2daca38c81730c1e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void run()\n    {\n        Thread.currentThread().setName(\"Iv2ExecutionSite: \" + CoreUtils.hsIdToString(m_siteId));\n        if (m_coreBindIds != null) {\n            PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindIds);\n        }\n        initialize(m_startupConfig.m_serializedCatalog, m_startupConfig.m_timestamp);\n        m_startupConfig = null; // release the serializedCatalog bytes.\n\n        try {\n            while (m_shouldContinue) {\n                if (m_rejoinState == kStateRunning) {\n                    // Normal operation blocks the site thread on the sitetasker queue.\n                    SiteTasker task = m_scheduler.take();\n                    if (task instanceof TransactionTask) {\n                        m_currentTxnId = ((TransactionTask)task).getTxnId();\n                        m_lastTxnTime = EstTime.currentTimeMillis();\n                    }\n                    task.run(getSiteProcedureConnection());\n                }\n                else {\n                    // Rejoin operation poll and try to do some catchup work. Tasks\n                    // are responsible for logging any rejoin work they might have.\n                    SiteTasker task = m_scheduler.poll();\n                    if (task != null) {\n                        task.runForRejoin(getSiteProcedureConnection(), m_rejoinTaskLog);\n                    }\n                    replayFromTaskLog();\n                }\n            }\n        }\n        catch (OutOfMemoryError e)\n        {\n            // Even though OOM should be caught by the Throwable section below,\n            // it sadly needs to be handled seperately. The goal here is to make\n            // sure VoltDB crashes.\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" ran out of Java memory. \" + \"This node will shut down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, e);\n        }\n        catch (Throwable t)\n        {\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" encountered an \" + \"unexpected error and will die, taking this VoltDB node down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, t);\n        }\n        shutdown();\n    }","id":79544,"modified_method":"@Override\n    public void run()\n    {\n        Thread.currentThread().setName(\"Iv2ExecutionSite: \" + CoreUtils.hsIdToString(m_siteId));\n        if (m_coreBindIds != null) {\n            PosixJNAAffinity.INSTANCE.setAffinity(m_coreBindIds);\n        }\n        initialize(m_startupConfig.m_serializedCatalog, m_startupConfig.m_timestamp);\n        m_startupConfig = null; // release the serializedCatalog bytes.\n        //Maintain a minimum ratio of task log (unrestricted) to live (restricted) transactions\n        final MinimumRatioMaintainer mrm = new MinimumRatioMaintainer(m_taskLogReplayRatio);\n        try {\n            while (m_shouldContinue) {\n                if (m_rejoinState == kStateRunning) {\n                    // Normal operation blocks the site thread on the sitetasker queue.\n                    SiteTasker task = m_scheduler.take();\n                    if (task instanceof TransactionTask) {\n                        m_currentTxnId = ((TransactionTask)task).getTxnId();\n                        m_lastTxnTime = EstTime.currentTimeMillis();\n                    }\n                    task.run(getSiteProcedureConnection());\n                }\n                else {\n                    // Rejoin operation poll and try to do some catchup work. Tasks\n                    // are responsible for logging any rejoin work they might have.\n                    SiteTasker task = null;\n                    boolean didWork = false;\n                    while ((task = m_scheduler.poll()) != null) {\n                        didWork = true;\n                        //If the task log is empty, free to execute the task\n                        //If the mrm says we can do a restricted task, go do it\n                        //Otherwise spin doing unrestricted tasks until we can bail out\n                        //and do the restricted task that was polled\n                        if (!m_rejoinTaskLog.isEmpty() && !mrm.canDoRestricted()) {\n                            while (!mrm.canDoRestricted()) {\n                                replayFromTaskLog(mrm);\n                            }\n                        }\n                        mrm.didRestricted();\n                        task.runForRejoin(getSiteProcedureConnection(), m_rejoinTaskLog);\n                    }\n                    //If there are no tasks, do task log work\n                    didWork |= replayFromTaskLog(mrm);\n                    if (!didWork) Thread.yield();\n                }\n            }\n        }\n        catch (OutOfMemoryError e)\n        {\n            // Even though OOM should be caught by the Throwable section below,\n            // it sadly needs to be handled seperately. The goal here is to make\n            // sure VoltDB crashes.\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" ran out of Java memory. \" + \"This node will shut down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, e);\n        }\n        catch (Throwable t)\n        {\n            String errmsg = \"Site: \" + org.voltcore.utils.CoreUtils.hsIdToString(m_siteId) +\n                \" encountered an \" + \"unexpected error and will die, taking this VoltDB node down.\";\n            VoltDB.crashLocalVoltDB(errmsg, true, t);\n        }\n        shutdown();\n    }","commit_id":"ee7cb1489f2775ae0b38b7ac8798764e668e5175","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void replayFromTaskLog() throws IOException\n    {\n        // not yet time to catch-up.\n        if (m_rejoinState != kStateReplayingRejoin) {\n            return;\n        }\n\n        // replay 10:1 in favor of replay\n        for (int i=0; i < 10; ++i) {\n            if (m_rejoinTaskLog.isEmpty()) {\n                break;\n            }\n\n            TransactionInfoBaseMessage tibm = m_rejoinTaskLog.getNextMessage();\n            if (tibm == null) {\n                break;\n            }\n\n            if (tibm instanceof Iv2InitiateTaskMessage) {\n                Iv2InitiateTaskMessage m = (Iv2InitiateTaskMessage)tibm;\n                SpProcedureTask t = new SpProcedureTask(\n                        m_initiatorMailbox, m.getStoredProcedureName(),\n                        null, m, m_drGateway);\n                if (!filter(tibm)) {\n                    m_currentTxnId = t.getTxnId();\n                    m_lastTxnTime = EstTime.currentTimeMillis();\n                    t.runFromTaskLog(this);\n                }\n            }\n            else if (tibm instanceof FragmentTaskMessage) {\n                FragmentTaskMessage m = (FragmentTaskMessage)tibm;\n                if (global_replay_mpTxn == null) {\n                    global_replay_mpTxn = new ParticipantTransactionState(m.getTxnId(), m);\n                }\n                else if (global_replay_mpTxn.txnId != m.getTxnId()) {\n                    VoltDB.crashLocalVoltDB(\"Started a MP transaction during replay before completing \" +\n                            \" open transaction.\", false, null);\n                }\n\n                TransactionTask t;\n                if (m.isSysProcTask()) {\n                    t = new SysprocFragmentTask(m_initiatorMailbox, m, global_replay_mpTxn);\n                } else {\n                    t = new FragmentTask(m_initiatorMailbox, m, global_replay_mpTxn);\n                }\n\n                if (!filter(tibm)) {\n                    m_currentTxnId = t.getTxnId();\n                    m_lastTxnTime = EstTime.currentTimeMillis();\n                    t.runFromTaskLog(this);\n                }\n            }\n            else if (tibm instanceof CompleteTransactionMessage) {\n                // Needs improvement: completes for sysprocs aren't filterable as sysprocs.\n                // Only complete transactions that are open...\n                if (global_replay_mpTxn != null) {\n                    CompleteTransactionMessage m = (CompleteTransactionMessage)tibm;\n                    CompleteTransactionTask t = new CompleteTransactionTask(global_replay_mpTxn,\n                            null, m, m_drGateway);\n                    if (!m.isRestart()) {\n                        global_replay_mpTxn = null;\n                    }\n                    if (!filter(tibm)) {\n                        t.runFromTaskLog(this);\n                    }\n                }\n            }\n            else {\n                VoltDB.crashLocalVoltDB(\"Can not replay message type \" +\n                        tibm + \" during live rejoin. Unexpected error.\",\n                        false, null);\n            }\n        }\n\n        // exit replay being careful not to exit in the middle of a multi-partititon\n        // transaction. The SPScheduler doesn't have a valid transaction state for a\n        // partially replayed MP txn and in case of rollback the scheduler's undo token\n        // is wrong. Run MP txns fully kStateRejoining or fully kStateRunning.\n        if (m_rejoinTaskLog.isEmpty() && global_replay_mpTxn == null) {\n            setReplayRejoinComplete();\n        }\n    }","id":79545,"modified_method":"boolean replayFromTaskLog(MinimumRatioMaintainer mrm) throws IOException\n    {\n        // not yet time to catch-up.\n        if (m_rejoinState != kStateReplayingRejoin) {\n            return false;\n        }\n\n        TransactionInfoBaseMessage tibm = m_rejoinTaskLog.getNextMessage();\n        if (tibm != null) {\n            mrm.didUnrestricted();\n            if (tibm instanceof Iv2InitiateTaskMessage) {\n                Iv2InitiateTaskMessage m = (Iv2InitiateTaskMessage)tibm;\n                SpProcedureTask t = new SpProcedureTask(\n                        m_initiatorMailbox, m.getStoredProcedureName(),\n                        null, m, m_drGateway);\n                if (!filter(tibm)) {\n                    m_currentTxnId = t.getTxnId();\n                    m_lastTxnTime = EstTime.currentTimeMillis();\n                    t.runFromTaskLog(this);\n                }\n            }\n            else if (tibm instanceof FragmentTaskMessage) {\n                FragmentTaskMessage m = (FragmentTaskMessage)tibm;\n                if (global_replay_mpTxn == null) {\n                    global_replay_mpTxn = new ParticipantTransactionState(m.getTxnId(), m);\n                }\n                else if (global_replay_mpTxn.txnId != m.getTxnId()) {\n                    VoltDB.crashLocalVoltDB(\"Started a MP transaction during replay before completing \" +\n                            \" open transaction.\", false, null);\n                }\n\n                TransactionTask t;\n                if (m.isSysProcTask()) {\n                    t = new SysprocFragmentTask(m_initiatorMailbox, m, global_replay_mpTxn);\n                } else {\n                    t = new FragmentTask(m_initiatorMailbox, m, global_replay_mpTxn);\n                }\n\n                if (!filter(tibm)) {\n                    m_currentTxnId = t.getTxnId();\n                    m_lastTxnTime = EstTime.currentTimeMillis();\n                    t.runFromTaskLog(this);\n                }\n            }\n            else if (tibm instanceof CompleteTransactionMessage) {\n                // Needs improvement: completes for sysprocs aren't filterable as sysprocs.\n                // Only complete transactions that are open...\n                if (global_replay_mpTxn != null) {\n                    CompleteTransactionMessage m = (CompleteTransactionMessage)tibm;\n                    CompleteTransactionTask t = new CompleteTransactionTask(global_replay_mpTxn,\n                            null, m, m_drGateway);\n                    if (!m.isRestart()) {\n                        global_replay_mpTxn = null;\n                    }\n                    if (!filter(tibm)) {\n                        t.runFromTaskLog(this);\n                    }\n                }\n            }\n            else {\n                VoltDB.crashLocalVoltDB(\"Can not replay message type \" +\n                        tibm + \" during live rejoin. Unexpected error.\",\n                        false, null);\n            }\n        }\n\n        // exit replay being careful not to exit in the middle of a multi-partititon\n        // transaction. The SPScheduler doesn't have a valid transaction state for a\n        // partially replayed MP txn and in case of rollback the scheduler's undo token\n        // is wrong. Run MP txns fully kStateRejoining or fully kStateRunning.\n        if (m_rejoinTaskLog.isEmpty() && global_replay_mpTxn == null) {\n            setReplayRejoinComplete();\n        }\n        return tibm != null;\n    }","commit_id":"ee7cb1489f2775ae0b38b7ac8798764e668e5175","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private HttpUriRequest buildRequest() {\n\n        if (HttpGetWithEntity.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpGetWithEntity(buildUri()));\n        }\n\n        if (HttpHead.METHOD_NAME.equalsIgnoreCase(method)) {\n            checkBodyNotSupported();\n            return new HttpHead(buildUri());\n        }\n\n        if (HttpDeleteWithEntity.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpDeleteWithEntity(buildUri()));\n        }\n\n        if (HttpPut.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpPut(buildUri()));\n        }\n\n        if (HttpPost.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpPost(buildUri()));\n        }\n\n        throw new UnsupportedOperationException(\"method [\" + method + \"] not supported\");\n    }","id":79546,"modified_method":"private HttpUriRequest buildRequest() {\n\n        if (HttpGetWithEntity.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpGetWithEntity(buildUri()));\n        }\n\n        if (HttpHead.METHOD_NAME.equalsIgnoreCase(method)) {\n            checkBodyNotSupported();\n            return new HttpHead(buildUri());\n        }\n\n        if (HttpOptions.METHOD_NAME.equalsIgnoreCase(method)) {\n            checkBodyNotSupported();\n            return new HttpOptions(buildUri());\n        }\n\n        if (HttpDeleteWithEntity.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpDeleteWithEntity(buildUri()));\n        }\n\n        if (HttpPut.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpPut(buildUri()));\n        }\n\n        if (HttpPost.METHOD_NAME.equalsIgnoreCase(method)) {\n            return addOptionalBody(new HttpPost(buildUri()));\n        }\n\n        throw new UnsupportedOperationException(\"method [\" + method + \"] not supported\");\n    }","commit_id":"a1e335b1e9d53ca1f970219f6df1b532d9509d3b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        HttpRequest request = (HttpRequest) e.getMessage();\n        // the netty HTTP handling always copy over the buffer to its own buffer, either in NioWorker internally\n        // when reading, or using a cumalation buffer\n        NettyHttpRequest httpRequest = new NettyHttpRequest(request, e.getChannel());\n        serverTransport.dispatchRequest(httpRequest, new NettyHttpChannel(serverTransport, e.getChannel(), httpRequest));\n        super.messageReceived(ctx, e);\n    }","id":79547,"modified_method":"@Override\n    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {\n        HttpRequest request = (HttpRequest) e.getMessage();\n        // the netty HTTP handling always copy over the buffer to its own buffer, either in NioWorker internally\n        // when reading, or using a cumalation buffer\n        NettyHttpRequest httpRequest = new NettyHttpRequest(request, e.getChannel());\n        serverTransport.dispatchRequest(httpRequest, new NettyHttpChannel(serverTransport, e.getChannel(), httpRequest, corsPattern));\n        super.messageReceived(ctx, e);\n    }","commit_id":"a1e335b1e9d53ca1f970219f6df1b532d9509d3b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public HttpRequestHandler(NettyHttpServerTransport serverTransport) {\n        this.serverTransport = serverTransport;\n    }","id":79548,"modified_method":"public HttpRequestHandler(NettyHttpServerTransport serverTransport) {\n        this.serverTransport = serverTransport;\n        this.corsPattern = RestUtils.getCorsSettingRegex(serverTransport.settings());\n    }","commit_id":"a1e335b1e9d53ca1f970219f6df1b532d9509d3b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public NettyHttpChannel(NettyHttpServerTransport transport, Channel channel, NettyHttpRequest request) {\n        super(request);\n        this.transport = transport;\n        this.channel = channel;\n        this.nettyRequest = request.request();\n    }","id":79549,"modified_method":"public NettyHttpChannel(NettyHttpServerTransport transport, Channel channel, NettyHttpRequest request, Pattern corsPattern) {\n        super(request);\n        this.transport = transport;\n        this.channel = channel;\n        this.nettyRequest = request.request();\n        this.corsPattern = corsPattern;\n    }","commit_id":"a1e335b1e9d53ca1f970219f6df1b532d9509d3b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void sendResponse(RestResponse response) {\n        // Decide whether to close the connection or not.\n        boolean http10 = nettyRequest.getProtocolVersion().equals(HttpVersion.HTTP_1_0);\n        boolean close =\n                HttpHeaders.Values.CLOSE.equalsIgnoreCase(nettyRequest.headers().get(HttpHeaders.Names.CONNECTION)) ||\n                        (http10 && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(nettyRequest.headers().get(HttpHeaders.Names.CONNECTION)));\n\n        // Build the response object.\n        HttpResponseStatus status = getStatus(response.status());\n        org.jboss.netty.handler.codec.http.HttpResponse resp;\n        if (http10) {\n            resp = new DefaultHttpResponse(HttpVersion.HTTP_1_0, status);\n            if (!close) {\n                resp.headers().add(HttpHeaders.Names.CONNECTION, \"Keep-Alive\");\n            }\n        } else {\n            resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status);\n        }\n        if (RestUtils.isBrowser(nettyRequest.headers().get(HttpHeaders.Names.USER_AGENT))) {\n            if (transport.settings().getAsBoolean(\"http.cors.enabled\", true)) {\n                // Add support for cross-origin Ajax requests (CORS)\n                resp.headers().add(\"Access-Control-Allow-Origin\", transport.settings().get(\"http.cors.allow-origin\", \"*\"));\n                if (nettyRequest.getMethod() == HttpMethod.OPTIONS) {\n                    // Allow Ajax requests based on the CORS \"preflight\" request\n                    resp.headers().add(\"Access-Control-Max-Age\", transport.settings().getAsInt(\"http.cors.max-age\", 1728000));\n                    resp.headers().add(\"Access-Control-Allow-Methods\", transport.settings().get(\"http.cors.allow-methods\", \"OPTIONS, HEAD, GET, POST, PUT, DELETE\"));\n                    resp.headers().add(\"Access-Control-Allow-Headers\", transport.settings().get(\"http.cors.allow-headers\", \"X-Requested-With, Content-Type, Content-Length\"));\n                }\n            }\n        }\n\n        String opaque = nettyRequest.headers().get(\"X-Opaque-Id\");\n        if (opaque != null) {\n            resp.headers().add(\"X-Opaque-Id\", opaque);\n        }\n\n        // Add all custom headers\n        Map<String, List<String>> customHeaders = response.getHeaders();\n        if (customHeaders != null) {\n            for (Map.Entry<String, List<String>> headerEntry : customHeaders.entrySet()) {\n                for (String headerValue : headerEntry.getValue()) {\n                    resp.headers().add(headerEntry.getKey(), headerValue);\n                }\n            }\n        }\n\n        BytesReference content = response.content();\n        ChannelBuffer buffer;\n        boolean addedReleaseListener = false;\n        try {\n            if (response.contentThreadSafe()) {\n                buffer = content.toChannelBuffer();\n            } else {\n                buffer = content.copyBytesArray().toChannelBuffer();\n            }\n            // handle JSONP\n            String callback = request.param(\"callback\");\n            if (callback != null) {\n                final BytesRef callbackBytes = new BytesRef(callback.length() * 4 + 1);\n                UnicodeUtil.UTF16toUTF8(callback, 0, callback.length(), callbackBytes);\n                callbackBytes.bytes[callbackBytes.length] = '(';\n                callbackBytes.length++;\n                buffer = ChannelBuffers.wrappedBuffer(\n                        ChannelBuffers.wrappedBuffer(callbackBytes.bytes, callbackBytes.offset, callbackBytes.length),\n                        buffer,\n                        ChannelBuffers.wrappedBuffer(END_JSONP)\n                );\n                // Add content-type header of \"application/javascript\"\n                resp.headers().add(HttpHeaders.Names.CONTENT_TYPE, \"application/javascript\");\n            }\n            resp.setContent(buffer);\n\n            // If our response doesn't specify a content-type header, set one\n            if (!resp.headers().contains(HttpHeaders.Names.CONTENT_TYPE)) {\n                resp.headers().add(HttpHeaders.Names.CONTENT_TYPE, response.contentType());\n            }\n\n            // If our response has no content-length, calculate and set one\n            if (!resp.headers().contains(HttpHeaders.Names.CONTENT_LENGTH)) {\n                resp.headers().add(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buffer.readableBytes()));\n            }\n\n            if (transport.resetCookies) {\n                String cookieString = nettyRequest.headers().get(HttpHeaders.Names.COOKIE);\n                if (cookieString != null) {\n                    CookieDecoder cookieDecoder = new CookieDecoder();\n                    Set<Cookie> cookies = cookieDecoder.decode(cookieString);\n                    if (!cookies.isEmpty()) {\n                        // Reset the cookies if necessary.\n                        CookieEncoder cookieEncoder = new CookieEncoder(true);\n                        for (Cookie cookie : cookies) {\n                            cookieEncoder.addCookie(cookie);\n                        }\n                        resp.headers().add(HttpHeaders.Names.SET_COOKIE, cookieEncoder.encode());\n                    }\n                }\n            }\n\n            ChannelFuture future = channel.write(resp);\n            if (response.contentThreadSafe() && content instanceof Releasable) {\n                future.addListener(new ReleaseChannelFutureListener((Releasable) content));\n                addedReleaseListener = true;\n            }\n            if (close) {\n                future.addListener(ChannelFutureListener.CLOSE);\n            }\n        } finally {\n            if (!addedReleaseListener && content instanceof Releasable) {\n                ((Releasable) content).close();\n            }\n        }\n    }","id":79550,"modified_method":"@Override\n    public void sendResponse(RestResponse response) {\n        // Decide whether to close the connection or not.\n        boolean http10 = nettyRequest.getProtocolVersion().equals(HttpVersion.HTTP_1_0);\n        boolean close =\n                HttpHeaders.Values.CLOSE.equalsIgnoreCase(nettyRequest.headers().get(HttpHeaders.Names.CONNECTION)) ||\n                        (http10 && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(nettyRequest.headers().get(HttpHeaders.Names.CONNECTION)));\n\n        // Build the response object.\n        HttpResponseStatus status = getStatus(response.status());\n        org.jboss.netty.handler.codec.http.HttpResponse resp;\n        if (http10) {\n            resp = new DefaultHttpResponse(HttpVersion.HTTP_1_0, status);\n            if (!close) {\n                resp.headers().add(HttpHeaders.Names.CONNECTION, \"Keep-Alive\");\n            }\n        } else {\n            resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status);\n        }\n        if (RestUtils.isBrowser(nettyRequest.headers().get(USER_AGENT))) {\n            if (transport.settings().getAsBoolean(\"http.cors.enabled\", true)) {\n                String originHeader = request.header(ORIGIN);\n                if (!Strings.isNullOrEmpty(originHeader)) {\n                    if (corsPattern == null) {\n                        resp.headers().add(ACCESS_CONTROL_ALLOW_ORIGIN, transport.settings().get(\"http.cors.allow-origin\", \"*\"));\n                    } else {\n                        resp.headers().add(ACCESS_CONTROL_ALLOW_ORIGIN, corsPattern.matcher(originHeader).matches() ? originHeader : \"null\");\n                    }\n                }\n                if (nettyRequest.getMethod() == HttpMethod.OPTIONS) {\n                    // Allow Ajax requests based on the CORS \"preflight\" request\n                    resp.headers().add(ACCESS_CONTROL_MAX_AGE, transport.settings().getAsInt(\"http.cors.max-age\", 1728000));\n                    resp.headers().add(ACCESS_CONTROL_ALLOW_METHODS, transport.settings().get(\"http.cors.allow-methods\", \"OPTIONS, HEAD, GET, POST, PUT, DELETE\"));\n                    resp.headers().add(ACCESS_CONTROL_ALLOW_HEADERS, transport.settings().get(\"http.cors.allow-headers\", \"X-Requested-With, Content-Type, Content-Length\"));\n                }\n            }\n        }\n\n        String opaque = nettyRequest.headers().get(\"X-Opaque-Id\");\n        if (opaque != null) {\n            resp.headers().add(\"X-Opaque-Id\", opaque);\n        }\n\n        // Add all custom headers\n        Map<String, List<String>> customHeaders = response.getHeaders();\n        if (customHeaders != null) {\n            for (Map.Entry<String, List<String>> headerEntry : customHeaders.entrySet()) {\n                for (String headerValue : headerEntry.getValue()) {\n                    resp.headers().add(headerEntry.getKey(), headerValue);\n                }\n            }\n        }\n\n        BytesReference content = response.content();\n        ChannelBuffer buffer;\n        boolean addedReleaseListener = false;\n        try {\n            if (response.contentThreadSafe()) {\n                buffer = content.toChannelBuffer();\n            } else {\n                buffer = content.copyBytesArray().toChannelBuffer();\n            }\n            // handle JSONP\n            String callback = request.param(\"callback\");\n            if (callback != null) {\n                final BytesRef callbackBytes = new BytesRef(callback.length() * 4 + 1);\n                UnicodeUtil.UTF16toUTF8(callback, 0, callback.length(), callbackBytes);\n                callbackBytes.bytes[callbackBytes.length] = '(';\n                callbackBytes.length++;\n                buffer = ChannelBuffers.wrappedBuffer(\n                        ChannelBuffers.wrappedBuffer(callbackBytes.bytes, callbackBytes.offset, callbackBytes.length),\n                        buffer,\n                        ChannelBuffers.wrappedBuffer(END_JSONP)\n                );\n                // Add content-type header of \"application/javascript\"\n                resp.headers().add(HttpHeaders.Names.CONTENT_TYPE, \"application/javascript\");\n            }\n            resp.setContent(buffer);\n\n            // If our response doesn't specify a content-type header, set one\n            if (!resp.headers().contains(HttpHeaders.Names.CONTENT_TYPE)) {\n                resp.headers().add(HttpHeaders.Names.CONTENT_TYPE, response.contentType());\n            }\n\n            // If our response has no content-length, calculate and set one\n            if (!resp.headers().contains(HttpHeaders.Names.CONTENT_LENGTH)) {\n                resp.headers().add(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buffer.readableBytes()));\n            }\n\n            if (transport.resetCookies) {\n                String cookieString = nettyRequest.headers().get(HttpHeaders.Names.COOKIE);\n                if (cookieString != null) {\n                    CookieDecoder cookieDecoder = new CookieDecoder();\n                    Set<Cookie> cookies = cookieDecoder.decode(cookieString);\n                    if (!cookies.isEmpty()) {\n                        // Reset the cookies if necessary.\n                        CookieEncoder cookieEncoder = new CookieEncoder(true);\n                        for (Cookie cookie : cookies) {\n                            cookieEncoder.addCookie(cookie);\n                        }\n                        resp.headers().add(HttpHeaders.Names.SET_COOKIE, cookieEncoder.encode());\n                    }\n                }\n            }\n\n            ChannelFuture future = channel.write(resp);\n            if (response.contentThreadSafe() && content instanceof Releasable) {\n                future.addListener(new ReleaseChannelFutureListener((Releasable) content));\n                addedReleaseListener = true;\n            }\n            if (close) {\n                future.addListener(ChannelFutureListener.CLOSE);\n            }\n        } finally {\n            if (!addedReleaseListener && content instanceof Releasable) {\n                ((Releasable) content).close();\n            }\n        }\n    }","commit_id":"a1e335b1e9d53ca1f970219f6df1b532d9509d3b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int b;\n        String hdr_name;\n        Header hdr;\n\n        // 1. dest_addr\n        dest_addr=Util.readAddress(in);\n\n        // 2. src_addr\n        src_addr=Util.readAddress(in);\n\n        // 3. buf\n        b=in.read();\n        if(b == 1) {\n            b=in.readInt();\n            buf=new byte[b];\n            in.read(buf, 0, b);\n            length=b;\n        }\n\n        // 4. headers\n        b=in.read();\n        if(b == 0)\n            return;\n        b=in.readInt();\n        headers();\n        for(int i=0; i < b; i++) {\n            hdr_name=in.readUTF();\n            hdr=readHeader(in);\n            headers.put(hdr_name, hdr);\n        }\n    }","id":79551,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int len, leading;\n        String hdr_name;\n        Header hdr;\n\n\n        // 1. read the leading byte first\n        leading=in.readByte();\n\n        // 1. dest_addr\n        if((leading & DEST_SET) == DEST_SET) {\n            if((leading & IPADDR_DEST) == IPADDR_DEST) {\n                dest_addr=new IpAddress();\n                dest_addr.readFrom(in);\n            }\n            else {\n                dest_addr=Util.readAddress(in);\n            }\n        }\n\n        // 2. src_addr\n        if((leading & SRC_SET) == SRC_SET) {\n            if((leading & IPADDR_SRC) == IPADDR_SRC) {\n                src_addr=new IpAddress();\n                src_addr.readFrom(in);\n            }\n            else {\n                src_addr=Util.readAddress(in);\n            }\n        }\n\n        // 3. buf\n        if((leading & BUF_SET) == BUF_SET) {\n            len=in.readInt();\n            buf=new byte[len];\n            in.read(buf, 0, len);\n            length=len;\n        }\n\n        // 4. headers\n        if((leading & HDRS_SET) == HDRS_SET) {\n            len=in.readInt();\n            headers();\n            for(int i=0; i < len; i++) {\n                hdr_name=in.readUTF();\n                hdr=readHeader(in);\n                headers.put(hdr_name, hdr);\n            }\n        }\n    }","commit_id":"3f7f731331bab0b6a2114fe5cbd33eab597cf0d8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers to the output stream\n     * @param outstream\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        Map.Entry        entry;\n\n        // 1. dest_addr\n        Util.writeAddress(dest_addr, out);\n\n        // 2. src_addr\n        Util.writeAddress(src_addr, out);\n\n        // 3. buf\n        if(buf == null)\n            out.write(0);\n        else {\n            out.write(1);\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 4. headers\n        if(headers == null || headers.size() == 0) {\n            out.write(0);\n            return;\n        }\n        out.write(1);\n        out.writeInt(headers.size());\n        for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            out.writeUTF((String)entry.getKey());\n            writeHeader((Header)entry.getValue(), out);\n        }\n    }","id":79552,"modified_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers to the output stream\n     * @param outstream\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        Map.Entry        entry;\n\n        byte leading=0;\n        if(dest_addr != null) {\n            leading+=DEST_SET;\n            if(dest_addr instanceof IpAddress)\n                leading+=IPADDR_DEST;\n        }\n        if(src_addr != null) {\n            leading+=SRC_SET;\n            if(src_addr instanceof IpAddress)\n                leading+=IPADDR_SRC;\n        }\n        if(buf != null)\n            leading+=BUF_SET;\n        if(headers != null && headers.size() > 0)\n            leading+=HDRS_SET;\n\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // 2. dest_addr\n        if(dest_addr != null) {\n            if(dest_addr instanceof IpAddress)\n                dest_addr.writeTo(out);\n            else\n                Util.writeAddress(dest_addr, out);\n        }\n\n        // 3. src_addr\n        if(src_addr != null) {\n            if(src_addr instanceof IpAddress)\n                src_addr.writeTo(out);\n            else\n                Util.writeAddress(src_addr, out);\n        }\n\n        // 4. buf\n        if(buf != null) {\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 5. headers\n        if(headers != null && headers.size() > 0) {\n            out.writeInt(headers.size());\n            for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                out.writeUTF((String)entry.getKey());\n                writeHeader((Header)entry.getValue(), out);\n            }\n        }\n    }","commit_id":"3f7f731331bab0b6a2114fe5cbd33eab597cf0d8","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers to the output stream\n     * @param outstream\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        Map.Entry        entry;\n\n        // 1. dest_addr\n        Util.writeAddress(dest_addr, out);\n\n        // 2. src_addr\n        Util.writeAddress(src_addr, out);\n\n        // 3. buf\n        if(buf == null)\n            out.write(0);\n        else {\n            out.write(1);\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 4. headers\n        if(headers == null || headers.size() == 0) {\n            out.write(0);\n            return;\n        }\n        out.write(1);\n        out.writeInt(headers.size());\n        for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            out.writeUTF((String)entry.getKey());\n            writeHeader((Header)entry.getValue(), out);\n        }\n    }","id":79553,"modified_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers to the output stream\n     * @param outstream\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        Map.Entry        entry;\n\n        byte leading=0;\n        if(dest_addr != null) {\n            leading+=DEST_SET;\n            if(dest_addr instanceof IpAddress)\n                leading+=IPADDR_DEST;\n        }\n        if(src_addr != null) {\n            leading+=SRC_SET;\n            if(src_addr instanceof IpAddress)\n                leading+=IPADDR_SRC;\n        }\n        if(buf != null)\n            leading+=BUF_SET;\n        if(headers != null && headers.size() > 0)\n            leading+=HDRS_SET;\n\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // 2. dest_addr\n        if(dest_addr != null) {\n            if(dest_addr instanceof IpAddress)\n                dest_addr.writeTo(out);\n            else\n                Util.writeAddress(dest_addr, out);\n        }\n\n        // 3. src_addr\n        if(src_addr != null) {\n            if(src_addr instanceof IpAddress)\n                src_addr.writeTo(out);\n            else\n                Util.writeAddress(src_addr, out);\n        }\n\n        // 4. buf\n        if(buf != null) {\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 5. headers\n        if(headers != null && headers.size() > 0) {\n            out.writeInt(headers.size());\n            for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                out.writeUTF((String)entry.getKey());\n                writeHeader((Header)entry.getValue(), out);\n            }\n        }\n    }","commit_id":"2a517e3ad30e10697d322a2cf148fb1cad86e062","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int b;\n        String hdr_name;\n        Header hdr;\n\n        // 1. dest_addr\n        dest_addr=Util.readAddress(in);\n\n        // 2. src_addr\n        src_addr=Util.readAddress(in);\n\n        // 3. buf\n        b=in.read();\n        if(b == 1) {\n            b=in.readInt();\n            buf=new byte[b];\n            in.read(buf, 0, b);\n            length=b;\n        }\n\n        // 4. headers\n        b=in.read();\n        if(b == 0)\n            return;\n        b=in.readInt();\n        headers();\n        for(int i=0; i < b; i++) {\n            hdr_name=in.readUTF();\n            hdr=readHeader(in);\n            headers.put(hdr_name, hdr);\n        }\n    }","id":79554,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int len, leading;\n        String hdr_name;\n        Header hdr;\n\n\n        // 1. read the leading byte first\n        leading=in.readByte();\n\n        // 1. dest_addr\n        if((leading & DEST_SET) == DEST_SET) {\n            if((leading & IPADDR_DEST) == IPADDR_DEST) {\n                dest_addr=new IpAddress();\n                dest_addr.readFrom(in);\n            }\n            else {\n                dest_addr=Util.readAddress(in);\n            }\n        }\n\n        // 2. src_addr\n        if((leading & SRC_SET) == SRC_SET) {\n            if((leading & IPADDR_SRC) == IPADDR_SRC) {\n                src_addr=new IpAddress();\n                src_addr.readFrom(in);\n            }\n            else {\n                src_addr=Util.readAddress(in);\n            }\n        }\n\n        // 3. buf\n        if((leading & BUF_SET) == BUF_SET) {\n            len=in.readInt();\n            buf=new byte[len];\n            in.read(buf, 0, len);\n            length=len;\n        }\n\n        // 4. headers\n        if((leading & HDRS_SET) == HDRS_SET) {\n            len=in.readInt();\n            headers();\n            for(int i=0; i < len; i++) {\n                hdr_name=in.readUTF();\n                hdr=readHeader(in);\n                headers.put(hdr_name, hdr);\n            }\n        }\n    }","commit_id":"2a517e3ad30e10697d322a2cf148fb1cad86e062","url":"https://github.com/belaban/JGroups"},{"original_method":"void addVisibleItemCount(int count) {\n\t\taddVisibleItemCount(count, false, false);\n\t}","id":79555,"modified_method":"void addVisibleItemCount(int count) {\n\t\tif (count == 0) return;\n\t\tComponent parent = getParent();\n\t\tif (parent instanceof Treeitem) {\n\t\t\tif (((Treeitem)parent).isOpen())\n\t\t\t\t((Treeitem)parent).addVisibleItemCount(count);\n\t\t} else if (parent instanceof Tree)\n\t\t\t((Tree)parent).addVisibleItemCount(count);\n\t\t_visibleItemCount += count;\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"public void onChildRemoved(Component child) {\n\t\tif (child instanceof Treerow) {\n\t\t\t_treerow = null;\n\t\t} else if (child instanceof Treechildren) {\n\t\t\taddVisibleItemCount(-_treechildren.getVisibleItemCount(), false);\n\t\t\t_treechildren = null;\n\t\t}\n\t\tsuper.onChildRemoved(child);\n\t}","id":79556,"modified_method":"public void onChildRemoved(Component child) {\n\t\tif (child instanceof Treerow) {\n\t\t\t_treerow = null;\n\t\t} else if (child instanceof Treechildren) {\n\t\t\taddVisibleItemCount(-_treechildren.getVisibleItemCount());\n\t\t\t_treechildren = null;\n\t\t}\n\t\tsuper.onChildRemoved(child);\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns the number of visible descendant {@link Treechildren}.\n\t * Descendants include direct children, grand children and so on.\n\t *\n\t * @since 3.6.1\n\t */\n\tpublic int getVisibleItemCount() {\n\t\treturn isVisible() ? 1 + (_open && _treechildren != null ? _treechildren.getVisibleItemCount() : 0 ): 0;\n\t}","id":79557,"modified_method":"/**\n\t * Returns the number of visible descendant {@link Treechildren}.\n\t * Descendants include direct children, grand children and so on.\n\t *\n\t * @since 3.6.1\n\t */\n\tpublic int getVisibleItemCount() {\n\t\treturn super.isVisible() ? 1 + (_open && _treechildren != null ? _treechildren.getVisibleItemCount() : 0 ): 0;\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets whether this container is open.\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\t//Note: _treerow might not be ready yet because it might be\n\t\t\t//initialized before creating child components (for ZK pages)\n\t\t\tsmartUpdate(\"open\", _open);\n\t\t\t\n\t\t\t//If the item is open, its tree has model and not rendered, render the item\n\t\t\tif(_open) {\n\t\t\t\tif (_treechildren != null) _treechildren.resyncVisibleItemCount();\n\t\t\t\tTree tree = getTree();\n\t\t\t\tif(tree != null && tree.getModel() !=null){\n\t\t\t\t\ttree.renderItem(this);\n\t\t\t\t}\n\t\t\t} else if (_treechildren != null)\n\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t}\n\t}","id":79558,"modified_method":"/** Sets whether this container is open.\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\t//Note: _treerow might not be ready yet because it might be\n\t\t\t//initialized before creating child components (for ZK pages)\n\t\t\tsmartUpdate(\"open\", _open);\n\t\t\t//If the item is open, its tree has model and not rendered, render the item\n\t\t\tif(_open) {\n\t\t\t\tif (_treechildren != null) addVisibleItemCount(_treechildren.getVisibleItemCount());\n\t\t\t\tTree tree = getTree();\n\t\t\t\tif(tree != null && tree.getModel() !=null){\n\t\t\t\t\ttree.renderItem(this);\n\t\t\t\t}\n\t\t\t} else \n\t\t\t\tif (_treechildren != null) addVisibleItemCount(-_treechildren.getVisibleItemCount());\n\t\t}\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"public boolean setVisible(boolean visible) {\n\t\tif(isVisible() != visible){\n\t\t\tsmartUpdate(\"visible\", visible);\n\t\t\t\t\tboolean result = super.setVisible(visible);\n\t\t\t\t\tif (_treechildren != null)\n\t\t\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t\t\t\tif (isVisible()) {\n\t\t\t\t\t\taddVisibleItemCount(1, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddVisibleItemCount(-1, true);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t}\n\t\treturn visible;\n\t}","id":79559,"modified_method":"public boolean setVisible(boolean visible) {\n\t\tif (isVisible() != visible) {\n\t\t\tsmartUpdate(\"visible\", visible);\n\t\t\tint count = isOpen() && _treechildren != null ? _treechildren\n\t\t\t\t\t.getVisibleItemCount() + 1 : 1;\n\t\t\tif (visible) {\n\t\t\t\tboolean result = super.setVisible(visible);\n\t\t\t\taddVisibleItemCount(count);\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\taddVisibleItemCount(-count);\n\t\t\t\treturn super.setVisible(visible);\n\t\t\t}\n\t\t}\n\t\treturn visible;\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"public void onChildAdded(Component child) {\n\t\tsuper.onChildAdded(child);\n\t\tif (_treechildren == child)\n\t\t\taddVisibleItemCount(_treechildren.getVisibleItemCount(), false);\n\t}","id":79560,"modified_method":"public void onChildAdded(Component child) {\n\t\tsuper.onChildAdded(child);\n\t\tif (_treechildren == child)\n\t\t\taddVisibleItemCount(_treechildren.getVisibleItemCount());\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onOpen.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\n\t\t\t_open = evt.isOpen();\n\t\t\tfinal Tree tree = getTree();\n\t\t\tif ( _open && !isLoaded() && tree != null && tree.getModel() != null) {\n\t\t\t\ttree.renderItem(Treeitem.this);\n\n\t\t\t\t// better client side performance with invalidate\n\t\t\t\tif (_treechildren != null && _treechildren.getChildren().size() >= 5)\n\t\t\t\t\tinvalidate();\n\t\t\t}\n\t\t\t\n\t\t\tif (_treechildren != null && isVisible()) {\n\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t\t}\n\t\t\t// Bug #2838782\n\t\t\tif (tree != null && tree.inPagingMold())\n\t\t\t\ttree.focus();\n\t\t\t\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":79561,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onOpen.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\n\t\t\tfinal boolean open = evt.isOpen();\n\n\t\t\tfinal Tree tree = getTree();\n\t\t\tif (open && !isLoaded() && tree != null && tree.getModel() != null) {\n\t\t\t\ttree.renderItem(Treeitem.this);\n\n\t\t\t\t// better client side performance with invalidate\n\t\t\t\tif (_treechildren != null && _treechildren.getChildren().size() >= 5)\n\t\t\t\t\tinvalidate();\n\t\t\t}\n\t\t\t\n\t\t\tif (_treechildren != null && super.isVisible()) {\n\t\t\t\tif (open)\n\t\t\t\t\taddVisibleItemCount(_treechildren.getVisibleItemCount());\n\t\t\t\telse {\n\t\t\t\t\taddVisibleItemCount(-_treechildren.getVisibleItemCount());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Bug #3170417 the status should update after update the visibleItemCount\n\t\t\t_open = open;\n\n\t\t\t// Bug #2838782\n\t\t\tif (tree != null && tree.inPagingMold())\n\t\t\t\ttree.focus();\n\t\t\t\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * adds the number of the visible item to the count of its parent.\n\t * @param count\n\t * @param force if true, ignores {@link #isVisible()}\n\t * @since 3.0.7\n\t */\n\tvoid addVisibleItemCount(int count, boolean force) {\n\t\tTreechildren tc = (Treechildren) getParent();\n\t\tif (tc != null && (force || isVisible())) {\n\t\t\tComponent parent = tc.getParent();\n\t\t\tif (parent instanceof Tree)\n\t\t\t\ttc.addVisibleItemCount(count);\n\t\t\telse if (((Treeitem)parent).isOpen()) {\n\t\t\t\ttc.addVisibleItemCount(count);\n\t\t\t}\n\t\t}\n\t}","id":79562,"modified_method":"/**\n\t * adds the number of the visible item to the count of its parent.\n\t * @param count\n\t * @param force if true, ignores {@link #isVisible()}\n\t * @since 3.0.7\n\t */\n\tvoid addVisibleItemCount(int count) {\n\t\tTreechildren tc = (Treechildren) getParent();\n\t\tif (tc != null && super.isVisible())\n\t\t\ttc.addVisibleItemCount(count);\n\t}","commit_id":"8aa56d9397cf74768e58f555d6d33e4c7cdfef94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets whether this container is open.\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\t//Note: _treerow might not be ready yet because it might be\n\t\t\t//initialized before creating child components (for ZK pages)\n\t\t\tsmartUpdate(\"open\", _open);\n\t\t\t//If the item is open, its tree has model and not rendered, render the item\n\t\t\tif(_open)\n\t\t\t\tif (_treechildren != null) addVisibleItemCount(_treechildren.getVisibleItemCount());\n\t\t\telse \n\t\t\t\tif (_treechildren != null) addVisibleItemCount(-_treechildren.getVisibleItemCount());\n\t\t\t\n\t\t\t\n\t\t\tTree tree = getTree();\n\t\t\tif(tree != null && tree.getModel() !=null){\n\t\t\t\tif(_open)\n\t\t\t\t\ttree.renderItem(this);\n\t\t\t\tTreeModel model = tree.getModel();\n\t\t\t\tif (model instanceof Openable)\n\t\t\t\t\t((Openable)model).setOpen(_treeNode, open);\n\t\t\t}\n\t\t}\n\t}","id":79563,"modified_method":"/** Sets whether this container is open.\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\t//Note: _treerow might not be ready yet because it might be\n\t\t\t//initialized before creating child components (for ZK pages)\n\t\t\tsmartUpdate(\"open\", _open);\n\t\t\t//If the item is open, its tree has model and not rendered, render the item\n\t\t\tif (_treechildren != null) \n\t\t\t\taddVisibleItemCount((_open ? 1: -1) * _treechildren.getVisibleItemCount());\n\t\t\t\n\t\t\tTree tree = getTree();\n\t\t\tif(tree != null && tree.getModel() !=null){\n\t\t\t\tif(_open)\n\t\t\t\t\ttree.renderItem(this);\n\t\t\t\tTreeModel model = tree.getModel();\n\t\t\t\tif (model instanceof Openable)\n\t\t\t\t\t((Openable)model).setOpen(_treeNode, open);\n\t\t\t}\n\t\t}\n\t}","commit_id":"4262d5e4e8fe926e560833890a405d6effcc93f7","url":"https://github.com/zkoss/zk"},{"original_method":"void resyncVisibleItemCount() {\n\t\t// reset first.\n\t\tif (_visibleItemCount != 0) {\n\t\t\tComponent parent = getParent();\n\t\t\tif (parent instanceof Treeitem) {\n\t\t\t\tif (((Treeitem)parent).isOpen())\n\t\t\t\t\t((Treeitem)parent).addVisibleItemCount(-_visibleItemCount, false);\n\t\t\t} else if (parent instanceof Tree)\n\t\t\t\t((Tree)parent).addVisibleItemCount(-_visibleItemCount);\n\t\t}\n\t\tfor (Iterator it = getChildren().iterator(); it.hasNext();) {\n\t\t\tTreeitem ti = (Treeitem)it.next();\n\t\t\taddVisibleItemCount(ti.getVisibleItemCount());\n\t\t}\n\t}","id":79564,"modified_method":"void resyncVisibleItemCount() {\n\t\tif (_visibleItemCount != 0) {\n\t\t\taddVisibleItemCount(-_visibleItemCount, true, true);\n\t\t\t_visibleItemCount = 0;\n\t\t}\n\t\tint newCount = 0;\n\t\tfor (Iterator it = getChildren().iterator(); it.hasNext();) {\n\t\t\tTreeitem ti = (Treeitem)it.next();\n\t\t\tnewCount += ti.getVisibleItemCount();\n\t\t}\n\t\taddVisibleItemCount(newCount, true, false);\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"void addVisibleItemCount(int count) {\n\t\tif (count == 0) return;\n\t\tComponent parent = getParent();\n\t\tif (parent instanceof Treeitem) {\n\t\t\tif (((Treeitem)parent).isOpen())\n\t\t\t\t((Treeitem)parent).addVisibleItemCount(count, false);\n\t\t} else if (parent instanceof Tree)\n\t\t\t((Tree)parent).addVisibleItemCount(count);\n\t\t_visibleItemCount += count;\n\t}","id":79565,"modified_method":"void addVisibleItemCount(int count) {\n\t\taddVisibleItemCount(count, false, false);\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"public boolean setVisible(boolean visible) {\n\t\tif(isVisible() != visible){\n\t\t\tsmartUpdate(\"visible\", visible);\n\t\t\tint count = isOpen() && _treechildren != null ?\n\t\t\t\t\t_treechildren.getVisibleItemCount() + 1: 1;\n\t\t\t\t\tboolean result = super.setVisible(visible);\n\t\t\t\t\tif (isVisible()) {\n\t\t\t\t\t\taddVisibleItemCount(count, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddVisibleItemCount(-count, true);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t}\n\t\treturn visible;\n\t}","id":79566,"modified_method":"public boolean setVisible(boolean visible) {\n\t\tif(isVisible() != visible){\n\t\t\tsmartUpdate(\"visible\", visible);\n\t\t\t\t\tboolean result = super.setVisible(visible);\n\t\t\t\t\tif (_treechildren != null)\n\t\t\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t\t\t\tif (isVisible()) {\n\t\t\t\t\t\taddVisibleItemCount(1, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddVisibleItemCount(-1, true);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t}\n\t\treturn visible;\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * adds the number of the visible item to the count of its parent.\n\t * @param count\n\t * @param force if true, ignores {@link #isVisible()}\n\t * @since 3.0.7\n\t */\n\tvoid addVisibleItemCount(int count, boolean force) {\n\t\tTreechildren tc = (Treechildren) getParent();\n\t\tif (tc != null && (force || isVisible()))\n\t\t\ttc.addVisibleItemCount(count);\n\t}","id":79567,"modified_method":"/**\n\t * adds the number of the visible item to the count of its parent.\n\t * @param count\n\t * @param force if true, ignores {@link #isVisible()}\n\t * @since 3.0.7\n\t */\n\tvoid addVisibleItemCount(int count, boolean force) {\n\t\tTreechildren tc = (Treechildren) getParent();\n\t\tif (tc != null && (force || isVisible())) {\n\t\t\tComponent parent = tc.getParent();\n\t\t\tif (parent instanceof Tree)\n\t\t\t\ttc.addVisibleItemCount(count);\n\t\t\telse if (((Treeitem)parent).isOpen()) {\n\t\t\t\ttc.addVisibleItemCount(count);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"/** Sets whether this container is open.\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\t//Note: _treerow might not be ready yet because it might be\n\t\t\t//initialized before creating child components (for ZK pages)\n\t\t\tsmartUpdate(\"open\", _open);\n\t\t\t\n\t\t\t//If the item is open, its tree has model and not rendered, render the item\n\t\t\tif(_open) {\n\t\t\t\tif (_treechildren != null) addVisibleItemCount(_treechildren.getVisibleItemCount(), false);\n\t\t\t\tTree tree = getTree();\n\t\t\t\tif(tree != null && tree.getModel() !=null){\n\t\t\t\t\ttree.renderItem(this);\n\t\t\t\t}\n\t\t\t} else if (_treechildren != null)\n\t\t\t\taddVisibleItemCount(-_treechildren.getVisibleItemCount(), true);\n\t\t}\n\t}","id":79568,"modified_method":"/** Sets whether this container is open.\n\t */\n\tpublic void setOpen(boolean open) {\n\t\tif (_open != open) {\n\t\t\t_open = open;\n\t\t\t//Note: _treerow might not be ready yet because it might be\n\t\t\t//initialized before creating child components (for ZK pages)\n\t\t\tsmartUpdate(\"open\", _open);\n\t\t\t\n\t\t\t//If the item is open, its tree has model and not rendered, render the item\n\t\t\tif(_open) {\n\t\t\t\tif (_treechildren != null) _treechildren.resyncVisibleItemCount();\n\t\t\t\tTree tree = getTree();\n\t\t\t\tif(tree != null && tree.getModel() !=null){\n\t\t\t\t\ttree.renderItem(this);\n\t\t\t\t}\n\t\t\t} else if (_treechildren != null)\n\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t}\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns the number of visible descendant {@link Treechildren}.\n\t * Descendants include direct children, grand children and so on.\n\t *\n\t * @since 3.6.1\n\t */\n\tpublic int getVisibleItemCount() {\n\t\treturn isVisible() ? 1 + (_treechildren != null ? _treechildren.getVisibleItemCount() : 0 ): 0;\n\t}","id":79569,"modified_method":"/**\n\t * Returns the number of visible descendant {@link Treechildren}.\n\t * Descendants include direct children, grand children and so on.\n\t *\n\t * @since 3.6.1\n\t */\n\tpublic int getVisibleItemCount() {\n\t\treturn isVisible() ? 1 + (_open && _treechildren != null ? _treechildren.getVisibleItemCount() : 0 ): 0;\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onOpen.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\n\t\t\t_open = evt.isOpen();\n\t\t\tif (_treechildren != null && isVisible()) {\n\t\t\t\tif (_open) {\n\t\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t\t\t\taddVisibleItemCount(_treechildren.getVisibleItemCount(), false);\n\t\t\t\t} else {\n\t\t\t\t\taddVisibleItemCount(-_treechildren.getVisibleItemCount(), true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal Tree tree = getTree();\n\t\t\tif ( _open && !isLoaded() && tree != null && tree.getModel() != null) {\n\t\t\t\ttree.renderItem(Treeitem.this);\n\n\t\t\t\t// better client side performance with invalidate\n\t\t\t\tif (_treechildren != null && _treechildren.getChildren().size() >= 5)\n\t\t\t\t\tinvalidate();\n\t\t\t}\n\n\t\t\t// Bug #2838782\n\t\t\tif (tree != null && tree.inPagingMold())\n\t\t\t\ttree.focus();\n\t\t\t\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","id":79570,"modified_method":"/** Processes an AU request.\n\t *\n\t * <p>Default: in addition to what are handled by {@link XulElement#service},\n\t * it also handles onOpen.\n\t * @since 5.0.0\n\t */\n\tpublic void service(org.zkoss.zk.au.AuRequest request, boolean everError) {\n\t\tfinal String cmd = request.getCommand();\n\t\tif (cmd.equals(Events.ON_OPEN)) {\n\t\t\tOpenEvent evt = OpenEvent.getOpenEvent(request);\n\n\t\t\t_open = evt.isOpen();\n\t\t\tfinal Tree tree = getTree();\n\t\t\tif ( _open && !isLoaded() && tree != null && tree.getModel() != null) {\n\t\t\t\ttree.renderItem(Treeitem.this);\n\n\t\t\t\t// better client side performance with invalidate\n\t\t\t\tif (_treechildren != null && _treechildren.getChildren().size() >= 5)\n\t\t\t\t\tinvalidate();\n\t\t\t}\n\t\t\t\n\t\t\tif (_treechildren != null && isVisible()) {\n\t\t\t\t_treechildren.resyncVisibleItemCount();\n\t\t\t}\n\t\t\t// Bug #2838782\n\t\t\tif (tree != null && tree.inPagingMold())\n\t\t\t\ttree.focus();\n\t\t\t\n\t\t\tEvents.postEvent(evt);\n\t\t} else\n\t\t\tsuper.service(request, everError);\n\t}","commit_id":"5caa62df7f617bdd09465f31fef430db66a17862","url":"https://github.com/zkoss/zk"},{"original_method":"private static void collectInheritingClasses(PsiClass aClass, Collection<LineMarkerInfo> result) {\n    if (!aClass.hasModifierProperty(PsiModifier.FINAL)) {\n      if (\"java.lang.Object\".equals(aClass.getQualifiedName())) return; // It's useless to have overriden markers for object.\n\n      final PsiClass inheritor = ClassInheritorsSearch.search(aClass, false).findFirst();\n      if (inheritor != null) {\n        final Icon icon = aClass.isInterface() ? IMPLEMENTED_INTERFACE_MARKER_RENDERER : SUBCLASSED_CLASS_MARKER_RENDERER;\n        final MarkerType type = MarkerType.SUBCLASSED_CLASS;\n        PsiElement range = aClass.getNameIdentifier();\n        if (range == null) range = aClass;\n        LineMarkerInfo info = new LineMarkerInfo<PsiClass>(aClass, range.getTextRange(), icon, Pass.UPDATE_OVERRIDEN_MARKERS, type.getTooltip(), type.<PsiClass>getNavigationHandler(),\n                                                           GutterIconRenderer.Alignment.RIGHT);\n        result.add(info);\n      }\n    }\n  }","id":79571,"modified_method":"private static void collectInheritingClasses(PsiClass aClass, Collection<LineMarkerInfo> result) {\n    if (!aClass.hasModifierProperty(PsiModifier.FINAL)) {\n      if (\"java.lang.Object\".equals(aClass.getQualifiedName())) return; // It's useless to have overriden markers for object.\n\n      final PsiClass inheritor = ClassInheritorsSearch.search(aClass, false).findFirst();\n      if (inheritor != null) {\n        final Icon icon = aClass.isInterface() ? IMPLEMENTED_INTERFACE_MARKER_RENDERER : SUBCLASSED_CLASS_MARKER_RENDERER;\n        final MarkerType type = MarkerType.SUBCLASSED_CLASS;\n        PsiElement range = aClass.getNameIdentifier();\n        if (range == null) range = aClass;\n        LineMarkerInfo info = new LineMarkerInfo<PsiElement>(range, range.getTextRange(), icon, Pass.UPDATE_OVERRIDEN_MARKERS, type.getTooltip(), type.getNavigationHandler(),\n                                                           GutterIconRenderer.Alignment.RIGHT);\n        result.add(info);\n      }\n    }\n  }","commit_id":"32144a9daab90da8e2f93d265701f670592024cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public LineMarkerInfo getLineMarkerInfo(final PsiElement element) {\n    if (element instanceof PsiIdentifier && element.getParent() instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element.getParent();\n      MethodSignatureBackedByPsiMethod superSignature = SuperMethodsSearch.search(method, null, true, false).findFirst();\n      if (superSignature != null) {\n        boolean overrides =\n          method.hasModifierProperty(PsiModifier.ABSTRACT) == superSignature.getMethod().hasModifierProperty(PsiModifier.ABSTRACT);\n\n        final Icon icon = overrides ? OVERRIDING_METHOD_ICON : IMPLEMENTING_METHOD_ICON;\n        final MarkerType type = MarkerType.OVERRIDING_METHOD;\n        return new LineMarkerInfo<PsiMethod>(method, element.getTextRange(), icon, Pass.UPDATE_ALL, type.getTooltip(), type.<PsiMethod>getNavigationHandler(), GutterIconRenderer.Alignment.LEFT);\n      }\n    }\n\n    if (myDaemonSettings.SHOW_METHOD_SEPARATORS && element.getFirstChild() == null) {\n      PsiElement element1 = element;\n      boolean isMember = false;\n      while (element1 != null && !(element1 instanceof PsiFile) && element1.getPrevSibling() == null) {\n        element1 = element1.getParent();\n        if (element1 instanceof PsiMember) {\n          isMember = true;\n          break;\n        }\n      }\n      if (isMember && !(element1 instanceof PsiAnonymousClass || element1.getParent() instanceof PsiAnonymousClass)) {\n        boolean drawSeparator = false;\n        int category = getCategory(element1);\n        for (PsiElement child = element1.getPrevSibling(); child != null; child = child.getPrevSibling()) {\n          int category1 = getCategory(child);\n          if (category1 == 0) continue;\n          drawSeparator = category != 1 || category1 != 1;\n          break;\n        }\n\n        if (drawSeparator) {\n          LineMarkerInfo info = new LineMarkerInfo<PsiElement>(element, element.getTextRange(), null, Pass.UPDATE_ALL, NullableFunction.NULL, null, GutterIconRenderer.Alignment.RIGHT);\n          EditorColorsScheme scheme = myColorsManager.getGlobalScheme();\n          info.separatorColor = scheme.getColor(CodeInsightColors.METHOD_SEPARATORS_COLOR);\n          info.separatorPlacement = SeparatorPlacement.TOP;\n          return info;\n        }\n      }\n    }\n\n    return null;\n  }","id":79572,"modified_method":"@Nullable\n  public LineMarkerInfo getLineMarkerInfo(final PsiElement element) {\n    if (element instanceof PsiIdentifier && element.getParent() instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element.getParent();\n      MethodSignatureBackedByPsiMethod superSignature = SuperMethodsSearch.search(method, null, true, false).findFirst();\n      if (superSignature != null) {\n        boolean overrides =\n          method.hasModifierProperty(PsiModifier.ABSTRACT) == superSignature.getMethod().hasModifierProperty(PsiModifier.ABSTRACT);\n\n        final Icon icon = overrides ? OVERRIDING_METHOD_ICON : IMPLEMENTING_METHOD_ICON;\n        final MarkerType type = MarkerType.OVERRIDING_METHOD;\n        return new LineMarkerInfo<PsiElement>(element, element.getTextRange(), icon, Pass.UPDATE_ALL, type.getTooltip(), type.getNavigationHandler(), GutterIconRenderer.Alignment.LEFT);\n      }\n    }\n\n    if (myDaemonSettings.SHOW_METHOD_SEPARATORS && element.getFirstChild() == null) {\n      PsiElement element1 = element;\n      boolean isMember = false;\n      while (element1 != null && !(element1 instanceof PsiFile) && element1.getPrevSibling() == null) {\n        element1 = element1.getParent();\n        if (element1 instanceof PsiMember) {\n          isMember = true;\n          break;\n        }\n      }\n      if (isMember && !(element1 instanceof PsiAnonymousClass || element1.getParent() instanceof PsiAnonymousClass)) {\n        boolean drawSeparator = false;\n        int category = getCategory(element1);\n        for (PsiElement child = element1.getPrevSibling(); child != null; child = child.getPrevSibling()) {\n          int category1 = getCategory(child);\n          if (category1 == 0) continue;\n          drawSeparator = category != 1 || category1 != 1;\n          break;\n        }\n\n        if (drawSeparator) {\n          LineMarkerInfo info = new LineMarkerInfo<PsiElement>(element, element.getTextRange(), null, Pass.UPDATE_ALL, NullableFunction.NULL, null, GutterIconRenderer.Alignment.RIGHT);\n          EditorColorsScheme scheme = myColorsManager.getGlobalScheme();\n          info.separatorColor = scheme.getColor(CodeInsightColors.METHOD_SEPARATORS_COLOR);\n          info.separatorPlacement = SeparatorPlacement.TOP;\n          return info;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"32144a9daab90da8e2f93d265701f670592024cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void collectOverridingMethods(final Set<PsiMethod> methods, Collection<LineMarkerInfo> result) {\n    final Set<PsiMethod> overridden = new HashSet<PsiMethod>();\n    Set<PsiClass> classes = new THashSet<PsiClass>();\n    for (PsiMethod method : methods) {\n      ProgressManager.getInstance().checkCanceled();\n      final PsiClass parentClass = method.getContainingClass();\n      if (!\"java.lang.Object\".equals(parentClass.getQualifiedName())) {\n        classes.add(parentClass);\n      }\n    }\n\n    for (final PsiClass aClass : classes) {\n      AllOverridingMethodsSearch.search(aClass).forEach(new Processor<Pair<PsiMethod, PsiMethod>>() {\n        public boolean process(final Pair<PsiMethod, PsiMethod> pair) {\n          final PsiMethod superMethod = pair.getFirst();\n          overridden.add(superMethod);\n          methods.remove(superMethod);\n          return !methods.isEmpty();\n        }\n      });\n    }\n\n    for (PsiMethod method : overridden) {\n      boolean overrides = !method.hasModifierProperty(PsiModifier.ABSTRACT);\n\n      final Icon icon = overrides ? OVERRIDEN_METHOD_MARKER_RENDERER : IMPLEMENTED_METHOD_MARKER_RENDERER;\n      final MarkerType type = MarkerType.OVERRIDEN_METHOD;\n      PsiElement range = method.getNameIdentifier();\n      if (range == null) range = method;\n      LineMarkerInfo info = new LineMarkerInfo<PsiMethod>(method, range.getTextRange(), icon, Pass.UPDATE_OVERRIDEN_MARKERS, type.getTooltip(), type.<PsiMethod>getNavigationHandler(),\n                                                          GutterIconRenderer.Alignment.RIGHT);\n      result.add(info);\n    }\n  }","id":79573,"modified_method":"private static void collectOverridingMethods(final Set<PsiMethod> methods, Collection<LineMarkerInfo> result) {\n    final Set<PsiMethod> overridden = new HashSet<PsiMethod>();\n    Set<PsiClass> classes = new THashSet<PsiClass>();\n    for (PsiMethod method : methods) {\n      ProgressManager.getInstance().checkCanceled();\n      final PsiClass parentClass = method.getContainingClass();\n      if (!\"java.lang.Object\".equals(parentClass.getQualifiedName())) {\n        classes.add(parentClass);\n      }\n    }\n\n    for (final PsiClass aClass : classes) {\n      AllOverridingMethodsSearch.search(aClass).forEach(new Processor<Pair<PsiMethod, PsiMethod>>() {\n        public boolean process(final Pair<PsiMethod, PsiMethod> pair) {\n          final PsiMethod superMethod = pair.getFirst();\n          overridden.add(superMethod);\n          methods.remove(superMethod);\n          return !methods.isEmpty();\n        }\n      });\n    }\n\n    for (PsiMethod method : overridden) {\n      boolean overrides = !method.hasModifierProperty(PsiModifier.ABSTRACT);\n\n      final Icon icon = overrides ? OVERRIDEN_METHOD_MARKER_RENDERER : IMPLEMENTED_METHOD_MARKER_RENDERER;\n      final MarkerType type = MarkerType.OVERRIDEN_METHOD;\n      PsiElement range = method.getNameIdentifier();\n      if (range == null) range = method;\n      LineMarkerInfo info = new LineMarkerInfo<PsiElement>(range, range.getTextRange(), icon, Pass.UPDATE_OVERRIDEN_MARKERS, type.getTooltip(), type.getNavigationHandler(),\n                                                          GutterIconRenderer.Alignment.RIGHT);\n      result.add(info);\n    }\n  }","commit_id":"32144a9daab90da8e2f93d265701f670592024cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void setLineMarkersToEditor(@NotNull Project project,\n                                            @NotNull Document document,\n                                            int startOffset,\n                                            int endOffset,\n                                            @NotNull Collection<LineMarkerInfo> markers,\n                                            int group) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    List<LineMarkerInfo> array = new ArrayList<LineMarkerInfo>();\n\n    List<LineMarkerInfo> oldMarkers = DaemonCodeAnalyzerImpl.getLineMarkers(document, project);\n    MarkupModel markupModel = document.getMarkupModel(project);\n    if (oldMarkers != null) {\n      for (LineMarkerInfo info : oldMarkers) {\n        RangeHighlighter highlighter = info.highlighter;\n        boolean toRemove = !highlighter.isValid() || info.updatePass == group\n                           && startOffset <= highlighter.getStartOffset() && (highlighter.getEndOffset() < endOffset || highlighter.getEndOffset() == document.getTextLength());\n\n        if (toRemove) {\n          markupModel.removeHighlighter(highlighter);\n        }\n        else {\n          array.add(info);\n        }\n      }\n    }\n\n    final EditorColorsScheme colorsScheme = EditorColorsManager.getInstance().getGlobalScheme(); // TODO: editor color scheme\n    for (LineMarkerInfo info : markers) {\n      PsiElement element = info.getElement();\n      TextRange textRange = element.getTextRange();\n      LOG.assertTrue(textRange != null, element);\n      TextRange elementRange = InjectedLanguageManager.getInstance(project).injectedToHost(element, textRange);\n      if (startOffset <= elementRange.getStartOffset() && elementRange.getEndOffset() <= endOffset) {\n        RangeHighlighter marker = markupModel.addRangeHighlighter(info.startOffset, info.endOffset, HighlighterLayer.ADDITIONAL_SYNTAX, info.textAttributesKey != null ? colorsScheme\n          .getAttributes(info.textAttributesKey) : null, HighlighterTargetArea.EXACT_RANGE);\n        marker.setGutterIconRenderer(info.createGutterRenderer());\n        marker.setLineSeparatorColor(info.separatorColor);\n        marker.setLineSeparatorPlacement(info.separatorPlacement);\n        info.highlighter = marker;\n        array.add(info);\n      }\n    }\n\n    DaemonCodeAnalyzerImpl.setLineMarkers(document, array, project);\n  }","id":79574,"modified_method":"public static void setLineMarkersToEditor(@NotNull Project project,\n                                            @NotNull Document document,\n                                            int startOffset,\n                                            int endOffset,\n                                            @NotNull Collection<LineMarkerInfo> markers,\n                                            int group) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    List<LineMarkerInfo> oldMarkers = DaemonCodeAnalyzerImpl.getLineMarkers(document, project);\n    List<LineMarkerInfo> array = new ArrayList<LineMarkerInfo>(oldMarkers == null ? markers.size() : oldMarkers.size());\n    MarkupModel markupModel = document.getMarkupModel(project);\n    RangeHighlightersToReuse toReuse = new RangeHighlightersToReuse();\n    if (oldMarkers != null) {\n      for (LineMarkerInfo info : oldMarkers) {\n        RangeHighlighter highlighter = info.highlighter;\n        boolean toRemove = !highlighter.isValid() ||\n                           info.updatePass == group &&\n                           startOffset <= highlighter.getStartOffset() &&\n                           (highlighter.getEndOffset() < endOffset || highlighter.getEndOffset() == document.getTextLength());\n\n        if (toRemove) {\n          toReuse.add(highlighter);\n        }\n        else {\n          array.add(info);\n        }\n      }\n    }\n\n    final EditorColorsScheme colorsScheme = EditorColorsManager.getInstance().getGlobalScheme(); // TODO: editor color scheme\n    for (LineMarkerInfo info : markers) {\n      PsiElement element = info.getElement();\n      TextRange textRange = element.getTextRange();\n      LOG.assertTrue(textRange != null, element);\n      TextRange elementRange = InjectedLanguageManager.getInstance(project).injectedToHost(element, textRange);\n      if (startOffset <= elementRange.getStartOffset() && elementRange.getEndOffset() <= endOffset) {\n\n        RangeHighlighter marker = toReuse.reuseHighlighterAt(info.startOffset, info.endOffset);\n\n        if (marker == null) {\n          marker = markupModel.addRangeHighlighter(info.startOffset, info.endOffset, HighlighterLayer.ADDITIONAL_SYNTAX,\n                                                   info.textAttributesKey != null\n                                                   ? colorsScheme.getAttributes(info.textAttributesKey)\n                                                   : null, HighlighterTargetArea.EXACT_RANGE);\n        }\n        GutterIconRenderer renderer = info.createGutterRenderer();\n        if (!Comparing.equal(marker.getGutterIconRenderer() == null ? null : marker.getGutterIconRenderer().getIcon(), renderer == null ? null : renderer.getIcon())) {\n          marker.setGutterIconRenderer(renderer);\n        }\n        if (!Comparing.equal(marker.getLineSeparatorColor(), info.separatorColor)) {\n          marker.setLineSeparatorColor(info.separatorColor);\n        }\n        if (!Comparing.equal(marker.getLineSeparatorPlacement(), info.separatorPlacement)) {\n          marker.setLineSeparatorPlacement(info.separatorPlacement);\n        }\n        info.highlighter = marker;\n        array.add(info);\n      }\n    }\n\n    for (RangeHighlighter highlighter : toReuse.forAll()) {\n      markupModel.removeHighlighter(highlighter);\n    }\n\n    DaemonCodeAnalyzerImpl.setLineMarkers(document, array, project);\n  }","commit_id":"32144a9daab90da8e2f93d265701f670592024cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void setHighlightersToEditor(@NotNull Project project,\n                                             @NotNull Document document,\n                                             @NotNull Map<TextRange, Collection<HighlightInfo>> infos,\n                                             int group) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    //serialized implicitly by the dispatch thread\n\n    PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(document);\n    cleanFileLevelHighlights(project, group, psiFile);\n\n    List<TextRange> ranges = new ArrayList<TextRange>(infos.keySet());\n    Collections.sort(ranges, BY_START_OFFSET);\n    //merge intersecting\n    for (int i = 1; i < ranges.size(); i++) {\n      TextRange range = ranges.get(i);\n      TextRange prev = ranges.get(i-1);\n      if (prev.intersects(range)) {\n        ranges.remove(i);\n        TextRange union = prev.union(range);\n\n        Collection<HighlightInfo> collection = infos.get(prev);\n        collection.addAll(infos.get(range));\n        infos.remove(prev);\n        infos.remove(range);\n        infos.put(union, collection);\n        ranges.set(i - 1, union);\n        i--;\n      }\n    }\n\n    MarkupModel markup = document.getMarkupModel(project);\n    List<HighlightInfo> oldHighlights = DaemonCodeAnalyzerImpl.getHighlights(markup);\n    List<HighlightInfo> oldHighlightsToRemove = DaemonCodeAnalyzerImpl.getHighlightsToRemove(markup);\n    assertMarkupConsistent(markup, oldHighlights, oldHighlightsToRemove);\n\n    List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n    MultiMap<HighlightInfo, HighlightInfo> infosToRemove = new MultiMap<HighlightInfo, HighlightInfo>(){\n      @Override\n      protected Map<HighlightInfo, Collection<HighlightInfo>> createMap() {\n        return new THashMap<HighlightInfo, Collection<HighlightInfo>>(DISTINQUISH_INVALID_MARKERS);\n      }\n\n      @Override\n      protected Collection<HighlightInfo> createCollection() {\n        return new ArrayList<HighlightInfo>();\n      }\n    };\n\n    boolean changed = false;\n    if (oldHighlights != null) {\n      for (HighlightInfo info : oldHighlights) {\n        RangeHighlighter highlighter = info.highlighter;\n        boolean toRemove = !highlighter.isValid() ||\n                           info.group == group && Collections.binarySearch(ranges, new TextRange(highlighter.getStartOffset(), highlighter.getEndOffset()),\n                                                                           BY_START_OFFSET_OR_CONTAINS) >= 0;\n        if (toRemove) {\n          infosToRemove.putValue(info,info);\n          changed = true;\n        }\n        else {\n          result.add(info);\n        }\n      }\n    }\n\n    for (HighlightInfo info : oldHighlightsToRemove) {\n      infosToRemove.putValue(info, info);\n      result.remove(info);\n      changed = true;\n    }\n\n    Map<TextRange, RangeMarker> ranges2markersCache = new THashMap<TextRange, RangeMarker>(oldHighlights == null ? 10 : oldHighlights.size());\n    for (TextRange range : ranges) {\n      int rangeStartOffset = range.getStartOffset();\n      int rangeEndOffset = range.getEndOffset();\n\n      List<HighlightInfo> highlights = new ArrayList<HighlightInfo>(infos.get(range));\n      Collections.sort(highlights, new Comparator<HighlightInfo>() {\n        public int compare(HighlightInfo o1, HighlightInfo o2) {\n          return o1.startOffset - o2.startOffset;\n        }\n      });\n\n      for (HighlightInfo info : highlights) {\n        if (info.isFileLevelAnnotation && psiFile != null && psiFile.getViewProvider().isPhysical()) {\n          addFileLevelHighlight(project, group, info, psiFile);\n          continue;\n        }\n\n        int infoStartOffset = info.startOffset;\n        int infoEndOffset = info.endOffset;\n        if (infoStartOffset < rangeStartOffset || infoEndOffset > rangeEndOffset) continue;\n\n        if (infoEndOffset == infoStartOffset) {\n          infoEndOffset++; //show something in case of empty highlightinfo\n        }\n        final int docLength = document.getTextLength();\n        if (infoEndOffset > docLength) {\n          infoEndOffset = docLength;\n        }\n\n        info.text = document.getCharsSequence().subSequence(infoStartOffset, infoEndOffset).toString();\n        info.group = group;\n\n        List<HighlightInfo> values = (List<HighlightInfo>)infosToRemove.get(info);\n\n        HighlightInfo toRemove = values.isEmpty() ? null : values.remove(0);\n        RangeHighlighterEx highlighter;\n        if (toRemove != null && toRemove.highlighter.isValid()) {\n          highlighter = toRemove.highlighter;\n          ((RangeHighlighterImpl)highlighter).setTextAttributes(info.getTextAttributes(psiFile));\n        }\n        else {\n          highlighter = createRangeHighlighter(project, psiFile, info, infoStartOffset, infoEndOffset, markup);\n        }\n        changed = true;\n        info.highlighter = highlighter;\n        highlighter.setAfterEndOfLine(info.isAfterEndOfLine);\n\n        Color color = info.getErrorStripeMarkColor(psiFile);\n        if (!Comparing.equal(color, highlighter.getErrorStripeMarkColor())) {\n          highlighter.setErrorStripeMarkColor(color);\n        }\n        highlighter.setErrorStripeTooltip(info);\n        GutterIconRenderer renderer = info.getGutterIconRenderer();\n        if (!Comparing.equal(renderer, highlighter.getGutterIconRenderer())) {\n          highlighter.setGutterIconRenderer(renderer);\n        }\n\n        ranges2markersCache.put(new TextRange(infoStartOffset, infoEndOffset), info.highlighter);\n        if (info.quickFixActionRanges != null) {\n          info.quickFixActionMarkers = new ArrayList<Pair<HighlightInfo.IntentionActionDescriptor, RangeMarker>>(info.quickFixActionRanges.size());\n          for (Pair<HighlightInfo.IntentionActionDescriptor, TextRange> pair : info.quickFixActionRanges) {\n            TextRange textRange = pair.second;\n            RangeMarker marker = getOrCreate(document, ranges2markersCache, textRange);\n            info.quickFixActionMarkers.add(Pair.create(pair.first, marker));\n          }\n        }\n        info.fixMarker = getOrCreate(document, ranges2markersCache, new TextRange(info.fixStartOffset, info.fixEndOffset));\n\n        assert Comparing.equal(info.getTextAttributes(psiFile), highlighter.getTextAttributes()) : \"Info: \"+info.getTextAttributes(psiFile)+\"; highlighter:\"+highlighter.getTextAttributes();\n        \n        result.add(info);\n      }\n\n      for (Iterator<HighlightInfo> it = infosToRemove.keySet().iterator(); it.hasNext();) {\n        HighlightInfo info = it.next();\n        if (info.highlighter.isValid()) {\n          if (info.group != group || info.getActualStartOffset() < rangeStartOffset || info.getActualEndOffset() > rangeEndOffset) continue;\n        }\n        Collection<HighlightInfo> values = infosToRemove.get(info);\n        for (HighlightInfo value : values) {\n          markup.removeHighlighter(value.highlighter);\n        }\n        changed = true;\n        it.remove();\n      }\n    }\n\n    List<HighlightInfo> listToRemove = infosToRemove.isEmpty() ? Collections.<HighlightInfo>emptyList() : new ArrayList<HighlightInfo>(infosToRemove.values());\n    if (changed) {\n      DaemonCodeAnalyzerImpl.setHighlights(markup, project, result, listToRemove);\n      clearWhiteSpaceOptimizationFlag(document);\n    }\n    assertMarkupConsistent(markup, result, listToRemove);\n  }","id":79575,"modified_method":"public static void setHighlightersToEditor(@NotNull Project project,\n                                             @NotNull Document document,\n                                             @NotNull Map<TextRange, Collection<HighlightInfo>> infos,\n                                             int group) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    //serialized implicitly by the dispatch thread\n\n    PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(document);\n    cleanFileLevelHighlights(project, group, psiFile);\n\n    List<TextRange> ranges = new ArrayList<TextRange>(infos.keySet());\n    Collections.sort(ranges, BY_START_OFFSET);\n    //merge intersecting\n    for (int i = 1; i < ranges.size(); i++) {\n      TextRange range = ranges.get(i);\n      TextRange prev = ranges.get(i-1);\n      if (prev.intersects(range)) {\n        ranges.remove(i);\n        TextRange union = prev.union(range);\n\n        Collection<HighlightInfo> collection = infos.get(prev);\n        collection.addAll(infos.get(range));\n        infos.remove(prev);\n        infos.remove(range);\n        infos.put(union, collection);\n        ranges.set(i - 1, union);\n        i--;\n      }\n    }\n\n    MarkupModel markup = document.getMarkupModel(project);\n    List<HighlightInfo> oldHighlights = DaemonCodeAnalyzerImpl.getHighlights(markup);\n    List<HighlightInfo> oldHighlightsToRemove = DaemonCodeAnalyzerImpl.getHighlightsToRemove(markup);\n    assertMarkupConsistent(markup, oldHighlights, oldHighlightsToRemove);\n\n    List<HighlightInfo> result = new ArrayList<HighlightInfo>();\n    RangeHighlightersToReuse infosToRemove = new RangeHighlightersToReuse();\n\n    boolean changed = false;\n    List<HighlightInfo> toRemoveInAnotherPass = new SmartList<HighlightInfo>();\n\n    if (oldHighlights != null) {\n      List<HighlightInfo> list = ContainerUtil.concat(oldHighlightsToRemove, oldHighlights);\n      for (int i = 0; i < list.size(); i++) {\n        HighlightInfo info = list.get(i);\n        RangeHighlighter highlighter = info.highlighter;\n        boolean toRemove = !highlighter.isValid() ||\n                           info.group == group &&\n                           Collections.binarySearch(ranges, new TextRange(highlighter.getStartOffset(), highlighter.getEndOffset()),\n                                                    BY_START_OFFSET_OR_CONTAINS) >= 0;\n        if (toRemove) {\n          infosToRemove.add(highlighter);\n          changed = true;\n        }\n        else if (i >= oldHighlightsToRemove.size()) {\n          result.add(info);\n        }\n        else {\n          toRemoveInAnotherPass.add(info);\n        }\n      }\n    }\n\n    Map<TextRange, RangeMarker> ranges2markersCache = new THashMap<TextRange, RangeMarker>(oldHighlights == null ? 10 : oldHighlights.size());\n    for (TextRange range : ranges) {\n      int rangeStartOffset = range.getStartOffset();\n      int rangeEndOffset = range.getEndOffset();\n\n      List<HighlightInfo> highlights = new ArrayList<HighlightInfo>(infos.get(range));\n      Collections.sort(highlights, new Comparator<HighlightInfo>() {\n        public int compare(HighlightInfo o1, HighlightInfo o2) {\n          return o1.startOffset - o2.startOffset;\n        }\n      });\n\n      for (HighlightInfo info : highlights) {\n        if (info.isFileLevelAnnotation && psiFile != null && psiFile.getViewProvider().isPhysical()) {\n          addFileLevelHighlight(project, group, info, psiFile);\n          continue;\n        }\n\n        int infoStartOffset = info.startOffset;\n        int infoEndOffset = info.endOffset;\n        if (infoStartOffset < rangeStartOffset || infoEndOffset > rangeEndOffset) continue;\n\n        if (infoEndOffset == infoStartOffset) {\n          infoEndOffset++; //show something in case of empty highlightinfo\n        }\n        final int docLength = document.getTextLength();\n        if (infoEndOffset > docLength) {\n          infoEndOffset = docLength;\n        }\n\n        info.text = document.getCharsSequence().subSequence(infoStartOffset, infoEndOffset).toString();\n        info.group = group;\n\n\n        RangeHighlighterEx highlighter = (RangeHighlighterEx)infosToRemove.reuseHighlighterAt(info.startOffset, info.endOffset);\n        if (highlighter != null) {\n          ((RangeHighlighterImpl)highlighter).setTextAttributes(info.getTextAttributes(psiFile));\n        }\n        else {\n          highlighter = createRangeHighlighter(project, psiFile, info, infoStartOffset, infoEndOffset, markup);\n        }\n        changed = true;\n        info.highlighter = highlighter;\n        highlighter.setAfterEndOfLine(info.isAfterEndOfLine);\n\n        Color color = info.getErrorStripeMarkColor(psiFile);\n        if (!Comparing.equal(color, highlighter.getErrorStripeMarkColor())) {\n          highlighter.setErrorStripeMarkColor(color);\n        }\n        highlighter.setErrorStripeTooltip(info);\n        GutterIconRenderer renderer = info.getGutterIconRenderer();\n        if (!Comparing.equal(renderer, highlighter.getGutterIconRenderer())) {\n          highlighter.setGutterIconRenderer(renderer);\n        }\n\n        ranges2markersCache.put(new TextRange(infoStartOffset, infoEndOffset), info.highlighter);\n        if (info.quickFixActionRanges != null) {\n          info.quickFixActionMarkers = new ArrayList<Pair<HighlightInfo.IntentionActionDescriptor, RangeMarker>>(info.quickFixActionRanges.size());\n          for (Pair<HighlightInfo.IntentionActionDescriptor, TextRange> pair : info.quickFixActionRanges) {\n            TextRange textRange = pair.second;\n            RangeMarker marker = getOrCreate(document, ranges2markersCache, textRange);\n            info.quickFixActionMarkers.add(Pair.create(pair.first, marker));\n          }\n        }\n        info.fixMarker = getOrCreate(document, ranges2markersCache, new TextRange(info.fixStartOffset, info.fixEndOffset));\n\n        assert Comparing.equal(info.getTextAttributes(psiFile), highlighter.getTextAttributes()) : \"Info: \" +\n                                                                                                   info.getTextAttributes(psiFile) +\n                                                                                                   \"; highlighter:\" +\n                                                                                                   highlighter.getTextAttributes();\n\n        result.add(info);\n      }\n    }\n\n    for (RangeHighlighter highlighter : infosToRemove.forAll()) {\n      markup.removeHighlighter(highlighter);\n      changed = true;\n    }\n\n    if (changed) {\n      DaemonCodeAnalyzerImpl.setHighlights(markup, project, result, toRemoveInAnotherPass);\n      clearWhiteSpaceOptimizationFlag(document);\n    }\n    assertMarkupConsistent(markup, result, toRemoveInAnotherPass);\n  }","commit_id":"32144a9daab90da8e2f93d265701f670592024cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected static TextRange calculateRangeToProcess(Editor editor) {\n    TextRange dirtyTextRange = FileStatusMap.getDirtyTextRange(editor, Pass.UPDATE_ALL);\n    if (dirtyTextRange == null) return null;\n    int startOffset = dirtyTextRange.getStartOffset();\n    int endOffset = dirtyTextRange.getEndOffset();\n    Rectangle rect = editor.getScrollingModel().getVisibleArea();\n    LogicalPosition startPosition = editor.xyToLogicalPosition(new Point(rect.x, rect.y));\n\n    int visibleStart = editor.logicalPositionToOffset(startPosition);\n    if (visibleStart > startOffset) {\n      startOffset = visibleStart;\n    }\n    LogicalPosition endPosition = editor.xyToLogicalPosition(new Point(rect.x + rect.width, rect.y + rect.height));\n\n    int visibleEnd = editor.logicalPositionToOffset(new LogicalPosition(endPosition.line + 1, 0));\n    if (visibleEnd < endOffset) {\n      endOffset = visibleEnd;\n    }\n\n    if (startOffset >= endOffset) {\n      return null;\n    }\n    TextRange textRange = new TextRange(startOffset, endOffset);\n    if (textRange.equals(dirtyTextRange)) {\n      return null; // no sense in highlighting the same region twice\n    }\n    return textRange;\n  }","id":79576,"modified_method":"@Nullable\n  protected TextRange calculateRangeToProcess(Editor editor) {\n    TextRange dirtyTextRange = FileStatusMap.getDirtyTextRange(editor, Pass.UPDATE_ALL);\n    if (dirtyTextRange == null) return null;\n    int startOffset = dirtyTextRange.getStartOffset();\n    int endOffset = dirtyTextRange.getEndOffset();\n    Rectangle rect = editor.getScrollingModel().getVisibleArea();\n    LogicalPosition startPosition = editor.xyToLogicalPosition(new Point(rect.x, rect.y));\n\n    int visibleStart = editor.logicalPositionToOffset(startPosition);\n    if (visibleStart > startOffset) {\n      startOffset = visibleStart;\n    }\n    LogicalPosition endPosition = editor.xyToLogicalPosition(new Point(rect.x + rect.width, rect.y + rect.height));\n\n    int visibleEnd = editor.logicalPositionToOffset(new LogicalPosition(endPosition.line + 1, 0));\n    if (visibleEnd < endOffset) {\n      endOffset = visibleEnd;\n    }\n\n    if (startOffset >= endOffset) {\n      return null;\n    }\n    TextRange textRange = new TextRange(startOffset, endOffset);\n    if (textRange.equals(dirtyTextRange)) {\n      return null; // no sense in highlighting the same region twice\n    }\n    return textRange;\n  }","commit_id":"32144a9daab90da8e2f93d265701f670592024cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String addTextRangeToHistory(TextRange textRange, final EditorEx consoleEditor) {\n    final DocumentImpl history = (DocumentImpl)myHistoryViewer.getDocument();\n    final MarkupModel markupModel = history.getMarkupModel(myProject);\n    appendToHistoryDocument(history, myPrompt);\n    markupModel.addRangeHighlighter(history.getTextLength() - myPrompt.length(), history.getTextLength(), HighlighterLayer.SYNTAX,\n                                    ConsoleViewContentType.USER_INPUT.getAttributes(),\n                                    HighlighterTargetArea.EXACT_RANGE);\n\n    final String text = consoleEditor.getDocument().getText(textRange);\n     //offset can be changed after text trimming after insert due to buffer constraints\n    appendToHistoryDocument(history, text);\n    int offset = history.getTextLength() - text.length();\n    final int localOffset = textRange.getStartOffset();\n    final HighlighterIterator iterator = consoleEditor.getHighlighter().createIterator(localOffset);\n    final int localEndOffset = textRange.getEndOffset();\n    while (!iterator.atEnd()) {\n      final int itStart = iterator.getStart();\n      if (itStart > localEndOffset) break;\n      final int itEnd = iterator.getEnd();\n      if (itEnd < localOffset) continue;\n      final int start = Math.max(itStart, localOffset) - localOffset + offset;\n      final int end = Math.min(itEnd, localEndOffset) - localOffset + offset;\n      markupModel.addRangeHighlighter(start, end, HighlighterLayer.SYNTAX, iterator.getTextAttributes(),\n                                      HighlighterTargetArea.EXACT_RANGE);\n\n      iterator.advance();\n    }\n    if (myDoSaveErrorsToHistory) {\n      duplicateHighlighters(markupModel, consoleEditor.getDocument().getMarkupModel(myProject), offset, textRange);\n      duplicateHighlighters(markupModel, consoleEditor.getMarkupModel(), offset, textRange);\n    }\n    if (!text.endsWith(\"\\n\")) {\n      appendToHistoryDocument(history, \"\\n\");\n    }\n    return text;\n  }","id":79577,"modified_method":"private String addTextRangeToHistory(TextRange textRange, final EditorEx consoleEditor) {\n    final DocumentImpl history = (DocumentImpl)myHistoryViewer.getDocument();\n    final MarkupModel markupModel = history.getMarkupModel(myProject);\n    appendToHistoryDocument(history, myPrompt);\n    markupModel.addRangeHighlighter(history.getTextLength() - myPrompt.length(), history.getTextLength(), HighlighterLayer.SYNTAX,\n                                    ConsoleViewContentType.USER_INPUT.getAttributes(),\n                                    HighlighterTargetArea.EXACT_RANGE);\n\n    final String text = consoleEditor.getDocument().getText(textRange);\n     //offset can be changed after text trimming after insert due to buffer constraints\n    appendToHistoryDocument(history, text);\n    int offset = history.getTextLength() - text.length();\n    final int localStartOffset = textRange.getStartOffset();\n    final HighlighterIterator iterator = consoleEditor.getHighlighter().createIterator(localStartOffset);\n    final int localEndOffset = textRange.getEndOffset();\n    while (!iterator.atEnd()) {\n      final int itStart = iterator.getStart();\n      if (itStart > localEndOffset) break;\n      final int itEnd = iterator.getEnd();\n      if (itEnd >= localStartOffset) {\n        final int start = Math.max(itStart, localStartOffset) - localStartOffset + offset;\n        final int end = Math.min(itEnd, localEndOffset) - localStartOffset + offset;\n        markupModel.addRangeHighlighter(start, end, HighlighterLayer.SYNTAX, iterator.getTextAttributes(),\n                                        HighlighterTargetArea.EXACT_RANGE);\n      }\n      iterator.advance();\n    }\n    if (myDoSaveErrorsToHistory) {\n      duplicateHighlighters(markupModel, consoleEditor.getDocument().getMarkupModel(myProject), offset, textRange);\n      duplicateHighlighters(markupModel, consoleEditor.getMarkupModel(), offset, textRange);\n    }\n    if (!text.endsWith(\"\\n\")) {\n      appendToHistoryDocument(history, \"\\n\");\n    }\n    return text;\n  }","commit_id":"7194dd37c1cc8ce1d1e571e5b196e80ac98f9455","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void printToHistory(@NotNull final List<Pair<String, TextAttributes>> attributedText) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"printToHistory(): \" + attributedText.size());\n    }\n    final boolean scrollToEnd = shouldScrollHistoryToEnd();\n    final int[] offsets = new int[attributedText.size() + 1];\n    int i = 0;\n    offsets[i] = 0;\n    final StringBuilder sb = new StringBuilder();\n    for (final Pair<String, TextAttributes> pair : attributedText) {\n      sb.append(StringUtil.convertLineSeparators(pair.getFirst()));\n      offsets[++i] = sb.length();\n    }\n    final DocumentEx history = myHistoryViewer.getDocument();\n    final int oldHistoryLength = history.getTextLength();\n    appendToHistoryDocument(history, sb.toString());\n    assert oldHistoryLength + offsets[i] == history.getTextLength()\n      : \"unexpected history length \" + oldHistoryLength + \" \" + offsets[i] + \" \" + history.getTextLength();\n    LOG.debug(\"printToHistory(): text processed\");\n    final MarkupModel markupModel = DocumentMarkupModel.forDocument(history, myProject, true);\n    i = 0;\n    for (final Pair<String, TextAttributes> pair : attributedText) {\n      markupModel.addRangeHighlighter(\n        oldHistoryLength + offsets[i],\n        oldHistoryLength + offsets[i+1],\n        HighlighterLayer.SYNTAX,\n        pair.getSecond(),\n        HighlighterTargetArea.EXACT_RANGE\n      );\n      ++i;\n    }\n    LOG.debug(\"printToHistory(): markup added\");\n    if (scrollToEnd) {\n      scrollHistoryToEnd();\n    }\n    queueUiUpdate(scrollToEnd);\n    LOG.debug(\"printToHistory(): completed\");\n  }","id":79578,"modified_method":"public void printToHistory(@NotNull final List<Pair<String, TextAttributes>> attributedText) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"printToHistory(): \" + attributedText.size());\n    }\n    final boolean scrollToEnd = shouldScrollHistoryToEnd();\n    final int[] offsets = new int[attributedText.size() + 1];\n    int i = 0;\n    offsets[i] = 0;\n    final StringBuilder sb = new StringBuilder();\n    for (final Pair<String, TextAttributes> pair : attributedText) {\n      sb.append(StringUtil.convertLineSeparators(pair.getFirst()));\n      offsets[++i] = sb.length();\n    }\n    final DocumentEx history = myHistoryViewer.getDocument();\n    final int oldHistoryLength = history.getTextLength();\n    appendToHistoryDocument(history, sb.toString());\n\n    assert oldHistoryLength + offsets[i] >= history.getTextLength()\n      : \"unexpected history length \" + oldHistoryLength + \" \" + offsets[i] + \" \" + history.getTextLength();\n\n    if (oldHistoryLength + offsets[i] != history.getTextLength()) {\n      // due to usage of cyclic buffer old text can be dropped\n      final int correction = oldHistoryLength + offsets[i] - history.getTextLength();\n      for (i = 0; i < offsets.length; ++i) {\n        offsets[i] -= correction;\n      }\n    }\n    LOG.debug(\"printToHistory(): text processed\");\n    final MarkupModel markupModel = DocumentMarkupModel.forDocument(history, myProject, true);\n    i = 0;\n    for (final Pair<String, TextAttributes> pair : attributedText) {\n      if (offsets[i] >= 0) {\n        markupModel.addRangeHighlighter(\n          oldHistoryLength + offsets[i],\n          oldHistoryLength + offsets[i+1],\n          HighlighterLayer.SYNTAX,\n          pair.getSecond(),\n          HighlighterTargetArea.EXACT_RANGE\n        );\n      }\n      ++i;\n    }\n    LOG.debug(\"printToHistory(): markup added\");\n    if (scrollToEnd) {\n      scrollHistoryToEnd();\n    }\n    queueUiUpdate(scrollToEnd);\n    LOG.debug(\"printToHistory(): completed\");\n  }","commit_id":"967ebcb6552ad0c2f7b0334f4ef7a25cf58429f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IFile createFile(final String name, final IContainer container, final String content,\n\t\t\tfinal IProgressMonitor progressMonitor) {\n\t\tfinal IFile file = container.getFile(new Path(name));\n\t\tassertExist(file.getParent());\n\t\ttry {\n\t\t\tfinal InputStream stream = new ByteArrayInputStream(content.getBytes(file.getCharset()));\n\t\t\tif (file.exists()) {\n\t\t\t\tfile.setContents(stream, true, true, progressMonitor);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfile.create(stream, true, progressMonitor);\n\t\t\t}\n\t\t\tstream.close();\n\t\t}\n\t\tcatch (final Exception e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t\tprogressMonitor.worked(1);\n\n\t\treturn file;\n\t}","id":79579,"modified_method":"public static IFile createFile(final String name, final IContainer container, final String content,\n\t\t\tfinal IProgressMonitor progressMonitor) {\n\t\tfinal IFile file = container.getFile(new Path(name));\n\t\tassertExist(file.getParent());\n\t\tSubMonitor subMonitor = SubMonitor.convert(progressMonitor, 1);\n\t\ttry {\n\t\t\tfinal InputStream stream = new ByteArrayInputStream(content.getBytes(file.getCharset()));\n\t\t\tif (file.exists()) {\n\t\t\t\tfile.setContents(stream, true, true, subMonitor.newChild(1));\n\t\t\t} else {\n\t\t\t\tfile.create(stream, true, subMonitor.newChild(1));\n\t\t\t}\n\t\t\tstream.close();\n\t\t} catch (final Exception e) {\n\t\t\tlogger.error(e);\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t\treturn file;\n\t}","commit_id":"d05ca51f984ba02f0f4e8d970f6e5c4af84cace8","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param name\n\t *            of the destination file\n\t * @param container\n\t *            directory containing the the destination file\n\t * @param contentUrl\n\t *            Url pointing to the src of the content\n\t * @param progressMonitor\n\t *            used to interact with and show the user the current operation\n\t *            status\n\t * @return\n\t */\n\tpublic static IFile createFile(final String name, final IContainer container, final URL contentUrl,\n\t\t\tfinal IProgressMonitor progressMonitor) {\n\n\t\tfinal IFile file = container.getFile(new Path(name));\n\t\tInputStream inputStream = null;\n\t\ttry {\n\t\t\tinputStream = contentUrl.openStream();\n\t\t\tif (file.exists()) {\n\t\t\t\tfile.setContents(inputStream, true, true, progressMonitor);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfile.create(inputStream, true, progressMonitor);\n\t\t\t}\n\t\t\tinputStream.close();\n\t\t}\n\t\tcatch (final Exception e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (null != inputStream) {\n\t\t\t\ttry {\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (final IOException e) {\n\t\t\t\t\tlogger.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprogressMonitor.worked(1);\n\n\t\treturn file;\n\t}","id":79580,"modified_method":"/**\n\t * @param name\n\t *            of the destination file\n\t * @param container\n\t *            directory containing the the destination file\n\t * @param contentUrl\n\t *            Url pointing to the src of the content\n\t * @param progressMonitor\n\t *            used to interact with and show the user the current operation\n\t *            status\n\t * @return\n\t */\n\tpublic static IFile createFile(final String name, final IContainer container, final URL contentUrl,\n\t\t\tfinal IProgressMonitor progressMonitor) {\n\t\tfinal IFile file = container.getFile(new Path(name));\n\t\tSubMonitor subMonitor = SubMonitor.convert(progressMonitor, 1);\n\t\ttry {\n\t\t\tInputStream inputStream = null;\n\t\t\ttry {\n\t\t\t\tinputStream = contentUrl.openStream();\n\t\t\t\tif (file.exists()) {\n\t\t\t\t\tfile.setContents(inputStream, true, true, subMonitor.newChild(1));\n\t\t\t\t} else {\n\t\t\t\t\tfile.create(inputStream, true, subMonitor.newChild(1));\n\t\t\t\t}\n\t\t\t\tinputStream.close();\n\t\t\t} catch (final Exception e) {\n\t\t\t\tlogger.error(e);\n\t\t\t} finally {\n\t\t\t\tif (null != inputStream) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinputStream.close();\n\t\t\t\t\t} catch (final IOException e) {\n\t\t\t\t\t\tlogger.error(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t\treturn file;\n\t}","commit_id":"d05ca51f984ba02f0f4e8d970f6e5c4af84cace8","url":"https://github.com/eclipse/xtext"},{"original_method":"public static IProject createProject(final String projectName, final IPath location, final List<String> srcFolders,\n\t\t\tfinal List<IProject> referencedProjects, final Set<String> requiredBundles,\n\t\t\tfinal List<String> exportedPackages, final List<String> importedPackages,\n\t\t\tfinal String activatorClassName,\n\t\t\tfinal IProgressMonitor progressMonitor,\tfinal Shell theShell,String[] projectNatures,\n\t\t\tIWorkingSet[] workingSets, IWorkbench workbench) {\n\n\t\tIProject project = null;\n\t\ttry {\n\t\t\tprogressMonitor.beginTask(\"\", 10);\n\t\t\tprogressMonitor.subTask(\"Creating project \" + projectName);\n\t\t\tfinal IWorkspace workspace = ResourcesPlugin.getWorkspace();\n\t\t\tproject = workspace.getRoot().getProject(projectName);\n\n\t\t\t// Clean up any old project information.\n\t\t\tif (project.exists()) {\n\t\t\t\tfinal boolean[] result = new boolean[1];\n\t\t\t\tPlatformUI.getWorkbench().getDisplay().syncExec(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tresult[0] = MessageDialog.openQuestion(theShell, \"Do you want to overwrite the project \"\n\t\t\t\t\t\t\t\t+ projectName, \"Note that everything inside the project '\" + projectName\n\t\t\t\t\t\t\t\t+ \"' will be deleted if you confirm this dialog.\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (result[0]) {\n\t\t\t\t\tproject.delete(true, true, new SubProgressMonitor(progressMonitor, 1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfinal IJavaProject javaProject = JavaCore.create(project);\n\t\t\tfinal IProjectDescription projectDescription = ResourcesPlugin.getWorkspace().newProjectDescription(\n\t\t\t\t\tprojectName);\n\t\t\tprojectDescription.setLocation(location);\n\t\t\tproject.create(projectDescription, new SubProgressMonitor(progressMonitor, 1));\n\t\t\tfinal List<IClasspathEntry> classpathEntries = new ArrayList<IClasspathEntry>();\n\t\t\tif (referencedProjects.size() != 0) {\n\t\t\t\tprojectDescription.setReferencedProjects(referencedProjects.toArray(new IProject[referencedProjects\n\t\t\t\t\t\t.size()]));\n\t\t\t\tfor (final IProject referencedProject : referencedProjects) {\n\t\t\t\t\tfinal IClasspathEntry referencedProjectClasspathEntry = JavaCore.newProjectEntry(referencedProject\n\t\t\t\t\t\t\t.getFullPath());\n\t\t\t\t\tclasspathEntries.add(referencedProjectClasspathEntry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprojectDescription.setNatureIds(projectNatures);\n\n\t\t\tfinal ICommand java = projectDescription.newCommand();\n\t\t\tjava.setBuilderName(JavaCore.BUILDER_ID);\n\n\t\t\tfinal ICommand manifest = projectDescription.newCommand();\n\t\t\tmanifest.setBuilderName(\"org.eclipse.pde.ManifestBuilder\");\n\n\t\t\tfinal ICommand schema = projectDescription.newCommand();\n\t\t\tschema.setBuilderName(\"org.eclipse.pde.SchemaBuilder\");\n\n\t\t\tprojectDescription.setBuildSpec(new ICommand[] { java, manifest, schema });\n\n\t\t\tproject.open(new SubProgressMonitor(progressMonitor, 1));\n\t\t\tproject.setDescription(projectDescription, new SubProgressMonitor(progressMonitor, 1));\n\n\t\t\tfor (final String src : srcFolders) {\n\t\t\t\tfinal IFolder srcContainer = project.getFolder(src);\n\t\t\t\tif (!srcContainer.exists()) {\n\t\t\t\t\tsrcContainer.create(false, true, new SubProgressMonitor(progressMonitor, 1));\n\t\t\t\t}\n\t\t\t\tfinal IClasspathEntry srcClasspathEntry = JavaCore.newSourceEntry(srcContainer.getFullPath());\n\t\t\t\tclasspathEntries.add(srcClasspathEntry);\n\t\t\t}\n\n\t\t\tclasspathEntries.add(JavaCore.newContainerEntry(new Path(\"org.eclipse.jdt.launching.JRE_CONTAINER\")));\n\t\t\tclasspathEntries.add(JavaCore.newContainerEntry(new Path(\"org.eclipse.pde.core.requiredPlugins\")));\n\n\t\t\tjavaProject.setRawClasspath(classpathEntries.toArray(new IClasspathEntry[classpathEntries.size()]),\n\t\t\t\t\tnew SubProgressMonitor(progressMonitor, 1));\n\n\t\t\tjavaProject.setOutputLocation(new Path(\"/\" + projectName + \"/bin\"), new SubProgressMonitor(progressMonitor,\n\t\t\t\t\t1));\n\t\t\tcreateManifest(projectName, requiredBundles, exportedPackages, importedPackages, activatorClassName, progressMonitor, project);\n\t\t\tcreateBuildProps(progressMonitor, project, srcFolders);\n\t\t}\n\t\tcatch (final Exception exception) {\n\t\t\texception.printStackTrace();\n\t\t\tlogger.error(exception);\n\t\t}\n\t\tfinally {\n\t\t\tprogressMonitor.done();\n\t\t}\n\n\t\tif (workbench != null && workingSets != null)\n\t\t\tworkbench.getWorkingSetManager().addToWorkingSets(project,\n\t\t\t\tworkingSets);\n\t\treturn project ;\n\t\t\n\t}","id":79581,"modified_method":"public static IProject createProject(final String projectName, final IPath location, final List<String> srcFolders,\n\t\t\tfinal List<IProject> referencedProjects, final Set<String> requiredBundles,\n\t\t\tfinal List<String> exportedPackages, final List<String> importedPackages, final String activatorClassName,\n\t\t\tfinal IProgressMonitor monitor, final Shell theShell, String[] projectNatures, IWorkingSet[] workingSets,\n\t\t\tIWorkbench workbench) {\n\n\t\tIProject project = null;\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 10);\n\t\ttry {\n\t\t\tsubMonitor.subTask(\"Creating project \" + projectName);\n\t\t\tfinal IWorkspace workspace = ResourcesPlugin.getWorkspace();\n\t\t\tproject = workspace.getRoot().getProject(projectName);\n\n\t\t\t// Clean up any old project information.\n\t\t\tif (project.exists()) {\n\t\t\t\tfinal boolean[] result = new boolean[1];\n\t\t\t\tPlatformUI.getWorkbench().getDisplay().syncExec(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tresult[0] = MessageDialog.openQuestion(theShell, \"Do you want to overwrite the project \"\n\t\t\t\t\t\t\t\t+ projectName, \"Note that everything inside the project '\" + projectName\n\t\t\t\t\t\t\t\t+ \"' will be deleted if you confirm this dialog.\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (result[0]) {\n\t\t\t\t\tproject.delete(true, true, subMonitor.newChild(1));\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfinal IJavaProject javaProject = JavaCore.create(project);\n\t\t\tfinal IProjectDescription projectDescription = ResourcesPlugin.getWorkspace().newProjectDescription(\n\t\t\t\t\tprojectName);\n\t\t\tprojectDescription.setLocation(location);\n\t\t\tproject.create(projectDescription, subMonitor.newChild(1));\n\t\t\tfinal List<IClasspathEntry> classpathEntries = new ArrayList<IClasspathEntry>();\n\t\t\tif (referencedProjects.size() != 0) {\n\t\t\t\tprojectDescription.setReferencedProjects(referencedProjects.toArray(new IProject[referencedProjects\n\t\t\t\t\t\t.size()]));\n\t\t\t\tfor (final IProject referencedProject : referencedProjects) {\n\t\t\t\t\tfinal IClasspathEntry referencedProjectClasspathEntry = JavaCore.newProjectEntry(referencedProject\n\t\t\t\t\t\t\t.getFullPath());\n\t\t\t\t\tclasspathEntries.add(referencedProjectClasspathEntry);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprojectDescription.setNatureIds(projectNatures);\n\n\t\t\tfinal ICommand java = projectDescription.newCommand();\n\t\t\tjava.setBuilderName(JavaCore.BUILDER_ID);\n\n\t\t\tfinal ICommand manifest = projectDescription.newCommand();\n\t\t\tmanifest.setBuilderName(\"org.eclipse.pde.ManifestBuilder\");\n\n\t\t\tfinal ICommand schema = projectDescription.newCommand();\n\t\t\tschema.setBuilderName(\"org.eclipse.pde.SchemaBuilder\");\n\n\t\t\tprojectDescription.setBuildSpec(new ICommand[] { java, manifest, schema });\n\n\t\t\tproject.open(subMonitor.newChild(1));\n\t\t\tproject.setDescription(projectDescription, subMonitor.newChild(1));\n\n\t\t\tfor (final String src : srcFolders) {\n\t\t\t\tfinal IFolder srcContainer = project.getFolder(src);\n\t\t\t\tif (!srcContainer.exists()) {\n\t\t\t\t\tsrcContainer.create(false, true, subMonitor.newChild(1));\n\t\t\t\t}\n\t\t\t\tfinal IClasspathEntry srcClasspathEntry = JavaCore.newSourceEntry(srcContainer.getFullPath());\n\t\t\t\tclasspathEntries.add(srcClasspathEntry);\n\t\t\t}\n\n\t\t\tclasspathEntries.add(JavaCore.newContainerEntry(new Path(\"org.eclipse.jdt.launching.JRE_CONTAINER\")));\n\t\t\tclasspathEntries.add(JavaCore.newContainerEntry(new Path(\"org.eclipse.pde.core.requiredPlugins\")));\n\n\t\t\tjavaProject.setRawClasspath(classpathEntries.toArray(new IClasspathEntry[classpathEntries.size()]),\n\t\t\t\t\tsubMonitor.newChild(1));\n\n\t\t\tjavaProject.setOutputLocation(new Path(\"/\" + projectName + \"/bin\"), subMonitor.newChild(1));\n\t\t\tcreateManifest(projectName, requiredBundles, exportedPackages, importedPackages, activatorClassName,\n\t\t\t\t\tsubMonitor.newChild(1), project);\n\t\t\tcreateBuildProps(subMonitor.newChild(1), project, srcFolders);\n\t\t\tif (workbench != null && workingSets != null)\n\t\t\t\tworkbench.getWorkingSetManager().addToWorkingSets(project, workingSets);\n\t\t} catch (final Exception exception) {\n\t\t\texception.printStackTrace();\n\t\t\tlogger.error(exception);\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t\treturn project;\n\t}","commit_id":"d05ca51f984ba02f0f4e8d970f6e5c4af84cace8","url":"https://github.com/eclipse/xtext"},{"original_method":"private static void createManifest(final String projectName, final Set<String> requiredBundles,\n\t\t\tfinal List<String> exportedPackages, final List<String> importedPackages,\n\t\t\tfinal String activatorClassName,\n\t\t\tfinal IProgressMonitor progressMonitor,\tfinal IProject project) throws CoreException {\n\t\tfinal StringBuilder mainContent = new StringBuilder(\"Manifest-Version: 1.0\\n\");\n\t\tmainContent.append(\"Bundle-ManifestVersion: 2\\n\");\n\t\tmainContent.append(\"Bundle-Name: \" + projectName + \"\\n\");\n\t\tmainContent.append(\"Bundle-Vendor: My Company\\n\");\n\t\tmainContent.append(\"Bundle-Version: 1.0.0\\n\");\n\t\tmainContent.append(\"Bundle-SymbolicName: \" + projectName.toLowerCase() + \"; singleton:=true\\n\");\n//\t\tmainContent.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n\t\tif (null != activatorClassName) {\n\t\t\tmainContent.append(\"Bundle-Activator: \" + activatorClassName + \"\\n\");\n\t\t}\n\t\tmainContent.append(\"Bundle-ActivationPolicy: lazy\\n\");\n\n\t\tif (!requiredBundles.isEmpty()) {\n\t\t\tmainContent.append(\"Require-Bundle: \");\n\t\t}\n\n\t\tfor (Iterator<String> iterator = requiredBundles.iterator(); iterator.hasNext();) {\n\t\t\tmainContent.append(\" \" + iterator.next());\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tmainContent.append(\",\");\n\t\t\t}\n\t\t\tmainContent.append(\"\\n\");\n\t\t}\n\n\t\tif (exportedPackages != null && !exportedPackages.isEmpty()) {\n\t\t\tmainContent.append(\"Export-Package: \" + exportedPackages.get(0));\n\t\t\tfor (int i = 1, x = exportedPackages.size(); i < x; i++) {\n\t\t\t\tmainContent.append(\",\\n \" + exportedPackages.get(i));\n\t\t\t}\n\t\t\tmainContent.append(\"\\n\");\n\t\t}\n\n\t\tif (importedPackages != null && !importedPackages.isEmpty()) {\n\t\t\tmainContent.append(\"Import-Package: \" + importedPackages.get(0));\n\t\t\tfor (int i = 1, x = importedPackages.size(); i < x; i++) {\n\t\t\t\tmainContent.append(\",\\n \" + importedPackages.get(i));\n\t\t\t}\n\t\t\tmainContent.append(\"\\n\");\n\t\t}\n\t\tmainContent.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n\n\t\tfinal IFolder metaInf = project.getFolder(\"META-INF\");\n\t\tmetaInf.create(false, true, new SubProgressMonitor(progressMonitor, 1));\n\t\tcreateFile(\"MANIFEST.MF\", metaInf, mainContent.toString(), progressMonitor);\n\t}","id":79582,"modified_method":"private static void createManifest(final String projectName, final Set<String> requiredBundles,\n\t\t\tfinal List<String> exportedPackages, final List<String> importedPackages, final String activatorClassName,\n\t\t\tfinal IProgressMonitor progressMonitor, final IProject project) throws CoreException {\n\t\tfinal StringBuilder mainContent = new StringBuilder(\"Manifest-Version: 1.0\\n\");\n\t\tmainContent.append(\"Bundle-ManifestVersion: 2\\n\");\n\t\tmainContent.append(\"Bundle-Name: \" + projectName + \"\\n\");\n\t\tmainContent.append(\"Bundle-Vendor: My Company\\n\");\n\t\tmainContent.append(\"Bundle-Version: 1.0.0\\n\");\n\t\tmainContent.append(\"Bundle-SymbolicName: \" + projectName.toLowerCase() + \"; singleton:=true\\n\");\n//\t\tmainContent.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n\t\tif (null != activatorClassName) {\n\t\t\tmainContent.append(\"Bundle-Activator: \" + activatorClassName + \"\\n\");\n\t\t}\n\t\tmainContent.append(\"Bundle-ActivationPolicy: lazy\\n\");\n\n\t\tif (!requiredBundles.isEmpty()) {\n\t\t\tmainContent.append(\"Require-Bundle: \");\n\t\t}\n\n\t\tfor (Iterator<String> iterator = requiredBundles.iterator(); iterator.hasNext();) {\n\t\t\tmainContent.append(\" \" + iterator.next());\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tmainContent.append(\",\");\n\t\t\t}\n\t\t\tmainContent.append(\"\\n\");\n\t\t}\n\n\t\tif (exportedPackages != null && !exportedPackages.isEmpty()) {\n\t\t\tmainContent.append(\"Export-Package: \" + exportedPackages.get(0));\n\t\t\tfor (int i = 1, x = exportedPackages.size(); i < x; i++) {\n\t\t\t\tmainContent.append(\",\\n \" + exportedPackages.get(i));\n\t\t\t}\n\t\t\tmainContent.append(\"\\n\");\n\t\t}\n\n\t\tif (importedPackages != null && !importedPackages.isEmpty()) {\n\t\t\tmainContent.append(\"Import-Package: \" + importedPackages.get(0));\n\t\t\tfor (int i = 1, x = importedPackages.size(); i < x; i++) {\n\t\t\t\tmainContent.append(\",\\n \" + importedPackages.get(i));\n\t\t\t}\n\t\t\tmainContent.append(\"\\n\");\n\t\t}\n\t\tmainContent.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n\n\t\tfinal IFolder metaInf = project.getFolder(\"META-INF\");\n\t\tSubMonitor subMonitor = SubMonitor.convert(progressMonitor, 2);\n\t\ttry {\n\t\t\tmetaInf.create(false, true, subMonitor.newChild(1));\n\t\t\tcreateFile(\"MANIFEST.MF\", metaInf, mainContent.toString(), subMonitor.newChild(1));\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","commit_id":"d05ca51f984ba02f0f4e8d970f6e5c4af84cace8","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void execute(final IProgressMonitor monitor) throws CoreException, InvocationTargetException,\n\t\t\tInterruptedException {\n\t\tmonitor.beginTask(Messages.XtextProjectCreator_CreatingProjectsMessage2\n\t\t\t\t+ getXtextProjectInfo().getProjectName(), 3);\n\n\t\tIProject project = createDslProject(monitor);\n\n\t\tcreateDslUiProject(monitor);\n\n\t\tif (getXtextProjectInfo().isCreateGeneratorProject()) {\n\t\t\tcreateGeneratorProject(monitor);\n\t\t}\n\n\t\tIFile dslGrammarFile = project.getFile(new Path(SRC_ROOT\n\t\t\t\t+ \"/\" + getXtextProjectInfo().getLanguageName().replace('.', '/') //$NON-NLS-1$\n\t\t\t\t+ \".xtext\")); //$NON-NLS-1$\n\t\tBasicNewResourceWizard.selectAndReveal(dslGrammarFile, PlatformUI.getWorkbench().getActiveWorkbenchWindow());\n\t\tsetResult(dslGrammarFile);\n\t}","id":79583,"modified_method":"@Override\n\tprotected void execute(final IProgressMonitor monitor) throws CoreException, InvocationTargetException,\n\t\t\tInterruptedException {\n\t\tSubMonitor subMonitor = SubMonitor.convert(\n\t\t\t\tmonitor, \n\t\t\t\tMessages.XtextProjectCreator_CreatingProjectsMessage2 + getXtextProjectInfo().getProjectName(), \n\t\t\t\tgetXtextProjectInfo().isCreateGeneratorProject() ? 3 : 2);\n\n\t\tIProject project = createDslProject(subMonitor.newChild(1));\n\n\t\tcreateDslUiProject(subMonitor.newChild(1));\n\n\t\tif (getXtextProjectInfo().isCreateGeneratorProject()) {\n\t\t\tcreateGeneratorProject(subMonitor.newChild(1));\n\t\t}\n\n\t\tIFile dslGrammarFile = project.getFile(new Path(SRC_ROOT\n\t\t\t\t+ \"/\" + getXtextProjectInfo().getLanguageName().replace('.', '/') //$NON-NLS-1$\n\t\t\t\t+ \".xtext\")); //$NON-NLS-1$\n\t\tBasicNewResourceWizard.selectAndReveal(dslGrammarFile, PlatformUI.getWorkbench().getActiveWorkbenchWindow());\n\t\tsetResult(dslGrammarFile);\n\t}","commit_id":"d05ca51f984ba02f0f4e8d970f6e5c4af84cace8","url":"https://github.com/eclipse/xtext"},{"original_method":"public void updateMarker(ResourceSet resourceSet, ImmutableList<Delta> resourceDescriptionDeltas,\n\t\t\tIProgressMonitor monitor) {\n\t\tmonitor.beginTask(\"Validating\", resourceDescriptionDeltas.size());\n\t\tfor (Delta delta : resourceDescriptionDeltas) {\n\t\t\tif (delta.getNew() != null) {\n\t\t\t\tIterable<IStorage> storages = mapper.getStorages(delta.getNew().getURI());\n\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\tif (storage instanceof IFile) {\n\t\t\t\t\t\tIFile file = (IFile) storage;\n\t\t\t\t\t\tif (!file.isReadOnly()) {\n\t\t\t\t\t\t\tResource resource = resourceSet.getResource(delta.getNew().getURI(), true);\n\t\t\t\t\t\t\taddMarkers(file, resource, new SubProgressMonitor(monitor, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmonitor.done();\n\t}","id":79584,"modified_method":"public void updateMarker(ResourceSet resourceSet, ImmutableList<Delta> resourceDescriptionDeltas,\n\t\t\tIProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, resourceDescriptionDeltas.size());\n\t\tfor (Delta delta : resourceDescriptionDeltas) {\n\t\t\tif (delta.getNew() != null) {\n\t\t\t\tIterable<IStorage> storages = mapper.getStorages(delta.getNew().getURI());\n\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\tif (storage instanceof IFile) {\n\t\t\t\t\t\tIFile file = (IFile) storage;\n\t\t\t\t\t\tif (!file.isReadOnly()) {\n\t\t\t\t\t\t\tResource resource = resourceSet.getResource(delta.getNew().getURI(), true);\n\t\t\t\t\t\t\taddMarkers(file, resource, subMonitor.newChild(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubMonitor.done();\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void addMarkers(IFile file, Resource resource, final IProgressMonitor monitor) {\n\t\ttry {\n\t\t\tmonitor.beginTask(\"Validating \"+resource.getURI(), 2);\n\t\t\tIResourceServiceProvider provider = resourceServiceProviderRegistry.getResourceServiceProvider(resource\n\t\t\t\t\t.getURI(), null);\n\t\t\t\n\t\t\tList<Issue> list = provider.getResourceValidator().validate(resource, CheckMode.FAST_ONLY,\n\t\t\t\t\tgetCancelIndicator(monitor));\n\t\t\tif (monitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tfile.deleteMarkers(MarkerTypes.FAST_VALIDATION, true, 1);\n\t\t\tfor (Issue issue : list) {\n\t\t\t\tmarkerCreator.createMarker(issue, file, MarkerTypes.FAST_VALIDATION);\n\t\t\t}\n\t\t\t\n\t\t\tlist = provider.getResourceValidator().validate(resource, CheckMode.NORMAL_ONLY,\n\t\t\t\t\tgetCancelIndicator(monitor));\n\t\t\tmonitor.worked(1);\n\t\t\tfile.deleteMarkers(MarkerTypes.NORMAL_VALIDATION, true, 1);\n\t\t\tif (monitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tfor (Issue issue : list) {\n\t\t\t\tmarkerCreator.createMarker(issue, file, MarkerTypes.NORMAL_VALIDATION);\n\t\t\t}\n\t\t\tmonitor.done();\n\t\t} catch (CoreException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t}\n\t}","id":79585,"modified_method":"protected void addMarkers(IFile file, Resource resource, final IProgressMonitor monitor) {\n\t\ttry {\n\t\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\t\tIResourceServiceProvider provider = resourceServiceProviderRegistry.getResourceServiceProvider(resource\n\t\t\t\t\t.getURI(), null);\n\t\t\t\n\t\t\tList<Issue> list = provider.getResourceValidator().validate(resource, CheckMode.FAST_ONLY,\n\t\t\t\t\tgetCancelIndicator(subMonitor));\n\t\t\tif (monitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tfile.deleteMarkers(MarkerTypes.FAST_VALIDATION, true, 1);\n\t\t\tfor (Issue issue : list) {\n\t\t\t\tmarkerCreator.createMarker(issue, file, MarkerTypes.FAST_VALIDATION);\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t\t\n\t\t\tlist = provider.getResourceValidator().validate(resource, CheckMode.NORMAL_ONLY,\n\t\t\t\t\tgetCancelIndicator(monitor));\n\t\t\tsubMonitor.worked(1);\n\t\t\tfile.deleteMarkers(MarkerTypes.NORMAL_VALIDATION, true, 1);\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tfor (Issue issue : list) {\n\t\t\t\tmarkerCreator.createMarker(issue, file, MarkerTypes.NORMAL_VALIDATION);\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t}\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * This method computes the {@link IResourceDescription}s for all affected (i.e. added, updated or transitively\n\t * affected) resources. It does not change any state in the underlying\n\t * {@link org.eclipse.xtext.resource.IResourceDescriptions} instance.\n\t * \n\t * @param rs\n\t *            - The ResourceSet to use for reloading the to be updated resources\n\t * @param toBeUpdated\n\t *            - the URIs which have to be reloaded\n\t * @param toBeDeleted\n\t *            - the URIs which are about to be deleted\n\t * @return returns an iterable of fresh {@link IResourceDescription} for all resources, which are affected by the\n\t *         change (i.e. the to BeUpdated and toBeDeleted resources)\n\t */\n\tpublic Iterable<Delta> transitiveUpdate(IResourceDescriptions resourceDescriptions, final ResourceSet rs,\n\t\t\tSet<URI> toBeUpdated, Set<URI> toBeDeleted, IProgressMonitor monitor) {\n\t\tHashSet<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\n\t\ttoBeDeletedAsSet.removeAll(Collections2.forIterable(toBeUpdated));\n\n\t\tMap<URI, Delta> result = Maps.newHashMap();\n\t\t// add deleted\n\t\tfor (URI toDelete : toBeDeletedAsSet) {\n\t\t\tIResourceDescription resourceDescription = resourceDescriptions.getResourceDescription(toDelete);\n\t\t\tif (resourceDescription != null)\n\t\t\t\tresult.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\n\t\t}\n\t\tmonitor.beginTask(\"Transitive update \", 3);\n\n\t\t// add toBeUpdated\n\t\tresult.putAll(update(resourceDescriptions, rs, toBeUpdated, new SubProgressMonitor(monitor, 1)));\n\n\t\t// add transient\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (monitor.isCanceled())\n\t\t\t\t\treturn Iterables.emptyIterable();\n\t\t\t\tSet<IResourceDescription> descriptions = findAffectedResourceDescriptions(resourceDescriptions, result\n\t\t\t\t\t\t.values());\n\t\t\t\tSet<URI> uris = Sets.newHashSet(Iterables.transform(descriptions,\n\t\t\t\t\t\tnew Function<IResourceDescription, URI>() {\n\t\t\t\t\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\t\t\t\t\treturn from.getURI();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\turis.removeAll(result.keySet());\n\t\t\t\tif (!uris.isEmpty()) {\n\t\t\t\t\tresult.putAll(update(resourceDescriptions, rs, uris, new SubProgressMonitor(monitor, 1)));\n\t\t\t\t} else {\n\t\t\t\t\treturn result.values();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tmonitor.done();\n\t\t}\n\t}","id":79586,"modified_method":"/**\n\t * This method computes the {@link IResourceDescription}s for all affected (i.e. added, updated or transitively\n\t * affected) resources. It does not change any state in the underlying\n\t * {@link org.eclipse.xtext.resource.IResourceDescriptions} instance.\n\t * \n\t * @param rs\n\t *            - The ResourceSet to use for reloading the to be updated resources\n\t * @param toBeUpdated\n\t *            - the URIs which have to be reloaded\n\t * @param toBeDeleted\n\t *            - the URIs which are about to be deleted\n\t * @return returns an iterable of fresh {@link IResourceDescription} for all resources, which are affected by the\n\t *         change (i.e. the to BeUpdated and toBeDeleted resources)\n\t */\n\tpublic Iterable<Delta> transitiveUpdate(IResourceDescriptions resourceDescriptions, final ResourceSet rs,\n\t\t\tSet<URI> toBeUpdated, Set<URI> toBeDeleted, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 1);\n\t\tHashSet<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\n\t\ttoBeDeletedAsSet.removeAll(Collections2.forIterable(toBeUpdated));\n\n\t\tMap<URI, Delta> result = Maps.newHashMap();\n\t\t// add deleted\n\t\tfor (URI toDelete : toBeDeletedAsSet) {\n\t\t\tIResourceDescription resourceDescription = resourceDescriptions.getResourceDescription(toDelete);\n\t\t\tif (resourceDescription != null)\n\t\t\t\tresult.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\n\t\t}\n\n\t\t// add toBeUpdated\n\t\tresult.putAll(update(resourceDescriptions, rs, toBeUpdated, subMonitor.newChild(1)));\n\n\t\t// add transient\n\t\twhile (true) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn Iterables.emptyIterable();\n\t\t\tsubMonitor.setWorkRemaining(1);\n\t\t\tSet<IResourceDescription> descriptions = findAffectedResourceDescriptions(resourceDescriptions, result\n\t\t\t\t\t.values());\n\t\t\tSet<URI> uris = Sets.newHashSet(Iterables.transform(descriptions,\n\t\t\t\t\tnew Function<IResourceDescription, URI>() {\n\t\t\t\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\t\t\t\treturn from.getURI();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\turis.removeAll(result.keySet());\n\t\t\tif (!uris.isEmpty()) {\n\t\t\t\tresult.putAll(update(resourceDescriptions, rs, uris, subMonitor.newChild(1)));\n\t\t\t} else {\n\t\t\t\treturn result.values();\n\t\t\t}\n\t\t}\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"private Map<URI, Delta> update(IResourceDescriptions resourceDescriptions, final ResourceSet set,\n\t\t\tSet<URI> toBeUpdated, IProgressMonitor monitor) {\n\t\tmonitor.beginTask(\"Updating resources...\", toBeUpdated.size() * 2);\n\t\tfor (URI uri : toBeUpdated) {\n\t\t\ttry {\n\t\t\t\tset.getResource(uri, true);\n\t\t\t\tmonitor.worked(1);\n\t\t\t} catch (WrappedException ex) {\n\t\t\t\tlog.error(\"Error loading resource from: \" + uri.toString(), ex);\n\t\t\t}\n\t\t}\n\t\tMap<URI, Delta> result = Maps.newHashMap();\n\t\tfor (URI uri : toBeUpdated) {\n\t\t\tManager manager = getResourceDescriptionManager(uri);\n\t\t\tif (manager != null) {\n\t\t\t\tResource resource = set.getResource(uri, false);\n\t\t\t\tIResourceDescription description = manager.getResourceDescription(resource);\n\t\t\t\tresult.put(uri, new DefaultResourceDescriptionDelta(resourceDescriptions.getResourceDescription(uri),\n\t\t\t\t\t\tdescription));\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\t\t}\n\t\tmonitor.done();\n\t\treturn result;\n\t}","id":79587,"modified_method":"private Map<URI, Delta> update(IResourceDescriptions resourceDescriptions, final ResourceSet set,\n\t\t\tSet<URI> toBeUpdated, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, toBeUpdated.size() * 2);\n\t\tfor (URI uri : toBeUpdated) {\n\t\t\ttry {\n\t\t\t\tset.getResource(uri, true);\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t} catch (WrappedException ex) {\n\t\t\t\tlog.error(\"Error loading resource from: \" + uri.toString(), ex);\n\t\t\t}\n\t\t}\n\t\tMap<URI, Delta> result = Maps.newHashMap();\n\t\tfor (URI uri : toBeUpdated) {\n\t\t\tManager manager = getResourceDescriptionManager(uri);\n\t\t\tif (manager != null) {\n\t\t\t\tResource resource = set.getResource(uri, false);\n\t\t\t\tIResourceDescription description = manager.getResourceDescription(resource);\n\t\t\t\tresult.put(uri, new DefaultResourceDescriptionDelta(resourceDescriptions.getResourceDescription(uri),\n\t\t\t\t\t\tdescription));\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"public ToBeBuilt removeProject(IProject project, final IProgressMonitor monitor) {\n\t\tToBeBuilt result = new ToBeBuilt();\n\t\tfor (IResourceDescription iResourceDescription : builderState.getAllResourceDescriptions()) {\n\t\t\tResourceDescriptionImpl descImpl = (ResourceDescriptionImpl) iResourceDescription;\n\t\t\tIterable<IStorage> storages = mapper.getStorages(descImpl.getURI());\n\t\t\tfor (IStorage storage : storages) {\n\t\t\t\tif (isOnProject(storage, project))\n\t\t\t\t\tresult.getToBeDeleted().add(descImpl.getURI());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":79588,"modified_method":"public ToBeBuilt removeProject(IProject project, final IProgressMonitor monitor) {\n\t\tToBeBuilt result = new ToBeBuilt();\n\t\tSubMonitor.convert(monitor, 0);\n\t\tIterable<IResourceDescription> allResourceDescriptions = builderState.getAllResourceDescriptions();\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, Collections2.forIterable(allResourceDescriptions).size());\n\t\tfor (IResourceDescription iResourceDescription : allResourceDescriptions) {\n\t\t\tResourceDescriptionImpl descImpl = (ResourceDescriptionImpl) iResourceDescription;\n\t\t\tIterable<IStorage> storages = mapper.getStorages(descImpl.getURI());\n\t\t\tfor (IStorage storage : storages) {\n\t\t\t\tif (isOnProject(storage, project))\n\t\t\t\t\tresult.getToBeDeleted().add(descImpl.getURI());\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void incrementalBuild(IResourceDelta delta, final IProgressMonitor monitor) throws CoreException {\n\t\tfinal ToBeBuilt toBeBuilt = new ToBeBuilt();\n\t\tmonitor.beginTask(\"incremental build\", 2);\n\t\tIResourceDeltaVisitor visitor = new IResourceDeltaVisitor() {\n\t\t\tpublic boolean visit(IResourceDelta delta) throws CoreException {\n\t\t\t\tif (delta.getResource() instanceof IStorage) {\n\t\t\t\t\tif (delta.getKind() == IResourceDelta.REMOVED) {\n\t\t\t\t\t\treturn toBeBuiltComputer.removeStorage(monitor, toBeBuilt, (IStorage) delta.getResource());\n\t\t\t\t\t} else if (delta.getKind() == IResourceDelta.ADDED || delta.getKind() == IResourceDelta.CHANGED) {\n\t\t\t\t\t\treturn toBeBuiltComputer.updateStorage(monitor, toBeBuilt, (IStorage) delta.getResource());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tdelta.accept(visitor);\n\t\tmonitor.worked(1);\n\t\tdoBuild(toBeBuilt, new SubProgressMonitor(monitor, 1));\n\t\tmonitor.done();\n\t}","id":79589,"modified_method":"protected void incrementalBuild(IResourceDelta delta, final IProgressMonitor monitor) throws CoreException {\n\t\tfinal ToBeBuilt toBeBuilt = new ToBeBuilt();\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\tIResourceDeltaVisitor visitor = new IResourceDeltaVisitor() {\n\t\t\tpublic boolean visit(IResourceDelta delta) throws CoreException {\n\t\t\t\tif (delta.getResource() instanceof IStorage) {\n\t\t\t\t\tif (delta.getKind() == IResourceDelta.REMOVED) {\n\t\t\t\t\t\treturn toBeBuiltComputer.removeStorage(monitor, toBeBuilt, (IStorage) delta.getResource());\n\t\t\t\t\t} else if (delta.getKind() == IResourceDelta.ADDED || delta.getKind() == IResourceDelta.CHANGED) {\n\t\t\t\t\t\treturn toBeBuiltComputer.updateStorage(monitor, toBeBuilt, (IStorage) delta.getResource());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tdelta.accept(visitor);\n\t\tsubMonitor.worked(1);\n\t\tdoBuild(toBeBuilt, subMonitor.newChild(1));\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void fullBuild(final IProgressMonitor monitor) throws CoreException {\n\t\tIProject project = getProject();\n\t\tmonitor.beginTask(\"full build\", 2);\n\t\tfinal ToBeBuilt toBeBuilt = toBeBuiltComputer.updateProject(project, new SubProgressMonitor(monitor, 1));\n\t\tdoBuild(toBeBuilt, new SubProgressMonitor(monitor, 1));\n\t\tmonitor.done();\n\t}","id":79590,"modified_method":"protected void fullBuild(final IProgressMonitor monitor) throws CoreException {\n\t\tIProject project = getProject();\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\tfinal ToBeBuilt toBeBuilt = toBeBuiltComputer.updateProject(project, subMonitor.newChild(1));\n\t\tdoBuild(toBeBuilt, subMonitor.newChild(1));\n\t\tmonitor.done();\n\t}","commit_id":"5e903fdf2f4617ee5dd2b21aa29323bea202cfea","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public void actionPerformed(AnActionEvent e) {\n      DialogBuilder dialog = new DialogBuilder(myProject);\n\n      final PythonPathEditor editor =\n        new PythonPathEditor(\"Classes\", OrderRootType.CLASSES, FileChooserDescriptorFactory.createAllButJarContentsDescriptor()) {\n          @Override\n          protected void onReloadButtonClicked() {\n            reloadSdk();\n          }\n        };\n      final JComponent component = editor.createComponent();\n      component.setPreferredSize(new Dimension(600, 400));\n      component.setBorder(IdeBorderFactory.createBorder(SideBorder.ALL));\n      dialog.setCenterPanel(component);\n      editor.reload(getSelectedSdk().getSdkModificator());\n\n      dialog.setTitle(\"Interpreter Paths\");\n      dialog.show();\n      updateOkButton();\n    }","id":79591,"modified_method":"@Override\n    public void actionPerformed(AnActionEvent e) {\n      DialogBuilder dialog = new DialogBuilder(myProject);\n\n      final PythonPathEditor editor =\n        new PythonPathEditor(\"Classes\", OrderRootType.CLASSES, FileChooserDescriptorFactory.createAllButJarContentsDescriptor()) {\n          @Override\n          protected void onReloadButtonClicked() {\n            reloadSdk();\n          }\n        };\n      final JComponent component = editor.createComponent();\n      component.setPreferredSize(new Dimension(600, 400));\n      component.setBorder(IdeBorderFactory.createBorder(SideBorder.ALL));\n      dialog.setCenterPanel(component);\n      final Sdk sdk = getSelectedSdk();\n      if (sdk != null) {\n        editor.reload(sdk.getSdkModificator());\n      }\n\n      dialog.setTitle(\"Interpreter Paths\");\n      dialog.show();\n      updateOkButton();\n    }","commit_id":"07226734334096dff765630a34d196dd4b38cf8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void apply() throws ConfigurationException {\n    AndroidSdkAdditionalData newData = new AndroidSdkAdditionalData(mySdk, myForm.getSelectedSdk());\n    newData.setBuildTarget(myForm.getSelectedBuildTarget());\n    final SdkModificator modificator = mySdk.getSdkModificator();\n    modificator.setSdkAdditionalData(newData);\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        modificator.commitChanges();\n      }\n    });\n  }","id":79592,"modified_method":"@Override\n  public void apply() throws ConfigurationException {\n    final Sdk javaSdk = myForm.getSelectedSdk();\n    AndroidSdkAdditionalData newData = new AndroidSdkAdditionalData(mySdk, javaSdk);\n    newData.setBuildTarget(myForm.getSelectedBuildTarget());\n    final SdkModificator modificator = mySdk.getSdkModificator();\n    modificator.setVersionString(javaSdk != null ? javaSdk.getVersionString() : null);\n    modificator.setSdkAdditionalData(newData);\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        modificator.commitChanges();\n      }\n    });\n  }","commit_id":"3b672e3c4d7b74a949f7560bcf343c8db9772d2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isModified() {\n    final AndroidSdkAdditionalData data = (AndroidSdkAdditionalData)mySdk.getSdkAdditionalData();\n    Sdk javaSdk = data != null ? data.getJavaSdk() : null;\n    return javaSdk != myForm.getSelectedSdk();\n  }","id":79593,"modified_method":"@Override\n  public boolean isModified() {\n    final AndroidSdkAdditionalData data = (AndroidSdkAdditionalData)mySdk.getSdkAdditionalData();\n    Sdk javaSdk = data != null ? data.getJavaSdk() : null;\n    final String javaSdkHomePath = javaSdk != null ? javaSdk.getHomePath() : null;\n    final Sdk selectedSdk = myForm.getSelectedSdk();\n    final String selectedSdkHomePath = selectedSdk != null ? selectedSdk.getHomePath() : null;\n    return !FileUtil.pathsEqual(javaSdkHomePath, selectedSdkHomePath);\n  }","commit_id":"98f74685eac94db2cbcc64f01ca5806117a862f8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateBuildTargets(AndroidSdkData androidSdkData) {\n    myBuildTargetsModel.removeAllElements();\n\n    if (androidSdkData != null) {\n      for (IAndroidTarget target : androidSdkData.getTargets()) {\n        myBuildTargetsModel.addElement(target);\n      }\n    }\n  }","id":79594,"modified_method":"private void updateBuildTargets(AndroidSdkData androidSdkData, IAndroidTarget buildTarget) {\n    myBuildTargetsModel.removeAllElements();\n\n    if (androidSdkData != null) {\n      for (IAndroidTarget target : androidSdkData.getTargets()) {\n        myBuildTargetsModel.addElement(target);\n      }\n    }\n\n    if (buildTarget != null) {\n      for (int i = 0; i < myBuildTargetsModel.getSize(); i++) {\n        IAndroidTarget target = (IAndroidTarget)myBuildTargetsModel.getElementAt(i);\n        if (buildTarget.hashString().equals(target.hashString())) {\n          myBuildTargetComboBox.setSelectedIndex(i);\n          return;\n        }\n      }\n    }\n    myBuildTargetComboBox.setSelectedItem(null);\n  }","commit_id":"98f74685eac94db2cbcc64f01ca5806117a862f8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void init(@Nullable Sdk jdk, Sdk androidSdk, IAndroidTarget buildTarget) {\n    updateJdks();\n    \n    final String jdkName = jdk != null ? jdk.getName() : null;\n\n    if (androidSdk != null) {\n      for (int i = 0; i < myJdksModel.getSize(); i++) {\n        if (Comparing.strEqual(((Sdk)myJdksModel.getElementAt(i)).getName(), jdkName)) {\n          myInternalJdkComboBox.setSelectedIndex(i);\n          break;\n        }\n      }\n    }\n\n    mySdkLocation = androidSdk != null ? androidSdk.getHomePath() : null;\n    AndroidSdkData androidSdkData = mySdkLocation != null ? AndroidSdkData.parse(mySdkLocation, new EmptySdkLog()) : null;\n    updateBuildTargets(androidSdkData);\n\n    if (buildTarget != null) {\n      for (int i = 0; i < myBuildTargetsModel.getSize(); i++) {\n        IAndroidTarget target = (IAndroidTarget)myBuildTargetsModel.getElementAt(i);\n        if (buildTarget.hashString().equals(target.hashString())) {\n          myBuildTargetComboBox.setSelectedIndex(i);\n          return;\n        }\n      }\n    }\n    myBuildTargetComboBox.setSelectedItem(null);\n  }","id":79595,"modified_method":"public void init(@Nullable Sdk jdk, Sdk androidSdk, IAndroidTarget buildTarget) {\n    updateJdks();\n    \n    final String jdkName = jdk != null ? jdk.getName() : null;\n\n    if (androidSdk != null) {\n      for (int i = 0; i < myJdksModel.getSize(); i++) {\n        if (Comparing.strEqual(((Sdk)myJdksModel.getElementAt(i)).getName(), jdkName)) {\n          myInternalJdkComboBox.setSelectedIndex(i);\n          break;\n        }\n      }\n    }\n\n    mySdkLocation = androidSdk != null ? androidSdk.getHomePath() : null;\n    AndroidSdkData androidSdkData = mySdkLocation != null ? AndroidSdkData.parse(mySdkLocation, new EmptySdkLog()) : null;\n\n    myFreeze = true;\n    updateBuildTargets(androidSdkData, buildTarget);\n    myFreeze = false;\n  }","commit_id":"98f74685eac94db2cbcc64f01ca5806117a862f8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AndroidSdkConfigurableForm(@NotNull SdkModel sdkModel, @NotNull final SdkModificator sdkModificator) {\n    mySdkModel = sdkModel;\n    myInternalJdkComboBox.setModel(myJdksModel);\n    myInternalJdkComboBox.setRenderer(new ListCellRendererWrapper(myInternalJdkComboBox.getRenderer()) {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof Sdk) {\n          setText(((Sdk)value).getName());\n        }\n      }\n    });\n    myBuildTargetComboBox.setModel(myBuildTargetsModel);\n\n    myBuildTargetComboBox.setRenderer(new ListCellRendererWrapper(myBuildTargetComboBox.getRenderer()) {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof IAndroidTarget) {\n          setText(AndroidSdkUtils.getTargetPresentableName((IAndroidTarget)value));\n        }\n        else if (value == null) {\n          setText(\"<html><font color='red'>[none]<\/font><\/html>\");\n        }\n      }\n    });\n\n    myBuildTargetComboBox.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        final IAndroidTarget target = (IAndroidTarget)e.getItem();\n\n        List<OrderRoot> roots = AndroidSdkUtils.getLibraryRootsForTarget(target, mySdkLocation);\n        Map<OrderRootType, String[]> configuredRoots = new HashMap<OrderRootType, String[]>();\n\n        for (OrderRootType type : OrderRootType.getAllTypes()) {\n          final VirtualFile[] oldRoots = sdkModificator.getRoots(type);\n          final String[] oldRootPaths = new String[oldRoots.length];\n          \n          for (int i = 0; i < oldRootPaths.length; i++) {\n            oldRootPaths[i] = oldRoots[i].getPath();\n          }\n          \n          configuredRoots.put(type, oldRootPaths);\n        }\n\n        for (OrderRoot root : roots) {\n          if (e.getStateChange() == ItemEvent.DESELECTED) {\n            sdkModificator.removeRoot(root.getFile(), root.getType());\n          }\n          else {\n            String[] configuredRootsForType = configuredRoots.get(root.getType());\n            if (ArrayUtil.find(configuredRootsForType, root.getFile().getPath()) == -1) {\n              sdkModificator.addRoot(root.getFile(), root.getType());\n            }\n          }\n        }\n      }\n    });\n  }","id":79596,"modified_method":"public AndroidSdkConfigurableForm(@NotNull SdkModel sdkModel, @NotNull final SdkModificator sdkModificator) {\n    mySdkModel = sdkModel;\n    myInternalJdkComboBox.setModel(myJdksModel);\n    myInternalJdkComboBox.setRenderer(new ListCellRendererWrapper(myInternalJdkComboBox.getRenderer()) {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof Sdk) {\n          setText(((Sdk)value).getName());\n        }\n      }\n    });\n    myBuildTargetComboBox.setModel(myBuildTargetsModel);\n\n    myBuildTargetComboBox.setRenderer(new ListCellRendererWrapper(myBuildTargetComboBox.getRenderer()) {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof IAndroidTarget) {\n          setText(AndroidSdkUtils.getTargetPresentableName((IAndroidTarget)value));\n        }\n        else if (value == null) {\n          setText(\"<html><font color='red'>[none]<\/font><\/html>\");\n        }\n      }\n    });\n\n    myBuildTargetComboBox.addItemListener(new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        if (myFreeze) {\n          return;\n        }\n        final IAndroidTarget target = (IAndroidTarget)e.getItem();\n\n        List<OrderRoot> roots = AndroidSdkUtils.getLibraryRootsForTarget(target, mySdkLocation);\n        Map<OrderRootType, String[]> configuredRoots = new HashMap<OrderRootType, String[]>();\n\n        for (OrderRootType type : OrderRootType.getAllTypes()) {\n          final VirtualFile[] oldRoots = sdkModificator.getRoots(type);\n          final String[] oldRootPaths = new String[oldRoots.length];\n          \n          for (int i = 0; i < oldRootPaths.length; i++) {\n            oldRootPaths[i] = oldRoots[i].getPath();\n          }\n          \n          configuredRoots.put(type, oldRootPaths);\n        }\n\n        for (OrderRoot root : roots) {\n          if (e.getStateChange() == ItemEvent.DESELECTED) {\n            sdkModificator.removeRoot(root.getFile(), root.getType());\n          }\n          else {\n            String[] configuredRootsForType = configuredRoots.get(root.getType());\n            if (ArrayUtil.find(configuredRootsForType, root.getFile().getPath()) == -1) {\n              sdkModificator.addRoot(root.getFile(), root.getType());\n            }\n          }\n        }\n      }\n    });\n  }","commit_id":"98f74685eac94db2cbcc64f01ca5806117a862f8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getValue() {\n    String text = myElement.getText();\n    return getRangeInElement().substring(text);\n  }","id":79597,"modified_method":"@NotNull\n  public String getValue() {\n    String text = myElement.getText();\n    final TextRange range = getRangeInElement();\n    if (range.getEndOffset() > text.length() || range.getStartOffset() > text.length() || range.getStartOffset() < 0 || range.getEndOffset() < 0) {\n      LOG.error(\"Wrong range in reference \" + this + \": \" + range + \". Reference text: '\" + text + \"'\");\n      return text;\n    }\n    return range.substring(text);\n  }","commit_id":"f5de591cdf2eb501bb248317299050c7c75e5b8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void init(final PsiElement element, PsiReference reference, final PsiElement referencedElement) {\n    final Project project = element.getProject();\n    myReferencedElement = referencedElement;\n    if (referencedElement != null) {\n      myReferencedElementPointer = SmartPointerManager.getInstance(project).createSmartPsiElementPointer(referencedElement);\n    }\n    if (reference == null) reference = element.getReference();\n    PsiFile containingFile = element.getContainingFile();\n    if (reference == null) {\n      final TextRange textRange = element.getTextRange();\n      if (textRange != null) {\n        reference = containingFile.findReferenceAt(textRange.getStartOffset());\n      }\n    }\n    myReference = reference;\n    if (reference != null) {\n      Document document = PsiDocumentManager.getInstance(project).getDocument(containingFile);\n      if (document != null) {\n        int elementStart = reference.getElement().getTextRange().getStartOffset();\n        myReferenceRangeMarker = document.createRangeMarker(elementStart + reference.getRangeInElement().getStartOffset(),\n                                                            elementStart + reference.getRangeInElement().getEndOffset());\n      }\n      myDynamicUsage = reference.resolve() == null;\n    }\n  }","id":79598,"modified_method":"private void init(final PsiElement element, PsiReference reference, final PsiElement referencedElement) {\n    final Project project = element.getProject();\n    myReferencedElement = referencedElement;\n    if (referencedElement != null) {\n      myReferencedElementPointer = SmartPointerManager.getInstance(project).createSmartPsiElementPointer(referencedElement);\n    }\n    if (reference == null) reference = element.getReference();\n    PsiFile containingFile = element.getContainingFile();\n    if (reference == null) {\n      final TextRange textRange = element.getTextRange();\n      if (textRange != null) {\n        reference = containingFile.findReferenceAt(textRange.getStartOffset());\n      }\n    }\n    myReference = reference;\n    if (reference != null) {\n      Document document = PsiDocumentManager.getInstance(project).getDocument(containingFile);\n      if (document != null) {\n        final int elementStart = reference.getElement().getTextRange().getStartOffset();\n        final TextRange rangeInElement = reference.getRangeInElement();\n        LOG.assertTrue(elementStart + rangeInElement.getEndOffset() <= document.getTextLength(), reference);\n        myReferenceRangeMarker = document.createRangeMarker(elementStart + rangeInElement.getStartOffset(),\n                                                            elementStart + rangeInElement.getEndOffset());\n      }\n      myDynamicUsage = reference.resolve() == null;\n    }\n  }","commit_id":"2c91f794178d26840d4c5542d81b194b6300dbac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doCheckRefs(final PsiElement value, final PsiReference[] references) {\n    ProgressManager progressManager = ProgressManager.getInstance();\n    for (final PsiReference reference : references) {\n      progressManager.checkCanceled();\n      if (reference == null) {\n        continue;\n      }\n      if (!reference.isSoft()) {\n        if(hasBadResolve(reference)) {\n          String description = getErrorDescription(reference);\n\n          HighlightInfo info = HighlightInfo.createHighlightInfo(\n            getTagProblemInfoType(PsiTreeUtil.getParentOfType(value, XmlTag.class)),\n            reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getStartOffset(),\n            reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset(),\n            description\n          );\n          addToResults(info);\n          if (reference instanceof QuickFixProvider) ((QuickFixProvider)reference).registerQuickfix(info, reference);\n        }\n      }\n    }\n  }","id":79599,"modified_method":"private void doCheckRefs(final PsiElement value, final PsiReference[] references) {\n    ProgressManager progressManager = ProgressManager.getInstance();\n    for (final PsiReference reference : references) {\n      progressManager.checkCanceled();\n      if (reference == null) {\n        continue;\n      }\n      if (!reference.isSoft()) {\n        if(hasBadResolve(reference)) {\n          String description = getErrorDescription(reference);\n\n          final int startOffset = reference.getElement().getTextRange().getStartOffset();\n          final TextRange referenceRange = reference.getRangeInElement();\n\n          // logging for IDEADEV-29655\n          if (referenceRange.getStartOffset() > referenceRange.getEndOffset()) {\n            final PsiElement element = reference.getElement();\n            final XmlTag tag = PsiTreeUtil.getParentOfType(element, XmlTag.class);\n            LOG.error(\"Reference range start offset > end offset for element:  \" + element.getText() + \", within tag: \" + (tag != null ? tag.getText() : \"NULL\") +\n            \", start offset: \" + referenceRange.getStartOffset() + \", end offset: \" + referenceRange.getEndOffset());\n          }\n\n          HighlightInfo info = HighlightInfo.createHighlightInfo(\n            getTagProblemInfoType(PsiTreeUtil.getParentOfType(value, XmlTag.class)),\n            startOffset + referenceRange.getStartOffset(),\n            startOffset + referenceRange.getEndOffset(),\n            description\n          );\n          addToResults(info);\n          if (reference instanceof QuickFixProvider) ((QuickFixProvider)reference).registerQuickfix(info, reference);\n        }\n      }\n    }\n  }","commit_id":"66eebf20f5f762e068c5cfb9256c39ea79a2271a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static <T> List<T> createProblemDescriptors(final DomElementProblemDescriptor problemDescriptor, final Function<Pair<TextRange, PsiElement>, T> creator) {\n    final List<T> descritors = new SmartList<T>();\n\n    if (problemDescriptor instanceof DomElementResolveProblemDescriptor) {\n      final PsiReference reference = ((DomElementResolveProblemDescriptor)problemDescriptor).getPsiReference();\n      final PsiElement element = reference.getElement();\n      final int startOffset = element.getTextRange().getStartOffset();\n      descritors.add(creator.fun(Pair.create(reference.getRangeInElement().shiftRight(startOffset), element)));\n      return descritors;\n    }\n\n    final DomElement domElement = problemDescriptor.getDomElement();\n    final PsiElement psiElement = getPsiElement(domElement);\n    if (psiElement != null && StringUtil.isNotEmpty(psiElement.getText())) {\n      if (psiElement instanceof XmlTag) {\n        final XmlTag tag = (XmlTag)psiElement;\n        if (tag.getSubTags().length > 0) {\n          addDescriptionsToTagEnds(tag, descritors, creator);\n          return descritors;\n        }\n      }\n      return Arrays.asList(creator.fun(Pair.create(psiElement.getTextRange(), psiElement)));\n    }\n\n    final XmlTag tag = getParentXmlTag(domElement);\n    if (tag != null) {\n      addDescriptionsToTagEnds(tag, descritors, creator);\n    }\n    return descritors;\n  }","id":79600,"modified_method":"private static <T> List<T> createProblemDescriptors(final DomElementProblemDescriptor problemDescriptor, final Function<Pair<TextRange, PsiElement>, T> creator) {\n    final List<T> descritors = new SmartList<T>();\n\n    if (problemDescriptor instanceof DomElementResolveProblemDescriptor) {\n      final PsiReference reference = ((DomElementResolveProblemDescriptor)problemDescriptor).getPsiReference();\n      final PsiElement element = reference.getElement();\n      final int startOffset = element.getTextRange().getStartOffset();\n      final TextRange referenceRange = reference.getRangeInElement();\n      final TextRange errorRange;\n      if (referenceRange.getStartOffset() == referenceRange.getEndOffset()) {\n        errorRange = element.getTextRange();\n      } else {\n        errorRange = referenceRange.shiftRight(startOffset);\n      }\n      descritors.add(creator.fun(Pair.create(errorRange, element)));\n      return descritors;\n    }\n\n    final DomElement domElement = problemDescriptor.getDomElement();\n    final PsiElement psiElement = getPsiElement(domElement);\n    if (psiElement != null && StringUtil.isNotEmpty(psiElement.getText())) {\n      if (psiElement instanceof XmlTag) {\n        final XmlTag tag = (XmlTag)psiElement;\n        if (tag.getSubTags().length > 0) {\n          addDescriptionsToTagEnds(tag, descritors, creator);\n          return descritors;\n        }\n      }\n      return Arrays.asList(creator.fun(Pair.create(psiElement.getTextRange(), psiElement)));\n    }\n\n    final XmlTag tag = getParentXmlTag(domElement);\n    if (tag != null) {\n      addDescriptionsToTagEnds(tag, descritors, creator);\n    }\n    return descritors;\n  }","commit_id":"13e1ba9fa66ae3402f28d9eba40b322f23763c87","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerUnresolvedReferenceProblem(final PyElement node, final PsiReference reference, HighlightSeverity severity) {\n      String description = null;\n      final String text = reference.getElement().getText();\n      final String ref_text = reference.getRangeInElement().substring(text); // text of the part we're working with\n      final PsiElement element = reference.getElement();\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      if (ref_text.length() <= 0) return; // empty text, nothing to highlight\n      final String refname = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : ref_text;\n      if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression refex = (PyReferenceExpression)element;\n        if (myIgnoredIdentifiers.contains(refname) || PyNames.COMPARISON_OPERATORS.contains(refname)) {\n          return;\n        }\n        if (CythonLanguageDialect.isInsideCythonFile(element) && CythonNames.BUILTINS.contains(text)) {\n          return;\n        }\n        if (refex.getQualifier() != null) {\n          final PyClassType object_type = PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname)) return;\n        }\n        else {\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (\"with\".equals(refname)) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));\n            }\n          }\n          if (ref_text.equals(\"true\") || ref_text.equals(\"false\"))\n            actions.add(new UnresolvedRefTrueFalseQuickFix(element));\n          addAddSelfFix(node, refex, actions);\n          PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n          if (callExpression != null)\n            actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, refex));\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refname)) return;\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.WEAK_WARNING;\n          description = PyBundle.message(\"INSP.module.$0.not.found\", ref_text);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof DocStringParameterReference) {\n        if (myIgnoredIdentifiers.contains(reference.getCanonicalText()))\n          return;\n      }\n      if (reference instanceof PsiReferenceEx && description == null) {\n        description = ((PsiReferenceEx)reference).getUnresolvedDescription();\n      }\n      if (description == null) {\n        boolean marked_qualified = false;\n        if (element instanceof PyQualifiedExpression) {\n          final PyQualifiedExpression qexpr = (PyQualifiedExpression)element;\n          if (myIgnoredIdentifiers.contains(ref_text) || PyNames.COMPARISON_OPERATORS.contains(qexpr.getReferencedName())) {\n            return;\n          }\n          final PyExpression qualifier = qexpr.getQualifier();\n          if (qualifier != null) {\n            PyType qtype = myTypeEvalContext.getType(qualifier);\n            if (qtype != null) {\n              if (ignoreUnresolvedMemberForType(qtype, reference, ref_text)) {\n                return;\n              }\n              addCreateMemberFromUsageFixes(qtype, reference, ref_text, actions);\n              if (qtype instanceof PyClassType) {\n                if (reference instanceof PyOperatorReference) {\n                  description = PyBundle.message(\"INSP.unresolved.operator.ref\",\n                                                 qtype.getName(), refname,\n                                                 ((PyOperatorReference)reference).getReadableOperatorName());\n                }\n                else {\n                  description = PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", ref_text, qtype.getName());\n                }\n                marked_qualified = true;\n              }\n              else {\n                description = PyBundle.message(\"INSP.cannot.find.$0.in.$1\", ref_text, qtype.getName());\n                marked_qualified = true;\n              }\n            }\n          }\n        }\n        if (!marked_qualified) {\n          description = PyBundle.message(\"INSP.unresolved.ref.$0\", ref_text);\n\n          // look in other imported modules for this whole name\n          if (PythonReferenceImporter.isImportable(element)) {\n            addAutoImportFix(node, reference, actions);\n          }\n\n          addCreateClassFix(ref_text, element, actions);\n        }\n      }\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      /*\n      else if (severity == HighlightSeverity.ERROR) {\n        hl_type = ProblemHighlightType.ERROR;\n      }\n      */\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      if (GenerateBinaryStubsFix.isApplicable(reference)) {\n        actions.add(new GenerateBinaryStubsFix(reference));\n      }\n      actions.add(new AddIgnoredIdentifierFix(ref_text));\n      addPluginQuickFixes(reference, actions);\n\n      PsiElement point = node.getLastChild(); // usually the identifier at the end of qual ref\n      if (point == null) point = node;\n      TextRange range = reference.getRangeInElement().shiftRight(-point.getStartOffsetInParent());\n      registerProblem(point, description, hl_type, null, range, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","id":79601,"modified_method":"private void registerUnresolvedReferenceProblem(final PyElement node, final PsiReference reference, HighlightSeverity severity) {\n      String description = null;\n      final String text = reference.getElement().getText();\n      TextRange rangeInElement = reference.getRangeInElement();\n      String ref_text = text;  // text of the part we're working with\n      if (rangeInElement.getStartOffset() > 0 && rangeInElement.getEndOffset() > 0)\n        ref_text = rangeInElement.substring(text);\n      final PsiElement element = reference.getElement();\n      final List<LocalQuickFix> actions = new ArrayList<LocalQuickFix>(2);\n      if (ref_text.length() <= 0) return; // empty text, nothing to highlight\n      final String refname = (element instanceof PyQualifiedExpression) ? ((PyQualifiedExpression)element).getReferencedName() : ref_text;\n      if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression refex = (PyReferenceExpression)element;\n        if (myIgnoredIdentifiers.contains(refname) || PyNames.COMPARISON_OPERATORS.contains(refname)) {\n          return;\n        }\n        if (CythonLanguageDialect.isInsideCythonFile(element) && CythonNames.BUILTINS.contains(text)) {\n          return;\n        }\n        if (refex.getQualifier() != null) {\n          final PyClassType object_type = PyBuiltinCache.getInstance(node).getObjectType();\n          if ((object_type != null) && object_type.getPossibleInstanceMembers().contains(refname)) return;\n        }\n        else {\n          if (LanguageLevel.forElement(node).isOlderThan(LanguageLevel.PYTHON26)) {\n            if (\"with\".equals(refname)) {\n              actions.add(new UnresolvedRefAddFutureImportQuickFix(refex));\n            }\n          }\n          if (ref_text.equals(\"true\") || ref_text.equals(\"false\"))\n            actions.add(new UnresolvedRefTrueFalseQuickFix(element));\n          addAddSelfFix(node, refex, actions);\n          PyCallExpression callExpression = PsiTreeUtil.getParentOfType(element, PyCallExpression.class);\n          if (callExpression != null)\n            actions.add(new UnresolvedRefCreateFunctionQuickFix(callExpression, refex));\n        }\n        // unqualified:\n        // may be module's\n        if (PyModuleType.getPossibleInstanceMembers().contains(refname)) return;\n        // may be a \"try: import ...\"; not an error not to resolve\n        if ((\n          PsiTreeUtil.getParentOfType(\n            PsiTreeUtil.getParentOfType(node, PyImportElement.class), PyTryExceptStatement.class, PyIfStatement.class\n          ) != null\n        )) {\n          severity = HighlightSeverity.WEAK_WARNING;\n          description = PyBundle.message(\"INSP.module.$0.not.found\", ref_text);\n          // TODO: mark the node so that future references pointing to it won't result in a error, but in a warning\n        }\n      }\n      if (reference instanceof DocStringParameterReference) {\n        if (myIgnoredIdentifiers.contains(reference.getCanonicalText()))\n          return;\n      }\n      if (reference instanceof PsiReferenceEx && description == null) {\n        description = ((PsiReferenceEx)reference).getUnresolvedDescription();\n      }\n      if (description == null) {\n        boolean marked_qualified = false;\n        if (element instanceof PyQualifiedExpression) {\n          final PyQualifiedExpression qexpr = (PyQualifiedExpression)element;\n          if (myIgnoredIdentifiers.contains(ref_text) || PyNames.COMPARISON_OPERATORS.contains(qexpr.getReferencedName())) {\n            return;\n          }\n          final PyExpression qualifier = qexpr.getQualifier();\n          if (qualifier != null) {\n            PyType qtype = myTypeEvalContext.getType(qualifier);\n            if (qtype != null) {\n              if (ignoreUnresolvedMemberForType(qtype, reference, ref_text)) {\n                return;\n              }\n              addCreateMemberFromUsageFixes(qtype, reference, ref_text, actions);\n              if (qtype instanceof PyClassType) {\n                if (reference instanceof PyOperatorReference) {\n                  description = PyBundle.message(\"INSP.unresolved.operator.ref\",\n                                                 qtype.getName(), refname,\n                                                 ((PyOperatorReference)reference).getReadableOperatorName());\n                }\n                else {\n                  description = PyBundle.message(\"INSP.unresolved.ref.$0.for.class.$1\", ref_text, qtype.getName());\n                }\n                marked_qualified = true;\n              }\n              else {\n                description = PyBundle.message(\"INSP.cannot.find.$0.in.$1\", ref_text, qtype.getName());\n                marked_qualified = true;\n              }\n            }\n          }\n        }\n        if (!marked_qualified) {\n          description = PyBundle.message(\"INSP.unresolved.ref.$0\", ref_text);\n\n          // look in other imported modules for this whole name\n          if (PythonReferenceImporter.isImportable(element)) {\n            addAutoImportFix(node, reference, actions);\n          }\n\n          addCreateClassFix(ref_text, element, actions);\n        }\n      }\n      ProblemHighlightType hl_type;\n      if (severity == HighlightSeverity.WARNING) {\n        hl_type = ProblemHighlightType.GENERIC_ERROR_OR_WARNING;\n      }\n      /*\n      else if (severity == HighlightSeverity.ERROR) {\n        hl_type = ProblemHighlightType.ERROR;\n      }\n      */\n      else {\n        hl_type = ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;\n      }\n\n      if (GenerateBinaryStubsFix.isApplicable(reference)) {\n        actions.add(new GenerateBinaryStubsFix(reference));\n      }\n      actions.add(new AddIgnoredIdentifierFix(ref_text));\n      addPluginQuickFixes(reference, actions);\n\n      PsiElement point = node.getLastChild(); // usually the identifier at the end of qual ref\n      if (point == null) point = node;\n      TextRange range = reference.getRangeInElement().shiftRight(-point.getStartOffsetInParent());\n      registerProblem(point, description, hl_type, null, range, actions.toArray(new LocalQuickFix[actions.size()]));\n    }","commit_id":"04067da99390ad5d590fb3d7a0ded8939fd896c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected Set<SNode> getDescendants(SNode node, Set<SNode> visited) {\n      this.ancestorsProvider = new ConceptAncestorsProvider();\n      Set<SNode> descendants = this.ancestorsProvider.getDescendants(node);\n      SetSequence.fromSet(descendants).removeSequence(SetSequence.fromSet(descendants).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.getModel(it).isReadOnly();\n        }\n      }));\n      return descendants;\n    }","id":79602,"modified_method":"@Override\n    protected Set<SNode> getDescendants(SNode node, Set<SNode> visited) {\n      this.ancestorsProvider = new ConceptAncestorsProvider();\n      Set<SNode> descendants = this.ancestorsProvider.getDescendants(node);\n      return SetSequence.fromSetWithValues(new HashSet<SNode>(), SetSequence.fromSet(descendants).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return !(SNodeOperations.getModel(it).isReadOnly());\n        }\n      }));\n    }","commit_id":"1cb8eea9547c6482bee9cc4b340febb93ba7013e","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected MPSTreeNode rebuild() {\n    SetSequence.fromSet(myCycles).clear();\n    if (myModules == null || ListSequence.fromList(myModules).isEmpty()) {\n      return new TextMPSTreeNode(\"No Content\", null);\n    }\n    SetSequence.fromSet(myCycles).addSequence(ListSequence.fromList(myModules).translate(new ITranslator2<IModule, Tuples._2<DependencyUtil.Role, IModule>>() {\n      public Iterable<Tuples._2<DependencyUtil.Role, IModule>> translate(IModule it) {\n        return DependencyUtil.getLoops(DependencyUtil.Role.None, it, isShowRuntime());\n      }\n    }));\n    ModuleDependencyNode root = new ModuleDependencyNode(myModules, null);\n    if (SetSequence.fromSet(myCycles).select(new ISelector<Tuples._2<DependencyUtil.Role, IModule>, IModule>() {\n      public IModule select(Tuples._2<DependencyUtil.Role, IModule> it) {\n        return it._1();\n      }\n    }).intersect(ListSequence.fromList(myModules)).isNotEmpty()) {\n      root.setCyclic();\n    }\n    expandRoot();\n    return root;\n  }","id":79603,"modified_method":"protected MPSTreeNode rebuild() {\n    SetSequence.fromSet(myCycles).clear();\n    if (myModules == null || ListSequence.fromList(myModules).isEmpty()) {\n      return new TextMPSTreeNode(\"No Content\", null);\n    }\n    SetSequence.fromSet(myCycles).addSequence(ListSequence.fromList(myModules).translate(new ITranslator2<IModule, Tuples._2<DependencyUtil.Role, IModule>>() {\n      public Iterable<Tuples._2<DependencyUtil.Role, IModule>> translate(IModule m) {\n        return DependencyUtil.getLoops(DependencyUtil.Role.None, m, isShowRuntime());\n      }\n    }).where(new IWhereFilter<Tuples._2<DependencyUtil.Role, IModule>>() {\n      public boolean accept(Tuples._2<DependencyUtil.Role, IModule> dep) {\n        return dep._0().isDependency();\n      }\n    }).select(new ISelector<Tuples._2<DependencyUtil.Role, IModule>, IModule>() {\n      public IModule select(Tuples._2<DependencyUtil.Role, IModule> dep) {\n        return dep._1();\n      }\n    }));\n    ModuleDependencyNode root = new ModuleDependencyNode(myModules, null);\n    expandRoot();\n    return root;\n  }","commit_id":"9a8aa7dfcc5f11f7422294c57149f5997e5e12e6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public DepDependencyNode(IModule module, boolean isRuntime, boolean isCyclic, IOperationContext context) {\n      super(module, isCyclic, context);\n      if (isRuntime) {\n        setNodeIdentifier(getNodeIdentifier() + \" (runtime)\");\n      }\n\n    }","id":79604,"modified_method":"public DepDependencyNode(IModule module, boolean isRuntime, boolean isCyclic, IOperationContext context) {\n      super(module, context);\n      if (isRuntime) {\n        setNodeIdentifier(getNodeIdentifier() + \" (runtime)\");\n      }\n      if (isCyclic) {\n        setCyclic();\n      }\n    }","commit_id":"9a8aa7dfcc5f11f7422294c57149f5997e5e12e6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModuleDependencyNode(IModule module, boolean isCyclic, IOperationContext context) {\n    this(ListSequence.fromListAndArray(new ArrayList<IModule>(), module), context);\n    myCyclic = isCyclic;\n  }","id":79605,"modified_method":"public ModuleDependencyNode(IModule module, IOperationContext context) {\n    this(ListSequence.fromListAndArray(new ArrayList<IModule>(), module), context);\n  }","commit_id":"9a8aa7dfcc5f11f7422294c57149f5997e5e12e6","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doInit() {\n    Set<IModule> reqModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<IModule> rtModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<Language> usedLanguages = SetSequence.fromSet(new HashSet<Language>());\n\n    DependencyTree tree = (DependencyTree) getTree();\n\n    for (IModule module : ListSequence.fromList(myModules)) {\n      DependenciesManager depManager = module.getDependenciesManager();\n      SetSequence.fromSet(reqModules).addSequence(SetSequence.fromSet(depManager.getAllVisibleModules()));\n      SetSequence.fromSet(rtModules).addSequence(SetSequence.fromSet(depManager.getAllRequiredModules()));\n      SetSequence.fromSet(usedLanguages).addSequence(SetSequence.fromSet(depManager.getAllUsedLanguages()));\n    }\n\n    Set<IModule> depLoops = SetSequence.fromSet(new HashSet<IModule>());\n    Set<IModule> langLoops = SetSequence.fromSet(new HashSet<IModule>());\n    SetSequence.fromSet(depLoops).addSequence(SetSequence.fromSet(tree.getCycles()).where(new IWhereFilter<Tuples._2<DependencyUtil.Role, IModule>>() {\n      public boolean accept(Tuples._2<DependencyUtil.Role, IModule> it) {\n        return it._0() == DependencyUtil.Role.DTDependency_ || it._0() == DependencyUtil.Role.RTDependency || it._0() == DependencyUtil.Role.None;\n      }\n    }).select(new ISelector<Tuples._2<DependencyUtil.Role, IModule>, IModule>() {\n      public IModule select(Tuples._2<DependencyUtil.Role, IModule> it) {\n        return it._1();\n      }\n    }));\n    SetSequence.fromSet(langLoops).addSequence(SetSequence.fromSet(tree.getCycles()).where(new IWhereFilter<Tuples._2<DependencyUtil.Role, IModule>>() {\n      public boolean accept(Tuples._2<DependencyUtil.Role, IModule> it) {\n        return it._0() == DependencyUtil.Role.UsedLanguage || it._0() == DependencyUtil.Role.None;\n      }\n    }).select(new ISelector<Tuples._2<DependencyUtil.Role, IModule>, IModule>() {\n      public IModule select(Tuples._2<DependencyUtil.Role, IModule> it) {\n        return it._1();\n      }\n    }));\n\n    Set<IModule> allModules = (tree.isShowRuntime() ?\n      rtModules :\n      reqModules\n    );\n    for (IModule m : SetSequence.fromSet(allModules).sort(new ISelector<IModule, Comparable<?>>() {\n      public Comparable<?> select(IModule it) {\n        return it.getModuleFqName();\n      }\n    }, true)) {\n      add(new ModuleDependencyNode.DepDependencyNode(m, !(SetSequence.fromSet(reqModules).contains(m)), SetSequence.fromSet(depLoops).contains(m), getOperationContext()));\n    }\n\n    if (tree.isShowUsedLanguage()) {\n      MPSTreeNode usedlanguages = new TextMPSTreeNode(\"Used languages\", getOperationContext());\n      for (Language l : SetSequence.fromSet(usedLanguages).sort(new ISelector<Language, Comparable<?>>() {\n        public Comparable<?> select(Language it) {\n          return it.getModuleFqName();\n        }\n      }, true)) {\n        usedlanguages.add(new ModuleDependencyNode.ULangDependencyNode(l, SetSequence.fromSet(langLoops).contains(l), getOperationContext()));\n      }\n      add(usedlanguages);\n    }\n    myInitialized = true;\n  }","id":79606,"modified_method":"protected void doInit() {\n    Set<IModule> reqModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<IModule> rtModules = SetSequence.fromSet(new HashSet<IModule>());\n    Set<Language> usedLanguages = SetSequence.fromSet(new HashSet<Language>());\n\n    DependencyTree tree = (DependencyTree) getTree();\n\n    for (IModule module : ListSequence.fromList(myModules)) {\n      DependenciesManager depManager = module.getDependenciesManager();\n      SetSequence.fromSet(reqModules).addSequence(SetSequence.fromSet(depManager.getAllVisibleModules()));\n      SetSequence.fromSet(rtModules).addSequence(SetSequence.fromSet(depManager.getAllRequiredModules()));\n      SetSequence.fromSet(usedLanguages).addSequence(SetSequence.fromSet(depManager.getAllUsedLanguages()));\n    }\n\n    Set<IModule> allModules = (tree.isShowRuntime() ?\n      rtModules :\n      reqModules\n    );\n\n    Set<IModule> depLoops = tree.getLoops();\n    // Dependency manager doesn't add module itself to its dependencies, fixing this here \n    SetSequence.fromSet(allModules).addSequence(SetSequence.fromSet(depLoops).intersect(ListSequence.fromList(myModules)));\n\n    for (IModule m : SetSequence.fromSet(allModules).sort(new ISelector<IModule, Comparable<?>>() {\n      public Comparable<?> select(IModule it) {\n        return it.getModuleFqName();\n      }\n    }, true)) {\n      add(new ModuleDependencyNode.DepDependencyNode(m, !(SetSequence.fromSet(reqModules).contains(m)), SetSequence.fromSet(depLoops).contains(m), getOperationContext()));\n    }\n\n    if (tree.isShowUsedLanguage()) {\n      MPSTreeNode usedlanguages = new TextMPSTreeNode(\"Used languages\", getOperationContext());\n      for (Language l : SetSequence.fromSet(usedLanguages).sort(new ISelector<Language, Comparable<?>>() {\n        public Comparable<?> select(Language it) {\n          return it.getModuleFqName();\n        }\n      }, true)) {\n        usedlanguages.add(new ModuleDependencyNode.ULangDependencyNode(l, getOperationContext()));\n      }\n      add(usedlanguages);\n    }\n    myInitialized = true;\n  }","commit_id":"9a8aa7dfcc5f11f7422294c57149f5997e5e12e6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ULangDependencyNode(IModule module, boolean isCyclic, IOperationContext context) {\n      super(module, isCyclic, context);\n    }","id":79607,"modified_method":"public ULangDependencyNode(IModule module, IOperationContext context) {\n      super(module, context);\n    }","commit_id":"9a8aa7dfcc5f11f7422294c57149f5997e5e12e6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Tuples._3<String, List<String>, List<String>> getDefaultRunParameters() {\n    List<String> startupPath = Java_Command.getClasspath(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"8b958198-128f-4136-80e5-ca9777caa869\")), true);\n    return MultiTuple.<String,List<String>,List<String>>from(\"jetbrains.mps.baseLanguage.unitTest.execution.server.TestRunner\", ListSequence.fromList(new ArrayList<String>()), startupPath);\n  }","id":79608,"modified_method":"public static Tuples._3<String, List<String>, List<String>> getDefaultRunParameters() {\n    List<String> startupPath = Java_Command.getClasspath(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"8b958198-128f-4136-80e5-ca9777caa869\")));\n    return MultiTuple.<String,List<String>,List<String>>from(\"jetbrains.mps.baseLanguage.unitTest.execution.server.TestRunner\", ListSequence.fromList(new ArrayList<String>()), startupPath);\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<String> getJavaHomes() {\n    String systemJavaHome = SystemProperties.getJavaHome();\n    List<String> homes = ListSequence.fromList(new LinkedList<String>());\n    String systemJdkHome = systemJavaHome.substring(0, systemJavaHome.length() - \"/jre\".length());\n    if (systemJavaHome.endsWith(\"jre\") && new File(systemJdkHome + File.separator + \"bin\").exists()) {\n      ListSequence.fromList(homes).addElement(systemJdkHome);\n    }\n    if (isNotEmpty_kk96hj_a0e0eb(System.getenv(\"JAVA_HOME\"))) {\n      ListSequence.fromList(homes).addElement(System.getenv(\"JAVA_HOME\"));\n    }\n    ListSequence.fromList(homes).addElement(systemJavaHome);\n    return homes;\n  }","id":79609,"modified_method":"public static List<String> getJavaHomes() {\n    String systemJavaHome = SystemProperties.getJavaHome();\n    List<String> homes = ListSequence.fromList(new LinkedList<String>());\n    String systemJdkHome = systemJavaHome.substring(0, systemJavaHome.length() - \"/jre\".length());\n    if (systemJavaHome.endsWith(\"jre\") && new File(systemJdkHome + File.separator + \"bin\").exists()) {\n      ListSequence.fromList(homes).addElement(systemJdkHome);\n    }\n    if (isNotEmpty_kk96hj_a0e0fb(System.getenv(\"JAVA_HOME\"))) {\n      ListSequence.fromList(homes).addElement(System.getenv(\"JAVA_HOME\"));\n    }\n    ListSequence.fromList(homes).addElement(systemJavaHome);\n    return homes;\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProcessHandler createProcess(final SNodeReference nodePointer) throws ExecutionException {\n    IModule module = check_yvpt_a0a0a3(check_yvpt_a0a0a0d(((SNodePointer) nodePointer)));\n    if (module == null) {\n      final Wrappers._T<String> text = new Wrappers._T<String>();\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          text.value = \"Can't find module for node \" + nodePointer;\n        }\n      });\n      throw new ExecutionException(text.value);\n    }\n    return new Java_Command().setJrePath_String(myJrePath_String).setWorkingDirectory_File(myWorkingDirectory_File).setProgramParameter_String(myProgramParameter_String).setVirtualMachineParameter_String(myVirtualMachineParameter_String).setClassPath_ListString(Java_Command.getClasspath(module, true)).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(Java_Command.getClassName(nodePointer));\n  }","id":79610,"modified_method":"public ProcessHandler createProcess(final SNodeReference nodePointer) throws ExecutionException {\n    IModule module = check_yvpt_a0a0a3(check_yvpt_a0a0a0d(((SNodePointer) nodePointer)));\n    if (module == null) {\n      final Wrappers._T<String> text = new Wrappers._T<String>();\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          text.value = \"Can't find module for node \" + nodePointer;\n        }\n      });\n      throw new ExecutionException(text.value);\n    }\n    return new Java_Command().setJrePath_String(myJrePath_String).setWorkingDirectory_File(myWorkingDirectory_File).setProgramParameter_String(myProgramParameter_String).setVirtualMachineParameter_String(myVirtualMachineParameter_String).setClassPath_ListString(Java_Command.getClasspath(module)).setDebuggerSettings_String(myDebuggerSettings_String).createProcess(Java_Command.getClassName(nodePointer));\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<String> getClasspath(final SNode node) {\n    final Wrappers._T<IModule> module = new Wrappers._T<IModule>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        module.value = SNodeOperations.getModel(node).getModelDescriptor().getModule();\n      }\n    });\n    return Java_Command.getClasspath(module.value, true);\n  }","id":79611,"modified_method":"public static List<String> getClasspath(final SNode node) {\n    // todo: node argument -> read action? \n    return ModelAccess.instance().runReadAction(new Computable<List<String>>() {\n      public List<String> compute() {\n        return Java_Command.getClasspath(SNodeOperations.getModel(node).getModelDescriptor().getModule());\n      }\n    });\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<String> getClasspath(final IModule module, boolean withDependencies) {\n    final ClasspathStringCollector visitor = new ClasspathStringCollector();\n    module.getClassPathItem().accept(visitor);\n    if (withDependencies) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          for (IModule m : CollectionSequence.fromCollection(new GlobalModuleDependenciesManager(module).getModules(GlobalModuleDependenciesManager.Deptype.EXECUTE))) {\n            m.getClassPathItem().accept(visitor);\n          }\n        }\n      });\n    }\n\n    Set<String> visited = visitor.getClasspath();\n    visited.removeAll(CommonPaths.getJDKPath());\n    return ListSequence.fromListWithValues(new ArrayList<String>(), visited);\n  }","id":79612,"modified_method":"public static List<String> getClasspath(IModule module, boolean withDependencies) {\n    if (withDependencies) {\n      return Java_Command.getClasspath(module);\n    } else {\n      return new ArrayList<String>(module.getFacet(JavaModuleFacet.class).getClassPath());\n    }\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean isNotEmpty_kk96hj_a0e0eb(String str) {\n    return str != null && str.length() > 0;\n  }","id":79613,"modified_method":"public static boolean isNotEmpty_kk96hj_a0e0fb(String str) {\n    return str != null && str.length() > 0;\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<String> getClassRunnerClassPath() {\n    final Wrappers._T<IModule> module = new Wrappers._T<IModule>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        module.value = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"5b247b59-8fd0-4475-a767-9e9ff6a9d01c\"));\n      }\n    });\n\n    return Java_Command.getClasspath(module.value, false);\n  }","id":79614,"modified_method":"private static List<String> getClassRunnerClassPath() {\n    return ModelAccess.instance().runReadAction(new Computable<List<String>>() {\n      public List<String> compute() {\n        return Java_Command.getClasspath(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"5b247b59-8fd0-4475-a767-9e9ff6a9d01c\")));\n      }\n    });\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<String> getClasspath(final List<ITestNodeWrapper> tests) {\n    final Set<IModule> uniqueModules = SetSequence.fromSet(new HashSet<IModule>());\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        for (ITestNodeWrapper testable : tests) {\n          IModule module = ((SNodePointer) testable.getNodePointer()).getModel().getModule();\n          SetSequence.fromSet(uniqueModules).addElement(module);\n        }\n      }\n    });\n    Set<String> classpath = SetSequence.fromSet(new LinkedHashSet<String>());\n    for (IModule module : uniqueModules) {\n      SetSequence.fromSet(classpath).addSequence(ListSequence.fromList(Java_Command.getClasspath(module, true)));\n    }\n    return SetSequence.fromSet(classpath).toListSequence();\n  }","id":79615,"modified_method":"private static List<String> getClasspath(final List<ITestNodeWrapper> tests) {\n    final Set<SModule> uniqueModules = SetSequence.fromSet(new HashSet<SModule>());\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        for (ITestNodeWrapper testable : tests) {\n          IModule module = ((SNodePointer) testable.getNodePointer()).getModel().getModule();\n          SetSequence.fromSet(uniqueModules).addElement(module);\n        }\n      }\n    });\n    return SetSequence.fromSet(uniqueModules).translate(new ITranslator2<SModule, String>() {\n      public Iterable<String> translate(SModule it) {\n        return Java_Command.getClasspath(it);\n      }\n    }).distinct().toListSequence();\n  }","commit_id":"6f53b9c03c5a50831066fcb9e0c8979c9bd0d8ce","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Node createConfiguration(String absPath) throws RepositoryException {\n        throw TODO.unimplemented().exception();\n    }","id":79616,"modified_method":"@Override\n    public Node createConfiguration(String absPath) throws RepositoryException {\n        return TODO.unimplemented().returnValue(null);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Version getBaseVersion(String absPath) throws RepositoryException {\n        throw new UnsupportedRepositoryOperationException();\n    }","id":79617,"modified_method":"@Override\n    public Version getBaseVersion(String absPath) throws RepositoryException {\n        return TODO.unimplemented().returnValue(null);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void restoreByLabel(\n            String absPath, String versionLabel, boolean removeExisting)\n            throws RepositoryException {\n        TODO.unimplemented().doNothing();\n    }","id":79618,"modified_method":"public VersionManagerImpl(SessionDelegate sessionDelegate) {\n        this.sessionDelegate = sessionDelegate;\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Node getActivity() throws RepositoryException {\n        throw new UnsupportedRepositoryOperationException();\n    }","id":79619,"modified_method":"@Override\n    public Node getActivity() throws RepositoryException {\n        return TODO.unimplemented().returnValue(null);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Version checkin(String absPath) throws RepositoryException {\n        throw TODO.unimplemented().exception();\n    }","id":79620,"modified_method":"@Override\n    public Version checkin(String absPath) throws RepositoryException {\n        String oakPath = sessionDelegate.getOakPathOrThrowNotFound(absPath);\n        NodeDelegate nodeDelegate = sessionDelegate.getNode(oakPath);\n        return TODO.dummyImplementation().returnValue(\n                new VersionImpl(nodeDelegate));\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public VersionHistory getVersionHistory(String absPath)\n            throws RepositoryException {\n        throw new UnsupportedRepositoryOperationException();\n    }","id":79621,"modified_method":"@Override\n    public VersionHistory getVersionHistory(String absPath)\n            throws RepositoryException {\n        return TODO.unimplemented().returnValue(null);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Node createActivity(String title) throws RepositoryException {\n        throw TODO.unimplemented().exception();\n    }","id":79622,"modified_method":"@Override\n    public Node createActivity(String title) throws RepositoryException {\n        return TODO.unimplemented().returnValue(null);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Version checkpoint(String absPath) throws RepositoryException {\n        throw TODO.unimplemented().exception();\n    }","id":79623,"modified_method":"@Override\n    public Version checkpoint(String absPath) throws RepositoryException {\n        return TODO.unimplemented().returnValue(null);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public VersionManager getVersionManager() {\n        return new VersionManagerImpl();\n    }","id":79624,"modified_method":"@Override\n    public VersionManager getVersionManager() {\n        return new VersionManagerImpl(sessionDelegate);\n    }","commit_id":"1de87639956c8807e8682edc03109526d59061af","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public void sawOpcode(int seen) {\n            switch(seen) {\n            case IALOAD:\n            case AALOAD:\n            case SALOAD:\n            case CALOAD:\n            case BALOAD:\n            case LALOAD:\n            case DALOAD:\n            case FALOAD: {\n                checkRange(stack.getStackItem(0), 0, stack.getStackItem(1).getConstant(), \"RANGE_ARRAY_INDEX\");\n                break;\n            }\n            case IASTORE:\n            case AASTORE:\n            case SASTORE:\n            case CASTORE:\n            case BASTORE:\n            case LASTORE:\n            case DASTORE:\n            case FASTORE: {\n                checkRange(stack.getStackItem(1), 0, stack.getStackItem(2).getConstant(), \"RANGE_ARRAY_INDEX\");\n                break;\n            }\n            case INVOKESTATIC: {\n                MethodDescriptor m = getMethodDescriptorOperand();\n                if(m.getSlashedClassName().equals(\"java/lang/System\") && m.getName().equals(\"arraycopy\")) {\n                    checkRange(stack.getStackItem(3), 0, stack.getStackItem(4).getConstant(), \"RANGE_ARRAY_OFFSET\");\n                    checkRange(stack.getStackItem(1), 0, stack.getStackItem(2).getConstant(), \"RANGE_ARRAY_OFFSET\");\n                    if(stack.getStackItem(0).getConstant() instanceof Number) {\n                        int length1 = Integer.MAX_VALUE;\n                        if(stack.getStackItem(4).getConstant() instanceof Integer) {\n                            length1 = (int) stack.getStackItem(4).getConstant();\n                        }\n                        if(stack.getStackItem(3).getConstant() instanceof Integer) {\n                            length1 -= (int) stack.getStackItem(3).getConstant();\n                        }\n                        int length2 = Integer.MAX_VALUE;\n                        if(stack.getStackItem(2).getConstant() instanceof Integer) {\n                            length2 = (int) stack.getStackItem(2).getConstant();\n                        }\n                        if(stack.getStackItem(1).getConstant() instanceof Integer) {\n                            length2 -= (int) stack.getStackItem(1).getConstant();\n                        }\n                        checkRange(stack.getStackItem(0), 0, Math.min(length1, length2)+1, \"RANGE_ARRAY_LENGTH\");\n                    }\n                }\n                break;\n            }\n            case INVOKEVIRTUAL:\n            case INVOKESPECIAL: {\n                MethodDescriptor m = getMethodDescriptorOperand();\n                if(m.getSlashedClassName().equals(\"java/lang/String\")) {\n                    if((m.getName().equals(\"charAt\") || m.getName().equals(\"codePointAt\")) && m.getSignature().startsWith(\"(I)\")) {\n                        checkRange(stack.getStackItem(0), 0, stack.getStackItem(1).getConstant(), \"RANGE_STRING_INDEX\");\n                    }\n                    if(m.getName().equals(\"substring\") || m.getName().equals(\"subSequence\")) {\n                        int nArgs = getNumberArguments(m.getSignature());\n                        Item thisArg = stack.getStackItem(nArgs);\n                        Item firstArg = stack.getStackItem(nArgs-1);\n                        int maxLength = thisArg.getConstant() instanceof String ? ((String)thisArg.getConstant()).length() : Integer.MAX_VALUE;\n                        checkRange(firstArg, 0, maxLength+1, \"RANGE_STRING_INDEX\");\n                        if(nArgs == 2) {\n                            Item secondArg = stack.getStackItem(0);\n                            checkRange(secondArg, firstArg.getConstant() == null ? 0 : firstArg.getConstant(), maxLength+1,\n                                    \"RANGE_STRING_INDEX\");\n                        }\n                    }\n                }\n                if ((m.getSignature().startsWith(\"([BII)\") || m.getSignature().startsWith(\"([CII)\") || m.getSignature().startsWith(\"([III)\"))\n                        && (((m.getName().equals(\"write\") || m.getName().equals(\"read\")) && m.getSlashedClassName().startsWith(\n                                \"java/io/\")) || (m.getName().equals(\"<init>\") && m.getSlashedClassName().equals(\"java/lang/String\")))) {\n                    Item arrayArg = stack.getStackItem(2);\n                    Item offsetArg = stack.getStackItem(1);\n                    Item lengthArg = stack.getStackItem(0);\n                    int length = Integer.MAX_VALUE;\n                    if(arrayArg.getConstant() instanceof Integer) {\n                        length = (int) arrayArg.getConstant();\n                    }\n                    if(offsetArg.getConstant() instanceof Integer) {\n                        checkRange(offsetArg, 0, length+1, \"RANGE_ARRAY_OFFSET\");\n                        length -= (int) offsetArg.getConstant();\n                    }\n                    checkRange(lengthArg, 0, length+1, \"RANGE_ARRAY_LENGTH\");\n                }\n                break;\n            }\n            default:\n                break;\n            }\n        }","id":79625,"modified_method":"@Override\n        public void sawOpcode(int seen) {\n            // System.out.printf(\"%4d %s%n\", getPC(), OPCODE_NAMES[seen]);\n            switch(seen) {\n            case IALOAD:\n            case AALOAD:\n            case SALOAD:\n            case CALOAD:\n            case BALOAD:\n            case LALOAD:\n            case DALOAD:\n            case FALOAD: {\n                checkRange(stack.getStackItem(0), 0, stack.getStackItem(1), \"RANGE_ARRAY_INDEX\");\n                break;\n            }\n            case IASTORE:\n            case AASTORE:\n            case SASTORE:\n            case CASTORE:\n            case BASTORE:\n            case LASTORE:\n            case DASTORE:\n            case FASTORE: {\n\n                checkRange(stack.getStackItem(1), 0,  stack.getStackItem(2), \"RANGE_ARRAY_INDEX\");\n                break;\n            }\n            case INVOKESTATIC: {\n                MethodDescriptor m = getMethodDescriptorOperand();\n                if(m.getSlashedClassName().equals(\"java/lang/System\") && m.getName().equals(\"arraycopy\")) {\n                    Item srcPos = stack.getStackItem(3);\n                    checkRange(srcPos, 0, stack.getStackItem(4), \"RANGE_ARRAY_OFFSET\");\n                    checkRange(stack.getStackItem(1), 0, stack.getStackItem(2), \"RANGE_ARRAY_OFFSET\");\n                    Object constantLength = stack.getStackItem(0).getConstant();\n                    if(constantLength instanceof Number) {\n                        int length1 = Integer.MAX_VALUE;\n                        if(stack.getStackItem(4).getConstant() instanceof Integer) {\n                            length1 = (int) stack.getStackItem(4).getConstant();\n                        }\n                        if(srcPos.getConstant() instanceof Integer) {\n                            length1 -= (int) srcPos.getConstant();\n                        }\n                        int length2 = Integer.MAX_VALUE;\n                        if(stack.getStackItem(2).getConstant() instanceof Integer) {\n                            length2 = (int) stack.getStackItem(2).getConstant();\n                        }\n                        if(stack.getStackItem(1).getConstant() instanceof Integer) {\n                            length2 -= (int) stack.getStackItem(1).getConstant();\n                        }\n                        checkRange(stack.getStackItem(0), 0, Math.min(length1, length2), \"RANGE_ARRAY_LENGTH\");\n                    }\n                }\n                break;\n            }\n            case INVOKEVIRTUAL:\n            case INVOKESPECIAL: {\n                MethodDescriptor m = getMethodDescriptorOperand();\n                if(m.getSlashedClassName().equals(\"java/lang/String\")) {\n                    if((m.getName().equals(\"charAt\") || m.getName().equals(\"codePointAt\")) && m.getSignature().startsWith(\"(I)\")) {\n                        checkRange(stack.getStackItem(0), 0, stack.getStackItem(1).getConstant(), \"RANGE_STRING_INDEX\");\n                    }\n                    if(m.getName().equals(\"substring\") || m.getName().equals(\"subSequence\")) {\n                        int nArgs = getNumberArguments(m.getSignature());\n                        Item thisArg = stack.getStackItem(nArgs);\n                        Item firstArg = stack.getStackItem(nArgs-1);\n                        Object thisConstantValue = thisArg.getConstant();\n                        int maxLength = thisConstantValue instanceof String ? ((String)thisConstantValue).length() : Integer.MAX_VALUE;\n                        checkRange(firstArg, 0,maxLength, \"RANGE_STRING_INDEX\");\n                        if(nArgs == 2) {\n                            Item secondArg = stack.getStackItem(0);\n                            checkRange(secondArg, firstArg.getConstant() == null ? 0 : firstArg.getConstant(),\n                                    maxLength,\n                                    \"RANGE_STRING_INDEX\");\n                        }\n                    }\n                }\n                if ((m.getSignature().startsWith(\"([BII)\") || m.getSignature().startsWith(\"([CII)\") || m.getSignature().startsWith(\"([III)\"))\n                        && (((m.getName().equals(\"write\") || m.getName().equals(\"read\")) && m.getSlashedClassName().startsWith(\n                                \"java/io/\")) || (m.getName().equals(\"<init>\") && m.getSlashedClassName().equals(\"java/lang/String\")))) {\n                    Item arrayArg = stack.getStackItem(2);\n                    Item offsetArg = stack.getStackItem(1);\n                    Item lengthArg = stack.getStackItem(0);\n                    int length = Integer.MAX_VALUE;\n                    if(arrayArg.getConstant() instanceof Integer) {\n                        length = (int) arrayArg.getConstant();\n                    }\n                    if(offsetArg.getConstant() instanceof Integer) {\n                        checkRange(offsetArg, 0, saturatingIncrement(length), \"RANGE_ARRAY_OFFSET\");\n                        length -= (int) offsetArg.getConstant();\n                    }\n                    checkRange(lengthArg, 0, saturatingIncrement(length), \"RANGE_ARRAY_LENGTH\");\n                }\n                break;\n            }\n            default:\n                break;\n            }\n        }","commit_id":"e09d217768d636b1eddcb90ca2317d62eacf331d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void checkRange(Item item, Object minValue, Object maxValue, String pattern) {\n            if(!(item.getConstant() instanceof Number)) {\n                return;\n            }\n            int value = ((Number)item.getConstant()).intValue();\n            int intMin = Integer.MIN_VALUE;\n            int intMax = Integer.MAX_VALUE;\n            if(minValue instanceof Number) {\n                intMin = ((Number)minValue).intValue();\n            }\n            if(maxValue instanceof Number) {\n                intMax = ((Number)maxValue).intValue()-1;\n            } else if(maxValue instanceof String) {\n                intMax = ((String)maxValue).length()-1;\n            }\n            if(value < intMin || value > intMax) {\n                BugInstance bug = new BugInstance(pattern, HIGH_PRIORITY).addClassAndMethod(DumbMethods.this).addSourceLine(DumbMethods.this)\n                        .addInt(value)\n                        .addString(value < intMin ? value + \" < \" + intMin : value + \" >= \" + (intMax + 1))\n                        .describe(StringAnnotation.ERROR_MSG_ROLE);\n                if (isMethodCall()) {\n                    bug.addCalledMethod(DumbMethods.this);\n                }\n                accumulator.accumulateBug(bug, DumbMethods.this);\n            }\n        }","id":79626,"modified_method":"private void checkRange(Item item, Object minValue, Object maxValue, String pattern) {\n            if(!(item.getConstant() instanceof Number)) {\n                return;\n            }\n            int value = ((Number)item.getConstant()).intValue();\n            int intMin = Integer.MIN_VALUE;\n            int intMax = Integer.MAX_VALUE;\n            if(minValue instanceof Number) {\n                intMin = ((Number)minValue).intValue();\n            }\n            if(maxValue instanceof Number) {\n                intMax = ((Number)maxValue).intValue();\n            } else if(maxValue instanceof String) {\n                intMax = ((String)maxValue).length()-1;\n            } else if (maxValue instanceof OpcodeStack.Item){\n                OpcodeStack.Item maxItem = (OpcodeStack.Item ) maxValue;\n                if (maxItem.getSignature().charAt(0) == '[' && maxItem.getConstant() instanceof Integer) {\n                    intMax = ((Integer)maxItem.getConstant())-1;\n\n                }\n            }\n            if (intMin > intMax) {\n                return;\n            }\n            if(value < intMin || value > intMax) {\n                BugInstance bug = new BugInstance(pattern, NORMAL_PRIORITY).addClassAndMethod(DumbMethods.this).addSourceLine(DumbMethods.this)\n                        .addInt(value).describe(IntAnnotation.INT_VALUE);\n                if (value < intMin) {\n                    bug.addInt(intMin).describe(IntAnnotation.INT_MIN_VALUE);\n                } else {\n                    bug.addInt(intMax).describe(IntAnnotation.INT_MAX_VALUE);\n                }\n\n                if (isMethodCall()) {\n                    bug.addCalledMethod(DumbMethods.this);\n                }\n                accumulator.accumulateBug(bug, DumbMethods.this);\n            }\n        }","commit_id":"e09d217768d636b1eddcb90ca2317d62eacf331d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void sawOpcode(int seen) {\n\n        if (isMethodCall()) {\n            MethodDescriptor called = getMethodDescriptorOperand();\n\n            if (previousMethodCall != null && !stack.isJumpTarget(getPC())) {\n                if (\"toString\".equals(called.getName())\n                        && \"java/lang/Integer\".equals(called.getClassDescriptor().getClassName())\n                        && \"valueOf\".equals(previousMethodCall.getName())\n                        && \"(I)Ljava/lang/Integer;\".equals(previousMethodCall.getSignature())\n                        ) {\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Integer\", \"toString\", \"(I)Ljava/lang/String;\", true);\n                    BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                    accumulator.accumulateBug(bug, this);\n\n                }  else if (\"intValue\".equals(called.getName())\n                        && \"java/lang/Integer\".equals(called.getClassDescriptor().getClassName())\n                        && \"java/lang/Integer\".equals(previousMethodCall.getSlashedClassName())\n                        && (\"<init>\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)V\".equals(previousMethodCall.getSignature())\n                                || \"valueOf\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)Ljava/lang/Integer;\".equals(previousMethodCall.getSignature())\n                                )) {\n\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;)I\", true);\n\n                    BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_FOR_PARSING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                    accumulator.accumulateBug(bug, this);\n                }  else if (\"longValue\".equals(called.getName())\n                        && \"java/lang/Long\".equals(called.getClassDescriptor().getClassName())\n                        && \"java/lang/Long\".equals(previousMethodCall.getSlashedClassName())\n                        && ( \"<init>\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)V\".equals(previousMethodCall.getSignature())\n                                ||  \"valueOf\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)Ljava/lang/Long;\".equals(previousMethodCall.getSignature()))\n                        ) {\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Long\", \"parseLong\", \"(Ljava/lang/String;)J\", true);\n\n                    BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_FOR_PARSING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                    accumulator.accumulateBug(bug, this);\n                } else if(\"compareTo\".equals(called.getName())\n                        && \"valueOf\".equals(previousMethodCall.getName())\n                        && called.getClassDescriptor().equals(previousMethodCall.getClassDescriptor()) && !previousMethodCall.getSignature().startsWith(\"(Ljava/lang/String;\")\n                        ) {\n                    String primitiveType = ClassName.getPrimitiveType(called.getClassDescriptor().getClassName());\n                    XMethod rvo = stack.getStackItem(1).getReturnValueOf();\n                    XField field = stack.getStackItem(1).getXField();\n                    String signature;\n                    if (rvo != null) {\n                        signature = new SignatureParser(rvo.getSignature()).getReturnTypeSignature();\n                    } else if (field != null) {\n                        signature = field.getSignature();\n                    } else {\n                        signature = \"\";\n                    }\n                    if (primitiveType != null\n                            && (previousMethodCall.equals(rvo) || signature.equals(primitiveType))\n                            && (getThisClass().getMajor() >= MAJOR_1_7 || getThisClass().getMajor() >= MAJOR_1_4\n                            && (primitiveType.equals(\"D\") || primitiveType.equals(\"F\")))) {\n                        MethodDescriptor shouldCall = new MethodDescriptor(called.getClassDescriptor().getClassName(), \"compare\",\n                                \"(\" + primitiveType + primitiveType + \")I\", true);\n                        BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_FOR_COMPARE\",\n                                primitiveType.equals(\"Z\") ? LOW_PRIORITY : primitiveType.equals(\"B\") ? NORMAL_PRIORITY\n                                        : HIGH_PRIORITY).addClassAndMethod(this).addCalledMethod(this).addMethod(shouldCall)\n                                        .describe(MethodAnnotation.SHOULD_CALL);\n                        accumulator.accumulateBug(bug, this);\n                    }\n                }\n            }\n            previousMethodCall = called;\n        } else {\n            previousMethodCall = null;\n        }\n\n\n        if (seen == LDC || seen == LDC_W || seen == LDC2_W) {\n            Constant c = getConstantRefOperand();\n            if (testingEnabled && (c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT)) {\n                BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                        .addString(\"Did you mean MICROS_PER_DAY\").addInt(MICROS_PER_DAY_OVERFLOWED_AS_INT)\n                        .describe(IntAnnotation.INT_VALUE);\n                accumulator.accumulateBug(bug, this);\n            }\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == Integer.MIN_VALUE\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == Long.MIN_VALUE)) {\n                sawLoadOfMinValue = true;\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n                absoluteValueAccumulator.clearBugs();\n            }\n        }\n\n\n        if (seen == LCMP) {\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            checkForCompatibleLongComparison(left, right);\n            checkForCompatibleLongComparison(right, left);\n        }\n\n        if (stack.getStackDepth() >= 2) {\n            switch (seen) {\n            case IF_ICMPEQ:\n            case IF_ICMPNE:\n            case IF_ICMPLE:\n            case IF_ICMPGE:\n            case IF_ICMPLT:\n            case IF_ICMPGT:\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item0.getConstant() instanceof Integer) {\n                    OpcodeStack.Item tmp = item0;\n                    item0 = item1;\n                    item1 = tmp;\n                }\n                Object constant1 = item1.getConstant();\n                XMethod returnValueOf = item0.getReturnValueOf();\n                if (constant1 instanceof Integer\n                        && returnValueOf != null\n                        && \"getYear\".equals(returnValueOf.getName())\n                        && (\"java.util.Date\".equals(returnValueOf.getClassName()) || \"java.sql.Date\".equals(returnValueOf.getClassName()))) {\n                    int year = (Integer) constant1;\n                    if (testingEnabled && year > 1900) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                                .addString(\"Comparison of getYear does understand that it returns year-1900\")\n                                .addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addInt(year)\n                                .describe(IntAnnotation.INT_VALUE), this);\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        // System.out.printf(\"%4d %10s: %s\\n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n        if (seen == IFLT && stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n            sawCheckForNonNegativeSignedByte = getPC();\n        }\n\n        if (pendingAbsoluteValueBug != null) {\n            if (opcodesSincePendingAbsoluteValueBug == 0) {\n                opcodesSincePendingAbsoluteValueBug++;\n            } else {\n                if (seen == IREM) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    Object constantValue = top.getConstant();\n                    if (constantValue instanceof Number && Util.isPowerOfTwo(((Number) constantValue).intValue())) {\n                        pendingAbsoluteValueBug.setPriority(Priorities.LOW_PRIORITY);\n                    }\n                }\n                /*\n                if (false)\n                    try {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen] + \":\"\n                                + OPCODE_NAMES[getNextOpcode()]);\n                    } catch (Exception e) {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen]);\n\n                    }\n                 */\n                absoluteValueAccumulator.accumulateBug(pendingAbsoluteValueBug, pendingAbsoluteValueBugSourceLine);\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n            }\n        }\n\n        if (seen == INVOKESTATIC\n                && \"org/easymock/EasyMock\".equals(getClassConstantOperand())\n                && (\"replay\".equals(getNameConstantOperand()) || \"verify\".equals(getNameConstantOperand()) || getNameConstantOperand()\n                        .startsWith(\"reset\")) && \"([Ljava/lang/Object;)V\".equals(getSigConstantOperand())\n                        && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD\", NORMAL_PRIORITY)\n            .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)\n                && getSigConstantOperand().indexOf(\"Ljava/lang/Runnable;\") >= 0) {\n            SignatureParser parser = new SignatureParser(getSigConstantOperand());\n            int count = 0;\n            for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {\n                String parameter = i.next();\n                if (\"Ljava/lang/Runnable;\".equals(parameter)) {\n                    OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);\n                    if (\"Ljava/lang/Thread;\".equals(item.getSignature())) {\n                        accumulator.accumulateBug(new BugInstance(this, \"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED\",\n                                NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this), this);\n                    }\n\n                }\n            }\n\n        }\n\n        if (prevOpcode == I2L && seen == INVOKESTATIC && \"java/lang/Double\".equals(getClassConstantOperand())\n                && \"longBitsToDouble\".equals(getNameConstantOperand())) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT\", HIGH_PRIORITY)\n            .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        /**\n         * Since you can change the number of core threads for a scheduled\n         * thread pool executor, disabling this for now\n         *\n        if (false && seen == INVOKESPECIAL\n                && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"<init>\")) {\n\n            int arguments = getNumberArguments(getSigConstantOperand());\n            OpcodeStack.Item item = stack.getStackItem(arguments - 1);\n            Object value = item.getConstant();\n            if (value instanceof Integer && ((Integer) value).intValue() == 0)\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS\",\n                        HIGH_PRIORITY).addClassAndMethod(this), this);\n\n        }\n         */\n        for(SubDetector subDetector : subDetectors) {\n            subDetector.sawOpcode(seen);\n        }\n\n        if (!sawLoadOfMinValue && seen == INVOKESTATIC &&\n                ClassName.isMathClass(getClassConstantOperand()) && \"abs\".equals(getNameConstantOperand())\n                ) {\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            int special = item0.getSpecialKind();\n            if (special == OpcodeStack.Item.RANDOM_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_RANDOM_INT\", HIGH_PRIORITY)\n                .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n            else if (special == OpcodeStack.Item.HASHCODE_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_HASHCODE\", HIGH_PRIORITY)\n                .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n        }\n\n        try {\n            int stackLoc = stackEntryThatMustBeNonnegative(seen);\n            if (stackLoc >= 0) {\n                OpcodeStack.Item tos = stack.getStackItem(stackLoc);\n                switch (tos.getSpecialKind()) {\n                case OpcodeStack.Item.HASHCODE_INT_REMAINDER:\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_REM_OF_HASHCODE\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n\n                    break;\n                case OpcodeStack.Item.RANDOM_INT:\n                case OpcodeStack.Item.RANDOM_INT_REMAINDER:\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"RV_REM_OF_RANDOM_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n            if (seen == IREM) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                Object constant0 = item0.getConstant();\n                if (constant0 instanceof Integer && ((Integer) constant0).intValue() == 1) {\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_REM_BY_1\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n\n            if (stack.getStackDepth() >= 1 && (seen == LOOKUPSWITCH || seen == TABLESWITCH)) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n                    int[] switchLabels = getSwitchLabels();\n                    int[] switchOffsets = getSwitchOffsets();\n                    for (int i = 0; i < switchLabels.length; i++) {\n                        int v = switchLabels[i];\n                        if (v <= -129 || v >= 128) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", HIGH_PRIORITY)\n                            .addClassAndMethod(this).addInt(v).describe(IntAnnotation.INT_VALUE),\n                            SourceLineAnnotation.fromVisitedInstruction(this, getPC() + switchOffsets[i]));\n                        }\n\n                    }\n                }\n            }\n            // check for use of signed byte where is it assumed it can be out of\n            // the -128...127 range\n            if (stack.getStackDepth() >= 2) {\n                switch (seen) {\n                case IF_ICMPEQ:\n                case IF_ICMPNE:\n                case IF_ICMPLT:\n                case IF_ICMPLE:\n                case IF_ICMPGE:\n                case IF_ICMPGT:\n                    OpcodeStack.Item item0 = stack.getStackItem(0);\n                    OpcodeStack.Item item1 = stack.getStackItem(1);\n                    int seen2 = seen;\n                    if (item0.getConstant() != null) {\n                        OpcodeStack.Item tmp = item0;\n                        item0 = item1;\n                        item1 = tmp;\n                        switch (seen) {\n                        case IF_ICMPLT:\n                            seen2 = IF_ICMPGT;\n                            break;\n                        case IF_ICMPGE:\n                            seen2 = IF_ICMPLE;\n                            break;\n                        case IF_ICMPGT:\n                            seen2 = IF_ICMPLT;\n                            break;\n                        case IF_ICMPLE:\n                            seen2 = IF_ICMPGE;\n                            break;\n                        default:\n                            break;\n                        }\n                    }\n                    Object constant1 = item1.getConstant();\n                    if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 <= -129 || v1 >= 128 || v1 == 127 && !(seen2 == IF_ICMPEQ || seen2 == IF_ICMPNE\n\n                                )) {\n                            int priority = HIGH_PRIORITY;\n                            if (v1 == 127) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 127 > x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 127 >= x : always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 127 < x : never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 127 <= x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 == 128) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 128 > x; always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 128 >= x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 128 < x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 128 <= x; never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 <= -129) {\n                                priority = NORMAL_PRIORITY;\n                            }\n\n                            if (getPC() - sawCheckForNonNegativeSignedByte < 10) {\n                                priority++;\n                            }\n\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", priority)\n                            .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n\n                        }\n                    } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 < 0) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n                        }\n\n                    }\n\n                }\n            }\n\n            switch (seen) {\n            case IFGE:\n            case IFLT:\n                if(stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    if (top.getSignature().equals(\"C\") && top.getRegisterNumber() != -1 && getMaxPC() > getNextPC() + 2) {\n                        //                        for(int i = -2; i <= 0; i++) {\n                        //                            int o = getPrevOpcode(-i);\n                        //                            System.out.printf(\"%2d %3d  %2x %s%n\",  i, o, o, OPCODE_NAMES[o]);\n                        //                        }\n                        //                        for(int i = 0; i < 5; i++) {\n                        //                            int o = getNextCodeByte(i);\n                        //                            System.out.printf(\"%2d %3d %2x %s%n\",  i, o, o, OPCODE_NAMES[o]);\n                        //\n                        //                        }\n                        int jump = IF_ICMPGE;\n                        if (seen == IFGE) {\n                            jump = IF_ICMPLT;\n                        }\n                        int nextCodeByte0 = getNextCodeByte(0);\n                        int nextCodeByte1 = getNextCodeByte(1);\n                        int nextCodeByte2 = getNextCodeByte(2);\n                        int nextCodeByte3 = getNextCodeByte(3);\n                        int nextCodeByte4 = getNextCodeByte(4);\n                        if (nextCodeByte0 == getPrevOpcode(1)\n                                && (nextCodeByte1 == BIPUSH && nextCodeByte2 == 128\n                                && nextCodeByte3 == jump\n                                || nextCodeByte1 == SIPUSH && nextCodeByte2 == 0 && nextCodeByte3 == 128\n                                && nextCodeByte4 == jump)\n                                ) {\n                            break;\n                        }\n                    }\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                            NORMAL_PRIORITY).addClassAndMethod(this).addInt(0).describe(IntAnnotation.INT_VALUE), this);\n                }\n                break;\n            case IAND:\n            case LAND:\n            case IOR:\n            case LOR:\n            case IXOR:\n            case LXOR:\n                long badValue = (seen == IAND || seen == LAND) ? -1 : 0;\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                int prevOpcode = getPrevOpcode(1);\n                int prevPrevOpcode = getPrevOpcode(2);\n                if (rhs.hasConstantValue(badValue)\n                        && (prevOpcode == LDC || prevOpcode == ICONST_0 || prevOpcode == ICONST_M1 || prevOpcode == LCONST_0)\n                        && prevPrevOpcode != GOTO) {\n                    reportVacuousBitOperation(seen, lhs);\n                }\n\n            }\n\n            if (checkForBitIorofSignedByte && seen != I2B) {\n                String pattern = (prevOpcode == LOR || prevOpcode == IOR) ? \"BIT_IOR_OF_SIGNED_BYTE\" : \"BIT_ADD_OF_SIGNED_BYTE\";\n                int priority = (prevOpcode == LOR || prevOpcode == LADD) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n                accumulator.accumulateBug(new BugInstance(this, pattern, priority).addClassAndMethod(this), this);\n\n                checkForBitIorofSignedByte = false;\n            } else if ((seen == IOR || seen == LOR || seen == IADD || seen == LADD) && stack.getStackDepth() >= 2) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n\n                int special0 = item0.getSpecialKind();\n                int special1 = item1.getSpecialKind();\n                if (special0 == OpcodeStack.Item.SIGNED_BYTE && special1 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item1.hasConstantValue(256) || special0 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item0.hasConstantValue(256) && special1 == OpcodeStack.Item.SIGNED_BYTE) {\n                    checkForBitIorofSignedByte = true;\n                } else {\n                    checkForBitIorofSignedByte = false;\n                }\n            } else {\n                checkForBitIorofSignedByte = false;\n            }\n\n            if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL\n                    && \"java/lang/String\".equals(getClassConstantOperand()) && getSigConstantOperand().startsWith(\"()\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"NP_IMMEDIATE_DEREFERENCE_OF_READLINE\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            if (seen == INVOKEVIRTUAL && \"java/io/BufferedReader\".equals(getClassConstantOperand())\n                    && \"ready\".equals(getNameConstantOperand()) && \"()Z\".equals(getSigConstantOperand())) {\n                sinceBufferedInputStreamReady = 0;\n            } else {\n                sinceBufferedInputStreamReady++;\n            }\n\n            prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n                    && \"readLine\".equals(getNameConstantOperand()) && \"()Ljava/lang/String;\".equals(getSigConstantOperand());\n\n            // System.out.println(randomNextIntState + \" \" + OPCODE_NAMES[seen]\n            // + \" \" + getMethodName());\n            switch (randomNextIntState) {\n            case 0:\n                if (seen == INVOKEVIRTUAL && \"java/util/Random\".equals(getClassConstantOperand())\n                && \"nextDouble\".equals(getNameConstantOperand()) || seen == INVOKESTATIC\n                && ClassName.isMathClass(getClassConstantOperand()) && \"random\".equals(getNameConstantOperand())) {\n                    randomNextIntState = 1;\n                }\n                break;\n            case 1:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_01_TO_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    randomNextIntState = 0;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else if (seen == LDC2_W && getConstantRefOperand() instanceof ConstantDouble\n                        && ((ConstantDouble) getConstantRefOperand()).getBytes() == Integer.MIN_VALUE) {\n                    randomNextIntState = 0;\n                } else {\n                    randomNextIntState = 2;\n                }\n\n                break;\n            case 2:\n                if (seen == I2D) {\n                    randomNextIntState = 3;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 3:\n                if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 4:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"DM_NEXTINT_VIA_NEXTDOUBLE\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n                }\n                randomNextIntState = 0;\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            if (isPublicStaticVoidMain\n                    && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().startsWith(\"javax/swing/\")\n                    && (\"show\".equals(getNameConstantOperand()) && \"()V\".equals(getSigConstantOperand())\n                            || \"pack\".equals(getNameConstantOperand()) && \"()V\".equals(getSigConstantOperand()) || \"setVisible\".equals(getNameConstantOperand()) && \"(Z)V\".equals(getSigConstantOperand()))) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            // if ((seen == INVOKEVIRTUAL)\n            // && getClassConstantOperand().equals(\"java/lang/String\")\n            // && getNameConstantOperand().equals(\"substring\")\n            // && getSigConstantOperand().equals(\"(I)Ljava/lang/String;\")\n            // && stack.getStackDepth() > 1) {\n            // OpcodeStack.Item item = stack.getStackItem(0);\n            // Object o = item.getConstant();\n            // if (o != null && o instanceof Integer) {\n            // int v = ((Integer) o).intValue();\n            // if (v == 0)\n            // accumulator.accumulateBug(new BugInstance(this,\n            // \"DMI_USELESS_SUBSTRING\", NORMAL_PRIORITY)\n            // .addClassAndMethod(this)\n            // .addSourceLine(this));\n            // }\n            // }\n\n            if ((seen == INVOKEVIRTUAL) && \"isAnnotationPresent\".equals(getNameConstantOperand())\n                    && \"(Ljava/lang/Class;)Z\".equals(getSigConstantOperand()) && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                Object value = item.getConstant();\n                if (value instanceof String) {\n                    String annotationClassName = (String) value;\n                    boolean lacksClassfileRetention = AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()\n                            .lacksRuntimeRetention(annotationClassName.replace('/', '.'));\n                    if (lacksClassfileRetention) {\n                        ClassDescriptor annotationClass = DescriptorFactory.createClassDescriptor(annotationClassName);\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION\", HIGH_PRIORITY)\n                                .addClassAndMethod(this).addCalledMethod(this).addClass(annotationClass)\n                                .describe(ClassAnnotation.ANNOTATION_ROLE), this);\n                    }\n\n                }\n\n            }\n            if ((seen == INVOKEVIRTUAL) && \"next\".equals(getNameConstantOperand())\n                    && \"()Ljava/lang/Object;\".equals(getSigConstantOperand()) && \"hasNext\".equals(getMethodName())\n                    && \"()Z\".equals(getMethodSig()) && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_CALLING_NEXT_FROM_HASNEXT\", item.isInitialParameter()\n                        && item.getRegisterNumber() == 0 ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && \"(Ljava/lang/String;)V\".equals(getSigConstantOperand())\n                    && !Subtypes2.isJSP(getThisClass())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if (seen == INVOKESTATIC && \"java/lang/System\".equals(getClassConstantOperand())\n                    && \"runFinalizersOnExit\".equals(getNameConstantOperand()) || seen == INVOKEVIRTUAL\n                    && \"java/lang/Runtime\".equals(getClassConstantOperand())\n                    && \"runFinalizersOnExit\".equals(getNameConstantOperand())) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_RUN_FINALIZERS_ON_EXIT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n            }\n\n            if ((seen == INVOKESPECIAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && \"()V\".equals(getSigConstantOperand())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n\n            }\n\n            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && \"java/lang/System\".equals(getClassConstantOperand())\n                    && \"exit\".equals(getNameConstantOperand()) && !\"processWindowEvent\".equals(getMethodName())\n                    && !getMethodName().startsWith(\"windowClos\") && getMethodName().indexOf(\"exit\") == -1\n                    && getMethodName().indexOf(\"Exit\") == -1 && getMethodName().indexOf(\"crash\") == -1\n                    && getMethodName().indexOf(\"Crash\") == -1 && getMethodName().indexOf(\"die\") == -1\n                    && getMethodName().indexOf(\"Die\") == -1 && getMethodName().indexOf(\"main\") == -1) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_EXIT\", getMethod().isStatic() ? LOW_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));\n            }\n            if (((seen == INVOKESTATIC && \"java/lang/System\".equals(getClassConstantOperand())) || (seen == INVOKEVIRTUAL && \"java/lang/Runtime\".equals(getClassConstantOperand())))\n                    && \"gc\".equals(getNameConstantOperand())\n                    && \"()V\".equals(getSigConstantOperand())\n                    && !getDottedClassName().startsWith(\"java.lang\")\n                    && !getMethodName().startsWith(\"gc\") && !getMethodName().endsWith(\"gc\")) {\n                if (gcInvocationBugReport == null) {\n                    // System.out.println(\"Saw call to GC\");\n                    if (isPublicStaticVoidMain) {\n                        // System.out.println(\"Skipping GC complaint in main method\");\n                        return;\n                    }\n                    if (isTestMethod(getMethod())) {\n                        return;\n                    }\n                    // Just save this report in a field; it will be flushed\n                    // IFF there were no calls to System.currentTimeMillis();\n                    // in the method.\n                    gcInvocationBugReport = new BugInstance(this, \"DM_GC\", HIGH_PRIORITY).addClassAndMethod(this).addSourceLine(\n                            this);\n                    gcInvocationPC = getPC();\n                    // System.out.println(\"GC invocation at pc \" + PC);\n                }\n            }\n            if (!isSynthetic && (seen == INVOKESPECIAL) && \"java/lang/Boolean\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && !\"java/lang/Boolean\".equals(getClassName())) {\n                int majorVersion = getThisClass().getMajor();\n                if (majorVersion >= MAJOR_1_4) {\n                    accumulator.accumulateBug(new BugInstance(this, \"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n            if ((seen == INVOKESTATIC) && \"java/lang/System\".equals(getClassConstantOperand())\n                    && (\"currentTimeMillis\".equals(getNameConstantOperand()) || \"nanoTime\".equals(getNameConstantOperand()))) {\n                sawCurrentTimeMillis = true;\n            }\n            if ((seen == INVOKEVIRTUAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && \"toString\".equals(getNameConstantOperand()) && \"()Ljava/lang/String;\".equals(getSigConstantOperand())) {\n\n                accumulator\n                .accumulateBug(new BugInstance(this, \"DM_STRING_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKEVIRTUAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && (\"toUpperCase\".equals(getNameConstantOperand()) || \"toLowerCase\".equals(getNameConstantOperand()))\n                    && \"()Ljava/lang/String;\".equals(getSigConstantOperand())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_CONVERT_CASE\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && \"<init>\".equals(getNameConstantOperand())) {\n                String cls = getClassConstantOperand();\n                String sig = getSigConstantOperand();\n                String primitiveType = ClassName.getPrimitiveType(cls);\n                if (primitiveType != null && sig.charAt(1) == primitiveType.charAt(0)) {\n                    primitiveObjCtorSeen = cls;\n                } else {\n                    primitiveObjCtorSeen = null;\n                }\n            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && \"toString\".equals(getNameConstantOperand())\n                    && getClassConstantOperand().equals(primitiveObjCtorSeen)\n                    && \"()Ljava/lang/String;\".equals(getSigConstantOperand())) {\n                BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this);\n                MethodAnnotation preferred = new MethodAnnotation(ClassName.toDottedClassName(primitiveObjCtorSeen),\n                        \"toString\", \"(\"+ClassName.getPrimitiveType(primitiveObjCtorSeen)+\")Ljava/lang/String;\", true);\n                bug.addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                accumulator.accumulateBug(\n                        bug, this);\n\n                primitiveObjCtorSeen = null;\n            } else {\n                primitiveObjCtorSeen = null;\n            }\n\n            if ((seen == INVOKESPECIAL) && \"<init>\".equals(getNameConstantOperand())) {\n                ctorSeen = true;\n            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && \"java/lang/Object\".equals(getClassConstantOperand())\n                    && \"getClass\".equals(getNameConstantOperand()) && \"()Ljava/lang/Class;\".equals(getSigConstantOperand())) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_NEW_FOR_GETCLASS\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n                ctorSeen = false;\n            } else {\n                ctorSeen = false;\n            }\n\n            if ((seen == INVOKEVIRTUAL) && isMonitorWait(getNameConstantOperand(), getSigConstantOperand())) {\n                checkMonitorWait();\n            }\n\n            if ((seen == INVOKESPECIAL) && \"<init>\".equals(getNameConstantOperand())\n                    && \"java/lang/Thread\".equals(getClassConstantOperand())) {\n                String sig = getSigConstantOperand();\n                if (\"()V\".equals(sig) || \"(Ljava/lang/String;)V\".equals(sig)\n                        || \"(Ljava/lang/ThreadGroup;Ljava/lang/String;)V\".equals(sig)) {\n                    OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);\n                    if (!\"<init>\".equals(getMethodName()) || invokedOn.getRegisterNumber() != 0) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DM_USELESS_THREAD\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                    }\n                }\n            }\n\n            if (seen == INVOKESPECIAL && \"java/math/BigDecimal\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && \"(D)V\".equals(getSigConstantOperand())) {\n                OpcodeStack.Item top = stack.getStackItem(0);\n                Object value = top.getConstant();\n                if (value instanceof Double && !((Double)value).isInfinite() && !((Double)value).isNaN()) {\n                    double arg = ((Double) value).doubleValue();\n                    String dblString = Double.toString(arg);\n                    String bigDecimalString = new BigDecimal(arg).toString();\n                    boolean ok = dblString.equals(bigDecimalString) || dblString.equals(bigDecimalString + \".0\");\n\n                    if (!ok) {\n                        boolean scary = dblString.length() <= 8 && bigDecimalString.length() > 12\n                                && dblString.toUpperCase().indexOf('E') == -1;\n                        bugReporter.reportBug(new BugInstance(this, \"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE\",\n                                scary ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this).addCalledMethod(this)\n                                .addMethod(\"java.math.BigDecimal\", \"valueOf\", \"(D)Ljava/math/BigDecimal;\", true)\n                                .describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET).addString(dblString)\n                                .addString(bigDecimalString).addSourceLine(this));\n                    }\n                }\n\n            }\n\n        } finally {\n            prevOpcode = seen;\n        }\n    }","id":79627,"modified_method":"@Override\n    public void sawOpcode(int seen) {\n\n        if (isMethodCall()) {\n            MethodDescriptor called = getMethodDescriptorOperand();\n\n            if (previousMethodCall != null && !stack.isJumpTarget(getPC())) {\n                if (\"toString\".equals(called.getName())\n                        && \"java/lang/Integer\".equals(called.getClassDescriptor().getClassName())\n                        && \"valueOf\".equals(previousMethodCall.getName())\n                        && \"(I)Ljava/lang/Integer;\".equals(previousMethodCall.getSignature())\n                        ) {\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Integer\", \"toString\", \"(I)Ljava/lang/String;\", true);\n                    BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                    accumulator.accumulateBug(bug, this);\n\n                }  else if (\"intValue\".equals(called.getName())\n                        && \"java/lang/Integer\".equals(called.getClassDescriptor().getClassName())\n                        && \"java/lang/Integer\".equals(previousMethodCall.getSlashedClassName())\n                        && (\"<init>\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)V\".equals(previousMethodCall.getSignature())\n                                || \"valueOf\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)Ljava/lang/Integer;\".equals(previousMethodCall.getSignature())\n                                )) {\n\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;)I\", true);\n\n                    BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_FOR_PARSING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                    accumulator.accumulateBug(bug, this);\n                }  else if (\"longValue\".equals(called.getName())\n                        && \"java/lang/Long\".equals(called.getClassDescriptor().getClassName())\n                        && \"java/lang/Long\".equals(previousMethodCall.getSlashedClassName())\n                        && ( \"<init>\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)V\".equals(previousMethodCall.getSignature())\n                                ||  \"valueOf\".equals(previousMethodCall.getName())\n                                && \"(Ljava/lang/String;)Ljava/lang/Long;\".equals(previousMethodCall.getSignature()))\n                        ) {\n                    MethodAnnotation preferred = new MethodAnnotation(\"java.lang.Long\", \"parseLong\", \"(Ljava/lang/String;)J\", true);\n\n                    BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_FOR_PARSING\", HIGH_PRIORITY).addClassAndMethod(this)\n                            .addCalledMethod(this).addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                    accumulator.accumulateBug(bug, this);\n                } else if(\"compareTo\".equals(called.getName())\n                        && \"valueOf\".equals(previousMethodCall.getName())\n                        && called.getClassDescriptor().equals(previousMethodCall.getClassDescriptor()) && !previousMethodCall.getSignature().startsWith(\"(Ljava/lang/String;\")\n                        ) {\n                    String primitiveType = ClassName.getPrimitiveType(called.getClassDescriptor().getClassName());\n                    XMethod rvo = stack.getStackItem(1).getReturnValueOf();\n                    XField field = stack.getStackItem(1).getXField();\n                    String signature;\n                    if (rvo != null) {\n                        signature = new SignatureParser(rvo.getSignature()).getReturnTypeSignature();\n                    } else if (field != null) {\n                        signature = field.getSignature();\n                    } else {\n                        signature = \"\";\n                    }\n                    if (primitiveType != null\n                            && (previousMethodCall.equals(rvo) || signature.equals(primitiveType))\n                            && (getThisClass().getMajor() >= MAJOR_1_7 || getThisClass().getMajor() >= MAJOR_1_4\n                            && (primitiveType.equals(\"D\") || primitiveType.equals(\"F\")))) {\n                        MethodDescriptor shouldCall = new MethodDescriptor(called.getClassDescriptor().getClassName(), \"compare\",\n                                \"(\" + primitiveType + primitiveType + \")I\", true);\n                        BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_FOR_COMPARE\",\n                                primitiveType.equals(\"Z\") ? LOW_PRIORITY : primitiveType.equals(\"B\") ? NORMAL_PRIORITY\n                                        : HIGH_PRIORITY).addClassAndMethod(this).addCalledMethod(this).addMethod(shouldCall)\n                                        .describe(MethodAnnotation.SHOULD_CALL);\n                        accumulator.accumulateBug(bug, this);\n                    }\n                }\n            }\n            previousMethodCall = called;\n        } else {\n            previousMethodCall = null;\n        }\n\n\n        if (seen == LDC || seen == LDC_W || seen == LDC2_W) {\n            Constant c = getConstantRefOperand();\n            if (testingEnabled && (c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == MICROS_PER_DAY_OVERFLOWED_AS_INT)) {\n                BugInstance bug = new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                        .addString(\"Did you mean MICROS_PER_DAY\").addInt(MICROS_PER_DAY_OVERFLOWED_AS_INT)\n                        .describe(IntAnnotation.INT_VALUE);\n                accumulator.accumulateBug(bug, this);\n            }\n            if ((c instanceof ConstantInteger && ((ConstantInteger) c).getBytes() == Integer.MIN_VALUE\n                    || c instanceof ConstantLong && ((ConstantLong) c).getBytes() == Long.MIN_VALUE)) {\n                sawLoadOfMinValue = true;\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n                absoluteValueAccumulator.clearBugs();\n            }\n        }\n\n\n        if (seen == LCMP) {\n            OpcodeStack.Item left = stack.getStackItem(1);\n            OpcodeStack.Item right = stack.getStackItem(0);\n            checkForCompatibleLongComparison(left, right);\n            checkForCompatibleLongComparison(right, left);\n        }\n\n        if (stack.getStackDepth() >= 2) {\n            switch (seen) {\n            case IF_ICMPEQ:\n            case IF_ICMPNE:\n            case IF_ICMPLE:\n            case IF_ICMPGE:\n            case IF_ICMPLT:\n            case IF_ICMPGT:\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n                if (item0.getConstant() instanceof Integer) {\n                    OpcodeStack.Item tmp = item0;\n                    item0 = item1;\n                    item1 = tmp;\n                }\n                Object constant1 = item1.getConstant();\n                XMethod returnValueOf = item0.getReturnValueOf();\n                if (constant1 instanceof Integer\n                        && returnValueOf != null\n                        && \"getYear\".equals(returnValueOf.getName())\n                        && (\"java.util.Date\".equals(returnValueOf.getClassName()) || \"java.sql.Date\".equals(returnValueOf.getClassName()))) {\n                    int year = (Integer) constant1;\n                    if (testingEnabled && year > 1900) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"TESTING\", HIGH_PRIORITY).addClassAndMethod(this)\n                                .addString(\"Comparison of getYear does understand that it returns year-1900\")\n                                .addMethod(returnValueOf).describe(MethodAnnotation.METHOD_CALLED).addInt(year)\n                                .describe(IntAnnotation.INT_VALUE), this);\n                    }\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        // System.out.printf(\"%4d %10s: %s\\n\", getPC(), OPCODE_NAMES[seen],\n        // stack);\n        if (seen == IFLT && stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n            sawCheckForNonNegativeSignedByte = getPC();\n        }\n\n        if (pendingAbsoluteValueBug != null) {\n            if (opcodesSincePendingAbsoluteValueBug == 0) {\n                opcodesSincePendingAbsoluteValueBug++;\n            } else {\n                if (seen == IREM) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    Object constantValue = top.getConstant();\n                    if (constantValue instanceof Number && Util.isPowerOfTwo(((Number) constantValue).intValue())) {\n                        pendingAbsoluteValueBug.setPriority(Priorities.LOW_PRIORITY);\n                    }\n                }\n                /*\n                if (false)\n                    try {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen] + \":\"\n                                + OPCODE_NAMES[getNextOpcode()]);\n                    } catch (Exception e) {\n                        pendingAbsoluteValueBug.addString(OPCODE_NAMES[getPrevOpcode(1)] + \":\" + OPCODE_NAMES[seen]);\n\n                    }\n                 */\n                absoluteValueAccumulator.accumulateBug(pendingAbsoluteValueBug, pendingAbsoluteValueBugSourceLine);\n                pendingAbsoluteValueBug = null;\n                pendingAbsoluteValueBugSourceLine = null;\n            }\n        }\n\n        if (seen == INVOKESTATIC\n                && \"org/easymock/EasyMock\".equals(getClassConstantOperand())\n                && (\"replay\".equals(getNameConstantOperand()) || \"verify\".equals(getNameConstantOperand()) || getNameConstantOperand()\n                        .startsWith(\"reset\")) && \"([Ljava/lang/Object;)V\".equals(getSigConstantOperand())\n                        && getPrevOpcode(1) == ANEWARRAY && getPrevOpcode(2) == ICONST_0) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD\", NORMAL_PRIORITY)\n            .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        if ((seen == INVOKESTATIC || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKEINTERFACE)\n                && getSigConstantOperand().indexOf(\"Ljava/lang/Runnable;\") >= 0) {\n            SignatureParser parser = new SignatureParser(getSigConstantOperand());\n            int count = 0;\n            for (Iterator<String> i = parser.parameterSignatureIterator(); i.hasNext(); count++) {\n                String parameter = i.next();\n                if (\"Ljava/lang/Runnable;\".equals(parameter)) {\n                    OpcodeStack.Item item = stack.getStackItem(parser.getNumParameters() - 1 - count);\n                    if (\"Ljava/lang/Thread;\".equals(item.getSignature())) {\n                        accumulator.accumulateBug(new BugInstance(this, \"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED\",\n                                NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this), this);\n                    }\n\n                }\n            }\n\n        }\n\n        if (prevOpcode == I2L && seen == INVOKESTATIC && \"java/lang/Double\".equals(getClassConstantOperand())\n                && \"longBitsToDouble\".equals(getNameConstantOperand())) {\n            accumulator.accumulateBug(new BugInstance(this, \"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT\", HIGH_PRIORITY)\n            .addClassAndMethod(this).addCalledMethod(this), this);\n        }\n\n        /**\n         * Since you can change the number of core threads for a scheduled\n         * thread pool executor, disabling this for now\n         *\n        if (false && seen == INVOKESPECIAL\n                && getClassConstantOperand().equals(\"java/util/concurrent/ScheduledThreadPoolExecutor\")\n                && getNameConstantOperand().equals(\"<init>\")) {\n\n            int arguments = getNumberArguments(getSigConstantOperand());\n            OpcodeStack.Item item = stack.getStackItem(arguments - 1);\n            Object value = item.getConstant();\n            if (value instanceof Integer && ((Integer) value).intValue() == 0)\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS\",\n                        HIGH_PRIORITY).addClassAndMethod(this), this);\n\n        }\n         */\n        for(SubDetector subDetector : subDetectors) {\n            subDetector.sawOpcode(seen);\n        }\n\n        if (!sawLoadOfMinValue && seen == INVOKESTATIC &&\n                ClassName.isMathClass(getClassConstantOperand()) && \"abs\".equals(getNameConstantOperand())\n                ) {\n            OpcodeStack.Item item0 = stack.getStackItem(0);\n            int special = item0.getSpecialKind();\n            if (special == OpcodeStack.Item.RANDOM_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_RANDOM_INT\", HIGH_PRIORITY)\n                .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n            else if (special == OpcodeStack.Item.HASHCODE_INT) {\n                pendingAbsoluteValueBug = new BugInstance(this, \"RV_ABSOLUTE_VALUE_OF_HASHCODE\", HIGH_PRIORITY)\n                .addClassAndMethod(this);\n                pendingAbsoluteValueBugSourceLine = SourceLineAnnotation.fromVisitedInstruction(this);\n                opcodesSincePendingAbsoluteValueBug = 0;\n            }\n\n        }\n\n        try {\n            int stackLoc = stackEntryThatMustBeNonnegative(seen);\n            if (stackLoc >= 0) {\n                OpcodeStack.Item tos = stack.getStackItem(stackLoc);\n                switch (tos.getSpecialKind()) {\n                case OpcodeStack.Item.HASHCODE_INT_REMAINDER:\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_REM_OF_HASHCODE\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n\n                    break;\n                case OpcodeStack.Item.RANDOM_INT:\n                case OpcodeStack.Item.RANDOM_INT_REMAINDER:\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"RV_REM_OF_RANDOM_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n            if (seen == IREM) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                Object constant0 = item0.getConstant();\n                if (constant0 instanceof Integer && ((Integer) constant0).intValue() == 1) {\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_REM_BY_1\", HIGH_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n\n            if (stack.getStackDepth() >= 1 && (seen == LOOKUPSWITCH || seen == TABLESWITCH)) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE) {\n                    int[] switchLabels = getSwitchLabels();\n                    int[] switchOffsets = getSwitchOffsets();\n                    for (int i = 0; i < switchLabels.length; i++) {\n                        int v = switchLabels[i];\n                        if (v <= -129 || v >= 128) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", HIGH_PRIORITY)\n                            .addClassAndMethod(this).addInt(v).describe(IntAnnotation.INT_VALUE),\n                            SourceLineAnnotation.fromVisitedInstruction(this, getPC() + switchOffsets[i]));\n                        }\n\n                    }\n                }\n            }\n            // check for use of signed byte where is it assumed it can be out of\n            // the -128...127 range\n            if (stack.getStackDepth() >= 2) {\n                switch (seen) {\n                case IF_ICMPEQ:\n                case IF_ICMPNE:\n                case IF_ICMPLT:\n                case IF_ICMPLE:\n                case IF_ICMPGE:\n                case IF_ICMPGT:\n                    OpcodeStack.Item item0 = stack.getStackItem(0);\n                    OpcodeStack.Item item1 = stack.getStackItem(1);\n                    int seen2 = seen;\n                    if (item0.getConstant() != null) {\n                        OpcodeStack.Item tmp = item0;\n                        item0 = item1;\n                        item1 = tmp;\n                        switch (seen) {\n                        case IF_ICMPLT:\n                            seen2 = IF_ICMPGT;\n                            break;\n                        case IF_ICMPGE:\n                            seen2 = IF_ICMPLE;\n                            break;\n                        case IF_ICMPGT:\n                            seen2 = IF_ICMPLT;\n                            break;\n                        case IF_ICMPLE:\n                            seen2 = IF_ICMPGE;\n                            break;\n                        default:\n                            break;\n                        }\n                    }\n                    Object constant1 = item1.getConstant();\n                    if (item0.getSpecialKind() == OpcodeStack.Item.SIGNED_BYTE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 <= -129 || v1 >= 128 || v1 == 127 && !(seen2 == IF_ICMPEQ || seen2 == IF_ICMPNE\n\n                                )) {\n                            int priority = HIGH_PRIORITY;\n                            if (v1 == 127) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 127 > x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 127 >= x : always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 127 < x : never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 127 <= x\n                                    priority = LOW_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 == 128) {\n                                switch (seen2) {\n                                case IF_ICMPGT: // 128 > x; always true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                case IF_ICMPGE: // 128 >= x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLT: // 128 < x\n                                    priority = HIGH_PRIORITY;\n                                    break;\n                                case IF_ICMPLE: // 128 <= x; never true\n                                    priority = NORMAL_PRIORITY;\n                                    break;\n                                }\n                            } else if (v1 <= -129) {\n                                priority = NORMAL_PRIORITY;\n                            }\n\n                            if (getPC() - sawCheckForNonNegativeSignedByte < 10) {\n                                priority++;\n                            }\n\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_SIGNED_BYTE\", priority)\n                            .addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n\n                        }\n                    } else if (item0.getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE && constant1 instanceof Number) {\n                        int v1 = ((Number) constant1).intValue();\n                        if (v1 < 0) {\n                            accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                                    HIGH_PRIORITY).addClassAndMethod(this).addInt(v1).describe(IntAnnotation.INT_VALUE), this);\n                        }\n\n                    }\n\n                }\n            }\n\n            switch (seen) {\n            case IFGE:\n            case IFLT:\n                if(stack.getStackDepth() > 0 && stack.getStackItem(0).getSpecialKind() == OpcodeStack.Item.NON_NEGATIVE) {\n                    OpcodeStack.Item top = stack.getStackItem(0);\n                    if (top.getRegisterNumber() != -1 && getMaxPC() > getNextPC() + 6) {\n                        if (false) {\n                            for(int i = -2; i <= 0; i++) {\n                                int o = getPrevOpcode(-i);\n                                System.out.printf(\"%2d %3d  %2x %s%n\",  i, o, o, OPCODE_NAMES[o]);\n                            }\n                            for(int i = 0; i < 6; i++) {\n                                int o = getNextCodeByte(i);\n                                System.out.printf(\"%2d %3d %2x %s%n\",  i, o, o, OPCODE_NAMES[o]);\n\n                            }\n                        }\n                        int jump = IF_ICMPGE;\n                        if (seen == IFGE) {\n                            jump = IF_ICMPLT;\n                        }\n                        int nextCodeByte0 = getNextCodeByte(0);\n                        int loadConstant = 1;\n                        if (nextCodeByte0 == ILOAD) {\n                            loadConstant = 2;\n                        }\n                        int nextCodeByte1 = getNextCodeByte(loadConstant);\n                        int nextCodeByte2 = getNextCodeByte(loadConstant+1);\n                        int nextCodeByte3 = getNextCodeByte(loadConstant+2);\n                        int nextCodeByte4 = getNextCodeByte(loadConstant+3);\n                        if (nextCodeByte0 == getPrevOpcode(1)\n                                && (nextCodeByte1 == BIPUSH && nextCodeByte2 == 128\n                                && nextCodeByte3 == jump\n                                || nextCodeByte1 == SIPUSH && nextCodeByte2 == 0 && nextCodeByte3 == 128\n                                && nextCodeByte4 == jump)\n                                ) {\n                            break;\n                        }\n                    }\n                    accumulator.accumulateBug(new BugInstance(this, \"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE\",\n                            NORMAL_PRIORITY).addClassAndMethod(this).addInt(0).describe(IntAnnotation.INT_VALUE), this);\n                }\n                break;\n            case IAND:\n            case LAND:\n            case IOR:\n            case LOR:\n            case IXOR:\n            case LXOR:\n                long badValue = (seen == IAND || seen == LAND) ? -1 : 0;\n                OpcodeStack.Item rhs = stack.getStackItem(0);\n                OpcodeStack.Item lhs = stack.getStackItem(1);\n                int prevOpcode = getPrevOpcode(1);\n                int prevPrevOpcode = getPrevOpcode(2);\n                if (rhs.hasConstantValue(badValue)\n                        && (prevOpcode == LDC || prevOpcode == ICONST_0 || prevOpcode == ICONST_M1 || prevOpcode == LCONST_0)\n                        && prevPrevOpcode != GOTO) {\n                    reportVacuousBitOperation(seen, lhs);\n                }\n\n            }\n\n            if (checkForBitIorofSignedByte && seen != I2B) {\n                String pattern = (prevOpcode == LOR || prevOpcode == IOR) ? \"BIT_IOR_OF_SIGNED_BYTE\" : \"BIT_ADD_OF_SIGNED_BYTE\";\n                int priority = (prevOpcode == LOR || prevOpcode == LADD) ? HIGH_PRIORITY : NORMAL_PRIORITY;\n                accumulator.accumulateBug(new BugInstance(this, pattern, priority).addClassAndMethod(this), this);\n\n                checkForBitIorofSignedByte = false;\n            } else if ((seen == IOR || seen == LOR || seen == IADD || seen == LADD) && stack.getStackDepth() >= 2) {\n                OpcodeStack.Item item0 = stack.getStackItem(0);\n                OpcodeStack.Item item1 = stack.getStackItem(1);\n\n                int special0 = item0.getSpecialKind();\n                int special1 = item1.getSpecialKind();\n                if (special0 == OpcodeStack.Item.SIGNED_BYTE && special1 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item1.hasConstantValue(256) || special0 == OpcodeStack.Item.LOW_8_BITS_CLEAR\n                        && !item0.hasConstantValue(256) && special1 == OpcodeStack.Item.SIGNED_BYTE) {\n                    checkForBitIorofSignedByte = true;\n                } else {\n                    checkForBitIorofSignedByte = false;\n                }\n            } else {\n                checkForBitIorofSignedByte = false;\n            }\n\n            if (prevOpcodeWasReadLine && sinceBufferedInputStreamReady >= 100 && seen == INVOKEVIRTUAL\n                    && \"java/lang/String\".equals(getClassConstantOperand()) && getSigConstantOperand().startsWith(\"()\")) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"NP_IMMEDIATE_DEREFERENCE_OF_READLINE\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            if (seen == INVOKEVIRTUAL && \"java/io/BufferedReader\".equals(getClassConstantOperand())\n                    && \"ready\".equals(getNameConstantOperand()) && \"()Z\".equals(getSigConstantOperand())) {\n                sinceBufferedInputStreamReady = 0;\n            } else {\n                sinceBufferedInputStreamReady++;\n            }\n\n            prevOpcodeWasReadLine = (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n                    && \"readLine\".equals(getNameConstantOperand()) && \"()Ljava/lang/String;\".equals(getSigConstantOperand());\n\n            // System.out.println(randomNextIntState + \" \" + OPCODE_NAMES[seen]\n            // + \" \" + getMethodName());\n            switch (randomNextIntState) {\n            case 0:\n                if (seen == INVOKEVIRTUAL && \"java/util/Random\".equals(getClassConstantOperand())\n                && \"nextDouble\".equals(getNameConstantOperand()) || seen == INVOKESTATIC\n                && ClassName.isMathClass(getClassConstantOperand()) && \"random\".equals(getNameConstantOperand())) {\n                    randomNextIntState = 1;\n                }\n                break;\n            case 1:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(new BugInstance(this, \"RV_01_TO_INT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n                    randomNextIntState = 0;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else if (seen == LDC2_W && getConstantRefOperand() instanceof ConstantDouble\n                        && ((ConstantDouble) getConstantRefOperand()).getBytes() == Integer.MIN_VALUE) {\n                    randomNextIntState = 0;\n                } else {\n                    randomNextIntState = 2;\n                }\n\n                break;\n            case 2:\n                if (seen == I2D) {\n                    randomNextIntState = 3;\n                } else if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 3:\n                if (seen == DMUL) {\n                    randomNextIntState = 4;\n                } else {\n                    randomNextIntState = 0;\n                }\n                break;\n            case 4:\n                if (seen == D2I) {\n                    accumulator.accumulateBug(\n                            new BugInstance(this, \"DM_NEXTINT_VIA_NEXTDOUBLE\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n                }\n                randomNextIntState = 0;\n                break;\n            default:\n                throw new IllegalStateException();\n            }\n            if (isPublicStaticVoidMain\n                    && seen == INVOKEVIRTUAL\n                    && getClassConstantOperand().startsWith(\"javax/swing/\")\n                    && (\"show\".equals(getNameConstantOperand()) && \"()V\".equals(getSigConstantOperand())\n                            || \"pack\".equals(getNameConstantOperand()) && \"()V\".equals(getSigConstantOperand()) || \"setVisible\".equals(getNameConstantOperand()) && \"(Z)V\".equals(getSigConstantOperand()))) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD\", LOW_PRIORITY).addClassAndMethod(this),\n                        this);\n            }\n\n            // if ((seen == INVOKEVIRTUAL)\n            // && getClassConstantOperand().equals(\"java/lang/String\")\n            // && getNameConstantOperand().equals(\"substring\")\n            // && getSigConstantOperand().equals(\"(I)Ljava/lang/String;\")\n            // && stack.getStackDepth() > 1) {\n            // OpcodeStack.Item item = stack.getStackItem(0);\n            // Object o = item.getConstant();\n            // if (o != null && o instanceof Integer) {\n            // int v = ((Integer) o).intValue();\n            // if (v == 0)\n            // accumulator.accumulateBug(new BugInstance(this,\n            // \"DMI_USELESS_SUBSTRING\", NORMAL_PRIORITY)\n            // .addClassAndMethod(this)\n            // .addSourceLine(this));\n            // }\n            // }\n\n            if ((seen == INVOKEVIRTUAL) && \"isAnnotationPresent\".equals(getNameConstantOperand())\n                    && \"(Ljava/lang/Class;)Z\".equals(getSigConstantOperand()) && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n                Object value = item.getConstant();\n                if (value instanceof String) {\n                    String annotationClassName = (String) value;\n                    boolean lacksClassfileRetention = AnalysisContext.currentAnalysisContext().getAnnotationRetentionDatabase()\n                            .lacksRuntimeRetention(annotationClassName.replace('/', '.'));\n                    if (lacksClassfileRetention) {\n                        ClassDescriptor annotationClass = DescriptorFactory.createClassDescriptor(annotationClassName);\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION\", HIGH_PRIORITY)\n                                .addClassAndMethod(this).addCalledMethod(this).addClass(annotationClass)\n                                .describe(ClassAnnotation.ANNOTATION_ROLE), this);\n                    }\n\n                }\n\n            }\n            if ((seen == INVOKEVIRTUAL) && \"next\".equals(getNameConstantOperand())\n                    && \"()Ljava/lang/Object;\".equals(getSigConstantOperand()) && \"hasNext\".equals(getMethodName())\n                    && \"()Z\".equals(getMethodSig()) && stack.getStackDepth() > 0) {\n                OpcodeStack.Item item = stack.getStackItem(0);\n\n                accumulator.accumulateBug(new BugInstance(this, \"DMI_CALLING_NEXT_FROM_HASNEXT\", item.isInitialParameter()\n                        && item.getRegisterNumber() == 0 ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this)\n                        .addCalledMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && \"(Ljava/lang/String;)V\".equals(getSigConstantOperand())\n                    && !Subtypes2.isJSP(getThisClass())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if (seen == INVOKESTATIC && \"java/lang/System\".equals(getClassConstantOperand())\n                    && \"runFinalizersOnExit\".equals(getNameConstantOperand()) || seen == INVOKEVIRTUAL\n                    && \"java/lang/Runtime\".equals(getClassConstantOperand())\n                    && \"runFinalizersOnExit\".equals(getNameConstantOperand())) {\n                accumulator.accumulateBug(\n                        new BugInstance(this, \"DM_RUN_FINALIZERS_ON_EXIT\", HIGH_PRIORITY).addClassAndMethod(this), this);\n            }\n\n            if ((seen == INVOKESPECIAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && \"()V\".equals(getSigConstantOperand())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_STRING_VOID_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n\n            }\n\n            if (!isPublicStaticVoidMain && seen == INVOKESTATIC && \"java/lang/System\".equals(getClassConstantOperand())\n                    && \"exit\".equals(getNameConstantOperand()) && !\"processWindowEvent\".equals(getMethodName())\n                    && !getMethodName().startsWith(\"windowClos\") && getMethodName().indexOf(\"exit\") == -1\n                    && getMethodName().indexOf(\"Exit\") == -1 && getMethodName().indexOf(\"crash\") == -1\n                    && getMethodName().indexOf(\"Crash\") == -1 && getMethodName().indexOf(\"die\") == -1\n                    && getMethodName().indexOf(\"Die\") == -1 && getMethodName().indexOf(\"main\") == -1) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_EXIT\", getMethod().isStatic() ? LOW_PRIORITY\n                        : NORMAL_PRIORITY).addClassAndMethod(this), SourceLineAnnotation.fromVisitedInstruction(this));\n            }\n            if (((seen == INVOKESTATIC && \"java/lang/System\".equals(getClassConstantOperand())) || (seen == INVOKEVIRTUAL && \"java/lang/Runtime\".equals(getClassConstantOperand())))\n                    && \"gc\".equals(getNameConstantOperand())\n                    && \"()V\".equals(getSigConstantOperand())\n                    && !getDottedClassName().startsWith(\"java.lang\")\n                    && !getMethodName().startsWith(\"gc\") && !getMethodName().endsWith(\"gc\")) {\n                if (gcInvocationBugReport == null) {\n                    // System.out.println(\"Saw call to GC\");\n                    if (isPublicStaticVoidMain) {\n                        // System.out.println(\"Skipping GC complaint in main method\");\n                        return;\n                    }\n                    if (isTestMethod(getMethod())) {\n                        return;\n                    }\n                    // Just save this report in a field; it will be flushed\n                    // IFF there were no calls to System.currentTimeMillis();\n                    // in the method.\n                    gcInvocationBugReport = new BugInstance(this, \"DM_GC\", HIGH_PRIORITY).addClassAndMethod(this).addSourceLine(\n                            this);\n                    gcInvocationPC = getPC();\n                    // System.out.println(\"GC invocation at pc \" + PC);\n                }\n            }\n            if (!isSynthetic && (seen == INVOKESPECIAL) && \"java/lang/Boolean\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && !\"java/lang/Boolean\".equals(getClassName())) {\n                int majorVersion = getThisClass().getMajor();\n                if (majorVersion >= MAJOR_1_4) {\n                    accumulator.accumulateBug(new BugInstance(this, \"DM_BOOLEAN_CTOR\", NORMAL_PRIORITY).addClassAndMethod(this),\n                            this);\n                }\n\n            }\n            if ((seen == INVOKESTATIC) && \"java/lang/System\".equals(getClassConstantOperand())\n                    && (\"currentTimeMillis\".equals(getNameConstantOperand()) || \"nanoTime\".equals(getNameConstantOperand()))) {\n                sawCurrentTimeMillis = true;\n            }\n            if ((seen == INVOKEVIRTUAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && \"toString\".equals(getNameConstantOperand()) && \"()Ljava/lang/String;\".equals(getSigConstantOperand())) {\n\n                accumulator\n                .accumulateBug(new BugInstance(this, \"DM_STRING_TOSTRING\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKEVIRTUAL) && \"java/lang/String\".equals(getClassConstantOperand())\n                    && (\"toUpperCase\".equals(getNameConstantOperand()) || \"toLowerCase\".equals(getNameConstantOperand()))\n                    && \"()Ljava/lang/String;\".equals(getSigConstantOperand())) {\n\n                accumulator.accumulateBug(new BugInstance(this, \"DM_CONVERT_CASE\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n            }\n\n            if ((seen == INVOKESPECIAL) && \"<init>\".equals(getNameConstantOperand())) {\n                String cls = getClassConstantOperand();\n                String sig = getSigConstantOperand();\n                String primitiveType = ClassName.getPrimitiveType(cls);\n                if (primitiveType != null && sig.charAt(1) == primitiveType.charAt(0)) {\n                    primitiveObjCtorSeen = cls;\n                } else {\n                    primitiveObjCtorSeen = null;\n                }\n            } else if ((primitiveObjCtorSeen != null) && (seen == INVOKEVIRTUAL) && \"toString\".equals(getNameConstantOperand())\n                    && getClassConstantOperand().equals(primitiveObjCtorSeen)\n                    && \"()Ljava/lang/String;\".equals(getSigConstantOperand())) {\n                BugInstance bug = new BugInstance(this, \"DM_BOXED_PRIMITIVE_TOSTRING\", NORMAL_PRIORITY).addClassAndMethod(this).addCalledMethod(this);\n                MethodAnnotation preferred = new MethodAnnotation(ClassName.toDottedClassName(primitiveObjCtorSeen),\n                        \"toString\", \"(\"+ClassName.getPrimitiveType(primitiveObjCtorSeen)+\")Ljava/lang/String;\", true);\n                bug.addMethod(preferred).describe(MethodAnnotation.SHOULD_CALL);\n                accumulator.accumulateBug(\n                        bug, this);\n\n                primitiveObjCtorSeen = null;\n            } else {\n                primitiveObjCtorSeen = null;\n            }\n\n            if ((seen == INVOKESPECIAL) && \"<init>\".equals(getNameConstantOperand())) {\n                ctorSeen = true;\n            } else if (ctorSeen && (seen == INVOKEVIRTUAL) && \"java/lang/Object\".equals(getClassConstantOperand())\n                    && \"getClass\".equals(getNameConstantOperand()) && \"()Ljava/lang/Class;\".equals(getSigConstantOperand())) {\n                accumulator.accumulateBug(new BugInstance(this, \"DM_NEW_FOR_GETCLASS\", NORMAL_PRIORITY).addClassAndMethod(this),\n                        this);\n                ctorSeen = false;\n            } else {\n                ctorSeen = false;\n            }\n\n            if ((seen == INVOKEVIRTUAL) && isMonitorWait(getNameConstantOperand(), getSigConstantOperand())) {\n                checkMonitorWait();\n            }\n\n            if ((seen == INVOKESPECIAL) && \"<init>\".equals(getNameConstantOperand())\n                    && \"java/lang/Thread\".equals(getClassConstantOperand())) {\n                String sig = getSigConstantOperand();\n                if (\"()V\".equals(sig) || \"(Ljava/lang/String;)V\".equals(sig)\n                        || \"(Ljava/lang/ThreadGroup;Ljava/lang/String;)V\".equals(sig)) {\n                    OpcodeStack.Item invokedOn = stack.getItemMethodInvokedOn(this);\n                    if (!\"<init>\".equals(getMethodName()) || invokedOn.getRegisterNumber() != 0) {\n                        accumulator.accumulateBug(\n                                new BugInstance(this, \"DM_USELESS_THREAD\", LOW_PRIORITY).addClassAndMethod(this), this);\n\n                    }\n                }\n            }\n\n            if (seen == INVOKESPECIAL && \"java/math/BigDecimal\".equals(getClassConstantOperand())\n                    && \"<init>\".equals(getNameConstantOperand()) && \"(D)V\".equals(getSigConstantOperand())) {\n                OpcodeStack.Item top = stack.getStackItem(0);\n                Object value = top.getConstant();\n                if (value instanceof Double && !((Double)value).isInfinite() && !((Double)value).isNaN()) {\n                    double arg = ((Double) value).doubleValue();\n                    String dblString = Double.toString(arg);\n                    String bigDecimalString = new BigDecimal(arg).toString();\n                    boolean ok = dblString.equals(bigDecimalString) || dblString.equals(bigDecimalString + \".0\");\n\n                    if (!ok) {\n                        boolean scary = dblString.length() <= 8 && bigDecimalString.length() > 12\n                                && dblString.toUpperCase().indexOf('E') == -1;\n                        bugReporter.reportBug(new BugInstance(this, \"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE\",\n                                scary ? NORMAL_PRIORITY : LOW_PRIORITY).addClassAndMethod(this).addCalledMethod(this)\n                                .addMethod(\"java.math.BigDecimal\", \"valueOf\", \"(D)Ljava/math/BigDecimal;\", true)\n                                .describe(MethodAnnotation.METHOD_ALTERNATIVE_TARGET).addString(dblString)\n                                .addString(bigDecimalString).addSourceLine(this));\n                    }\n                }\n\n            }\n\n        } finally {\n            prevOpcode = seen;\n        }\n    }","commit_id":"e09d217768d636b1eddcb90ca2317d62eacf331d","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + ternaryConversionState);\n\t\tif (seen == IMUL) {\n\t\t\tif (imul_distance != 1) resetIMulCastLong();\n\t\t\timul_distance = 0;\n\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\t\t\t\timul_constant = adjustMultiplier(item0.getConstant(), imul_constant);\n\t\t\t\timul_constant = adjustMultiplier(item1.getConstant(), imul_constant);\n\n\t\t\t\tif (item0.isInitialParameter() || item1.isInitialParameter())\n\t\t\t\t\timul_operand_is_parameter = true;\n\t\t\t}} else {\n\t\t\t\timul_distance++;\n\t\t\t}\n\n\t\tif (prevOpCode == IMUL && seen == I2L) {\n\t\t\tint priority = adjustPriority(imul_constant, NORMAL_PRIORITY);\n\t\t\tif (priority >= LOW_PRIORITY && imul_operand_is_parameter) priority = NORMAL_PRIORITY;\n\t\t\tif (priority <= best_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG) {\n\t\t\t\tbest_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG = priority;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG\", \n\t\t\t\t\t\tpriority)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\t\tif (getMethodName().equals(\"<clinit>\") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {\n\t\t\tString clazz = getClassConstantOperand();\n\t\t\tif (!clazz.equals(getClassName())) {\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass targetClass = Repository.lookupClass(clazz);\n\t\t\t\t\tif (Repository.instanceOf(targetClass, getThisClass())) {\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (seen == GETSTATIC) priority--;\n\t\t\t\t\t\tif (!targetClass.isPublic()) priority++;\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\t\t\"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION\", \n\t\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(this).addClass(getDottedClassConstantOperand()),\n\t\t\t\t\t\tthis);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore it\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (false && (seen == INVOKEVIRTUAL)\n\t\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(\"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\n\t\tif (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n\t\t\tItem index  = stack.getStackItem(0);\n\t\t\tif (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION)\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\n\t\t}\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t\t&& getPrevOpcode(3) == IREM\n\t\t)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue && \n\t\t\t\t(!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t\t|| seen == I2B && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)) \n\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\t\tconstantArgumentToShift = false;\n\t\tshiftOfNonnegativeValue = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject rightHandSide\n\t\t\t\t= stack.getStackItem(0).getConstant();\n\n\t\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\t\tshiftOfNonnegativeValue = stack.getStackItem(1).isNonNegative();\n\t\t\t\tif (rightHandSide instanceof Integer) {\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", \n\t\t\t\t\t\t\t\tvalueOfConstantArgumentToShift < 0 ? LOW_PRIORITY : HIGH_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT), this);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Date\")\n\t\t\t\t&& getNameConstantOperand().equals(\"setMonth\")\n\t\t\t\t&& getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", HIGH_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Calendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"set\")\n\n\t\t\t\t||\n\t\t\t\tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"<init>\")\n\n\t\t) {\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tif (sig.startsWith(\"(III\")) {\n\t\t\t\tint pos = sig.length() - 5;\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(pos);\n\t\t\t\tObject o = item.getConstant();\n\t\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\t\tint v = (Integer) o;\n\t\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t\t|| seen == ISTORE_0\n\t\t\t\t|| seen == ISTORE_1\n\t\t\t\t|| seen == ISTORE_2\n\t\t\t\t|| seen == ISTORE_3)\n\t\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\n\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t// Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) {\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\tif (!item.isNonNegative() && item.getSpecialKind() != OpcodeStack.Item.MATH_ABS)\n\t\t\t\t\tbadlyComputingOddState++;\n\t\t\t\telse  badlyComputingOddState = 0;\n\t\t\t}\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE)  {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n\t\t\t\t&& (getNameConstantOperand().equals(\"toString\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n\t\t\t\t)\n\t\t) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tString signature = item.getSignature();\n\t\t\tif (signature != null && signature.startsWith(\"[\")) {\n\t\t\t\tString name = null;\n\t\t\t\tint reg = item.getRegisterNumber();\n\t\t\t\tCollection<BugAnnotation> as = new ArrayList<BugAnnotation>();\n\t\t\t\tif(reg != -1) {\n\t\t\t\t\tLocalVariableAnnotation lva =\n\t\t\t\t\t\tLocalVariableAnnotation.getLocalVariableAnnotation(\n\t\t\t\t\t\t\tgetMethod(), reg, getPC(), getPC()-1);\n\t\t\t\t\tname = \"array \" + lva.getName() + \"[]\";\n\t\t\t\t\tas.add(lva);\n\t\t\t\t}\n\t\t\t\tif(name != null) {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addAnnotations(as), this);\n\t\t\t\t} else {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isTigerOrHigher) {\n\t\t\tif (previousMethodInvocation != null && prevOpCode == INVOKESPECIAL && seen == INVOKEVIRTUAL) {\n\t\t\t\tString classNameForPreviousMethod = previousMethodInvocation.getClassName();\n\t\t\t\tString classNameForThisMethod = getClassConstantOperand();\n\t\t\t\tif (classNameForPreviousMethod.startsWith(\"java.lang.\") \n\t\t\t\t\t\t&& classNameForPreviousMethod.equals(classNameForThisMethod.replace('/','.'))\n\t\t\t\t\t\t&& getNameConstantOperand().endsWith(\"Value\")\n\t\t\t\t\t\t&& getSigConstantOperand().length() == 3) {\n\t\t\t\t\tif (getSigConstantOperand().charAt(2) == previousMethodInvocation.getSignature().charAt(1))\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\t} else ternaryConversionState = 0;\n\n\t\t\t} else if (seen == INVOKEVIRTUAL) {\n\t\t\t\tif (getClassConstantOperand().startsWith(\"java/lang\") && getNameConstantOperand().endsWith(\"Value\") && getSigConstantOperand().length() == 3)\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}else if (ternaryConversionState == 1) {\n\t\t\t\tif (I2L <= seen && seen <= I2S) \n\t\t\t\t\tternaryConversionState = 2;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}\n\t\t\telse if (ternaryConversionState == 2) {\n\t\t\t\tternaryConversionState = 0;\n\t\t\t\tif (seen == GOTO) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKESTATIC)\n\t\t\tif ((getNameConstantOperand().startsWith(\"assert\") || getNameConstantOperand().startsWith(\"fail\")) && getMethodName().equals(\"run\")\n\t\t\t\t\t&& implementsRunnable(getThisClass())) {\n\t\t\t\ttry {\n\t\t\t\t\t int size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\"java/lang/Throwable\", getPC());\n\t\t\t\t\tint size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\"java/lang/Error\", getPC());\n\t\t\t\t\tint size3 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\t\t\"java/lang/AssertionFailureError\", getPC());\n\t\t\t\t\tint size = Math.min(Math.min( size1, size2), size3);\n\t\t\t\t\t if (size == Integer.MAX_VALUE) {\n\t\t\t\t\tJavaClass targetClass = AnalysisContext.currentAnalysisContext().lookupClass(getClassConstantOperand().replace('/', '.'));\n\t\t\t\t\tif (targetClass.getSuperclassName().startsWith(\"junit\")) {\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\t }\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t}\n\n\t\t\t}\n\t\tif (seen == INVOKESPECIAL && getClassConstantOperand().startsWith(\"java/lang/\")  && getNameConstantOperand().equals(\"<init>\")\n\t\t\t\t&& getSigConstantOperand().length() == 4\n\t\t) \n\n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse if (seen == INVOKESTATIC && getClassConstantOperand().startsWith(\"java/lang/\")  \n\t\t\t\t&& getNameConstantOperand().equals(\"valueOf\")\n\t\t\t\t&& getSigConstantOperand().length() == 4) \n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse previousMethodInvocation = null;\n\t\tprevOpCode = seen;\n\n\t\t// Check for PrintStream.printf, PrintStream.format, String.format,\n\t\t// Formatter.format\n\n\t\tif(fsState == FS_STATE_NONE) {\n\t\t\tif(seen == LDC) {\n\t\t\t\tConstant c = getConstantRefOperand();\n\t\t\t\tif (c instanceof ConstantString) {\n\t\t\t\t\tfsFmtStr = getStringConstantOperand();\n\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Format str: \" + fsFmtStr);\n\t\t\t\t\t}\n\t\t\t\t\tfsState = FS_STATE_SAW_STR_LOAD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(fsState == FS_STATE_SAW_STR_LOAD) {\n\t\t\tif(seen == ICONST_0) {\n\t\t\t\tprevConst = 0; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_1) {\n\t\t\t\tprevConst = 1; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_2) {\n\t\t\t\tprevConst = 2; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_3) {\n\t\t\t\tprevConst = 3; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_4) {\n\t\t\t\tprevConst = 4; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_5) {\n\t\t\t\tprevConst = 5; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == BIPUSH) {\n\t\t\t\tprevConst = getIntConstant();\n\t\t\t\tfsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else {\n\t\t\t\tprevConst = -1;\n\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t}\n\t\t}\n\t\telse if(fsState == FS_STATE_SAW_CONST_PUSH) {\n\t\t\tif(seen == ANEWARRAY) {\n\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\tSystem.out.println(\"New array with const: \" + prevConst);\n\t\t\t\t}\n\t\t\t\tfsState = FS_STATE_SAW_NEWARRAY;\n\t\t\t\tfsAAStores = 0;\n\t\t\t} else {\n\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t}\n\t\t}\n\t\telse if(fsState == FS_STATE_SAW_NEWARRAY) {\n\t\t\tif(seen == AASTORE) {\n\t\t\t\tfsAAStores++;\n\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Saw an AASTORE; new count: \" + fsAAStores);\n\t\t\t\t}\n\t\t\t\tif(fsAAStores > prevConst) {\n\t\t\t\t\t// Stored too many array elements!\n\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Oops, \" + fsAAStores + \" is too many\");\n\t\t\t\t\t}\n\t\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(\n\t\t\t   fsAAStores == prevConst &&\n\t\t\t   (seen == INVOKESPECIAL ||\n\t\t\t\tseen == INVOKEVIRTUAL ||\n\t\t\t\tseen == INVOKESTATIC))\n\t\t\t{\n\t\t\t\tString cl = getClassConstantOperand();\n\t\t\t\tString nm = getNameConstantOperand();\n\t\t\t\tXMethod xm = XFactory.createReferencedXMethod(this);\n\t\t\t\tint flags = xm.getAccessFlags();\n\t\t\t\tif((flags & ACC_TRANSIENT) != 0) {\n\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Found VARARGS method: \" + cl + \".\" + nm);\n\t\t\t\t\t}\n\t\t\t\t\tif(\"java/util/Formatter\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/lang/String\".equals(cl)    && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"printf\".equals(nm))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Get the format string if possible\n\t\t\t\t\t\tint pcts = 0;\n\t\t\t\t\t\tfor(int i = 0; i < fsFmtStr.length(); i++) {\n\t\t\t\t\t\t\tif(fsFmtStr.charAt(i) == '%') {\n\t\t\t\t\t\t\t\tif(i < fsFmtStr.length()-1 &&\n\t\t\t\t\t\t\t\t   // If next char is '%', then it's just\n\t\t\t\t\t\t\t\t   // an escaped percent.  If next char is\n\t\t\t\t\t\t\t\t   // 'n', then it's just the platform-\n\t\t\t\t\t\t\t\t   // specific line separator.  In neither\n\t\t\t\t\t\t\t\t   // case is an argument consumed.\n\t\t\t\t\t\t\t\t   (fsFmtStr.charAt(i+1) == '%' ||\n\t\t\t\t\t                fsFmtStr.charAt(i+1) == 'n'))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ti++; continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpcts++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(pcts != prevConst) {\n\t\t\t\t\t\t\t// Bug!\n\t\t\t\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_ARG_MISMATCH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t\t.addString(fsFmtStr)\n\t\t\t\t\t\t\t\t.addInt(pcts)\n\t\t\t\t\t\t\t\t.addInt(prevConst)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\t\tSystem.out.println(\n\t\t\t\t\t\t\t\t\t\"WARNING: # percent signs (\" + pcts +\n\t\t\t\t\t\t\t\t\t\") doesn't match vararg array size: \" +\n\t\t\t\t\t\t\t\t\tprevConst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// OK\n\t\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"# percent signs (\" + pcts +\n\t\t\t\t\t\t\t\t\t\") matchs vararg array size: \" + prevConst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Not a VARARGS I'm familiar with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(\"java/util/Formatter\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/lang/String\".equals(cl)\t&& \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"printf\".equals(nm))\n\t\t\t\t\t{\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Oops: \" + cl + \".\" + nm + \" not a VARARGS\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t}\n\t\t}\n\t}","id":79628,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + ternaryConversionState);\n\t\tif (seen == IMUL) {\n\t\t\tif (imul_distance != 1) resetIMulCastLong();\n\t\t\timul_distance = 0;\n\t\t\tif (stack.getStackDepth() > 1) {\n\t\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\t\t\t\timul_constant = adjustMultiplier(item0.getConstant(), imul_constant);\n\t\t\t\timul_constant = adjustMultiplier(item1.getConstant(), imul_constant);\n\n\t\t\t\tif (item0.isInitialParameter() || item1.isInitialParameter())\n\t\t\t\t\timul_operand_is_parameter = true;\n\t\t\t}} else {\n\t\t\t\timul_distance++;\n\t\t\t}\n\n\t\tif (prevOpCode == IMUL && seen == I2L) {\n\t\t\tint priority = adjustPriority(imul_constant, NORMAL_PRIORITY);\n\t\t\tif (priority >= LOW_PRIORITY && imul_operand_is_parameter) priority = NORMAL_PRIORITY;\n\t\t\tif (priority <= best_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG) {\n\t\t\t\tbest_priority_for_ICAST_INTEGER_MULTIPLY_CAST_TO_LONG = priority;\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG\", \n\t\t\t\t\t\tpriority)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\t\tif (getMethodName().equals(\"<clinit>\") && (seen == PUTSTATIC || seen == GETSTATIC || seen == INVOKESTATIC)) {\n\t\t\tString clazz = getClassConstantOperand();\n\t\t\tif (!clazz.equals(getClassName())) {\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass targetClass = Repository.lookupClass(clazz);\n\t\t\t\t\tif (Repository.instanceOf(targetClass, getThisClass())) {\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\t\tif (seen == GETSTATIC) priority--;\n\t\t\t\t\t\tif (!targetClass.isPublic()) priority++;\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \n\t\t\t\t\t\t\t\t\"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION\", \n\t\t\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(this).addClass(getDottedClassConstantOperand()),\n\t\t\t\t\t\tthis);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\t// ignore it\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (false && (seen == INVOKEVIRTUAL)\n\t\t\t\t&&   getNameConstantOperand().equals(\"equals\")\n\t\t\t\t&&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(\"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t}\n\n\n\t\tif (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n\t\t\tItem index  = stack.getStackItem(0);\n\t\t\tif (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION)\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\n\t\t}\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t\t&& getPrevOpcode(3) == IREM\n\t\t)\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue && \n\t\t\t\t(!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t\t|| seen == I2B && getPrevOpcode(1) == IUSHR && !shiftOfNonnegativeValue\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)) \n\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", NORMAL_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\n\n\t\tconstantArgumentToShift = false;\n\t\tshiftOfNonnegativeValue = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject rightHandSide\n\t\t\t\t= stack.getStackItem(0).getConstant();\n\n\t\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\t\tshiftOfNonnegativeValue = stack.getStackItem(1).isNonNegative();\n\t\t\t\tif (rightHandSide instanceof Integer) {\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", \n\t\t\t\t\t\t\t\tvalueOfConstantArgumentToShift < 0 ? LOW_PRIORITY : HIGH_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift).describe(IntAnnotation.INT_SHIFT), this);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Date\")\n\t\t\t\t&& getNameConstantOperand().equals(\"setMonth\")\n\t\t\t\t&& getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", HIGH_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Calendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"set\")\n\n\t\t\t\t||\n\t\t\t\tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n\t\t\t\t&& getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n\t\t\t\t&& getNameConstantOperand().equals(\"<init>\")\n\n\t\t) {\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tif (sig.startsWith(\"(III\")) {\n\t\t\t\tint pos = sig.length() - 5;\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(pos);\n\t\t\t\tObject o = item.getConstant();\n\t\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\t\tint v = (Integer) o;\n\t\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v).describe(IntAnnotation.INT_VALUE)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t\t|| seen == ISTORE_0\n\t\t\t\t|| seen == ISTORE_1\n\t\t\t\t|| seen == ISTORE_2\n\t\t\t\t|| seen == ISTORE_3)\n\t\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n\t\t\t.addClassAndMethod(this), this);\n\t\t\t\n\n\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\n\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t// Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) {\n\t\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\t\tif (!item.isNonNegative() && item.getSpecialKind() != OpcodeStack.Item.MATH_ABS)\n\t\t\t\t\tbadlyComputingOddState++;\n\t\t\t\telse  badlyComputingOddState = 0;\n\t\t\t}\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE)  {\n\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t}\n\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\tif (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n\t\t\t\t&& (getNameConstantOperand().equals(\"toString\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n\t\t\t\t\t\t|| getNameConstantOperand().equals(\"append\")\n\t\t\t\t\t\t&& getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n\t\t\t\t)\n\t\t) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tString signature = item.getSignature();\n\t\t\tif (signature != null && signature.startsWith(\"[\")) {\n\t\t\t\tString name = null;\n\t\t\t\tint reg = item.getRegisterNumber();\n\t\t\t\tCollection<BugAnnotation> as = new ArrayList<BugAnnotation>();\n\t\t\t\tif(reg != -1) {\n\t\t\t\t\tLocalVariableAnnotation lva =\n\t\t\t\t\t\tLocalVariableAnnotation.getLocalVariableAnnotation(\n\t\t\t\t\t\t\tgetMethod(), reg, getPC(), getPC()-1);\n\t\t\t\t\tname = \"array \" + lva.getName() + \"[]\";\n\t\t\t\t\tas.add(lva);\n\t\t\t\t}\n\t\t\t\tif(name != null) {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addAnnotations(as), this);\n\t\t\t\t} else {\n\t\t\t\t\tbugAccumulator.accumulateBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isTigerOrHigher) {\n\t\t\tif (previousMethodInvocation != null && prevOpCode == INVOKESPECIAL && seen == INVOKEVIRTUAL) {\n\t\t\t\tString classNameForPreviousMethod = previousMethodInvocation.getClassName();\n\t\t\t\tString classNameForThisMethod = getClassConstantOperand();\n\t\t\t\tif (classNameForPreviousMethod.startsWith(\"java.lang.\") \n\t\t\t\t\t\t&& classNameForPreviousMethod.equals(classNameForThisMethod.replace('/','.'))\n\t\t\t\t\t\t&& getNameConstantOperand().endsWith(\"Value\")\n\t\t\t\t\t\t&& getSigConstantOperand().length() == 3) {\n\t\t\t\t\tif (getSigConstantOperand().charAt(2) == previousMethodInvocation.getSignature().charAt(1))\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\telse \n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\t} else ternaryConversionState = 0;\n\n\t\t\t} else if (seen == INVOKEVIRTUAL) {\n\t\t\t\tif (getClassConstantOperand().startsWith(\"java/lang\") && getNameConstantOperand().endsWith(\"Value\") && getSigConstantOperand().length() == 3)\n\t\t\t\t\tternaryConversionState = 1;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}else if (ternaryConversionState == 1) {\n\t\t\t\tif (I2L <= seen && seen <= I2S) \n\t\t\t\t\tternaryConversionState = 2;\n\t\t\t\telse ternaryConversionState = 0;\n\t\t\t}\n\t\t\telse if (ternaryConversionState == 2) {\n\t\t\t\tternaryConversionState = 0;\n\t\t\t\tif (seen == GOTO) \n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t\t}\n\t\t}\n\n\t\tif (seen == INVOKESTATIC)\n\t\t\tif ((getNameConstantOperand().startsWith(\"assert\") || getNameConstantOperand().startsWith(\"fail\")) && getMethodName().equals(\"run\")\n\t\t\t\t\t&& implementsRunnable(getThisClass())) {\n\t\t\t\ttry {\n\t\t\t\t\t int size1 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\"java/lang/Throwable\", getPC());\n\t\t\t\t\tint size2 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\"java/lang/Error\", getPC());\n\t\t\t\t\tint size3 = Util.getSizeOfSurroundingTryBlock(getConstantPool(), getMethod().getCode(),\n                    \t\t\t\t\t\t\t\t\t\t\t\t\"java/lang/AssertionFailureError\", getPC());\n\t\t\t\t\tint size = Math.min(Math.min( size1, size2), size3);\n\t\t\t\t\t if (size == Integer.MAX_VALUE) {\n\t\t\t\t\tJavaClass targetClass = AnalysisContext.currentAnalysisContext().lookupClass(getClassConstantOperand().replace('/', '.'));\n\t\t\t\t\tif (targetClass.getSuperclassName().startsWith(\"junit\")) {\n\t\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this, \"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this), this);\n\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\t }\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tAnalysisContext.reportMissingClass(e);\n\t\t\t\t}\n\n\t\t\t}\n\t\tif (seen == INVOKESPECIAL && getClassConstantOperand().startsWith(\"java/lang/\")  && getNameConstantOperand().equals(\"<init>\")\n\t\t\t\t&& getSigConstantOperand().length() == 4\n\t\t) \n\n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse if (seen == INVOKESTATIC && getClassConstantOperand().startsWith(\"java/lang/\")  \n\t\t\t\t&& getNameConstantOperand().equals(\"valueOf\")\n\t\t\t\t&& getSigConstantOperand().length() == 4) \n\t\t\tpreviousMethodInvocation = XFactory.createReferencedXMethod(this);\n\t\telse previousMethodInvocation = null;\n\t\tprevOpCode = seen;\n\n\t\t// Check for PrintStream.printf, PrintStream.format, String.format,\n\t\t// Formatter.format\n\n\t\tif(fsState == FS_STATE_NONE) {\n\t\t\tif(seen == LDC) {\n\t\t\t\tConstant c = getConstantRefOperand();\n\t\t\t\tif (c instanceof ConstantString) {\n\t\t\t\t\tfsFmtStr = getStringConstantOperand();\n\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Format str: \" + fsFmtStr);\n\t\t\t\t\t}\n\t\t\t\t\tfsState = FS_STATE_SAW_STR_LOAD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(fsState == FS_STATE_SAW_STR_LOAD) {\n\t\t\tif(seen == ICONST_0) {\n\t\t\t\tprevConst = 0; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_1) {\n\t\t\t\tprevConst = 1; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_2) {\n\t\t\t\tprevConst = 2; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_3) {\n\t\t\t\tprevConst = 3; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_4) {\n\t\t\t\tprevConst = 4; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == ICONST_5) {\n\t\t\t\tprevConst = 5; fsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else if(seen == BIPUSH) {\n\t\t\t\tprevConst = getIntConstant();\n\t\t\t\tfsState = FS_STATE_SAW_CONST_PUSH;\n\t\t\t} else {\n\t\t\t\tprevConst = -1;\n\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t}\n\t\t}\n\t\telse if(fsState == FS_STATE_SAW_CONST_PUSH) {\n\t\t\tif(seen == ANEWARRAY) {\n\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\tSystem.out.println(\"New array with const: \" + prevConst);\n\t\t\t\t}\n\t\t\t\tfsState = FS_STATE_SAW_NEWARRAY;\n\t\t\t\tfsAAStores = 0;\n\t\t\t} else {\n\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t}\n\t\t}\n\t\telse if(fsState == FS_STATE_SAW_NEWARRAY) {\n\t\t\tif(seen == AASTORE) {\n\t\t\t\tfsAAStores++;\n\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Saw an AASTORE; new count: \" + fsAAStores);\n\t\t\t\t}\n\t\t\t\tif(fsAAStores > prevConst) {\n\t\t\t\t\t// Stored too many array elements!\n\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Oops, \" + fsAAStores + \" is too many\");\n\t\t\t\t\t}\n\t\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(\n\t\t\t   fsAAStores == prevConst &&\n\t\t\t   (seen == INVOKESPECIAL ||\n\t\t\t\tseen == INVOKEVIRTUAL ||\n\t\t\t\tseen == INVOKESTATIC))\n\t\t\t{\n\t\t\t\tString cl = getClassConstantOperand();\n\t\t\t\tString nm = getNameConstantOperand();\n\t\t\t\tXMethod xm = XFactory.createReferencedXMethod(this);\n\t\t\t\tint flags = xm.getAccessFlags();\n\t\t\t\tif((flags & ACC_TRANSIENT) != 0) {\n\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"Found VARARGS method: \" + cl + \".\" + nm);\n\t\t\t\t\t}\n\t\t\t\t\tif(\"java/util/Formatter\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/lang/String\".equals(cl)    && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"printf\".equals(nm))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Get the format string if possible\n\t\t\t\t\t\tint pcts = 0;\n\t\t\t\t\t\tfor(int i = 0; i < fsFmtStr.length(); i++) {\n\t\t\t\t\t\t\tif(fsFmtStr.charAt(i) == '%') {\n\t\t\t\t\t\t\t\tif(i < fsFmtStr.length()-1 &&\n\t\t\t\t\t\t\t\t   // If next char is '%', then it's just\n\t\t\t\t\t\t\t\t   // an escaped percent.  If next char is\n\t\t\t\t\t\t\t\t   // 'n', then it's just the platform-\n\t\t\t\t\t\t\t\t   // specific line separator.  In neither\n\t\t\t\t\t\t\t\t   // case is an argument consumed.\n\t\t\t\t\t\t\t\t   (fsFmtStr.charAt(i+1) == '%' ||\n\t\t\t\t\t                fsFmtStr.charAt(i+1) == 'n'))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ti++; continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpcts++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(pcts != prevConst) {\n\t\t\t\t\t\t\t// Bug!\n\t\t\t\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_ARG_MISMATCH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t\t.addString(fsFmtStr)\n\t\t\t\t\t\t\t\t.addInt(pcts).describe(IntAnnotation.INT_EXPECTED_ARGUMENTS)\n\t\t\t\t\t\t\t\t.addInt(prevConst).describe(IntAnnotation.INT_ACTUAL_ARGUMENTS)\n\t\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\t\tSystem.out.println(\n\t\t\t\t\t\t\t\t\t\"WARNING: # percent signs (\" + pcts +\n\t\t\t\t\t\t\t\t\t\") doesn't match vararg array size: \" +\n\t\t\t\t\t\t\t\t\tprevConst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// OK\n\t\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"# percent signs (\" + pcts +\n\t\t\t\t\t\t\t\t\t\") matchs vararg array size: \" + prevConst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Not a VARARGS I'm familiar with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(\"java/util/Formatter\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/lang/String\".equals(cl)\t&& \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"format\".equals(nm) ||\n\t\t\t\t\t   \"java/io/PrintStream\".equals(cl) && \"printf\".equals(nm))\n\t\t\t\t\t{\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\tif(VAMISMATCH_DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Oops: \" + cl + \".\" + nm + \" not a VARARGS\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfsState = FS_STATE_NONE;\n\t\t\t}\n\t\t}\n\t}","commit_id":"90322ef7905bd1a6fdb65c688476a7f26a3846a5","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public TaskInputs dir(final Object dirPath) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskInputs.dir(Object)\", \"TaskInputs.includeDir(Object)\");\n        taskMutator.mutate(\"TaskInputs.dir(Object)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(resolver.resolveFilesAsTree(dirPath));\n            }\n        });\n        return this;\n    }","id":79629,"modified_method":"@Override\n    public TaskInputFilePropertySpec dir(final Object dirPath) {\n        return taskMutator.mutate(\"TaskInputs.dir(Object)\", new Callable<TaskInputFilePropertySpec>() {\n            @Override\n            public TaskInputFilePropertySpec call() {\n                return addSpec(resolver.resolveFilesAsTree(dirPath));\n            }\n        });\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskInputs files(final Object... paths) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskInputs.files(Object...)\", \"TaskInputs.includeFiles(Object...)\");\n        taskMutator.mutate(\"TaskInputs.files(Object...)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(paths);\n            }\n        });\n        return this;\n    }","id":79630,"modified_method":"@Override\n    public TaskInputFilePropertySpec files(final Object... paths) {\n        return taskMutator.mutate(\"TaskInputs.files(Object...)\", new Callable<TaskInputFilePropertySpec>() {\n            @Override\n            public TaskInputFilePropertySpec call() {\n                return addSpec(paths);\n            }\n        });\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskInputs sourceDir(final Object path) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskInputs.sourceDir(Object)\", \"TaskInputs.includeDir(Object)\");\n        taskMutator.mutate(\"TaskInputs.sourceDir(Object)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(resolver.resolveFilesAsTree(path), true);\n            }\n        });\n        return this;\n    }","id":79631,"modified_method":"@Override\n    public TaskInputs sourceDir(final Object path) {\n        DeprecationLogger.nagUserOfDiscontinuedMethod(\"TaskInputs.sourceDir(Object)\", \"Please use TaskInputs.dir(Object).skipWhenEmpty() instead.\");\n        taskMutator.mutate(\"TaskInputs.sourceDir(Object)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(resolver.resolveFilesAsTree(path), true);\n            }\n        });\n        return this;\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskInputs file(final Object path) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskInputs.file(Object)\", \"TaskInputs.includeFile(Object)\");\n        taskMutator.mutate(\"TaskInputs.file(Object)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(path);\n            }\n        });\n        return this;\n    }","id":79632,"modified_method":"@Override\n    public TaskInputFilePropertySpec file(final Object path) {\n        return taskMutator.mutate(\"TaskInputs.file(Object)\", new Callable<TaskInputFilePropertySpec>() {\n            @Override\n            public TaskInputFilePropertySpec call() {\n                return addSpec(path);\n            }\n        });\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskInputs source(final Object... paths) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskInputs.source(Object...)\", \"TaskInputs.includeFiles(Object...)\");\n        taskMutator.mutate(\"TaskInputs.source(Object...)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(paths, true);\n            }\n        });\n        return this;\n    }","id":79633,"modified_method":"@Override\n    public TaskInputs source(final Object... paths) {\n        DeprecationLogger.nagUserOfDiscontinuedMethod(\"TaskInputs.source(Object...)\", \"Please use TaskInputs.files(Object...).skipWhenEmpty() instead.\");\n        taskMutator.mutate(\"TaskInputs.source(Object...)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(paths, true);\n            }\n        });\n        return this;\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskInputs source(final Object path) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskInputs.source(Object)\", \"TaskInputs.includeFile(Object)\");\n        taskMutator.mutate(\"TaskInputs.source(Object)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(path, true);\n            }\n        });\n        return this;\n    }","id":79634,"modified_method":"@Override\n    public TaskInputs source(final Object path) {\n        DeprecationLogger.nagUserOfDiscontinuedMethod(\"TaskInputs.source(Object)\", \"Please use TaskInputs.file(Object).skipWhenEmpty() instead.\");\n        taskMutator.mutate(\"TaskInputs.source(Object)\", new Runnable() {\n            @Override\n            public void run() {\n                addSpec(path, true);\n            }\n        });\n        return this;\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskOutputs dir(final Object path) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskOutputs.dir(Object)\", \"TaskOutputs.includeDir(Object)\");\n        taskMutator.mutate(\"TaskOutputs.dir(Object)\", new Runnable() {\n            public void run() {\n                addSpec(path);\n            }\n        });\n        return this;\n    }","id":79635,"modified_method":"@Override\n    public TaskOutputFilePropertySpec dir(final Object path) {\n        return taskMutator.mutate(\"TaskOutputs.dir(Object)\", new Callable<TaskOutputFilePropertySpec>() {\n            @Override\n            public TaskOutputFilePropertySpec call() throws Exception {\n                return addSpec(path);\n            }\n        });\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskOutputs files(final Object... paths) {\n        DeprecationLogger.nagUserOfDiscontinuedMethod(\"TaskOutputs.files(Object...)\", \"Please use the TaskOutputs.includeFile(Object) or the TaskOutputs.includeDir(Object) method instead.\");\n        taskMutator.mutate(\"TaskOutputs.files(Object...)\", new Runnable() {\n            public void run() {\n                addSpec(paths);\n            }\n        });\n        return this;\n    }","id":79636,"modified_method":"@Override\n    public TaskOutputFilePropertySpec files(final Object... paths) {\n        DeprecationLogger.nagUserOfDiscontinuedMethod(\"TaskOutputs.files(Object...)\", \"Please use the TaskOutputs.file(Object) or the TaskOutputs.dir(Object) method instead.\");\n        return taskMutator.mutate(\"TaskOutputs.files(Object...)\", new Callable<TaskOutputFilePropertySpec>() {\n            @Override\n            public TaskOutputFilePropertySpec call() throws Exception {\n                return addSpec(paths);\n            }\n        });\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public TaskOutputs file(final Object path) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"TaskOutputs.file(Object)\", \"TaskOutputs.includeFile(Object)\");\n        taskMutator.mutate(\"TaskOutputs.file(Object)\", new Runnable() {\n            public void run() {\n                addSpec(path);\n            }\n        });\n        return this;\n    }","id":79637,"modified_method":"@Override\n    public TaskOutputFilePropertySpec file(final Object path) {\n        return taskMutator.mutate(\"TaskOutputs.file(Object)\", new Callable<TaskOutputFilePropertySpec>() {\n            @Override\n            public TaskOutputFilePropertySpec call() throws Exception {\n                return addSpec(path);\n            }\n        });\n    }","commit_id":"cc2cb11a63b3570c133e1fb37158c9eab3e43760","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n\t * Create a SimpleToadletServer, using the settings from the SubConfig (the fproxy.*\n\t * config).\n\t */\n\tpublic SimpleToadletServer(SubConfig fproxyConfig, Node node) throws IOException, InvalidConfigValueException {\n\t\t\n\t\tfproxyConfig.register(\"enabled\", true, 1, true, \"Enable fproxy?\", \"Whether to enable fproxy and related HTTP services\",\n\t\t\t\tnew FproxyEnabledCallback());\n\t\t\n\t\tboolean enabled = fproxyConfig.getBoolean(\"enabled\");\n\t\t\n\t\tfproxyConfig.register(\"port\", DEFAULT_FPROXY_PORT, 2, true, \"Fproxy port number\", \"Fproxy port number\",\n\t\t\t\tnew FproxyPortCallback());\n\t\tfproxyConfig.register(\"bindTo\", \"127.0.0.1\", 2, true, \"IP address to bind to\", \"IP address to bind to\",\n\t\t\t\tnew FproxyBindtoCallback());\n\t\tfproxyConfig.register(\"css\", \"clean\", 1, true, \"CSS Name\", \"Name of the CSS Fproxy should use\",\n\t\t\t\tnew FproxyCSSNameCallback());\n\n\t\tthis.bf = node.tempBucketFactory;\n\t\tport = fproxyConfig.getInt(\"port\");\n\t\tbindTo = fproxyConfig.getString(\"bindTo\");\n\t\tcssName = fproxyConfig.getString(\"css\");\n\t\tif(cssName.indexOf(':') != -1 || cssName.indexOf('/') != -1)\n\t\t\tthrow new InvalidConfigValueException(\"CSS name must not contain slashes or colons!\");\n\t\t\n\t\tthis.sock = new ServerSocket(port, 0, InetAddress.getByName(this.bindTo));\n\t\ttoadlets = new LinkedList();\n\t\t\n\t\tnode.setToadletContainer(this); // even if not enabled, because of config\n\t\t\n\t\tif(!enabled) {\n\t\t\tLogger.normal(node, \"Not starting Fproxy as it's disabled\");\n\t\t} else {\n\t\t\tmyThread = new Thread(this, \"SimpleToadletServer\");\n\t\t\tmyThread.setDaemon(true);\n\t\t\tmyThread.start();\n\t\t\tSystem.out.println(\"Starting fproxy on port \"+(port));\n\t\t\tLogger.normal(this, \"Starting fproxy on \"+bindTo+\":\"+port);\n\t\t}\n\t}","id":79638,"modified_method":"/**\n\t * Create a SimpleToadletServer, using the settings from the SubConfig (the fproxy.*\n\t * config).\n\t */\n\tpublic SimpleToadletServer(SubConfig fproxyConfig, Node node) throws IOException, InvalidConfigValueException {\n\t\t\n\t\tfproxyConfig.register(\"enabled\", true, 1, true, \"Enable fproxy?\", \"Whether to enable fproxy and related HTTP services\",\n\t\t\t\tnew FproxyEnabledCallback());\n\t\t\n\t\tboolean enabled = fproxyConfig.getBoolean(\"enabled\");\n\t\t\n\t\tfproxyConfig.register(\"port\", DEFAULT_FPROXY_PORT, 2, true, \"Fproxy port number\", \"Fproxy port number\",\n\t\t\t\tnew FproxyPortCallback());\n\t\tfproxyConfig.register(\"bindTo\", \"127.0.0.1\", 2, true, \"IP address to bind to\", \"IP address to bind to\",\n\t\t\t\tnew FproxyBindtoCallback());\n\t\tfproxyConfig.register(\"css\", \"clean\", 1, true, \"CSS Name\", \"Name of the CSS Fproxy should use\",\n\t\t\t\tnew FproxyCSSNameCallback());\n\n\t\tthis.bf = node.tempBucketFactory;\n\t\tport = fproxyConfig.getInt(\"port\");\n\t\tbindTo = fproxyConfig.getString(\"bindTo\");\n\t\tcssName = fproxyConfig.getString(\"css\");\n\t\tif(cssName.indexOf(':') != -1 || cssName.indexOf('/') != -1)\n\t\t\tthrow new InvalidConfigValueException(\"CSS name must not contain slashes or colons!\");\n\t\t\n\t\ttoadlets = new LinkedList();\n\t\tnode.setToadletContainer(this); // even if not enabled, because of config\n\t\t\n\t\tif(!enabled) {\n\t\t\tLogger.normal(node, \"Not starting Fproxy as it's disabled\");\n\t\t\tthis.sock = null;\n\t\t} else {\n\t\t\tthis.sock = new ServerSocket(port, 0, InetAddress.getByName(this.bindTo));\n\t\t\n\t\t\tmyThread = new Thread(this, \"SimpleToadletServer\");\n\t\t\tmyThread.setDaemon(true);\n\t\t\tmyThread.start();\n\t\t\tSystem.out.println(\"Starting fproxy on port \"+(port));\n\t\t\tLogger.normal(this, \"Starting fproxy on \"+bindTo+\":\"+port);\n\t\t}\n\t}","commit_id":"55aa5ad234e4345384041a4f8b026c665ad6d139","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Write the alerts as HTML to a StringBuffer\n\t */\n\tpublic void toHtml(StringBuffer buf) {\n\t\tUserAlert[] a = getAlerts();\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tUserAlert alert = a[i];\n\t\t\tsynchronized(alert) {\n\t\t\t\tif(!alert.isValid()) return;\n\t\t\t\t// FIXME should have separate CSS styles for each type of alert\n\t\t\t\tbuf.append(\"<p><b>\");\n\t\t\t\tshort level = a[i].getPriorityClass();\n\t\t\t\tif(level <= UserAlert.CRITICAL_ERROR)\n\t\t\t\t\tbuf.append(\"<font color=\\\"darkred\\\">\");\n\t\t\t\telse if(level <= UserAlert.ERROR)\n\t\t\t\t\tbuf.append(\"<font color=\\\"red\\\">\");\n\t\t\t\telse if(level <= UserAlert.WARNING)\n\t\t\t\t\tbuf.append(\"<font color=\\\"blue\\\">\");\n\t\t\t\telse if(level <= UserAlert.MINOR)\n\t\t\t\t\tbuf.append(\"<font color=\\\"green\\\">\");\n\t\t\t\tbuf.append(a[i].getTitle());\n\t\t\t\tif(level <= UserAlert.MINOR)\n\t\t\t\t\tbuf.append(\"<\/font>\");\n\t\t\t\tbuf.append(\"<\/b><br>\\n\");\n\t\t\t\tbuf.append(a[i].getText());\n\t\t\t\tbuf.append(\"<p>\\n\");\n\t\t\t}\n\t\t}\n\t}","id":79639,"modified_method":"/**\n\t * Write the alerts as HTML to a StringBuffer\n\t */\n\tpublic void toHtml(StringBuffer buf) {\n\t\tUserAlert[] a = getAlerts();\n\t\tfor(int i=0;i<a.length;i++) {\n\t\t\tUserAlert alert = a[i];\n\t\t\tsynchronized(alert) {\n\t\t\t\tif(!alert.isValid()) return;\n\t\t\t\tbuf.append(\"<p><b>\");\n\t\t\t\tshort level = a[i].getPriorityClass();\n\t\t\t\tif(level <= UserAlert.CRITICAL_ERROR)\n\t\t\t\t\tbuf.append(\"<span color=\\\"darkred\\\">\");\n\t\t\t\telse if(level <= UserAlert.ERROR)\n\t\t\t\t\tbuf.append(\"<span class=\\\"alert-error\\\">\");\n\t\t\t\telse if(level <= UserAlert.WARNING)\n\t\t\t\t\tbuf.append(\"<span class=\\\"alert-warning\\\">\");\n\t\t\t\telse if(level <= UserAlert.MINOR)\n\t\t\t\t\tbuf.append(\"<span class=\\\"alert-minor\\\">\");\n\t\t\t\tbuf.append(a[i].getTitle());\n\t\t\t\tif(level <= UserAlert.MINOR)\n\t\t\t\t\tbuf.append(\"<\/span>\");\n\t\t\t\tbuf.append(\"<\/b><br />\\n\");\n\t\t\t\tbuf.append(a[i].getText());\n\t\t\t\tbuf.append(\"<\/p>\\n\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"55aa5ad234e4345384041a4f8b026c665ad6d139","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tStringBuffer buf = new StringBuffer();\n\t\t\n\t\tHTTPRequest request = new HTTPRequest(uri);\n\t\tif (request.getParam(\"newbookmark\").length() > 0) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Add a Bookmark\");\n\t\t\t\n\t\t\tbuf.append(\"<form action=\\\".\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div>\\n\");\n\t\t\tbuf.append(\"Please confirm that you wish to add the key:<br />\\n\");\n\t\t\tbuf.append(\"<i>\"+request.getParam(\"newbookmark\")+\"<\/i><br />\");\n\t\t\tbuf.append(\"To your bookmarks, and enter the description that you would prefer:<br />\\n\");\n\t\t\tbuf.append(\"Description:\\n\");\n\t\t\tbuf.append(\"<input type=\\\"text\\\" name=\\\"name\\\" value=\\\"\"+HTMLEncoder.encode(request.getParam(\"desc\"))+\"\\\" style=\\\"width: 100%; \\\" />\\n\");\n\t\t\tbuf.append(\"<input type=\\\"hidden\\\" name=\\\"newbookmark\\\" value=\\\"\"+HTMLEncoder.encode(request.getParam(\"newbookmark\"))+\"\\\" />\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" value=\\\"Add Bookmark\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\t\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\treturn;\n\t\t} else if (request.isParameterSet(\"managebookmarks\")) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Bookmark Manager\");\n\t\t\t\n\t\t\t// existing bookmarks\n\t\t\tbuf.append(\"<form action=\\\".\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"<h2>My Bookmarks<\/h2>\\n\");\n\t\t\tEnumeration e = bookmarks.getBookmarks();\n\t\t\tif (!e.hasMoreElements()) {\n\t\t\t\tbuf.append(\"<i>You currently have no bookmarks defined<\/i>\");\n\t\t\t} else {\n\t\t\t\tbuf.append(\"<ul id=\\\"bookmarks\\\">\\n\");\n\t\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\t\n\t\t\t\t\tbuf.append(\"<li><a href=\\\"/\"+HTMLEncoder.encode(b.getKey())+\"\\\">\");\n\t\t\t\t\tbuf.append(HTMLEncoder.encode(b.getDesc()));\n\t\t\t\t\tbuf.append(\"<\/a>\\n\");\n\t\t\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"delete_\"+b.hashCode()+\"\\\" value=\\\"Delete\\\" style=\\\"float: right; \\\" />\\n\");\n\t\t\t\t\tbuf.append(\"<\/li>\\n\");\n\t\t\t\t}\n\t\t\t\tbuf.append(\"<\/ul>\\n\");\n\t\t\t}\n\t\t\tbuf.append(\"<input type=\\\"hidden\\\" name=\\\"managebookmarks\\\" value=\\\"yes\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\t\n\t\t\t// new bookmark\n\t\t\tbuf.append(\"<form action=\\\".\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"<h2>New Bookmark<\/h2>\\n\");\n\t\t\tbuf.append(\"Key: \\n\");\n\t\t\tbuf.append(\"<input type=\\\"text\\\" name=\\\"newbookmark\\\" style=\\\"width: 100%; \\\"/>\\n\");\n\t\t\tbuf.append(\"Description: \\n\");\n\t\t\tbuf.append(\"<input type=\\\"text\\\" name=\\\"name\\\" style=\\\"width: 100%; \\\"/>\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" value=\\\"Add Bookmark\\\"/>\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\t\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tctx.getPageMaker().makeHead(buf, \"Freenet FProxy Homepage\");\n\t\tif(node.isTestnetEnabled())\n\t\t\tbuf.append(\"<div style=\\\"color: red; font-size: 200%; \\\">WARNING: TESTNET MODE ENABLED<\/div>\");\n\n\t\t// Alerts\n\t\t\n\t\tnode.alerts.toHtml(buf);\n\t\t\n\t\t// Fetch-a-key box\n\t\tbuf.append(\"<br style=\\\"clear: all; \\\" />\\n\");\n\t\tbuf.append(\"<form action=\\\"/\\\" method=\\\"get\\\">\\n\");\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>Fetch a Key<\/h2>\\n\");\n\t\tbuf.append(\"Key: <input type=\\\"text\\\" size=\\\"80\\\" name=\\\"key\\\"/>\\n\");\n\t\tbuf.append(\"<input type=\\\"submit\\\" value=\\\"Fetch\\\" />\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\tbuf.append(\"<\/form>\\n\");\n\t\t\n\t\t// Bookmarks\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>My Bookmarks<\/h2>\");\n\t\t\n\t\tEnumeration e = bookmarks.getBookmarks();\n\t\tif (!e.hasMoreElements()) {\n\t\t\tbuf.append(\"<i>You currently have no bookmarks defined<\/i>\");\n\t\t} else {\n\t\t\tbuf.append(\"<ul id=\\\"bookmarks\\\">\\n\");\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\t\n\t\t\t\tbuf.append(\"<li><a href=\\\"/\"+HTMLEncoder.encode(b.getKey())+\"\\\">\");\n\t\t\t\tbuf.append(HTMLEncoder.encode(b.getDesc()));\n\t\t\t\tbuf.append(\"<\/a><\/li>\\n\");\n\t\t\t}\n\t\t\tbuf.append(\"<\/ul>\\n\");\n\t\t}\n\t\tbuf.append(\"<div id=\\\"bookmarkedit\\\">\\n\");\n\t\tbuf.append(\"<a href=\\\"?managebookmarks\\\" class=\\\"interfacelink\\\">Edit My Bookmarks<\/a>\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\t// Version info\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>Version<\/h2>\");\n\t\tbuf.append(\"Freenet version \"+Version.nodeVersion+\" build #\"+Version.buildNumber());\n\t\tif(Version.buildNumber() < Version.highestSeenBuild) {\n\t\t\tbuf.append(\"<br />\");\n\t\t\tbuf.append(\"<b>A newer version is available! (Build #\"+Version.highestSeenBuild+\")<\/b>\");\n\t\t}\n\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\t// Quit Form\n\t\tbuf.append(\"<form method=\\\"post\\\" action=\\\".\\\">\\n\");\n\t\tbuf.append(\"<div class=\\\"exit\\\">\\n\");\n\t\tbuf.append(\"<input type=\\\"hidden\\\" name=\\\"exit\\\" value=\\\"true\\\" /><input type=\\\"submit\\\" value=\\\"Shut down the node\\\" />\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\tbuf.append(\"<\/form>\\n\");\n\t\t\n\t\t// Activity\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>Current Activity<\/h2>\\n\");\n\t\tbuf.append(\"<ul id=\\\"activity\\\">\\n\"\n\t\t\t\t+ \"<li>Inserts: \"+this.node.getNumInserts()+\"<\/li>\\n\"\n\t\t\t\t+ \"<li>Requests: \"+this.node.getNumRequests()+\"<\/li>\\n\"\n\t\t\t\t+ \"<li>Transferring Requests: \"+this.node.getNumTransferringRequests()+\"<\/li>\\n\"\n\t\t\t\t+ \"<\/ul>\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t}","id":79640,"modified_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tStringBuffer buf = new StringBuffer();\n\t\t\n\t\tHTTPRequest request = new HTTPRequest(uri);\n\t\tif (request.getParam(\"newbookmark\").length() > 0) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Add a Bookmark\");\n\t\t\t\n\t\t\tbuf.append(\"<form action=\\\".\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div>\\n\");\n\t\t\tbuf.append(\"Please confirm that you wish to add the key:<br />\\n\");\n\t\t\tbuf.append(\"<i>\"+request.getParam(\"newbookmark\")+\"<\/i><br />\");\n\t\t\tbuf.append(\"To your bookmarks, and enter the description that you would prefer:<br />\\n\");\n\t\t\tbuf.append(\"Description:\\n\");\n\t\t\tbuf.append(\"<input type=\\\"text\\\" name=\\\"name\\\" value=\\\"\"+HTMLEncoder.encode(request.getParam(\"desc\"))+\"\\\" style=\\\"width: 100%; \\\" />\\n\");\n\t\t\tbuf.append(\"<input type=\\\"hidden\\\" name=\\\"key\\\" value=\\\"\"+HTMLEncoder.encode(request.getParam(\"newbookmark\"))+\"\\\" />\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"addbookmark\\\" value=\\\"Add Bookmark\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\t\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\treturn;\n\t\t} else if (request.isParameterSet(\"managebookmarks\")) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Bookmark Manager\");\n\t\t\t\n\t\t\t// existing bookmarks\n\t\t\tbuf.append(\"<form action=\\\".\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"<h2>My Bookmarks<\/h2>\\n\");\n\t\t\tEnumeration e = bookmarks.getBookmarks();\n\t\t\tif (!e.hasMoreElements()) {\n\t\t\t\tbuf.append(\"<i>You currently have no bookmarks defined<\/i>\");\n\t\t\t} else {\n\t\t\t\tbuf.append(\"<ul id=\\\"bookmarks\\\">\\n\");\n\t\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\t\n\t\t\t\t\tbuf.append(\"<li><a href=\\\"/\"+HTMLEncoder.encode(b.getKey())+\"\\\">\");\n\t\t\t\t\tbuf.append(HTMLEncoder.encode(b.getDesc()));\n\t\t\t\t\tbuf.append(\"<\/a>\\n\");\n\t\t\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"delete_\"+b.hashCode()+\"\\\" value=\\\"Delete\\\" style=\\\"float: right; \\\" />\\n\");\n\t\t\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"edit_\"+b.hashCode()+\"\\\" value=\\\"Edit\\\" style=\\\"float: right; \\\" />\\n\");\n\t\t\t\t\tbuf.append(\"<\/li>\\n\");\n\t\t\t\t}\n\t\t\t\tbuf.append(\"<\/ul>\\n\");\n\t\t\t}\n\t\t\tbuf.append(\"<input type=\\\"hidden\\\" name=\\\"managebookmarks\\\" value=\\\"yes\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\t\n\t\t\t// new bookmark\n\t\t\tthis.makeBookmarkEditForm(buf, MODE_ADD, null, \"\", \"\", null);\n\t\t\t\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tctx.getPageMaker().makeHead(buf, \"Freenet FProxy Homepage\");\n\t\tif(node.isTestnetEnabled())\n\t\t\tbuf.append(\"<div style=\\\"color: red; font-size: 200%; \\\">WARNING: TESTNET MODE ENABLED<\/div>\");\n\n\t\t// Alerts\n\t\t\n\t\tnode.alerts.toHtml(buf);\n\t\t\n\t\t// Fetch-a-key box\n\t\tbuf.append(\"<br style=\\\"clear: all; \\\" />\\n\");\n\t\tbuf.append(\"<form action=\\\"/\\\" method=\\\"get\\\">\\n\");\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>Fetch a Key<\/h2>\\n\");\n\t\tbuf.append(\"Key: <input type=\\\"text\\\" size=\\\"80\\\" name=\\\"key\\\"/>\\n\");\n\t\tbuf.append(\"<input type=\\\"submit\\\" value=\\\"Fetch\\\" />\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\tbuf.append(\"<\/form>\\n\");\n\t\t\n\t\t// Bookmarks\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>My Bookmarks<\/h2>\");\n\t\t\n\t\tEnumeration e = bookmarks.getBookmarks();\n\t\tif (!e.hasMoreElements()) {\n\t\t\tbuf.append(\"<i>You currently have no bookmarks defined<\/i>\");\n\t\t} else {\n\t\t\tbuf.append(\"<ul id=\\\"bookmarks\\\">\\n\");\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\t\n\t\t\t\tbuf.append(\"<li><a href=\\\"/\"+HTMLEncoder.encode(b.getKey())+\"\\\">\");\n\t\t\t\tbuf.append(HTMLEncoder.encode(b.getDesc()));\n\t\t\t\tbuf.append(\"<\/a><\/li>\\n\");\n\t\t\t}\n\t\t\tbuf.append(\"<\/ul>\\n\");\n\t\t}\n\t\tbuf.append(\"<div id=\\\"bookmarkedit\\\">\\n\");\n\t\tbuf.append(\"<a href=\\\"?managebookmarks\\\" class=\\\"interfacelink\\\">Edit My Bookmarks<\/a>\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\t// Version info\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>Version<\/h2>\");\n\t\tbuf.append(\"Freenet version \"+Version.nodeVersion+\" build #\"+Version.buildNumber());\n\t\tif(Version.buildNumber() < Version.highestSeenBuild) {\n\t\t\tbuf.append(\"<br />\");\n\t\t\tbuf.append(\"<b>A newer version is available! (Build #\"+Version.highestSeenBuild+\")<\/b>\");\n\t\t}\n\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\t// Quit Form\n\t\tbuf.append(\"<form method=\\\"post\\\" action=\\\".\\\">\\n\");\n\t\tbuf.append(\"<div class=\\\"exit\\\">\\n\");\n\t\tbuf.append(\"<input type=\\\"hidden\\\" name=\\\"exit\\\" value=\\\"true\\\" /><input type=\\\"submit\\\" value=\\\"Shut down the node\\\" />\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\tbuf.append(\"<\/form>\\n\");\n\t\t\n\t\t// Activity\n\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\tbuf.append(\"<h2>Current Activity<\/h2>\\n\");\n\t\tbuf.append(\"<ul id=\\\"activity\\\">\\n\"\n\t\t\t\t+ \"<li>Inserts: \"+this.node.getNumInserts()+\"<\/li>\\n\"\n\t\t\t\t+ \"<li>Requests: \"+this.node.getNumRequests()+\"<\/li>\\n\"\n\t\t\t\t+ \"<li>Transferring Requests: \"+this.node.getNumTransferringRequests()+\"<\/li>\\n\"\n\t\t\t\t+ \"<\/ul>\\n\");\n\t\tbuf.append(\"<\/div>\\n\");\n\t\t\n\t\tctx.getPageMaker().makeTail(buf);\n\t\t\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t}","commit_id":"55aa5ad234e4345384041a4f8b026c665ad6d139","url":"https://github.com/freenet/fred"},{"original_method":"public void handlePost(URI uri, Bucket data, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\t\n\t\tif(data.size() > 1024*1024) {\n\t\t\tthis.writeReply(ctx, 400, \"text/plain\", \"Too big\", \"Too much data, config servlet limited to 1MB\");\n\t\t\treturn;\n\t\t}\n\t\tbyte[] d = BucketTools.toByteArray(data);\n\t\tString s = new String(d, \"us-ascii\");\n\t\tHTTPRequest request;\n\t\ttry {\n\t\t\trequest = new HTTPRequest(\"/\", s);\n\t\t} catch (URISyntaxException e) {\n\t\t\tLogger.error(this, \"Impossible: \"+e, e);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tStringBuffer buf = new StringBuffer();\n\t\t\n\t\tif (request.getParam(\"shutdownconfirm\").length() > 0) {\n\t\t\t// false for no navigation bars, because that would be very silly\n\t\t\tctx.getPageMaker().makeHead(buf, \"Node Shut down\", false);\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"The Freenet node has been successfully shut down\\n\");\n\t\t\tbuf.append(\"<br />\\n\");\n\t\t\tbuf.append(\"Thank you for using Freenet\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\t\t\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\tthis.node.exit();\n\t\t} else if (request.getParam(\"exit\").equalsIgnoreCase(\"true\")) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Node Shutdown\");\n\t\t\tbuf.append(\"<form action=\\\"/\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"Are you sure you wish to shut down your Freenet node?<br />\\n\");\n\t\t\tbuf.append(\"<div class=\\\"cancel\\\">\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"cancel\\\" value=\\\"Cancel\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<div class=\\\"confirm\\\">\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"shutdownconfirm\\\" value=\\\"Shut Down\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<br style=\\\"clear: all;\\\">\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t} else if (request.getParam(\"newbookmark\").length() > 0) {\n\t\t\ttry {\n\t\t\t\tbookmarks.addBookmark(new Bookmark(request.getParam(\"newbookmark\"), request.getParam(\"name\")));\n\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\tthis.sendErrorPage(ctx, 200, \"Invalid freenet key\", \"Could not add the given item as a bookmark since it was not possible to interpret it as a freenet key. Please <a href=\\\"/\\\">Try Again<\/a>\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (request.isParameterSet(\"managebookmarks\")) {\n\t\t\tEnumeration e = bookmarks.getBookmarks();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\n\t\t\t\tif (request.isParameterSet(\"delete_\"+b.hashCode())) {\n\t\t\t\t\tbookmarks.removeBookmark(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t}\n\t\t} else {\n\t\t\tthis.handleGet(uri, ctx);\n\t\t}\n\t}","id":79641,"modified_method":"public void handlePost(URI uri, Bucket data, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\t\n\t\tif(data.size() > 1024*1024) {\n\t\t\tthis.writeReply(ctx, 400, \"text/plain\", \"Too big\", \"Data exceeds 1MB limit\");\n\t\t\treturn;\n\t\t}\n\t\tbyte[] d = BucketTools.toByteArray(data);\n\t\tString s = new String(d, \"us-ascii\");\n\t\tHTTPRequest request;\n\t\ttry {\n\t\t\trequest = new HTTPRequest(\"/\", s);\n\t\t} catch (URISyntaxException e) {\n\t\t\tLogger.error(this, \"Impossible: \"+e, e);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tStringBuffer buf = new StringBuffer();\n\t\t\n\t\tif (request.getParam(\"shutdownconfirm\").length() > 0) {\n\t\t\t// false for no navigation bars, because that would be very silly\n\t\t\tctx.getPageMaker().makeHead(buf, \"Node Shut down\", false);\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"The Freenet node has been successfully shut down\\n\");\n\t\t\tbuf.append(\"<br />\\n\");\n\t\t\tbuf.append(\"Thank you for using Freenet\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\t\t\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t\tthis.node.exit();\n\t\t} else if (request.getParam(\"exit\").equalsIgnoreCase(\"true\")) {\n\t\t\tctx.getPageMaker().makeHead(buf, \"Node Shutdown\");\n\t\t\tbuf.append(\"<form action=\\\"/\\\" method=\\\"post\\\">\\n\");\n\t\t\tbuf.append(\"<div class=\\\"infobox\\\">\\n\");\n\t\t\tbuf.append(\"Are you sure you wish to shut down your Freenet node?<br />\\n\");\n\t\t\tbuf.append(\"<div class=\\\"cancel\\\">\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"cancel\\\" value=\\\"Cancel\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<div class=\\\"confirm\\\">\\n\");\n\t\t\tbuf.append(\"<input type=\\\"submit\\\" name=\\\"shutdownconfirm\\\" value=\\\"Shut Down\\\" />\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<br style=\\\"clear: all;\\\">\\n\");\n\t\t\tbuf.append(\"<\/div>\\n\");\n\t\t\tbuf.append(\"<\/form>\\n\");\n\t\t\tctx.getPageMaker().makeTail(buf);\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", buf.toString());\n\t\t} else if (request.isParameterSet(\"addbookmark\")) {\n\t\t\ttry {\n\t\t\t\tbookmarks.addBookmark(new Bookmark(request.getParam(\"key\"), request.getParam(\"name\")));\n\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\tthis.sendBookmarkEditPage(ctx, MODE_ADD, null, request.getParam(\"key\"), request.getParam(\"name\"), \"Given key does not appear to be a valid Freenet key.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t}\n\t\t} else if (request.isParameterSet(\"managebookmarks\")) {\n\t\t\tEnumeration e = bookmarks.getBookmarks();\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tBookmark b = (Bookmark)e.nextElement();\n\t\t\t\n\t\t\t\tif (request.isParameterSet(\"delete_\"+b.hashCode())) {\n\t\t\t\t\tbookmarks.removeBookmark(b);\n\t\t\t\t} else if (request.isParameterSet(\"edit_\"+b.hashCode())) {\n\t\t\t\t\tthis.sendBookmarkEditPage(ctx, b);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (request.isParameterSet(\"update_\"+b.hashCode())) {\n\t\t\t\t\t// removing it and adding means that any USK subscriptions are updated properly\n\t\t\t\t\ttry {\n\t\t\t\t\t\tBookmark newbkmk = new Bookmark(request.getParam(\"key\"), request.getParam(\"name\"));\n\t\t\t\t\t\tbookmarks.removeBookmark(b);\n\t\t\t\t\t\tbookmarks.addBookmark(newbkmk);\n\t\t\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\t\t\tthis.sendBookmarkEditPage(ctx, MODE_EDIT, b, request.getParam(\"key\"), request.getParam(\"name\"), \"Given key does not appear to be a valid freenet key.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.handleGet(new URI(\"/welcome/?managebookmarks\"), ctx);\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\t\n\t\t\t}\n\t\t} else {\n\t\t\tthis.handleGet(uri, ctx);\n\t\t}\n\t}","commit_id":"55aa5ad234e4345384041a4f8b026c665ad6d139","url":"https://github.com/freenet/fred"},{"original_method":"public void handleMethodGET(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tboolean needsGeneration = true;\n\t\t// If the browser has requested this image, then it will send this header\n\t\tif (ctx.getHeaders().containsKey(\"if-modified-since\")) {\n\t\t\ttry {\n\t\t\t\t// If the received date is equal to the last modification of this class, then it doesn't need regeneration\n\t\t\t\tif (ToadletContextImpl.parseHTTPDate(ctx.getHeaders().get(\"if-modified-since\")).compareTo(LAST_MODIFIED) == 0) {\n\t\t\t\t\t// So we just send the NOT_MODIFIED response, and skip the generation\n\t\t\t\t\tctx.sendReplyHeaders(304, \"Not Modified\", null, \"image/png\", 0, LAST_MODIFIED);\n\t\t\t\t\tneedsGeneration = false;\n\t\t\t\t}\n\t\t\t} catch (ParseException pe) {\n\t\t\t\t// If something goes wrong, we regenerate\n\t\t\t}\n\t\t}\n\t\tif (needsGeneration) {\n\t\t\t// The text that will be drawn\n\t\t\tString text = req.getParam(\"text\");\n\t\t\t// If width or height is specified, we use it, if not, then we use the default\n\t\t\tint requiredWidth = req.getParam(\"width\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"width\")) : DEFAULT_WIDTH;\n\t\t\tint requiredHeight = req.getParam(\"height\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"height\")) : DEFAULT_HEIGHT;\n\t\t\t// This is the image we are making\n\t\t\tBufferedImage buffer = new BufferedImage(requiredWidth, requiredHeight, BufferedImage.TYPE_INT_RGB);\n\t\t\tGraphics2D g2 = buffer.createGraphics();\n\t\t\tg2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\t\t\tFontRenderContext fc = g2.getFontRenderContext();\n\t\t\t// We then specify the maximum font size that fits in the image\n\t\t\t// For this, we start at 1, and increase it, until it overflows. This-1 will be the font size\n\t\t\tfloat size = 1;\n\t\t\tg2.setFont(g2.getFont().deriveFont(size));\n\t\t\tint width = 0;\n\t\t\tint height = 0;\n\t\t\twhile (width < requiredWidth && height < requiredHeight) {\n\t\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\n\t\t\t\t// calculate the size of the text\n\t\t\t\twidth = (int) bounds.getWidth();\n\t\t\t\theight = (int) bounds.getHeight();\n\t\t\t\tg2.setFont(g2.getFont().deriveFont(++size));\n\t\t\t}\n\t\t\tg2.setFont(g2.getFont().deriveFont(size - 1));\n\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\t\t\t// actually do the drawing\n\t\t\tg2.setColor(new Color(0, 0, 0));\n\t\t\tg2.fillRect(0, 0, width, height);\n\t\t\tg2.setColor(new Color(255, 255, 255));\n\t\t\t// We position it to the center. Note that this is not the upper left corner\n\t\t\tg2.drawString(text, (int) (requiredWidth / 2 - bounds.getWidth() / 2), (int) (requiredHeight / 2 + bounds.getHeight() / 4));\n\n\t\t\t// Write the data, and send the modification data to let the client cache it\n\t\t\tBucket data = ctx.getBucketFactory().makeBucket(-1);\n\t\t\tImageIO.write(buffer, \"png\", data.getOutputStream());\n\t\t\tMultiValueTable<String, String> headers=new MultiValueTable<String, String>();\n\t\t\tctx.sendReplyHeaders(200, \"OK\", headers, \"image/png\", data.size(), LAST_MODIFIED);\n\t\t\tctx.writeData(data);\n\t\t}\n\t}","id":79642,"modified_method":"public void handleMethodGET(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tboolean needsGeneration = true;\n\t\t// If the browser has requested this image, then it will send this header\n\t\tif (ctx.getHeaders().containsKey(\"if-modified-since\")) {\n\t\t\ttry {\n\t\t\t\t// If the received date is equal to the last modification of this class, then it doesn't need regeneration\n\t\t\t\tif (ToadletContextImpl.parseHTTPDate(ctx.getHeaders().get(\"if-modified-since\")).compareTo(LAST_MODIFIED) == 0) {\n\t\t\t\t\t// So we just send the NOT_MODIFIED response, and skip the generation\n\t\t\t\t\tctx.sendReplyHeaders(304, \"Not Modified\", null, \"image/png\", 0, LAST_MODIFIED);\n\t\t\t\t\tneedsGeneration = false;\n\t\t\t\t}\n\t\t\t} catch (ParseException pe) {\n\t\t\t\t// If something goes wrong, we regenerate\n\t\t\t}\n\t\t}\n\t\tif (needsGeneration) {\n\t\t\t// The text that will be drawn\n\t\t\tString text = req.getParam(\"text\");\n\t\t\t// If width or height is specified, we use it, if not, then we use the default\n\t\t\tint requiredWidth = req.getParam(\"width\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"width\").endsWith(\"px\")?req.getParam(\"width\").substring(0, req.getParam(\"width\").length()-2):req.getParam(\"width\")) : DEFAULT_WIDTH;\n\t\t\tint requiredHeight = req.getParam(\"height\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"height\").endsWith(\"px\")?req.getParam(\"height\").substring(0, req.getParam(\"height\").length()-2):req.getParam(\"height\")) : DEFAULT_HEIGHT;\n\t\t\t// This is the image we are making\n\t\t\tBufferedImage buffer = new BufferedImage(requiredWidth, requiredHeight, BufferedImage.TYPE_INT_RGB);\n\t\t\tGraphics2D g2 = buffer.createGraphics();\n\t\t\tg2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\t\t\tFontRenderContext fc = g2.getFontRenderContext();\n\t\t\t// We then specify the maximum font size that fits in the image\n\t\t\t// For this, we start at 1, and increase it, until it overflows. This-1 will be the font size\n\t\t\tfloat size = 1;\n\t\t\tg2.setFont(g2.getFont().deriveFont(size));\n\t\t\tint width = 0;\n\t\t\tint height = 0;\n\t\t\twhile (width < requiredWidth && height < requiredHeight) {\n\t\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\n\t\t\t\t// calculate the size of the text\n\t\t\t\twidth = (int) bounds.getWidth();\n\t\t\t\theight = (int) bounds.getHeight();\n\t\t\t\tg2.setFont(g2.getFont().deriveFont(++size));\n\t\t\t}\n\t\t\tg2.setFont(g2.getFont().deriveFont(size - 1));\n\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\t\t\t// actually do the drawing\n\t\t\tg2.setColor(new Color(0, 0, 0));\n\t\t\tg2.fillRect(0, 0, width, height);\n\t\t\tg2.setColor(new Color(255, 255, 255));\n\t\t\t// We position it to the center. Note that this is not the upper left corner\n\t\t\tg2.drawString(text, (int) (requiredWidth / 2 - bounds.getWidth() / 2), (int) (requiredHeight / 2 + bounds.getHeight() / 4));\n\n\t\t\t// Write the data, and send the modification data to let the client cache it\n\t\t\tBucket data = ctx.getBucketFactory().makeBucket(-1);\n\t\t\tImageIO.write(buffer, \"png\", data.getOutputStream());\n\t\t\tMultiValueTable<String, String> headers=new MultiValueTable<String, String>();\n\t\t\tctx.sendReplyHeaders(200, \"OK\", headers, \"image/png\", data.size(), LAST_MODIFIED);\n\t\t\tctx.writeData(data);\n\t\t}\n\t}","commit_id":"cb414b6331f0296280344c57b81ed8700b9aeb88","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    protected void completeInterval() {\n        this.uniqueSessionIds.clear();\n    }","id":79643,"modified_method":"@Override\n    protected void completeInterval() {\n        this.uniqueStrings = null;\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"void countSession(String eventSessionId) {\n        checkState();\n        \n        if (this.uniqueSessionIds.add(eventSessionId)) {\n            this.concurrentUsers++;\n        }\n    }","id":79644,"modified_method":"void countSession(String eventSessionId) {\n        checkState();\n        \n        if (this.uniqueStrings == null) {\n            this.uniqueStrings = new UniqueStrings();\n        }\n        \n        if (this.uniqueStrings.add(eventSessionId)) {\n            this.concurrentUsers++;\n        }\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected boolean isComplete() {\n        return this.concurrentUsers > 0 && this.uniqueSessionIds.isEmpty();\n    }","id":79645,"modified_method":"@Override\n    protected boolean isComplete() {\n        return this.concurrentUsers > 0 && this.uniqueStrings == null;\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void addFetches(Root<ConcurrentUserAggregationImpl> root) {\n        root.fetch(ConcurrentUserAggregationImpl_.uniqueSessionIds, JoinType.LEFT);        \n    }","id":79646,"modified_method":"@Override\n    protected void addFetches(Root<ConcurrentUserAggregationImpl> root) {\n        root.fetch(ConcurrentUserAggregationImpl_.uniqueStrings, JoinType.LEFT);        \n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void addUnclosedPredicate(CriteriaBuilder cb, Root<ConcurrentUserAggregationImpl> root,\n            List<Predicate> keyPredicates) {\n        keyPredicates.add(cb.notEqual(cb.size(root.get(ConcurrentUserAggregationImpl_.uniqueSessionIds)), 0));\n    }","id":79647,"modified_method":"@Override\n    protected void addUnclosedPredicate(CriteriaBuilder cb, Root<ConcurrentUserAggregationImpl> root,\n            List<Predicate> keyPredicates) {\n        keyPredicates.add(cb.isNotNull(root.get(ConcurrentUserAggregationImpl_.uniqueStrings)));\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void addFetches(Root<LoginAggregationImpl> root) {\n        root.fetch(LoginAggregationImpl_.uniqueUserNames, JoinType.LEFT);\n    }","id":79648,"modified_method":"@Override\n    protected void addFetches(Root<LoginAggregationImpl> root) {\n        root.fetch(LoginAggregationImpl_.uniqueStrings, JoinType.LEFT);\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void addUnclosedPredicate(CriteriaBuilder cb, Root<LoginAggregationImpl> root,\n            List<Predicate> keyPredicates) {\n        keyPredicates.add(cb.notEqual(cb.size(root.get(LoginAggregationImpl_.uniqueUserNames)), 0));\n    }","id":79649,"modified_method":"@Override\n    protected void addUnclosedPredicate(CriteriaBuilder cb, Root<LoginAggregationImpl> root,\n            List<Predicate> keyPredicates) {\n        keyPredicates.add(cb.isNotNull(root.get(LoginAggregationImpl_.uniqueStrings)));\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"void countUser(String userName) {\n        checkState();\n        \n        if (this.uniqueUserNames.add(userName)) {\n            this.uniqueLoginCount++;\n        }\n        this.loginCount++;\n    }","id":79650,"modified_method":"void countUser(String userName) {\n        checkState();\n        \n        if (this.uniqueStrings == null) {\n            this.uniqueStrings = new UniqueStrings();\n        }\n        \n        if (this.uniqueStrings.add(userName)) {\n            this.uniqueLoginCount++;\n        }\n        this.loginCount++;\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected boolean isComplete() {\n        return this.loginCount > 0 && this.uniqueUserNames.isEmpty();\n    }","id":79651,"modified_method":"@Override\n    protected boolean isComplete() {\n        return this.loginCount > 0 && this.uniqueStrings == null;\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void completeInterval() {\n        this.uniqueUserNames.clear();\n    }","id":79652,"modified_method":"@Override\n    protected void completeInterval() {\n        this.uniqueStrings = null;\n    }","commit_id":"d57884f7e7135d872489665f1d532197e2d90c60","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setValue(String value) {\n            this.value = value;\n        }","id":79653,"modified_method":"public void setValue(String value) {\n            this.v = value;\n        }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n        public String toString() {\n            return \"JsonWrapper [type=\" + type + \", value=\" + value + \"]\";\n        }","id":79654,"modified_method":"@Override\n        public String toString() {\n            return \"JsonWrapper [type=\" + t + \", value=\" + v + \"]\";\n        }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"public Class<?> getType() {\n            return type;\n        }","id":79655,"modified_method":"public Class<?> getType() {\n            return t;\n        }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"public String getValue() {\n            return value;\n        }","id":79656,"modified_method":"public String getValue() {\n            return v;\n        }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"public JsonWrapper(Class<?> type, String value) {\n            this.type = type;\n            this.value = value;\n        }","id":79657,"modified_method":"public JsonWrapper(Class<?> type, String value) {\n            this.t = type;\n            this.v = value;\n        }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setType(Class<?> type) {\n            this.type = type;\n        }","id":79658,"modified_method":"public void setType(Class<?> type) {\n            this.t = type;\n        }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void addFetches(Root<TabRenderAggregationImpl> root) {\n        root.fetch(TabRenderAggregationImpl_.renderTimes, JoinType.LEFT);\n    }","id":79659,"modified_method":"@Override\n    protected void addFetches(Root<TabRenderAggregationImpl> root) {\n        root.fetch(TabRenderAggregationImpl_.statisticalSummary, JoinType.LEFT);\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void addUnclosedPredicate(CriteriaBuilder cb, Root<TabRenderAggregationImpl> root,\n            List<Predicate> keyPredicates) {\n        keyPredicates.add(cb.notEqual(cb.size(root.get(TabRenderAggregationImpl_.renderTimes)), 0));\n    }","id":79660,"modified_method":"@Override\n    protected void addUnclosedPredicate(CriteriaBuilder cb, Root<TabRenderAggregationImpl> root,\n            List<Predicate> keyPredicates) {\n        keyPredicates.add(cb.isNotNull(root.get(TabRenderAggregationImpl_.statisticalSummary)));\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"TabRenderAggregationImpl(TimeDimension timeDimension, DateDimension dateDimension, \n            AggregationInterval interval, AggregatedGroupMapping aggregatedGroup, String tabName) {\n        super(timeDimension, dateDimension, interval, aggregatedGroup);\n\n        Validate.notNull(dateDimension);\n        \n        this.id = -1;\n        this.tabName = tabName;\n    }","id":79661,"modified_method":"TabRenderAggregationImpl(TimeDimension timeDimension, DateDimension dateDimension, \n            AggregationInterval interval, AggregatedGroupMapping aggregatedGroup, String tabName) {\n        super(timeDimension, dateDimension, interval, aggregatedGroup);\n\n        Validate.notNull(tabName);\n        \n        this.id = -1;\n        this.tabName = tabName;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = super.hashCode();\n        long temp;\n        temp = Double.doubleToLongBits(geometricMean);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(max);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(mean);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(min);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(ninetiethPercentile);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + renderCount;\n        temp = Double.doubleToLongBits(standardDeviation);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + ((tabName == null) ? 0 : tabName.hashCode());\n        return result;\n    }","id":79662,"modified_method":"@Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = super.hashCode();\n        long temp;\n        temp = Double.doubleToLongBits(geometricMean);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + ((tabName == null) ? 0 : tabName.hashCode());\n        return result;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected boolean isComplete() {\n        return this.renderCount > 0 && this.renderTimes.isEmpty();\n    }","id":79663,"modified_method":"@Override\n    protected boolean isComplete() {\n        return this.renderCount > 0 && this.statisticalSummary == null;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (!super.equals(obj))\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        TabRenderAggregationImpl other = (TabRenderAggregationImpl) obj;\n        if (Double.doubleToLongBits(geometricMean) != Double.doubleToLongBits(other.geometricMean))\n            return false;\n        if (Double.doubleToLongBits(max) != Double.doubleToLongBits(other.max))\n            return false;\n        if (Double.doubleToLongBits(mean) != Double.doubleToLongBits(other.mean))\n            return false;\n        if (Double.doubleToLongBits(min) != Double.doubleToLongBits(other.min))\n            return false;\n        if (Double.doubleToLongBits(ninetiethPercentile) != Double.doubleToLongBits(other.ninetiethPercentile))\n            return false;\n        if (renderCount != other.renderCount)\n            return false;\n        if (Double.doubleToLongBits(standardDeviation) != Double.doubleToLongBits(other.standardDeviation))\n            return false;\n        if (tabName == null) {\n            if (other.tabName != null)\n                return false;\n        }\n        else if (!tabName.equals(other.tabName))\n            return false;\n        return true;\n    }","id":79664,"modified_method":"@Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (!super.equals(obj))\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        TabRenderAggregationImpl other = (TabRenderAggregationImpl) obj;\n        if (Double.doubleToLongBits(geometricMean) != Double.doubleToLongBits(other.geometricMean))\n            return false;\n        if (tabName == null) {\n            if (other.tabName != null)\n                return false;\n        }\n        else if (!tabName.equals(other.tabName))\n            return false;\n        return true;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public String toString() {\n        return \"TabRenderAggregationImpl [id=\" + id + \", dateDimension=\" + getDateDimension() + \", timeDimension=\"\n                + getTimeDimension() + \", interval=\" + getInterval() + \", aggregatedGroup=\" + getAggregatedGroup()\n                + \", duration=\" + getDuration() + \" tabName=\" + tabName + \", renderCount=\" + renderCount\n                + \", geometricMean=\" + geometricMean + \", max=\" + max + \", mean=\" + mean + \", min=\" + min\n                + \", ninetiethPercentileTime=\" + ninetiethPercentile + \", standardDeviation=\" + standardDeviation\n                + \"]\";\n    }","id":79665,"modified_method":"@Override\n    public String toString() {\n        return \"TabRenderAggregationImpl [tabName=\" + tabName + \", renderCount=\" + renderCount + \", sum=\" + sum\n                + \", sumsq=\" + sumsq + \", mean=\" + mean + \", standardDeviation=\" + standardDeviation + \", variance=\"\n                + variance + \", populationVariance=\" + populationVariance + \", max=\" + max + \", min=\" + min\n                + \", geometricMean=\" + geometricMean + \", sumOfLogs=\" + sumOfLogs + \", secondMoment=\" + secondMoment\n                + \", getTimeDimension\" + getTimeDimension() + \", getDateDimension\" + getDateDimension()\n                + \", getInterval\" + getInterval() + \", getDuration\" + getDuration() + \", getAggregatedGroup\"\n                + getAggregatedGroup() + \"]\";\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public double getStandardDeviationTime() {\n        return this.standardDeviation;\n    }","id":79666,"modified_method":"public double getStandardDeviation() {\n        return this.standardDeviation;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public double getGeometricMeanTime() {\n        return this.geometricMean;\n    }","id":79667,"modified_method":"public double getGeometricMean() {\n        return this.geometricMean;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public double getMeanTime() {\n        return this.mean;\n    }","id":79668,"modified_method":"public double getMean() {\n        return this.mean;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public double getMinTime() {\n        return this.min;\n    }","id":79669,"modified_method":"public double getMin() {\n        return this.min;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"void countRender(long executionTime) {\n        checkState();\n        \n        //Lazily init the statistics object\n        if (this.statistics == null) {\n            if (this.renderTimes.isEmpty()) {\n                this.statistics = new DescriptiveStatistics();\n            }\n            else {\n                final double[] doubleRenderTimes = new double[this.renderTimes.size()];\n                int i = 0;\n                for (final Long renderTime : this.renderTimes) {\n                    doubleRenderTimes[i++] = renderTime.doubleValue();\n                }\n                this.statistics = new DescriptiveStatistics(doubleRenderTimes);\n            }\n        }\n        \n        this.renderTimes.add(executionTime);\n        this.renderCount++;\n        this.statistics.addValue(executionTime);\n        \n        //Update statistic values\n        this.geometricMean = this.statistics.getGeometricMean();\n        this.max = this.statistics.getMax();\n        this.mean = this.statistics.getMean();\n        this.min = this.statistics.getMin();\n        this.ninetiethPercentile = this.statistics.getPercentile(90);\n        this.standardDeviation = this.statistics.getStandardDeviation();\n    }","id":79670,"modified_method":"void countRender(long executionTime) {\n        checkState();\n        \n        //Lazily init the statistics object\n        if (this.statisticalSummary == null) {\n            this.statisticalSummary = new JpaStatisticalSummary();\n        }\n        \n        this.statisticalSummary.addValue(executionTime);\n\n        //Update statistic values\n        this.renderCount = (int)this.statisticalSummary.getN();\n        this.sum = this.statisticalSummary.getSum();\n        this.sumsq = this.statisticalSummary.getSumsq();\n        this.mean = this.statisticalSummary.getMean();\n        this.standardDeviation = this.statisticalSummary.getStandardDeviation();\n        this.variance = this.statisticalSummary.getVariance();\n        this.populationVariance = this.statisticalSummary.getPopulationVariance();\n        this.max = this.statisticalSummary.getMax();\n        this.min = this.statisticalSummary.getMin();\n        this.geometricMean = this.statisticalSummary.getGeometricMean();\n        this.sumOfLogs = this.statisticalSummary.getSumOfLogs();\n        this.secondMoment = this.statisticalSummary.getSecondMoment();\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void completeInterval() {\n        this.renderTimes.clear();\n    }","id":79671,"modified_method":"@Override\n    protected void completeInterval() {\n        this.statisticalSummary = null;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public double getMaxTime() {\n        return this.max;\n    }","id":79672,"modified_method":"public double getMax() {\n        return this.max;\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    protected void updateAggregation(PortalRenderEvent e, AggregationIntervalInfo intervalInfo, TabRenderAggregationImpl aggregation) {\n        final long executionTime = e.getExecutionTime();\n        final int duration = intervalInfo.getDurationTo(e.getTimestampAsDate());\n        aggregation.setDuration(duration);\n        aggregation.countRender(executionTime);\n    }","id":79673,"modified_method":"@Override\n    protected void updateAggregation(PortalRenderEvent e, AggregationIntervalInfo intervalInfo, TabRenderAggregationImpl aggregation) {\n        final long executionTime = e.getExecutionTimeNano();\n        final int duration = intervalInfo.getDurationTo(e.getTimestampAsDate());\n        aggregation.setDuration(duration);\n        aggregation.countRender(executionTime);\n    }","commit_id":"3d11f7689e8bc713c017ca21c45594e0c92b3698","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     *  Verify the first byte.\n     *  The InternalSocket doesn't support SoTimeout, so use available()\n     *  instead to prevent hanging.\n     */\n    protected boolean validate(Socket socket) {\n        try {\n            InputStream is = socket.getInputStream();\n            for (int i = 0; i < 20; i++) {\n                if (is.available() > 0)\n                    return is.read() == I2PClient.PROTOCOL_BYTE;\n                try { Thread.sleep(250); } catch (InterruptedException ie) {}\n            }\n        } catch (IOException ioe) {}\n        if (_log.shouldLog(Log.WARN))\n             _log.warn(\"Peer did not authenticate themselves as I2CP quickly enough, dropping\");\n        return false;\n    }","id":79674,"modified_method":"/**\n     *  Verify the first byte.\n     *  The InternalSocket doesn't support SoTimeout, so use available()\n     *  instead to prevent hanging.\n     */\n    protected boolean validate(Socket socket) {\n        try {\n            InputStream is = socket.getInputStream();\n            for (int i = 0; i < CONNECT_TIMEOUT / LOOP_DELAY; i++) {\n                if (is.available() > 0)\n                    return is.read() == I2PClient.PROTOCOL_BYTE;\n                try { Thread.sleep(LOOP_DELAY); } catch (InterruptedException ie) {}\n            }\n        } catch (IOException ioe) {}\n        if (_log.shouldLog(Log.WARN))\n             _log.warn(\"Peer did not authenticate themselves as I2CP quickly enough, dropping\");\n        return false;\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** \n     * Start up the socket listener, listens for connections, and\n     * fires those connections off via {@link #runConnection runConnection}.  \n     * This only returns if the socket cannot be opened or there is a catastrophic\n     * failure.\n     *\n     */\n    public void runServer() {\n        _running = true;\n        int curDelay = 1000;\n        while (_running) {\n            try {\n                if (_bindAllInterfaces) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Listening on port \" + _port + \" on all interfaces\");\n                    _socket = new ServerSocket(_port);\n                } else {\n                    String listenInterface = _context.getProperty(ClientManagerFacadeImpl.PROP_CLIENT_HOST, \n                                                                  ClientManagerFacadeImpl.DEFAULT_HOST);\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(\"Listening on port \" + _port + \" of the specific interface: \" + listenInterface);\n                    _socket = new ServerSocket(_port, 0, InetAddress.getByName(listenInterface));\n                }\n                \n                \n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"ServerSocket created, before accept: \" + _socket);\n                \n                curDelay = 1000;\n                _listening = true;\n                while (_running) {\n                    try {\n                        Socket socket = _socket.accept();\n                        if (validate(socket)) {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"Connection received\");\n                            runConnection(socket);\n                        } else {\n                            if (_log.shouldLog(Log.WARN))\n                                _log.warn(\"Refused connection from \" + socket.getInetAddress());\n                            try {\n                                socket.close();\n                            } catch (IOException ioe) {}\n                        }\n                    } catch (IOException ioe) {\n                        if (_context.router().isAlive()) \n                            _log.error(\"Server error accepting\", ioe);\n                    } catch (Throwable t) {\n                        if (_context.router().isAlive()) \n                            _log.error(\"Fatal error running client listener - killing the thread!\", t);\n                        _listening = false;\n                        return;\n                    }\n                }\n            } catch (IOException ioe) {\n                if (_context.router().isAlive()) \n                    _log.error(\"Error listening on port \" + _port, ioe);\n            }\n            \n            _listening = false;\n            if (_socket != null) {\n                try { _socket.close(); } catch (IOException ioe) {}\n                _socket = null; \n            }\n            \n            if (!_context.router().isAlive()) break;\n            \n            if (curDelay < 60*1000)\n                _log.error(\"Error listening, waiting \" + (curDelay/1000) + \"s before we try again\");\n            else\n                _log.log(Log.CRIT, \"I2CP error listening to port \" + _port + \" - is another I2P instance running? Resolve conflicts and restart\");\n            try { Thread.sleep(curDelay); } catch (InterruptedException ie) {}\n            curDelay = Math.min(curDelay*3, 60*1000);\n        }\n\n        if (_context.router().isAlive())\n            _log.error(\"CANCELING I2CP LISTEN\", new Exception(\"I2CP Listen cancelled!!!\"));\n        _running = false;\n    }","id":79675,"modified_method":"/** \n     * Start up the socket listener, listens for connections, and\n     * fires those connections off via {@link #runConnection runConnection}.  \n     * This only returns if the socket cannot be opened or there is a catastrophic\n     * failure.\n     *\n     */\n    public void runServer() {\n        _running = true;\n        int curDelay = 1000;\n        while (_running) {\n            try {\n                _socket = getServerSocket();\n                \n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"ServerSocket created, before accept: \" + _socket);\n                \n                curDelay = 1000;\n                _listening = true;\n                while (_running) {\n                    try {\n                        Socket socket = _socket.accept();\n                        if (validate(socket)) {\n                            if (_log.shouldLog(Log.DEBUG))\n                                _log.debug(\"Connection received\");\n                            runConnection(socket);\n                        } else {\n                            if (_log.shouldLog(Log.WARN))\n                                _log.warn(\"Refused connection from \" + socket.getInetAddress());\n                            try {\n                                socket.close();\n                            } catch (IOException ioe) {}\n                        }\n                    } catch (IOException ioe) {\n                        if (_context.router().isAlive()) \n                            _log.error(\"Server error accepting\", ioe);\n                    } catch (Throwable t) {\n                        if (_context.router().isAlive()) \n                            _log.error(\"Fatal error running client listener - killing the thread!\", t);\n                        _listening = false;\n                        return;\n                    }\n                }\n            } catch (IOException ioe) {\n                if (_context.router().isAlive()) \n                    _log.error(\"Error listening on port \" + _port, ioe);\n            }\n            \n            _listening = false;\n            if (_socket != null) {\n                try { _socket.close(); } catch (IOException ioe) {}\n                _socket = null; \n            }\n            \n            if (!_context.router().isAlive()) break;\n            \n            if (curDelay < 60*1000)\n                _log.error(\"Error listening, waiting \" + (curDelay/1000) + \"s before we try again\");\n            else\n                _log.log(Log.CRIT, \"I2CP error listening to port \" + _port + \" - is another I2P instance running? Resolve conflicts and restart\");\n            try { Thread.sleep(curDelay); } catch (InterruptedException ie) {}\n            curDelay = Math.min(curDelay*3, 60*1000);\n        }\n\n        if (_context.router().isAlive())\n            _log.error(\"CANCELING I2CP LISTEN\", new Exception(\"I2CP Listen cancelled!!!\"));\n        _running = false;\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public ClientListenerRunner(RouterContext context, ClientManager manager, int port) {\n        _context = context;\n        _log = _context.logManager().getLog(ClientListenerRunner.class);\n        _manager = manager;\n        _port = port;\n        \n        String val = context.getProperty(BIND_ALL_INTERFACES);\n        _bindAllInterfaces = Boolean.valueOf(val).booleanValue();\n    }","id":79676,"modified_method":"public ClientListenerRunner(RouterContext context, ClientManager manager, int port) {\n        _context = context;\n        _log = _context.logManager().getLog(getClass());\n        _manager = manager;\n        _port = port;\n        _bindAllInterfaces = context.getBooleanProperty(BIND_ALL_INTERFACES);\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public ClientManager(RouterContext context, int port) {\n        _ctx = context;\n        _log = context.logManager().getLog(ClientManager.class);\n        _ctx.statManager().createRateStat(\"client.receiveMessageSize\", \n                                              \"How large are messages received by the client?\", \n                                              \"ClientMessages\", \n                                              new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _runners = new HashMap();\n        _pendingRunners = new HashSet();\n        startListeners(port);\n    }","id":79677,"modified_method":"public ClientManager(RouterContext context, int port) {\n        _ctx = context;\n        _log = context.logManager().getLog(ClientManager.class);\n        //_ctx.statManager().createRateStat(\"client.receiveMessageSize\", \n        //                                      \"How large are messages received by the client?\", \n        //                                      \"ClientMessages\", \n        //                                      new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _runners = new HashMap();\n        _pendingRunners = new HashSet();\n        startListeners(port);\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** Todo: Start a 3rd listener for IPV6? */\n    private void startListeners(int port) {\n        if (!_ctx.getBooleanProperty(PROP_DISABLE_EXTERNAL)) {\n            _listener = new ClientListenerRunner(_ctx, this, port);\n            Thread t = new I2PThread(_listener, \"ClientListener:\" + port, true);\n            t.start();\n        }\n        _isStarted = true;\n    }","id":79678,"modified_method":"/** Todo: Start a 3rd listener for IPV6? */\n    private void startListeners(int port) {\n        if (!_ctx.getBooleanProperty(PROP_DISABLE_EXTERNAL)) {\n            // there's no option to start both an SSL and non-SSL listener\n            if (_ctx.getBooleanProperty(PROP_ENABLE_SSL))\n                _listener = new SSLClientListenerRunner(_ctx, this, port);\n            else\n                _listener = new ClientListenerRunner(_ctx, this, port);\n            Thread t = new I2PThread(_listener, \"ClientListener:\" + port, true);\n            t.start();\n        }\n        _isStarted = true;\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void runJob() {\n            ClientConnectionRunner runner = null;\n            if (_msg.getDestination() != null) \n                runner = getRunner(_msg.getDestination());\n            else \n                runner = getRunner(_msg.getDestinationHash());\n\n            if (runner != null) {\n                _ctx.statManager().addRateData(\"client.receiveMessageSize\", \n                                                   _msg.getPayload().getSize(), 0);\n                runner.receiveMessage(_msg.getDestination(), null, _msg.getPayload());\n            } else {\n                // no client connection...\n                // we should pool these somewhere...\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Message received but we don't have a connection to \" \n                              + _msg.getDestination() + \"/\" + _msg.getDestinationHash() \n                              + \" currently.  DROPPED\");\n            }\n        }","id":79679,"modified_method":"public void runJob() {\n            ClientConnectionRunner runner = null;\n            if (_msg.getDestination() != null) \n                runner = getRunner(_msg.getDestination());\n            else \n                runner = getRunner(_msg.getDestinationHash());\n\n            if (runner != null) {\n                //_ctx.statManager().addRateData(\"client.receiveMessageSize\", \n                //                                   _msg.getPayload().getSize(), 0);\n                runner.receiveMessage(_msg.getDestination(), null, _msg.getPayload());\n            } else {\n                // no client connection...\n                // we should pool these somewhere...\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Message received but we don't have a connection to \" \n                              + _msg.getDestination() + \"/\" + _msg.getDestinationHash() \n                              + \" currently.  DROPPED\");\n            }\n        }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Connect to the router and establish a session.  This call blocks until \n     * a session is granted.\n     *\n     * @throws I2PSessionException if there is a configuration error or the router is\n     *                             not reachable\n     */\n    public void connect() throws I2PSessionException {\n        setOpening(true);\n        _closed = false;\n        _availabilityNotifier.stopNotifying();\n        \n        if ( (_options != null) && \n             (I2PClient.PROP_RELIABILITY_GUARANTEED.equals(_options.getProperty(I2PClient.PROP_RELIABILITY, I2PClient.PROP_RELIABILITY_BEST_EFFORT))) ) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"I2CP guaranteed delivery mode has been removed, using best effort.\");\n        }\n            \n        long startConnect = _context.clock().now();\n        try {\n            // If we are in the router JVM, connect using the interal queue\n            if (_context.isRouterContext()) {\n                // _socket, _out, and _writer remain null\n                InternalClientManager mgr = _context.internalClientManager();\n                if (mgr == null)\n                    throw new I2PSessionException(\"Router is not ready for connections\");\n                // the following may throw an I2PSessionException\n                _queue = mgr.connect();\n                _reader = new QueuedI2CPMessageReader(_queue, this);\n            } else {\n                _socket = new Socket(_hostname, _portNum);\n                // _socket.setSoTimeout(1000000); // Uhmmm we could really-really use a real timeout, and handle it.\n                _out = _socket.getOutputStream();\n                synchronized (_out) {\n                    _out.write(I2PClient.PROTOCOL_BYTE);\n                    _out.flush();\n                }\n                _writer = new ClientWriterRunner(_out, this);\n                InputStream in = _socket.getInputStream();\n                _reader = new I2CPMessageReader(in, this);\n            }\n            Thread notifier = new I2PAppThread(_availabilityNotifier, \"ClientNotifier \" + getPrefix(), true);\n            notifier.start();\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"before startReading\");\n            _reader.startReading();\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"Before getDate\");\n            sendMessage(new GetDateMessage());\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"After getDate / begin waiting for a response\");\n            int waitcount = 0;\n            while (!_dateReceived) {\n                if (waitcount++ > 30) {\n                    closeSocket();\n                    throw new IOException(\"No handshake received from the router\");\n                }\n                try {\n                    synchronized (_dateReceivedLock) {\n                        _dateReceivedLock.wait(1000);\n                    }\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"After received a SetDate response\");\n\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"Before producer.connect()\");\n            _producer.connect(this);\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"After  producer.connect()\");\n\n            // wait until we have created a lease set\n            waitcount = 0;\n            while (_leaseSet == null) {\n                if (waitcount++ > 5*60) {\n                    try {\n                        _producer.disconnect(this);\n                    } catch (I2PSessionException ipe) {}\n                    closeSocket();\n                    throw new IOException(\"No tunnels built after waiting 5 minutes... are there network problems?\");\n                }\n                synchronized (_leaseSetWait) {\n                    try {\n                        _leaseSetWait.wait(1000);\n                    } catch (InterruptedException ie) { // nop\n                    }\n                }\n            }\n            long connected = _context.clock().now();\n            if (_log.shouldLog(Log.INFO))\n                 _log.info(getPrefix() + \"Lease set created with inbound tunnels after \"\n                           + (connected - startConnect)\n                           + \"ms - ready to participate in the network!\");\n            startIdleMonitor();\n             setOpening(false);\n        } catch (UnknownHostException uhe) {\n            _closed = true;\n            setOpening(false);\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, uhe);\n        } catch (IOException ioe) {\n            _closed = true;\n            setOpening(false);\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, ioe);\n        }\n    }","id":79680,"modified_method":"/**\n     * Connect to the router and establish a session.  This call blocks until \n     * a session is granted.\n     *\n     * @throws I2PSessionException if there is a configuration error or the router is\n     *                             not reachable\n     */\n    public void connect() throws I2PSessionException {\n        setOpening(true);\n        _closed = false;\n        _availabilityNotifier.stopNotifying();\n        \n        if ( (_options != null) && \n             (I2PClient.PROP_RELIABILITY_GUARANTEED.equals(_options.getProperty(I2PClient.PROP_RELIABILITY, I2PClient.PROP_RELIABILITY_BEST_EFFORT))) ) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"I2CP guaranteed delivery mode has been removed, using best effort.\");\n        }\n            \n        long startConnect = _context.clock().now();\n        try {\n            // If we are in the router JVM, connect using the interal queue\n            if (_context.isRouterContext()) {\n                // _socket, _out, and _writer remain null\n                InternalClientManager mgr = _context.internalClientManager();\n                if (mgr == null)\n                    throw new I2PSessionException(\"Router is not ready for connections\");\n                // the following may throw an I2PSessionException\n                _queue = mgr.connect();\n                _reader = new QueuedI2CPMessageReader(_queue, this);\n            } else {\n                if (Boolean.valueOf(_options.getProperty(PROP_ENABLE_SSL)).booleanValue())\n                    _socket = I2CPSSLSocketFactory.createSocket(_context, _hostname, _portNum);\n                else\n                    _socket = new Socket(_hostname, _portNum);\n                // _socket.setSoTimeout(1000000); // Uhmmm we could really-really use a real timeout, and handle it.\n                _out = _socket.getOutputStream();\n                synchronized (_out) {\n                    _out.write(I2PClient.PROTOCOL_BYTE);\n                    _out.flush();\n                }\n                _writer = new ClientWriterRunner(_out, this);\n                InputStream in = _socket.getInputStream();\n                _reader = new I2CPMessageReader(in, this);\n            }\n            Thread notifier = new I2PAppThread(_availabilityNotifier, \"ClientNotifier \" + getPrefix(), true);\n            notifier.start();\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"before startReading\");\n            _reader.startReading();\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"Before getDate\");\n            sendMessage(new GetDateMessage());\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"After getDate / begin waiting for a response\");\n            int waitcount = 0;\n            while (!_dateReceived) {\n                if (waitcount++ > 30) {\n                    closeSocket();\n                    throw new IOException(\"No handshake received from the router\");\n                }\n                try {\n                    synchronized (_dateReceivedLock) {\n                        _dateReceivedLock.wait(1000);\n                    }\n                } catch (InterruptedException ie) { // nop\n                }\n            }\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"After received a SetDate response\");\n\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"Before producer.connect()\");\n            _producer.connect(this);\n            if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + \"After  producer.connect()\");\n\n            // wait until we have created a lease set\n            waitcount = 0;\n            while (_leaseSet == null) {\n                if (waitcount++ > 5*60) {\n                    try {\n                        _producer.disconnect(this);\n                    } catch (I2PSessionException ipe) {}\n                    closeSocket();\n                    throw new IOException(\"No tunnels built after waiting 5 minutes... are there network problems?\");\n                }\n                synchronized (_leaseSetWait) {\n                    try {\n                        _leaseSetWait.wait(1000);\n                    } catch (InterruptedException ie) { // nop\n                    }\n                }\n            }\n            long connected = _context.clock().now();\n            if (_log.shouldLog(Log.INFO))\n                 _log.info(getPrefix() + \"Lease set created with inbound tunnels after \"\n                           + (connected - startConnect)\n                           + \"ms - ready to participate in the network!\");\n            startIdleMonitor();\n             setOpening(false);\n        } catch (UnknownHostException uhe) {\n            _closed = true;\n            setOpening(false);\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, uhe);\n        } catch (IOException ioe) {\n            _closed = true;\n            setOpening(false);\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, ioe);\n        }\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Parse the config for anything we know about.\n     * Also fill in the authorization properties if missing.\n     */\n    protected void loadConfig(Properties options) {\n        _options = new Properties();\n        _options.putAll(filter(options));\n        if (!_context.isRouterContext()) {\n            _hostname = _options.getProperty(I2PClient.PROP_TCP_HOST, \"127.0.0.1\");\n            String portNum = _options.getProperty(I2PClient.PROP_TCP_PORT, LISTEN_PORT + \"\");\n            try {\n                _portNum = Integer.parseInt(portNum);\n            } catch (NumberFormatException nfe) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(getPrefix() + \"Invalid port number specified, defaulting to \"\n                              + LISTEN_PORT, nfe);\n                _portNum = LISTEN_PORT;\n            }\n        }\n\n        // auto-add auth if required, not set in the options, and we are in the same JVM\n        if (_context.isRouterContext() &&\n            Boolean.valueOf(_context.getProperty(\"i2cp.auth\")).booleanValue() &&\n            ((!options.containsKey(\"i2cp.username\")) || (!options.containsKey(\"i2cp.password\")))) {\n            String configUser = _context.getProperty(\"i2cp.username\");\n            String configPW = _context.getProperty(\"i2cp.password\");\n            if (configUser != null && configPW != null) {\n                _options.setProperty(\"i2cp.username\", configUser);\n                _options.setProperty(\"i2cp.password\", configPW);\n            }\n        }\n    }","id":79681,"modified_method":"/**\n     * Parse the config for anything we know about.\n     * Also fill in the authorization properties if missing.\n     */\n    protected void loadConfig(Properties options) {\n        _options = new Properties();\n        _options.putAll(filter(options));\n        if (_context.isRouterContext()) {\n            // just for logging\n            _hostname = \"[internal connection]\";\n        } else {\n            _hostname = _options.getProperty(I2PClient.PROP_TCP_HOST, \"127.0.0.1\");\n            String portNum = _options.getProperty(I2PClient.PROP_TCP_PORT, LISTEN_PORT + \"\");\n            try {\n                _portNum = Integer.parseInt(portNum);\n            } catch (NumberFormatException nfe) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(getPrefix() + \"Invalid port number specified, defaulting to \"\n                              + LISTEN_PORT, nfe);\n                _portNum = LISTEN_PORT;\n            }\n        }\n\n        // auto-add auth if required, not set in the options, and we are in the same JVM\n        // TODO bypass this on router side for internal connections\n        if (_context.isRouterContext() &&\n            Boolean.valueOf(_context.getProperty(\"i2cp.auth\")).booleanValue() &&\n            ((!options.containsKey(\"i2cp.username\")) || (!options.containsKey(\"i2cp.password\")))) {\n            String configUser = _context.getProperty(\"i2cp.username\");\n            String configPW = _context.getProperty(\"i2cp.password\");\n            if (configUser != null && configPW != null) {\n                _options.setProperty(\"i2cp.username\", configUser);\n                _options.setProperty(\"i2cp.password\", configPW);\n            }\n        }\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Connect to the router and establish a session.  This call blocks until \n     * a session is granted.\n     *\n     * @throws I2PSessionException if there is a configuration error or the router is\n     *                             not reachable\n     */\n    @Override\n    public void connect() throws I2PSessionException {\n        _closed = false;\n        \n        try {\n            // If we are in the router JVM, connect using the interal queue\n            if (_context.isRouterContext()) {\n                // _socket, _out, and _writer remain null\n                InternalClientManager mgr = _context.internalClientManager();\n                if (mgr == null)\n                    throw new I2PSessionException(\"Router is not ready for connections\");\n                // the following may throw an I2PSessionException\n                _queue = mgr.connect();\n                _reader = new QueuedI2CPMessageReader(_queue, this);\n            } else {\n                _socket = new Socket(_hostname, _portNum);\n                _out = _socket.getOutputStream();\n                synchronized (_out) {\n                    _out.write(I2PClient.PROTOCOL_BYTE);\n                    _out.flush();\n                }\n                _writer = new ClientWriterRunner(_out, this);\n                InputStream in = _socket.getInputStream();\n                _reader = new I2CPMessageReader(in, this);\n            }\n            // we do not receive payload messages, so we do not need an AvailabilityNotifier\n            _reader.startReading();\n\n        } catch (UnknownHostException uhe) {\n            _closed = true;\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, uhe);\n        } catch (IOException ioe) {\n            _closed = true;\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, ioe);\n        }\n    }","id":79682,"modified_method":"/**\n     * Connect to the router and establish a session.  This call blocks until \n     * a session is granted.\n     *\n     * @throws I2PSessionException if there is a configuration error or the router is\n     *                             not reachable\n     */\n    @Override\n    public void connect() throws I2PSessionException {\n        _closed = false;\n        \n        try {\n            // If we are in the router JVM, connect using the interal queue\n            if (_context.isRouterContext()) {\n                // _socket, _out, and _writer remain null\n                InternalClientManager mgr = _context.internalClientManager();\n                if (mgr == null)\n                    throw new I2PSessionException(\"Router is not ready for connections\");\n                // the following may throw an I2PSessionException\n                _queue = mgr.connect();\n                _reader = new QueuedI2CPMessageReader(_queue, this);\n            } else {\n                if (Boolean.valueOf(getOptions().getProperty(PROP_ENABLE_SSL)).booleanValue())\n                    _socket = I2CPSSLSocketFactory.createSocket(_context, _hostname, _portNum);\n                else\n                    _socket = new Socket(_hostname, _portNum);\n                _out = _socket.getOutputStream();\n                synchronized (_out) {\n                    _out.write(I2PClient.PROTOCOL_BYTE);\n                    _out.flush();\n                }\n                _writer = new ClientWriterRunner(_out, this);\n                InputStream in = _socket.getInputStream();\n                _reader = new I2CPMessageReader(in, this);\n            }\n            // we do not receive payload messages, so we do not need an AvailabilityNotifier\n            _reader.startReading();\n\n        } catch (UnknownHostException uhe) {\n            _closed = true;\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, uhe);\n        } catch (IOException ioe) {\n            _closed = true;\n            throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, ioe);\n        }\n    }","commit_id":"8efefeeb5bcb89fd90812269921479c5bfce641c","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String getImages() { \n        try {\n            List listeners = StatSummarizer.instance().getListeners();\n            TreeSet ordered = new TreeSet(new AlphaComparator());\n            ordered.addAll(listeners);\n\n            // go to some trouble to see if we have the data for the combined bw graph\n            boolean hasTx = false;\n            boolean hasRx = false;\n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                String title = lsnr.getRate().getRateStat().getName();\n                if (title.equals(\"bw.sendRate\")) hasTx = true;\n                else if (title.equals(\"bw.recvRate\")) hasRx = true;\n            }\n\n            if (hasTx && hasRx && !_showEvents) {\n                _out.write(\"<a href=\\\"viewstat.jsp?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + (3 * _periodCount )\n                           + \"&amp;width=\" + (3 * _width)\n                           + \"&amp;height=\" + (3 * _height)\n                           + \"\\\" target=\\\"_blank\\\">\");\n                String title = _(\"Combined bandwidth graph\");\n                _out.write(\"<img class=\\\"statimage\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + (_height - 13)\n                           + \"\\\" alt=\\\"\" + title + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n            \n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                Rate r = lsnr.getRate();\n                // e.g. \"statname for 60m\"\n                String title = _(\"{0} for {1}\", r.getRateStat().getName(), DataHelper.formatDuration2(_periodCount * r.getPeriod()));\n                _out.write(\"<a href=\\\"viewstat.jsp?stat=\"\n                           + r.getRateStat().getName() \n                           + \"&amp;showEvents=\" + _showEvents\n                           + \"&amp;period=\" + r.getPeriod() \n                           + \"&amp;periodCount=\" + (3 * _periodCount)\n                           + \"&amp;width=\" + (3 * _width)\n                           + \"&amp;height=\" + (3 * _height)\n                           + \"\\\" target=\\\"_blank\\\">\");\n                _out.write(\"<img class=\\\"statimage\\\" border=\\\"0\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=\"\n                           + r.getRateStat().getName() \n                           + \"&amp;showEvents=\" + _showEvents\n                           + \"&amp;period=\" + r.getPeriod() \n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + _height\n                           + \"\\\" alt=\\\"\" + title \n                           + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n            // FIXME <meta> not allowed inside <div>, move to the .jsp\n            if (_refreshDelaySeconds > 0)\n                // shorten the refresh by 3 seconds so we beat the iframe\n                _out.write(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" + (_refreshDelaySeconds - 3) + \"\\\">\\n\");\n\n            // FIXME jrobin doesn't support setting the timezone, will have to mod TimeAxis.java\n            _out.write(\"<p<i>\" + _(\"All times are UTC.\") + \"<\/i><\/p>\\n\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","id":79683,"modified_method":"public String getImages() { \n        try {\n            List listeners = StatSummarizer.instance().getListeners();\n            TreeSet ordered = new TreeSet(new AlphaComparator());\n            ordered.addAll(listeners);\n\n            // go to some trouble to see if we have the data for the combined bw graph\n            boolean hasTx = false;\n            boolean hasRx = false;\n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                String title = lsnr.getRate().getRateStat().getName();\n                if (title.equals(\"bw.sendRate\")) hasTx = true;\n                else if (title.equals(\"bw.recvRate\")) hasRx = true;\n            }\n\n            if (hasTx && hasRx && !_showEvents) {\n                _out.write(\"<a href=\\\"viewstat.jsp?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + (3 * _periodCount )\n                           + \"&amp;width=\" + (3 * _width)\n                           + \"&amp;height=\" + (3 * _height)\n                           + \"\\\" target=\\\"_blank\\\">\");\n                String title = _(\"Combined bandwidth graph\");\n                _out.write(\"<img class=\\\"statimage\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=bw.combined\"\n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + (_height - 13)\n                           + \"\\\" alt=\\\"\" + title + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n            \n            for (Iterator iter = ordered.iterator(); iter.hasNext(); ) {\n                SummaryListener lsnr = (SummaryListener)iter.next();\n                Rate r = lsnr.getRate();\n                // e.g. \"statname for 60m\"\n                String title = _(\"{0} for {1}\", r.getRateStat().getName(), DataHelper.formatDuration2(_periodCount * r.getPeriod()));\n                _out.write(\"<a href=\\\"viewstat.jsp?stat=\"\n                           + r.getRateStat().getName() \n                           + \"&amp;showEvents=\" + _showEvents\n                           + \"&amp;period=\" + r.getPeriod() \n                           + \"&amp;periodCount=\" + (3 * _periodCount)\n                           + \"&amp;width=\" + (3 * _width)\n                           + \"&amp;height=\" + (3 * _height)\n                           + \"\\\" target=\\\"_blank\\\">\");\n                _out.write(\"<img class=\\\"statimage\\\" border=\\\"0\\\"\"\n                           + \" src=\\\"viewstat.jsp?stat=\"\n                           + r.getRateStat().getName() \n                           + \"&amp;showEvents=\" + _showEvents\n                           + \"&amp;period=\" + r.getPeriod() \n                           + \"&amp;periodCount=\" + _periodCount \n                           + \"&amp;width=\" + _width\n                           + \"&amp;height=\" + _height\n                           + \"\\\" alt=\\\"\" + title \n                           + \"\\\" title=\\\"\" + title + \"\\\"><\/a>\\n\");\n            }\n\n            // FIXME jrobin doesn't support setting the timezone, will have to mod TimeAxis.java\n            _out.write(\"<p><i>\" + _(\"All times are UTC.\") + \"<\/i><\/p>\\n\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** set the defaults after we have a context */\n    @Override\n    public void setContextId(String contextId) {\n        super.setContextId(contextId);\n        _width = _context.getProperty(PROP_X, DEFAULT_X);\n        _height = _context.getProperty(PROP_Y, DEFAULT_Y);\n        _periodCount = _context.getProperty(PROP_PERIODS, DEFAULT_PERIODS);\n        _refreshDelaySeconds = _context.getProperty(PROP_REFRESH, DEFAULT_REFRESH);\n        _showEvents = Boolean.valueOf(_context.getProperty(PROP_EVENTS)).booleanValue();\n    }","id":79684,"modified_method":"/** set the defaults after we have a context */\n    @Override\n    public void setContextId(String contextId) {\n        super.setContextId(contextId);\n        _width = _context.getProperty(PROP_X, DEFAULT_X);\n        _height = _context.getProperty(PROP_Y, DEFAULT_Y);\n        _periodCount = _context.getProperty(PROP_PERIODS, DEFAULT_PERIODS);\n        _refreshDelaySeconds = _context.getProperty(PROP_REFRESH, DEFAULT_REFRESH);\n        _showEvents = _context.getBooleanProperty(PROP_EVENTS);\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String getForm() { \n        String prev = System.getProperty(\"net.i2p.router.web.GraphHelper.nonce\");\n        if (prev != null) System.setProperty(\"net.i2p.router.web.GraphHelper.noncePrev\", prev);\n        String nonce = \"\" + _context.random().nextLong();\n        System.setProperty(\"net.i2p.router.web.GraphHelper.nonce\", nonce);\n        try {\n            _out.write(\"<br><h3>\" + _(\"Configure Graph Display\") + \" [<a href=\\\"configstats\\\">\" + _(\"Select Stats\") + \"<\/a>]<\/h3>\");\n            _out.write(\"<form action=\\\"graphs\\\" method=\\\"POST\\\">\\n\" +\n                       \"<input type=\\\"hidden\\\" name=\\\"action\\\" value=\\\"foo\\\">\\n\" +\n                       \"<input type=\\\"hidden\\\" name=\\\"nonce\\\" value=\\\"\" + nonce + \"\\\" >\\n\");\n            _out.write(_(\"Periods\") + \": <input size=\\\"3\\\" type=\\\"text\\\" name=\\\"periodCount\\\" value=\\\"\" + _periodCount + \"\\\"><br>\\n\");\n            _out.write(_(\"Plot averages\") + \": <input type=\\\"radio\\\" class=\\\"optbox\\\" name=\\\"showEvents\\\" value=\\\"false\\\" \" + (_showEvents ? \"\" : \"checked=\\\"true\\\" \") + \"> \");\n            _out.write(_(\"or\")+ \" \" +_(\"plot events\") + \": <input type=\\\"radio\\\" class=\\\"optbox\\\" name=\\\"showEvents\\\" value=\\\"true\\\" \"+ (_showEvents ? \"checked=\\\"true\\\" \" : \"\") + \"><br>\\n\");\n            _out.write(_(\"Image sizes\") + \": \" + _(\"width\") + \": <input size=\\\"4\\\" type=\\\"text\\\" name=\\\"width\\\" value=\\\"\" + _width \n                       + \"\\\"> \" + _(\"pixels\") + \", \" + _(\"height\") + \": <input size=\\\"4\\\" type=\\\"text\\\" name=\\\"height\\\" value=\\\"\" + _height  \n                       + \"\\\"> \" + _(\"pixels\") + \"<br>\\n\");\n            _out.write(_(\"Refresh delay\") + \": <select name=\\\"refreshDelay\\\">\");\n            for (int i = 0; i < times.length; i++) {\n                _out.write(\"<option value=\\\"\");\n                _out.write(Integer.toString(times[i]));\n                _out.write(\"\\\"\");\n                if (times[i] == _refreshDelaySeconds)\n                    _out.write(\" selected=\\\"true\\\"\");\n                _out.write(\">\");\n                if (times[i] > 0)\n                    _out.write(DataHelper.formatDuration2(times[i] * 1000));\n                else\n                    _out.write(_(\"Never\"));\n                _out.write(\"<\/option>\\n\");\n            }\n            _out.write(\"<\/select><br>\\n\" +\n                       \"<hr><div class=\\\"formaction\\\"><input type=\\\"submit\\\" value=\\\"\" + _(\"Redraw\") + \"\\\"><\/div><\/form>\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","id":79685,"modified_method":"public String getForm() { \n        String prev = System.getProperty(\"net.i2p.router.web.GraphHelper.nonce\");\n        if (prev != null) System.setProperty(\"net.i2p.router.web.GraphHelper.noncePrev\", prev);\n        String nonce = \"\" + _context.random().nextLong();\n        System.setProperty(\"net.i2p.router.web.GraphHelper.nonce\", nonce);\n        try {\n            _out.write(\"<br><h3>\" + _(\"Configure Graph Display\") + \" [<a href=\\\"configstats\\\">\" + _(\"Select Stats\") + \"<\/a>]<\/h3>\");\n            _out.write(\"<form action=\\\"graphs\\\" method=\\\"POST\\\">\\n\" +\n                       \"<input type=\\\"hidden\\\" name=\\\"action\\\" value=\\\"foo\\\">\\n\" +\n                       \"<input type=\\\"hidden\\\" name=\\\"nonce\\\" value=\\\"\" + nonce + \"\\\" >\\n\");\n            _out.write(_(\"Periods\") + \": <input size=\\\"5\\\" style=\\\"text-align: right;\\\" type=\\\"text\\\" name=\\\"periodCount\\\" value=\\\"\" + _periodCount + \"\\\"><br>\\n\");\n            _out.write(_(\"Plot averages\") + \": <input type=\\\"radio\\\" class=\\\"optbox\\\" name=\\\"showEvents\\\" value=\\\"false\\\" \" + (_showEvents ? \"\" : \"checked=\\\"true\\\" \") + \"> \");\n            _out.write(_(\"or\")+ \" \" +_(\"plot events\") + \": <input type=\\\"radio\\\" class=\\\"optbox\\\" name=\\\"showEvents\\\" value=\\\"true\\\" \"+ (_showEvents ? \"checked=\\\"true\\\" \" : \"\") + \"><br>\\n\");\n            _out.write(_(\"Image sizes\") + \": \" + _(\"width\") + \": <input size=\\\"4\\\" style=\\\"text-align: right;\\\" type=\\\"text\\\" name=\\\"width\\\" value=\\\"\" + _width \n                       + \"\\\"> \" + _(\"pixels\") + \", \" + _(\"height\") + \": <input size=\\\"4\\\" style=\\\"text-align: right;\\\" type=\\\"text\\\" name=\\\"height\\\" value=\\\"\" + _height  \n                       + \"\\\"> \" + _(\"pixels\") + \"<br>\\n\");\n            _out.write(_(\"Refresh delay\") + \": <select name=\\\"refreshDelay\\\">\");\n            for (int i = 0; i < times.length; i++) {\n                _out.write(\"<option value=\\\"\");\n                _out.write(Integer.toString(times[i]));\n                _out.write(\"\\\"\");\n                if (times[i] == _refreshDelaySeconds)\n                    _out.write(\" selected=\\\"true\\\"\");\n                _out.write(\">\");\n                if (times[i] > 0)\n                    _out.write(DataHelper.formatDuration2(times[i] * 1000));\n                else\n                    _out.write(_(\"Never\"));\n                _out.write(\"<\/option>\\n\");\n            }\n            _out.write(\"<\/select><br>\\n\" +\n                       _(\"Store graph data on disk?\") +\n                       \" <input type=\\\"checkbox\\\" class=\\\"optbox\\\" value=\\\"true\\\" name=\\\"persistent\\\"\");\n            boolean persistent = _context.getBooleanPropertyDefaultTrue(SummaryListener.PROP_PERSISTENT);\n            if (persistent)\n                _out.write(\" checked=\\\"true\\\"\");\n            _out.write(\">\" +\n                       \"<hr><div class=\\\"formaction\\\"><input type=\\\"submit\\\" value=\\\"\" + _(\"Save settings and redraw graphs\") + \"\\\"><\/div><\/form>\");\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        return \"\"; \n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Silently save settings if changed, no indication of success or failure\n     *  @since 0.7.10\n     */\n    private void saveSettings() {\n        if (_width != _context.getProperty(PROP_X, DEFAULT_X) ||\n            _height != _context.getProperty(PROP_Y, DEFAULT_Y) ||\n            _periodCount != _context.getProperty(PROP_PERIODS, DEFAULT_PERIODS) ||\n            _refreshDelaySeconds != _context.getProperty(PROP_REFRESH, DEFAULT_REFRESH) ||\n            _showEvents != Boolean.valueOf(_context.getProperty(PROP_EVENTS)).booleanValue()) {\n            _context.router().setConfigSetting(PROP_X, \"\" + _width);\n            _context.router().setConfigSetting(PROP_Y, \"\" + _height);\n            _context.router().setConfigSetting(PROP_PERIODS, \"\" + _periodCount);\n            _context.router().setConfigSetting(PROP_REFRESH, \"\" + _refreshDelaySeconds);\n            _context.router().setConfigSetting(PROP_EVENTS, \"\" + _showEvents);\n            _context.router().saveConfig();\n            addFormNotice(_(\"Graph settings saved\"));\n        }\n    }","id":79686,"modified_method":"/**\n     *  Silently save settings if changed, no indication of success or failure\n     *  @since 0.7.10\n     */\n    private void saveSettings() {\n        if (_width != _context.getProperty(PROP_X, DEFAULT_X) ||\n            _height != _context.getProperty(PROP_Y, DEFAULT_Y) ||\n            _periodCount != _context.getProperty(PROP_PERIODS, DEFAULT_PERIODS) ||\n            _refreshDelaySeconds != _context.getProperty(PROP_REFRESH, DEFAULT_REFRESH) ||\n            _showEvents != _context.getBooleanProperty(PROP_EVENTS) ||\n            _persistent != _context.getBooleanPropertyDefaultTrue(SummaryListener.PROP_PERSISTENT)) {\n            _context.router().setConfigSetting(PROP_X, \"\" + _width);\n            _context.router().setConfigSetting(PROP_Y, \"\" + _height);\n            _context.router().setConfigSetting(PROP_PERIODS, \"\" + _periodCount);\n            _context.router().setConfigSetting(PROP_REFRESH, \"\" + _refreshDelaySeconds);\n            _context.router().setConfigSetting(PROP_EVENTS, \"\" + _showEvents);\n            _context.router().setConfigSetting(SummaryListener.PROP_PERSISTENT, \"\" + _persistent);\n            _context.router().saveConfig();\n            addFormNotice(_(\"Graph settings saved\"));\n        }\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * It doesn't appear that Rates are ever stored in a Set or Map\n     * (RateStat stores in an array) so let's make this easy.\n     * We can always make something faster if it's actually used.\n     */\n    @Override\n    public int hashCode() {\n/*****\n        int hash = 5;\n        hash = 67 * hash + (int)(Double.doubleToLongBits(this._currentTotalValue) ^ (Double.doubleToLongBits(this._currentTotalValue) >>> 32));\n        hash = 67 * hash + (int)(this._currentEventCount ^ (this._currentEventCount >>> 32));\n        hash = 67 * hash + (int)(this._currentTotalEventTime ^ (this._currentTotalEventTime >>> 32));\n        hash = 67 * hash + (int)(Double.doubleToLongBits(this._lastTotalValue) ^ (Double.doubleToLongBits(this._lastTotalValue) >>> 32));\n        hash = 67 * hash + (int)(this._lastEventCount ^ (this._lastEventCount >>> 32));\n        hash = 67 * hash + (int)(this._lastTotalEventTime ^ (this._lastTotalEventTime >>> 32));\n        hash = 67 * hash + (int)(Double.doubleToLongBits(this._extremeTotalValue) ^ (Double.doubleToLongBits(this._extremeTotalValue) >>> 32));\n        hash = 67 * hash + (int)(this._extremeEventCount ^ (this._extremeEventCount >>> 32));\n        hash = 67 * hash + (int)(this._extremeTotalEventTime ^ (this._extremeTotalEventTime >>> 32));\n        hash = 67 * hash + (int)(Double.doubleToLongBits(this._lifetimeTotalValue) ^ (Double.doubleToLongBits(this._lifetimeTotalValue) >>> 32));\n        hash = 67 * hash + (int)(this._lifetimeEventCount ^ (this._lifetimeEventCount >>> 32));\n        hash = 67 * hash + (int)(this._lifetimeTotalEventTime ^ (this._lifetimeTotalEventTime >>> 32));\n        hash = 67 * hash + (int)(this._creationDate ^ (this._creationDate >>> 32));\n        hash = 67 * hash + (int)(this._period ^ (this._period >>> 32));\n        return hash;\n******/\n        return toString().hashCode();\n    }","id":79687,"modified_method":"/**\n     * It doesn't appear that Rates are ever stored in a Set or Map\n     * (RateStat stores in an array) so let's make this easy.\n     */\n    @Override\n    public int hashCode() {\n        return DataHelper.hashCode(_stat) ^ ((int)_period) ^ ((int) _creationDate);\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if ((obj == null) || !(obj instanceof Rate)) return false;\n        if (obj == this) return true;\n        Rate r = (Rate) obj;\n        return _period == r.getPeriod() && _creationDate == r.getCreationDate() &&\n        //_lastCoalesceDate == r.getLastCoalesceDate() &&\n               _currentTotalValue == r.getCurrentTotalValue() && _currentEventCount == r.getCurrentEventCount()\n               && _currentTotalEventTime == r.getCurrentTotalEventTime() && _lastTotalValue == r.getLastTotalValue()\n               && _lastEventCount == r.getLastEventCount() && _lastTotalEventTime == r.getLastTotalEventTime()\n               && _extremeTotalValue == r.getExtremeTotalValue() && _extremeEventCount == r.getExtremeEventCount()\n               && _extremeTotalEventTime == r.getExtremeTotalEventTime()\n               && _lifetimeTotalValue == r.getLifetimeTotalValue() && _lifetimeEventCount == r.getLifetimeEventCount()\n               && _lifetimeTotalEventTime == r.getLifetimeTotalEventTime();\n    }","id":79688,"modified_method":"/**\n     * This is used in StatSummarizer and SummaryListener.\n     * We base it on the stat we are tracking, not the stored data.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if ((obj == null) || !(obj instanceof Rate)) return false;\n        if (obj == this) return true;\n        Rate r = (Rate) obj;\n        return _period == r.getPeriod() && _creationDate == r.getCreationDate() &&\n               // do this the easy way to avoid NPEs.\n               // Alternative: compare name and group name (very carefully to avoid NPEs)\n               _stat == r._stat;\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean locked_renderPng(Rate rate, OutputStream out, int width, int height, boolean hideLegend,\n                                          boolean hideGrid, boolean hideTitle, boolean showEvents, int periodCount,\n                                          boolean showCredit) throws IOException {\n        if (width > GraphHelper.MAX_X)\n            width = GraphHelper.MAX_X;\n        else if (width <= 0)\n            width = GraphHelper.DEFAULT_X;\n        if (height > GraphHelper.MAX_Y)\n            height = GraphHelper.MAX_Y;\n        else if (height <= 0)\n            height = GraphHelper.DEFAULT_Y;\n        for (int i = 0; i < _listeners.size(); i++) {\n            SummaryListener lsnr = _listeners.get(i);\n            if (lsnr.getRate().equals(rate)) {\n                lsnr.renderPng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount, showCredit);\n                return true;\n            }\n        }\n        return false;\n    }","id":79689,"modified_method":"private boolean locked_renderPng(Rate rate, OutputStream out, int width, int height, boolean hideLegend,\n                                          boolean hideGrid, boolean hideTitle, boolean showEvents, int periodCount,\n                                          boolean showCredit) throws IOException {\n        if (width > GraphHelper.MAX_X)\n            width = GraphHelper.MAX_X;\n        else if (width <= 0)\n            width = GraphHelper.DEFAULT_X;\n        if (height > GraphHelper.MAX_Y)\n            height = GraphHelper.MAX_Y;\n        else if (height <= 0)\n            height = GraphHelper.DEFAULT_Y;\n        for (SummaryListener lsnr : _listeners) {\n            if (lsnr.getRate().equals(rate)) {\n                lsnr.renderPng(out, width, height, hideLegend, hideGrid, hideTitle, showEvents, periodCount, showCredit);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean locked_getXML(Rate rate, OutputStream out) throws IOException {\n        for (int i = 0; i < _listeners.size(); i++) {\n            SummaryListener lsnr = _listeners.get(i);\n            if (lsnr.getRate().equals(rate)) {\n                lsnr.getData().exportXml(out);\n                out.write((\"<!-- Rate: \" + lsnr.getRate().getRateStat().getName() + \" for period \" + lsnr.getRate().getPeriod() + \" -->\\n\").getBytes());\n                out.write((\"<!-- Average data soure name: \" + lsnr.getName() + \" event count data source name: \" + lsnr.getEventName() + \" -->\\n\").getBytes());\n                return true;\n            }\n        }\n        return false;\n    }","id":79690,"modified_method":"private boolean locked_getXML(Rate rate, OutputStream out) throws IOException {\n        for (SummaryListener lsnr : _listeners) {\n            if (lsnr.getRate().equals(rate)) {\n                lsnr.getData().exportXml(out);\n                out.write((\"<!-- Rate: \" + lsnr.getRate().getRateStat().getName() + \" for period \" + lsnr.getRate().getPeriod() + \" -->\\n\").getBytes());\n                out.write((\"<!-- Average data soure name: \" + lsnr.getName() + \" event count data source name: \" + lsnr.getEventName() + \" -->\\n\").getBytes());\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void removeDb(Rate r) {\n        for (int i = 0; i < _listeners.size(); i++) {\n            SummaryListener lsnr = _listeners.get(i);\n            if (lsnr.getRate().equals(r)) {\n                _listeners.remove(i);\n                lsnr.stopListening();\n                return;\n            }\n        }\n    }","id":79691,"modified_method":"private void removeDb(Rate r) {\n        for (SummaryListener lsnr : _listeners) {\n            if (lsnr.getRate().equals(r)) {\n                // no iter.remove() in COWAL\n                _listeners.remove(lsnr);\n                lsnr.stopListening();\n                return;\n            }\n        }\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n        _thread = Thread.currentThread();\n        String specs = \"\";\n        while (_isRunning && _context.router().isAlive()) {\n            specs = adjustDatabases(specs);\n            try { Thread.sleep(60*1000); } catch (InterruptedException ie) {}\n        }\n    }","id":79692,"modified_method":"public void run() {\n        boolean isPersistent = _context.getBooleanPropertyDefaultTrue(SummaryListener.PROP_PERSISTENT);\n        if (!isPersistent)\n            deleteOldRRDs();\n        _thread = Thread.currentThread();\n        String specs = \"\";\n        while (_isRunning && _context.router().isAlive()) {\n            specs = adjustDatabases(specs);\n            try { Thread.sleep(60*1000); } catch (InterruptedException ie) {}\n        }\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public SummaryListener(Rate r) {\n        _context = I2PAppContext.getGlobalContext();\n        _rate = r;\n        _log = _context.logManager().getLog(SummaryListener.class);\n        _isPersistent = _context.getBooleanProperty(PROP_PERSISTENT);\n    }","id":79693,"modified_method":"public SummaryListener(Rate r) {\n        _context = I2PAppContext.getGlobalContext();\n        _rate = r;\n        _log = _context.logManager().getLog(SummaryListener.class);\n        _isPersistent = _context.getBooleanPropertyDefaultTrue(PROP_PERSISTENT);\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void render(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid, boolean hideTitle, boolean showEvents, int periodCount, boolean showCredit) throws IOException {\n        long end = _listener.now() - 60*1000;\n        if (periodCount <= 0 || periodCount > _listener.getRows())\n            periodCount = _listener.getRows();\n        long start = end - _listener.getRate().getPeriod()*periodCount;\n        //long begin = System.currentTimeMillis();\n        try {\n            RrdGraphDef def = new RrdGraphDef();\n            def.setTimeSpan(start/1000, end/1000);\n            def.setMinValue(0d);\n            String name = _listener.getRate().getRateStat().getName();\n            // heuristic to set K=1024\n            if ((name.startsWith(\"bw.\") || name.indexOf(\"Size\") >= 0 || name.indexOf(\"Bps\") >= 0 || name.indexOf(\"memory\") >= 0)\n                && !showEvents)\n                def.setBase(1024);\n            if (!hideTitle) {\n                String title;\n                String p;\n                // we want the formatting and translation of formatDuration2(), except not zh, and not the &nbsp;\n                if (\"zh\".equals(Messages.getLanguage(_context)))\n                    p = DataHelper.formatDuration(_listener.getRate().getPeriod());\n                else\n                    p = DataHelper.formatDuration2(_listener.getRate().getPeriod()).replace(\"&nbsp;\", \" \");\n                if (showEvents)\n                    // Note to translators: all runtime zh translation disabled in this file, no font available in RRD\n                    title = name + ' ' + _(\"events in {0}\", p);\n                else\n                    title = name + ' ' + _(\"averaged for {0}\", p);\n                def.setTitle(title);\n            }\n            String path = _listener.getData().getPath();\n            String dsNames[] = _listener.getData().getDsNames();\n            String plotName = null;\n            String descr = null;\n            if (showEvents) {\n                // include the average event count on the plot\n                plotName = dsNames[1];\n                descr = _(\"Events per period\");\n            } else {\n                // include the average value\n                plotName = dsNames[0];\n                // The descriptions are not tagged in the createRateStat calls\n                // (there are over 500 of them)\n                // but the descriptions for the default graphs are tagged in\n                // Strings.java\n                descr = _(_listener.getRate().getRateStat().getDescription());\n            }\n            long started = ((RouterContext)_context).router().getWhenStarted();\n            if (started > start && started < end)\n                def.vrule(started / 1000, Color.BLACK, _(\"Restart\"), 4.0f);\n            def.datasource(plotName, path, plotName, SummaryListener.CF, _listener.getBackendName());\n            def.area(plotName, Color.BLUE, descr + \"\\\\r\");\n            if (!hideLegend) {\n                def.gprint(plotName, SummaryListener.CF, _(\"avg\") + \": %.2f %s\");\n                def.gprint(plotName, \"MAX\", ' ' + _(\"max\") + \": %.2f %S\");\n                def.gprint(plotName, \"LAST\", ' ' + _(\"now\") + \": %.2f %S\\\\r\");\n            }\n            if (!showCredit)\n                def.setShowSignature(false);\n            /*\n            // these four lines set up a graph plotting both values and events on the same chart\n            // (but with the same coordinates, so the values may look pretty skewed)\n                def.datasource(dsNames[0], path, dsNames[0], \"AVERAGE\", \"MEMORY\");\n                def.datasource(dsNames[1], path, dsNames[1], \"AVERAGE\", \"MEMORY\");\n                def.area(dsNames[0], Color.BLUE, _listener.getRate().getRateStat().getDescription());\n                def.line(dsNames[1], Color.RED, \"Events per period\");\n            */\n            if (hideLegend) \n                def.setNoLegend(true);\n            if (hideGrid) {\n                def.setDrawXGrid(false);\n                def.setDrawYGrid(false);\n            }\n            //System.out.println(\"rendering: path=\" + path + \" dsNames[0]=\" + dsNames[0] + \" dsNames[1]=\" + dsNames[1] + \" lsnr.getName=\" + _listener.getName());\n            def.setAntiAliasing(false);\n            //System.out.println(\"Rendering: \\n\" + def.exportXmlTemplate());\n            //System.out.println(\"*****************\\nData: \\n\" + _listener.getData().dump());\n            def.setWidth(width);\n            def.setHeight(height);\n\n            RrdGraph graph = new RrdGraph(def);\n            int totalWidth = graph.getRrdGraphInfo().getWidth();\n            int totalHeight = graph.getRrdGraphInfo().getHeight();\n            BufferedImage img = new BufferedImage(totalWidth, totalHeight, BufferedImage.TYPE_USHORT_565_RGB);\n            Graphics gfx = img.getGraphics();\n            graph.render(gfx);\n            ImageOutputStream ios = new MemoryCacheImageOutputStream(out);\n            ImageIO.write(img, \"png\", ios);\n            //System.out.println(\"Graph created\");\n\n            //File t = File.createTempFile(\"jrobinData\", \".xml\");\n            //_listener.getData().dumpXml(new FileOutputStream(t));\n            //System.out.println(\"plotted: \" + (data != null ? data.length : 0) + \" bytes in \" + timeToPlot\n            //                   ); // + \", data written to \" + t.getAbsolutePath());\n        } catch (RrdException re) {\n            _log.error(\"Error rendering\", re);\n            throw new IOException(\"Error plotting: \" + re.getMessage());\n        } catch (IOException ioe) {\n            _log.error(\"Error rendering\", ioe);\n            throw ioe;\n        } catch (OutOfMemoryError oom) {\n            _log.error(\"Error rendering\", oom);\n            throw new IOException(\"Error plotting: \" + oom.getMessage());\n        }\n    }","id":79694,"modified_method":"public void render(OutputStream out, int width, int height, boolean hideLegend, boolean hideGrid, boolean hideTitle, boolean showEvents, int periodCount, boolean showCredit) throws IOException {\n        long end = _listener.now() - 60*1000;\n        if (periodCount <= 0 || periodCount > _listener.getRows())\n            periodCount = _listener.getRows();\n        long start = end - _listener.getRate().getPeriod()*periodCount;\n        //long begin = System.currentTimeMillis();\n        try {\n            RrdGraphDef def = new RrdGraphDef();\n            def.setTimeSpan(start/1000, end/1000);\n            def.setMinValue(0d);\n            String name = _listener.getRate().getRateStat().getName();\n            // heuristic to set K=1024\n            if ((name.startsWith(\"bw.\") || name.indexOf(\"Size\") >= 0 || name.indexOf(\"Bps\") >= 0 || name.indexOf(\"memory\") >= 0)\n                && !showEvents)\n                def.setBase(1024);\n            if (!hideTitle) {\n                String title;\n                String p;\n                // we want the formatting and translation of formatDuration2(), except not zh, and not the &nbsp;\n                //if (\"zh\".equals(Messages.getLanguage(_context)))\n                //    p = DataHelper.formatDuration(_listener.getRate().getPeriod());\n                //else\n                    p = DataHelper.formatDuration2(_listener.getRate().getPeriod()).replace(\"&nbsp;\", \" \");\n                if (showEvents)\n                    title = name + ' ' + _(\"events in {0}\", p);\n                else\n                    title = name + ' ' + _(\"averaged for {0}\", p);\n                def.setTitle(title);\n            }\n            String path = _listener.getData().getPath();\n            String dsNames[] = _listener.getData().getDsNames();\n            String plotName = null;\n            String descr = null;\n            if (showEvents) {\n                // include the average event count on the plot\n                plotName = dsNames[1];\n                descr = _(\"Events per period\");\n            } else {\n                // include the average value\n                plotName = dsNames[0];\n                // The descriptions are not tagged in the createRateStat calls\n                // (there are over 500 of them)\n                // but the descriptions for the default graphs are tagged in\n                // Strings.java\n                descr = _(_listener.getRate().getRateStat().getDescription());\n            }\n            long started = ((RouterContext)_context).router().getWhenStarted();\n            if (started > start && started < end)\n                def.vrule(started / 1000, Color.BLACK, _(\"Restart\"), 4.0f);\n            def.datasource(plotName, path, plotName, SummaryListener.CF, _listener.getBackendName());\n            if (descr.length() > 0)\n                def.area(plotName, Color.BLUE, descr + \"\\\\r\");\n            else\n                def.area(plotName, Color.BLUE);\n            if (!hideLegend) {\n                def.gprint(plotName, SummaryListener.CF, _(\"avg\") + \": %.2f %s\");\n                def.gprint(plotName, \"MAX\", ' ' + _(\"max\") + \": %.2f %S\");\n                def.gprint(plotName, \"LAST\", ' ' + _(\"now\") + \": %.2f %S\\\\r\");\n            }\n            if (!showCredit)\n                def.setShowSignature(false);\n            /*\n            // these four lines set up a graph plotting both values and events on the same chart\n            // (but with the same coordinates, so the values may look pretty skewed)\n                def.datasource(dsNames[0], path, dsNames[0], \"AVERAGE\", \"MEMORY\");\n                def.datasource(dsNames[1], path, dsNames[1], \"AVERAGE\", \"MEMORY\");\n                def.area(dsNames[0], Color.BLUE, _listener.getRate().getRateStat().getDescription());\n                def.line(dsNames[1], Color.RED, \"Events per period\");\n            */\n            if (hideLegend) \n                def.setNoLegend(true);\n            if (hideGrid) {\n                def.setDrawXGrid(false);\n                def.setDrawYGrid(false);\n            }\n            //System.out.println(\"rendering: path=\" + path + \" dsNames[0]=\" + dsNames[0] + \" dsNames[1]=\" + dsNames[1] + \" lsnr.getName=\" + _listener.getName());\n            def.setAntiAliasing(false);\n            //System.out.println(\"Rendering: \\n\" + def.exportXmlTemplate());\n            //System.out.println(\"*****************\\nData: \\n\" + _listener.getData().dump());\n            def.setWidth(width);\n            def.setHeight(height);\n\n            RrdGraph graph = new RrdGraph(def);\n            int totalWidth = graph.getRrdGraphInfo().getWidth();\n            int totalHeight = graph.getRrdGraphInfo().getHeight();\n            BufferedImage img = new BufferedImage(totalWidth, totalHeight, BufferedImage.TYPE_USHORT_565_RGB);\n            Graphics gfx = img.getGraphics();\n            graph.render(gfx);\n            ImageOutputStream ios = new MemoryCacheImageOutputStream(out);\n            ImageIO.write(img, \"png\", ios);\n            //System.out.println(\"Graph created\");\n\n            //File t = File.createTempFile(\"jrobinData\", \".xml\");\n            //_listener.getData().dumpXml(new FileOutputStream(t));\n            //System.out.println(\"plotted: \" + (data != null ? data.length : 0) + \" bytes in \" + timeToPlot\n            //                   ); // + \", data written to \" + t.getAbsolutePath());\n        } catch (RrdException re) {\n            _log.error(\"Error rendering\", re);\n            throw new IOException(\"Error plotting: \" + re.getMessage());\n        } catch (IOException ioe) {\n            _log.error(\"Error rendering\", ioe);\n            throw ioe;\n        } catch (OutOfMemoryError oom) {\n            _log.error(\"Error rendering\", oom);\n            throw new IOException(\"Error plotting: \" + oom.getMessage());\n        }\n    }","commit_id":"cf0d2197b808c79ac0c936c3bb6941c53bcbcbfa","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void addCapabilities(RouterInfo ri) {\n        int bwLim = Math.min(_context.bandwidthLimiter().getInboundKBytesPerSecond(),\n                             _context.bandwidthLimiter().getOutboundKBytesPerSecond());\n        bwLim = (int)(((float)bwLim) * getSharePercentage());\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Adding capabilities w/ bw limit @ \" + bwLim, new Exception(\"caps\"));\n        \n        String force = _context.getProperty(PROP_FORCE_BWCLASS);\n        if (force != null && force.length() > 0) {\n            ri.addCapability(force.charAt(0));\n        } else if (bwLim < 12) {\n            ri.addCapability(CAPABILITY_BW12);\n        } else if (bwLim <= 32) {\n            ri.addCapability(CAPABILITY_BW32);\n        } else if (bwLim <= 64) {\n            ri.addCapability(CAPABILITY_BW64);\n        } else if (bwLim <= 128) {\n            ri.addCapability(CAPABILITY_BW128);\n        } else { // ok, more than 128KBps... aka \"lots\"\n            ri.addCapability(CAPABILITY_BW256);\n        }\n        \n        // if prop set to true, don't tell people we are ff even if we are\n        if (FloodfillNetworkDatabaseFacade.floodfillEnabled(_context) &&\n            !Boolean.valueOf(_context.getProperty(\"router.hideFloodfillParticipant\")).booleanValue())\n            ri.addCapability(FloodfillNetworkDatabaseFacade.CAPABILITY_FLOODFILL);\n        \n        if(Boolean.valueOf(_context.getProperty(PROP_HIDDEN)).booleanValue())\n            ri.addCapability(RouterInfo.CAPABILITY_HIDDEN);\n        \n        if (Boolean.valueOf(_context.getProperty(PROP_FORCE_UNREACHABLE)).booleanValue()) {\n            ri.addCapability(CAPABILITY_UNREACHABLE);\n            return;\n        }\n        switch (_context.commSystem().getReachabilityStatus()) {\n            case CommSystemFacade.STATUS_OK:\n                ri.addCapability(CAPABILITY_REACHABLE);\n                break;\n            case CommSystemFacade.STATUS_DIFFERENT:\n            case CommSystemFacade.STATUS_REJECT_UNSOLICITED:\n                ri.addCapability(CAPABILITY_UNREACHABLE);\n                break;\n            case CommSystemFacade.STATUS_UNKNOWN:\n                // no explicit capability\n                break;\n        }\n    }","id":79695,"modified_method":"public void addCapabilities(RouterInfo ri) {\n        int bwLim = Math.min(_context.bandwidthLimiter().getInboundKBytesPerSecond(),\n                             _context.bandwidthLimiter().getOutboundKBytesPerSecond());\n        bwLim = (int)(((float)bwLim) * getSharePercentage());\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Adding capabilities w/ bw limit @ \" + bwLim, new Exception(\"caps\"));\n        \n        String force = _context.getProperty(PROP_FORCE_BWCLASS);\n        if (force != null && force.length() > 0) {\n            ri.addCapability(force.charAt(0));\n        } else if (bwLim < 12) {\n            ri.addCapability(CAPABILITY_BW12);\n        } else if (bwLim <= 32) {\n            ri.addCapability(CAPABILITY_BW32);\n        } else if (bwLim <= 64) {\n            ri.addCapability(CAPABILITY_BW64);\n        } else if (bwLim <= 128) {\n            ri.addCapability(CAPABILITY_BW128);\n        } else { // ok, more than 128KBps... aka \"lots\"\n            ri.addCapability(CAPABILITY_BW256);\n        }\n        \n        // if prop set to true, don't tell people we are ff even if we are\n        if (FloodfillNetworkDatabaseFacade.floodfillEnabled(_context) &&\n            !_context.getBooleanProperty(\"router.hideFloodfillParticipant\"))\n            ri.addCapability(FloodfillNetworkDatabaseFacade.CAPABILITY_FLOODFILL);\n        \n        if(_context.getBooleanProperty(PROP_HIDDEN))\n            ri.addCapability(RouterInfo.CAPABILITY_HIDDEN);\n        \n        if (_context.getBooleanProperty(PROP_FORCE_UNREACHABLE)) {\n            ri.addCapability(CAPABILITY_UNREACHABLE);\n            return;\n        }\n        switch (_context.commSystem().getReachabilityStatus()) {\n            case CommSystemFacade.STATUS_OK:\n                ri.addCapability(CAPABILITY_REACHABLE);\n                break;\n            case CommSystemFacade.STATUS_DIFFERENT:\n            case CommSystemFacade.STATUS_REJECT_UNSOLICITED:\n                ri.addCapability(CAPABILITY_UNREACHABLE);\n                break;\n            case CommSystemFacade.STATUS_UNKNOWN:\n                // no explicit capability\n                break;\n        }\n    }","commit_id":"cdb6313c338002513ba65ff23e15a7bf9a9790b8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public boolean isHidden() {\n        RouterInfo ri = _routerInfo;\n        if ( (ri != null) && (ri.isHidden()) )\n            return true;\n        return Boolean.valueOf(_context.getProperty(PROP_HIDDEN_HIDDEN)).booleanValue();\n    }","id":79696,"modified_method":"public boolean isHidden() {\n        RouterInfo ri = _routerInfo;\n        if ( (ri != null) && (ri.isHidden()) )\n            return true;\n        return _context.getBooleanProperty(PROP_HIDDEN_HIDDEN);\n    }","commit_id":"cdb6313c338002513ba65ff23e15a7bf9a9790b8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public ProblemDescriptorImpl(PsiElement startElement, PsiElement endElement, String descriptionTemplate, LocalQuickFix[] fixes,\n                               ProblemHighlightType highlightType, boolean isAfterEndOfLine, final TextRange rangeInElement) {\n    super(fixes, descriptionTemplate);\n    LOG.assertTrue(startElement.isValid(), \"Invalid PsiElement\");\n    LOG.assertTrue(startElement.isPhysical(), \"Non-physical PsiElement. Physical element is required to be able to anchor the problem in the source tree\");\n    LOG.assertTrue(endElement.isValid(), \"Invalid PsiElement\");\n    LOG.assertTrue(endElement.isPhysical(), \"Non-physical PsiElement. Physical element is required to be able to anchor the problem in the source tree\");\n\n    if (startElement.getTextRange().getStartOffset() >= endElement.getTextRange().getEndOffset()) {\n      LOG.error(\"Empty PSI elements should not be passed to createDescriptor\");\n    }\n\n    myHighlightType = highlightType;\n    final Project project = startElement.getProject();\n    myStartSmartPointer = SmartPointerManager.getInstance(project).createLazyPointer(startElement);\n    myEndSmartPointer = startElement == endElement ? null : SmartPointerManager.getInstance(project).createLazyPointer(endElement);\n\n    myAfterEndOfLine = isAfterEndOfLine;\n    myTextRangeInElement = rangeInElement;\n  }","id":79697,"modified_method":"public ProblemDescriptorImpl(PsiElement startElement, PsiElement endElement, String descriptionTemplate, LocalQuickFix[] fixes,\n                               ProblemHighlightType highlightType, boolean isAfterEndOfLine, final TextRange rangeInElement) {\n    super(fixes, descriptionTemplate);\n    LOG.assertTrue(startElement.isValid(), \"Invalid PsiElement\");\n    LOG.assertTrue(startElement.isPhysical(), \"Non-physical PsiElement. Physical element is required to be able to anchor the problem in the source tree\");\n    LOG.assertTrue(endElement.isValid(), \"Invalid PsiElement\");\n    LOG.assertTrue(endElement.isPhysical(), \"Non-physical PsiElement. Physical element is required to be able to anchor the problem in the source tree\");\n\n    if (startElement.getTextRange().getStartOffset() >= endElement.getTextRange().getEndOffset() && rangeInElement.getStartOffset() >= rangeInElement.getEndOffset()) {\n      LOG.error(\"Empty PSI elements should not be passed to createDescriptor\");\n    }\n\n    myHighlightType = highlightType;\n    final Project project = startElement.getProject();\n    myStartSmartPointer = SmartPointerManager.getInstance(project).createLazyPointer(startElement);\n    myEndSmartPointer = startElement == endElement ? null : SmartPointerManager.getInstance(project).createLazyPointer(endElement);\n\n    myAfterEndOfLine = isAfterEndOfLine;\n    myTextRangeInElement = rangeInElement;\n  }","commit_id":"b315f90f97beb7dc6886d3c292d8906f75158b8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextRange getRangeInElement(final XmlAttributeValue xmlAttributeValue) {\n    return new TextRange(1, xmlAttributeValue.getTextLength() - 1);\n  }","id":79698,"modified_method":"public TextRange getRangeInElement(final XmlAttributeValue xmlAttributeValue) {\n    final int textLength = xmlAttributeValue.getTextLength();\n    return textLength == 0 ? new TextRange(0, 0) : new TextRange(1, textLength - 1);\n  }","commit_id":"b315f90f97beb7dc6886d3c292d8906f75158b8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    // inject only in non-template languages, because otherwise we can get conflict with other templating mechanisms (e.g. Handlebars)\n    if (context.getContainingFile().getViewProvider() instanceof MultiplePsiFilesPerDocumentFileViewProvider) return;\n\n    // check that we have angular directives indexed before injecting\n    final Project project = context.getProject();\n    if (!AngularIndexUtil.hasAngularJS(project)) return;\n\n    final PsiElement parent = context.getParent();\n    if (context instanceof XmlAttributeValueImpl && parent instanceof XmlAttribute) {\n      if (AngularAttributesRegistry.isAngularExpressionAttribute((XmlAttribute)parent)) {\n        registrar.startInjecting(AngularJSLanguage.INSTANCE).\n          addPlace(null, null, (PsiLanguageInjectionHost)context, new TextRange(1, context.getTextLength() - 1)).\n          doneInjecting();\n        return;\n      }\n    }\n\n    if (context instanceof XmlTextImpl || context instanceof XmlAttributeValueImpl) {\n      final String text = context.getText();\n      int startIndex;\n      int endIndex = -1;\n      do {\n        startIndex = text.indexOf(AngularJSBracesUtil.getInjectionStart(project), endIndex);\n        endIndex = startIndex >= 0 ? text.indexOf(AngularJSBracesUtil.getInjectionEnd(project), startIndex) : -1;\n        endIndex = endIndex > 0 ? endIndex : text.length();\n        final PsiElement injectionCandidate = startIndex >= 0 ? context.findElementAt(startIndex) : null;\n        if (injectionCandidate != null && injectionCandidate.getNode().getElementType() != XmlTokenType.XML_COMMENT_CHARACTERS) {\n          registrar.startInjecting(AngularJSLanguage.INSTANCE).\n                    addPlace(null, null, (PsiLanguageInjectionHost)context, new TextRange(startIndex + 2, endIndex)).\n                    doneInjecting();\n        }\n      } while (startIndex >= 0);\n    }\n  }","id":79699,"modified_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    // inject only in non-template languages, because otherwise we can get conflict with other templating mechanisms (e.g. Handlebars)\n    if (context.getContainingFile().getViewProvider() instanceof MultiplePsiFilesPerDocumentFileViewProvider) return;\n\n    // check that we have angular directives indexed before injecting\n    final Project project = context.getProject();\n    if (!AngularIndexUtil.hasAngularJS(project)) return;\n\n    final PsiElement parent = context.getParent();\n    if (context instanceof XmlAttributeValueImpl && parent instanceof XmlAttribute) {\n      final int length = context.getTextLength();\n      if (AngularAttributesRegistry.isAngularExpressionAttribute((XmlAttribute)parent) && length > 1) {\n        registrar.startInjecting(AngularJSLanguage.INSTANCE).\n          addPlace(null, null, (PsiLanguageInjectionHost)context, new TextRange(1, length - 1)).\n          doneInjecting();\n        return;\n      }\n    }\n\n    if (context instanceof XmlTextImpl || context instanceof XmlAttributeValueImpl) {\n      final String text = context.getText();\n      int startIndex;\n      int endIndex = -1;\n      do {\n        startIndex = text.indexOf(AngularJSBracesUtil.getInjectionStart(project), endIndex);\n        endIndex = startIndex >= 0 ? text.indexOf(AngularJSBracesUtil.getInjectionEnd(project), startIndex) : -1;\n        endIndex = endIndex > 0 ? endIndex : text.length();\n        final PsiElement injectionCandidate = startIndex >= 0 ? context.findElementAt(startIndex) : null;\n        if (injectionCandidate != null && injectionCandidate.getNode().getElementType() != XmlTokenType.XML_COMMENT_CHARACTERS) {\n          registrar.startInjecting(AngularJSLanguage.INSTANCE).\n                    addPlace(null, null, (PsiLanguageInjectionHost)context, new TextRange(startIndex + 2, endIndex)).\n                    doneInjecting();\n        }\n      } while (startIndex >= 0);\n    }\n  }","commit_id":"18fd2ee2539f5a2c90617612fb75242e6805b4c4","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void injectWholeXmlAttributeValue() {\n    final TextRange range = new TextRange(1, element.getTextLength() - 1);\n    registrar.startInjecting(OgnlLanguage.INSTANCE)\n             .addPlace(addPrefixSuffix ? OgnlLanguage.EXPRESSION_PREFIX : null,\n                       addPrefixSuffix ? OgnlLanguage.EXPRESSION_SUFFIX : null,\n                       element,\n                       range)\n             .doneInjecting();\n  }","id":79700,"modified_method":"private void injectWholeXmlAttributeValue() {\n    final int textLength = element.getTextLength();\n    if (textLength < 2) {\n      return;\n    }\n\n    final TextRange range = new TextRange(1, textLength - 1);\n    registrar.startInjecting(OgnlLanguage.INSTANCE)\n             .addPlace(addPrefixSuffix ? OgnlLanguage.EXPRESSION_PREFIX : null,\n                       addPrefixSuffix ? OgnlLanguage.EXPRESSION_SUFFIX : null,\n                       element,\n                       range)\n             .doneInjecting();\n  }","commit_id":"4ad7738567e61a7ca6126be590644ba3383f3400","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected TextRange createTextRange() {\n    if (myGenericValue instanceof GenericAttributeValue) {\n      return new TextRange(1, ((GenericAttributeValue)myGenericValue).getXmlAttributeValue().getTextLength() - 1);\n    }\n    final XmlTag tag = myGenericValue.getXmlTag();\n    assert tag != null;\n    XmlTagValue tagValue = tag.getValue();\n    final String text = tagValue.getText();\n    final String trimmed = text.trim();\n    final int index = text.indexOf(trimmed);\n    final int startOffset = tagValue.getTextRange().getStartOffset() - tag.getTextRange().getStartOffset() + index;\n    return new TextRange(startOffset, startOffset + trimmed.length());\n  }","id":79701,"modified_method":"protected TextRange createTextRange() {\n    if (myGenericValue instanceof GenericAttributeValue) {\n      final int length = ((GenericAttributeValue)myGenericValue).getXmlAttributeValue().getTextLength();\n      return length < 2 ? TextRange.from(0, length) : new TextRange(1, length - 1);\n    }\n    final XmlTag tag = myGenericValue.getXmlTag();\n    assert tag != null;\n    XmlTagValue tagValue = tag.getValue();\n    final String text = tagValue.getText();\n    final String trimmed = text.trim();\n    final int index = text.indexOf(trimmed);\n    final int startOffset = tagValue.getTextRange().getStartOffset() - tag.getTextRange().getStartOffset() + index;\n    return new TextRange(startOffset, startOffset + trimmed.length());\n  }","commit_id":"dfc2f6144410fb94e2c5c0ba32b1bed22554b922","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Produce a page and/or a tool list doPage = true is best for the\n\t * tabs-based portal and for RSS - these think in terms of pages doPage =\n\t * false is best for the portlet-style - it unrolls all of the tools unless\n\t * a page is marked as a popup. If the page is a popup - it is left a page\n\t * and marked as such. restTools = true - generate resetting tool URLs.\n\t * \n\t * @see org.sakaiproject.portal.api.PortalSiteHelper#pageListToMap(javax.servlet.http.HttpServletRequest,\n\t *      boolean, org.sakaiproject.site.api.Site,\n\t *      org.sakaiproject.site.api.SitePage, java.lang.String,\n\t *      java.lang.String, boolean, boolean, boolean)\n\t */\n\tpublic Map pageListToMap(HttpServletRequest req, boolean loggedIn, Site site,\n\t\t\tSitePage page, String toolContextPath, String portalPrefix, boolean doPages,\n\t\t\tboolean resetTools, boolean includeSummary)\n\t{\n\n\t\tMap<String, Object> theMap = new HashMap<String, Object>();\n\n\t\tString pageUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)) + \"/page/\");\n\t\tString toolUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)));\n\t\tif (resetTools)\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool-reset/\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool/\";\n\t\t}\n\n\t\tString pagePopupUrl = Web.returnUrl(req, \"/page/\");\n\t\tboolean showHelp = ServerConfigurationService.getBoolean(\"display.help.menu\",\n\t\t\t\ttrue);\n\t\tString iconUrl = site.getIconUrlFull();\n\t\tboolean published = site.isPublished();\n\t\tString type = site.getType();\n\n\t\ttheMap.put(\"pageNavPublished\", Boolean.valueOf(published));\n\t\ttheMap.put(\"pageNavType\", type);\n\t\ttheMap.put(\"pageNavIconUrl\", iconUrl);\n\t\t// theMap.put(\"pageNavSitToolsHead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_toolshead\")));\n\n\t\t// order the pages based on their tools and the tool order for the\n\t\t// site type\n\t\t// List pages = site.getOrderedPages();\n\t\tList pages = getPermittedPagesInOrder(site);\n\n\t\tList<Map> l = new ArrayList<Map>();\n\n\t\tfor (Iterator i = pages.iterator(); i.hasNext();)\n\t\t{\n\n\t\t\tSitePage p = (SitePage) i.next();\n\t\t\t// check if current user has permission to see page\n\t\t\t// we will draw page button if it have permission to see at least\n\t\t\t// one tool on the page\n\t\t\tList pTools = p.getTools();\n\t\t\tToolConfiguration firstTool = null;\n\t\t\tif (pTools != null && pTools.size() > 0)\n\t\t\t{\n\t\t\t\tfirstTool = (ToolConfiguration) pTools.get(0);\n\t\t\t}\n\t\t\tString toolsOnPage = null;\n\n\t\t\tboolean current = (page != null && p.getId().equals(page.getId()) && !p\n\t\t\t\t\t.isPopUp());\n\t\t\tString alias = lookupPageToAlias(site, p);\n\t\t\tString pagerefUrl = pageUrl + Web.escapeUrl((alias != null)?alias:p.getId());\n\n\t\t\tif (doPages || p.isPopUp())\n\t\t\t{\n\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\tm.put(\"isPage\", Boolean.valueOf(true));\n\t\t\t\tm.put(\"current\", Boolean.valueOf(current));\n\t\t\t\tm.put(\"ispopup\", Boolean.valueOf(p.isPopUp()));\n\t\t\t\tm.put(\"pagePopupUrl\", pagePopupUrl);\n\t\t\t\tm.put(\"pageTitle\", Web.escapeHtml(p.getTitle()));\n\t\t\t\tm.put(\"jsPageTitle\", Web.escapeJavascript(p.getTitle()));\n\t\t\t\tm.put(\"pageId\", Web.escapeUrl(p.getId()));\n\t\t\t\tm.put(\"jsPageId\", Web.escapeJavascript(p.getId()));\n\t\t\t\tm.put(\"pageRefUrl\", pagerefUrl);\n\t\t\t\tif (toolsOnPage != null) m.put(\"toolsOnPage\", toolsOnPage);\n\t\t\t\tif (includeSummary) summarizePage(m, site, p);\n\t\t\t\tif (firstTool != null)\n\t\t\t\t{\n\t\t\t\t\tString menuClass = firstTool.getToolId();\n\t\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.put(\"menuClass\", \"icon-default-tool\");\n\t\t\t\t}\n\t\t\t\tm.put(\"pageProps\", createPageProps(p));\n\t\t\t\t// this is here to allow the tool reorder to work\n\t\t\t\tm.put(\"_sitePage\", p);\n\t\t\t\tl.add(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Loop through the tools again and Unroll the tools\n\t\t\tIterator iPt = pTools.iterator();\n\n\t\t\twhile (iPt.hasNext())\n\t\t\t{\n\t\t\t\tToolConfiguration placement = (ToolConfiguration) iPt.next();\n\n\t\t\t\tString toolrefUrl = toolUrl + Web.escapeUrl(placement.getId());\n\n\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\tm.put(\"isPage\", Boolean.valueOf(false));\n\t\t\t\tm.put(\"toolId\", Web.escapeUrl(placement.getId()));\n\t\t\t\tm.put(\"jsToolId\", Web.escapeJavascript(placement.getId()));\n\t\t\t\tm.put(\"toolRegistryId\", placement.getToolId());\n\t\t\t\tm.put(\"toolTitle\", Web.escapeHtml(placement.getTitle()));\n\t\t\t\tm.put(\"jsToolTitle\", Web.escapeJavascript(placement.getTitle()));\n\t\t\t\tm.put(\"toolrefUrl\", toolrefUrl);\n\t\t\t\tString menuClass = placement.getToolId();\n\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t// this is here to allow the tool reorder to work if requried.\n\t\t\t\tm.put(\"_placement\", placement);\n\t\t\t\tl.add(m);\n\t\t\t}\n\n\t\t}\n\t\tPageFilter pageFilter = portal.getPageFilter();\n\t\tif (pageFilter != null)\n\t\t{\n\t\t\tl = pageFilter.filterPlacements(l, site);\n\t\t}\n\n\t\ttheMap.put(\"pageNavTools\", l);\n\t\ttheMap.put(\"pageMaxIfSingle\", ServerConfigurationService.getBoolean(\n\t\t\t\t\"portal.experimental.maximizesinglepage\", false));\n\t\ttheMap.put(\"pageNavToolsCount\", Integer.valueOf(l.size()));\n\n\t\tString helpUrl = ServerConfigurationService.getHelpUrl(null);\n\t\ttheMap.put(\"pageNavShowHelp\", Boolean.valueOf(showHelp));\n\t\ttheMap.put(\"pageNavHelpUrl\", helpUrl);\n\t\ttheMap.put(\"helpMenuClass\", \"icon-sakai-help\");\n\t\ttheMap.put(\"subsiteClass\", \"icon-sakai-subsite\");\n\n\t\t// theMap.put(\"pageNavSitContentshead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_contentshead\")));\n\n\t\t// Handle Presense\n\t\tboolean showPresence = ServerConfigurationService.getBoolean(\n\t\t\t\t\"display.users.present\", true);\n\t\tString presenceUrl = Web.returnUrl(req, \"/presence/\"\n\t\t\t\t+ Web.escapeUrl(site.getId()));\n\n\t\t// theMap.put(\"pageNavSitPresenceTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presencetitle\")));\n\t\t// theMap.put(\"pageNavSitPresenceFrameTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presenceiframetit\")));\n\t\ttheMap.put(\"pageNavShowPresenceLoggedIn\", Boolean.valueOf(showPresence\n\t\t\t\t&& loggedIn));\n\t\ttheMap.put(\"pageNavPresenceUrl\", presenceUrl);\n\n\t\treturn theMap;\n\t}","id":79702,"modified_method":"/**\n\t * Produce a page and/or a tool list doPage = true is best for the\n\t * tabs-based portal and for RSS - these think in terms of pages doPage =\n\t * false is best for the portlet-style - it unrolls all of the tools unless\n\t * a page is marked as a popup. If the page is a popup - it is left a page\n\t * and marked as such. restTools = true - generate resetting tool URLs.\n\t * \n\t * @see org.sakaiproject.portal.api.PortalSiteHelper#pageListToMap(javax.servlet.http.HttpServletRequest,\n\t *      boolean, org.sakaiproject.site.api.Site,\n\t *      org.sakaiproject.site.api.SitePage, java.lang.String,\n\t *      java.lang.String, boolean, boolean, boolean)\n\t */\n\tpublic Map pageListToMap(HttpServletRequest req, boolean loggedIn, Site site,\n\t\t\tSitePage page, String toolContextPath, String portalPrefix, boolean doPages,\n\t\t\tboolean resetTools, boolean includeSummary)\n\t{\n\n\t\tMap<String, Object> theMap = new HashMap<String, Object>();\n\n\t\tString pageUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)) + \"/page/\");\n\t\tString toolUrl = Web.returnUrl(req, \"/\" + portalPrefix + \"/\"\n\t\t\t\t+ Web.escapeUrl(getSiteEffectiveId(site)));\n\t\tif (resetTools)\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool-reset/\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttoolUrl = toolUrl + \"/tool/\";\n\t\t}\n\n\t\tString pagePopupUrl = Web.returnUrl(req, \"/page/\");\n\t\tboolean showHelp = ServerConfigurationService.getBoolean(\"display.help.menu\",\n\t\t\t\ttrue);\n\t\tString iconUrl = site.getIconUrlFull();\n\t\tboolean published = site.isPublished();\n\t\tString type = site.getType();\n\n\t\ttheMap.put(\"pageNavPublished\", Boolean.valueOf(published));\n\t\ttheMap.put(\"pageNavType\", type);\n\t\ttheMap.put(\"pageNavIconUrl\", iconUrl);\n\t\t// theMap.put(\"pageNavSitToolsHead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_toolshead\")));\n\n\t\t// order the pages based on their tools and the tool order for the\n\t\t// site type\n\t\t// List pages = site.getOrderedPages();\n\t\tList pages = getPermittedPagesInOrder(site);\n\n\t\tList<Map> l = new ArrayList<Map>();\n\n\t\tfor (Iterator i = pages.iterator(); i.hasNext();)\n\t\t{\n\n\t\t\tSitePage p = (SitePage) i.next();\n\t\t\t// check if current user has permission to see page\n\t\t\t// we will draw page button if it have permission to see at least\n\t\t\t// one tool on the page\n\t\t\tList pTools = p.getTools();\n\t\t\tToolConfiguration firstTool = null;\n\t\t\tif (pTools != null && pTools.size() > 0)\n\t\t\t{\n\t\t\t\tfirstTool = (ToolConfiguration) pTools.get(0);\n\t\t\t}\n\t\t\tString toolsOnPage = null;\n\n\t\t\tboolean current = (page != null && p.getId().equals(page.getId()) && !p\n\t\t\t\t\t.isPopUp());\n\t\t\tString alias = lookupPageToAlias(site.getId(), p);\n\t\t\tString pagerefUrl = pageUrl + Web.escapeUrl((alias != null)?alias:p.getId());\n\n\t\t\tif (doPages || p.isPopUp())\n\t\t\t{\n\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\tm.put(\"isPage\", Boolean.valueOf(true));\n\t\t\t\tm.put(\"current\", Boolean.valueOf(current));\n\t\t\t\tm.put(\"ispopup\", Boolean.valueOf(p.isPopUp()));\n\t\t\t\tm.put(\"pagePopupUrl\", pagePopupUrl);\n\t\t\t\tm.put(\"pageTitle\", Web.escapeHtml(p.getTitle()));\n\t\t\t\tm.put(\"jsPageTitle\", Web.escapeJavascript(p.getTitle()));\n\t\t\t\tm.put(\"pageId\", Web.escapeUrl(p.getId()));\n\t\t\t\tm.put(\"jsPageId\", Web.escapeJavascript(p.getId()));\n\t\t\t\tm.put(\"pageRefUrl\", pagerefUrl);\n\t\t\t\tif (toolsOnPage != null) m.put(\"toolsOnPage\", toolsOnPage);\n\t\t\t\tif (includeSummary) summarizePage(m, site, p);\n\t\t\t\tif (firstTool != null)\n\t\t\t\t{\n\t\t\t\t\tString menuClass = firstTool.getToolId();\n\t\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.put(\"menuClass\", \"icon-default-tool\");\n\t\t\t\t}\n\t\t\t\tm.put(\"pageProps\", createPageProps(p));\n\t\t\t\t// this is here to allow the tool reorder to work\n\t\t\t\tm.put(\"_sitePage\", p);\n\t\t\t\tl.add(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Loop through the tools again and Unroll the tools\n\t\t\tIterator iPt = pTools.iterator();\n\n\t\t\twhile (iPt.hasNext())\n\t\t\t{\n\t\t\t\tToolConfiguration placement = (ToolConfiguration) iPt.next();\n\n\t\t\t\tString toolrefUrl = toolUrl + Web.escapeUrl(placement.getId());\n\n\t\t\t\tMap<String, Object> m = new HashMap<String, Object>();\n\t\t\t\tm.put(\"isPage\", Boolean.valueOf(false));\n\t\t\t\tm.put(\"toolId\", Web.escapeUrl(placement.getId()));\n\t\t\t\tm.put(\"jsToolId\", Web.escapeJavascript(placement.getId()));\n\t\t\t\tm.put(\"toolRegistryId\", placement.getToolId());\n\t\t\t\tm.put(\"toolTitle\", Web.escapeHtml(placement.getTitle()));\n\t\t\t\tm.put(\"jsToolTitle\", Web.escapeJavascript(placement.getTitle()));\n\t\t\t\tm.put(\"toolrefUrl\", toolrefUrl);\n\t\t\t\tString menuClass = placement.getToolId();\n\t\t\t\tmenuClass = \"icon-\" + menuClass.replace('.', '-');\n\t\t\t\tm.put(\"menuClass\", menuClass);\n\t\t\t\t// this is here to allow the tool reorder to work if requried.\n\t\t\t\tm.put(\"_placement\", placement);\n\t\t\t\tl.add(m);\n\t\t\t}\n\n\t\t}\n\t\tPageFilter pageFilter = portal.getPageFilter();\n\t\tif (pageFilter != null)\n\t\t{\n\t\t\tl = pageFilter.filterPlacements(l, site);\n\t\t}\n\n\t\ttheMap.put(\"pageNavTools\", l);\n\t\ttheMap.put(\"pageMaxIfSingle\", ServerConfigurationService.getBoolean(\n\t\t\t\t\"portal.experimental.maximizesinglepage\", false));\n\t\ttheMap.put(\"pageNavToolsCount\", Integer.valueOf(l.size()));\n\n\t\tString helpUrl = ServerConfigurationService.getHelpUrl(null);\n\t\ttheMap.put(\"pageNavShowHelp\", Boolean.valueOf(showHelp));\n\t\ttheMap.put(\"pageNavHelpUrl\", helpUrl);\n\t\ttheMap.put(\"helpMenuClass\", \"icon-sakai-help\");\n\t\ttheMap.put(\"subsiteClass\", \"icon-sakai-subsite\");\n\n\t\t// theMap.put(\"pageNavSitContentshead\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_contentshead\")));\n\n\t\t// Handle Presense\n\t\tboolean showPresence = ServerConfigurationService.getBoolean(\n\t\t\t\t\"display.users.present\", true);\n\t\tString presenceUrl = Web.returnUrl(req, \"/presence/\"\n\t\t\t\t+ Web.escapeUrl(site.getId()));\n\n\t\t// theMap.put(\"pageNavSitPresenceTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presencetitle\")));\n\t\t// theMap.put(\"pageNavSitPresenceFrameTitle\",\n\t\t// Web.escapeHtml(rb.getString(\"sit_presenceiframetit\")));\n\t\ttheMap.put(\"pageNavShowPresenceLoggedIn\", Boolean.valueOf(showPresence\n\t\t\t\t&& loggedIn));\n\t\ttheMap.put(\"pageNavPresenceUrl\", presenceUrl);\n\n\t\treturn theMap;\n\t}","commit_id":"dae759b492276527d152b4f2779c8f2c5f249b45","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Find the short alias.\n\t * @param alias\n\t * @return\n\t */\n\tprivate String parseAlias(String aliasId, Site site)\n\t{\n\t\tString prefix = PAGE_ALIAS+ site.getId()+ Entity.SEPARATOR;\n\t\tString alias = null;\n\t\tif (aliasId.startsWith(prefix))\n\t\t{\n\t\t\talias = aliasId.substring(prefix.length());\n\t\t}\n\t\treturn alias;\n\t}","id":79703,"modified_method":"/**\n\t * Find the short alias.\n\t * @param alias\n\t * @return\n\t */\n\tprivate String parseAlias(String aliasId, String siteId)\n\t{\n\t\tString prefix = PAGE_ALIAS+ siteId+ Entity.SEPARATOR;\n\t\tString alias = null;\n\t\tif (aliasId.startsWith(prefix))\n\t\t{\n\t\t\talias = aliasId.substring(prefix.length());\n\t\t}\n\t\treturn alias;\n\t}","commit_id":"dae759b492276527d152b4f2779c8f2c5f249b45","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String lookupPageToAlias(Site site, SitePage page)\n\t{\n\t\tString alias = null;\n\t\tList<Alias> aliases = AliasService.getAliases(page.getReference());\n\t\tif (aliases.size() > 0)\n\t\t{\t\n\t\t\tif (aliases.size() > 1 && log.isWarnEnabled())\n\t\t\t{\n\t\t\t\tlog.warn(\"More than one alias for: \"+site.getId()+ \":\"+ page.getId());\n\t\t\t\t// Sort on ID so it is consistent in the alias it uses.\n\t\t\t\tCollections.sort(aliases, getAliasComparator());\n\t\t\t}\n\t\t\talias = aliases.get(0).getId();\n\t\t\talias = parseAlias(alias, site);\n\t\t}\n\t\treturn alias;\n\t}","id":79704,"modified_method":"public String lookupPageToAlias(String siteId, SitePage page)\n\t{\n\t\tString alias = null;\n\t\tList<Alias> aliases = AliasService.getAliases(page.getReference());\n\t\tif (aliases.size() > 0)\n\t\t{\t\n\t\t\tif (aliases.size() > 1 && log.isWarnEnabled())\n\t\t\t{\n\t\t\t\tlog.warn(\"More than one alias for: \"+siteId+ \":\"+ page.getId());\n\t\t\t\t// Sort on ID so it is consistent in the alias it uses.\n\t\t\t\tCollections.sort(aliases, getAliasComparator());\n\t\t\t}\n\t\t\talias = aliases.get(0).getId();\n\t\t\talias = parseAlias(alias, siteId);\n\t\t}\n\t\treturn alias;\n\t}","commit_id":"dae759b492276527d152b4f2779c8f2c5f249b45","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String getPortalPageUrl(ToolConfiguration p)\n\t{\n\t\treturn \"/site/\" + p.getSiteId() + \"/page/\" + p.getPageId();\n\t}","id":79705,"modified_method":"public String getPortalPageUrl(ToolConfiguration p)\n\t{\n\t\tSitePage sitePage = p.getContainingPage();\n\t\tString page = getSiteHelper().lookupPageToAlias(p.getSiteId(), sitePage);\n\t\tif (page == null)\n\t\t{\n\t\t\t// Fall back to default of using the page Id.\n\t\t\tpage = p.getPageId();\n\t\t}\n\t\treturn \"/site/\" + p.getSiteId() + \"/page/\" + page;\n\t}","commit_id":"dae759b492276527d152b4f2779c8f2c5f249b45","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void rebuildIndex(Session session, SearchBuilderItem controlItem)\n\t\t\tthrows HibernateException\n\t{\n\t\t// delete all and return the master action only\n\t\t// the caller will then rebuild the index from scratch\n\t\tlog\n\t\t\t\t.debug(\"DELETE ALL RECORDS ==========================================================\");\n\t\tsession.flush();\n\t\ttry\n\t\t{\n\t\t\tif (SearchBuilderItem.GLOBAL_CONTEXT.equals(controlItem\n\t\t\t\t\t.getContext()))\n\t\t\t{\n\t\t\t\tsession.connection().createStatement().execute(\n\t\t\t\t\t\t\"delete from searchbuilderitem where name <> '\"\n\t\t\t\t\t\t\t\t+ SearchBuilderItem.GLOBAL_MASTER + \"' \");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsession.connection().createStatement().execute(\n\t\t\t\t\t\t\"delete from searchbuilderitem where context = '\"\n\t\t\t\t\t\t\t\t+ controlItem.getContext() + \"' and name <> '\"\n\t\t\t\t\t\t\t\t+ controlItem.getName() + \"' \");\n\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException e)\n\t\t{\n\t\t\tthrow new HibernateException(\"Failed to perform delete \", e);\n\t\t}\n\n\t\t// THIS DOES NOT WORK IN H 2.1 session.delete(\"from\n\t\t// \"+SearchBuilderItemImpl.class.getName());\n\t\tlog\n\t\t\t\t.debug(\"DONE DELETE ALL RECORDS ===========================================================\");\n\t\tlog\n\t\t\t\t.debug(\"ADD ALL RECORDS ===========================================================\");\n\t\tfor (Iterator i = searchIndexBuilder.getContentProducers().iterator(); i\n\t\t\t\t.hasNext();)\n\t\t{\n\t\t\tEntityContentProducer ecp = (EntityContentProducer) i.next();\n\t\t\tList contentList = null;\n\t\t\tif (SearchBuilderItem.GLOBAL_CONTEXT.equals(controlItem\n\t\t\t\t\t.getContext()))\n\t\t\t{\n\t\t\t\tcontentList = ecp.getAllContent();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontentList = ecp.getSiteContent(controlItem.getContext());\n\t\t\t}\n\t\t\tint added = 0;\n\t\t\tfor (Iterator ci = contentList.iterator(); ci.hasNext();)\n\t\t\t{\n\t\t\t\tString resourceName = (String) ci.next();\n\t\t\t\tList lx = session.createQuery(\n\t\t\t\t\t\t\" from \" + SearchBuilderItemImpl.class.getName()\n\t\t\t\t\t\t\t\t+ \" where name = ?  \").setParameter(0,\n\t\t\t\t\t\tresourceName, Hibernate.STRING).list();\n\t\t\t\tif (lx == null || lx.size() == 0)\n\t\t\t\t{\n\t\t\t\t\tadded++;\n\t\t\t\t\tSearchBuilderItem sbi = new SearchBuilderItemImpl();\n\t\t\t\t\tsbi.setName(resourceName);\n\t\t\t\t\tsbi.setSearchaction(SearchBuilderItem.ACTION_ADD);\n\t\t\t\t\tsbi.setSearchstate(SearchBuilderItem.STATE_PENDING);\n\t\t\t\t\tsbi.setContext(ecp.getSiteId(resourceName));\n\t\t\t\t\tsession.saveOrUpdate(sbi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.debug(\" Added \" + added);\n\t\t}\n\t\tlog\n\t\t\t\t.debug(\"DONE ADD ALL RECORDS ===========================================================\");\n\t\tcontrolItem.setSearchstate(SearchBuilderItem.STATE_COMPLETED);\n\t\tsession.saveOrUpdate(controlItem);\n\n\t}","id":79706,"modified_method":"private void rebuildIndex(Session session, SearchBuilderItem controlItem)\n\t\t\tthrows HibernateException\n\t{\n\t\t// delete all and return the master action only\n\t\t// the caller will then rebuild the index from scratch\n\t\tlog\n\t\t\t\t.debug(\"DELETE ALL RECORDS ==========================================================\");\n\t\tsession.flush();\n\t\ttry\n\t\t{\n\t\t\tif (SearchBuilderItem.GLOBAL_CONTEXT.equals(controlItem\n\t\t\t\t\t.getContext()))\n\t\t\t{\n\t\t\t\tsession.connection().createStatement().execute(\n\t\t\t\t\t\t\"delete from searchbuilderitem where name <> '\"\n\t\t\t\t\t\t\t\t+ SearchBuilderItem.GLOBAL_MASTER + \"' \");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsession.connection().createStatement().execute(\n\t\t\t\t\t\t\"delete from searchbuilderitem where context = '\"\n\t\t\t\t\t\t\t\t+ controlItem.getContext() + \"' and name <> '\"\n\t\t\t\t\t\t\t\t+ controlItem.getName() + \"' \");\n\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException e)\n\t\t{\n\t\t\tthrow new HibernateException(\"Failed to perform delete \", e);\n\t\t}\n\n\t\t// THIS DOES NOT WORK IN H 2.1 session.delete(\"from\n\t\t// \"+SearchBuilderItemImpl.class.getName());\n\t\tlog\n\t\t\t\t.debug(\"DONE DELETE ALL RECORDS ===========================================================\");\n\t\tlog\n\t\t\t\t.debug(\"ADD ALL RECORDS ===========================================================\");\n\t\tfor (Iterator i = searchIndexBuilder.getContentProducers().iterator(); i\n\t\t\t\t.hasNext();)\n\t\t{\n\t\t\tEntityContentProducer ecp = (EntityContentProducer) i.next();\n\t\t\tList contentList = null;\n\t\t\tif (SearchBuilderItem.GLOBAL_CONTEXT.equals(controlItem\n\t\t\t\t\t.getContext()))\n\t\t\t{\n\t\t\t\tcontentList = ecp.getAllContent();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontentList = ecp.getSiteContent(controlItem.getContext());\n\t\t\t}\n\t\t\tint added = 0;\n\t\t\tfor (Iterator ci = contentList.iterator(); ci.hasNext();)\n\t\t\t{\n\t\t\t\tString resourceName = (String) ci.next();\n\t\t\t\tList lx = session.createQuery(\n\t\t\t\t\t\t\" from \" + SearchBuilderItemImpl.class.getName()\n\t\t\t\t\t\t\t\t+ \" where name = ?  \").setParameter(0,\n\t\t\t\t\t\tresourceName, Hibernate.STRING).list();\n\t\t\t\tif (lx == null || lx.size() == 0)\n\t\t\t\t{\n\t\t\t\t\tadded++;\n\t\t\t\t\tSearchBuilderItem sbi = new SearchBuilderItemImpl();\n\t\t\t\t\tsbi.setName(resourceName);\n\t\t\t\t\tsbi.setSearchaction(SearchBuilderItem.ACTION_ADD);\n\t\t\t\t\tsbi.setSearchstate(SearchBuilderItem.STATE_PENDING);\n\t\t\t\t\tString context = ecp.getSiteId(resourceName);\n\t\t\t\t\tif ( context == null || context.length() == 0 ) {\n\t\t\t\t\t\tcontext = \"none\";\n\t\t\t\t\t}\n\t\t\t\t\tsbi.setContext(context);\n\t\t\t\t\tsession.saveOrUpdate(sbi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.debug(\" Added \" + added);\n\t\t}\n\t\tlog\n\t\t\t\t.debug(\"DONE ADD ALL RECORDS ===========================================================\");\n\t\tcontrolItem.setSearchstate(SearchBuilderItem.STATE_COMPLETED);\n\t\tsession.saveOrUpdate(controlItem);\n\n\t}","commit_id":"f7e33cc51582610b2edc3917fbb1ac3245b0d70d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List<DecoratedSynopticMsgcntrItem> getContents(){\n\t\t\n\t\t\n\t\t\n\t\tif(isMyWorkspace() && !isDisableMyWorkspace()){\n\t\t\tif(myContents != null){\n\t\t\t\treturn myContents;\n\t\t\t}\n\t\t\t\n\t\t\tperformance = getPerformance();\n\t\t\tuserRequestSynoptic = isUserRequestSynoptic();\n\t\t\t\t\n\t\t\tList<SynopticMsgcntrItem> synItems;\n\t\t\tmyContentsSize = -1;\n\t\t\tmyDisplayedSites = 0;\n\t\t\t//findWorkspaceSynopticMsgcntrItems\n\t\t\tsynItems = getSynopticMsgcntrManager().getWorkspaceSynopticMsgcntrItems(getCurrentUser());\n\t\t\t\n\t\t\t//Grab user's preferences for site order, and remove sites that user has removed\n\t\t\tPreferences prefs = PreferencesService.getPreferences(getCurrentUser());\n\t\t\tResourceProperties props = prefs.getProperties(CHARON_PREFS);\n\t\t\tList<String> orderedSites = props.getPropertyList(\"order\");\n\t\t\t\n\t\t\tList<String> excludedSites = props.getPropertyList(\"exclude\");\n\n\t\t\tif(excludedSites != null){\n\t\t\t\t//user has set preferences so filter out any missing sites:\n\t\t\t\tfor (Iterator iterator = synItems.iterator(); iterator\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tSynopticMsgcntrItem synItem = (SynopticMsgcntrItem) iterator.next();\n\t\t\t\t\tif(excludedSites.contains(synItem.getSiteId())){\n\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsynItems = sortSynopticMsgcntrList(synItems, orderedSites);\n\t\t\t\n\t\t\tmyContents = new ArrayList<DecoratedSynopticMsgcntrItem>();\n\n\t\t\tboolean isAdmin = SecurityService.isSuperUser();\n\n\t\t\tfor (SynopticMsgcntrItem synopticMsgcntrItem : synItems) {\n\t\t\t\ttry {\n\n\t\t\t\t\tif(isAdmin){\n\t\t\t\t\t\t//remove any extra sites that the admin may have picked up\n\t\t\t\t\t\tif(AuthzGroupService.getUserRole(SessionManager.getCurrentSessionUserId(), \"/site/\" + synopticMsgcntrItem.getSiteId()) == null){\n\t\t\t\t\t\t\t//admin is not a member, so delete this user\n\t\t\t\t\t\t\tgetSynopticMsgcntrManager().deleteSynopticMsgcntrItem(synopticMsgcntrItem);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!PERFORMANCE_2.equals(performance)){\n\t\t\t\t\t\t Site site;\n\t\t\t\t\t\t//only add if the site exists:\n\t\t\t\t\t\tsite = SiteService.getSite(synopticMsgcntrItem.getSiteId());\n\n\t\t\t\t\t\tif(!site.isPublished()){\n\t\t\t\t\t\t\t//remove this item since the site has been unpublished:\n\t\t\t\t\t\t\tgetSynopticMsgcntrManager().deleteSynopticMsgcntrItem(synopticMsgcntrItem);\n\t\t\t\t\t\t}else if(!SecurityService.unlock(synopticMsgcntrItem.getUserId(), SiteService.SITE_VISIT, \"/site/\" + site.getId())){\n\t\t\t\t\t\t\t//user is no longer a member of the site, remove synoptic info:\n\t\t\t\t\t\t\tgetSynopticMsgcntrManager().deleteSynopticMsgcntrItem(synopticMsgcntrItem);\n\t\t\t\t\t\t}else{\n\n\n\t\t\t\t\t\t\tDecoratedSynopticMsgcntrItem dSynopticItem = new DecoratedSynopticMsgcntrItem(synopticMsgcntrItem, site);\n\t\t\t\t\t\t\t//this covers the case when a tool had unread messages but then the tool was \n\t\t\t\t\t\t\t//removed from the site\n\t\t\t\t\t\t\tboolean isMessageForumsPageInSite = isMessageForumsPageInSite(site);\n\t\t\t\t\t\t\tif(!isDisableMessages() && !isMessageForumsPageInSite && !isMessagesPageInSite(site) && dSynopticItem.getNewMessagesCount() != 0){\n\t\t\t\t\t\t\t\t//update synoptic item since it the db is out of sync:\n\t\t\t\t\t\t\t\tgetSynopticMsgcntrManager()\n\t\t\t\t\t\t\t\t.resetMessagesAndForumSynopticInfo(\n\t\t\t\t\t\t\t\t\t\tsynopticMsgcntrItem.getUserId(),\n\t\t\t\t\t\t\t\t\t\tsynopticMsgcntrItem.getSiteId());\n\t\t\t\t\t\t\t}else if(!isDisableForums() && !isMessageForumsPageInSite && !isForumsPageInSite(site) && dSynopticItem.getNewForumCount() != 0){\n\t\t\t\t\t\t\t\t//update synoptic item since it the db is out of sync:\n\t\t\t\t\t\t\t\tgetSynopticMsgcntrManager()\n\t\t\t\t\t\t\t\t.resetMessagesAndForumSynopticInfo(\n\t\t\t\t\t\t\t\t\t\tsynopticMsgcntrItem.getUserId(),\n\t\t\t\t\t\t\t\t\t\tsynopticMsgcntrItem.getSiteId());\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//check if the site title has changed:\n\t\t\t\t\t\t\t\tif(dSynopticItem.getSynopticMsgcntrItem().getSiteTitle() != null && !dSynopticItem.getSynopticMsgcntrItem().getSiteTitle().equals(site.getTitle())){\n\t\t\t\t\t\t\t\t\t//update all site titles in table\n\t\t\t\t\t\t\t\t\tgetSynopticMsgcntrManager().updateAllSiteTitles(synopticMsgcntrItem.getSiteId(), site.getTitle());\n\t\t\t\t\t\t\t\t\t//set the current synoptic item's site title to the correct title\n\t\t\t\t\t\t\t\t\tdSynopticItem.getSynopticMsgcntrItem().setSiteTitle(site.getTitle());\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t//everything checks out, so add it to the list\n\t\t\t\t\t\t\t\tmyContents.add(dSynopticItem);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(!SecurityService.unlock(synopticMsgcntrItem.getUserId(), SiteService.SITE_VISIT, \"/site/\" + synopticMsgcntrItem.getSiteId())){\n\t\t\t\t\t\t\t//user is no longer a member of the site, remove synoptic info:\n\t\t\t\t\t\t\tgetSynopticMsgcntrManager().deleteSynopticMsgcntrItem(synopticMsgcntrItem);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tDecoratedSynopticMsgcntrItem dSynopticItem = new DecoratedSynopticMsgcntrItem(synopticMsgcntrItem, null);\n\t\t\t\t\t\t\tmyContents.add(dSynopticItem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IdUnusedException e) {\n\t\t\t\t\t//we not longer need this record so delete it\n\t\t\t\t\tgetSynopticMsgcntrManager().deleteSynopticMsgcntrItem(synopticMsgcntrItem);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tmyContentsSize = myContents.size();\n\t\t\tfor (Iterator iterator = myContents.iterator(); iterator.hasNext();) {\n\t\t\t\tDecoratedSynopticMsgcntrItem dSynopticMsgcntrItem = (DecoratedSynopticMsgcntrItem) iterator\n\t\t\t\t\t\t.next();\n\t\t\t\tif(!dSynopticMsgcntrItem.getSynopticMsgcntrItem().isHideItem())\n\t\t\t\t\tmyDisplayedSites++;\n\t\t\t}\n\t\t\t\n\t\t\treturn myContents;\n\t\t}else{\n\t\t\t//not workspace or workspace is disabled\n\t\t\treturn null;\n\t\t}\n\t}","id":79707,"modified_method":"public List<DecoratedSynopticMsgcntrItem> getContents(){\n\t\t\n\t\t\n\t\t\n\t\tif(isMyWorkspace() && !isDisableMyWorkspace()){\n\t\t\tif(myContents != null){\n\t\t\t\treturn myContents;\n\t\t\t}\n\t\t\t\n\t\t\tperformance = getPerformance();\n\t\t\tuserRequestSynoptic = isUserRequestSynoptic();\n\t\t\t\t\n\t\t\tList<SynopticMsgcntrItem> synItems;\n\t\t\tmyContentsSize = -1;\n\t\t\tmyDisplayedSites = 0;\n\t\t\t//findWorkspaceSynopticMsgcntrItems\n\t\t\tsynItems = getSynopticMsgcntrManager().getWorkspaceSynopticMsgcntrItems(getCurrentUser());\n\t\t\t\n\t\t\t//Grab user's preferences for site order, and remove sites that user has removed\n\t\t\tPreferences prefs = PreferencesService.getPreferences(getCurrentUser());\n\t\t\tResourceProperties props = prefs.getProperties(CHARON_PREFS);\n\t\t\tList<String> orderedSites = props.getPropertyList(\"order\");\n\t\t\t\n\t\t\tList<String> excludedSites = props.getPropertyList(\"exclude\");\n\n\t\t\tif(excludedSites != null){\n\t\t\t\t//user has set preferences so filter out any missing sites:\n\t\t\t\tfor (Iterator iterator = synItems.iterator(); iterator\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tSynopticMsgcntrItem synItem = (SynopticMsgcntrItem) iterator.next();\n\t\t\t\t\tif(excludedSites.contains(synItem.getSiteId())){\n\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsynItems = sortSynopticMsgcntrList(synItems, orderedSites);\n\t\t\t\n\t\t\tmyContents = new ArrayList<DecoratedSynopticMsgcntrItem>();\n\n\t\t\t/**\n\t\t\t * This sites query needs to be the same as what the portal calls... this is to take advantage of query caching.\n\t\t\t * In theory sorting by TITLE_ASC seems like it would be slower, but that actually allows the query cache to find\n\t\t\t * it. If this is causing a slow down, check to see if portal changed it's getSites query.\n\t\t\t */\n\t\t\tList<Site> sites = SiteService.getSites(\n\t\t\t\t\torg.sakaiproject.site.api.SiteService.SelectionType.ACCESS, null, null,\n\t\t\t\t\tnull, org.sakaiproject.site.api.SiteService.SortType.TITLE_ASC, null);\n\t\t\t\n\n\t\t\tfor (SynopticMsgcntrItem synopticMsgcntrItem : synItems) {\n\t\t\t\tboolean deleteSite = false;\n\t\t\t\tboolean resetSynopticInfo = false;\n\t\t\t\tSite site = null;\n\t\t\t\tString synopticSiteId = synopticMsgcntrItem.getSiteId();\n\t\t\t\tif(synopticSiteId != null && !\"\".equals(synopticSiteId)){\n\t\t\t\t\tfor (Site itrSite : sites) {\n\t\t\t\t\t\tif(synopticSiteId.equals(itrSite.getId())){\n\t\t\t\t\t\t\tsite = itrSite;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t//only add if the site exists:\n\t\t\t\t\tif(site != null){\n\t\t\t\t\t\t//check if the site title has changed:\n\t\t\t\t\t\tif(synopticMsgcntrItem.getSiteTitle() != null && !synopticMsgcntrItem.getSiteTitle().equals(site.getTitle())){\n\t\t\t\t\t\t\t//update all site titles in table\n\t\t\t\t\t\t\tgetSynopticMsgcntrManager().updateAllSiteTitles(synopticMsgcntrItem.getSiteId(), site.getTitle());\n\t\t\t\t\t\t\t//set the current synoptic item's site title to the correct title\n\t\t\t\t\t\t\tsynopticMsgcntrItem.setSiteTitle(site.getTitle());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!PERFORMANCE_2.equals(performance)){\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tDecoratedSynopticMsgcntrItem dSynopticItem = new DecoratedSynopticMsgcntrItem(synopticMsgcntrItem, site);\n\t\t\t\t\t\t\t//this covers the case when a tool had unread messages but then the tool was \n\t\t\t\t\t\t\t//removed from the site\n\t\t\t\t\t\t\tboolean isMessageForumsPageInSite = isMessageForumsPageInSite(site);\n\t\t\t\t\t\t\tif(!isDisableMessages() && !isMessageForumsPageInSite && !isMessagesPageInSite(site) && dSynopticItem.getNewMessagesCount() != 0){\n\t\t\t\t\t\t\t\t//update synoptic item since the db is out of sync:\n\t\t\t\t\t\t\t\tresetSynopticInfo = true;\n\t\t\t\t\t\t\t}else if(!isDisableForums() && !isMessageForumsPageInSite && !isForumsPageInSite(site) && dSynopticItem.getNewForumCount() != 0){\n\t\t\t\t\t\t\t\t//update synoptic item since it the db is out of sync:\n\t\t\t\t\t\t\t\tresetSynopticInfo = true;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//everything checks out, so add it to the list\n\t\t\t\t\t\t\t\tmyContents.add(dSynopticItem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tDecoratedSynopticMsgcntrItem dSynopticItem = new DecoratedSynopticMsgcntrItem(synopticMsgcntrItem, null);\n\t\t\t\t\t\t\tmyContents.add(dSynopticItem);\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//site is null (could not find site is access list)\n\t\t\t\t\t\tdeleteSite = true;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t//site Id is null or \"\"\n\t\t\t\t\tdeleteSite = true;\n\t\t\t\t}\n\n\n\t\t\t\tif(deleteSite){\n\t\t\t\t\t//synoptic item for site needs to be delete\n\t\t\t\t\tgetSynopticMsgcntrManager().deleteSynopticMsgcntrItem(synopticMsgcntrItem);\n\t\t\t\t}\n\t\t\t\tif(resetSynopticInfo){\n\t\t\t\t\t//update synoptic item since the db is out of sync:\n\t\t\t\t\tgetSynopticMsgcntrManager()\n\t\t\t\t\t.resetMessagesAndForumSynopticInfo(\n\t\t\t\t\t\t\tsynopticMsgcntrItem.getUserId(),\n\t\t\t\t\t\t\tsynopticMsgcntrItem.getSiteId());\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\t\n\t\t\tmyContentsSize = myContents.size();\n\t\t\tfor (Iterator iterator = myContents.iterator(); iterator.hasNext();) {\n\t\t\t\tDecoratedSynopticMsgcntrItem dSynopticMsgcntrItem = (DecoratedSynopticMsgcntrItem) iterator\n\t\t\t\t\t\t.next();\n\t\t\t\tif(!dSynopticMsgcntrItem.getSynopticMsgcntrItem().isHideItem())\n\t\t\t\t\tmyDisplayedSites++;\n\t\t\t}\n\t\t\t\n\t\t\treturn myContents;\n\t\t}else{\n\t\t\t//not workspace or workspace is disabled\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"3f8acb8e0c3404e47b150b124d1edb18398c0abe","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Add a resource to the indexing queue {@inheritDoc}\n\t */\n\tpublic void addResource(Notification notification, Event event)\n\t{\n\t\tlog.debug(\"Add resource \" + notification + \"::\" + event);\n\t\tString resourceName = event.getResource();\n\t\tEntityContentProducer ecp = newEntityContentProducer(event);\n\t\tInteger action = ecp.getAction(event);\n\t\tint retries = 5;\n\t\twhile (retries > 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSearchBuilderItem sb = searchBuilderItemDao\n\t\t\t\t\t\t.findByName(resourceName);\n\t\t\t\tif (sb == null)\n\t\t\t\t{\n\t\t\t\t\t// new\n\t\t\t\t\tsb = searchBuilderItemDao.create();\n\t\t\t\t\tsb.setSearchaction(action);\n\t\t\t\t\tsb.setName(resourceName);\n\t\t\t\t\tsb.setContext(ecp.getSiteId(resourceName));\n\t\t\t\t\tsb.setSearchstate(SearchBuilderItem.STATE_PENDING);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.setSearchaction(action);\n\t\t\t\t\tsb.setContext(ecp.getSiteId(resourceName));\n\t\t\t\t\tsb.setName(resourceName);\n\t\t\t\t\tsb.setSearchstate(SearchBuilderItem.STATE_PENDING);\n\t\t\t\t}\n\t\t\t\tsearchBuilderItemDao.update(sb);\n\t\t\t\tsb = searchBuilderItemDao.findByName(resourceName);\n\t\t\t\tlog.debug(\"SEARCHBUILDER: Added Resource \" + action + \" \"\n\t\t\t\t\t\t+ sb.getName());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcatch (Throwable t)\n\t\t\t{\n\t\t\t\tlog.warn(\"Retrying to register \" + resourceName\n\t\t\t\t\t\t+ \" with the search engine \", t);\n\t\t\t\tretries--;\n\t\t\t}\n\t\t}\n\t\tif (retries == 0)\n\t\t{\n\t\t\tlog.warn(\"In trying to register resource \" + resourceName\n\t\t\t\t\t+ \" in search engine, I failed after\"\n\t\t\t\t\t+ \" 5 attempts, this resource will\"\n\t\t\t\t\t+ \" not be indexed untill it is modified\");\n\t\t}\n\t\trestartBuilder();\n\t}","id":79708,"modified_method":"/**\n\t * Add a resource to the indexing queue {@inheritDoc}\n\t */\n\tpublic void addResource(Notification notification, Event event)\n\t{\n\t\tlog.debug(\"Add resource \" + notification + \"::\" + event);\n\t\tString resourceName = event.getResource();\n\t\tif ( resourceName == null ) {\n\t\t\t// default if null\n\t\t\tresourceName = \"\";\n\t\t}\n\t\tEntityContentProducer ecp = newEntityContentProducer(event);\n\t\tInteger action = ecp.getAction(event);\n\t\tint retries = 5;\n\t\twhile (retries > 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSearchBuilderItem sb = searchBuilderItemDao\n\t\t\t\t\t\t.findByName(resourceName);\n\t\t\t\tif (sb == null)\n\t\t\t\t{\n\t\t\t\t\t// new\n\t\t\t\t\tsb = searchBuilderItemDao.create();\n\t\t\t\t\tsb.setSearchaction(action);\n\t\t\t\t\tsb.setName(resourceName);\n\t\t\t\t\tString siteId = ecp.getSiteId(resourceName);\n\t\t\t\t\tif ( siteId == null ) {\n\t\t\t\t\t\t// default if null should neve happen\n\t\t\t\t\t\tsiteId = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tsb.setContext(siteId);\n\t\t\t\t\tsb.setSearchstate(SearchBuilderItem.STATE_PENDING);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.setSearchaction(action);\n\t\t\t\t\tString siteId = ecp.getSiteId(resourceName);\n\t\t\t\t\tif ( siteId == null ) {\n\t\t\t\t\t\t// default if null, should never happen\n\t\t\t\t\t\tsiteId = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tsb.setContext(siteId);\n\t\t\t\t\tsb.setName(resourceName);\n\t\t\t\t\tsb.setSearchstate(SearchBuilderItem.STATE_PENDING);\n\t\t\t\t}\n\t\t\t\tsearchBuilderItemDao.update(sb);\n\t\t\t\tlog.debug(\"SEARCHBUILDER: Added Resource \" + action + \" \"\n\t\t\t\t\t\t+ sb.getName());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcatch (Throwable t)\n\t\t\t{\n\t\t\t\tlog.warn(\"Retrying to register \" + resourceName\n\t\t\t\t\t\t+ \" with the search engine \", t);\n\t\t\t\tretries--;\n\t\t\t}\n\t\t}\n\t\tif (retries == 0)\n\t\t{\n\t\t\tlog.warn(\"In trying to register resource \" + resourceName\n\t\t\t\t\t+ \" in search engine, I failed after\"\n\t\t\t\t\t+ \" 5 attempts, this resource will\"\n\t\t\t\t\t+ \" not be indexed untill it is modified\");\n\t\t}\n\t\trestartBuilder();\n\t}","commit_id":"52833ac1bb0603e2b93ecd2940edc8baffb45162","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String getParent() {       \n        if (getAbsoluteFileName().lastIndexOf(File.separator) > 0) {\n            return getAbsoluteFileName().substring(0, getAbsoluteFileName().lastIndexOf(File.separator));\n        } else {\n            return \"\";\n        }\n    }","id":79709,"modified_method":"public String getParent() {       \n        if (getAbsoluteFileName().lastIndexOf(getFileSeparator()) > 0) {\n            return getAbsoluteFileName().substring(0, getAbsoluteFileName().lastIndexOf(getFileSeparator()));\n        } else {\n            return \"\";\n        }\n    }","commit_id":"9e4164f06fbc0ca4ebd0560b818b7d7232111498","url":"https://github.com/apache/camel"},{"original_method":"public void setAbsoluteFileName(String absoluteFileName) {\n        // must normalize path to cater for Windows and other OS\n        this.absoluteFileName = FileUtil.normalizePath(absoluteFileName);\n    }","id":79710,"modified_method":"public void setAbsoluteFileName(String absoluteFileName) {\n               \n        this.absoluteFileName = needToNormalize()\n            // must normalize path to cater for Windows and other OS\n            ? FileUtil.normalizePath(absoluteFileName)\n            // we don't need to do that for Remote File\n            : absoluteFileName;\n        \n    }","commit_id":"9e4164f06fbc0ca4ebd0560b818b7d7232111498","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Changes the name of this remote file. This method alters the absolute and\n     * relative names as well.\n     *\n     * @param newName the new name\n     */\n    public void changeFileName(String newName) {\n        // must normalize path to cater for Windows and other OS\n        newName = FileUtil.normalizePath(newName);\n\n        setAbsoluteFileName(getParent() + File.separator + newName);\n        \n        // relative name is a bit more complex to set as newName itself can contain\n        // folders we need to consider as well\n        String baseNewName = null;\n        if (newName.indexOf(File.separator) != -1) {\n            baseNewName = newName.substring(0, newName.lastIndexOf(File.separator));\n            newName = newName.substring(newName.lastIndexOf(File.separator) + 1);\n        }\n\n        if (relativeFileName.indexOf(File.separator) != -1) {\n            String relative = relativeFileName.substring(0, relativeFileName.lastIndexOf(File.separator));\n            if (baseNewName != null) {\n                setRelativeFileName(relative + File.separator + baseNewName + File.separator + newName);\n            } else {\n                setRelativeFileName(relative + File.separator + newName);\n            }\n        } else {\n            if (baseNewName != null) {\n                setRelativeFileName(baseNewName + File.separator + newName);\n            } else {\n                setRelativeFileName(newName);\n            }\n        }\n\n        setFileName(newName);\n    }","id":79711,"modified_method":"/**\n     * Changes the name of this remote file. This method alters the absolute and\n     * relative names as well.\n     *\n     * @param newName the new name\n     */\n    public void changeFileName(String newName) {\n        \n        newName = needToNormalize()\n            // must normalize path to cater for Windows and other OS\n            ? FileUtil.normalizePath(newName)\n            // for the remote file we don't need to do that     \n            : newName;\n\n        setAbsoluteFileName(getParent() + getFileSeparator() + newName);\n        \n        // relative name is a bit more complex to set as newName itself can contain\n        // folders we need to consider as well\n        String baseNewName = null;\n        if (newName.indexOf(getFileSeparator()) != -1) {\n            baseNewName = newName.substring(0, newName.lastIndexOf(getFileSeparator()));\n            newName = newName.substring(newName.lastIndexOf(getFileSeparator()) + 1);\n        }\n\n        if (relativeFileName.indexOf(getFileSeparator()) != -1) {\n            String relative = relativeFileName.substring(0, relativeFileName.lastIndexOf(File.separator));\n            if (baseNewName != null) {\n                setRelativeFileName(relative + getFileSeparator() + baseNewName + getFileSeparator() + newName);\n            } else {\n                setRelativeFileName(relative + getFileSeparator() + newName);\n            }\n        } else {\n            if (baseNewName != null) {\n                setRelativeFileName(baseNewName + getFileSeparator() + newName);\n            } else {\n                setRelativeFileName(newName);\n            }\n        }\n\n        setFileName(newName);\n    }","commit_id":"9e4164f06fbc0ca4ebd0560b818b7d7232111498","url":"https://github.com/apache/camel"},{"original_method":"public void setFile(String file) {\n        // must normalize path to cater for Windows and other OS\n        this.file = FileUtil.normalizePath(file);\n    }","id":79712,"modified_method":"public void setFile(String file) { \n        this.file = needToNormalize()\n            // must normalize path to cater for Windows and other OS\n            ? FileUtil.normalizePath(file)\n            // for the remote file we don't need to do that   \n            : file;        \n    }","commit_id":"9e4164f06fbc0ca4ebd0560b818b7d7232111498","url":"https://github.com/apache/camel"},{"original_method":"@Test\n  public void find_users_with_permission_template() throws Exception {\n    service.findUsersWithPermissionTemplate(ImmutableMap.<String, Object>of(\n      \"permission\", \"user\",\n      \"template\", \"my_template\",\n      \"selected\", \"all\"));\n\n    ArgumentCaptor<WithPermissionQuery> argumentCaptor = ArgumentCaptor.forClass(WithPermissionQuery.class);\n    verify(finder).findUsersWithPermissionTemplate(argumentCaptor.capture());\n\n    WithPermissionQuery query = argumentCaptor.getValue();\n    assertThat(query.permission()).isEqualTo(\"user\");\n    assertThat(query.template()).isEqualTo(\"my_template\");\n    assertThat(query.membership()).isEqualTo(WithPermissionQuery.ANY);\n  }","id":79713,"modified_method":"@Test\n  public void find_users_with_permission_template() throws Exception {\n    service.findUsersWithPermissionTemplate(ImmutableMap.<String, Object>of(\n      \"permission\", \"user\",\n      \"template\", \"my_template\",\n      \"selected\", \"all\"));\n    verify(finder).findUsersWithPermissionTemplate(any(WithPermissionQuery.class));\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    permissionTemplateDao = mock(PermissionTemplateDao.class);\n    userDao = mock(UserDao.class);\n    service = new InternalPermissionTemplateService(permissionTemplateDao, userDao, finder);\n  }","id":79714,"modified_method":"@Before\n  public void setUp() {\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    service = new InternalPermissionTemplateService(permissionTemplateDao, userDao, finder);\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @return a paginated list of users.\n   */\n  public List<UserWithPermissionDto> selectUsers(WithPermissionQuery query, @Nullable Long componentId, int offset, int limit) {\n    SqlSession session = myBatis.openSession();\n    try {\n      Map<String, Object> params = newHashMap();\n      params.put(\"query\", query);\n      params.put(\"componentId\", componentId);\n      return session.selectList(\"org.sonar.core.permission.PermissionMapper.selectUsers\", params, new RowBounds(offset, limit));\n    } finally {\n      myBatis.closeQuietly(session);\n    }\n  }","id":79715,"modified_method":"/**\n   * @return a paginated list of users.\n   */\n  public List<UserWithPermissionDto> selectUsers(WithPermissionQuery query, @Nullable Long componentId, int offset, int limit) {\n    SqlSession session = myBatis.openSession();\n    try {\n      Map<String, Object> params = newHashMap();\n      params.put(\"query\", query);\n      params.put(\"componentId\", componentId);\n      return session.selectList(\"org.sonar.core.permission.PermissionMapper.selectUsers\", params, new RowBounds(offset, limit));\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @return a non paginated list of groups.\n   * Membership parameter from query is not taking into account in order to deal more easily deal the 'Anyone' group\n   */\n  public List<GroupWithPermissionDto> selectGroups(WithPermissionQuery query, @Nullable Long componentId) {\n    SqlSession session = myBatis.openSession();\n    try {\n      Map<String, Object> params = newHashMap();\n      params.put(\"query\", query);\n      params.put(\"componentId\", componentId);\n      params.put(\"anyoneGroup\", DefaultGroups.ANYONE);\n      return session.selectList(\"org.sonar.core.permission.PermissionMapper.selectGroups\", params);\n    } finally {\n      myBatis.closeQuietly(session);\n    }\n  }","id":79716,"modified_method":"/**\n   * @return a non paginated list of groups.\n   * Membership parameter from query is not taking into account in order to deal more easily with the 'Anyone' group\n   */\n  public List<GroupWithPermissionDto> selectGroups(WithPermissionQuery query, @Nullable Long componentId) {\n    SqlSession session = myBatis.openSession();\n    try {\n      Map<String, Object> params = newHashMap();\n      params.put(\"query\", query);\n      params.put(\"componentId\", componentId);\n      params.put(\"anyoneGroup\", DefaultGroups.ANYONE);\n      return session.selectList(\"org.sonar.core.permission.PermissionMapper.selectGroups\", params);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public UserWithPermissionQueryResult findUsersWithPermission(WithPermissionQuery query) {\n    Long componentId = componentId(query.component());\n    int limit = limit(query);\n    return toQueryResult(permissionDao.selectUsers(query, componentId, offset(query), limit), limit);\n  }","id":79717,"modified_method":"public UserWithPermissionQueryResult findUsersWithPermission(WithPermissionQuery query) {\n    Long componentId = componentId(query.component());\n    int limit = limit(query);\n    return toUserQueryResult(permissionDao.selectUsers(query, componentId, offset(query), limit), limit);\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public UserWithPermissionQueryResult findUsersWithPermissionTemplate(WithPermissionQuery query) {\n    Long permissionTemplateId = templateId(query.template());\n    int limit = limit(query);\n    return toQueryResult(permissionTemplateDao.selectUsers(query, permissionTemplateId, offset(query), limit), limit);\n  }","id":79718,"modified_method":"public UserWithPermissionQueryResult findUsersWithPermissionTemplate(WithPermissionQuery query) {\n    Long permissionTemplateId = templateId(query.template());\n    int limit = limit(query);\n    return toUserQueryResult(permissionTemplateDao.selectUsers(query, permissionTemplateId, offset(query), limit), limit);\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Paging for groups search is done in Java in order to correctly handle the 'Anyone' group\n   */\n  public GroupWithPermissionQueryResult findGroupsWithPermission(WithPermissionQuery query) {\n    Long componentId = componentId(query.component());\n\n    List<GroupWithPermissionDto> dtos = permissionDao.selectGroups(query, componentId);\n    addAnyoneGroup(dtos, query);\n    List<GroupWithPermissionDto> filteredDtos = filterMembership(dtos, query);\n\n    Paging paging = Paging.create(query.pageSize(), query.pageIndex(), filteredDtos.size());\n    List<GroupWithPermission> pagedGroups = pagedGroups(filteredDtos, paging);\n    return new GroupWithPermissionQueryResult(pagedGroups, paging.hasNextPage());\n  }","id":79719,"modified_method":"/**\n   * Paging for groups search is done in Java in order to correctly handle the 'Anyone' group\n   */\n  public GroupWithPermissionQueryResult findGroupsWithPermission(WithPermissionQuery query) {\n    Long componentId = componentId(query.component());\n    return toGroupQueryResult(permissionDao.selectGroups(query, componentId), query);\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private UserWithPermissionQueryResult toQueryResult(List<UserWithPermissionDto> dtos, int limit) {\n    boolean hasMoreResults = false;\n    if (dtos.size() == limit) {\n      hasMoreResults = true;\n      // Removed last entry as it's only need to know if there more results or not\n      dtos.remove(dtos.size() - 1);\n    }\n    return new UserWithPermissionQueryResult(toUserWithPermissionList(dtos), hasMoreResults);\n  }","id":79720,"modified_method":"private UserWithPermissionQueryResult toUserQueryResult(List<UserWithPermissionDto> dtos, int limit) {\n    boolean hasMoreResults = false;\n    if (dtos.size() == limit) {\n      hasMoreResults = true;\n      // Removed last entry as it's only need to know if there more results or not\n      dtos.remove(dtos.size() - 1);\n    }\n    return new UserWithPermissionQueryResult(toUserWithPermissionList(dtos), hasMoreResults);\n  }","commit_id":"bab1d0bd90e426b4f65cd085343c4e2758b1761b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Collection getCollection(DBBroker broker, Txn transaction, XmldbURI collectionPath) throws IOException, PermissionDeniedException {\n        XmldbURI path = VERSIONS_COLLECTION.append(collectionPath);\n        Collection collection = broker.openCollection(path, Lock.WRITE_LOCK);\n        if (collection == null) {\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Creating versioning collection: \" + path);\n            collection = broker.getOrCreateCollection(transaction, path);\n            broker.saveCollection(transaction, collection);\n        } else {\n            transaction.registerLock(collection.getLock(), Lock.WRITE_LOCK);\n        }\n        return collection;\n    }","id":79721,"modified_method":"private Collection getVersionsCollection(DBBroker broker, Txn transaction, XmldbURI collectionPath) throws IOException, PermissionDeniedException {\n        XmldbURI path = VERSIONS_COLLECTION.append(collectionPath);\n        Collection collection = broker.openCollection(path, Lock.WRITE_LOCK);\n        if (collection == null) {\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Creating versioning collection: \" + path);\n            collection = broker.getOrCreateCollection(transaction, path);\n            broker.saveCollection(transaction, collection);\n        } else {\n            transaction.registerLock(collection.getLock(), Lock.WRITE_LOCK);\n        }\n        return collection;\n    }","commit_id":"958d7f05ffb671999d59b987b762248a27bcffba","url":"https://github.com/eXist-db/exist"},{"original_method":"private long newRevision(BrokerPool pool) {\n        String dataDir = (String) pool.getConfiguration().getProperty(BrokerPool.PROPERTY_DATA_DIR);\n        synchronized (latch) {\n            File f = new File(dataDir, \"versions.dbx\");\n            long rev = 0;\n            if (f.canRead()) {\n                try {\n                    DataInputStream is = new DataInputStream(new FileInputStream(f));\n                    rev = is.readLong();\n                    is.close();\n                } catch (FileNotFoundException e) {\n                    LOG.warn(\"Failed to read versions.dbx: \" + e.getMessage(), e);\n                } catch (IOException e) {\n                    LOG.warn(\"Failed to read versions.dbx: \" + e.getMessage(), e);\n                }\n            }\n            ++rev;\n            try {\n                DataOutputStream os = new DataOutputStream(new FileOutputStream(f));\n                os.writeLong(rev);\n                os.close();\n            } catch (FileNotFoundException e) {\n                LOG.warn(\"Failed to write versions.dbx: \" + e.getMessage(), e);\n            } catch (IOException e) {\n                LOG.warn(\"Failed to write versions.dbx: \" + e.getMessage(), e);\n            }\n            return rev;\n        }\n    }","id":79722,"modified_method":"private long newRevision(BrokerPool pool) {\n        String dataDir = (String) pool.getConfiguration().getProperty(BrokerPool.PROPERTY_DATA_DIR);\n        synchronized (latch) {\n            File f = new File(dataDir, \"versions.dbx\");\n            long rev = 0;\n            if (f.canRead()) {\n                DataInputStream is = null;\n                try {\n                    is = new DataInputStream(new FileInputStream(f));\n                    rev = is.readLong();\n                } catch (FileNotFoundException e) {\n                    LOG.warn(\"Failed to read versions.dbx: \" + e.getMessage(), e);\n                } catch (IOException e) {\n                    LOG.warn(\"Failed to read versions.dbx: \" + e.getMessage(), e);\n                }\n                finally\n                {\n                    if(is != null)\n                    {\n                        try\n                        {\n                            is.close();\n                        }\n                        catch(IOException ioe)\n                        {\n                            LOG.warn(\"Failed to close InputStream for versions.dbx: \" + ioe.getMessage(), ioe);\n                        }\n                    }\n                }\n            }\n            \n            ++rev;\n\n            DataOutputStream os = null;\n            try {\n                os = new DataOutputStream(new FileOutputStream(f));\n                os.writeLong(rev);\n            } catch (FileNotFoundException e) {\n                LOG.warn(\"Failed to write versions.dbx: \" + e.getMessage(), e);\n            } catch (IOException e) {\n                LOG.warn(\"Failed to write versions.dbx: \" + e.getMessage(), e);\n            }\n            finally\n            {\n                if(os != null)\n                {\n                    try\n                    {\n                        os.close();\n                    }\n                    catch(IOException ioe)\n                    {\n                         LOG.warn(\"Failed to close OutputStream for versions.dbx: \" + ioe.getMessage(), ioe);\n                    }\n                }\n            }\n            return rev;\n        }\n    }","commit_id":"958d7f05ffb671999d59b987b762248a27bcffba","url":"https://github.com/eXist-db/exist"},{"original_method":"public void finish(int event, DBBroker broker, Txn transaction, XmldbURI documentPath, DocumentImpl document) {\n        if (documentPath.startsWith(VERSIONS_COLLECTION))\n            return;\n        User activeUser = broker.getUser();\n        try {\n            broker.setUser(org.exist.security.SecurityManager.SYSTEM_USER);\n            if (vDoc != null && !removeLast) {\n                try {\n                    vDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                    vCollection.addDocument(transaction, broker, vDoc);\n                    broker.storeXMLResource(transaction, vDoc);\n                } catch (LockException e) {\n                    LOG.warn(\"Versioning trigger could not store base document: \" + vDoc.getFileURI() +\n                            e.getMessage(), e);\n                } finally {\n                    vDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n                }\n            }\n            if (event == STORE_DOCUMENT_EVENT) {\n                try {\n                    vCollection = getCollection(broker, transaction, documentPath.removeLastSegment());\n\n                    String existingURI = document.getFileURI().toString();\n                    XmldbURI deletedURI = XmldbURI.create(existingURI + DELETED_SUFFIX);\n                    lastRev = vCollection.getDocument(broker, deletedURI);\n                    if (lastRev == null) {\n                        lastRev = vCollection.getDocument(broker, XmldbURI.create(existingURI + BASE_SUFFIX));\n                        removeLast = false;\n                    } else\n                        removeLast = true;\n                } catch (IOException e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } catch (PermissionDeniedException e) {\n                    LOG.warn(\"Permission denied in VersioningTrigger: \" + e.getMessage(), e);\n                }\n            }\n            if (lastRev != null || event == REMOVE_DOCUMENT_EVENT) {\n                Diff diff = new StandardDiff(broker);\n                if (documentPath.isCollectionPathAbsolute())\n                    documentPath = documentPath.lastSegment();\n                DocumentImpl base = null;\n                try {\n                    vCollection.setTriggersEnabled(false);\n\n                    long rev = newRevision(broker.getBrokerPool());\n                    Properties properties = new Properties();\n                    properties.setProperty(\"document\", documentPath.toString());\n                    properties.setProperty(\"revision\", Long.toString(rev));\n                    properties.setProperty(\"date\", new DateTimeValue(new Date()).getStringValue());\n                    properties.setProperty(\"user\", broker.getUser().getName());\n                    if (documentKey != null) {\n                        properties.setProperty(\"key\", documentKey);\n                    }\n                    StringWriter writer = new StringWriter();\n                    SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(\n                            SAXSerializer.class);\n                    Properties outputProperties = new Properties();\n                    outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n                    outputProperties.setProperty(OutputKeys.INDENT, \"no\");\n                    sax.setOutput(writer, outputProperties);\n                    sax.startDocument();\n\n                    sax.startElement(ELEMENT_VERSION, null);\n                    writeProperties(sax, properties);\n                    if (event == REMOVE_DOCUMENT_EVENT) {\n                        sax.startElement(ELEMENT_REMOVED, null);\n                        sax.endElement(ELEMENT_REMOVED);\n                    } else {\n                        diff.diff(lastRev, document);\n                        diff.diff2XML(sax);\n                    }\n                    sax.endElement(ELEMENT_VERSION);\n\n                    sax.endDocument();\n                    String editscript = writer.toString();\n\n//                    System.out.println(\"documentPath: \" + documentPath);\n//                    System.out.println(editscript);\n\n                    if (removeLast)\n                        vCollection.removeXMLResource(transaction, broker, lastRev.getFileURI());\n\n                    XmldbURI diffUri = XmldbURI.createInternal(documentPath.toString() + '.' + rev);\n                    IndexInfo info = vCollection.validateXMLResource(transaction, broker, diffUri, editscript);\n                    vCollection.store(transaction, broker, info, editscript, false);\n                } catch (Exception e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } finally {\n                    if (base != null)\n                        base.getUpdateLock().release(Lock.READ_LOCK);\n                    vCollection.setTriggersEnabled(true);\n                }\n            }\n        } finally {\n            broker.setUser(activeUser);\n        }\n    }","id":79723,"modified_method":"public void finish(int event, DBBroker broker, Txn transaction, XmldbURI documentPath, DocumentImpl document) {\n\n        if (documentPath.startsWith(VERSIONS_COLLECTION))\n            return;\n        \n        User activeUser = broker.getUser();\n\n        try {\n            broker.setUser(org.exist.security.SecurityManager.SYSTEM_USER);\n\n            if (vDoc != null && !removeLast) {\n                if(!(vDoc instanceof BinaryDocument))\n                {\n                    try {\n                        vDoc.getUpdateLock().acquire(Lock.WRITE_LOCK);\n                        vCollection.addDocument(transaction, broker, vDoc);\n                        broker.storeXMLResource(transaction, vDoc);\n                    } catch (LockException e) {\n                        LOG.warn(\"Versioning trigger could not store base document: \" + vDoc.getFileURI() +\n                                e.getMessage(), e);\n                    } finally {\n                        vDoc.getUpdateLock().release(Lock.WRITE_LOCK);\n                    }\n                }\n            }\n\n            if (event == STORE_DOCUMENT_EVENT) {\n                try {\n                    vCollection = getVersionsCollection(broker, transaction, documentPath.removeLastSegment());\n\n                    String existingURI = document.getFileURI().toString();\n                    XmldbURI deletedURI = XmldbURI.create(existingURI + DELETED_SUFFIX);\n                    lastRev = vCollection.getDocument(broker, deletedURI);\n                    if (lastRev == null) {\n                        lastRev = vCollection.getDocument(broker, XmldbURI.create(existingURI + BASE_SUFFIX));\n                        removeLast = false;\n                    } else\n                        removeLast = true;\n                } catch (IOException e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } catch (PermissionDeniedException e) {\n                    LOG.warn(\"Permission denied in VersioningTrigger: \" + e.getMessage(), e);\n                }\n            }\n\n            if (lastRev != null || event == REMOVE_DOCUMENT_EVENT)\n            {\n                try{\n\n                    long revision = newRevision(broker.getBrokerPool());\n                    if (documentPath.isCollectionPathAbsolute())\n                            documentPath = documentPath.lastSegment();\n                    XmldbURI diffUri = XmldbURI.createInternal(documentPath.toString() + '.' + revision);\n\n                    vCollection.setTriggersEnabled(false);\n\n                    StringWriter writer = new StringWriter();\n                    SAXSerializer sax = (SAXSerializer) SerializerPool.getInstance().borrowObject(\n                            SAXSerializer.class);\n                    Properties outputProperties = new Properties();\n                    outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n                    outputProperties.setProperty(OutputKeys.INDENT, \"no\");\n                    sax.setOutput(writer, outputProperties);\n\n                    sax.startDocument();\n                    sax.startElement(ELEMENT_VERSION, null);\n                    writeProperties(sax, getVersionProperties(revision, documentPath));\n\n                    if(event == REMOVE_DOCUMENT_EVENT)\n                    {\n                        sax.startElement(ELEMENT_REMOVED, null);\n                        sax.endElement(ELEMENT_REMOVED);\n                    }\n                    else\n                    {\n\n                        //Diff\n                        if(document instanceof BinaryDocument)\n                        {\n                            //create a copy of the last Binary revision\n                            XmldbURI binUri = XmldbURI.create(diffUri.toString() + BINARY_SUFFIX);\n                            broker.copyResource(transaction, document, vCollection, binUri);\n\n                            //Create metadata about the last Binary Version\n                            sax.startElement(ELEMENT_REPLACED_BINARY, null);\n                            sax.attribute(ATTRIBUTE_REF, binUri.toString());\n                            sax.endElement(ELEMENT_REPLACED_BINARY);\n                        }\n                        else if(lastRev instanceof BinaryDocument)\n                        {\n                            //create a copy of the last XML revision\n                            XmldbURI xmlUri = XmldbURI.create(diffUri.toString() + XML_SUFFIX);\n                            broker.copyResource(transaction, document, vCollection, xmlUri);\n\n                            //Create metadata about the last Binary Version\n                            sax.startElement(ELEMENT_REPLACED_XML, null);\n                            sax.attribute(ATTRIBUTE_REF, xmlUri.toString());\n                            sax.endElement(ELEMENT_REPLACED_BINARY);\n                        }\n                        else\n                        {\n                            //Diff the XML versions\n                            Diff diff = new StandardDiff(broker);\n                            diff.diff(lastRev, document);\n                            diff.diff2XML(sax);\n                        }\n\n                        sax.endElement(ELEMENT_VERSION);\n\n                        sax.endDocument();\n                        String editscript = writer.toString();\n\n    //                    System.out.println(\"documentPath: \" + documentPath);\n    //                    System.out.println(editscript);\n\n                        if (removeLast)\n                        {\n                           if(lastRev instanceof BinaryDocument)\n                           {\n                                vCollection.removeBinaryResource(transaction, broker, lastRev.getFileURI());\n                           }\n                           else\n                           {\n                                vCollection.removeXMLResource(transaction, broker, lastRev.getFileURI());\n                           }\n                        }\n\n                        \n                        IndexInfo info = vCollection.validateXMLResource(transaction, broker, diffUri, editscript);\n                        vCollection.store(transaction, broker, info, editscript, false);\n                        \n                    }\n                }\n                catch (Exception e) {\n                    LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n                } finally {\n                    vCollection.setTriggersEnabled(true);\n                }\n            }\n\n        } finally {\n            broker.setUser(activeUser);\n        }\n    }","commit_id":"958d7f05ffb671999d59b987b762248a27bcffba","url":"https://github.com/eXist-db/exist"},{"original_method":"public void prepare(int event, DBBroker broker, Txn transaction, XmldbURI documentPath, DocumentImpl existingDocument)\n    throws TriggerException {\n        this.broker = broker;\n        this.documentPath = documentPath;\n        User activeUser = broker.getUser();\n        try {\n            broker.setUser(org.exist.security.SecurityManager.SYSTEM_USER);\n            if (event == UPDATE_DOCUMENT_EVENT || event == REMOVE_DOCUMENT_EVENT) {\n                Collection collection = existingDocument.getCollection();\n                if (collection.getURI().startsWith(VERSIONS_COLLECTION))\n                    return;\n                vCollection = getCollection(broker, transaction, documentPath.removeLastSegment());\n\n                String existingURI = existingDocument.getFileURI().toString();\n                XmldbURI baseURI = XmldbURI.create(existingURI + BASE_SUFFIX);\n                DocumentImpl baseRev = vCollection.getDocument(broker, baseURI);\n\n                String vFileName;\n                if (baseRev == null) {\n                    vFileName = baseURI.toString();\n                    removeLast = false;\n                } else if (event == REMOVE_DOCUMENT_EVENT) {\n                    vFileName = existingURI + DELETED_SUFFIX;\n                    removeLast = false;\n                } else {\n                    vFileName = existingURI + TEMP_SUFFIX;\n                    removeLast = true;\n                }\n\n                // setReferenced(true) will tell the broker that the document\n                // data is referenced from another document and should not be\n                // deleted when the orignal document is removed.\n                existingDocument.getMetadata().setReferenced(true);\n\n                vDoc = new DocumentImpl(broker.getBrokerPool(), vCollection, XmldbURI.createInternal(vFileName));\n                vDoc.copyOf(existingDocument);\n                vDoc.copyChildren(existingDocument);\n\n                if (event != REMOVE_DOCUMENT_EVENT)\n                    lastRev = vDoc;\n            }\n        } catch (PermissionDeniedException e) {\n            throw new TriggerException(\"Permission denied in VersioningTrigger: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n        } finally {\n            broker.setUser(activeUser);\n        }\n    }","id":79724,"modified_method":"public void prepare(int event, DBBroker broker, Txn transaction, XmldbURI documentPath, DocumentImpl existingDocument)\n    throws TriggerException {\n\n        this.broker = broker;\n        this.documentPath = documentPath;\n        User activeUser = broker.getUser();\n\n        try {\n            broker.setUser(org.exist.security.SecurityManager.SYSTEM_USER);\n\n            if(event == UPDATE_DOCUMENT_EVENT || event == REMOVE_DOCUMENT_EVENT)\n            {\n                Collection collection = existingDocument.getCollection();\n                if (collection.getURI().startsWith(VERSIONS_COLLECTION))\n                    return;\n                vCollection = getVersionsCollection(broker, transaction, documentPath.removeLastSegment());\n\n                String existingURI = existingDocument.getFileURI().toString();\n                XmldbURI baseURI = XmldbURI.create(existingURI + BASE_SUFFIX);\n                DocumentImpl baseRev = vCollection.getDocument(broker, baseURI);\n\n                String vFileName;\n\n                if (baseRev == null) {\n                    vFileName = baseURI.toString();\n                    removeLast = false;\n                } else if (event == REMOVE_DOCUMENT_EVENT) {\n                    vFileName = existingURI + DELETED_SUFFIX;\n                    removeLast = false;\n                } else {\n                    vFileName = existingURI + TEMP_SUFFIX;\n                    removeLast = true;\n                }\n\n                // setReferenced(true) will tell the broker that the document\n                // data is referenced from another document and should not be\n                // deleted when the orignal document is removed.\n                existingDocument.getMetadata().setReferenced(true);\n\n\n                if(existingDocument instanceof BinaryDocument)\n                {\n                    XmldbURI binUri = XmldbURI.createInternal(vFileName);\n                    broker.copyResource(transaction, existingDocument, vCollection, binUri);\n                    vDoc = vCollection.getDocument(broker, binUri);\n                }\n                else\n                {\n                    vDoc = new DocumentImpl(broker.getBrokerPool(), vCollection, XmldbURI.createInternal(vFileName));\n                    vDoc.copyOf(existingDocument);\n                    vDoc.copyChildren(existingDocument);\n                }\n                \n                if (event != REMOVE_DOCUMENT_EVENT)\n                    lastRev = vDoc;\n            }\n        } catch (PermissionDeniedException e) {\n            throw new TriggerException(\"Permission denied in VersioningTrigger: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            LOG.warn(\"Caught exception in VersioningTrigger: \" + e.getMessage(), e);\n        } finally {\n            broker.setUser(activeUser);\n        }\n    }","commit_id":"958d7f05ffb671999d59b987b762248a27bcffba","url":"https://github.com/eXist-db/exist"},{"original_method":"private boolean isSignificantJavaElement(final ASTNode current) {\n    if (current.getTreeParent() != null && current.getTreeParent().getElementType() == ElementType.CLASS) return true;\n    if (current.getElementType() == ElementType.METHOD) return true;\n    if (current.getElementType() == ElementType.CLASS) return true;\n    if (ElementType.STATEMENT_BIT_SET.isInSet(current.getElementType())) return true;\n    return false;\n  }","id":79725,"modified_method":"private boolean isSignificantJavaElement(final ASTNode current) {\n    final ASTNode treeParent = current.getTreeParent();\n    if (treeParent == null) return true;\n    if (treeParent.getElementType() == ElementType.BINARY_EXPRESSION) return false;\n    return true;\n  }","commit_id":"a49b5318bd72fbf3e3be8631872394dfb312363e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TextRange getSignificantRange(final PsiFile file, final int offset) {\n    final ASTNode elementAtOffset = SourceTreeToPsiMap.psiElementToTree(file.findElementAt(offset));\n    if (file instanceof PsiJavaFile) {\n      ASTNode current = elementAtOffset;\n      while (current != null && !isSignificantJavaElement(current)) {\n        current = current.getTreeParent();\n      }\n      if (current == null) {\n        return file.getTextRange();\n      }\n      else {\n        return current.getTextRange();\n      }\n    } else {\n      return elementAtOffset.getTextRange();\n    }\n  }","id":79726,"modified_method":"private TextRange getSignificantRange(final PsiFile file, final int offset) {\n    final ASTNode elementAtOffset = SourceTreeToPsiMap.psiElementToTree(file.findElementAt(offset));\n    if (file instanceof PsiJavaFile) {\n      ASTNode current = elementAtOffset;\n      while (current != null && !(current.getPsi() instanceof PsiBinaryExpression ||\n                                  current.getPsi() instanceof PsiConditionalExpression)) {\n        current = current.getTreeParent();\n      }\n      if (current == null) {\n        return elementAtOffset.getTextRange();\n      }\n      else {\n        return current.getTextRange();\n      }\n    } else {\n      return elementAtOffset.getTextRange();\n    }\n  }","commit_id":"a49b5318bd72fbf3e3be8631872394dfb312363e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiDirectory findDirectory(VirtualFile vFile) {\n    LOG.assertTrue(myInitialized, \"Access to psi files should be performed only after startup activity\");\n    LOG.assertTrue(!myDisposed);\n\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    LOG.assertTrue(vFile.isValid());\n\n    if (!vFile.isDirectory()) return null;\n\n    dispatchPendingEvents();\n\n    synchronized (PsiLock.LOCK) {\n      PsiDirectory psiDir = myVFileToPsiDirMap.get(vFile);\n      if (psiDir != null) return psiDir;\n\n      if (myProjectRootManager.getFileIndex().isIgnored(vFile)) return null;\n\n      VirtualFile parent = vFile.getParent();\n      if (parent != null) { //?\n        findDirectory(parent);// need to cache parent directory - used for firing events\n      }\n      psiDir = new PsiDirectoryImpl(myManager, vFile);\n      myVFileToPsiDirMap.put(vFile, psiDir);\n      return psiDir;\n    }\n  }","id":79727,"modified_method":"public PsiDirectory findDirectory(VirtualFile vFile) {\n    LOG.assertTrue(myInitialized, \"Access to psi files should be performed only after startup activity\");\n    LOG.assertTrue(!myDisposed);\n\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    LOG.assertTrue(vFile.isValid(), vFile.getName());\n\n    if (!vFile.isDirectory()) return null;\n\n    dispatchPendingEvents();\n\n    synchronized (PsiLock.LOCK) {\n      PsiDirectory psiDir = myVFileToPsiDirMap.get(vFile);\n      if (psiDir != null) return psiDir;\n\n      if (myProjectRootManager.getFileIndex().isIgnored(vFile)) return null;\n\n      VirtualFile parent = vFile.getParent();\n      if (parent != null) { //?\n        findDirectory(parent);// need to cache parent directory - used for firing events\n      }\n      psiDir = new PsiDirectoryImpl(myManager, vFile);\n      myVFileToPsiDirMap.put(vFile, psiDir);\n      return psiDir;\n    }\n  }","commit_id":"a49b5318bd72fbf3e3be8631872394dfb312363e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiSwitchStatement getEnclosingSwitchStatement() {\n    if (getTreeParent().getTreeParent().getElementType() == SWITCH_STATEMENT) return (PsiSwitchStatement)SourceTreeToPsiMap.treeElementToPsi(getTreeParent().getTreeParent());\n    return null;\n  }","id":79728,"modified_method":"public PsiSwitchStatement getEnclosingSwitchStatement() {\n    final CompositeElement guessedSwitch = getTreeParent().getTreeParent();\n    return guessedSwitch != null && guessedSwitch.getElementType() == SWITCH_STATEMENT\n           ? (PsiSwitchStatement)SourceTreeToPsiMap.treeElementToPsi(guessedSwitch)\n           : null;\n  }","commit_id":"f7249af686d07ca139e6b8d92847f504c3c4965e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isTextFragment(final ASTNode node) {\n    return node.getTreeParent().getElementType() == XmlElementType.XML_TEXT\n           || node.getElementType() == XmlElementType.XML_DATA_CHARACTERS\n           || node.getElementType() == JspElementType.JSP_SCRIPTLET\n           || node.getElementType() == JspElementType.JSP_DECLARATION\n           || node.getElementType() == JspElementType.JSP_EXPRESSION\n      ;\n  }","id":79729,"modified_method":"private boolean isTextFragment(final ASTNode node) {\n    final ASTNode parent = node.getTreeParent();\n    return parent != null && parent.getElementType() == XmlElementType.XML_TEXT\n           || node.getElementType() == XmlElementType.XML_DATA_CHARACTERS\n           || node.getElementType() == JspElementType.JSP_SCRIPTLET\n           || node.getElementType() == JspElementType.JSP_DECLARATION\n           || node.getElementType() == JspElementType.JSP_EXPRESSION\n      ;\n  }","commit_id":"3252cdb6ff1e89f2eb986f4ba7ea66a96d371b3f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getKind() {\n    IElementType i = getTreeParent().getElementType();\n    if (i == TokenType.DUMMY_HOLDER) {\n      return myKindWhenDummy;\n    }\n    else if (i == JavaElementType.TYPE) {\n      return getTreeParent().getTreeParent().getPsi() instanceof PsiTypeCodeFragment ? CLASS_OR_PACKAGE_NAME_KIND : CLASS_NAME_KIND;\n    }\n    else if (i == JavaElementType.EXTENDS_LIST || i == JavaElementType.IMPLEMENTS_LIST || i == JavaElementType.EXTENDS_BOUND_LIST || i ==\n                                                                                                                                     JavaElementType.THROWS_LIST ||\n             i == JavaElementType.THIS_EXPRESSION ||\n             i == JavaElementType.SUPER_EXPRESSION ||\n             i == JavaDocElementType.DOC_METHOD_OR_FIELD_REF ||\n             i == JavaDocTokenType.DOC_TAG_VALUE_TOKEN ||\n             i == JavaElementType.REFERENCE_PARAMETER_LIST ||\n             i == JavaElementType.ANNOTATION) {\n      if (isQualified()) {\n        return CLASS_OR_PACKAGE_NAME_KIND;\n      }\n\n      return CLASS_NAME_KIND;\n    }\n    else if (i == JavaElementType.NEW_EXPRESSION) {\n      final ASTNode qualifier = getTreeParent().findChildByRole(ChildRole.QUALIFIER);\n      return qualifier != null ? CLASS_IN_QUALIFIED_NEW_KIND : CLASS_NAME_KIND;\n    }\n    else if (i == JavaElementType.ANONYMOUS_CLASS) {\n      if (getTreeParent().getChildRole(this) == ChildRole.BASE_CLASS_REFERENCE) {\n        LOG.assertTrue(getTreeParent().getTreeParent().getElementType() == JavaElementType.NEW_EXPRESSION);\n        final ASTNode qualifier = getTreeParent().getTreeParent().findChildByRole(ChildRole.QUALIFIER);\n        return qualifier != null ? CLASS_IN_QUALIFIED_NEW_KIND : CLASS_NAME_KIND;\n      }\n      else {\n        return CLASS_OR_PACKAGE_NAME_KIND; // uncomplete code\n      }\n    }\n    else if (i == JavaElementType.PACKAGE_STATEMENT) {\n      return PACKAGE_NAME_KIND;\n    }\n    else if (i == JavaElementType.IMPORT_STATEMENT) {\n      final boolean isOnDemand = ((PsiImportStatement)SourceTreeToPsiMap.treeElementToPsi(getTreeParent())).isOnDemand();\n      return isOnDemand ? CLASS_FQ_OR_PACKAGE_NAME_KIND : CLASS_FQ_NAME_KIND;\n    }\n    else if (i == JavaElementType.IMPORT_STATIC_STATEMENT) {\n      return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n    }\n    else if (i == JavaElementType.JAVA_CODE_REFERENCE) {\n      final int parentKind = ((PsiJavaCodeReferenceElementImpl)getTreeParent()).getKind();\n      switch (parentKind) {\n      case CLASS_NAME_KIND:\n             return CLASS_OR_PACKAGE_NAME_KIND;\n\n      case PACKAGE_NAME_KIND:\n             return PACKAGE_NAME_KIND;\n\n      case CLASS_OR_PACKAGE_NAME_KIND:\n             return CLASS_OR_PACKAGE_NAME_KIND;\n\n      case CLASS_FQ_NAME_KIND:\n             return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n\n      case CLASS_FQ_OR_PACKAGE_NAME_KIND:\n             return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n\n      case CLASS_IN_QUALIFIED_NEW_KIND:\n             return CLASS_IN_QUALIFIED_NEW_KIND; //??\n\n      default:\n             LOG.assertTrue(false);\n             return -1;\n      }\n    }\n    else if (i == JavaElementType.CLASS || i == JavaElementType.PARAMETER_LIST || i == TokenType.ERROR_ELEMENT) {\n      return CLASS_OR_PACKAGE_NAME_KIND;\n    }\n    else if (i == JavaElementType.IMPORT_STATIC_REFERENCE) {\n      return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n    }\n    else if (i == JavaDocElementType.DOC_TAG || i == JavaDocElementType.DOC_INLINE_TAG || i == JavaDocElementType.DOC_REFERENCE_HOLDER || i ==\n                                                                                                                                          JavaDocElementType.DOC_TYPE_HOLDER) {\n      return CLASS_OR_PACKAGE_NAME_KIND;\n    }\n    else if (isCodeFragmentType(i)) {\n      PsiJavaCodeReferenceCodeFragment fragment = (PsiJavaCodeReferenceCodeFragment)getTreeParent().getPsi();\n      return fragment.isClassesAccepted() ? CLASS_FQ_OR_PACKAGE_NAME_KIND : PACKAGE_NAME_KIND;\n    }\n    else {\n      LOG.error(\"Unknown parent for java code reference:\" + getTreeParent());\n      return CLASS_NAME_KIND;\n    }\n  }","id":79730,"modified_method":"public int getKind() {\n    IElementType i = getTreeParent().getElementType();\n    if (i == TokenType.DUMMY_HOLDER) {\n      return myKindWhenDummy;\n    }\n    if (i == JavaElementType.TYPE) {\n      return getTreeParent().getTreeParent().getPsi() instanceof PsiTypeCodeFragment ? CLASS_OR_PACKAGE_NAME_KIND : CLASS_NAME_KIND;\n    }\n    if (i == JavaElementType.EXTENDS_LIST ||\n        i == JavaElementType.IMPLEMENTS_LIST ||\n        i == JavaElementType.EXTENDS_BOUND_LIST ||\n        i == JavaElementType.THROWS_LIST ||\n        i == JavaElementType.THIS_EXPRESSION ||\n        i == JavaElementType.SUPER_EXPRESSION ||\n        i == JavaDocElementType.DOC_METHOD_OR_FIELD_REF ||\n        i == JavaDocTokenType.DOC_TAG_VALUE_TOKEN ||\n        i == JavaElementType.REFERENCE_PARAMETER_LIST ||\n        i == JavaElementType.ANNOTATION) {\n      if (isQualified()) {\n        return CLASS_OR_PACKAGE_NAME_KIND;\n      }\n\n      return CLASS_NAME_KIND;\n    }\n    if (i == JavaElementType.NEW_EXPRESSION) {\n      final ASTNode qualifier = getTreeParent().findChildByRole(ChildRole.QUALIFIER);\n      return qualifier != null ? CLASS_IN_QUALIFIED_NEW_KIND : CLASS_NAME_KIND;\n    }\n    if (i == JavaElementType.ANONYMOUS_CLASS) {\n      if (getTreeParent().getChildRole(this) == ChildRole.BASE_CLASS_REFERENCE) {\n        LOG.assertTrue(getTreeParent().getTreeParent().getElementType() == JavaElementType.NEW_EXPRESSION);\n        final ASTNode qualifier = getTreeParent().getTreeParent().findChildByRole(ChildRole.QUALIFIER);\n        return qualifier != null ? CLASS_IN_QUALIFIED_NEW_KIND : CLASS_NAME_KIND;\n      }\n      else {\n        return CLASS_OR_PACKAGE_NAME_KIND; // uncomplete code\n      }\n    }\n    if (i == JavaElementType.PACKAGE_STATEMENT) {\n      return PACKAGE_NAME_KIND;\n    }\n    if (i == JavaElementType.IMPORT_STATEMENT) {\n      final boolean isOnDemand = ((PsiImportStatement)SourceTreeToPsiMap.treeElementToPsi(getTreeParent())).isOnDemand();\n      return isOnDemand ? CLASS_FQ_OR_PACKAGE_NAME_KIND : CLASS_FQ_NAME_KIND;\n    }\n    if (i == JavaElementType.IMPORT_STATIC_STATEMENT) {\n      return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n    }\n    if (i == JavaElementType.JAVA_CODE_REFERENCE) {\n      final int parentKind = ((PsiJavaCodeReferenceElementImpl)getTreeParent()).getKind();\n      switch (parentKind) {\n        case CLASS_NAME_KIND:\n          return CLASS_OR_PACKAGE_NAME_KIND;\n\n        case PACKAGE_NAME_KIND:\n          return PACKAGE_NAME_KIND;\n\n        case CLASS_OR_PACKAGE_NAME_KIND:\n          return CLASS_OR_PACKAGE_NAME_KIND;\n\n        case CLASS_FQ_NAME_KIND:\n          return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n\n        case CLASS_FQ_OR_PACKAGE_NAME_KIND:\n          return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n\n        case CLASS_IN_QUALIFIED_NEW_KIND:\n          return CLASS_IN_QUALIFIED_NEW_KIND; //??\n\n        default:\n          LOG.assertTrue(false);\n          return -1;\n      }\n    }\n    if (i == JavaElementType.CLASS || i == JavaElementType.PARAMETER_LIST || i == TokenType.ERROR_ELEMENT) {\n      return CLASS_OR_PACKAGE_NAME_KIND;\n    }\n    if (i == JavaElementType.IMPORT_STATIC_REFERENCE) {\n      return CLASS_FQ_OR_PACKAGE_NAME_KIND;\n    }\n    if (i == JavaDocElementType.DOC_TAG ||\n        i == JavaDocElementType.DOC_INLINE_TAG ||\n        i == JavaDocElementType.DOC_REFERENCE_HOLDER ||\n        i == JavaDocElementType.DOC_TYPE_HOLDER) {\n      return CLASS_OR_PACKAGE_NAME_KIND;\n    }\n    if (isCodeFragmentType(i)) {\n      PsiJavaCodeReferenceCodeFragment fragment = (PsiJavaCodeReferenceCodeFragment)getTreeParent().getPsi();\n      return fragment.isClassesAccepted() ? CLASS_FQ_OR_PACKAGE_NAME_KIND : PACKAGE_NAME_KIND;\n    }\n    CompositeElement parent = getTreeParent();\n    String message = \"Unknown parent for java code reference: '\" + parent +\"'; \" +\n                     \"Type: \"+i+\"; \\n\";\n\n    while (parent != null && parent.getPsi() instanceof PsiExpression) {\n      parent = parent.getTreeParent();\n      message += \" Parent: '\" + parent+\"'; \";\n    }\n    LOG.error(message);\n    return CLASS_NAME_KIND;\n  }","commit_id":"78f6fa37a49ba20f6c4ba95331b32d38603eb96b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiModifierList getModifierList() {\n    CompositeElement first = (CompositeElement)TreeUtil.findChild(getTreeParent(), LOCAL_VARIABLE);\n    return (PsiModifierList)first.findChildByRoleAsPsiElement(ChildRole.MODIFIER_LIST);\n  }","id":79731,"modified_method":"public PsiModifierList getModifierList() {\n    CompositeElement parent = getTreeParent();\n    if (parent == null) return null;\n    CompositeElement first = (CompositeElement)TreeUtil.findChild(parent, LOCAL_VARIABLE);\n    return (PsiModifierList)first.findChildByRoleAsPsiElement(ChildRole.MODIFIER_LIST);\n  }","commit_id":"38836e42f9e20e0b894aec6d60703d20e98ceb7f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement getParent() {\n    if (myParent == null) {\n      myParent = myNode.getTreeParent().getPsi();\n    }\n    return myParent;\n  }","id":79732,"modified_method":"public PsiElement getParent() {\n    if (myParent == null) {\n      final ASTNode treeParent = myNode.getTreeParent();\n      if (treeParent != null) {\n        myParent = treeParent.getPsi();\n      }\n    }\n    return myParent;\n  }","commit_id":"3a2d7ff43eda9e0d8fa94acd942ff6fbda958d25","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void onInvalidated(@NotNull ASTNode treeElement) {\n    if (!PsiInvalidElementAccessException.isTrackingInvalidation()) {\n      return;\n    }\n    if (PsiInvalidElementAccessException.findInvalidationTrace(treeElement) != null) {\n      return;\n    }\n\n    Object trace = ourPsiModificationTrace.get();\n    if (trace == null) {\n      trace = new Throwable();\n      LOG.info(\"PSI invalidated outside transaction\", (Throwable)trace);\n    }\n    PsiInvalidElementAccessException.setInvalidationTrace(treeElement, trace);\n  }","id":79733,"modified_method":"public static void onInvalidated(@NotNull ASTNode treeElement) {\n    Object trace = calcInvalidationTrace(treeElement);\n    if (trace != null) {\n      PsiInvalidElementAccessException.setInvalidationTrace(treeElement, trace);\n    }\n  }","commit_id":"3b0a609016b04c811fa95e40e061722853817615","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setViewProvider(@NotNull final VirtualFile virtualFile, final FileViewProvider fileViewProvider) {\n    if (!(virtualFile instanceof VirtualFileWindow)) {\n      if (fileViewProvider == null) {\n        myVFileToViewProviderMap.remove(virtualFile);\n\n        Document document = FileDocumentManager.getInstance().getCachedDocument(virtualFile);\n        if (document != null) {\n          PsiDocumentManagerBase.cachePsi(document, null);\n        }\n      }\n      else {\n        myVFileToViewProviderMap.put(virtualFile, fileViewProvider);\n      }\n    }\n  }","id":79734,"modified_method":"@Override\n  public void setViewProvider(@NotNull final VirtualFile virtualFile, @Nullable final FileViewProvider fileViewProvider) {\n    FileViewProvider prev = findCachedViewProvider(virtualFile);\n    if (prev != null) {\n      DebugUtil.startPsiModification(null);\n      try {\n        DebugUtil.onInvalidated(prev);\n      }\n      finally {\n        DebugUtil.finishPsiModification();\n      }\n    }\n\n    if (!(virtualFile instanceof VirtualFileWindow)) {\n      if (fileViewProvider == null) {\n        myVFileToViewProviderMap.remove(virtualFile);\n\n        Document document = FileDocumentManager.getInstance().getCachedDocument(virtualFile);\n        if (document != null) {\n          PsiDocumentManagerBase.cachePsi(document, null);\n        }\n      }\n      else {\n        myVFileToViewProviderMap.put(virtualFile, fileViewProvider);\n      }\n    }\n  }","commit_id":"3b0a609016b04c811fa95e40e061722853817615","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Object findInvalidationTrace(ASTNode element) {\n    while (element != null) {\n      Object trace = element.getUserData(INVALIDATION_TRACE);\n      if (trace != null) {\n        return trace;\n      }\n      element = element.getTreeParent();\n    }\n    return null;\n  }","id":79735,"modified_method":"public static Object findInvalidationTrace(@Nullable ASTNode element) {\n    while (element != null) {\n      Object trace = element.getUserData(INVALIDATION_TRACE);\n      if (trace != null) {\n        return trace;\n      }\n      ASTNode parent = element.getTreeParent();\n      if (parent == null && element instanceof FileASTNode) {\n        PsiElement psi = element.getPsi();\n        trace = psi == null ? null : psi.getUserData(INVALIDATION_TRACE);\n        if (trace != null) {\n          return trace;\n        }\n      }\n      element = parent;\n    }\n    return null;\n  }","commit_id":"3b0a609016b04c811fa95e40e061722853817615","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void setInvalidationTrace(ASTNode element, Object trace) {\n    element.putUserData(INVALIDATION_TRACE, trace);\n  }","id":79736,"modified_method":"public static void setInvalidationTrace(UserDataHolder element, Object trace) {\n    element.putUserData(INVALIDATION_TRACE, trace);\n  }","commit_id":"3b0a609016b04c811fa95e40e061722853817615","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setRange(final TextRange range) {\n    myRange = range;\n    getTreeParent().subtreeChanged();\n  }","id":79737,"modified_method":"public void setRange(final TextRange range) {\n    myRange = range;\n    final CompositeElement element = getTreeParent();\n    if(element != null) element.subtreeChanged();\n  }","commit_id":"97d06471c0c18e5241a2d8cc9b30d98ef481f5c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CloneBlock(Integer snapshotId, String hash, String resourceKey, Integer indexInFile, Integer startLine, Integer endLine) {\n    this.snapshotId = snapshotId;\n    this.hash = hash;\n    this.indexInFile = indexInFile;\n    this.resourceKey = resourceKey;\n    this.startLine = startLine;\n    this.endLine = endLine;\n  }","id":79738,"modified_method":"public CloneBlock(Integer projectSnapshotId, Integer snapshotId, String hash, Integer indexInFile, Integer startLine, Integer endLine) {\n    this.projectSnapshotId = projectSnapshotId;\n    this.snapshotId = snapshotId;\n    this.hash = hash;\n    this.indexInFile = indexInFile;\n    this.startLine = startLine;\n    this.endLine = endLine;\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Collection<Block> getBySequenceHash(ByteArray sequenceHash) {\n    List<Block> result = cache.get(sequenceHash);\n    if (result != null) {\n      return result;\n    } else {\n      // not in cache\n      return Collections.emptyList();\n    }\n  }","id":79739,"modified_method":"public Collection<Block> getByHash(ByteArray hash) {\n    Collection<Block> result = cache.get(hash);\n    if (result != null) {\n      return result;\n    } else {\n      return Collections.emptyList();\n    }\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DbCloneIndex(DatabaseSession session, Integer currentSnapshotId, Integer lastSnapshotId) {\n    this.session = session;\n    this.currentSnapshotId = currentSnapshotId;\n    this.lastSnapshotId = lastSnapshotId;\n  }","id":79740,"modified_method":"/**\n   * For tests.\n   */\n  DbCloneIndex(DatabaseSession session, ResourcePersister resourcePersister, Integer currentProjectSnapshotId, Integer prevSnapshotId) {\n    this.session = session;\n    this.resourcePersister = resourcePersister;\n    this.currentProjectSnapshotId = currentProjectSnapshotId;\n    this.lastSnapshotId = prevSnapshotId;\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldInsert() {\n    setupData(\"fixture\");\n\n    index.insert(new Block(\"baz\", new ByteArray(\"bb\"), 0, 0, 1));\n\n    checkTables(\"shouldInsert\", \"clone_blocks\");\n  }","id":79741,"modified_method":"@Test\n  public void shouldInsert() {\n    Resource resource = new JavaFile(\"foo\");\n    index = spy(new DbCloneIndex(getSession(), null, 1, null));\n    doReturn(2).when(index).getSnapshotIdFor(resource);\n    setupData(\"shouldInsert\");\n\n    index.insert(resource, Arrays.asList(new Block(\"foo\", new ByteArray(\"bb\"), 0, 1, 2)));\n\n    checkTables(\"shouldInsert\", \"clone_blocks\");\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldGetByHash() {\n    setupData(\"fixture\");\n\n    index.prepareCache(\"foo\");\n    Collection<Block> blocks = index.getBySequenceHash(new ByteArray(\"aa\"));\n    Iterator<Block> blocksIterator = blocks.iterator();\n\n    assertThat(blocks.size(), is(1));\n\n    Block block = blocksIterator.next();\n    assertThat(block.getResourceId(), is(\"bar-last\"));\n  }","id":79742,"modified_method":"@Test\n  public void shouldGetByHash() {\n    Resource resource = new JavaFile(\"foo\");\n    index = spy(new DbCloneIndex(getSession(), null, 9, 7));\n    doReturn(10).when(index).getSnapshotIdFor(resource);\n    setupData(\"shouldGetByHash\");\n\n    index.prepareCache(resource);\n    Collection<Block> blocks = index.getByHash(new ByteArray(\"aa\"));\n    Iterator<Block> blocksIterator = blocks.iterator();\n\n    assertThat(blocks.size(), is(1));\n\n    Block block = blocksIterator.next();\n    assertThat(\"block resourceId\", block.getResourceId(), is(\"bar-last\"));\n    assertThat(\"block hash\", block.getBlockHash(), is(new ByteArray(\"aa\")));\n    assertThat(\"block index in file\", block.getIndexInFile(), is(0));\n    assertThat(\"block start line\", block.getFirstLineNumber(), is(1));\n    assertThat(\"block end line\", block.getLastLineNumber(), is(2));\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static void deleteSnapshotsData(DatabaseSession session, List<Integer> snapshotIds) {\n    deleteMeasuresBySnapshotId(session, snapshotIds);\n    deleteSources(session, snapshotIds);\n    deleteViolations(session, snapshotIds);\n    deleteDependencies(session, snapshotIds);\n    deleteSnapshots(session, snapshotIds);\n  }","id":79743,"modified_method":"public static void deleteSnapshotsData(DatabaseSession session, List<Integer> snapshotIds) {\n    deleteMeasuresBySnapshotId(session, snapshotIds);\n    deleteSources(session, snapshotIds);\n    deleteViolations(session, snapshotIds);\n    deleteDependencies(session, snapshotIds);\n    deleteCloneBlocks(session, snapshotIds);\n    deleteSnapshots(session, snapshotIds);\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void analyse(Project project, SensorContext context) {\n    List<InputFile> inputFiles = project.getFileSystem().mainFiles(project.getLanguageKey());\n    if (inputFiles.isEmpty()) {\n      return;\n    }\n\n    // Create index\n    CloneIndex index = new PackedMemoryCloneIndex();\n    if (isCrossProject(project)) {\n      Logs.INFO.info(\"Enabled cross-project analysis\");\n      Snapshot currentSnapshot = resourcePersister.getSnapshot(project);\n      Snapshot lastSnapshot = resourcePersister.getLastSnapshot(currentSnapshot, false);\n      DbCloneIndex db = new DbCloneIndex(dbSession, currentSnapshot.getId(), lastSnapshot == null ? null : lastSnapshot.getId());\n      index = new CombinedCloneIndex(index, db);\n    }\n\n    TokenChunker tokenChunker = JavaTokenProducer.build();\n    StatementChunker statementChunker = JavaStatementBuilder.build();\n    BlockChunker blockChunker = new BlockChunker(BLOCK_SIZE);\n\n    for (InputFile inputFile : inputFiles) {\n      File file = inputFile.getFile();\n      TokenQueue tokenQueue = tokenChunker.chunk(file);\n      List<Statement> statements = statementChunker.chunk(tokenQueue);\n      Resource resource = getResource(inputFile);\n      List<Block> blocks = blockChunker.chunk(getFullKey(project, resource), statements);\n      for (Block block : blocks) {\n        index.insert(block);\n      }\n    }\n\n    // Detect\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = getResource(inputFile);\n\n      List<Block> fileBlocks = Lists.newArrayList(index.getByResourceId(getFullKey(project, resource)));\n      List<CloneGroup> clones = OriginalCloneDetectionAlgorithm.detect(index, fileBlocks);\n      if (!clones.isEmpty()) {\n        // Save\n        DuplicationsData data = new DuplicationsData();\n        for (CloneGroup clone : clones) {\n          poplulateData(data, clone);\n        }\n        data.save(context, resource);\n      }\n    }\n  }","id":79744,"modified_method":"public void analyse(Project project, SensorContext context) {\n    List<InputFile> inputFiles = project.getFileSystem().mainFiles(project.getLanguageKey());\n    if (inputFiles.isEmpty()) {\n      return;\n    }\n\n    // Create index\n    final SonarCloneIndex index;\n    if (isCrossProject(project)) {\n      Logs.INFO.info(\"Enabled cross-project analysis\");\n      index = new SonarCloneIndex(new DbCloneIndex(dbSession, resourcePersister, project));\n    } else {\n      index = new SonarCloneIndex();\n    }\n\n    TokenChunker tokenChunker = JavaTokenProducer.build();\n    StatementChunker statementChunker = JavaStatementBuilder.build();\n    BlockChunker blockChunker = new BlockChunker(BLOCK_SIZE);\n\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = getResource(inputFile);\n      String resourceKey = getFullKey(project, resource);\n\n      File file = inputFile.getFile();\n      TokenQueue tokenQueue = tokenChunker.chunk(file);\n      List<Statement> statements = statementChunker.chunk(tokenQueue);\n      List<Block> blocks = blockChunker.chunk(resourceKey, statements);\n      index.insert(resource, blocks);\n    }\n\n    // Detect\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = getResource(inputFile);\n      String resourceKey = getFullKey(project, resource);\n\n      Collection<Block> fileBlocks = index.getByResource(resource, resourceKey);\n      List<CloneGroup> clones = OriginalCloneDetectionAlgorithm.detect(index, fileBlocks);\n      if (!clones.isEmpty()) {\n        // Save\n        DuplicationsData data = new DuplicationsData();\n        for (CloneGroup clone : clones) {\n          poplulateData(data, clone);\n        }\n        data.save(context, resource);\n      }\n    }\n  }","commit_id":"5ff8c8c74e58a9df51be059908a064a43a67c50d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List getExtensions() {\n    return Arrays.asList(CpdSensor.class, SumDuplicationsDecorator.class, DuplicationDensityDecorator.class,\n        SonarEngine.class,\n        PmdEngine.class,\n        SonarBridgeEngine.class);\n  }","id":79745,"modified_method":"public List getExtensions() {\n    return Arrays.asList(CpdSensor.class, SumDuplicationsDecorator.class, DuplicationDensityDecorator.class,\n        IndexFactory.class,\n        SonarEngine.class,\n        PmdEngine.class,\n        SonarBridgeEngine.class);\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void skipByLanguage() {\n    PropertiesConfiguration conf = new PropertiesConfiguration();\n    conf.setProperty(\"sonar.cpd.skip\", \"false\");\n    conf.setProperty(\"sonar.cpd.php.skip\", \"true\");\n\n    Project phpProject = createPhpProject().setConfiguration(conf);\n    Project javaProject = createJavaProject().setConfiguration(conf);\n\n    CpdSensor sensor = new CpdSensor(new SonarEngine(), new PmdEngine(new CpdMapping[0]));\n    assertTrue(sensor.isSkipped(phpProject));\n    assertFalse(sensor.isSkipped(javaProject));\n  }","id":79746,"modified_method":"@Test\n  public void skipByLanguage() {\n    PropertiesConfiguration conf = new PropertiesConfiguration();\n    conf.setProperty(\"sonar.cpd.skip\", \"false\");\n    conf.setProperty(\"sonar.cpd.php.skip\", \"true\");\n\n    Project phpProject = createPhpProject().setConfiguration(conf);\n    Project javaProject = createJavaProject().setConfiguration(conf);\n\n    CpdSensor sensor = new CpdSensor(new SonarEngine(new IndexFactory()), new PmdEngine(new CpdMapping[0]));\n    assertTrue(sensor.isSkipped(phpProject));\n    assertFalse(sensor.isSkipped(javaProject));\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void doNotSkipByDefault() {\n    Project project = createJavaProject().setConfiguration(new PropertiesConfiguration());\n\n    CpdSensor sensor = new CpdSensor(new SonarEngine(), new PmdEngine(new CpdMapping[0]));\n    assertFalse(sensor.isSkipped(project));\n  }","id":79747,"modified_method":"@Test\n  public void doNotSkipByDefault() {\n    Project project = createJavaProject().setConfiguration(new PropertiesConfiguration());\n\n    CpdSensor sensor = new CpdSensor(new SonarEngine(new IndexFactory()), new PmdEngine(new CpdMapping[0]));\n    assertFalse(sensor.isSkipped(project));\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void engine() {\n    PropertiesConfiguration conf = new PropertiesConfiguration();\n    Project project = createJavaProject().setConfiguration(conf);\n    CpdSensor sensor = new CpdSensor(new SonarEngine(), new PmdEngine(new CpdMapping[0]));\n\n    assertThat(sensor.isSonarEngineEnabled(project), is(true));\n    conf.setProperty(\"sonar.cpd.engine\", \"pmd\");\n    assertThat(sensor.isSonarEngineEnabled(project), is(false));\n  }","id":79748,"modified_method":"@Test\n  public void engine() {\n    PropertiesConfiguration conf = new PropertiesConfiguration();\n    Project project = createJavaProject().setConfiguration(conf);\n    CpdSensor sensor = new CpdSensor(new SonarEngine(new IndexFactory()), new PmdEngine(new CpdMapping[0]));\n\n    assertThat(sensor.isSonarEngineEnabled(project), is(true));\n    conf.setProperty(\"sonar.cpd.engine\", \"pmd\");\n    assertThat(sensor.isSonarEngineEnabled(project), is(false));\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void generalSkip() {\n    PropertiesConfiguration conf = new PropertiesConfiguration();\n    conf.setProperty(\"sonar.cpd.skip\", \"true\");\n\n    Project project = createJavaProject().setConfiguration(conf);\n\n    CpdSensor sensor = new CpdSensor(new SonarEngine(), new PmdEngine(new CpdMapping[0]));\n    assertTrue(sensor.isSkipped(project));\n  }","id":79749,"modified_method":"@Test\n  public void generalSkip() {\n    PropertiesConfiguration conf = new PropertiesConfiguration();\n    conf.setProperty(\"sonar.cpd.skip\", \"true\");\n\n    Project project = createJavaProject().setConfiguration(conf);\n\n    CpdSensor sensor = new CpdSensor(new SonarEngine(new IndexFactory()), new PmdEngine(new CpdMapping[0]));\n    assertTrue(sensor.isSkipped(project));\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void prepareCache(Resource resource) {\n    int resourceSnapshotId = getSnapshotIdFor(resource);\n    List<DuplicationUnitDto> units = dao.selectCandidates(resourceSnapshotId, lastSnapshotId);\n    cache.clear();\n    // TODO Godin: maybe remove conversion of units to blocks?\n    for (DuplicationUnitDto unit : units) {\n      String hash = unit.getHash();\n      String resourceKey = unit.getResourceKey();\n      int indexInFile = unit.getIndexInFile();\n      int startLine = unit.getStartLine();\n      int endLine = unit.getEndLine();\n\n      // TODO Godin: in fact we could work directly with id instead of key - this will allow to decrease memory consumption\n      Block block = new Block(resourceKey, new ByteArray(hash), indexInFile, startLine, endLine);\n\n      // Group blocks by hash\n      Collection<Block> sameHash = cache.get(block.getBlockHash());\n      if (sameHash == null) {\n        sameHash = Lists.newArrayList();\n        cache.put(block.getBlockHash(), sameHash);\n      }\n      sameHash.add(block);\n    }\n  }","id":79750,"modified_method":"public void prepareCache(Resource resource) {\n    int resourceSnapshotId = getSnapshotIdFor(resource);\n    String languageKey = resource.getLanguage().getKey();\n    List<DuplicationUnitDto> units = dao.selectCandidates(resourceSnapshotId, lastSnapshotId, languageKey);\n    cache.clear();\n    // TODO Godin: maybe remove conversion of units to blocks?\n    for (DuplicationUnitDto unit : units) {\n      String hash = unit.getHash();\n      String resourceKey = unit.getResourceKey();\n      int indexInFile = unit.getIndexInFile();\n      int startLine = unit.getStartLine();\n      int endLine = unit.getEndLine();\n\n      // TODO Godin: in fact we could work directly with id instead of key - this will allow to decrease memory consumption\n      Block block = new Block(resourceKey, new ByteArray(hash), indexInFile, startLine, endLine);\n\n      // Group blocks by hash\n      Collection<Block> sameHash = cache.get(block.getBlockHash());\n      if (sameHash == null) {\n        sameHash = Lists.newArrayList();\n        cache.put(block.getBlockHash(), sameHash);\n      }\n      sameHash.add(block);\n    }\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<DuplicationUnitDto> selectCandidates(int resourceSnapshotId, Integer lastSnapshotId) {\n    SqlSession session = mybatis.openSession();\n    try {\n      DuplicationMapper mapper = session.getMapper(DuplicationMapper.class);\n      return mapper.selectCandidates(resourceSnapshotId, lastSnapshotId);\n    } finally {\n      MyBatis.closeSessionQuietly(session);\n    }\n  }","id":79751,"modified_method":"public List<DuplicationUnitDto> selectCandidates(int resourceSnapshotId, Integer lastSnapshotId, String language) {\n    SqlSession session = mybatis.openSession();\n    try {\n      DuplicationMapper mapper = session.getMapper(DuplicationMapper.class);\n      return mapper.selectCandidates(resourceSnapshotId, lastSnapshotId, language);\n    } finally {\n      MyBatis.closeSessionQuietly(session);\n    }\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldGetByHash() throws Exception {\n    setupData(\"shouldGetByHash\");\n\n    List<DuplicationUnitDto> blocks = dao.selectCandidates(10, 7);\n    assertThat(blocks.size(), is(1));\n\n    DuplicationUnitDto block = blocks.get(0);\n    assertThat(\"block resourceId\", block.getResourceKey(), is(\"bar-last\"));\n    assertThat(\"block hash\", block.getHash(), is(\"aa\"));\n    assertThat(\"block index in file\", block.getIndexInFile(), is(0));\n    assertThat(\"block start line\", block.getStartLine(), is(1));\n    assertThat(\"block end line\", block.getEndLine(), is(2));\n\n    // check null for lastSnapshotId\n    blocks = dao.selectCandidates(10, null);\n    assertThat(blocks.size(), is(2));\n  }","id":79752,"modified_method":"@Test\n  public void shouldGetByHash() throws Exception {\n    setupData(\"shouldGetByHash\");\n\n    List<DuplicationUnitDto> blocks = dao.selectCandidates(10, 7, \"java\");\n    assertThat(blocks.size(), is(1));\n\n    DuplicationUnitDto block = blocks.get(0);\n    assertThat(\"block resourceId\", block.getResourceKey(), is(\"bar-last\"));\n    assertThat(\"block hash\", block.getHash(), is(\"aa\"));\n    assertThat(\"block index in file\", block.getIndexInFile(), is(0));\n    assertThat(\"block start line\", block.getStartLine(), is(1));\n    assertThat(\"block end line\", block.getEndLine(), is(2));\n\n    // check null for lastSnapshotId\n    blocks = dao.selectCandidates(10, null, \"java\");\n    assertThat(blocks.size(), is(2));\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SonarBridgeEngine() {\n    this.mappings = null;\n  }","id":79753,"modified_method":"public SonarBridgeEngine(IndexFactory indexFactory) {\n    this(indexFactory, null);\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void analyse(Project project, SensorContext context) {\n    ProjectFileSystem fileSystem = project.getFileSystem();\n    List<InputFile> inputFiles = fileSystem.mainFiles(project.getLanguageKey());\n    if (inputFiles.isEmpty()) {\n      return;\n    }\n\n    CpdMapping mapping = getMapping(project.getLanguage());\n\n    // Create index\n    BlockChunker blockChunker = new BlockChunker(getMinimumTokens(project));\n    CloneIndex index = new PackedMemoryCloneIndex();\n    TokenizerBridge bridge = new TokenizerBridge(mapping.getTokenizer(), fileSystem.getSourceCharset().name());\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = mapping.createResource(inputFile.getFile(), fileSystem.getSourceDirs());\n      String resourceId = getFullKey(project, resource);\n      List<Block> blocks = blockChunker.chunk(resourceId, bridge.tokenize(inputFile.getFile()));\n      for (Block block : blocks) {\n        index.insert(block);\n      }\n    }\n    bridge.clearCache();\n\n    // Detect\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = mapping.createResource(inputFile.getFile(), fileSystem.getSourceDirs());\n      String resourceId = getFullKey(project, resource);\n      Collection<Block> fileBlocks = index.getByResourceId(resourceId);\n      List<CloneGroup> duplications = SuffixTreeCloneDetectionAlgorithm.detect(index, fileBlocks);\n      SonarEngine.save(context, resource, duplications);\n    }\n  }","id":79754,"modified_method":"@Override\n  public void analyse(Project project, SensorContext context) {\n    ProjectFileSystem fileSystem = project.getFileSystem();\n    List<InputFile> inputFiles = fileSystem.mainFiles(project.getLanguageKey());\n    if (inputFiles.isEmpty()) {\n      return;\n    }\n\n    CpdMapping mapping = getMapping(project.getLanguage());\n\n    // Create index\n    SonarDuplicationsIndex index = indexFactory.create(project);\n\n    BlockChunker blockChunker = new BlockChunker(BLOCK_SIZE);\n    TokenizerBridge bridge = new TokenizerBridge(mapping.getTokenizer(), fileSystem.getSourceCharset().name());\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = mapping.createResource(inputFile.getFile(), fileSystem.getSourceDirs());\n      String resourceId = SonarEngine.getFullKey(project, resource);\n      List<Block> blocks = blockChunker.chunk(resourceId, bridge.tokenize(inputFile.getFile()));\n      index.insert(resource, blocks);\n    }\n    bridge.clearCache();\n\n    // Detect\n    for (InputFile inputFile : inputFiles) {\n      Resource resource = mapping.createResource(inputFile.getFile(), fileSystem.getSourceDirs());\n      String resourceKey = SonarEngine.getFullKey(project, resource);\n\n      Collection<Block> fileBlocks = index.getByResource(resource, resourceKey);\n      List<CloneGroup> duplications = SuffixTreeCloneDetectionAlgorithm.detect(index, fileBlocks);\n      SonarEngine.save(context, resource, duplications);\n    }\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SonarBridgeEngine(CpdMapping[] mappings) {\n    this.mappings = mappings;\n  }","id":79755,"modified_method":"public SonarBridgeEngine(IndexFactory indexFactory, CpdMapping[] mappings) {\n    this.indexFactory = indexFactory;\n    this.mappings = mappings;\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void analyse(Project project, SensorContext context) {\n    List<InputFile> inputFiles = project.getFileSystem().mainFiles(project.getLanguageKey());\n    if (inputFiles.isEmpty()) {\n      return;\n    }\n\n    // Create index\n    final SonarDuplicationsIndex index;\n    if (isCrossProject(project)) {\n      LOG.info(\"Cross-project analysis enabled\");\n      index = new SonarDuplicationsIndex(new DbDuplicationsIndex(resourcePersister, project, dao));\n    } else {\n      LOG.info(\"Cross-project analysis disabled\");\n      index = new SonarDuplicationsIndex();\n    }\n\n    TokenChunker tokenChunker = JavaTokenProducer.build();\n    StatementChunker statementChunker = JavaStatementBuilder.build();\n    BlockChunker blockChunker = new BlockChunker(BLOCK_SIZE);\n\n    for (InputFile inputFile : inputFiles) {\n      LOG.debug(\"Populating index from {}\", inputFile.getFile());\n      Resource resource = getResource(inputFile);\n      String resourceKey = getFullKey(project, resource);\n\n      List<Statement> statements;\n\n      Reader reader = null;\n      try {\n        reader = new InputStreamReader(new FileInputStream(inputFile.getFile()), project.getFileSystem().getSourceCharset());\n        statements = statementChunker.chunk(tokenChunker.chunk(reader));\n      } catch (FileNotFoundException e) {\n        throw new SonarException(e);\n      } finally {\n        IOUtils.closeQuietly(reader);\n      }\n\n      List<Block> blocks = blockChunker.chunk(resourceKey, statements);\n      index.insert(resource, blocks);\n    }\n\n    // Detect\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    try {\n      for (InputFile inputFile : inputFiles) {\n        LOG.debug(\"Detection of duplications for {}\", inputFile.getFile());\n        Resource resource = getResource(inputFile);\n        String resourceKey = getFullKey(project, resource);\n\n        Collection<Block> fileBlocks = index.getByResource(resource, resourceKey);\n\n        List<CloneGroup> clones;\n        try {\n          clones = executorService.submit(new Task(index, fileBlocks)).get(TIMEOUT, TimeUnit.SECONDS);\n        } catch (TimeoutException e) {\n          clones = null;\n          LOG.warn(\"Timeout during detection of duplications for \" + inputFile.getFile(), e);\n        } catch (InterruptedException e) {\n          throw new SonarException(e);\n        } catch (ExecutionException e) {\n          throw new SonarException(e);\n        }\n\n        save(context, resource, clones);\n      }\n    } finally {\n      executorService.shutdown();\n    }\n  }","id":79756,"modified_method":"@Override\n  public void analyse(Project project, SensorContext context) {\n    List<InputFile> inputFiles = project.getFileSystem().mainFiles(project.getLanguageKey());\n    if (inputFiles.isEmpty()) {\n      return;\n    }\n\n    // Create index\n    final SonarDuplicationsIndex index = indexFactory.create(project);\n\n    TokenChunker tokenChunker = JavaTokenProducer.build();\n    StatementChunker statementChunker = JavaStatementBuilder.build();\n    BlockChunker blockChunker = new BlockChunker(BLOCK_SIZE);\n\n    for (InputFile inputFile : inputFiles) {\n      LOG.debug(\"Populating index from {}\", inputFile.getFile());\n      Resource resource = getResource(inputFile);\n      String resourceKey = getFullKey(project, resource);\n\n      List<Statement> statements;\n\n      Reader reader = null;\n      try {\n        reader = new InputStreamReader(new FileInputStream(inputFile.getFile()), project.getFileSystem().getSourceCharset());\n        statements = statementChunker.chunk(tokenChunker.chunk(reader));\n      } catch (FileNotFoundException e) {\n        throw new SonarException(e);\n      } finally {\n        IOUtils.closeQuietly(reader);\n      }\n\n      List<Block> blocks = blockChunker.chunk(resourceKey, statements);\n      index.insert(resource, blocks);\n    }\n\n    // Detect\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    try {\n      for (InputFile inputFile : inputFiles) {\n        LOG.debug(\"Detection of duplications for {}\", inputFile.getFile());\n        Resource resource = getResource(inputFile);\n        String resourceKey = getFullKey(project, resource);\n\n        Collection<Block> fileBlocks = index.getByResource(resource, resourceKey);\n\n        List<CloneGroup> clones;\n        try {\n          clones = executorService.submit(new Task(index, fileBlocks)).get(TIMEOUT, TimeUnit.SECONDS);\n        } catch (TimeoutException e) {\n          clones = null;\n          LOG.warn(\"Timeout during detection of duplications for \" + inputFile.getFile(), e);\n        } catch (InterruptedException e) {\n          throw new SonarException(e);\n        } catch (ExecutionException e) {\n          throw new SonarException(e);\n        }\n\n        save(context, resource, clones);\n      }\n    } finally {\n      executorService.shutdown();\n    }\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * For dry run, where is no access to database.\n   */\n  public SonarEngine() {\n    this(null, null);\n  }","id":79757,"modified_method":"public SonarEngine(IndexFactory indexFactory) {\n    this.indexFactory = indexFactory;\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static String getFullKey(Project project, Resource resource) {\n    return new StringBuilder(ResourceModel.KEY_SIZE)\n      .append(project.getKey())\n      .append(':')\n      .append(resource.getKey())\n      .toString();\n  }","id":79758,"modified_method":"static String getFullKey(Project project, Resource resource) {\n    return new StringBuilder(ResourceModel.KEY_SIZE)\n      .append(project.getKey())\n      .append(':')\n      .append(resource.getKey())\n      .toString();\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public TokenEntry(String image, String tokenSrcID, int beginLine) {\n    Integer i = TOKENS.get(image);\n    if (i == null) {\n      i = TOKENS.size() + 1;\n      TOKENS.put(image, i);\n    }\n    this.identifier = i.intValue();\n    this.tokenSrcID = tokenSrcID;\n    this.beginLine = beginLine;\n    this.index = tokenCount++;\n  }","id":79759,"modified_method":"public TokenEntry(String image, String tokenSrcID, int beginLine) {\n    Integer i = TOKENS.get(image);\n    if (i == null) {\n      i = TOKENS.size() + 1;\n      TOKENS.put(image, i);\n    }\n    this.identifier = i.intValue();\n    this.tokenSrcID = tokenSrcID;\n    this.beginLine = beginLine;\n    this.index = tokenCount++;\n    this.value = image;\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private TokenEntry() {\n    this.identifier = 0;\n    this.tokenSrcID = \"EOFMarker\";\n  }","id":79760,"modified_method":"private TokenEntry() {\n    this.identifier = 0;\n    this.tokenSrcID = \"EOFMarker\";\n    this.value = \"\";\n  }","commit_id":"ed409e8f0a53554aad46ac438b93b7adc02cc5d8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void initialize(final ExtensionContext context) {\n\n        log.debugf(\"Initializing Threading Extension\");\n\n        // Register the remoting subsystem\n        final SubsystemRegistration registration = context.registerSubsystem(THREADS, 1, 0);\n        registration.registerXMLElementWriter(ThreadsParser.INSTANCE);\n        // Remoting subsystem description and operation handlers\n        final ManagementResourceRegistration subsystem = registration.registerSubsystemModel(SUBSYSTEM_PROVIDER);\n        subsystem.registerOperationHandler(ADD, ThreadsSubsystemAdd.INSTANCE, ThreadsSubsystemAdd.INSTANCE, false);\n        subsystem.registerOperationHandler(DESCRIBE, ThreadsSubsystemDescribeHandler.INSTANCE,\n                ThreadsSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, SUBSYSTEM_REMOVE_PROVIDER, false);\n\n        final ManagementResourceRegistration threadFactories = subsystem.registerSubModel(PathElement.pathElement(THREAD_FACTORY),\n                THREAD_FACTORY_DESC);\n        threadFactories.registerOperationHandler(ADD, ThreadFactoryAdd.INSTANCE, ThreadFactoryAdd.INSTANCE, false);\n        threadFactories.registerOperationHandler(REMOVE, ThreadFactoryRemove.INSTANCE, ThreadFactoryRemove.INSTANCE, false);\n        ThreadFactoryWriteAttributeHandler.INSTANCE.registerAttributes(threadFactories);\n\n        final ManagementResourceRegistration boundedQueueThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(BOUNDED_QUEUE_THREAD_POOL), BOUNDED_QUEUE_THREAD_POOL_DESC);\n        boundedQueueThreadPools.registerOperationHandler(ADD, BoundedQueueThreadPoolAdd.INSTANCE,\n                BoundedQueueThreadPoolAdd.INSTANCE, false);\n        boundedQueueThreadPools.registerOperationHandler(REMOVE, BoundedQueueThreadPoolRemove.INSTANCE,\n                BoundedQueueThreadPoolRemove.INSTANCE, false);\n        BoundedQueueThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(boundedQueueThreadPools);\n        BoundedQueueThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(boundedQueueThreadPools);\n\n        final ManagementResourceRegistration unboundedQueueThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(UNBOUNDED_QUEUE_THREAD_POOL), UNBOUNDED_QUEUE_THREAD_POOL_DESC);\n        unboundedQueueThreadPools.registerOperationHandler(ADD, UnboundedQueueThreadPoolAdd.INSTANCE,\n                UnboundedQueueThreadPoolAdd.INSTANCE, false);\n        unboundedQueueThreadPools.registerOperationHandler(REMOVE, UnboundedQueueThreadPoolRemove.INSTANCE,\n                UnboundedQueueThreadPoolRemove.INSTANCE, false);\n        UnboundedQueueThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(unboundedQueueThreadPools);\n        UnboundedQueueThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(unboundedQueueThreadPools);\n\n        final ManagementResourceRegistration queuelessThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(QUEUELESS_THREAD_POOL), QUEUELESS_THREAD_POOL_DESC);\n        queuelessThreadPools.registerOperationHandler(ADD, QueuelessThreadPoolAdd.INSTANCE, QueuelessThreadPoolAdd.INSTANCE,\n                false);\n        queuelessThreadPools.registerOperationHandler(REMOVE, QueuelessThreadPoolRemove.INSTANCE,\n                QueuelessThreadPoolRemove.INSTANCE, false);\n        QueuelessThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(queuelessThreadPools);\n        QueuelessThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(queuelessThreadPools);\n\n        final ManagementResourceRegistration scheduledThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(SCHEDULED_THREAD_POOL), SCHEDULED_THREAD_POOL_DESC);\n        scheduledThreadPools.registerOperationHandler(ADD, ScheduledThreadPoolAdd.INSTANCE, ScheduledThreadPoolAdd.INSTANCE,\n                false);\n        scheduledThreadPools.registerOperationHandler(REMOVE, ScheduledThreadPoolRemove.INSTANCE,\n                ScheduledThreadPoolRemove.INSTANCE, false);\n        ScheduledThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(scheduledThreadPools);\n        ScheduledThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(scheduledThreadPools);\n    }","id":79761,"modified_method":"@Override\n    public void initialize(final ExtensionContext context) {\n\n        log.debugf(\"Initializing Threading Extension\");\n\n        final boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Register the remoting subsystem\n        final SubsystemRegistration registration = context.registerSubsystem(THREADS, 1, 0);\n        registration.registerXMLElementWriter(ThreadsParser.INSTANCE);\n        // Remoting subsystem description and operation handlers\n        final ManagementResourceRegistration subsystem = registration.registerSubsystemModel(SUBSYSTEM_PROVIDER);\n        subsystem.registerOperationHandler(ADD, ThreadsSubsystemAdd.INSTANCE, ThreadsSubsystemAdd.INSTANCE, false);\n        subsystem.registerOperationHandler(DESCRIBE, ThreadsSubsystemDescribeHandler.INSTANCE,\n                ThreadsSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerOperationHandler(REMOVE, ReloadRequiredRemoveStepHandler.INSTANCE, SUBSYSTEM_REMOVE_PROVIDER, false);\n\n        final ManagementResourceRegistration threadFactories = subsystem.registerSubModel(PathElement.pathElement(THREAD_FACTORY),\n                THREAD_FACTORY_DESC);\n        threadFactories.registerOperationHandler(ADD, ThreadFactoryAdd.INSTANCE, ThreadFactoryAdd.INSTANCE, false);\n        threadFactories.registerOperationHandler(REMOVE, ThreadFactoryRemove.INSTANCE, ThreadFactoryRemove.INSTANCE, false);\n        ThreadFactoryWriteAttributeHandler.INSTANCE.registerAttributes(threadFactories);\n\n        final ManagementResourceRegistration boundedQueueThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(BOUNDED_QUEUE_THREAD_POOL), BOUNDED_QUEUE_THREAD_POOL_DESC);\n        boundedQueueThreadPools.registerOperationHandler(ADD, BoundedQueueThreadPoolAdd.INSTANCE,\n                BoundedQueueThreadPoolAdd.INSTANCE, false);\n        boundedQueueThreadPools.registerOperationHandler(REMOVE, BoundedQueueThreadPoolRemove.INSTANCE,\n                BoundedQueueThreadPoolRemove.INSTANCE, false);\n        if (registerRuntimeOnly) {\n            BoundedQueueThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(boundedQueueThreadPools);\n        }\n        BoundedQueueThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(boundedQueueThreadPools);\n\n        final ManagementResourceRegistration unboundedQueueThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(UNBOUNDED_QUEUE_THREAD_POOL), UNBOUNDED_QUEUE_THREAD_POOL_DESC);\n        unboundedQueueThreadPools.registerOperationHandler(ADD, UnboundedQueueThreadPoolAdd.INSTANCE,\n                UnboundedQueueThreadPoolAdd.INSTANCE, false);\n        unboundedQueueThreadPools.registerOperationHandler(REMOVE, UnboundedQueueThreadPoolRemove.INSTANCE,\n                UnboundedQueueThreadPoolRemove.INSTANCE, false);\n        if (registerRuntimeOnly) {\n            UnboundedQueueThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(unboundedQueueThreadPools);\n        }\n        UnboundedQueueThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(unboundedQueueThreadPools);\n\n        final ManagementResourceRegistration queuelessThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(QUEUELESS_THREAD_POOL), QUEUELESS_THREAD_POOL_DESC);\n        queuelessThreadPools.registerOperationHandler(ADD, QueuelessThreadPoolAdd.INSTANCE, QueuelessThreadPoolAdd.INSTANCE,\n                false);\n        queuelessThreadPools.registerOperationHandler(REMOVE, QueuelessThreadPoolRemove.INSTANCE,\n                QueuelessThreadPoolRemove.INSTANCE, false);\n        if (registerRuntimeOnly) {\n            QueuelessThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(queuelessThreadPools);\n        }\n        QueuelessThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(queuelessThreadPools);\n\n        final ManagementResourceRegistration scheduledThreadPools = subsystem.registerSubModel(\n                PathElement.pathElement(SCHEDULED_THREAD_POOL), SCHEDULED_THREAD_POOL_DESC);\n        scheduledThreadPools.registerOperationHandler(ADD, ScheduledThreadPoolAdd.INSTANCE, ScheduledThreadPoolAdd.INSTANCE,\n                false);\n        scheduledThreadPools.registerOperationHandler(REMOVE, ScheduledThreadPoolRemove.INSTANCE,\n                ScheduledThreadPoolRemove.INSTANCE, false);\n        if (registerRuntimeOnly) {\n            ScheduledThreadPoolReadAttributeHandler.INSTANCE.registerAttributes(scheduledThreadPools);\n        }\n        ScheduledThreadPoolWriteAttributeHandler.INSTANCE.registerAttributes(scheduledThreadPools);\n    }","commit_id":"dfc961bd4151963805b823f873b1863e72334a74","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void register(@NotNull Class<?> javaClass, @NotNull ClassDescriptor kotlinDescriptor) {\n        register(getJavaClassFqName(javaClass), kotlinDescriptor);\n    }","id":79762,"modified_method":"@Override\n    /*package*/ void register(\n            @NotNull Class<?> javaClass,\n            @NotNull ClassDescriptor kotlinDescriptor\n    ) {\n        register(getJavaClassFqName(javaClass), kotlinDescriptor);\n    }","commit_id":"c0334094bab2eb934077846b22a722221f099f7c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void registerCovariant(@NotNull Class<?> javaClass, @NotNull ClassDescriptor kotlinDescriptor) {\n        registerCovariant(getJavaClassFqName(javaClass), kotlinDescriptor);\n    }","id":79763,"modified_method":"@Override\n    /*package*/ void register(\n            @NotNull Class<?> javaClass,\n            @NotNull ClassDescriptor kotlinDescriptor,\n            @NotNull ClassDescriptor kotlinMutableDescriptor\n    ) {\n        FqName javaClassName = getJavaClassFqName(javaClass);\n        register(javaClassName, kotlinDescriptor);\n        registerCovariant(javaClassName, kotlinMutableDescriptor);\n    }","commit_id":"c0334094bab2eb934077846b22a722221f099f7c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void register(@NotNull ClassDescriptor kotlinDescriptor, @NotNull Class<?> javaClass) {\n        register(kotlinDescriptor, AsmTypeConstants.getType(javaClass));\n    }","id":79764,"modified_method":"@Override\n    /*package*/ void register(\n            @NotNull Class<?> javaClass,\n            @NotNull ClassDescriptor kotlinDescriptor,\n            @NotNull ClassDescriptor kotlinMutableDescriptor\n    ) {\n        register(javaClass, kotlinDescriptor);\n        register(javaClass, kotlinMutableDescriptor);\n    }","commit_id":"c0334094bab2eb934077846b22a722221f099f7c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void addSources(SdkModificator sdkModificator) {\n    if (!addOrderEntries(OrderRootType.SOURCES, ProjectRootType.SOURCE, getInternalJavaSdk(sdkModificator.getHomePath()), sdkModificator) &&\n        SystemInfo.isMac){\n      ProjectJdk [] jdks = ProjectJdkTable.getInstance().getAllJdks();\n      for(int i = 0; i < jdks.length; i++){\n        if (jdks[i].getSdkType() instanceof JavaSdk){\n          addOrderEntries(OrderRootType.SOURCES, ProjectRootType.SOURCE, jdks[i], sdkModificator);\n          break;\n        }\n      }\n    }\n  }","id":79765,"modified_method":"private void addSources(SdkModificator sdkModificator) {\n    final Sdk internalJavaSdk = getInternalJavaSdk(sdkModificator.getHomePath());\n    if (!addOrderEntries(OrderRootType.SOURCES, ProjectRootType.SOURCE, internalJavaSdk, sdkModificator)){\n      if (SystemInfo.isMac) {\n        ProjectJdk [] jdks = ProjectJdkTable.getInstance().getAllJdks();\n        for (ProjectJdk jdk : jdks) {\n          if (jdk.getSdkType() instanceof JavaSdk) {\n            addOrderEntries(OrderRootType.SOURCES, ProjectRootType.SOURCE, jdk, sdkModificator);\n            break;\n          }\n        }\n      }\n      else {\n        final File jdkHome = new File(internalJavaSdk.getHomePath()).getParentFile();\n        final File jarFile = new File(jdkHome, \"src.zip\");\n        if (jarFile.exists()){\n          JarFileSystem jarFileSystem = JarFileSystem.getInstance();\n          String path = jarFile.getAbsolutePath().replace(File.separatorChar, '/') + JarFileSystem.JAR_SEPARATOR;\n          jarFileSystem.setNoCopyJarForPath(path);\n          sdkModificator.addRoot(jarFileSystem.findFileByPath(path), ProjectRootType.SOURCE);\n        }\n      }\n    }\n  }","commit_id":"4a09f15e173426da498ebb2ca9a8f5961c946607","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (CalculatorMeta) smi;\n    data = (CalculatorData) sdi;\n\n    Object[] r = getRow(); // get row, set busy!\n    if ( r == null ) { // no more input to be expected...\n      setOutputDone();\n      return false;\n    }\n\n    if ( first ) {\n      first = false;\n      data.outputRowMeta = getInputRowMeta().clone();\n      meta.getFields( data.outputRowMeta, getStepname(), null, null, this, repository, metaStore );\n\n      // get all metadata, including source rows and temporary fields.\n      data.calcRowMeta = meta.getAllFields( getInputRowMeta() );\n\n      data.fieldIndexes = new FieldIndexes[meta.getCalculation().length];\n      List<Integer> tempIndexes = new ArrayList<Integer>();\n\n      // Calculate the indexes of the values and arguments in the target data or temporary data\n      // We do this in advance to save time later on.\n      //\n      for ( int i = 0; i < meta.getCalculation().length; i++ ) {\n        CalculatorMetaFunction function = meta.getCalculation()[i];\n        data.fieldIndexes[i] = new FieldIndexes();\n\n        if ( !Const.isEmpty( function.getFieldName() ) ) {\n          data.fieldIndexes[i].indexName = data.calcRowMeta.indexOfValue( function.getFieldName() );\n          if ( data.fieldIndexes[i].indexName < 0 ) {\n            // Nope: throw an exception\n            throw new KettleStepException( BaseMessages.getString(\n              PKG, \"Calculator.Error.UnableFindField\", function.getFieldName(), \"\" + ( i + 1 ) ) );\n          }\n        } else {\n          throw new KettleStepException( BaseMessages.getString( PKG, \"Calculator.Error.NoNameField\", \"\"\n            + ( i + 1 ) ) );\n        }\n\n        if ( !Const.isEmpty( function.getFieldA() ) ) {\n          if ( function.getCalcType() != CalculatorMetaFunction.CALC_CONSTANT ) {\n            data.fieldIndexes[i].indexA = data.calcRowMeta.indexOfValue( function.getFieldA() );\n            if ( data.fieldIndexes[i].indexA < 0 ) {\n              // Nope: throw an exception\n              throw new KettleStepException( \"Unable to find the first argument field '\"\n                + function.getFieldName() + \" for calculation #\" + ( i + 1 ) );\n            }\n          } else {\n            data.fieldIndexes[i].indexA = -1;\n          }\n        } else {\n          throw new KettleStepException( \"There is no first argument specified for calculated field #\" + ( i + 1 ) );\n        }\n\n        if ( !Const.isEmpty( function.getFieldB() ) ) {\n          data.fieldIndexes[i].indexB = data.calcRowMeta.indexOfValue( function.getFieldB() );\n          if ( data.fieldIndexes[i].indexB < 0 ) {\n            // Nope: throw an exception\n            throw new KettleStepException( \"Unable to find the second argument field '\"\n              + function.getFieldName() + \" for calculation #\" + ( i + 1 ) );\n          }\n        }\n        data.fieldIndexes[i].indexC = -1;\n        if ( !Const.isEmpty( function.getFieldC() ) ) {\n          data.fieldIndexes[i].indexC = data.calcRowMeta.indexOfValue( function.getFieldC() );\n          if ( data.fieldIndexes[i].indexC < 0 ) {\n            // Nope: throw an exception\n            throw new KettleStepException( \"Unable to find the third argument field '\"\n              + function.getFieldName() + \" for calculation #\" + ( i + 1 ) );\n          }\n        }\n\n        if ( function.isRemovedFromResult() ) {\n          tempIndexes.add( Integer.valueOf( getInputRowMeta().size() + i ) );\n        }\n      }\n\n      // Convert temp indexes to int[]\n      data.tempIndexes = new int[tempIndexes.size()];\n      for ( int i = 0; i < data.tempIndexes.length; i++ ) {\n        data.tempIndexes[i] = tempIndexes.get( i ).intValue();\n      }\n    }\n\n    if ( log.isRowLevel() ) {\n      logRowlevel( BaseMessages.getString( PKG, \"Calculator.Log.ReadRow\" )\n        + getLinesRead() + \" : \" + getInputRowMeta().getString( r ) );\n    }\n    boolean sendToErrorRow = false;\n    String errorMessage = null;\n\n    try {\n      Object[] row = calcFields( getInputRowMeta(), r );\n      putRow( data.outputRowMeta, row ); // copy row to possible alternate rowset(s).\n\n      if ( log.isRowLevel() ) {\n        logRowlevel( \"Wrote row #\" + getLinesWritten() + \" : \" + getInputRowMeta().getString( r ) );\n      }\n      if ( checkFeedback( getLinesRead() ) ) {\n        if ( log.isBasic() ) {\n          logBasic( BaseMessages.getString( PKG, \"Calculator.Log.Linenr\", \"\" + getLinesRead() ) );\n        }\n      }\n    } catch ( KettleException e ) {\n      if ( getStepMeta().isDoingErrorHandling() ) {\n        sendToErrorRow = true;\n        errorMessage = e.toString();\n      } else {\n        logError( BaseMessages.getString( PKG, \"Calculator.ErrorInStepRunning\" + \" : \" + e.getMessage() ) );\n        throw new KettleStepException( BaseMessages.getString( PKG, \"Calculator.ErrorInStepRunning\" ), e );\n      }\n      if ( sendToErrorRow ) {\n        // Simply add this row to the error row\n        putError( getInputRowMeta(), r, 1, errorMessage, null, \"CALC001\" );\n      }\n    }\n    return true;\n  }","id":79766,"modified_method":"public boolean processRow( StepMetaInterface smi, StepDataInterface sdi ) throws KettleException {\n    meta = (CalculatorMeta) smi;\n    data = (CalculatorData) sdi;\n\n    Object[] r = getRow(); // get row, set busy!\n    if ( r == null ) { // no more input to be expected...\n      setOutputDone();\n      return false;\n    }\n\n    if ( first ) {\n      first = false;\n      data.setOutputRowMeta( getInputRowMeta().clone() );\n      meta.getFields( data.getOutputRowMeta(), getStepname(), null, null, this, repository, metaStore );\n\n      // get all metadata, including source rows and temporary fields.\n      data.setCalcRowMeta( meta.getAllFields( getInputRowMeta() ) );\n\n      data.setFieldIndexes( new FieldIndexes[meta.getCalculation().length] );\n      List<Integer> tempIndexes = new ArrayList<Integer>();\n\n      // Calculate the indexes of the values and arguments in the target data or temporary data\n      // We do this in advance to save time later on.\n      //\n      //CHECKSTYLE:Indentation:OFF\n      for ( int i = 0; i < meta.getCalculation().length; i++ ) {\n        CalculatorMetaFunction function = meta.getCalculation()[i];\n        data.getFieldIndexes()[i] = new FieldIndexes();\n\n        if ( !Const.isEmpty( function.getFieldName() ) ) {\n          data.getFieldIndexes()[i].indexName = data.getCalcRowMeta().indexOfValue( function.getFieldName() );\n          if ( data.getFieldIndexes()[i].indexName < 0 ) {\n            // Nope: throw an exception\n            throw new KettleStepException( BaseMessages.getString(\n              PKG, \"Calculator.Error.UnableFindField\", function.getFieldName(), \"\" + ( i + 1 ) ) );\n          }\n        } else {\n          throw new KettleStepException( BaseMessages.getString( PKG, \"Calculator.Error.NoNameField\", \"\"\n            + ( i + 1 ) ) );\n        }\n\n        if ( !Const.isEmpty( function.getFieldA() ) ) {\n          if ( function.getCalcType() != CalculatorMetaFunction.CALC_CONSTANT ) {\n            data.getFieldIndexes()[i].indexA = data.getCalcRowMeta().indexOfValue( function.getFieldA() );\n            if ( data.getFieldIndexes()[i].indexA < 0 ) {\n              // Nope: throw an exception\n              throw new KettleStepException( \"Unable to find the first argument field '\"\n                + function.getFieldName() + \" for calculation #\" + ( i + 1 ) );\n            }\n          } else {\n            data.getFieldIndexes()[i].indexA = -1;\n          }\n        } else {\n          throw new KettleStepException( \"There is no first argument specified for calculated field #\" + ( i + 1 ) );\n        }\n\n        if ( !Const.isEmpty( function.getFieldB() ) ) {\n          data.getFieldIndexes()[i].indexB = data.getCalcRowMeta().indexOfValue( function.getFieldB() );\n          if ( data.getFieldIndexes()[i].indexB < 0 ) {\n            // Nope: throw an exception\n            throw new KettleStepException( \"Unable to find the second argument field '\"\n              + function.getFieldName() + \" for calculation #\" + ( i + 1 ) );\n          }\n        }\n        data.getFieldIndexes()[i].indexC = -1;\n        if ( !Const.isEmpty( function.getFieldC() ) ) {\n          data.getFieldIndexes()[i].indexC = data.getCalcRowMeta().indexOfValue( function.getFieldC() );\n          if ( data.getFieldIndexes()[i].indexC < 0 ) {\n            // Nope: throw an exception\n            throw new KettleStepException( \"Unable to find the third argument field '\"\n              + function.getFieldName() + \" for calculation #\" + ( i + 1 ) );\n          }\n        }\n\n        if ( function.isRemovedFromResult() ) {\n          tempIndexes.add( getInputRowMeta().size() + i );\n        }\n      }\n\n      // Convert temp indexes to int[]\n      data.setTempIndexes( new int[tempIndexes.size()] );\n      for ( int i = 0; i < data.getTempIndexes().length; i++ ) {\n        data.getTempIndexes()[i] = tempIndexes.get( i );\n      }\n    }\n\n    if ( log.isRowLevel() ) {\n      logRowlevel( BaseMessages.getString( PKG, \"Calculator.Log.ReadRow\" )\n        + getLinesRead() + \" : \" + getInputRowMeta().getString( r ) );\n    }\n\n    try {\n      Object[] row = calcFields( getInputRowMeta(), r );\n      putRow( data.getOutputRowMeta(), row ); // copy row to possible alternate rowset(s).\n\n      if ( log.isRowLevel() ) {\n        logRowlevel( \"Wrote row #\" + getLinesWritten() + \" : \" + getInputRowMeta().getString( r ) );\n      }\n      if ( checkFeedback( getLinesRead() ) ) {\n        if ( log.isBasic() ) {\n          logBasic( BaseMessages.getString( PKG, \"Calculator.Log.Linenr\", \"\" + getLinesRead() ) );\n        }\n      }\n    } catch ( KettleException e ) {\n      if ( getStepMeta().isDoingErrorHandling() ) {\n        putError( getInputRowMeta(), r, 1, e.toString(), null, \"CALC001\" );\n      } else {\n        logError( BaseMessages.getString( PKG, \"Calculator.ErrorInStepRunning\" + \" : \" + e.getMessage() ) );\n        throw new KettleStepException( BaseMessages.getString( PKG, \"Calculator.ErrorInStepRunning\" ), e );\n      }\n    }\n    return true;\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (CalculatorMeta) smi;\n    data = (CalculatorData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      return true;\n    }\n    return false;\n  }","id":79767,"modified_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (CalculatorMeta) smi;\n    data = (CalculatorData) sdi;\n\n    return super.init( smi, sdi );\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * @param inputRowMeta\n   *          the input row metadata\n   * @param r\n   *          the input row (data)\n   * @return A row including the calculations, excluding the temporary values\n   * @throws KettleValueException\n   *           in case there is a calculation error.\n   */\n  private Object[] calcFields( RowMetaInterface inputRowMeta, Object[] r ) throws KettleValueException {\n    // First copy the input data to the new result...\n    Object[] calcData = RowDataUtil.resizeArray( r, data.calcRowMeta.size() );\n\n    for ( int i = 0, index = inputRowMeta.size() + i; i < meta.getCalculation().length; i++, index++ ) {\n      CalculatorMetaFunction fn = meta.getCalculation()[i];\n      if ( !Const.isEmpty( fn.getFieldName() ) ) {\n        ValueMetaInterface targetMeta = data.calcRowMeta.getValueMeta( index );\n\n        // Get the metadata & the data...\n        // ValueMetaInterface metaTarget = data.calcRowMeta.getValueMeta(i);\n\n        ValueMetaInterface metaA = null;\n        Object dataA = null;\n\n        if ( data.fieldIndexes[i].indexA >= 0 ) {\n          metaA = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexA );\n          dataA = calcData[data.fieldIndexes[i].indexA];\n        }\n\n        ValueMetaInterface metaB = null;\n        Object dataB = null;\n\n        if ( data.fieldIndexes[i].indexB >= 0 ) {\n          metaB = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexB );\n          dataB = calcData[data.fieldIndexes[i].indexB];\n        }\n\n        ValueMetaInterface metaC = null;\n        Object dataC = null;\n\n        if ( data.fieldIndexes[i].indexC >= 0 ) {\n          metaC = data.calcRowMeta.getValueMeta( data.fieldIndexes[i].indexC );\n          dataC = calcData[data.fieldIndexes[i].indexC];\n        }\n\n        int calcType = fn.getCalcType();\n        // The data types are those of the first argument field, convert to the target field.\n        // Exceptions:\n        // - multiply can be string\n        // - constant is string\n        // - all date functions except add days/months\n        // - hex encode / decodes\n\n        int resultType;\n        if ( metaA != null ) {\n          resultType = metaA.getType();\n        } else {\n          resultType = ValueMetaInterface.TYPE_NONE;\n        }\n\n        switch ( calcType ) {\n          case CalculatorMetaFunction.CALC_NONE:\n            break;\n          case CalculatorMetaFunction.CALC_COPY_OF_FIELD: // Create a copy of field A\n\n            calcData[index] = dataA;\n\n            break;\n          case CalculatorMetaFunction.CALC_ADD: // A + B\n            calcData[index] = ValueDataUtil.plus( metaA, dataA, metaB, dataB );\n            if ( metaA.isString() || metaB.isString() ) {\n              resultType = ValueMetaInterface.TYPE_STRING;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_SUBTRACT: // A - B\n            calcData[index] = ValueDataUtil.minus( metaA, dataA, metaB, dataB );\n            if ( metaA.isDate() ) {\n              resultType = ValueMetaInterface.TYPE_INTEGER;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_MULTIPLY: // A * B\n            calcData[index] = ValueDataUtil.multiply( metaA, dataA, metaB, dataB );\n            if ( metaA.isString() || metaB.isString() ) {\n              resultType = ValueMetaInterface.TYPE_STRING;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_DIVIDE: // A / B\n            calcData[index] = ValueDataUtil.divide( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_SQUARE: // A * A\n            calcData[index] = ValueDataUtil.multiply( metaA, dataA, metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_SQUARE_ROOT: // SQRT( A )\n            calcData[index] = ValueDataUtil.sqrt( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_PERCENT_1: // 100 * A / B\n            calcData[index] = ValueDataUtil.percent1( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_PERCENT_2: // A - ( A * B / 100 )\n            calcData[index] = ValueDataUtil.percent2( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_PERCENT_3: // A + ( A * B / 100 )\n            calcData[index] = ValueDataUtil.percent3( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_COMBINATION_1: // A + B * C\n            calcData[index] = ValueDataUtil.combination1( metaA, dataA, metaB, dataB, metaC, dataC );\n            break;\n          case CalculatorMetaFunction.CALC_COMBINATION_2: // SQRT( A*A + B*B )\n            calcData[index] = ValueDataUtil.combination2( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_1: // ROUND( A )\n            calcData[index] = ValueDataUtil.round( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_2: // ROUND( A , B )\n            calcData[index] = ValueDataUtil.round( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_STD_1: // ROUND( A )\n            calcData[index] = ValueDataUtil.round( metaA, dataA, java.math.BigDecimal.ROUND_HALF_UP );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_STD_2: // ROUND( A , B )\n            calcData[index] = ValueDataUtil.round( metaA, dataA, metaB, dataB, java.math.BigDecimal.ROUND_HALF_UP );\n            break;\n          case CalculatorMetaFunction.CALC_CEIL: // CEIL( A )\n            calcData[index] = ValueDataUtil.ceil( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_FLOOR: // FLOOR( A )\n            calcData[index] = ValueDataUtil.floor( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_CONSTANT: // Set field to constant value...\n            calcData[index] = fn.getFieldA(); // A string\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_NVL: // Replace null values with another value\n            calcData[index] = ValueDataUtil.nvl( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_ADD_DAYS: // Add B days to date field A\n            calcData[index] = ValueDataUtil.addDays( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_HOURS: // Add B hours to date field A\n            calcData[index] = ValueDataUtil.addHours( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_MINUTES: // Add B minutes to date field A\n            calcData[index] = ValueDataUtil.addMinutes( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_YEAR_OF_DATE: // What is the year (Integer) of a date?\n            calcData[index] = ValueDataUtil.yearOfDate( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MONTH_OF_DATE: // What is the month (Integer) of a date?\n            calcData[index] = ValueDataUtil.monthOfDate( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAY_OF_YEAR: // What is the day of year (Integer) of a date?\n            calcData[index] = ValueDataUtil.dayOfYear( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAY_OF_MONTH: // What is the day of month (Integer) of a date?\n            calcData[index] = ValueDataUtil.dayOfMonth( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAY_OF_WEEK: // What is the day of week (Integer) of a date?\n            calcData[index] = ValueDataUtil.dayOfWeek( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_WEEK_OF_YEAR: // What is the week of year (Integer) of a date?\n            calcData[index] = ValueDataUtil.weekOfYear( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_WEEK_OF_YEAR_ISO8601: // What is the week of year (Integer) of a date ISO8601\n                                                                 // style?\n            calcData[index] = ValueDataUtil.weekOfYearISO8601( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_YEAR_OF_DATE_ISO8601: // What is the year (Integer) of a date ISO8601 style?\n            calcData[index] = ValueDataUtil.yearOfDateISO8601( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_BYTE_TO_HEX_ENCODE: // Byte to Hex encode string field A\n            calcData[index] = ValueDataUtil.byteToHexEncode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_HEX_TO_BYTE_DECODE: // Hex to Byte decode string field A\n            calcData[index] = ValueDataUtil.hexToByteDecode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n\n          case CalculatorMetaFunction.CALC_CHAR_TO_HEX_ENCODE: // Char to Hex encode string field A\n            calcData[index] = ValueDataUtil.charToHexEncode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_HEX_TO_CHAR_DECODE: // Hex to Char decode string field A\n            calcData[index] = ValueDataUtil.hexToCharDecode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_CRC32: // CRC32\n            calcData[index] = ValueDataUtil.ChecksumCRC32( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADLER32: // ADLER32\n            calcData[index] = ValueDataUtil.ChecksumAdler32( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MD5: // MD5\n            calcData[index] = ValueDataUtil.createChecksum( metaA, dataA, \"MD5\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SHA1: // SHA-1\n            calcData[index] = ValueDataUtil.createChecksum( metaA, dataA, \"SHA-1\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_LEVENSHTEIN_DISTANCE: // LEVENSHTEIN DISTANCE\n            calcData[index] = ValueDataUtil.getLevenshtein_Distance( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_METAPHONE: // METAPHONE\n            calcData[index] = ValueDataUtil.get_Metaphone( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DOUBLE_METAPHONE: // Double METAPHONE\n            calcData[index] = ValueDataUtil.get_Double_Metaphone( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ABS: // ABS( A )\n            calcData[index] = ValueDataUtil.abs( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_TIME_FROM_DATE: // Remove Time from field A\n            calcData[index] = ValueDataUtil.removeTimeFromDate( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF: // DateA - DateB\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"d\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD3: // A + B + C\n            calcData[index] = ValueDataUtil.plus3( metaA, dataA, metaB, dataB, metaC, dataC );\n            if ( metaA.isString() || metaB.isString() || metaC.isString() ) {\n              resultType = ValueMetaInterface.TYPE_STRING;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_INITCAP: // InitCap( A )\n            calcData[index] = ValueDataUtil.initCap( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_UPPER_CASE: // UpperCase( A )\n            calcData[index] = ValueDataUtil.upperCase( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_LOWER_CASE: // UpperCase( A )\n            calcData[index] = ValueDataUtil.lowerCase( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MASK_XML: // escapeXML( A )\n            calcData[index] = ValueDataUtil.escapeXML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_USE_CDATA: // CDATA( A )\n            calcData[index] = ValueDataUtil.useCDATA( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_CR: // REMOVE CR FROM A\n            calcData[index] = ValueDataUtil.removeCR( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_LF: // REMOVE LF FROM A\n            calcData[index] = ValueDataUtil.removeLF( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_CRLF: // REMOVE CRLF FROM A\n            calcData[index] = ValueDataUtil.removeCRLF( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_TAB: // REMOVE TAB FROM A\n            calcData[index] = ValueDataUtil.removeTAB( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_GET_ONLY_DIGITS: // GET ONLY DIGITS FROM A\n            calcData[index] = ValueDataUtil.getDigits( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_DIGITS: // REMOVE DIGITS FROM A\n            calcData[index] = ValueDataUtil.removeDigits( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_STRING_LEN: // RETURN THE LENGTH OF A\n            calcData[index] = ValueDataUtil.stringLen( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_LOAD_FILE_CONTENT_BINARY: // LOAD CONTENT OF A FILE A IN A BLOB\n            calcData[index] = ValueDataUtil.loadFileContentInBinary( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_TIME_TO_DATE: // Add time B to a date A\n            calcData[index] = ValueDataUtil.addTimeToDate( metaA, dataA, metaB, dataB, metaC, dataC );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_QUARTER_OF_DATE: // What is the quarter (Integer) of a date?\n            calcData[index] = ValueDataUtil.quarterOfDate( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SUBSTITUTE_VARIABLE: // variable substitution in string\n            calcData[index] = environmentSubstitute( dataA.toString() );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_UNESCAPE_XML: // UnescapeXML( A )\n            calcData[index] = ValueDataUtil.unEscapeXML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ESCAPE_HTML: // EscapeHTML( A )\n            calcData[index] = ValueDataUtil.escapeHTML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_UNESCAPE_HTML: // UnescapeHTML( A )\n            calcData[index] = ValueDataUtil.unEscapeHTML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ESCAPE_SQL: // EscapeSQL( A )\n            calcData[index] = ValueDataUtil.escapeSQL( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_WORKING_DIFF: // DateWorkingDiff( A , B)\n            calcData[index] = ValueDataUtil.DateWorkingDiff( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_MONTHS: // Add B months to date field A\n            calcData[index] = ValueDataUtil.addMonths( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_CHECK_XML_FILE_WELL_FORMED: // Check if file A is well formed\n            calcData[index] = ValueDataUtil.isXMLFileWellFormed( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_CHECK_XML_WELL_FORMED: // Check if xml A is well formed\n            calcData[index] = ValueDataUtil.isXMLWellFormed( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_GET_FILE_ENCODING: // Get file encoding from a file A\n            calcData[index] = ValueDataUtil.getFileEncoding( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAMERAU_LEVENSHTEIN: // DAMERAULEVENSHTEIN DISTANCE\n            calcData[index] = ValueDataUtil.getDamerauLevenshtein_Distance( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_NEEDLEMAN_WUNSH: // NEEDLEMANWUNSH DISTANCE\n            calcData[index] = ValueDataUtil.getNeedlemanWunsch_Distance( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_JARO: // Jaro DISTANCE\n            calcData[index] = ValueDataUtil.getJaro_Similitude( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_JARO_WINKLER: // Jaro DISTANCE\n            calcData[index] = ValueDataUtil.getJaroWinkler_Similitude( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SOUNDEX: // SOUNDEX\n            calcData[index] = ValueDataUtil.get_SoundEx( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REFINED_SOUNDEX: // REFINEDSOUNDEX\n            calcData[index] = ValueDataUtil.get_RefinedSoundEx( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_MSEC: // DateA - DateB (ms)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"ms\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_SEC: // DateA - DateB (s)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"s\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_MN: // DateA - DateB (mn)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"mn\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_HR: // DateA - DateB (h)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"h\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_HOUR_OF_DAY:\n            calcData[index] = ValueDataUtil.hourOfDay( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MINUTE_OF_HOUR:\n            calcData[index] = ValueDataUtil.minuteOfHour( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SECOND_OF_MINUTE:\n            calcData[index] = ValueDataUtil.secondOfMinute( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          default:\n            throw new KettleValueException( BaseMessages.getString( PKG, \"Calculator.Log.UnknownCalculationType\" )\n              + fn.getCalcType() );\n        }\n\n        // If we don't have a target data type, throw an error.\n        // Otherwise the result is non-deterministic.\n        //\n        if ( targetMeta.getType() == ValueMetaInterface.TYPE_NONE ) {\n          throw new KettleValueException( BaseMessages.getString( PKG, \"Calculator.Log.NoType\" )\n            + ( i + 1 ) + \" : \" + fn.getFieldName() + \" = \" + fn.getCalcTypeDesc() + \" / \"\n            + fn.getCalcTypeLongDesc() );\n        }\n\n        // Convert the data to the correct target data type.\n        //\n        if ( calcData[index] != null ) {\n          if ( targetMeta.getType() != resultType ) {\n            ValueMetaInterface resultMeta = null;\n            try {\n              resultMeta = ValueMetaFactory.createValueMeta( \"result\", resultType );\n            } catch ( Exception exception ) {\n              throw new KettleValueException( \"Error creating value\" );\n            }\n            resultMeta.setConversionMask( fn.getConversionMask() );\n            resultMeta.setGroupingSymbol( fn.getGroupingSymbol() );\n            resultMeta.setDecimalSymbol( fn.getDecimalSymbol() );\n            resultMeta.setCurrencySymbol( fn.getCurrencySymbol() );\n            try {\n              calcData[index] = targetMeta.convertData( resultMeta, calcData[index] );\n            } catch ( Exception ex ) {\n              throw new KettleValueException( \"resultType: \"\n                + resultType + \"; targetMeta: \" + targetMeta.getType(), ex );\n            }\n          }\n        }\n      }\n    }\n\n    // OK, now we should refrain from adding the temporary fields to the result.\n    // So we remove them.\n    //\n    return RowDataUtil.removeItems( calcData, data.tempIndexes );\n  }","id":79768,"modified_method":"/**\n   * @param inputRowMeta\n   *          the input row metadata\n   * @param r\n   *          the input row (data)\n   * @return A row including the calculations, excluding the temporary values\n   * @throws KettleValueException\n   *           in case there is a calculation error.\n   */\n  private Object[] calcFields( RowMetaInterface inputRowMeta, Object[] r ) throws KettleValueException {\n    // First copy the input data to the new result...\n    Object[] calcData = RowDataUtil.resizeArray( r, data.getCalcRowMeta().size() );\n\n    for ( int i = 0, index = inputRowMeta.size() + i; i < meta.getCalculation().length; i++, index++ ) {\n      CalculatorMetaFunction fn = meta.getCalculation()[i];\n      if ( !Const.isEmpty( fn.getFieldName() ) ) {\n        ValueMetaInterface targetMeta = data.getCalcRowMeta().getValueMeta( index );\n\n        // Get the metadata & the data...\n        // ValueMetaInterface metaTarget = data.calcRowMeta.getValueMeta(i);\n\n        ValueMetaInterface metaA = null;\n        Object dataA = null;\n\n        if ( data.getFieldIndexes()[i].indexA >= 0 ) {\n          metaA = data.getCalcRowMeta().getValueMeta( data.getFieldIndexes()[ i ].indexA );\n          dataA = calcData[ data.getFieldIndexes()[i].indexA];\n        }\n\n        ValueMetaInterface metaB = null;\n        Object dataB = null;\n\n        if ( data.getFieldIndexes()[i].indexB >= 0 ) {\n          metaB = data.getCalcRowMeta().getValueMeta( data.getFieldIndexes()[ i ].indexB );\n          dataB = calcData[ data.getFieldIndexes()[i].indexB];\n        }\n\n        ValueMetaInterface metaC = null;\n        Object dataC = null;\n\n        if ( data.getFieldIndexes()[i].indexC >= 0 ) {\n          metaC = data.getCalcRowMeta().getValueMeta( data.getFieldIndexes()[ i ].indexC );\n          dataC = calcData[ data.getFieldIndexes()[i].indexC];\n        }\n\n        int calcType = fn.getCalcType();\n        // The data types are those of the first argument field, convert to the target field.\n        // Exceptions:\n        // - multiply can be string\n        // - constant is string\n        // - all date functions except add days/months\n        // - hex encode / decodes\n\n        int resultType;\n        if ( metaA != null ) {\n          resultType = metaA.getType();\n        } else {\n          resultType = ValueMetaInterface.TYPE_NONE;\n        }\n\n        switch ( calcType ) {\n          case CalculatorMetaFunction.CALC_NONE:\n            break;\n          case CalculatorMetaFunction.CALC_COPY_OF_FIELD: // Create a copy of field A\n\n            calcData[index] = dataA;\n\n            break;\n          case CalculatorMetaFunction.CALC_ADD: // A + B\n            calcData[index] = ValueDataUtil.plus( metaA, dataA, metaB, dataB );\n            if ( metaA.isString() || metaB.isString() ) {\n              resultType = ValueMetaInterface.TYPE_STRING;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_SUBTRACT: // A - B\n            calcData[index] = ValueDataUtil.minus( metaA, dataA, metaB, dataB );\n            if ( metaA.isDate() ) {\n              resultType = ValueMetaInterface.TYPE_INTEGER;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_MULTIPLY: // A * B\n            calcData[index] = ValueDataUtil.multiply( metaA, dataA, metaB, dataB );\n            if ( metaA.isString() || metaB.isString() ) {\n              resultType = ValueMetaInterface.TYPE_STRING;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_DIVIDE: // A / B\n            calcData[index] = ValueDataUtil.divide( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_SQUARE: // A * A\n            calcData[index] = ValueDataUtil.multiply( metaA, dataA, metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_SQUARE_ROOT: // SQRT( A )\n            calcData[index] = ValueDataUtil.sqrt( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_PERCENT_1: // 100 * A / B\n            calcData[index] = ValueDataUtil.percent1( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_PERCENT_2: // A - ( A * B / 100 )\n            calcData[index] = ValueDataUtil.percent2( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_PERCENT_3: // A + ( A * B / 100 )\n            calcData[index] = ValueDataUtil.percent3( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_COMBINATION_1: // A + B * C\n            calcData[index] = ValueDataUtil.combination1( metaA, dataA, metaB, dataB, metaC, dataC );\n            break;\n          case CalculatorMetaFunction.CALC_COMBINATION_2: // SQRT( A*A + B*B )\n            calcData[index] = ValueDataUtil.combination2( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_1: // ROUND( A )\n            calcData[index] = ValueDataUtil.round( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_2: // ROUND( A , B )\n            calcData[index] = ValueDataUtil.round( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_STD_1: // ROUND( A )\n            calcData[index] = ValueDataUtil.round( metaA, dataA, java.math.BigDecimal.ROUND_HALF_UP );\n            break;\n          case CalculatorMetaFunction.CALC_ROUND_STD_2: // ROUND( A , B )\n            calcData[index] = ValueDataUtil.round( metaA, dataA, metaB, dataB, java.math.BigDecimal.ROUND_HALF_UP );\n            break;\n          case CalculatorMetaFunction.CALC_CEIL: // CEIL( A )\n            calcData[index] = ValueDataUtil.ceil( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_FLOOR: // FLOOR( A )\n            calcData[index] = ValueDataUtil.floor( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_CONSTANT: // Set field to constant value...\n            calcData[index] = fn.getFieldA(); // A string\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_NVL: // Replace null values with another value\n            calcData[index] = ValueDataUtil.nvl( metaA, dataA, metaB, dataB );\n            break;\n          case CalculatorMetaFunction.CALC_ADD_DAYS: // Add B days to date field A\n            calcData[index] = ValueDataUtil.addDays( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_HOURS: // Add B hours to date field A\n            calcData[index] = ValueDataUtil.addHours( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_MINUTES: // Add B minutes to date field A\n            calcData[index] = ValueDataUtil.addMinutes( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_YEAR_OF_DATE: // What is the year (Integer) of a date?\n            calcData[index] = ValueDataUtil.yearOfDate( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MONTH_OF_DATE: // What is the month (Integer) of a date?\n            calcData[index] = ValueDataUtil.monthOfDate( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAY_OF_YEAR: // What is the day of year (Integer) of a date?\n            calcData[index] = ValueDataUtil.dayOfYear( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAY_OF_MONTH: // What is the day of month (Integer) of a date?\n            calcData[index] = ValueDataUtil.dayOfMonth( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAY_OF_WEEK: // What is the day of week (Integer) of a date?\n            calcData[index] = ValueDataUtil.dayOfWeek( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_WEEK_OF_YEAR: // What is the week of year (Integer) of a date?\n            calcData[index] = ValueDataUtil.weekOfYear( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_WEEK_OF_YEAR_ISO8601: // What is the week of year (Integer) of a date ISO8601\n                                                                 // style?\n            calcData[index] = ValueDataUtil.weekOfYearISO8601( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_YEAR_OF_DATE_ISO8601: // What is the year (Integer) of a date ISO8601 style?\n            calcData[index] = ValueDataUtil.yearOfDateISO8601( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_BYTE_TO_HEX_ENCODE: // Byte to Hex encode string field A\n            calcData[index] = ValueDataUtil.byteToHexEncode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_HEX_TO_BYTE_DECODE: // Hex to Byte decode string field A\n            calcData[index] = ValueDataUtil.hexToByteDecode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n\n          case CalculatorMetaFunction.CALC_CHAR_TO_HEX_ENCODE: // Char to Hex encode string field A\n            calcData[index] = ValueDataUtil.charToHexEncode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_HEX_TO_CHAR_DECODE: // Hex to Char decode string field A\n            calcData[index] = ValueDataUtil.hexToCharDecode( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_CRC32: // CRC32\n            calcData[index] = ValueDataUtil.ChecksumCRC32( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADLER32: // ADLER32\n            calcData[index] = ValueDataUtil.ChecksumAdler32( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MD5: // MD5\n            calcData[index] = ValueDataUtil.createChecksum( metaA, dataA, \"MD5\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SHA1: // SHA-1\n            calcData[index] = ValueDataUtil.createChecksum( metaA, dataA, \"SHA-1\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_LEVENSHTEIN_DISTANCE: // LEVENSHTEIN DISTANCE\n            calcData[index] = ValueDataUtil.getLevenshtein_Distance( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_METAPHONE: // METAPHONE\n            calcData[index] = ValueDataUtil.get_Metaphone( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DOUBLE_METAPHONE: // Double METAPHONE\n            calcData[index] = ValueDataUtil.get_Double_Metaphone( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ABS: // ABS( A )\n            calcData[index] = ValueDataUtil.abs( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_TIME_FROM_DATE: // Remove Time from field A\n            calcData[index] = ValueDataUtil.removeTimeFromDate( metaA, dataA );\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF: // DateA - DateB\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"d\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD3: // A + B + C\n            calcData[index] = ValueDataUtil.plus3( metaA, dataA, metaB, dataB, metaC, dataC );\n            if ( metaA.isString() || metaB.isString() || metaC.isString() ) {\n              resultType = ValueMetaInterface.TYPE_STRING;\n            }\n            break;\n          case CalculatorMetaFunction.CALC_INITCAP: // InitCap( A )\n            calcData[index] = ValueDataUtil.initCap( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_UPPER_CASE: // UpperCase( A )\n            calcData[index] = ValueDataUtil.upperCase( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_LOWER_CASE: // UpperCase( A )\n            calcData[index] = ValueDataUtil.lowerCase( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MASK_XML: // escapeXML( A )\n            calcData[index] = ValueDataUtil.escapeXML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_USE_CDATA: // CDATA( A )\n            calcData[index] = ValueDataUtil.useCDATA( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_CR: // REMOVE CR FROM A\n            calcData[index] = ValueDataUtil.removeCR( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_LF: // REMOVE LF FROM A\n            calcData[index] = ValueDataUtil.removeLF( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_CRLF: // REMOVE CRLF FROM A\n            calcData[index] = ValueDataUtil.removeCRLF( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_TAB: // REMOVE TAB FROM A\n            calcData[index] = ValueDataUtil.removeTAB( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_GET_ONLY_DIGITS: // GET ONLY DIGITS FROM A\n            calcData[index] = ValueDataUtil.getDigits( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REMOVE_DIGITS: // REMOVE DIGITS FROM A\n            calcData[index] = ValueDataUtil.removeDigits( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_STRING_LEN: // RETURN THE LENGTH OF A\n            calcData[index] = ValueDataUtil.stringLen( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_LOAD_FILE_CONTENT_BINARY: // LOAD CONTENT OF A FILE A IN A BLOB\n            calcData[index] = ValueDataUtil.loadFileContentInBinary( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_TIME_TO_DATE: // Add time B to a date A\n            calcData[index] = ValueDataUtil.addTimeToDate( metaA, dataA, metaB, dataB, metaC, dataC );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_QUARTER_OF_DATE: // What is the quarter (Integer) of a date?\n            calcData[index] = ValueDataUtil.quarterOfDate( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SUBSTITUTE_VARIABLE: // variable substitution in string\n            calcData[index] = environmentSubstitute( dataA.toString() );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_UNESCAPE_XML: // UnescapeXML( A )\n            calcData[index] = ValueDataUtil.unEscapeXML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ESCAPE_HTML: // EscapeHTML( A )\n            calcData[index] = ValueDataUtil.escapeHTML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_UNESCAPE_HTML: // UnescapeHTML( A )\n            calcData[index] = ValueDataUtil.unEscapeHTML( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ESCAPE_SQL: // EscapeSQL( A )\n            calcData[index] = ValueDataUtil.escapeSQL( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_WORKING_DIFF: // DateWorkingDiff( A , B)\n            calcData[index] = ValueDataUtil.DateWorkingDiff( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_ADD_MONTHS: // Add B months to date field A\n            calcData[index] = ValueDataUtil.addMonths( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_CHECK_XML_FILE_WELL_FORMED: // Check if file A is well formed\n            calcData[index] = ValueDataUtil.isXMLFileWellFormed( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_CHECK_XML_WELL_FORMED: // Check if xml A is well formed\n            calcData[index] = ValueDataUtil.isXMLWellFormed( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_GET_FILE_ENCODING: // Get file encoding from a file A\n            calcData[index] = ValueDataUtil.getFileEncoding( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DAMERAU_LEVENSHTEIN: // DAMERAULEVENSHTEIN DISTANCE\n            calcData[index] = ValueDataUtil.getDamerauLevenshtein_Distance( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_NEEDLEMAN_WUNSH: // NEEDLEMANWUNSH DISTANCE\n            calcData[index] = ValueDataUtil.getNeedlemanWunsch_Distance( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_JARO: // Jaro DISTANCE\n            calcData[index] = ValueDataUtil.getJaro_Similitude( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_JARO_WINKLER: // Jaro DISTANCE\n            calcData[index] = ValueDataUtil.getJaroWinkler_Similitude( metaA, dataA, metaB, dataB );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SOUNDEX: // SOUNDEX\n            calcData[index] = ValueDataUtil.get_SoundEx( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_REFINED_SOUNDEX: // REFINEDSOUNDEX\n            calcData[index] = ValueDataUtil.get_RefinedSoundEx( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_MSEC: // DateA - DateB (ms)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"ms\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_SEC: // DateA - DateB (s)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"s\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_MN: // DateA - DateB (mn)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"mn\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_DATE_DIFF_HR: // DateA - DateB (h)\n            calcData[index] = ValueDataUtil.DateDiff( metaA, dataA, metaB, dataB, \"h\" );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_HOUR_OF_DAY:\n            calcData[index] = ValueDataUtil.hourOfDay( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_MINUTE_OF_HOUR:\n            calcData[index] = ValueDataUtil.minuteOfHour( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          case CalculatorMetaFunction.CALC_SECOND_OF_MINUTE:\n            calcData[index] = ValueDataUtil.secondOfMinute( metaA, dataA );\n            resultType = CalculatorMetaFunction.calcDefaultResultType[calcType];\n            break;\n          default:\n            throw new KettleValueException( BaseMessages.getString( PKG, \"Calculator.Log.UnknownCalculationType\" )\n              + fn.getCalcType() );\n        }\n\n        // If we don't have a target data type, throw an error.\n        // Otherwise the result is non-deterministic.\n        //\n        if ( targetMeta.getType() == ValueMetaInterface.TYPE_NONE ) {\n          throw new KettleValueException( BaseMessages.getString( PKG, \"Calculator.Log.NoType\" )\n            + ( i + 1 ) + \" : \" + fn.getFieldName() + \" = \" + fn.getCalcTypeDesc() + \" / \"\n            + fn.getCalcTypeLongDesc() );\n        }\n\n        // Convert the data to the correct target data type.\n        //\n        if ( calcData[index] != null ) {\n          if ( targetMeta.getType() != resultType ) {\n            ValueMetaInterface resultMeta;\n            try {\n              resultMeta = ValueMetaFactory.createValueMeta( \"result\", resultType );\n            } catch ( Exception exception ) {\n              throw new KettleValueException( \"Error creating value\" );\n            }\n            resultMeta.setConversionMask( fn.getConversionMask() );\n            resultMeta.setGroupingSymbol( fn.getGroupingSymbol() );\n            resultMeta.setDecimalSymbol( fn.getDecimalSymbol() );\n            resultMeta.setCurrencySymbol( fn.getCurrencySymbol() );\n            try {\n              calcData[index] = targetMeta.convertData( resultMeta, calcData[index] );\n            } catch ( Exception ex ) {\n              throw new KettleValueException( \"resultType: \"\n                + resultType + \"; targetMeta: \" + targetMeta.getType(), ex );\n            }\n          }\n        }\n      }\n    }\n\n    // OK, now we should refrain from adding the temporary fields to the result.\n    // So we remove them.\n    //\n    return RowDataUtil.removeItems( calcData, data.getTempIndexes() );\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check( List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta,\n    RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info, VariableSpace space,\n    Repository repository, IMetaStore metaStore ) {\n    CheckResult cr = null;\n\n    // See if we have input streams leading to this step!\n    if ( input.length > 0 ) {\n      cr =\n        new CheckResult( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(\n          PKG, \"CalculatorMeta.CheckResult.ExpectedInputOk\" ), stepMeta );\n      remarks.add( cr );\n\n      if ( prev == null || prev.size() == 0 ) {\n        cr =\n          new CheckResult( CheckResultInterface.TYPE_RESULT_WARNING, BaseMessages.getString(\n            PKG, \"CalculatorMeta.CheckResult.ExpectedInputError\" ), stepMeta );\n        remarks.add( cr );\n      } else {\n        cr =\n          new CheckResult( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(\n            PKG, \"CalculatorMeta.CheckResult.FieldsReceived\", \"\" + prev.size() ), stepMeta );\n        remarks.add( cr );\n      }\n    } else {\n      cr =\n        new CheckResult( CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(\n          PKG, \"CalculatorMeta.CheckResult.ExpectedInputError\" ), stepMeta );\n      remarks.add( cr );\n    }\n  }","id":79769,"modified_method":"public void check( List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta,\n    RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info, VariableSpace space,\n    Repository repository, IMetaStore metaStore ) {\n    CheckResult cr;\n\n    // See if we have input streams leading to this step!\n    if ( input.length > 0 ) {\n      cr =\n        new CheckResult( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(\n          PKG, \"CalculatorMeta.CheckResult.ExpectedInputOk\" ), stepMeta );\n      remarks.add( cr );\n\n      if ( prev == null || prev.size() == 0 ) {\n        cr =\n          new CheckResult( CheckResultInterface.TYPE_RESULT_WARNING, BaseMessages.getString(\n            PKG, \"CalculatorMeta.CheckResult.ExpectedInputError\" ), stepMeta );\n        remarks.add( cr );\n      } else {\n        cr =\n          new CheckResult( CheckResultInterface.TYPE_RESULT_OK, BaseMessages.getString(\n            PKG, \"CalculatorMeta.CheckResult.FieldsReceived\", \"\" + prev.size() ), stepMeta );\n        remarks.add( cr );\n      }\n    } else {\n      cr =\n        new CheckResult( CheckResultInterface.TYPE_RESULT_ERROR, BaseMessages.getString(\n          PKG, \"CalculatorMeta.CheckResult.ExpectedInputError\" ), stepMeta );\n      remarks.add( cr );\n    }\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public RowMetaInterface getAllFields( RowMetaInterface inputRowMeta ) {\n    RowMetaInterface rowMeta = inputRowMeta.clone();\n\n    for ( int i = 0; i < calculation.length; i++ ) {\n      CalculatorMetaFunction fn = calculation[i];\n      if ( !Const.isEmpty( fn.getFieldName() ) ) { // It's a new field!\n        ValueMetaInterface v = getValueMeta( fn, null );\n        rowMeta.addValueMeta( v );\n      }\n    }\n    return rowMeta;\n  }","id":79770,"modified_method":"public RowMetaInterface getAllFields( RowMetaInterface inputRowMeta ) {\n    RowMetaInterface rowMeta = inputRowMeta.clone();\n\n    for ( CalculatorMetaFunction fn : getCalculation() ) {\n      if ( !Const.isEmpty( fn.getFieldName() ) ) { // It's a new field!\n        ValueMetaInterface v = getValueMeta( fn, null );\n        rowMeta.addValueMeta( v );\n      }\n    }\n    return rowMeta;\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private ValueMetaInterface getValueMeta( CalculatorMetaFunction fn, String origin ) {\n    ValueMetaInterface v = null;\n    // What if the user didn't specify a data type?\n    // In that case we look for the default data type\n    //\n    int defaultResultType = fn.getValueType();\n    if ( defaultResultType == ValueMetaInterface.TYPE_NONE ) {\n      defaultResultType = CalculatorMetaFunction.getCalcFunctionDefaultResultType( fn.getCalcType() );\n    }\n    try {\n      v = ValueMetaFactory.createValueMeta( fn.getFieldName(), defaultResultType );\n    } catch ( Exception ex ) {\n      return null;\n    }\n    v.setLength( fn.getValueLength() );\n    v.setPrecision( fn.getValuePrecision() );\n    v.setOrigin( origin );\n    v.setComments( fn.getCalcTypeDesc() );\n    v.setConversionMask( fn.getConversionMask() );\n    v.setDecimalSymbol( fn.getDecimalSymbol() );\n    v.setGroupingSymbol( fn.getGroupingSymbol() );\n    v.setCurrencySymbol( fn.getCurrencySymbol() );\n\n    return v;\n  }","id":79771,"modified_method":"private ValueMetaInterface getValueMeta( CalculatorMetaFunction fn, String origin ) {\n    ValueMetaInterface v;\n    // What if the user didn't specify a data type?\n    // In that case we look for the default data type\n    //\n    int defaultResultType = fn.getValueType();\n    if ( defaultResultType == ValueMetaInterface.TYPE_NONE ) {\n      defaultResultType = CalculatorMetaFunction.getCalcFunctionDefaultResultType( fn.getCalcType() );\n    }\n    try {\n      v = ValueMetaFactory.createValueMeta( fn.getFieldName(), defaultResultType );\n    } catch ( Exception ex ) {\n      return null;\n    }\n    v.setLength( fn.getValueLength() );\n    v.setPrecision( fn.getValuePrecision() );\n    v.setOrigin( origin );\n    v.setComments( fn.getCalcTypeDesc() );\n    v.setConversionMask( fn.getConversionMask() );\n    v.setDecimalSymbol( fn.getDecimalSymbol() );\n    v.setGroupingSymbol( fn.getGroupingSymbol() );\n    v.setCurrencySymbol( fn.getCurrencySymbol() );\n\n    return v;\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      CalculatorMeta m = (CalculatorMeta) obj;\n      return ( getXML() == m.getXML() );\n    }\n\n    return false;\n  }","id":79772,"modified_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      CalculatorMeta m = (CalculatorMeta) obj;\n      return ( getXML().equals( m.getXML() ) );\n    }\n\n    return false;\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getFields( RowMetaInterface row, String origin, RowMetaInterface[] info, StepMeta nextStep,\n    VariableSpace space, Repository repository, IMetaStore metaStore ) throws KettleStepException {\n    for ( int i = 0; i < calculation.length; i++ ) {\n      CalculatorMetaFunction fn = calculation[i];\n      if ( !fn.isRemovedFromResult() ) {\n        if ( !Const.isEmpty( fn.getFieldName() ) ) { // It's a new field!\n          ValueMetaInterface v = getValueMeta( fn, origin );\n          row.addValueMeta( v );\n        }\n      }\n    }\n  }","id":79773,"modified_method":"public void getFields( RowMetaInterface row, String origin, RowMetaInterface[] info, StepMeta nextStep,\n    VariableSpace space, Repository repository, IMetaStore metaStore ) throws KettleStepException {\n    for ( CalculatorMetaFunction fn : calculation ) {\n      if ( !fn.isRemovedFromResult() ) {\n        if ( !Const.isEmpty( fn.getFieldName() ) ) { // It's a new field!\n          ValueMetaInterface v = getValueMeta( fn, origin );\n          row.addValueMeta( v );\n        }\n      }\n    }\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() {\n    StringBuilder retval = new StringBuilder( 300 );\n\n    if ( calculation != null ) {\n      for ( int i = 0; i < calculation.length; i++ ) {\n        retval.append( \"       \" ).append( calculation[i].getXML() ).append( Const.CR );\n      }\n    }\n\n    return retval.toString();\n  }","id":79774,"modified_method":"public String getXML() {\n    StringBuilder retval = new StringBuilder( 300 );\n\n    if ( calculation != null ) {\n      for ( CalculatorMetaFunction aCalculation : calculation ) {\n        retval.append( \"       \" ).append( aCalculation.getXML() ).append( Const.CR );\n      }\n    }\n\n    return retval.toString();\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      CalculatorMetaFunction mf = (CalculatorMetaFunction) obj;\n      return ( getXML() == mf.getXML() );\n    }\n\n    return false;\n  }","id":79775,"modified_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      CalculatorMetaFunction mf = (CalculatorMetaFunction) obj;\n      return ( getXML().equals( mf.getXML() ) );\n    }\n\n    return false;\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static final int getCalcFunctionType( String desc ) {\n    for ( int i = 1; i < calc_desc.length; i++ ) {\n      if ( calc_desc[i].equalsIgnoreCase( desc ) ) {\n        return i;\n      }\n    }\n    for ( int i = 1; i < calcLongDesc.length; i++ ) {\n      if ( calcLongDesc[i].equalsIgnoreCase( desc ) ) {\n        return i;\n      }\n    }\n\n    return CALC_NONE;\n  }","id":79776,"modified_method":"public static int getCalcFunctionType( String desc ) {\n    for ( int i = 1; i < calc_desc.length; i++ ) {\n      if ( calc_desc[ i ].equalsIgnoreCase( desc ) ) {\n        return i;\n      }\n    }\n    for ( int i = 1; i < calcLongDesc.length; i++ ) {\n      if ( calcLongDesc[ i ].equalsIgnoreCase( desc ) ) {\n        return i;\n      }\n    }\n\n    return CALC_NONE;\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static final String getCalcFunctionLongDesc( int type ) {\n    if ( type < 0 || type >= calcLongDesc.length ) {\n      return null;\n    }\n    return calcLongDesc[type];\n  }","id":79777,"modified_method":"public static String getCalcFunctionLongDesc( int type ) {\n    if ( type < 0 || type >= calcLongDesc.length ) {\n      return null;\n    }\n    return calcLongDesc[ type ];\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static final String getCalcFunctionDesc( int type ) {\n    if ( type < 0 || type >= calc_desc.length ) {\n      return null;\n    }\n    return calc_desc[type];\n  }","id":79778,"modified_method":"public static String getCalcFunctionDesc( int type ) {\n    if ( type < 0 || type >= calc_desc.length ) {\n      return null;\n    }\n    return calc_desc[ type ];\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static final int getCalcFunctionDefaultResultType( int type ) {\n    if ( type < 0 || type >= calcDefaultResultType.length ) {\n      return ValueMetaInterface.TYPE_NONE;\n    }\n    return calcDefaultResultType[type];\n  }","id":79779,"modified_method":"public static int getCalcFunctionDefaultResultType( int type ) {\n    if ( type < 0 || type >= calcDefaultResultType.length ) {\n      return ValueMetaInterface.TYPE_NONE;\n    }\n    return calcDefaultResultType[ type ];\n  }","commit_id":"3fe83141fe893f12754f6a41d0c6d753a76d50f6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step, int nr ) throws KettleException {\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"field_name\", fieldName );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"formula_string\", formula );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"value_type\", ValueMeta.getTypeDesc( valueType ) );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"value_length\", valueLength );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"value_precision\", valuePrecision );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"replace_field\", replaceField );\n  }","id":79780,"modified_method":"public void saveRep( Repository rep, IMetaStore metaStore, ObjectId id_transformation, ObjectId id_step, int nr ) throws KettleException {\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"field_name\", fieldName );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"formula_string\", formula );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"value_type\", ValueMetaFactory.getValueMetaName( valueType ) );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"value_length\", valueLength );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"value_precision\", valuePrecision );\n    rep.saveStepAttribute( id_transformation, id_step, nr, \"replace_field\", replaceField );\n  }","commit_id":"87ca200d28c00ad56f37b0a814d211d6263fb347","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() {\n    String xml = \"\";\n\n    xml += \"<\" + XML_TAG + \">\";\n\n    xml += XMLHandler.addTagValue( \"field_name\", fieldName );\n    xml += XMLHandler.addTagValue( \"formula_string\", formula );\n    xml += XMLHandler.addTagValue( \"value_type\", ValueMeta.getTypeDesc( valueType ) );\n    xml += XMLHandler.addTagValue( \"value_length\", valueLength );\n    xml += XMLHandler.addTagValue( \"value_precision\", valuePrecision );\n    xml += XMLHandler.addTagValue( \"replace_field\", replaceField );\n\n    xml += \"<\/\" + XML_TAG + \">\";\n\n    return xml;\n  }","id":79781,"modified_method":"public String getXML() {\n    StringBuilder xml = new StringBuilder();\n\n    xml.append( XMLHandler.openTag( XML_TAG ) );\n\n    xml.append( XMLHandler.addTagValue( \"field_name\", fieldName ) );\n    xml.append( XMLHandler.addTagValue( \"formula_string\", formula ) );\n    xml.append( XMLHandler.addTagValue( \"value_type\", ValueMetaFactory.getValueMetaName( valueType ) ) );\n    xml.append( XMLHandler.addTagValue( \"value_length\", valueLength ) );\n    xml.append( XMLHandler.addTagValue( \"value_precision\", valuePrecision ) );\n    xml.append( XMLHandler.addTagValue( \"replace_field\", replaceField ) );\n\n    xml.append( XMLHandler.closeTag( XML_TAG ) );\n\n    return xml.toString();\n  }","commit_id":"87ca200d28c00ad56f37b0a814d211d6263fb347","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JaninoMetaFunction( Node calcnode ) {\n    fieldName = XMLHandler.getTagValue( calcnode, \"field_name\" );\n    formula = XMLHandler.getTagValue( calcnode, \"formula_string\" );\n    valueType = ValueMeta.getType( XMLHandler.getTagValue( calcnode, \"value_type\" ) );\n    valueLength = Const.toInt( XMLHandler.getTagValue( calcnode, \"value_length\" ), -1 );\n    valuePrecision = Const.toInt( XMLHandler.getTagValue( calcnode, \"value_precision\" ), -1 );\n    replaceField = XMLHandler.getTagValue( calcnode, \"replace_field\" );\n  }","id":79782,"modified_method":"public JaninoMetaFunction( Node calcnode ) {\n    fieldName = XMLHandler.getTagValue( calcnode, \"field_name\" );\n    formula = XMLHandler.getTagValue( calcnode, \"formula_string\" );\n    valueType = ValueMetaFactory.getIdForValueMeta( XMLHandler.getTagValue( calcnode, \"value_type\" ) );\n    valueLength = Const.toInt( XMLHandler.getTagValue( calcnode, \"value_length\" ), -1 );\n    valuePrecision = Const.toInt( XMLHandler.getTagValue( calcnode, \"value_precision\" ), -1 );\n    replaceField = XMLHandler.getTagValue( calcnode, \"replace_field\" );\n  }","commit_id":"87ca200d28c00ad56f37b0a814d211d6263fb347","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      JaninoMetaFunction mf = (JaninoMetaFunction) obj;\n      return ( getXML() == mf.getXML() );\n    }\n\n    return false;\n  }","id":79783,"modified_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      JaninoMetaFunction mf = (JaninoMetaFunction) obj;\n      return ( getXML().equals( mf.getXML() ) );\n    }\n\n    return false;\n  }","commit_id":"87ca200d28c00ad56f37b0a814d211d6263fb347","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JaninoMetaFunction( Repository rep, ObjectId id_step, int nr ) throws KettleException {\n    fieldName = rep.getStepAttributeString( id_step, nr, \"field_name\" );\n    formula = rep.getStepAttributeString( id_step, nr, \"formula_string\" );\n    valueType = ValueMeta.getType( rep.getStepAttributeString( id_step, nr, \"value_type\" ) );\n    valueLength = (int) rep.getStepAttributeInteger( id_step, nr, \"value_length\" );\n    valuePrecision = (int) rep.getStepAttributeInteger( id_step, nr, \"value_precision\" );\n    replaceField = rep.getStepAttributeString( id_step, nr, \"replace_field\" );\n  }","id":79784,"modified_method":"public JaninoMetaFunction( Repository rep, ObjectId id_step, int nr ) throws KettleException {\n    fieldName = rep.getStepAttributeString( id_step, nr, \"field_name\" );\n    formula = rep.getStepAttributeString( id_step, nr, \"formula_string\" );\n    valueType = ValueMetaFactory.getIdForValueMeta( rep.getStepAttributeString( id_step, nr, \"value_type\" ) );\n    valueLength = (int) rep.getStepAttributeInteger( id_step, nr, \"value_length\" );\n    valuePrecision = (int) rep.getStepAttributeInteger( id_step, nr, \"value_precision\" );\n    replaceField = rep.getStepAttributeString( id_step, nr, \"replace_field\" );\n  }","commit_id":"87ca200d28c00ad56f37b0a814d211d6263fb347","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      FormulaMetaFunction mf = (FormulaMetaFunction) obj;\n      return ( getXML() == mf.getXML() );\n    }\n\n    return false;\n  }","id":79785,"modified_method":"public boolean equals( Object obj ) {\n    if ( obj != null && ( obj.getClass().equals( this.getClass() ) ) ) {\n      FormulaMetaFunction mf = (FormulaMetaFunction) obj;\n      return ( getXML().equals( mf.getXML() ) );\n    }\n\n    return false;\n  }","commit_id":"f11fbca991f0f98dc892e77b260b436d1e92a444","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static String call_evaluate_4959435991187146982(SNode thisNode, Context context) {\n    String key = \"usedMacro\";\n    Set<String> usedMacro = context.<Set<String>>get(key);\n    if (usedMacro == null) {\n      usedMacro = SetSequence.fromSet(new HashSet<String>());\n      context.put(key, usedMacro);\n    }\n    if (SetSequence.fromSet(usedMacro).contains(SPropertyOperations.getString(thisNode, \"name\"))) {\n      // cycle \n      return null;\n    }\n    SetSequence.fromSet(usedMacro).addElement(SPropertyOperations.getString(thisNode, \"name\"));\n\n    String result = BuildSourcePath_Behavior.call_getLocalPath_5481553824944787364(SLinkOperations.getTarget(thisNode, \"defaultPath\", true), context);\n\n    SetSequence.fromSet(usedMacro).removeElement(SPropertyOperations.getString(thisNode, \"name\"));\n\n    return result;\n  }","id":79786,"modified_method":"public static String call_evaluate_4959435991187146982(SNode thisNode, Context context) {\n    String key = \"usedMacro\";\n    Set<String> usedMacro = context.<Set<String>>get(key);\n    if (usedMacro == null) {\n      usedMacro = SetSequence.fromSet(new HashSet<String>());\n      context.put(key, usedMacro);\n    }\n    if (SetSequence.fromSet(usedMacro).contains(SPropertyOperations.getString(thisNode, \"name\"))) {\n      // cycle \n      return null;\n    }\n    SetSequence.fromSet(usedMacro).addElement(SPropertyOperations.getString(thisNode, \"name\"));\n    try {\n      return BuildSourcePath_Behavior.call_getLocalPath_5481553824944787364(SLinkOperations.getTarget(thisNode, \"defaultPath\", true), context);\n    } finally {\n      SetSequence.fromSet(usedMacro).removeElement(SPropertyOperations.getString(thisNode, \"name\"));\n    }\n\n\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initModule(SNode module) throws PathConverter.PathConvertException {\n    SPropertyOperations.set(module, \"compact\", \"\" + true);\n    SPropertyOperations.set(module, \"name\", moduleDescriptor.getModuleReference().getModuleFqName());\n    SPropertyOperations.set(module, \"uuid\", moduleDescriptor.getModuleReference().getModuleId().toString());\n    SLinkOperations.setTarget(module, \"path\", converter.convertPath(moduleFile.getPath(), SNodeOperations.getModel(project)), true);\n  }","id":79787,"modified_method":"private void initModule(SNode module) throws PathConverter.PathConvertException {\n    SPropertyOperations.set(module, \"compact\", \"\" + true);\n    SPropertyOperations.set(module, \"name\", moduleDescriptor.getModuleReference().getModuleFqName());\n    SPropertyOperations.set(module, \"uuid\", moduleDescriptor.getModuleReference().getModuleId().toString());\n    SLinkOperations.setTarget(module, \"path\", ListSequence.fromList(converter.convertPath(moduleFile.getPath(), SNodeOperations.getModel(project))).first(), true);\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void checkRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"runtime solution should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        final String localPath = BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p);\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\") && eq_a6ewnz_a0a0a0a0a0a0b0g0c0o(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)), localPath);\n          }\n        }))) {\n          report(\"runtime jar should be extracted into build script: \" + path, myOriginalModule);\n        }\n\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":79788,"modified_method":"private void checkRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"runtime solution should be extracted into build script: \" + module.toString(), myOriginalModule);\n      }\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      List<SNode> p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        final Set<String> localPath = SetSequence.fromSet(new HashSet<String>());\n        ListSequence.fromList(p).visitAll(new IVisitor<SNode>() {\n          public void visit(SNode it) {\n            SetSequence.fromSet(localPath).addElement(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(it));\n          }\n        });\n        if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).any(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\") && SetSequence.fromSet(localPath).contains(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)));\n          }\n        }))) {\n          report(\"runtime jar should be extracted into build script: \" + path, myOriginalModule);\n        }\n\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectLocalDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(jar);\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n    Iterable<ModuleReference> usedLanguages = myModuleDescriptor.getUsedLanguages();\n    Iterable<ModuleReference> usedDevkits = myModuleDescriptor.getUsedDevkits();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      usedLanguages = Sequence.fromIterable(usedLanguages).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModuleReference>() {\n        public Iterable<ModuleReference> translate(GeneratorDescriptor it) {\n          return it.getUsedLanguages();\n        }\n      }));\n      usedDevkits = Sequence.fromIterable(usedDevkits).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModuleReference>() {\n        public Iterable<ModuleReference> translate(GeneratorDescriptor it) {\n          return it.getUsedDevkits();\n        }\n      }));\n    }\n\n    for (ModuleReference lang : usedLanguages) {\n      SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find used language in dependencies: \" + lang.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", null);\n      SLinkOperations.setTarget(ul, \"language\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ul);\n    }\n    for (ModuleReference devkit : usedDevkits) {\n      SNode resolved = SNodeOperations.as(visible.resolve(devkit.getModuleFqName(), devkit.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find used devkit in dependencies: \" + devkit.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ud = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit\", null);\n      SLinkOperations.setTarget(ud, \"devkit\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ud);\n    }\n  }","id":79789,"modified_method":"private void collectLocalDependencies() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(jar);\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n    Iterable<ModuleReference> usedLanguages = myModuleDescriptor.getUsedLanguages();\n    Iterable<ModuleReference> usedDevkits = myModuleDescriptor.getUsedDevkits();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      usedLanguages = Sequence.fromIterable(usedLanguages).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModuleReference>() {\n        public Iterable<ModuleReference> translate(GeneratorDescriptor it) {\n          return it.getUsedLanguages();\n        }\n      }));\n      usedDevkits = Sequence.fromIterable(usedDevkits).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModuleReference>() {\n        public Iterable<ModuleReference> translate(GeneratorDescriptor it) {\n          return it.getUsedDevkits();\n        }\n      }));\n    }\n\n    for (ModuleReference lang : usedLanguages) {\n      SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find used language in dependencies: \" + lang.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyUseLanguage\", null);\n      SLinkOperations.setTarget(ul, \"language\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ul);\n    }\n    for (ModuleReference devkit : usedDevkits) {\n      SNode resolved = SNodeOperations.as(visible.resolve(devkit.getModuleFqName(), devkit.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find used devkit in dependencies: \" + devkit.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ud = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnDevKit\", null);\n      SLinkOperations.setTarget(ud, \"devkit\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(ud);\n    }\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void importRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", null);\n      SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(ul);\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(jar);\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":79790,"modified_method":"private void importRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", null);\n      SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(ul);\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(jar);\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectSources() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    List<String> res = new ArrayList<String>();\n    for (String sp : myModuleDescriptor.getSourcePaths()) {\n      res.add(sp);\n    }\n    IFile genPath = ProjectPathUtil.getGeneratorOutputPath(myModuleFile, myModuleDescriptor);\n    if (genPath != null) {\n      res.add(genPath.getPath());\n    }\n    for (String path : res) {\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n      SNode javaSource = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJavaSource\", null);\n      SLinkOperations.setTarget(javaSource, \"folder\", SConceptOperations.createNewNode(\"jetbrains.mps.build.structure.BuildInputSingleFolder\", null), true);\n      SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(javaSource, \"folder\", true), \"jetbrains.mps.build.structure.BuildInputSingleFolder\"), \"path\", p, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"sources\", true)).addElement(javaSource);\n    }\n    Iterable<ModelRoot> modelRoots = myModuleDescriptor.getModelRoots();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      modelRoots = Sequence.fromIterable(modelRoots).concat(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModelRoot>() {\n        public Iterable<ModelRoot> translate(GeneratorDescriptor it) {\n          return it.getModelRoots();\n        }\n      }));\n    }\n    for (ModelRoot modelRoot : modelRoots) {\n      if (modelRoot.getManager() != null) {\n        continue;\n      }\n\n      String path = modelRoot.getPath();\n      SNode p = convertPath(path, myOriginalModule);\n      if (p == null) {\n        continue;\n      }\n\n      SNode mroot = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleModelRoot\", null);\n      SLinkOperations.setTarget(mroot, \"folder\", p, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"sources\", true)).addElement(mroot);\n    }\n  }","id":79791,"modified_method":"private void collectSources() {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n    List<String> res = new ArrayList<String>();\n    for (String sp : myModuleDescriptor.getSourcePaths()) {\n      res.add(sp);\n    }\n    IFile genPath = ProjectPathUtil.getGeneratorOutputPath(myModuleFile, myModuleDescriptor);\n    if (genPath != null) {\n      res.add(genPath.getPath());\n    }\n    for (String path : res) {\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n      SNode javaSource = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJavaSource\", null);\n      SLinkOperations.setTarget(javaSource, \"folder\", SConceptOperations.createNewNode(\"jetbrains.mps.build.structure.BuildInputSingleFolder\", null), true);\n      SLinkOperations.setTarget(SNodeOperations.cast(SLinkOperations.getTarget(javaSource, \"folder\", true), \"jetbrains.mps.build.structure.BuildInputSingleFolder\"), \"path\", p, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"sources\", true)).addElement(javaSource);\n    }\n    Iterable<ModelRoot> modelRoots = myModuleDescriptor.getModelRoots();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      modelRoots = Sequence.fromIterable(modelRoots).concat(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, ModelRoot>() {\n        public Iterable<ModelRoot> translate(GeneratorDescriptor it) {\n          return it.getModelRoots();\n        }\n      }));\n    }\n    for (ModelRoot modelRoot : modelRoots) {\n      if (modelRoot.getManager() != null) {\n        continue;\n      }\n\n      String path = modelRoot.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      SNode mroot = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleModelRoot\", null);\n      SLinkOperations.setTarget(mroot, \"folder\", p, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"sources\", true)).addElement(mroot);\n    }\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String normalizePath(String path, boolean addSlash) {\n    try {\n      path = new File(path).getCanonicalPath();\n      path = path.replace(\"\\\\\", \"/\");\n    } catch (IOException ignore) {\n      // ignore \n    }\n    if (addSlash && !(path.endsWith(\"/\"))) {\n      path = path + \"/\";\n    }\n    return path;\n  }","id":79792,"modified_method":"private static String normalizePath(String path, boolean addSlash) {\n    if (path == null || StringUtils.isEmpty(path)) {\n      return null;\n    }\n    try {\n      path = new File(path).getCanonicalPath();\n      path = path.replace(\"\\\\\", \"/\");\n    } catch (IOException ignore) {\n      // ignore \n    }\n    if (addSlash && !(path.endsWith(\"/\"))) {\n      path = path + \"/\";\n    }\n    return path;\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PathConverter(SNode project) {\n    String workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(project, Context.defaultContext());\n    this.workingDirectory = normalizePath(workingDir, true);\n  }","id":79793,"modified_method":"public PathConverter(SNode project) {\n    String workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(project, Context.defaultContext());\n    this.workingDirectory = normalizePath(workingDir, true);\n\n    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());\n    ListSequence.fromList(SLinkOperations.getTargets(project, \"macros\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.structure.BuildFolderMacro\");\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        String path = normalizePath(BuildFolderMacro_Behavior.call_evaluate_4959435991187146982(SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\"), Context.defaultContext()), true);\n        if (path != null && path.length() > 1) {\n          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, \"jetbrains.mps.build.structure.BuildFolderMacro\")));\n        }\n      }\n    });\n    ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(workingDir, (SNode) null));\n    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Comparable<?>>() {\n      public Comparable<?> select(Tuples._2<String, SNode> it) {\n        return it._0().length() * 2 - ((it._1() == null ?\n          1 :\n          0\n        ));\n      }\n    }, false);\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode convertPath(String path, SModel model) throws PathConverter.PathConvertException {\n    path = normalizePath(path, false);\n    if (path.length() < workingDirectory.length()) {\n      path = normalizePath(path, true);\n    }\n    if (!(path.startsWith(workingDirectory))) {\n      throw new PathConverter.PathConvertException(\"source path (\" + path + \") should be under working directory (\" + workingDirectory + \")\");\n    }\n    path = path.substring(workingDirectory.length());\n    SNode plp = SModelOperations.createNewNode(model, \"jetbrains.mps.build.structure.BuildSourceProjectRelativePath\", null);\n    SNode last = null;\n    for (String fname : path.split(\"/\")) {\n      if (StringUtils.isNotEmpty(fname)) {\n        SNode npath = SModelOperations.createNewNode(model, \"jetbrains.mps.build.structure.BuildCompositePath\", null);\n        SPropertyOperations.set(npath, \"head\", fname);\n        if (last == null) {\n          SLinkOperations.setTarget(plp, \"compositePart\", npath, true);\n        } else {\n          SLinkOperations.setTarget(last, \"tail\", npath, true);\n        }\n        last = npath;\n      }\n    }\n    return plp;\n  }","id":79794,"modified_method":"public List<SNode> convertPath(String path, SModel model) throws PathConverter.PathConvertException {\n    path = normalizePath(path, false);\n    String withSlash = normalizePath(path, true);\n    List<SNode> result = new ArrayList<SNode>();\n    for (Tuples._2<String, SNode> m : Sequence.fromIterable(macros)) {\n      String mdir = m._0();\n      String currPath = (path.length() < mdir.length() ?\n        withSlash :\n        path\n      );\n      if (!(currPath.startsWith(mdir))) {\n        continue;\n      }\n      currPath = currPath.substring(mdir.length());\n      SNode relPath;\n      if (m._1() == null) {\n        relPath = SModelOperations.createNewNode(model, \"jetbrains.mps.build.structure.BuildSourceProjectRelativePath\", null);\n      } else {\n        relPath = SModelOperations.createNewNode(model, \"jetbrains.mps.build.structure.BuildSourceMacroRelativePath\", null);\n        SLinkOperations.setTarget(SNodeOperations.cast(relPath, \"jetbrains.mps.build.structure.BuildSourceMacroRelativePath\"), \"macro\", m._1(), false);\n      }\n      buildCompositePath(relPath, currPath, model);\n      ListSequence.fromList(result).addElement(relPath);\n\n    }\n    if ((int) ListSequence.fromList(result).count() == 0) {\n      throw new PathConverter.PathConvertException(\"source path (\" + path + \") should be under working directory (\" + workingDirectory + \"), or any macros default directory\");\n\n    }\n    return result;\n  }","commit_id":"0258bc50f45ea07adb8db4d2f55eca19c80436f8","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Activate\n\tprotected void activate(Map<String, Object> properties) {\n\t\t_s3StoreConfiguration = Configurable.createConfigurable(\n\t\t\tS3StoreConfiguration.class, properties);\n\n\t\ttry {\n\t\t\t_s3Service = getS3Service();\n\t\t\t_s3Bucket = getS3Bucket();\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tthrow new IllegalArgumentException(s3se);\n\t\t}\n\t}","id":79795,"modified_method":"@Activate\n\tprotected void activate(Map<String, Object> properties) {\n\t\t_s3StoreConfiguration = Configurable.createConfigurable(\n\t\t\tS3StoreConfiguration.class, properties);\n\n\t\t_bucketName = _s3StoreConfiguration.bucketName();\n\n\t\t_awsCredentialsProvider = getAWSCredentialsProvider();\n\n\t\t_amazonS3 = getAmazonS3(_awsCredentialsProvider);\n\n\t\t_s3KeyTransformer = new S3KeyTransformer();\n\n\t\tint tempDirCleanUpExpunge = GetterUtil.getInteger(\n\t\t\t_s3StoreConfiguration.tempDirCleanUpExpunge());\n\n\t\tint tempDirCleanUpFrequency = GetterUtil.getInteger(\n\t\t\t_s3StoreConfiguration.tempDirCleanUpFrequency());\n\n\t\t_s3LocalStore = new S3LocalStore(\n\t\t\t_s3KeyTransformer, tempDirCleanUpExpunge, tempDirCleanUpFrequency);\n\n\t\ttry {\n\t\t\tif (Validator.isNull(_s3StoreConfiguration.s3StorageClass())) {\n\t\t\t\t_storageClass = StorageClass.Standard;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_storageClass = StorageClass.fromValue(\n\t\t\t\t\t_s3StoreConfiguration.s3StorageClass());\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalArgumentException iae) {\n\t\t\t_storageClass = StorageClass.Standard;\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(iae);\n\t\t\t}\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean hasFile(\n\t\tlong companyId, long repositoryId, String fileName,\n\t\tString versionLabel) {\n\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(),\n\t\t\t\tgetKey(companyId, repositoryId, fileName, versionLabel), null);\n\n\t\t\tif (s3Objects.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tif (isS3NoSuchKeyException(s3se)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthrow new SystemException(s3se);\n\t\t}\n\t}","id":79796,"modified_method":"@Override\n\tpublic boolean hasFile(\n\t\tlong companyId, long repositoryId, String fileName,\n\t\tString versionLabel) {\n\n\t\tS3Object s3Object = null;\n\n\t\ttry {\n\t\t\ts3Object = getS3Object(\n\t\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (NoSuchFileException nsfe) {\n\t\t\treturn false;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (s3Object != null) {\n\t\t\t\t\ts3Object.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Failed to close S3Object, connection to AWS\" +\n\t\t\t\t\t\t\t\" S3 bucket may be open\",\n\t\t\t\t\t\tioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString newFileName)\n\t\tthrows DuplicateFileException, NoSuchFileException {\n\n\t\tFile tempFile = null;\n\t\tInputStream is = null;\n\t\tS3Object newS3Object = null;\n\n\t\tif (!hasFile(companyId, repositoryId, fileName)) {\n\t\t\tthrow new NoSuchFileException(companyId, repositoryId, fileName);\n\t\t}\n\n\t\tif (hasFile(companyId, repositoryId, newFileName)) {\n\t\t\tthrow new DuplicateFileException(\n\t\t\t\tcompanyId, repositoryId, newFileName);\n\t\t}\n\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId, fileName),\n\t\t\t\tnull);\n\n\t\t\tfor (S3Object oldS3Object : s3Objects) {\n\t\t\t\tString oldKey = oldS3Object.getKey();\n\n\t\t\t\toldS3Object = _s3Service.getObject(_s3Bucket.getName(), oldKey);\n\n\t\t\t\ttempFile = new File(\n\t\t\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) +\n\t\t\t\t\t\tFile.separator + PortalUUIDUtil.generate());\n\n\t\t\t\tFileUtil.write(tempFile, oldS3Object.getDataInputStream());\n\n\t\t\t\toldS3Object.closeDataInputStream();\n\n\t\t\t\tis = new FileInputStream(tempFile);\n\n\t\t\t\tString newPrefix = getKey(companyId, repositoryId, newFileName);\n\n\t\t\t\tint x = oldKey.indexOf(StringPool.SLASH);\n\n\t\t\t\tx = oldKey.indexOf(CharPool.SLASH, x + 1);\n\t\t\t\tx = oldKey.indexOf(CharPool.SLASH, x + 1);\n\n\t\t\t\tString newKey = newPrefix + oldKey.substring(x);\n\n\t\t\t\tnewS3Object = new S3Object(_s3Bucket, newKey);\n\n\t\t\t\tnewS3Object.setDataInputStream(is);\n\n\t\t\t\t_s3Service.putObject(_s3Bucket, newS3Object);\n\t\t\t\t_s3Service.deleteObject(_s3Bucket, oldKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(is);\n\n\t\t\tFileUtil.delete(tempFile);\n\t\t}\n\t}","id":79797,"modified_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString newFileName)\n\t\tthrows PortalException {\n\n\t\tString oldPrefix = _s3KeyTransformer.getFileKey(\n\t\t\tcompanyId, repositoryId, fileName);\n\t\tString newPrefix = _s3KeyTransformer.getFileKey(\n\t\t\tcompanyId, repositoryId, newFileName);\n\n\t\tmoveObjects(oldPrefix, newPrefix);\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getKey(\n\t\tlong companyId, long repositoryId, String fileName,\n\t\tString versionLabel) {\n\n\t\tStringBundler sb = new StringBundler(6);\n\n\t\tsb.append(companyId);\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(repositoryId);\n\t\tsb.append(getNormalizedFileName(fileName));\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(versionLabel);\n\n\t\treturn sb.toString();\n\t}","id":79798,"modified_method":"protected S3Object getS3Object(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel)\n\t\tthrows NoSuchFileException {\n\n\t\tif (Validator.isNull(versionLabel)) {\n\t\t\tversionLabel = getHeadVersionLabel(\n\t\t\t\tcompanyId, repositoryId, fileName);\n\t\t}\n\n\t\tString key = _s3KeyTransformer.getFileVersionKey(\n\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\n\t\ttry {\n\t\t\tGetObjectRequest request = new GetObjectRequest(_bucketName, key);\n\n\t\t\tS3Object s3Object = _amazonS3.getObject(request);\n\n\t\t\tif (s3Object == null) {\n\t\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn s3Object;\n\t\t\t}\n\t\t}\n\t\tcatch (AmazonClientException ae) {\n\t\t\tif (isFileNotFound(ae)) {\n\t\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\t\t\t}\n\n\t\t\tthrow convertAWSException(ae);\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, long newRepositoryId,\n\t\t\tString fileName)\n\t\tthrows DuplicateFileException, NoSuchFileException {\n\n\t\tFile tempFile = null;\n\t\tInputStream is = null;\n\t\tS3Object newS3Object = null;\n\n\t\tif (!hasFile(companyId, repositoryId, fileName)) {\n\t\t\tthrow new NoSuchFileException(companyId, newRepositoryId, fileName);\n\t\t}\n\n\t\tif (hasFile(companyId, newRepositoryId, fileName)) {\n\t\t\tthrow new DuplicateFileException(\n\t\t\t\tcompanyId, newRepositoryId, fileName);\n\t\t}\n\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId, fileName),\n\t\t\t\tnull);\n\n\t\t\tfor (S3Object oldS3Object : s3Objects) {\n\t\t\t\tString oldKey = oldS3Object.getKey();\n\n\t\t\t\toldS3Object = _s3Service.getObject(_s3Bucket.getName(), oldKey);\n\n\t\t\t\ttempFile = new File(\n\t\t\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) +\n\t\t\t\t\t\tFile.separator + PortalUUIDUtil.generate());\n\n\t\t\t\tFileUtil.write(tempFile, oldS3Object.getDataInputStream());\n\n\t\t\t\tis = new FileInputStream(tempFile);\n\n\t\t\t\tString newPrefix = getKey(companyId, newRepositoryId);\n\n\t\t\t\tint x = oldKey.indexOf(CharPool.SLASH);\n\n\t\t\t\tx = oldKey.indexOf(CharPool.SLASH, x + 1);\n\n\t\t\t\tString newKey = newPrefix + oldKey.substring(x);\n\n\t\t\t\tnewS3Object = new S3Object(_s3Bucket, newKey);\n\n\t\t\t\tnewS3Object.setDataInputStream(is);\n\n\t\t\t\t_s3Service.putObject(_s3Bucket, newS3Object);\n\t\t\t\t_s3Service.deleteObject(_s3Bucket, oldKey);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(is);\n\n\t\t\tFileUtil.delete(tempFile);\n\t\t}\n\t}","id":79799,"modified_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, long newRepositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException {\n\n\t\tString oldPrefix = _s3KeyTransformer.getFileKey(\n\t\t\tcompanyId, repositoryId, fileName);\n\t\tString newPrefix = _s3KeyTransformer.getFileKey(\n\t\t\tcompanyId, newRepositoryId, fileName);\n\n\t\tmoveObjects(oldPrefix, newPrefix);\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel, InputStream is)\n\t\tthrows DuplicateFileException, NoSuchFileException {\n\n\t\tif (hasFile(companyId, repositoryId, fileName, versionLabel)) {\n\t\t\tthrow new DuplicateFileException(\n\t\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\t\t}\n\n\t\ttry {\n\t\t\tS3Object s3Object = new S3Object(\n\t\t\t\t_s3Bucket,\n\t\t\t\tgetKey(companyId, repositoryId, fileName, versionLabel));\n\n\t\t\ts3Object.setDataInputStream(is);\n\n\t\t\t_s3Service.putObject(_s3Bucket, s3Object);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (isS3NoSuchKeyException(e)) {\n\t\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\tcompanyId, repositoryId, fileName, versionLabel, e);\n\t\t\t}\n\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(is);\n\t\t}\n\t}","id":79800,"modified_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel, InputStream is)\n\t\tthrows PortalException {\n\n\t\tif (hasFile(companyId, repositoryId, fileName, versionLabel)) {\n\t\t\tthrow new DuplicateFileException(\n\t\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\t\t}\n\n\t\ttry {\n\t\t\tObjectMetadata objectMetadata = constructMetadata(fileName);\n\t\t\tString objectKey = _s3KeyTransformer.getFileVersionKey(\n\t\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\n\t\t\tPutObjectRequest request = new PutObjectRequest(\n\t\t\t\t_bucketName, objectKey, is, objectMetadata);\n\n\t\t\t_amazonS3.putObject(request);\n\t\t}\n\t\tcatch (AmazonClientException ae) {\n\t\t\tthrow convertAWSException(ae);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(is);\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void deleteDirectory(\n\t\tlong companyId, long repositoryId, String dirName) {\n\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId, dirName),\n\t\t\t\tnull);\n\n\t\t\tfor (S3Object s3Object : s3Objects) {\n\t\t\t\t_s3Service.deleteObject(_s3Bucket, s3Object.getKey());\n\t\t\t}\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tif (isS3NoSuchKeyException(s3se)) {\n\t\t\t\tlogFailedDeletion(companyId, repositoryId, dirName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new SystemException(s3se);\n\t\t\t}\n\t\t}\n\t}","id":79801,"modified_method":"@Override\n\tpublic void deleteDirectory(\n\t\tlong companyId, long repositoryId, String dirName) {\n\n\t\tString prefix = _s3KeyTransformer.getDirectoryKey(\n\t\t\tcompanyId, repositoryId, dirName);\n\n\t\tdeleteObjectsWithPrefix(prefix);\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic File getFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel)\n\t\tthrows NoSuchFileException {\n\n\t\ttry {\n\t\t\tif (Validator.isNull(versionLabel)) {\n\t\t\t\tversionLabel = getHeadVersionLabel(\n\t\t\t\t\tcompanyId, repositoryId, fileName);\n\t\t\t}\n\n\t\t\tS3Object s3Object = _s3Service.getObject(\n\t\t\t\t_s3Bucket.getName(),\n\t\t\t\tgetKey(companyId, repositoryId, fileName, versionLabel));\n\n\t\t\tFile tempFile = getTempFile(s3Object, fileName);\n\n\t\t\tcleanUpTempFiles();\n\n\t\t\treturn tempFile;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (isS3NoSuchKeyException(e)) {\n\t\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\tcompanyId, repositoryId, fileName, versionLabel, e);\n\t\t\t}\n\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t}","id":79802,"modified_method":"@Override\n\tpublic File getFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel)\n\t\tthrows PortalException {\n\n\t\tS3Object s3Object = getS3Object(\n\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\n\t\ttry {\n\t\t\tFile tempFile = _s3LocalStore.getTempFile(s3Object, fileName);\n\n\t\t\t_s3LocalStore.cleanUpTempFiles();\n\n\t\t\treturn tempFile;\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected AWSCredentials getAWSCredentials() throws S3ServiceException {\n\t\tString accessKey = _s3StoreConfiguration.accessKey();\n\t\tString secretKey = _s3StoreConfiguration.secretKey();\n\n\t\tif (Validator.isNull(accessKey) || Validator.isNull(secretKey)) {\n\t\t\tthrow new S3ServiceException(\n\t\t\t\t\"S3 access and secret keys are not set\");\n\t\t}\n\t\telse {\n\t\t\treturn new AWSCredentials(accessKey, secretKey);\n\t\t}\n\t}","id":79803,"modified_method":"protected AWSCredentialsProvider getAWSCredentialsProvider() {\n\t\tString accessKey = _s3StoreConfiguration.accessKey();\n\t\tString secretKey = _s3StoreConfiguration.secretKey();\n\n\t\tif (Validator.isNotNull(accessKey) && Validator.isNotNull(secretKey)) {\n\t\t\tAWSCredentials awsCredentials = new BasicAWSCredentials(\n\t\t\t\taccessKey, secretKey);\n\n\t\t\treturn new StaticCredentialsProvider(awsCredentials);\n\t\t}\n\t\telse {\n\t\t\treturn new DefaultAWSCredentialsProviderChain();\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getHeadVersionLabel(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows NoSuchFileException, S3ServiceException {\n\n\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId, fileName),\n\t\t\tnull);\n\n\t\tString[] keys = new String[s3Objects.length];\n\n\t\tfor (int i = 0; i < s3Objects.length; i++) {\n\t\t\tS3Object s3Object = s3Objects[i];\n\n\t\t\tkeys[i] = s3Object.getKey();\n\t\t}\n\n\t\tif (keys.length > 0) {\n\t\t\tArrays.sort(keys);\n\n\t\t\tString headKey = keys[keys.length - 1];\n\n\t\t\tint x = headKey.lastIndexOf(CharPool.SLASH);\n\n\t\t\treturn headKey.substring(x + 1);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchFileException(companyId, repositoryId, fileName);\n\t\t}\n\t}","id":79804,"modified_method":"protected String getHeadVersionLabel(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows NoSuchFileException {\n\n\t\tString prefix = _s3KeyTransformer.getFileKey(\n\t\t\tcompanyId, repositoryId, fileName);\n\n\t\tList<S3ObjectSummary> versions = listObjectsWithPrefix(prefix);\n\n\t\tString[] keys = new String[versions.size()];\n\n\t\tIterator<S3ObjectSummary> versionsIterator = versions.iterator();\n\n\t\tfor (int i = 0; i < keys.length; i++) {\n\t\t\tS3ObjectSummary s3ObjectSummary = versionsIterator.next();\n\n\t\t\tkeys[i] = s3ObjectSummary.getKey();\n\t\t}\n\n\t\tif (keys.length > 0) {\n\t\t\tArrays.sort(keys);\n\n\t\t\tString headKey = keys[keys.length - 1];\n\n\t\t\tint x = headKey.lastIndexOf(CharPool.SLASH);\n\n\t\t\treturn headKey.substring(x + 1);\n\t\t}\n\t\telse {\n\t\t\tthrow new NoSuchFileException(companyId, repositoryId, fileName);\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Deactivate\n\tprotected void deactivate() throws ServiceException {\n\t\tif (!_s3Service.isShutdown()) {\n\t\t\t_s3Service.shutdown();\n\t\t}\n\n\t\t_s3Bucket = null;\n\t\t_s3Service = null;\n\t\t_s3StoreConfiguration = null;\n\t}","id":79805,"modified_method":"@Deactivate\n\tprotected void deactivate() {\n\t\t_amazonS3 = null;\n\t\t_awsCredentialsProvider = null;\n\t\t_bucketName = null;\n\t\t_s3StoreConfiguration = null;\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void deleteFile(long companyId, long repositoryId, String fileName) {\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId, fileName),\n\t\t\t\tnull);\n\n\t\t\tfor (S3Object s3Object : s3Objects) {\n\t\t\t\t_s3Service.deleteObject(_s3Bucket, s3Object.getKey());\n\t\t\t}\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tif (isS3NoSuchKeyException(s3se)) {\n\t\t\t\tlogFailedDeletion(companyId, repositoryId, fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new SystemException(s3se);\n\t\t\t}\n\t\t}\n\t}","id":79806,"modified_method":"@Override\n\tpublic void deleteFile(long companyId, long repositoryId, String fileName) {\n\t\tString prefix = _s3KeyTransformer.getFileKey(\n\t\t\tcompanyId, repositoryId, fileName);\n\n\t\tdeleteObjectsWithPrefix(prefix);\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName, InputStream is)\n\t\tthrows DuplicateFileException {\n\n\t\tif (hasFile(companyId, repositoryId, fileName)) {\n\t\t\tthrow new DuplicateFileException(companyId, repositoryId, fileName);\n\t\t}\n\n\t\ttry {\n\t\t\tS3Object s3Object = new S3Object(\n\t\t\t\t_s3Bucket,\n\t\t\t\tgetKey(companyId, repositoryId, fileName, VERSION_DEFAULT));\n\n\t\t\ts3Object.setDataInputStream(is);\n\n\t\t\t_s3Service.putObject(_s3Bucket, s3Object);\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tthrow new SystemException(s3se);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(is);\n\t\t}\n\t}","id":79807,"modified_method":"@Override\n\tpublic void addFile(\n\t\t\tlong companyId, long repositoryId, String fileName, InputStream is)\n\t\tthrows PortalException {\n\n\t\tif (hasFile(companyId, repositoryId, fileName)) {\n\t\t\tthrow new DuplicateFileException(companyId, repositoryId, fileName);\n\t\t}\n\n\t\ttry {\n\t\t\tObjectMetadata objectMetadata = constructMetadata(fileName);\n\t\t\tString objectKey = _s3KeyTransformer.getFileVersionKey(\n\t\t\t\tcompanyId, repositoryId, fileName, VERSION_DEFAULT);\n\n\t\t\tPutObjectRequest request = new PutObjectRequest(\n\t\t\t\t_bucketName, objectKey, is, objectMetadata);\n\n\t\t\trequest.withStorageClass(_storageClass);\n\n\t\t\t_amazonS3.putObject(request);\n\t\t}\n\t\tcatch (AmazonClientException ae) {\n\t\t\tthrow convertAWSException(ae);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(is);\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel)\n\t\tthrows NoSuchFileException {\n\n\t\ttry {\n\t\t\tif (Validator.isNull(versionLabel)) {\n\t\t\t\tversionLabel = getHeadVersionLabel(\n\t\t\t\t\tcompanyId, repositoryId, fileName);\n\t\t\t}\n\n\t\t\tS3Object s3Object = _s3Service.getObject(\n\t\t\t\t_s3Bucket.getName(),\n\t\t\t\tgetKey(companyId, repositoryId, fileName, versionLabel));\n\n\t\t\treturn s3Object.getDataInputStream();\n\t\t}\n\t\tcatch (ServiceException se) {\n\t\t\tif (isS3NoSuchKeyException(se)) {\n\t\t\t\tthrow new NoSuchFileException(\n\t\t\t\t\tcompanyId, repositoryId, fileName, versionLabel, se);\n\t\t\t}\n\n\t\t\tthrow new SystemException(se);\n\t\t}\n\t}","id":79808,"modified_method":"@Override\n\tpublic InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionLabel)\n\t\tthrows PortalException {\n\n\t\tS3Object s3Object = getS3Object(\n\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\n\t\treturn s3Object.getObjectContent();\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void deleteFile(\n\t\tlong companyId, long repositoryId, String fileName,\n\t\tString versionLabel) {\n\n\t\ttry {\n\t\t\t_s3Service.deleteObject(\n\t\t\t\t_s3Bucket,\n\t\t\t\tgetKey(companyId, repositoryId, fileName, versionLabel));\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tif (isS3NoSuchKeyException(s3se)) {\n\t\t\t\tlogFailedDeletion(companyId, repositoryId, fileName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new SystemException(s3se);\n\t\t\t}\n\t\t}\n\t}","id":79809,"modified_method":"@Override\n\tpublic void deleteFile(\n\t\tlong companyId, long repositoryId, String fileName,\n\t\tString versionLabel) {\n\n\t\tString key = _s3KeyTransformer.getFileVersionKey(\n\t\t\tcompanyId, repositoryId, fileName, versionLabel);\n\n\t\ttry {\n\t\t\tDeleteObjectRequest request = new DeleteObjectRequest(\n\t\t\t\t_bucketName, key);\n\n\t\t\t_amazonS3.deleteObject(request);\n\t\t}\n\t\tcatch (AmazonClientException ae) {\n\t\t\tthrow convertAWSException(ae);\n\t\t}\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String[] getFileNames(long companyId, long repositoryId) {\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId), null);\n\n\t\t\treturn getFileNames(s3Objects);\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tif (isS3NoSuchKeyException(s3se)) {\n\t\t\t\treturn new String[0];\n\t\t\t}\n\n\t\t\tthrow new SystemException(s3se);\n\t\t}\n\t}","id":79810,"modified_method":"@Override\n\tpublic String[] getFileNames(long companyId, long repositoryId) {\n\t\treturn getFileNames(companyId, repositoryId, StringPool.BLANK);\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String[] getFileNames(\n\t\tlong companyId, long repositoryId, String dirName) {\n\n\t\ttry {\n\t\t\tS3Object[] s3Objects = _s3Service.listObjects(\n\t\t\t\t_s3Bucket.getName(), getKey(companyId, repositoryId, dirName),\n\t\t\t\tnull);\n\n\t\t\treturn getFileNames(s3Objects);\n\t\t}\n\t\tcatch (S3ServiceException s3se) {\n\t\t\tif (isS3NoSuchKeyException(s3se)) {\n\t\t\t\treturn new String[0];\n\t\t\t}\n\n\t\t\tthrow new SystemException(s3se);\n\t\t}\n\t}","id":79811,"modified_method":"@Override\n\tpublic String[] getFileNames(\n\t\tlong companyId, long repositoryId, String dirName) {\n\n\t\tString prefix = null;\n\n\t\tif (Validator.isNull(dirName)) {\n\t\t\tprefix = _s3KeyTransformer.getRepositoryKey(\n\t\t\t\tcompanyId, repositoryId);\n\t\t}\n\t\telse {\n\t\t\tprefix = _s3KeyTransformer.getDirectoryKey(\n\t\t\t\tcompanyId, repositoryId, dirName);\n\t\t}\n\n\t\tList<S3ObjectSummary> objectSummaries = listObjectsWithPrefix(prefix);\n\n\t\tString[] fileNames = new String[objectSummaries.size()];\n\n\t\tIterator<S3ObjectSummary> objectSummaryIterator =\n\t\t\tobjectSummaries.iterator();\n\n\t\tfor (int i = 0; i < fileNames.length; i++) {\n\t\t\tS3ObjectSummary s3ObjectSummary = objectSummaryIterator.next();\n\n\t\t\tString objectKey = s3ObjectSummary.getKey();\n\n\t\t\tfileNames[i] = _s3KeyTransformer.getFileName(objectKey);\n\t\t}\n\n\t\treturn fileNames;\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic long getFileSize(long companyId, long repositoryId, String fileName)\n\t\tthrows NoSuchFileException {\n\n\t\ttry {\n\t\t\tString versionLabel = getHeadVersionLabel(\n\t\t\t\tcompanyId, repositoryId, fileName);\n\n\t\t\tStorageObject storageObject = _s3Service.getObjectDetails(\n\t\t\t\t_s3Bucket.getName(),\n\t\t\t\tgetKey(companyId, repositoryId, fileName, versionLabel));\n\n\t\t\treturn storageObject.getContentLength();\n\t\t}\n\t\tcatch (ServiceException se) {\n\t\t\tthrow new SystemException(se);\n\t\t}\n\t}","id":79812,"modified_method":"@Override\n\tpublic long getFileSize(long companyId, long repositoryId, String fileName)\n\t\tthrows PortalException {\n\n\t\tString version = getHeadVersionLabel(companyId, repositoryId, fileName);\n\t\tString key = _s3KeyTransformer.getFileVersionKey(\n\t\t\tcompanyId, repositoryId, fileName, version);\n\n\t\tGetObjectMetadataRequest request = new GetObjectMetadataRequest(\n\t\t\t_bucketName, key);\n\n\t\tObjectMetadata objectMetadata = _amazonS3.getObjectMetadata(request);\n\n\t\tif (objectMetadata == null) {\n\t\t\tthrow new NoSuchFileException(companyId, repositoryId, fileName);\n\t\t}\n\n\t\treturn objectMetadata.getContentLength();\n\t}","commit_id":"f02a1bdb1c4b16181b36ff4be55164efa687a09c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void incrementBackupEntryMemoryCost(long backupEntryMemoryCost) {\n        this.backupEntryMemoryCost.addAndGet(backupEntryMemoryCost);\n    }","id":79813,"modified_method":"public void incrementBackupEntryMemoryCost(long backupEntryMemoryCost) {\n        this.backupEntryMemoryCost += backupEntryMemoryCost;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void writeData(ObjectDataOutput out)\n            throws IOException {\n        out.writeLong(getCount);\n        out.writeLong(putCount);\n        out.writeLong(removeCount);\n        out.writeLong(numberOfOtherOperations);\n        out.writeLong(numberOfEvents);\n        out.writeLong(lastAccessTime);\n        out.writeLong(lastUpdateTime);\n        out.writeLong(hits);\n        out.writeLong(ownedEntryCount.get());\n        out.writeLong(backupEntryCount.get());\n        out.writeInt(backupCount.get());\n        out.writeLong(ownedEntryMemoryCost.get());\n        out.writeLong(backupEntryMemoryCost.get());\n        out.writeLong(creationTime);\n        out.writeLong(lockedEntryCount.get());\n        out.writeLong(dirtyEntryCount.get());\n        out.writeLong(totalGetLatencies);\n        out.writeLong(totalPutLatencies);\n        out.writeLong(totalRemoveLatencies);\n        out.writeLong(maxGetLatency);\n        out.writeLong(maxPutLatency);\n        out.writeLong(maxRemoveLatency);\n        out.writeLong(heapCost.get());\n        boolean hasNearCache = nearCacheStats != null;\n        out.writeBoolean(hasNearCache);\n        if (hasNearCache) {\n            nearCacheStats.writeData(out);\n        }\n    }","id":79814,"modified_method":"@Override\n    public void writeData(ObjectDataOutput out)\n            throws IOException {\n        out.writeLong(getCount);\n        out.writeLong(putCount);\n        out.writeLong(removeCount);\n        out.writeLong(numberOfOtherOperations);\n        out.writeLong(numberOfEvents);\n        out.writeLong(lastAccessTime);\n        out.writeLong(lastUpdateTime);\n        out.writeLong(hits);\n        out.writeLong(ownedEntryCount);\n        out.writeLong(backupEntryCount);\n        out.writeInt(backupCount);\n        out.writeLong(ownedEntryMemoryCost);\n        out.writeLong(backupEntryMemoryCost);\n        out.writeLong(creationTime);\n        out.writeLong(lockedEntryCount);\n        out.writeLong(dirtyEntryCount);\n        out.writeLong(totalGetLatencies);\n        out.writeLong(totalPutLatencies);\n        out.writeLong(totalRemoveLatencies);\n        out.writeLong(maxGetLatency);\n        out.writeLong(maxPutLatency);\n        out.writeLong(maxRemoveLatency);\n        out.writeLong(heapCost);\n        boolean hasNearCache = nearCacheStats != null;\n        out.writeBoolean(hasNearCache);\n        if (hasNearCache) {\n            nearCacheStats.writeData(out);\n        }\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void incrementBackupEntryCount(long backupEntryCount) {\n        this.backupEntryCount.addAndGet(backupEntryCount);\n    }","id":79815,"modified_method":"public void incrementBackupEntryCount(long backupEntryCount) {\n        this.backupEntryCount += backupEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getHeapCost() {\n        return heapCost.get();\n    }","id":79816,"modified_method":"@Override\n    public long getHeapCost() {\n        return heapCost;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getOwnedEntryCount() {\n        return ownedEntryCount.get();\n    }","id":79817,"modified_method":"@Override\n    public long getOwnedEntryCount() {\n        return ownedEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void fromJson(JsonObject json) {\n        GET_COUNT_UPDATER.set(this, getLong(json, \"getCount\", -1L));\n        PUT_COUNT_UPDATER.set(this, getLong(json, \"putCount\", -1L));\n        REMOVE_COUNT_UPDATER.set(this, getLong(json, \"removeCount\", -1L));\n        NUMBER_OF_OTHER_OPERATIONS_UPDATER.set(this, getLong(json, \"numberOfOtherOperations\", -1L));\n        NUMBER_OF_EVENTS_UPDATER.set(this, getLong(json, \"numberOfEvents\", -1L));\n        LAST_ACCESS_TIME_UPDATER.set(this, getLong(json, \"lastAccessTime\", -1L));\n        LAST_UPDATE_TIME_UPDATER.set(this, getLong(json, \"lastUpdateTime\", -1L));\n        HITS_UPDATER.set(this, getLong(json, \"hits\", -1L));\n        ownedEntryCount.set(getLong(json, \"ownedEntryCount\", -1L));\n        backupEntryCount.set(getLong(json, \"backupEntryCount\", -1L));\n        backupCount.set(getInt(json, \"backupCount\", -1));\n        ownedEntryMemoryCost.set(getLong(json, \"ownedEntryMemoryCost\", -1L));\n        backupEntryMemoryCost.set(getLong(json, \"backupEntryMemoryCost\", -1L));\n        creationTime = getLong(json, \"creationTime\", -1L);\n        lockedEntryCount.set(getLong(json, \"lockedEntryCount\", -1L));\n        dirtyEntryCount.set(getLong(json, \"dirtyEntryCount\", -1L));\n        TOTAL_GET_LATENCIES_UPDATER.set(this, getLong(json, \"totalGetLatencies\", -1L));\n        TOTAL_PUT_LATENCIES_UPDATER.set(this, getLong(json, \"totalPutLatencies\", -1L));\n        TOTAL_REMOVE_LATENCIES_UPDATER.set(this, getLong(json, \"totalRemoveLatencies\", -1L));\n        MAX_GET_LATENCY_UPDATER.set(this, getLong(json, \"maxGetLatency\", -1L));\n        MAX_PUT_LATENCY_UPDATER.set(this, getLong(json, \"maxPutLatency\", -1L));\n        MAX_REMOVE_LATENCY_UPDATER.set(this, getLong(json, \"maxRemoveLatency\", -1L));\n        heapCost.set(getLong(json, \"heapCost\", -1L));\n        final JsonValue jsonNearCacheStats = json.get(\"nearCacheStats\");\n        if (jsonNearCacheStats != null) {\n            nearCacheStats = new NearCacheStatsImpl();\n            nearCacheStats.fromJson(jsonNearCacheStats.asObject());\n        }\n    }","id":79818,"modified_method":"@Override\n    public void fromJson(JsonObject json) {\n        GET_COUNT_UPDATER.set(this, getLong(json, \"getCount\", -1L));\n        PUT_COUNT_UPDATER.set(this, getLong(json, \"putCount\", -1L));\n        REMOVE_COUNT_UPDATER.set(this, getLong(json, \"removeCount\", -1L));\n        NUMBER_OF_OTHER_OPERATIONS_UPDATER.set(this, getLong(json, \"numberOfOtherOperations\", -1L));\n        NUMBER_OF_EVENTS_UPDATER.set(this, getLong(json, \"numberOfEvents\", -1L));\n        LAST_ACCESS_TIME_UPDATER.set(this, getLong(json, \"lastAccessTime\", -1L));\n        LAST_UPDATE_TIME_UPDATER.set(this, getLong(json, \"lastUpdateTime\", -1L));\n        HITS_UPDATER.set(this, getLong(json, \"hits\", -1L));\n        ownedEntryCount = getLong(json, \"ownedEntryCount\", -1L);\n        backupEntryCount = getLong(json, \"backupEntryCount\", -1L);\n        backupCount = getInt(json, \"backupCount\", -1);\n        ownedEntryMemoryCost = getLong(json, \"ownedEntryMemoryCost\", -1L);\n        backupEntryMemoryCost = getLong(json, \"backupEntryMemoryCost\", -1L);\n        creationTime = getLong(json, \"creationTime\", -1L);\n        lockedEntryCount = getLong(json, \"lockedEntryCount\", -1L);\n        dirtyEntryCount = getLong(json, \"dirtyEntryCount\", -1L);\n        TOTAL_GET_LATENCIES_UPDATER.set(this, getLong(json, \"totalGetLatencies\", -1L));\n        TOTAL_PUT_LATENCIES_UPDATER.set(this, getLong(json, \"totalPutLatencies\", -1L));\n        TOTAL_REMOVE_LATENCIES_UPDATER.set(this, getLong(json, \"totalRemoveLatencies\", -1L));\n        MAX_GET_LATENCY_UPDATER.set(this, getLong(json, \"maxGetLatency\", -1L));\n        MAX_PUT_LATENCY_UPDATER.set(this, getLong(json, \"maxPutLatency\", -1L));\n        MAX_REMOVE_LATENCY_UPDATER.set(this, getLong(json, \"maxRemoveLatency\", -1L));\n        heapCost = getLong(json, \"heapCost\", -1L);\n        final JsonValue jsonNearCacheStats = json.get(\"nearCacheStats\");\n        if (jsonNearCacheStats != null) {\n            nearCacheStats = new NearCacheStatsImpl();\n            nearCacheStats.fromJson(jsonNearCacheStats.asObject());\n        }\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public JsonObject toJson() {\n        JsonObject root = new JsonObject();\n        root.add(\"getCount\", getCount);\n        root.add(\"putCount\", putCount);\n        root.add(\"removeCount\", removeCount);\n        root.add(\"numberOfOtherOperations\", numberOfOtherOperations);\n        root.add(\"numberOfEvents\", numberOfEvents);\n        root.add(\"lastAccessTime\", lastAccessTime);\n        root.add(\"lastUpdateTime\", lastUpdateTime);\n        root.add(\"hits\", hits);\n        root.add(\"ownedEntryCount\", ownedEntryCount.get());\n        root.add(\"backupEntryCount\", backupEntryCount.get());\n        root.add(\"backupCount\", backupCount.get());\n        root.add(\"ownedEntryMemoryCost\", ownedEntryMemoryCost.get());\n        root.add(\"backupEntryMemoryCost\", backupEntryMemoryCost.get());\n        root.add(\"creationTime\", creationTime);\n        root.add(\"lockedEntryCount\", lockedEntryCount.get());\n        root.add(\"dirtyEntryCount\", dirtyEntryCount.get());\n        root.add(\"totalGetLatencies\", totalGetLatencies);\n        root.add(\"totalPutLatencies\", totalPutLatencies);\n        root.add(\"totalRemoveLatencies\", totalRemoveLatencies);\n        root.add(\"maxGetLatency\", maxGetLatency);\n        root.add(\"maxPutLatency\", maxPutLatency);\n        root.add(\"maxRemoveLatency\", maxRemoveLatency);\n        root.add(\"heapCost\", heapCost.get());\n        if (nearCacheStats != null) {\n            root.add(\"nearCacheStats\", nearCacheStats.toJson());\n        }\n        return root;\n    }","id":79819,"modified_method":"public JsonObject toJson() {\n        JsonObject root = new JsonObject();\n        root.add(\"getCount\", getCount);\n        root.add(\"putCount\", putCount);\n        root.add(\"removeCount\", removeCount);\n        root.add(\"numberOfOtherOperations\", numberOfOtherOperations);\n        root.add(\"numberOfEvents\", numberOfEvents);\n        root.add(\"lastAccessTime\", lastAccessTime);\n        root.add(\"lastUpdateTime\", lastUpdateTime);\n        root.add(\"hits\", hits);\n        root.add(\"ownedEntryCount\", ownedEntryCount);\n        root.add(\"backupEntryCount\", backupEntryCount);\n        root.add(\"backupCount\", backupCount);\n        root.add(\"ownedEntryMemoryCost\", ownedEntryMemoryCost);\n        root.add(\"backupEntryMemoryCost\", backupEntryMemoryCost);\n        root.add(\"creationTime\", creationTime);\n        root.add(\"lockedEntryCount\", lockedEntryCount);\n        root.add(\"dirtyEntryCount\", dirtyEntryCount);\n        root.add(\"totalGetLatencies\", totalGetLatencies);\n        root.add(\"totalPutLatencies\", totalPutLatencies);\n        root.add(\"totalRemoveLatencies\", totalRemoveLatencies);\n        root.add(\"maxGetLatency\", maxGetLatency);\n        root.add(\"maxPutLatency\", maxPutLatency);\n        root.add(\"maxRemoveLatency\", maxRemoveLatency);\n        root.add(\"heapCost\", heapCost);\n        if (nearCacheStats != null) {\n            root.add(\"nearCacheStats\", nearCacheStats.toJson());\n        }\n        return root;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public int getBackupCount() {\n        return backupCount.get();\n    }","id":79820,"modified_method":"@Override\n    public int getBackupCount() {\n        return backupCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setBackupEntryCount(long backupEntryCount) {\n        this.backupEntryCount.set(backupEntryCount);\n    }","id":79821,"modified_method":"public void setBackupEntryCount(long backupEntryCount) {\n        this.backupEntryCount = backupEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setOwnedEntryCount(long ownedEntryCount) {\n        this.ownedEntryCount.set(ownedEntryCount);\n    }","id":79822,"modified_method":"public void setOwnedEntryCount(long ownedEntryCount) {\n        this.ownedEntryCount = ownedEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getOwnedEntryMemoryCost() {\n        return ownedEntryMemoryCost.get();\n    }","id":79823,"modified_method":"@Override\n    public long getOwnedEntryMemoryCost() {\n        return ownedEntryMemoryCost;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getDirtyEntryCount() {\n        return dirtyEntryCount.get();\n    }","id":79824,"modified_method":"@Override\n    public long getDirtyEntryCount() {\n        return dirtyEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getLockedEntryCount() {\n        return lockedEntryCount.get();\n    }","id":79825,"modified_method":"@Override\n    public long getLockedEntryCount() {\n        return lockedEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void readData(ObjectDataInput in)\n            throws IOException {\n        GET_COUNT_UPDATER.set(this, in.readLong());\n        PUT_COUNT_UPDATER.set(this, in.readLong());\n        REMOVE_COUNT_UPDATER.set(this, in.readLong());\n        NUMBER_OF_OTHER_OPERATIONS_UPDATER.set(this, in.readLong());\n        NUMBER_OF_EVENTS_UPDATER.set(this, in.readLong());\n        LAST_ACCESS_TIME_UPDATER.set(this, in.readLong());\n        LAST_UPDATE_TIME_UPDATER.set(this, in.readLong());\n        HITS_UPDATER.set(this, in.readLong());\n        ownedEntryCount.set(in.readLong());\n        backupEntryCount.set(in.readLong());\n        backupCount.set(in.readInt());\n        ownedEntryMemoryCost.set(in.readLong());\n        backupEntryMemoryCost.set(in.readLong());\n        creationTime = in.readLong();\n        lockedEntryCount.set(in.readLong());\n        dirtyEntryCount.set(in.readLong());\n        TOTAL_GET_LATENCIES_UPDATER.set(this, in.readLong());\n        TOTAL_PUT_LATENCIES_UPDATER.set(this, in.readLong());\n        TOTAL_REMOVE_LATENCIES_UPDATER.set(this, in.readLong());\n        MAX_GET_LATENCY_UPDATER.set(this, in.readLong());\n        MAX_PUT_LATENCY_UPDATER.set(this, in.readLong());\n        MAX_REMOVE_LATENCY_UPDATER.set(this, in.readLong());\n        heapCost.set(in.readLong());\n        boolean hasNearCache = in.readBoolean();\n        if (hasNearCache) {\n            nearCacheStats = new NearCacheStatsImpl();\n            nearCacheStats.readData(in);\n        }\n    }","id":79826,"modified_method":"@Override\n    public void readData(ObjectDataInput in)\n            throws IOException {\n        GET_COUNT_UPDATER.set(this, in.readLong());\n        PUT_COUNT_UPDATER.set(this, in.readLong());\n        REMOVE_COUNT_UPDATER.set(this, in.readLong());\n        NUMBER_OF_OTHER_OPERATIONS_UPDATER.set(this, in.readLong());\n        NUMBER_OF_EVENTS_UPDATER.set(this, in.readLong());\n        LAST_ACCESS_TIME_UPDATER.set(this, in.readLong());\n        LAST_UPDATE_TIME_UPDATER.set(this, in.readLong());\n        HITS_UPDATER.set(this, in.readLong());\n        ownedEntryCount = in.readLong();\n        backupEntryCount = in.readLong();\n        backupCount = in.readInt();\n        ownedEntryMemoryCost = in.readLong();\n        backupEntryMemoryCost = in.readLong();\n        creationTime = in.readLong();\n        lockedEntryCount = in.readLong();\n        dirtyEntryCount = in.readLong();\n        TOTAL_GET_LATENCIES_UPDATER.set(this, in.readLong());\n        TOTAL_PUT_LATENCIES_UPDATER.set(this, in.readLong());\n        TOTAL_REMOVE_LATENCIES_UPDATER.set(this, in.readLong());\n        MAX_GET_LATENCY_UPDATER.set(this, in.readLong());\n        MAX_PUT_LATENCY_UPDATER.set(this, in.readLong());\n        MAX_REMOVE_LATENCY_UPDATER.set(this, in.readLong());\n        heapCost = in.readLong();\n        boolean hasNearCache = in.readBoolean();\n        if (hasNearCache) {\n            nearCacheStats = new NearCacheStatsImpl();\n            nearCacheStats.readData(in);\n        }\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void incrementOwnedEntryCount(long ownedEntryCount) {\n        this.ownedEntryCount.addAndGet(ownedEntryCount);\n    }","id":79827,"modified_method":"public void incrementOwnedEntryCount(long ownedEntryCount) {\n        this.ownedEntryCount += ownedEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getBackupEntryMemoryCost() {\n        return backupEntryMemoryCost.get();\n    }","id":79828,"modified_method":"@Override\n    public long getBackupEntryMemoryCost() {\n        return backupEntryMemoryCost;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void incrementOwnedEntryMemoryCost(long ownedEntryMemoryCost) {\n        this.ownedEntryMemoryCost.addAndGet(ownedEntryMemoryCost);\n    }","id":79829,"modified_method":"public void incrementOwnedEntryMemoryCost(long ownedEntryMemoryCost) {\n        this.ownedEntryMemoryCost += ownedEntryMemoryCost;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void incrementLockedEntryCount(long lockedEntryCount) {\n        this.lockedEntryCount.addAndGet(lockedEntryCount);\n    }","id":79830,"modified_method":"public void incrementLockedEntryCount(long lockedEntryCount) {\n        this.lockedEntryCount += lockedEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void incrementDirtyEntryCount(long dirtyEntryCount) {\n        this.dirtyEntryCount.addAndGet(dirtyEntryCount);\n    }","id":79831,"modified_method":"public void incrementDirtyEntryCount(long dirtyEntryCount) {\n        this.dirtyEntryCount += dirtyEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getBackupEntryCount() {\n        return backupEntryCount.get();\n    }","id":79832,"modified_method":"@Override\n    public long getBackupEntryCount() {\n        return backupEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setBackupCount(int backupCount) {\n        this.backupCount.set(backupCount);\n    }","id":79833,"modified_method":"public void setBackupCount(int backupCount) {\n        this.backupCount = backupCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void incrementHeapCost(long heapCost) {\n        this.heapCost.addAndGet(heapCost);\n    }","id":79834,"modified_method":"public void incrementHeapCost(long heapCost) {\n        this.heapCost += heapCost;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setLockedEntryCount(long lockedEntryCount) {\n        this.lockedEntryCount.set(lockedEntryCount);\n    }","id":79835,"modified_method":"public void setLockedEntryCount(long lockedEntryCount) {\n        this.lockedEntryCount = lockedEntryCount;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Calculates and adds owner partition stats.\n     */\n    private void addOwnerPartitionStats(LocalMapStatsImpl localMapStats, String mapName, int partitionId) {\n        final PartitionContainer partitionContainer = mapServiceContext.getPartitionContainer(partitionId);\n        final RecordStore recordStore = partitionContainer.getExistingRecordStore(mapName);\n        if (recordStore == null) {\n            return;\n        }\n        int lockedEntryCount = 0;\n        long lastAccessTime = 0;\n        long lastUpdateTime = 0;\n        long ownedEntryMemoryCost = 0;\n        long hits = 0;\n        final Map<Data, Record> records = recordStore.getReadonlyRecordMap();\n\n        localMapStats.incrementHeapCost(recordStore.getHeapCost());\n        localMapStats.incrementOwnedEntryCount(records.size());\n        for (Record record : records.values()) {\n            RecordStatistics stats = record.getStatistics();\n            ownedEntryMemoryCost += record.getCost();\n            lastAccessTime = Math.max(lastAccessTime, record.getLastAccessTime());\n            lastUpdateTime = Math.max(lastUpdateTime, record.getLastUpdateTime());\n            hits += stats.getHits();\n            if (recordStore.isLocked(record.getKey())) {\n                lockedEntryCount++;\n            }\n        }\n        localMapStats.incrementOwnedEntryMemoryCost(ownedEntryMemoryCost);\n        localMapStats.incrementLockedEntryCount(lockedEntryCount);\n        localMapStats.incrementHits(hits);\n        localMapStats.incrementDirtyEntryCount(recordStore.getMapDataStore().notFinishedOperationsCount());\n        localMapStats.setLastAccessTime(lastAccessTime);\n        localMapStats.setLastUpdateTime(lastUpdateTime);\n    }","id":79836,"modified_method":"/**\n     * Calculates and adds owner partition stats.\n     */\n    private void addOwnerPartitionStats(LocalMapStatsImpl localMapStats, String mapName, int partitionId) {\n        final PartitionContainer partitionContainer = mapServiceContext.getPartitionContainer(partitionId);\n        final RecordStore recordStore = partitionContainer.getExistingRecordStore(mapName);\n        if (recordStore == null) {\n            return;\n        }\n        int lockedEntryCount = 0;\n        long lastAccessTime = 0;\n        long lastUpdateTime = 0;\n        long ownedEntryMemoryCost = 0;\n        long hits = 0;\n        final Map<Data, Record> records = recordStore.getReadonlyRecordMap();\n\n        for (Record record : records.values()) {\n            RecordStatistics stats = record.getStatistics();\n            ownedEntryMemoryCost += record.getCost();\n            lastAccessTime = Math.max(lastAccessTime, record.getLastAccessTime());\n            lastUpdateTime = Math.max(lastUpdateTime, record.getLastUpdateTime());\n            hits += stats.getHits();\n            if (recordStore.isLocked(record.getKey())) {\n                lockedEntryCount++;\n            }\n        }\n\n        localMapStats.incrementOwnedEntryMemoryCost(ownedEntryMemoryCost);\n        localMapStats.incrementLockedEntryCount(lockedEntryCount);\n        localMapStats.incrementHits(hits);\n        localMapStats.incrementDirtyEntryCount(recordStore.getMapDataStore().notFinishedOperationsCount());\n        localMapStats.setLastAccessTime(lastAccessTime);\n        localMapStats.setLastUpdateTime(lastUpdateTime);\n        localMapStats.incrementHeapCost(recordStore.getHeapCost());\n        localMapStats.incrementOwnedEntryCount(records.size());\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public LocalMapStatsImpl createLocalMapStats(String mapName) {\n        final NodeEngine nodeEngine = this.nodeEngine;\n        final MapContainer mapContainer = mapServiceContext.getMapContainer(mapName);\n        final LocalMapStatsImpl localMapStats = getLocalMapStatsImpl(mapName);\n        if (!mapContainer.getMapConfig().isStatisticsEnabled()) {\n            return localMapStats;\n        }\n        final int backupCount = mapContainer.getTotalBackupCount();\n        final ClusterService clusterService = nodeEngine.getClusterService();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        final Address thisAddress = clusterService.getThisAddress();\n\n        for (int partitionId = 0; partitionId < partitionService.getPartitionCount(); partitionId++) {\n            InternalPartition partition = partitionService.getPartition(partitionId);\n            Address owner = partition.getOwnerOrNull();\n            if (owner == null) {\n                //no-op because no owner is set yet. Therefor we don't know anything about the map\n                continue;\n            }\n            if (owner.equals(thisAddress)) {\n                addOwnerPartitionStats(localMapStats, mapName, partitionId);\n            } else {\n                addReplicaPartitionStats(localMapStats, mapName, partitionId,\n                        partition, clusterService, backupCount, thisAddress);\n            }\n        }\n\n        localMapStats.setBackupCount(backupCount);\n\n        addNearCacheStats(localMapStats, mapContainer);\n\n        return localMapStats;\n    }","id":79837,"modified_method":"public LocalMapStatsImpl createLocalMapStats(String mapName) {\n        final NodeEngine nodeEngine = this.nodeEngine;\n        final MapContainer mapContainer = mapServiceContext.getMapContainer(mapName);\n        final LocalMapStatsImpl localMapStats = getLocalMapStatsImpl(mapName);\n        if (!mapContainer.getMapConfig().isStatisticsEnabled()) {\n            return localMapStats;\n        }\n        final int backupCount = mapContainer.getTotalBackupCount();\n        final ClusterService clusterService = nodeEngine.getClusterService();\n        final InternalPartitionService partitionService = nodeEngine.getPartitionService();\n        final Address thisAddress = clusterService.getThisAddress();\n\n        localMapStats.init();\n        for (int partitionId = 0; partitionId < partitionService.getPartitionCount(); partitionId++) {\n            InternalPartition partition = partitionService.getPartition(partitionId);\n            Address owner = partition.getOwnerOrNull();\n            if (owner == null) {\n                //no-op because no owner is set yet. Therefor we don't know anything about the map\n                continue;\n            }\n            if (owner.equals(thisAddress)) {\n                addOwnerPartitionStats(localMapStats, mapName, partitionId);\n            } else {\n                addReplicaPartitionStats(localMapStats, mapName, partitionId,\n                        partition, clusterService, backupCount, thisAddress);\n            }\n        }\n\n        localMapStats.setBackupCount(backupCount);\n\n        addNearCacheStats(localMapStats, mapContainer);\n\n        return localMapStats;\n    }","commit_id":"2ca3c2b413f7721d71e02e7ec741da3cb47786b1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCachePuts(long number) {\n        puts.getAndAdd(number);\n    }","id":79838,"modified_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCachePuts(long number) {\n        PUTS_UPDATER.addAndGet(this, number);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheExpiries(long number) {\n        expiries.getAndAdd(number);\n    }","id":79839,"modified_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheExpiries(long number) {\n        EXPIRIES_UPDATER.addAndGet(this, number);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increments the getCache time accumulator.\n     *\n     * @param duration the time taken in nanoseconds.\n     */\n    public void addGetTimeNano(long duration) {\n        if (getCacheTimeTakenNanos.get() <= Long.MAX_VALUE - duration) {\n            getCacheTimeTakenNanos.addAndGet(duration);\n        } else {\n            //counter full. Just reset.\n            clear();\n            getCacheTimeTakenNanos.set(duration);\n        }\n    }","id":79840,"modified_method":"/**\n     * Increments the getCache time accumulator.\n     *\n     * @param duration the time taken in nanoseconds.\n     */\n    public void addGetTimeNano(long duration) {\n        for (;;) {\n            long nanos = getCacheTimeTakenNanos;\n            if (nanos <= Long.MAX_VALUE - duration) {\n                GET_CACHE_TIME_TAKEN_NANOS_UPDATER.compareAndSet(this, nanos, nanos + duration);\n            } else {\n                //counter full. Just reset.\n                clear();\n                GET_CACHE_TIME_TAKEN_NANOS_UPDATER.set(this, duration);\n            }\n        }\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getCacheRemovals() {\n        return removals.get();\n    }","id":79841,"modified_method":"@Override\n    public long getCacheRemovals() {\n        return removals;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheEvictions(long number) {\n        evictions.getAndAdd(number);\n    }","id":79842,"modified_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheEvictions(long number) {\n        EVICTIONS_UPDATER.addAndGet(this, number);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increments the remove time accumulator.\n     *\n     * @param duration the time taken in nanoseconds.\n     */\n    public void addRemoveTimeNano(long duration) {\n        if (removeTimeTakenNanos.get() <= Long.MAX_VALUE - duration) {\n            removeTimeTakenNanos.addAndGet(duration);\n        } else {\n            //counter full. Just reset.\n            clear();\n            removeTimeTakenNanos.set(duration);\n        }\n    }","id":79843,"modified_method":"/**\n     * Increments the remove time accumulator.\n     *\n     * @param duration the time taken in nanoseconds.\n     */\n    public void addRemoveTimeNano(long duration) {\n        for (;;) {\n            long nanos = removeTimeTakenNanos;\n            if (nanos <= Long.MAX_VALUE - duration) {\n                REMOVALS_UPDATER.compareAndSet(this, nanos, nanos + duration);\n            } else {\n                //counter full. Just reset.\n                clear();\n                REMOVALS_UPDATER.set(this, duration);\n            }\n        }\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheRemovals(long number) {\n        removals.getAndAdd(number);\n    }","id":79844,"modified_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheRemovals(long number) {\n        REMOVALS_UPDATER.addAndGet(this, number);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheHits(long number) {\n        hits.getAndAdd(number);\n    }","id":79845,"modified_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheHits(long number) {\n        HITS_UPDATER.addAndGet(this, number);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     *\n     * The total number of expiries from the cache. An expiry may or may not be evicted.\n     * This number represents the entries that fail evaluation and may not include the entries which are not yet\n     * evaluated for expiry or not accessed.\n     *\n     * @return the number of expiries.\n     */\n    public long getCacheExpiries() {\n        return expiries.get();\n    }","id":79846,"modified_method":"/**\n     *\n     * The total number of expiries from the cache. An expiry may or may not be evicted.\n     * This number represents the entries that fail evaluation and may not include the entries which are not yet\n     * evaluated for expiry or not accessed.\n     *\n     * @return the number of expiries.\n     */\n    public long getCacheExpiries() {\n        return expiries;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public long getCacheRemoveTimeTakenNanos() {\n        return removeTimeTakenNanos.get();\n    }","id":79847,"modified_method":"public long getCacheRemoveTimeTakenNanos() {\n        return removeTimeTakenNanos;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getCacheEvictions() {\n        return evictions.get();\n    }","id":79848,"modified_method":"@Override\n    public long getCacheEvictions() {\n        return evictions;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Implementation of {@link javax.cache.management.CacheStatisticsMXBean#clear()}.\n     * @see javax.cache.management.CacheStatisticsMXBean#clear()\n     */\n    public void clear() {\n        puts.set(0);\n        misses.set(0);\n        removals.set(0);\n        expiries.set(0);\n        hits.set(0);\n        evictions.set(0);\n        getCacheTimeTakenNanos.set(0);\n        putTimeTakenNanos.set(0);\n        removeTimeTakenNanos.set(0);\n    }","id":79849,"modified_method":"/**\n     * Implementation of {@link javax.cache.management.CacheStatisticsMXBean#clear()}.\n     * @see javax.cache.management.CacheStatisticsMXBean#clear()\n     */\n    public void clear() {\n        puts = 0;\n        misses = 0;\n        removals = 0;\n        expiries = 0;\n        hits = 0;\n        evictions = 0;\n        getCacheTimeTakenNanos = 0;\n        putTimeTakenNanos = 0;\n        removeTimeTakenNanos = 0;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getCachePuts() {\n        return puts.get();\n    }","id":79850,"modified_method":"@Override\n    public long getCachePuts() {\n        return puts;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getCacheHits() {\n        return hits.get();\n    }","id":79851,"modified_method":"@Override\n    public long getCacheHits() {\n        return hits;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public long getCacheGetTimeTakenNanos() {\n        return getCacheTimeTakenNanos.get();\n    }","id":79852,"modified_method":"public long getCacheGetTimeTakenNanos() {\n        return getCacheTimeTakenNanos;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public long getCacheMisses() {\n        return misses.get();\n    }","id":79853,"modified_method":"@Override\n    public long getCacheMisses() {\n        return misses;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void readData(ObjectDataInput in)\n            throws IOException {\n        puts.set(in.readLong());\n        removals.set(in.readLong());\n        expiries.set(in.readLong());\n        evictions.set(in.readLong());\n\n        hits.set(in.readLong());\n        misses.set(in.readLong());\n\n        putTimeTakenNanos.set(in.readLong());\n        getCacheTimeTakenNanos.set(in.readLong());\n        removeTimeTakenNanos.set(in.readLong());\n    }","id":79854,"modified_method":"@Override\n    public void readData(ObjectDataInput in)\n            throws IOException {\n        puts = in.readLong();\n        removals = in.readLong();\n        expiries = in.readLong();\n        evictions = in.readLong();\n\n        hits = in.readLong();\n        misses = in.readLong();\n\n        putTimeTakenNanos = in.readLong();\n        getCacheTimeTakenNanos = in.readLong();\n        removeTimeTakenNanos = in.readLong();\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increments the put time accumulator.\n     *\n     * @param duration the time taken in nanoseconds.\n     */\n    public void addPutTimeNano(long duration) {\n        if (putTimeTakenNanos.get() <= Long.MAX_VALUE - duration) {\n            putTimeTakenNanos.addAndGet(duration);\n        } else {\n            //counter full. Just reset.\n            clear();\n            putTimeTakenNanos.set(duration);\n        }\n    }","id":79855,"modified_method":"/**\n     * Increments the put time accumulator.\n     *\n     * @param duration the time taken in nanoseconds.\n     */\n    public void addPutTimeNano(long duration) {\n        for (;;) {\n            long nanos = putTimeTakenNanos;\n            if (nanos <= Long.MAX_VALUE - duration) {\n                PUT_TIME_TAKEN_NANOS_UPDATER.compareAndSet(this, nanos, nanos + duration);\n            } else {\n                //counter full. Just reset.\n                clear();\n                PUT_TIME_TAKEN_NANOS_UPDATER.set(this, duration);\n            }\n        }\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public long getCachePutTimeTakenNanos() {\n        return putTimeTakenNanos.get();\n    }","id":79856,"modified_method":"public long getCachePutTimeTakenNanos() {\n        return putTimeTakenNanos;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheMisses(long number) {\n        misses.getAndAdd(number);\n    }","id":79857,"modified_method":"/**\n     * Increases the counter by the number specified.\n     *\n     * @param number the number by which the counter is increased.\n     */\n    public void increaseCacheMisses(long number) {\n        MISSES_UPDATER.addAndGet(this, number);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     *\n     * Simple CacheStatistics adder. Can be used to merge two statistics data,\n     * such as the ones collected from multiple nodes.\n     * @param other CacheStatisticsImpl to be merged.\n     * @return CacheStatisticsImpl with merged data.\n     */\n    public CacheStatisticsImpl accumulate(CacheStatisticsImpl other) {\n        puts.addAndGet(other.getCachePuts());\n        removals.addAndGet(other.getCacheRemovals());\n        expiries.addAndGet(other.getCacheExpiries());\n        evictions.addAndGet(other.getCacheEvictions());\n        hits.addAndGet(other.getCacheHits());\n        misses.addAndGet(other.getCacheMisses());\n        putTimeTakenNanos.addAndGet(other.getCachePutTimeTakenNanos());\n        getCacheTimeTakenNanos.addAndGet(other.getCacheGetTimeTakenNanos());\n        removeTimeTakenNanos.addAndGet(other.getCacheRemoveTimeTakenNanos());\n        return this;\n    }","id":79858,"modified_method":"/**\n     *\n     * Simple CacheStatistics adder. Can be used to merge two statistics data,\n     * such as the ones collected from multiple nodes.\n     * @param other CacheStatisticsImpl to be merged.\n     * @return CacheStatisticsImpl with merged data.\n     */\n    public CacheStatisticsImpl accumulate(CacheStatisticsImpl other) {\n        PUTS_UPDATER.addAndGet(this, other.getCachePuts());\n        REMOVALS_UPDATER.addAndGet(this, other.getCacheRemovals());\n        EXPIRIES_UPDATER.addAndGet(this, other.getCacheExpiries());\n        EVICTIONS_UPDATER.addAndGet(this, other.getCacheEvictions());\n        HITS_UPDATER.addAndGet(this, other.getCacheHits());\n        MISSES_UPDATER.addAndGet(this, other.getCacheMisses());\n        PUT_TIME_TAKEN_NANOS_UPDATER.addAndGet(this, other.getCachePutTimeTakenNanos());\n        GET_CACHE_TIME_TAKEN_NANOS_UPDATER.addAndGet(this, other.getCacheGetTimeTakenNanos());\n        REMOVE_TIME_TAKEN_NANOS_UPDATER.addAndGet(this, other.getCacheRemoveTimeTakenNanos());\n        return this;\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void writeData(ObjectDataOutput out)\n            throws IOException {\n        out.writeLong(puts.get());\n        out.writeLong(removals.get());\n        out.writeLong(expiries.get());\n        out.writeLong(evictions.get());\n\n        out.writeLong(hits.get());\n        out.writeLong(misses.get());\n\n        out.writeLong(putTimeTakenNanos.get());\n        out.writeLong(getCacheTimeTakenNanos.get());\n        out.writeLong(removeTimeTakenNanos.get());\n    }","id":79859,"modified_method":"@Override\n    public void writeData(ObjectDataOutput out)\n            throws IOException {\n        out.writeLong(puts);\n        out.writeLong(removals);\n        out.writeLong(expiries);\n        out.writeLong(evictions);\n\n        out.writeLong(hits);\n        out.writeLong(misses);\n\n        out.writeLong(putTimeTakenNanos);\n        out.writeLong(getCacheTimeTakenNanos);\n        out.writeLong(removeTimeTakenNanos);\n    }","commit_id":"a158274bf86846be6cc766e49cd7115b79d6863f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Wrap a function call into a user defined function.\n     * This is used to handle dynamic function calls or partial\n     * function applications on built in functions.\n     * \n     * @param context\n     * @param call the function call to be wrapped\n     * @return a new function call referencing an inline function\n     * @throws XPathException\n     */\n    public static FunctionCall wrap(XQueryContext context, Function call) throws XPathException {\n\t\tint argCount = call.getArgumentCount();\n\t\tQName[] variables = new QName[argCount];\n\t\tList<Expression> innerArgs = new ArrayList<Expression>(argCount);\n\t\tList<Expression> wrapperArgs = new ArrayList<Expression>(argCount);\n\t\tFunctionSignature signature = call.getSignature();\n\t\t// the parameters of the newly created inline function:\n\t\tList<SequenceType> newParamTypes = new ArrayList<SequenceType>();\n\t\tSequenceType[] paramTypes = signature.getArgumentTypes();\n\t\tfor (int i = 0; i < argCount; i++) {\n\t\t\tExpression param = call.getArgument(i);\n\t\t\twrapperArgs.add(param);\n\t\t\tQName varName = new QName(\"vp\" + i);\n\t\t\tvariables[i] = varName;\n\t\t\tVariableReference ref = new VariableReference(context, varName.toString());\n\t\t\tinnerArgs.add(ref);\n\t\t\t\n\t\t\t// copy parameter sequence types\n\t\t\t// overloaded functions like concat may have an arbitrary number of arguments\n\t\t\tif (i < paramTypes.length)\n\t\t\t\tnewParamTypes.add(paramTypes[i]);\n\t\t\telse\n\t\t\t\t// overloaded function: add last sequence type\n\t\t\t\tnewParamTypes.add(paramTypes[paramTypes.length - 1]);\n\t\t}\n\t\tSequenceType[] newParamArray = newParamTypes.toArray(new SequenceType[newParamTypes.size()]);\n\t\tFunctionSignature newSignature = new FunctionSignature(signature.getName(), newParamArray, signature.getReturnType());\n\t\tUserDefinedFunction func = new UserDefinedFunction(context, newSignature);\n\t\tfor (QName varName: variables) {\n\t\t\tfunc.addVariable(varName);\n\t\t}\n\t\t\n\t\tcall.setArguments(innerArgs);\n\t\t\n\t\tfunc.setFunctionBody(call);\n\t\t\n\t\tFunctionCall wrappedCall = new FunctionCall(context, func);\n\t\twrappedCall.setArguments(wrapperArgs);\n\t\treturn wrappedCall;\n\t}","id":79860,"modified_method":"/**\n     * Wrap a function call into a user defined function.\n     * This is used to handle dynamic function calls or partial\n     * function applications on built in functions.\n     * \n     * @param context\n     * @param call the function call to be wrapped\n     * @return a new function call referencing an inline function\n     * @throws XPathException\n     */\n    public static FunctionCall wrap(XQueryContext context, Function call) throws XPathException {\n\t\tint argCount = call.getArgumentCount();\n\t\tQName[] variables = new QName[argCount];\n\t\tList<Expression> innerArgs = new ArrayList<Expression>(argCount);\n\t\tList<Expression> wrapperArgs = new ArrayList<Expression>(argCount);\n\t\tFunctionSignature signature = call.getSignature();\n\t\t// the parameters of the newly created inline function:\n\t\tList<SequenceType> newParamTypes = new ArrayList<SequenceType>();\n\t\tSequenceType[] paramTypes = signature.getArgumentTypes();\n\t\tfor (int i = 0; i < argCount; i++) {\n\t\t\tExpression param = call.getArgument(i);\n\t\t\twrapperArgs.add(param);\n\t\t\tQName varName = new QName(\"vp\" + i);\n\t\t\tvariables[i] = varName;\n\t\t\tVariableReference ref = new VariableReference(context, varName.toString());\n\t\t\tinnerArgs.add(ref);\n\t\t\t\n\t\t\t// copy parameter sequence types\n\t\t\t// overloaded functions like concat may have an arbitrary number of arguments\n\t\t\tif (i < paramTypes.length)\n\t\t\t\tnewParamTypes.add(paramTypes[i]);\n\t\t\telse\n\t\t\t\t// overloaded function: add last sequence type\n\t\t\t\tnewParamTypes.add(paramTypes[paramTypes.length - 1]);\n\t\t}\n\t\tSequenceType[] newParamArray = newParamTypes.toArray(new SequenceType[newParamTypes.size()]);\n\t\tFunctionSignature newSignature = new FunctionSignature(signature);\n        newSignature.setArgumentTypes(newParamArray);\n\n\t\tUserDefinedFunction func = new UserDefinedFunction(context, newSignature);\n\t\tfor (QName varName: variables) {\n\t\t\tfunc.addVariable(varName);\n\t\t}\n\t\t\n\t\tcall.setArguments(innerArgs);\n\t\t\n\t\tfunc.setFunctionBody(call);\n\t\t\n\t\tFunctionCall wrappedCall = new FunctionCall(context, func);\n\t\twrappedCall.setArguments(wrapperArgs);\n\t\treturn wrappedCall;\n\t}","commit_id":"d2c586f6177a6367829c733a277f00cdaa2e1dad","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        Module module;\n        XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n        tempContext.setModuleLoadPath(context.getModuleLoadPath());\n        if (isCalledAs(\"inspect-module\")) {\n            module = tempContext.importModule(null, null, args[0].getStringValue());\n        } else {\n            module = tempContext.importModule(args[0].getStringValue(), null, null);\n        }\n\n        if (module == null)\n            return Sequence.EMPTY_SEQUENCE;\n        MemTreeBuilder builder = context.getDocumentBuilder();\n        AttributesImpl attribs = new AttributesImpl();\n        attribs.addAttribute(\"\", \"uri\", \"uri\", \"CDATA\", module.getNamespaceURI());\n        attribs.addAttribute(\"\", \"prefix\", \"prefix\", \"CDATA\", module.getDefaultPrefix());\n        if (isCalledAs(\"inspect-module\"))\n            attribs.addAttribute(\"\", \"location\", \"location\", \"CDATA\", args[0].getStringValue());\n        else\n            attribs.addAttribute(\"\", \"location\", \"location\", \"CDATA\", module.getClass().getName());\n        int nodeNr = builder.startElement(MODULE_QNAME, attribs);\n        if (!module.isInternalModule())\n            XQDocHelper.parse((ExternalModule) module);\n        if (module.getDescription() != null) {\n            builder.startElement(InspectFunction.DESCRIPTION_QNAME, null);\n            builder.characters(module.getDescription());\n            builder.endElement();\n        }\n        if (!module.isInternalModule()) {\n            ExternalModule externalModule = (ExternalModule) module;\n            if (externalModule.getMetadata() != null) {\n                for (Map.Entry<String, String> entry: externalModule.getMetadata().entrySet()) {\n                    builder.startElement(new QName(entry.getKey()), null);\n                    builder.characters(entry.getValue());\n                    builder.endElement();\n                }\n            }\n            // variables\n            for (VariableDeclaration var: externalModule.getVariableDeclarations()) {\n                attribs.clear();\n                attribs.addAttribute(\"\", \"name\", \"name\", \"CDATA\", var.getName());\n                SequenceType type = var.getSequenceType();\n                if (type != null) {\n                    attribs.addAttribute(\"\", \"type\", \"type\", \"CDATA\", Type.getTypeName(type.getPrimaryType()));\n                    attribs.addAttribute(\"\", \"cardinality\", \"cardinality\", \"CDATA\", Cardinality.getDescription(type.getCardinality()));\n                }\n                builder.startElement(VARIABLE_QNAME, attribs);\n                builder.endElement();\n            }\n        }\n        // functions\n        for (FunctionSignature sig : module.listFunctions()) {\n            if (!sig.isPrivate()) {\n                InspectFunction.generateDocs(sig, builder);\n            }\n        }\n        builder.endElement();\n        return builder.getDocument().getNode(nodeNr);\n    }","id":79861,"modified_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        Module module;\n        XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n        tempContext.setModuleLoadPath(context.getModuleLoadPath());\n        if (isCalledAs(\"inspect-module\")) {\n            module = tempContext.importModule(null, null, args[0].getStringValue());\n        } else {\n            module = tempContext.importModule(args[0].getStringValue(), null, null);\n        }\n\n        if (module == null)\n            return Sequence.EMPTY_SEQUENCE;\n        MemTreeBuilder builder = context.getDocumentBuilder();\n        AttributesImpl attribs = new AttributesImpl();\n        attribs.addAttribute(\"\", \"uri\", \"uri\", \"CDATA\", module.getNamespaceURI());\n        attribs.addAttribute(\"\", \"prefix\", \"prefix\", \"CDATA\", module.getDefaultPrefix());\n        if (module.isInternalModule()) {\n            attribs.addAttribute(\"\", \"location\", \"location\", \"CDATA\", \"java:\" + module.getClass().getName());\n        } else if (isCalledAs(\"inspect-module\")) {\n            attribs.addAttribute(\"\", \"location\", \"location\", \"CDATA\", args[0].getStringValue());\n        }\n        int nodeNr = builder.startElement(MODULE_QNAME, attribs);\n        if (!module.isInternalModule())\n            XQDocHelper.parse((ExternalModule) module);\n        if (module.getDescription() != null) {\n            builder.startElement(InspectFunction.DESCRIPTION_QNAME, null);\n            builder.characters(module.getDescription());\n            builder.endElement();\n        }\n        if (!module.isInternalModule()) {\n            ExternalModule externalModule = (ExternalModule) module;\n            if (externalModule.getMetadata() != null) {\n                for (Map.Entry<String, String> entry: externalModule.getMetadata().entrySet()) {\n                    builder.startElement(new QName(entry.getKey()), null);\n                    builder.characters(entry.getValue());\n                    builder.endElement();\n                }\n            }\n            // variables\n            for (VariableDeclaration var: externalModule.getVariableDeclarations()) {\n                attribs.clear();\n                attribs.addAttribute(\"\", \"name\", \"name\", \"CDATA\", var.getName());\n                SequenceType type = var.getSequenceType();\n                if (type != null) {\n                    attribs.addAttribute(\"\", \"type\", \"type\", \"CDATA\", Type.getTypeName(type.getPrimaryType()));\n                    attribs.addAttribute(\"\", \"cardinality\", \"cardinality\", \"CDATA\", Cardinality.getDescription(type.getCardinality()));\n                }\n                builder.startElement(VARIABLE_QNAME, attribs);\n                builder.endElement();\n            }\n        }\n        // functions\n        for (FunctionSignature sig : module.listFunctions()) {\n            if (!sig.isPrivate()) {\n                InspectFunction.generateDocs(sig, builder);\n            }\n        }\n        builder.endElement();\n        return builder.getDocument().getNode(nodeNr);\n    }","commit_id":"d2c586f6177a6367829c733a277f00cdaa2e1dad","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        ValueSequence list = new ValueSequence();\n        if (getArgumentCount() == 1) {\n            XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n            tempContext.setModuleLoadPath(context.getModuleLoadPath());\n\n            Module module = tempContext.importModule(null, null, args[0].getStringValue());\n            if (module == null)\n                return Sequence.EMPTY_SEQUENCE;\n            addFunctionRefsFromModule(tempContext, list, module);\n        } else {\n            addFunctionRefsFromContext(list);\n        }\n        return list;\n    }","id":79862,"modified_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        ValueSequence list = new ValueSequence();\n        if (getArgumentCount() == 1) {\n            XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n            tempContext.setModuleLoadPath(context.getModuleLoadPath());\n\n            Module module;\n            if (isCalledAs(\"module-functions-by-uri\"))\n                module = tempContext.importModule(args[0].getStringValue(), null, null);\n            else\n                module = tempContext.importModule(null, null, args[0].getStringValue());\n            if (module == null)\n                return Sequence.EMPTY_SEQUENCE;\n            addFunctionRefsFromModule(tempContext, list, module);\n        } else {\n            addFunctionRefsFromContext(list);\n        }\n        return list;\n    }","commit_id":"d2c586f6177a6367829c733a277f00cdaa2e1dad","url":"https://github.com/eXist-db/exist"},{"original_method":"public ResourceSet execute(Source source) \n\t\tthrows XMLDBException {\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tDBBroker broker = null;\n\t\t\tSequence result;\n\t\t\ttry {\n\t\t\t\tbroker = brokerPool.get(user);\n\t\t\t\tDocumentSet docs = collection.getCollection().allDocs(broker, new DocumentSet(), true, true);\n\t\t\t\t\n\t\t\t\tXQuery xquery = broker.getXQueryService();\n\t\t\t\tXQueryPool pool = xquery.getXQueryPool();\n\t\t\t\tXQueryContext context;\n\t\t\t\tCompiledXQuery compiled = pool.borrowCompiledXQuery(broker, source);\n\t\t\t\tif(compiled == null)\n\t\t\t\t    context = xquery.newContext();\n\t\t\t\telse\n\t\t\t\t    context = compiled.getContext();\n\t\t\t\tcontext.setBackwardsCompatibility(xpathCompatible);\n\t\t\t\tcontext.setStaticallyKnownDocuments(docs);\n\t\t\t\tsetupContext(context);\n\t\t\t\t\n\t\t\t\tif(compiled == null)\n\t\t\t\t    compiled = xquery.compile(context, source);\n\t\t\t\tcheckPragmas(context);\n\t\t\t\ttry {\n\t\t\t\t    result = xquery.execute(compiled, null);\n\t\t\t\t} finally {\n\t\t\t\t    pool.returnCompiledXQuery(source, compiled);\n\t\t\t\t}\n\t\t\t} catch (EXistException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t\t} catch (XPathException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t\t} catch (IOException e) {\n\t\t\t    throw new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n            } finally {\n\t\t\t\tbrokerPool.release(broker);\n\t\t\t}\n\t\t\tLOG.debug(\"query took \" + (System.currentTimeMillis() - start) + \" ms.\");\n\t\t\tif(result != null)\n\t\t\t\treturn new LocalResourceSet(user, brokerPool, collection, properties, result, null);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}","id":79863,"modified_method":"public ResourceSet execute(Source source) \n\t\tthrows XMLDBException {\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tDBBroker broker = null;\n\t\t\tSequence result;\n\t\t\ttry {\n\t\t\t\tbroker = brokerPool.get(user);\n\t\t\t\tDocumentSet docs = collection.getCollection().allDocs(broker, new DocumentSet(), true, true);\n\t\t\t\t\n\t\t\t\tXQuery xquery = broker.getXQueryService();\n\t\t\t\tXQueryPool pool = xquery.getXQueryPool();\n\t\t\t\tXQueryContext context;\n\t\t\t\tCompiledXQuery compiled = pool.borrowCompiledXQuery(broker, source);\n\t\t\t\tif(compiled == null)\n\t\t\t\t    context = xquery.newContext();\n\t\t\t\telse\n\t\t\t\t    context = compiled.getContext();\n\t\t\t\tcontext.setBackwardsCompatibility(xpathCompatible);\n\t\t\t\tcontext.setStaticallyKnownDocuments(docs);\n\t\t\t\tsetupContext(context);\n\t\t\t\t\n\t\t\t\tif(compiled == null)\n\t\t\t\t    compiled = xquery.compile(context, source);\n\t\t\t\ttry {\n\t\t\t\t    result = xquery.execute(compiled, null);\n\t\t\t\t    // check if serialization options have been set\n\t\t\t\t    // via pragma or 'declare option'\n\t\t\t\t    checkPragmas(context);\n\t\t\t\t} finally {\n\t\t\t\t    pool.returnCompiledXQuery(source, compiled);\n\t\t\t\t}\n\t\t\t} catch (EXistException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t\t} catch (XPathException e) {\n\t\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t\t} catch (IOException e) {\n\t\t\t    throw new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n            } finally {\n\t\t\t\tbrokerPool.release(broker);\n\t\t\t}\n\t\t\tLOG.debug(\"query took \" + (System.currentTimeMillis() - start) + \" ms.\");\n\t\t\tif(result != null)\n\t\t\t\treturn new LocalResourceSet(user, brokerPool, collection, properties, result, null);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}","commit_id":"4660b3a9538baace7c0e6e8c1562fec4086a0313","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\tif (isCalledAs(\"declare-namespace\"))\n\t\t\tdeclareNamespace(args);\n\t\telse\n\t\t\timportModule(args);\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","id":79864,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\tif (isCalledAs(\"declare-namespace\"))\n\t\t\tdeclareNamespace(args);\n\t\telse if (isCalledAs(\"declare-option\"))\n\t\t\tdeclareOption(args);\n\t\telse\n\t\t\timportModule(args);\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","commit_id":"4660b3a9538baace7c0e6e8c1562fec4086a0313","url":"https://github.com/eXist-db/exist"},{"original_method":"public InspectModule(XQueryContext context) {\n        super(context, signature);\n    }","id":79865,"modified_method":"public InspectModule(XQueryContext context, FunctionSignature signature) {\n        super(context, signature);\n    }","commit_id":"5db898f67da5075642f0ad8984cda37ea726e6ea","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n        tempContext.setModuleLoadPath(context.getModuleLoadPath());\n        Module module = tempContext.importModule(null, null, args[0].getStringValue());\n\n        if (module == null)\n            return Sequence.EMPTY_SEQUENCE;\n        MemTreeBuilder builder = context.getDocumentBuilder();\n        AttributesImpl attribs = new AttributesImpl();\n        attribs.addAttribute(\"\", \"uri\", \"uri\", \"CDATA\", module.getNamespaceURI());\n        attribs.addAttribute(\"\", \"prefix\", \"prefix\", \"CDATA\", module.getDefaultPrefix());\n        int nodeNr = builder.startElement(MODULE_QNAME, attribs);\n        if (!module.isInternalModule())\n            XQDocHelper.parse((ExternalModule) module);\n        if (module.getDescription() != null) {\n            builder.startElement(InspectFunction.DESCRIPTION_QNAME, null);\n            builder.characters(module.getDescription());\n            builder.endElement();\n        }\n        if (!module.isInternalModule()) {\n            ExternalModule externalModule = (ExternalModule) module;\n            if (externalModule.getMetadata() != null) {\n                for (Map.Entry<String, String> entry: externalModule.getMetadata().entrySet()) {\n                    builder.startElement(new QName(entry.getKey()), null);\n                    builder.characters(entry.getValue());\n                    builder.endElement();\n                }\n            }\n            // variables\n            for (VariableDeclaration var: externalModule.getVariableDeclarations()) {\n                attribs.clear();\n                attribs.addAttribute(\"\", \"name\", \"name\", \"CDATA\", var.getName());\n                SequenceType type = var.getSequenceType();\n                if (type != null) {\n                    attribs.addAttribute(\"\", \"type\", \"type\", \"CDATA\", Type.getTypeName(type.getPrimaryType()));\n                    attribs.addAttribute(\"\", \"cardinality\", \"cardinality\", \"CDATA\", Cardinality.getDescription(type.getCardinality()));\n                }\n                builder.startElement(VARIABLE_QNAME, attribs);\n                builder.endElement();\n            }\n        }\n        // functions\n        for (FunctionSignature sig : module.listFunctions()) {\n            if (!sig.isPrivate()) {\n                InspectFunction.generateDocs(sig, builder);\n            }\n        }\n        builder.endElement();\n        return builder.getDocument().getNode(nodeNr);\n    }","id":79866,"modified_method":"@Override\n    public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException {\n        Module module;\n        XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n        tempContext.setModuleLoadPath(context.getModuleLoadPath());\n        if (isCalledAs(\"inspect-module\")) {\n            module = tempContext.importModule(null, null, args[0].getStringValue());\n        } else {\n            module = tempContext.importModule(args[0].getStringValue(), null, null);\n        }\n\n        if (module == null)\n            return Sequence.EMPTY_SEQUENCE;\n        MemTreeBuilder builder = context.getDocumentBuilder();\n        AttributesImpl attribs = new AttributesImpl();\n        attribs.addAttribute(\"\", \"uri\", \"uri\", \"CDATA\", module.getNamespaceURI());\n        attribs.addAttribute(\"\", \"prefix\", \"prefix\", \"CDATA\", module.getDefaultPrefix());\n        if (isCalledAs(\"inspect-module\"))\n            attribs.addAttribute(\"\", \"location\", \"location\", \"CDATA\", args[0].getStringValue());\n        else\n            attribs.addAttribute(\"\", \"location\", \"location\", \"CDATA\", module.getClass().getName());\n        int nodeNr = builder.startElement(MODULE_QNAME, attribs);\n        if (!module.isInternalModule())\n            XQDocHelper.parse((ExternalModule) module);\n        if (module.getDescription() != null) {\n            builder.startElement(InspectFunction.DESCRIPTION_QNAME, null);\n            builder.characters(module.getDescription());\n            builder.endElement();\n        }\n        if (!module.isInternalModule()) {\n            ExternalModule externalModule = (ExternalModule) module;\n            if (externalModule.getMetadata() != null) {\n                for (Map.Entry<String, String> entry: externalModule.getMetadata().entrySet()) {\n                    builder.startElement(new QName(entry.getKey()), null);\n                    builder.characters(entry.getValue());\n                    builder.endElement();\n                }\n            }\n            // variables\n            for (VariableDeclaration var: externalModule.getVariableDeclarations()) {\n                attribs.clear();\n                attribs.addAttribute(\"\", \"name\", \"name\", \"CDATA\", var.getName());\n                SequenceType type = var.getSequenceType();\n                if (type != null) {\n                    attribs.addAttribute(\"\", \"type\", \"type\", \"CDATA\", Type.getTypeName(type.getPrimaryType()));\n                    attribs.addAttribute(\"\", \"cardinality\", \"cardinality\", \"CDATA\", Cardinality.getDescription(type.getCardinality()));\n                }\n                builder.startElement(VARIABLE_QNAME, attribs);\n                builder.endElement();\n            }\n        }\n        // functions\n        for (FunctionSignature sig : module.listFunctions()) {\n            if (!sig.isPrivate()) {\n                InspectFunction.generateDocs(sig, builder);\n            }\n        }\n        builder.endElement();\n        return builder.getDocument().getNode(nodeNr);\n    }","commit_id":"5db898f67da5075642f0ad8984cda37ea726e6ea","url":"https://github.com/eXist-db/exist"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tpublic Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\t\n\t\tif(\"get-module-description\".equals(getSignature().getName().getLocalName())) {\n\t\t\tString uri = args[0].getStringValue();\n\t\t\tModule module = context.getModule(uri);\n\t\t\tif(module == null)\n\t\t\t\tthrow new XPathException(this, \"No module found matching namespace URI: \" + uri);\n\t\t\treturn new StringValue(module.getDescription());\n\t\t} else if (\"is-module-registered\".equals(getSignature().getName().getLocalName())) {\n\t\t\tString uri = args[0].getStringValue();\n\t\t\tModule module = context.getModule(uri);\n\t\t\treturn new BooleanValue(module != null);\n        } else if (\"mapped-modules\".equals(getSignature().getName().getLocalName())) {\n            ValueSequence resultSeq = new ValueSequence();\n            for (Iterator<String> i = context.getMappedModuleURIs(); i.hasNext();) {\n                resultSeq.add(new StringValue(i.next().toString()));\n            }\n            return resultSeq;\n\t\t} else if (\"is-module-mapped\".equals(getSignature().getName().getLocalName())) {\n\t\t\tString uri = args[0].getStringValue();\n\t\t\treturn new BooleanValue(((Map<String, String>)context.getBroker().getConfiguration().getProperty(XQueryContext.PROPERTY_STATIC_MODULE_MAP)).get(uri) != null);\n\t\t} else if (\"map-module\".equals(getSignature().getName().getLocalName())) {\n\t\t\tif (!context.getSubject().hasDbaRole()) {\n\t\t\t\tXPathException xPathException = new XPathException(this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to call this function.\");\n\t\t\t\tlogger.error(\"Invalid user\", xPathException);\n\t\t\t\tthrow xPathException;\n\t\t\t}\t\t\t\n\t\t\tString namespace = args[0].getStringValue();\n\t\t\tString location = args[1].getStringValue();\n\t\t\tMap <String, String> moduleMap = (Map<String, String>)context.getBroker().getConfiguration().getProperty(XQueryContext.PROPERTY_STATIC_MODULE_MAP);\n\t\t\tmoduleMap.put(namespace, location);\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t} else if (\"unmap-module\".equals(getSignature().getName().getLocalName())) {\n\t\t\tif (!context.getSubject().hasDbaRole()) {\n\t\t\t\tXPathException xPathException = new XPathException(this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to call this function.\");\n\t\t\t\tlogger.error(\"Invalid user\", xPathException);\n\t\t\t\tthrow xPathException;\n\t\t\t}\t\t\t\n\t\t\tString namespace = args[0].getStringValue();\n\t\t\tMap <String, String> moduleMap = (Map<String, String>)context.getBroker().getConfiguration().getProperty(XQueryContext.PROPERTY_STATIC_MODULE_MAP);\n\t\t\tmoduleMap.remove(namespace);\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t} else if (\"get-module-info\".equals(getSignature().getName().getLocalName())) {\n\t\t\tcontext.pushDocumentContext();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemTreeBuilder builder = context.getDocumentBuilder();\n\t\t\t\tbuilder.startElement(MODULES_QNAME, null);\n\t\t\t\t\n\t\t\t\tif (getArgumentCount() == 1) {\n\t\t\t\t\tModule module = context.getModule(args[0].getStringValue());\n\t\t\t\t\tif (module != null)\n\t\t\t\t\t\toutputModule(builder, module);\n\t\t\t\t} else {\n\t\t\t\t\tfor(Iterator<Module> i = context.getRootModules(); i.hasNext(); ) {\n\t\t\t\t\t\tModule module = i.next();\n\t\t\t\t\t\toutputModule(builder, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn builder.getDocument().getNode(1);\n\t\t\t} finally {\n\t\t\t\tcontext.popDocumentContext();\n\t\t\t}\n\t\t} else {\n\t\t\tValueSequence resultSeq = new ValueSequence();\n\t\t\tfor(Iterator<Module> i = context.getRootModules(); i.hasNext(); ) {\n\t\t\t\tModule module = i.next();\n\t\t\t\tresultSeq.add(new StringValue(module.getNamespaceURI()));\n\t\t\t}\n\t\t\treturn resultSeq;\n\t\t}\n\t}","id":79867,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tpublic Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\t\n\t\tif(\"get-module-description\".equals(getSignature().getName().getLocalName())) {\n\t\t\tString uri = args[0].getStringValue();\n\t\t\tModule module = context.getModule(uri);\n\t\t\tif(module == null)\n\t\t\t\tthrow new XPathException(this, \"No module found matching namespace URI: \" + uri);\n\t\t\treturn new StringValue(module.getDescription());\n\t\t} else if (\"is-module-registered\".equals(getSignature().getName().getLocalName())) {\n\t\t\tString uri = args[0].getStringValue();\n\t\t\tModule module = context.getModule(uri);\n\t\t\treturn new BooleanValue(module != null);\n        } else if (\"mapped-modules\".equals(getSignature().getName().getLocalName())) {\n            ValueSequence resultSeq = new ValueSequence();\n            for (Iterator<String> i = context.getMappedModuleURIs(); i.hasNext();) {\n                resultSeq.add(new StringValue(i.next().toString()));\n            }\n            return resultSeq;\n\t\t} else if (\"is-module-mapped\".equals(getSignature().getName().getLocalName())) {\n\t\t\tString uri = args[0].getStringValue();\n\t\t\treturn new BooleanValue(((Map<String, String>)context.getBroker().getConfiguration().getProperty(XQueryContext.PROPERTY_STATIC_MODULE_MAP)).get(uri) != null);\n\t\t} else if (\"map-module\".equals(getSignature().getName().getLocalName())) {\n\t\t\tif (!context.getSubject().hasDbaRole()) {\n\t\t\t\tXPathException xPathException = new XPathException(this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to call this function.\");\n\t\t\t\tlogger.error(\"Invalid user\", xPathException);\n\t\t\t\tthrow xPathException;\n\t\t\t}\t\t\t\n\t\t\tString namespace = args[0].getStringValue();\n\t\t\tString location = args[1].getStringValue();\n\t\t\tMap <String, String> moduleMap = (Map<String, String>)context.getBroker().getConfiguration().getProperty(XQueryContext.PROPERTY_STATIC_MODULE_MAP);\n\t\t\tmoduleMap.put(namespace, location);\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t} else if (\"unmap-module\".equals(getSignature().getName().getLocalName())) {\n\t\t\tif (!context.getSubject().hasDbaRole()) {\n\t\t\t\tXPathException xPathException = new XPathException(this, \"Permission denied, calling user '\" + context.getSubject().getName() + \"' must be a DBA to call this function.\");\n\t\t\t\tlogger.error(\"Invalid user\", xPathException);\n\t\t\t\tthrow xPathException;\n\t\t\t}\t\t\t\n\t\t\tString namespace = args[0].getStringValue();\n\t\t\tMap <String, String> moduleMap = (Map<String, String>)context.getBroker().getConfiguration().getProperty(XQueryContext.PROPERTY_STATIC_MODULE_MAP);\n\t\t\tmoduleMap.remove(namespace);\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\t} else if (\"get-module-info\".equals(getSignature().getName().getLocalName())) {\n\t\t\tcontext.pushDocumentContext();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tMemTreeBuilder builder = context.getDocumentBuilder();\n\t\t\t\tbuilder.startElement(MODULES_QNAME, null);\n\t\t\t\t\n\t\t\t\tif (getArgumentCount() == 1) {\n\t\t\t\t\tModule module = context.getModule(args[0].getStringValue());\n\t\t\t\t\tif (module != null)\n\t\t\t\t\t\toutputModule(builder, module);\n\t\t\t\t} else {\n\t\t\t\t\tfor(Iterator<Module> i = context.getRootModules(); i.hasNext(); ) {\n\t\t\t\t\t\tModule module = i.next();\n\t\t\t\t\t\toutputModule(builder, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn builder.getDocument().getNode(1);\n\t\t\t} finally {\n\t\t\t\tcontext.popDocumentContext();\n\t\t\t}\n\t\t} else {\n\t\t\tValueSequence resultSeq = new ValueSequence();\n            XQueryContext tempContext = new XQueryContext(context.getBroker().getBrokerPool(), AccessContext.XMLDB);\n\t\t\tfor(Iterator<Module> i = tempContext.getRootModules(); i.hasNext(); ) {\n\t\t\t\tModule module = i.next();\n\t\t\t\tresultSeq.add(new StringValue(module.getNamespaceURI()));\n\t\t\t}\n            for (URI uri : tempContext.getRepository().getJavaModules()) {\n                resultSeq.add(new StringValue(uri.toString()));\n            }\n\t\t\treturn resultSeq;\n\t\t}\n\t}","commit_id":"5db898f67da5075642f0ad8984cda37ea726e6ea","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\t\n\t\tif (isCalledAs(\"declare-namespace\"))\n\t\t\tdeclareNamespace(args);\n\t\telse if (isCalledAs(\"declare-option\"))\n\t\t\tdeclareOption(args);\n\t\telse\n\t\t\timportModule(args);\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","id":79868,"modified_method":"public Sequence eval(Sequence[] args, Sequence contextSequence)\n\t\t\tthrows XPathException {\n\t\t\n\t\tif (isCalledAs(\"declare-namespace\")) {\n                    declareNamespace(args);\n                } else if (isCalledAs(\"declare-option\")) {\n                    declareOption(args);\n                } else if(isCalledAs(\"get-option\")) {\n                    return getOption(args);\n                } else{\n                    importModule(args);\n                }\n\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","commit_id":"0bd82c03d2f39bacbb8cdab94590f67fff46da0c","url":"https://github.com/eXist-db/exist"},{"original_method":"public void appendToResponse(WOResponse response, WOContext context) {\n    WOComponent component = context.component();\n    boolean disabled = booleanValueForBinding(\"disabled\", false, component);\n    Object stringValue = valueForBinding(\"string\", component);\n    if (!disabled) {\n      response.appendContentString(\"<a \");\n      appendTagAttributeToResponse(response, \"href\", \"#\");\n      appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      appendTagAttributeToResponse(response, \"title\", valueForBinding(\"title\", component));\n      appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", component));\n      appendTagAttributeToResponse(response, \"class\", valueForBinding(\"class\", component));\n      appendTagAttributeToResponse(response, \"style\", valueForBinding(\"style\", component));\n      appendTagAttributeToResponse(response, \"id\", valueForBinding(\"id\", component));\n      // appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      response.appendContentString(\">\");\n    }\n    if (stringValue != null) {\n      response.appendContentHTMLString(stringValue.toString());\n    }\n    appendChildrenToResponse(response, context);\n    if (!disabled) {\n      response.appendContentString(\"<\/a>\");\n    }\n    super.appendToResponse(response, context);\n  }","id":79869,"modified_method":"public void appendToResponse(WOResponse response, WOContext context) {\n    WOComponent component = context.component();\n    boolean disabled = booleanValueForBinding(\"disabled\", false, component);\n    Object stringValue = valueForBinding(\"string\", component);\n    if (!disabled) {\n      response.appendContentString(\"<a \");\n      appendTagAttributeToResponse(response, \"href\", \"javascript:void(0);\");\n      appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      appendTagAttributeToResponse(response, \"title\", valueForBinding(\"title\", component));\n      appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", component));\n      appendTagAttributeToResponse(response, \"class\", valueForBinding(\"class\", component));\n      appendTagAttributeToResponse(response, \"style\", valueForBinding(\"style\", component));\n      appendTagAttributeToResponse(response, \"id\", valueForBinding(\"id\", component));\n      // appendTagAttributeToResponse(response, \"onclick\", onClick(context));\n      response.appendContentString(\">\");\n    }\n    if (stringValue != null) {\n      response.appendContentHTMLString(stringValue.toString());\n    }\n    appendChildrenToResponse(response, context);\n    if (!disabled) {\n      response.appendContentString(\"<\/a>\");\n    }\n    super.appendToResponse(response, context);\n  }","commit_id":"8dd20bc1bedcc4dfbd9554773e5336e857dcb079","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String onClick(WOContext context) {\n    NSDictionary options = createAjaxOptions(context.component());\n    StringBuffer sb = new StringBuffer();\n    if (associations().valueForKey(\"action\") == null) {\n      String updateContainerID = (String) valueForBinding(\"updateContainerID\", context.component());\n      sb.append(\"new Ajax.Updater('\" + updateContainerID + \"', $('\" + updateContainerID + \"').getAttribute('updateUrl'), \");\n      AjaxOptions.appendToBuffer(options, sb, context);\n      sb.append(\")\");\n    }\n    else {\n      String actionUrl = context.componentActionURL();\n      if (associations().valueForKey(\"function\") == null) {\n        String replaceID = (String) valueForBinding(\"replaceID\", context.component());\n        if (replaceID == null) {\n          sb.append(\"new Ajax.Request('\");\n          sb.append(actionUrl);\n          sb.append(\"', \");\n          AjaxOptions.appendToBuffer(options, sb, context);\n          sb.append(\")\");\n        }\n        else {\n          sb.append(\"new Ajax.Updater('\" + replaceID + \"', '\" + actionUrl + \"', \");\n          AjaxOptions.appendToBuffer(options, sb, context);\n          sb.append(\")\");\n        }\n      }\n      else {\n        String function = (String) valueForBinding(\"function\", context.component());\n        sb.append(\"return \" + function + \"('\" + actionUrl + \"')\");\n      }\n    }\n    String onClick = (String) valueForBinding(\"onClick\", context.component());\n    if (onClick != null) {\n      sb.append(\";\");\n      sb.append(onClick);\n    }\n    return sb.toString();\n  }","id":79870,"modified_method":"public String onClick(WOContext context) {\n\t  WOComponent component = context.component();\n    NSDictionary options = createAjaxOptions(component);\n    StringBuffer onClickBuffer = new StringBuffer();\n    WOAssociation directActionNameAssociation = (WOAssociation) associations().valueForKey(\"directActionName\");\n    \n    String actionUrl = null;\n    if (directActionNameAssociation != null) {\n    \tactionUrl = context.directActionURLForActionNamed((String)directActionNameAssociation.valueInComponent(component), ERXComponentUtilities.queryParametersInComponent(associations(), component)).replaceAll(\"&amp;\", \"&\");\n    }\n    else if (associations().valueForKey(\"action\") != null) {\n        actionUrl = context.componentActionURL();\n    }\n    else {\n      String updateContainerID = (String) valueForBinding(\"updateContainerID\", context.component());\n      onClickBuffer.append(\"new Ajax.Updater('\" + updateContainerID + \"', $('\" + updateContainerID + \"').getAttribute('updateUrl'), \");\n      AjaxOptions.appendToBuffer(options, onClickBuffer, context);\n      onClickBuffer.append(\")\");\n    }\n\n    if (actionUrl != null) {\n      if (associations().valueForKey(\"function\") == null) {\n        String replaceID = (String) valueForBinding(\"replaceID\", context.component());\n        if (replaceID == null) {\n          onClickBuffer.append(\"new Ajax.Request('\");\n          onClickBuffer.append(actionUrl);\n          onClickBuffer.append(\"', \");\n          AjaxOptions.appendToBuffer(options, onClickBuffer, context);\n          onClickBuffer.append(\")\");\n        }\n        else {\n          onClickBuffer.append(\"new Ajax.Updater('\" + replaceID + \"', '\" + actionUrl + \"', \");\n          AjaxOptions.appendToBuffer(options, onClickBuffer, context);\n          onClickBuffer.append(\")\");\n        }\n      }\n      else {\n        String function = (String) valueForBinding(\"function\", context.component());\n        onClickBuffer.append(\"return \" + function + \"('\" + actionUrl + \"')\");\n      }\n    }\n\n    String onClick = (String) valueForBinding(\"onClick\", context.component());\n    if (onClick != null) {\n      onClickBuffer.append(\";\");\n      onClickBuffer.append(onClick);\n    }\n    \n    return onClickBuffer.toString();\n  }","commit_id":"8dd20bc1bedcc4dfbd9554773e5336e857dcb079","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXNavigationItem(NSDictionary values) {\n\t\t// set uniqueID\n\t\t_uniqueID = \"id\" + counter;\n\t\tcounter++;\n\t\tif (values != null) {\n\t\t\tlog.debug(\"ERXNavigationItem {} assigned these values at creation:\\n{}\", uniqueID(), values);\n\t\t\t_action = (String) values.valueForKey(\"action\");\n\t\t\t_conditions = NSArray.EmptyArray;\n\t\t\tObject o = values.valueForKey(\"conditions\");\n\t\t\tif (o != null) {\n\t\t\t\tif (o instanceof NSArray) {\n\t\t\t\t\t_conditions = (NSArray) o;\n\t\t\t\t}\n\t\t\t\telse if (o instanceof String) {\n\t\t\t\t\t_conditions = NSArray.componentsSeparatedByString((String) o, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\to = values.valueForKey(\"qualifier\");\n\t\t\tif (o instanceof String && ((String) o).trim().length() > 0) {\n\t\t\t\t_qualifier = EOQualifier.qualifierWithQualifierFormat((String) o, null);\n\t\t\t}\n\t\t\t_href = (String) values.valueForKey(\"href\");\n\t\t\t_directActionName = (String) values.valueForKey(\"directActionName\");\n\t\t\t_directActionClass = (String) values.valueForKey(\"directActionClass\");\n\t\t\tif (values.valueForKey(\"height\") != null)\n\t\t\t\t_height = Integer.valueOf((String) values.valueForKey(\"height\")).intValue();\n\t\t\tif (values.valueForKey(\"width\") != null)\n\t\t\t\t_width = Integer.valueOf((String) values.valueForKey(\"width\")).intValue();\n\t\t\t_name = (String) values.valueForKey(\"name\");\n\t\t\t_displayName = (String) values.valueForKey(\"displayName\");\n\t\t\tif (_displayName == null || _displayName.length() == 0)\n\t\t\t\t_displayName = _name;\n\t\t\t_pageName = (String) values.valueForKey(\"pageName\");\n\t\t\t_secure = (String) values.valueForKey(\"secure\");\n\t\t\t_hasActivity = (String) values.valueForKey(\"hasActivity\");\n\t\t\tif (values.valueForKey(\"children\") != null && values.valueForKey(\"children\") instanceof NSArray) {\n\t\t\t\t_children = (NSArray) values.valueForKey(\"children\");\n\t\t\t}\n\t\t\telse if (values.valueForKey(\"children\") != null && values.valueForKey(\"children\") instanceof String) {\n\t\t\t\t_childrenBinding = (String) values.valueForKey(\"children\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_children = NSArray.EmptyArray;\n\t\t\t}\n\t\t\tif (values.valueForKey(\"childrenChoices\") != null) {\n\t\t\t\t_childrenChoices = (NSDictionary) values.valueForKey(\"childrenChoices\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_childrenChoices = NSDictionary.EmptyDictionary;\n\t\t\t}\n\t\t\tif (values.valueForKey(\"queryBindings\") != null) {\n\t\t\t\t_queryBindings = (NSDictionary) values.valueForKey(\"queryBindings\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_queryBindings = NSDictionary.EmptyDictionary;\n\t\t\t}\n\t\t\tif (values.valueForKey(\"childrenConditions\") == null || ((String) values.valueForKey(\"childrenConditions\")).equals(\"\")) {\n\t\t\t\t_childrenConditions = NSArray.EmptyArray;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_childrenConditions = NSArray.componentsSeparatedByString((String) values.valueForKey(\"childrenConditions\"), \",\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.warn(\"Constructing a ERXNavigationItem with a null dictionary!\");\n\t\t}\n\t}","id":79871,"modified_method":"public ERXNavigationItem(NSDictionary values) {\n\t\t// set uniqueID\n\t\t_uniqueID = \"id\" + counter;\n\t\tcounter++;\n\t\tif (values != null) {\n\t\t\tlog.debug(\"ERXNavigationItem {} assigned these values at creation:\\n{}\", uniqueID(), values);\n\t\t\t_action = (String) values.valueForKey(\"action\");\n\t\t\t_conditions = NSArray.EmptyArray;\n\t\t\tObject o = values.valueForKey(\"conditions\");\n\t\t\tif (o != null) {\n\t\t\t\tif (o instanceof NSArray) {\n\t\t\t\t\t_conditions = (NSArray) o;\n\t\t\t\t}\n\t\t\t\telse if (o instanceof String) {\n\t\t\t\t\t_conditions = NSArray.componentsSeparatedByString((String) o, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\to = values.valueForKey(\"qualifier\");\n\t\t\tif (o instanceof String && ((String) o).trim().length() > 0) {\n\t\t\t\t_qualifier = EOQualifier.qualifierWithQualifierFormat((String) o, null);\n\t\t\t}\n\t\t\t_href = (String) values.valueForKey(\"href\");\n\t\t\t_directActionName = (String) values.valueForKey(\"directActionName\");\n\t\t\t_directActionClass = (String) values.valueForKey(\"directActionClass\");\n\t\t\tif (values.valueForKey(\"height\") != null)\n\t\t\t\t_height = Integer.valueOf((String) values.valueForKey(\"height\")).intValue();\n\t\t\tif (values.valueForKey(\"width\") != null)\n\t\t\t\t_width = Integer.valueOf((String) values.valueForKey(\"width\")).intValue();\n\t\t\t_name = (String) values.valueForKey(\"name\");\n\t\t\t_defaultChild = (String) values.valueForKey(\"defaultChild\");\n\t\t\t_displayName = (String) values.valueForKey(\"displayName\");\n\t\t\tif (_displayName == null || _displayName.length() == 0)\n\t\t\t\t_displayName = _name;\n\t\t\t_pageName = (String) values.valueForKey(\"pageName\");\n\t\t\t_secure = (String) values.valueForKey(\"secure\");\n\t\t\t_hasActivity = (String) values.valueForKey(\"hasActivity\");\n\t\t\tif (values.valueForKey(\"children\") != null && values.valueForKey(\"children\") instanceof NSArray) {\n\t\t\t\t_children = (NSArray) values.valueForKey(\"children\");\n\t\t\t}\n\t\t\telse if (values.valueForKey(\"children\") != null && values.valueForKey(\"children\") instanceof String) {\n\t\t\t\t_childrenBinding = (String) values.valueForKey(\"children\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_children = NSArray.EmptyArray;\n\t\t\t}\n\t\t\tif (values.valueForKey(\"childrenChoices\") != null) {\n\t\t\t\t_childrenChoices = (NSDictionary) values.valueForKey(\"childrenChoices\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_childrenChoices = NSDictionary.EmptyDictionary;\n\t\t\t}\n\t\t\tif (values.valueForKey(\"queryBindings\") != null) {\n\t\t\t\t_queryBindings = (NSDictionary) values.valueForKey(\"queryBindings\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_queryBindings = NSDictionary.EmptyDictionary;\n\t\t\t}\n\t\t\tif (values.valueForKey(\"childrenConditions\") == null || ((String) values.valueForKey(\"childrenConditions\")).equals(\"\")) {\n\t\t\t\t_childrenConditions = NSArray.EmptyArray;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_childrenConditions = NSArray.componentsSeparatedByString((String) values.valueForKey(\"childrenConditions\"), \",\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlog.warn(\"Constructing a ERXNavigationItem with a null dictionary!\");\n\t\t}\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String directActionName() {\n\t\treturn directActionClass() == null ? _directActionName : directActionClass() + \"/\" + _directActionName;\n\t}","id":79872,"modified_method":"public String directActionName() {\n\t\tif (defaultChild() != null) {\n\t\t\treturn ERXNavigationManager.manager().navigationItemForName(defaultChild()).directActionName();\n\t\t}\n\t\treturn directActionClass() == null ? _directActionName : directActionClass() + \"/\" + _directActionName;\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String action() {\n\t\treturn _action;\n\t}","id":79873,"modified_method":"public String action() {\n\t\tif (defaultChild() != null) {\n\t\t\treturn ERXNavigationManager.manager().navigationItemForName(defaultChild()).action();\n\t\t}\n\t\treturn _action;\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String uneditedDirectActionName() {\n\t\treturn _directActionName;\n\t}","id":79874,"modified_method":"public String uneditedDirectActionName() {\n\t\tif (defaultChild() != null) {\n\t\t\treturn ERXNavigationManager.manager().navigationItemForName(defaultChild()).uneditedDirectActionName();\n\t\t}\n\t\treturn _directActionName;\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String pageName() {\n\t\treturn _pageName;\n\t}","id":79875,"modified_method":"public String pageName() {\n\t\tif (defaultChild() != null) {\n\t\t\treturn ERXNavigationManager.manager().navigationItemForName(defaultChild()).pageName();\n\t\t}\n\t\treturn _pageName;\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String href() {\n\t\treturn _href;\n\t}","id":79876,"modified_method":"public String href() {\n\t\tif (defaultChild() != null) {\n\t\t\treturn ERXNavigationManager.manager().navigationItemForName(defaultChild()).href();\n\t\t}\n\t\treturn _href;\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String directActionClass() {\n\t\treturn _directActionClass;\n\t}","id":79877,"modified_method":"public String directActionClass() {\n\t\tif (defaultChild() != null) {\n\t\t\treturn ERXNavigationManager.manager().navigationItemForName(defaultChild()).directActionClass();\n\t\t}\n\t\treturn _directActionClass;\n\t}","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void setNavigationItems(NSArray items) {\n        NSMutableDictionary itemsByName = new NSMutableDictionary();\n        if (items != null && items.count() > 0) {\n            for (Enumeration e = items.objectEnumerator(); e.hasMoreElements();) {\n                ERXNavigationItem item = (ERXNavigationItem)e.nextElement();\n                if (itemsByName.objectForKey(item.name()) != null) {\n                    log.warn(\"Attempting to register multiple navigation items for the same name: {}\", item.name());\n                } else {\n                    itemsByName.setObjectForKey(item, item.name());\n                    if (item.name().equals(\"Root\"))\n                        rootNavigationItem = item;\n                }\n            }\n        }\n        if (rootNavigationItem == null)\n            log.warn(\"No root navigation item set. You need one.\");\n        navigationItemsByName = itemsByName.immutableClone();\n    }","id":79878,"modified_method":"protected void setNavigationItems(NSArray items) {\n        NSMutableDictionary<String, ERXNavigationItem> itemsByName = new NSMutableDictionary<String, ERXNavigationItem>();\n        if (items != null && items.count() > 0) {\n            for (Enumeration e = items.objectEnumerator(); e.hasMoreElements();) {\n                ERXNavigationItem item = (ERXNavigationItem)e.nextElement();\n                if (itemsByName.objectForKey(item.name()) != null) {\n                    log.warn(\"Attempting to register multiple navigation items for the same name: {}\", item.name());\n                } else {\n                    itemsByName.setObjectForKey(item, item.name());\n                    if (item.name().equals(\"Root\"))\n                        rootNavigationItem = item;\n                }\n            }\n        }\n        if (rootNavigationItem == null)\n            log.warn(\"No root navigation item set. You need one.\");\n        navigationItemsByName = itemsByName.immutableClone();\n    }","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXNavigationItem navigationItemForName(String name) {\n        return (ERXNavigationItem)navigationItemsByName.objectForKey(name);\n    }","id":79879,"modified_method":"public ERXNavigationItem navigationItemForName(String name) {\n        return navigationItemsByName.objectForKey(name);\n    }","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void loadNavigationMenu() {\n        NSMutableArray navigationMenus = new NSMutableArray();\n        // First load the nav_menu from application.\n        NSArray appNavigationMenu = (NSArray)ERXFileUtilities.readPropertyListFromFileInFramework(navigationMenuFileName(), null);\n        if (appNavigationMenu != null) {\n            log.debug(\"Found navigation menu in application: {}\", WOApplication.application().name());\n            navigationMenus.addObjectsFromArray(createNavigationItemsFromDictionaries(appNavigationMenu));\n            registerObserverForFramework(null);\n        }\n        for (Enumeration e = ERXUtilities.allFrameworkNames().objectEnumerator(); e.hasMoreElements();) {\n            String frameworkName = (String)e.nextElement();\n            NSArray aNavigationMenu = (NSArray)ERXFileUtilities.readPropertyListFromFileInFramework(navigationMenuFileName(), frameworkName);\n            if (aNavigationMenu != null && aNavigationMenu.count() > 0) {\n                log.debug(\"Found navigation menu in framework: {}\", frameworkName);\n                navigationMenus.addObjectsFromArray(createNavigationItemsFromDictionaries(aNavigationMenu));\n                registerObserverForFramework(frameworkName);\n            }\n        }\n        setNavigationItems(navigationMenus);\n        log.debug(\"Navigation Menu Configured\");\n    }","id":79880,"modified_method":"public void loadNavigationMenu() {\n        NSMutableArray navigationMenus = new NSMutableArray();\n        // First load the nav_menu from application.\n        NSArray appNavigationMenu = (NSArray)ERXFileUtilities.readPropertyListFromFileInFramework(navigationMenuFileName(), null);\n        if (appNavigationMenu != null) {\n            log.debug(\"Found navigation menu in application: {}\", WOApplication.application().name());\n            navigationMenus.addObjectsFromArray(createNavigationItemsFromDictionaries(appNavigationMenu));\n            registerObserverForFramework(null);\n        }\n        for (Enumeration e = ERXUtilities.allFrameworkNames().objectEnumerator(); e.hasMoreElements();) {\n            String frameworkName = (String)e.nextElement();\n            NSArray aNavigationMenu = (NSArray)ERXFileUtilities.readPropertyListFromFileInFramework(navigationMenuFileName(), frameworkName);\n            if (aNavigationMenu != null && aNavigationMenu.count() > 0) {\n                log.debug(\"Found navigation menu in framework: {}\", frameworkName);\n                navigationMenus.addObjectsFromArray(createNavigationItemsFromDictionaries(aNavigationMenu));\n                registerObserverForFramework(frameworkName);\n            }\n        }\n        setNavigationItems(navigationMenus);\n        // compute default child items\n        NSMutableDictionary<Object, String> fakeContext = new NSMutableDictionary<Object, String>();\n        for (ERXNavigationItem anItem : navigationItemsByName().allValues()) {\n        \tanItem.childItemsInContext(fakeContext);\n        }\n        // set defaultChild values where actions match\n        for (String anItemName : navigationItemsByName().allKeys()) {\n        \tERXNavigationItem anItem = navigationItemsByName().objectForKey(anItemName);\n\t\t\tif (anItem.children() != null && anItem.children().count() > 0 && anItem.defaultChild() == null) {\n\t\t\t\tfor (String aChildName : anItem.children()) {\n\t\t\t\t\tERXNavigationItem aChild = navigationItemsByName().objectForKey(aChildName);\n\t\t\t\t\tif (aChild != null) {\n\t\t\t\t\t\tif (anItem.action() != null && anItem.action().equals(aChild.action())) {\n\t\t\t\t\t\t\tanItem.setDefaultChild(aChild.name());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (anItem.directActionName() != null && anItem.directActionName().equals(aChild.directActionName())) {\n\t\t\t\t\t\t\tanItem.setDefaultChild(aChild.name());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (anItem.href() != null && anItem.href().equals(aChild.href())) {\n\t\t\t\t\t\t\tanItem.setDefaultChild(aChild.name());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (anItem.pageName() != null && anItem.pageName().equals(aChild.pageName())) {\n\t\t\t\t\t\t\tanItem.setDefaultChild(aChild.name());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn(\"You set an undefined child on the item {}\", anItem.name());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n        }\n        log.debug(\"Navigation Menu Configured\");\n    }","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String contextComponentActionURL() {\n        // If the navigation should be disabled return null\n        if (navigationState().isDisabled() || meetsDisplayConditions() == false) {\n            return null;\n        }\n\n        // hrefs take precedence over actions.\n        if (navigationItem().href() != null && !\"\".equals(navigationItem().href().trim())) {\n        \treturn navigationItem().href();\n        }\n        \n        // If the user specified an action or pageName, return the source URL\n        if ((navigationItem().action() != null) || (navigationItem().pageName() != null)) {\n            // Return the URL to the action or page placed in the context by invokeAction\n            return context().componentActionURL();\n        }\n        if (navigationItem().directActionName() != null) {\n        \tif(_linkDirectlyToDirectActions) {\n        \t\tNSMutableDictionary bindings = navigationItem().queryBindings().mutableClone();\n        \t\tbindings.setObjectForKey(context().contextID(), \"__cid\");\n        \t\treturn context().directActionURLForActionNamed(navigationItem().directActionName(), bindings);\n        \t}\n        \treturn context().componentActionURL();\n        }\n\n        // If the user specified some javascript, put that into the HREF and return it\n        if (canGetValueForBinding(\"javascriptFunction\")) {\n\n            // Make sure there are no extra quotations marks - replace them with apostrophes\n            String theFunction = (String)valueForBinding(\"javascriptFunction\");\n            return StringUtils.replace(theFunction, \"\\\"\", \"'\");\n        }\n\n        return null;\n    }","id":79881,"modified_method":"public String contextComponentActionURL() {\n    \tString url = null;\n        // If the navigation should be disabled return null\n        if (navigationState().isDisabled() || meetsDisplayConditions() == false) {\n            return null;\n        }\n\n        // hrefs take precedence over actions.\n        if (navigationItem().href() != null && !\"\".equals(navigationItem().href().trim())) {\n        \turl =  navigationItem().href();\n        }\n        \n        // If the user specified an action or pageName, return the source URL\n        if (url == null && (navigationItem().action() != null) || (navigationItem().pageName() != null)) {\n            // Return the URL to the action or page placed in the context by invokeAction\n            url = context().componentActionURL();\n        }\n        if (url == null && navigationItem().directActionName() != null) {\n        \tif(_linkDirectlyToDirectActions) {\n        \t\tNSMutableDictionary bindings = navigationItem().queryBindings().mutableClone();\n        \t\tbindings.setObjectForKey(context().contextID(), \"__cid\");\n        \t\turl = context().directActionURLForActionNamed(navigationItem().directActionName(), bindings);\n        \t} else {\n        \t\turl = context().componentActionURL();\n        \t}\n        }\n\n        // If the user specified some javascript, put that into the HREF and return it\n        if (url == null && canGetValueForBinding(\"javascriptFunction\")) {\n            // Make sure there are no extra quotations marks - replace them with apostrophes\n            String theFunction = (String)valueForBinding(\"javascriptFunction\");\n            url = StringUtils.replace(theFunction, \"\\\"\", \"'\");\n        }\n        // force parent hierarchy to be computed, required for full state to be computed\n        children();\n        // store navigation state for this item\n\t\tERXNavigationManager.manager().storeInNavigationMap(context().session(), navigationItem(), url);\n        return url;\n    }","commit_id":"b7c5434b7a5a89accfecaef49a9d7c1ac911207d","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendAttributesToResponse(WOResponse response, WOContext context) {\n\t\tsuper.appendAttributesToResponse(response, context);\n\t\tresponse.appendContentString(\" onclick = \\\"location.href='\");\n\t\tresponse.appendContentString(context.componentActionURL());\n\t\tresponse.appendContentString(\"'\\\" style = \\\"cursor: pointer;\\\"\");\n\t}","id":79882,"modified_method":"public void appendAttributesToResponse(WOResponse response, WOContext context) {\n\t\tsuper.appendAttributesToResponse(response, context);\n\t\tWOComponent component = context.component();\n\t\tresponse.appendContentString(\" onclick = \\\"location.href='\");\n\t\tString url;\n\t\tif (_directActionName != null) {\n\t\t\tString actionName = (String) _directActionName.valueInComponent(component);\n\t\t\tif (_actionClass != null) {\n\t\t\t\tactionName = actionName + \"/\" + (String) _actionClass.valueInComponent(component);\n\t\t\t}\n\t\t\turl = context.directActionURLForActionNamed(actionName, null);\n\t\t}\n\t\telse {\n\t\t\turl = context.componentActionURL();\n\t\t}\n\t\tresponse.appendContentString(url);\n\t\tresponse.appendContentString(\"'\\\" style = \\\"cursor: pointer;\\\"\");\n\t}","commit_id":"ce1378ee2f7a9b705f7d0b7b67090a1642bff080","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERXClickableContainer(String name, NSDictionary associations, WOElement template) {\n\t\tsuper(name, ERXClickableContainer._processAssociations(associations), template);\n\t}","id":79883,"modified_method":"public ERXClickableContainer(String name, NSDictionary associations, WOElement template) {\n\t\tsuper(name, ERXClickableContainer._processAssociations(associations), template);\n\t\t_actionClass = (WOAssociation) _associations.removeObjectForKey(\"actionClass\");\n\t\t_directActionName = (WOAssociation) _associations.removeObjectForKey(\"directActionName\");\n\t}","commit_id":"ce1378ee2f7a9b705f7d0b7b67090a1642bff080","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Resolve relative imports from sdk root to the skeleton dir\n   */\n  private void addResultsFromSkeletons(@NotNull final PsiFile foothold) {\n    final boolean inSource = FileIndexFacade.getInstance(foothold.getProject()).isInContent(foothold.getVirtualFile());\n    if (inSource) return;\n    PsiDirectory containingDirectory = foothold.getContainingDirectory();\n    if (myRelativeLevel > 0) {\n      containingDirectory = ResolveImportUtil.stepBackFrom(foothold, myRelativeLevel);\n    }\n    if (containingDirectory != null) {\n      final QualifiedName containingPath = QualifiedNameFinder.findCanonicalImportPath(containingDirectory, null);\n      if (containingPath != null && containingPath.getComponentCount() > 0) {\n        final QualifiedName absolutePath = containingPath.append(myQualifiedName.toString());\n        final QualifiedNameResolverImpl absoluteVisitor =\n          (QualifiedNameResolverImpl)new QualifiedNameResolverImpl(absolutePath).fromElement(foothold);\n\n        final Sdk sdk = PythonSdkType.getSdk(foothold);\n        if (sdk == null) return;\n        final VirtualFile skeletonsDir = PySdkUtil.findSkeletonsDir(sdk);\n        if (skeletonsDir == null) return;\n        final PsiDirectory directory = myContext.getPsiManager().findDirectory(skeletonsDir);\n        myLibResults.add(absoluteVisitor.resolveModuleAt(directory));\n      }\n    }\n  }","id":79884,"modified_method":"/**\n   * Resolve relative imports from sdk root to the skeleton dir\n   */\n  private void addResultsFromSkeletons(@NotNull final PsiFile foothold) {\n    final boolean inSource = FileIndexFacade.getInstance(foothold.getProject()).isInContent(foothold.getVirtualFile());\n    if (inSource) return;\n    PsiDirectory containingDirectory = foothold.getContainingDirectory();\n    if (myRelativeLevel > 0) {\n      containingDirectory = ResolveImportUtil.stepBackFrom(foothold, myRelativeLevel);\n    }\n    if (containingDirectory != null) {\n      final QualifiedName containingPath = QualifiedNameFinder.findCanonicalImportPath(containingDirectory, null);\n      if (containingPath != null && containingPath.getComponentCount() > 0) {\n        final QualifiedName absolutePath = containingPath.append(myQualifiedName.toString());\n        final QualifiedNameResolverImpl absoluteVisitor =\n          (QualifiedNameResolverImpl)new QualifiedNameResolverImpl(absolutePath).fromElement(foothold);\n\n        final Sdk sdk = PythonSdkType.getSdk(foothold);\n        if (sdk == null) return;\n        final VirtualFile skeletonsDir = PySdkUtil.findSkeletonsDir(sdk);\n        if (skeletonsDir == null) return;\n        final PsiDirectory directory = myContext.getPsiManager().findDirectory(skeletonsDir);\n        final PsiElement psiElement = absoluteVisitor.resolveModuleAt(directory);\n        if (psiElement != null)\n          myLibResults.add(psiElement);\n      }\n    }\n  }","commit_id":"deb048df2a4f027a0580fd050c1476b0d4a4e142","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean visitRoot(final VirtualFile root) {\n      PsiElement module = root.isDirectory() ? psimgr.findDirectory(root) : psimgr.findFile(root);\n      for (String component : qualifiedName.getComponents()) {\n        module = resolveChild(module, component, foothold_file, false); // only files, we want a module\n        if (module == null) {\n          return true;\n        }\n      }\n      result = module;\n      return false;\n    }","id":79885,"modified_method":"public boolean visitRoot(final VirtualFile root) {\n      PsiElement module = root.isDirectory() ? psimgr.findDirectory(root) : psimgr.findFile(root);\n      for (String component : qualifiedName.getComponents()) {\n        module = resolveChild(module, component, foothold_file, false); // only files, we want a module\n      }\n      if (module != null) {\n        results.add(module);\n      }\n      return true;\n    }","commit_id":"e51d0db4c425d05495ef54988978b8ae807337c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement resolveModuleInRoots(PyQualifiedName moduleQualifiedName, PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return null;\n    PsiFile foothold_file = foothold.getContainingFile();\n    if (foothold_file == null || !foothold_file.isValid()) return null;\n\n    if (moduleQualifiedName.getComponentCount() < 1) return null;\n\n    ResolveInRootVisitor visitor = new ResolveInRootVisitor(moduleQualifiedName, foothold.getManager(), foothold_file);\n    visitRoots(foothold, visitor);\n    return visitor.getResult();\n  }","id":79886,"modified_method":"@Nullable\n  public static PsiElement resolveModuleInRoots(PyQualifiedName moduleQualifiedName, PsiElement foothold) {\n    final List<PsiElement> candidates = resolveModulesInRoots(moduleQualifiedName, foothold);\n    return candidates.isEmpty() ? null : candidates.get(0);\n  }","commit_id":"e51d0db4c425d05495ef54988978b8ae807337c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ResolveInRootVisitor(PyQualifiedName qName, PsiManager psimgr, PsiFile foothold_file) {\n      this.qualifiedName = qName;\n      this.psimgr = psimgr;\n      this.foothold_file = foothold_file;\n      this.result = null;\n    }","id":79887,"modified_method":"public ResolveInRootVisitor(PyQualifiedName qName, PsiManager psimgr, PsiFile foothold_file) {\n      this.qualifiedName = qName;\n      this.psimgr = psimgr;\n      this.foothold_file = foothold_file;\n    }","commit_id":"e51d0db4c425d05495ef54988978b8ae807337c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Resolves a module reference in a general case.\n   * @param module_reference possibly qualified module reference.\n   * @param source_file where that reference resides; serves as PSI foothold to determine module, project, etc.\n   * @param import_is_absolute if false, try old python 2.x's \"relative first, absolute next\" approach.\n   * @param relative_level if > 0, step back from source_file and resolve from there (even if import_is_absolute is false!). \n   * @return\n   */\n  @Nullable\n  private static PsiElement resolveModule(@Nullable PyQualifiedName qualifiedName, PsiFile source_file,\n                                          boolean import_is_absolute, int relative_level) {\n    PsiElement imported_from_module;\n\n    if (qualifiedName == null) return null;\n    String marker = StringUtil.join(qualifiedName.getComponents(), \".\") + \"#\" + Integer.toString(relative_level);\n    Set<String> being_imported = ourBeingImported.get();\n    if (being_imported.contains(marker)) return null; // break endless loop in import\n    try {\n      being_imported.add(marker);\n      if (relative_level > 0) {\n        // \"from ...module import\"\n        imported_from_module = resolveModuleAt(stepBackFrom(source_file, relative_level), source_file, qualifiedName);\n      }\n      else { // \"from module import\"\n        if (import_is_absolute) imported_from_module = resolveModuleInRoots(qualifiedName, source_file);\n        else {\n          imported_from_module = resolveModuleAt(source_file.getContainingDirectory(), source_file, qualifiedName);\n          if (imported_from_module == null) imported_from_module = resolveModuleInRoots(qualifiedName, source_file);\n        }\n      }\n      return imported_from_module;\n    }\n    finally {\n      being_imported.remove(marker);\n    }\n  }","id":79888,"modified_method":"/**\n   * Resolves a module reference in a general case.\n   * @param module_reference possibly qualified module reference.\n   * @param source_file where that reference resides; serves as PSI foothold to determine module, project, etc.\n   * @param import_is_absolute if false, try old python 2.x's \"relative first, absolute next\" approach.\n   * @param relative_level if > 0, step back from source_file and resolve from there (even if import_is_absolute is false!). \n   * @return\n   */\n  @NotNull\n  private static List<PsiElement> resolveModule(@Nullable PyQualifiedName qualifiedName, PsiFile source_file,\n                                                boolean import_is_absolute, int relative_level) {\n    if (qualifiedName == null) return null;\n    String marker = StringUtil.join(qualifiedName.getComponents(), \".\") + \"#\" + Integer.toString(relative_level);\n    Set<String> being_imported = ourBeingImported.get();\n    if (being_imported.contains(marker)) return null; // break endless loop in import\n    try {\n      being_imported.add(marker);\n      if (relative_level > 0) {\n        // \"from ...module import\"\n        final PsiElement module = resolveModuleAt(stepBackFrom(source_file, relative_level), source_file, qualifiedName);\n        return module != null ? Collections.singletonList(module) : Collections.<PsiElement>emptyList();\n      }\n      else { // \"from module import\"\n        if (import_is_absolute) {\n          return resolveModulesInRoots(qualifiedName, source_file);\n        }\n        else {\n          PsiElement module = resolveModuleAt(source_file.getContainingDirectory(), source_file, qualifiedName);\n          if (module != null) {\n            return Collections.singletonList(module);\n          }\n          return resolveModulesInRoots(qualifiedName, source_file);\n        }\n      }\n    }\n    finally {\n      being_imported.remove(marker);\n    }\n  }","commit_id":"e51d0db4c425d05495ef54988978b8ae807337c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement resolveImportElement(PyImportElement import_element, final PyQualifiedName qName) {\n    if (qName == null) {\n      return null;\n    }\n\n    final PsiFile file = import_element.getContainingFile();\n    final PyStatement importStatement = import_element.getContainingImportStatement();\n\n    boolean absolute_import_enabled = isAbsoluteImportEnabledFor(import_element);\n    PyQualifiedName moduleQName = null;\n\n    if (importStatement instanceof PyFromImportStatement) {\n      PsiElement imported_from_module;\n      PyFromImportStatement from_import_statement = (PyFromImportStatement)importStatement;\n      moduleQName = from_import_statement.getImportSourceQName();\n      final int relative_level = from_import_statement.getRelativeLevel();\n\n      if (relative_level > 0 && moduleQName == null) { // \"from ... import foo\"\n        return resolveChild(stepBackFrom(file, relative_level), qName.getComponents().get(0), file, false);\n      }\n\n      if (moduleQName != null) { // either \"from bar import foo\" or \"from ...bar import foo\"\n        imported_from_module = resolveModule(moduleQName, file, absolute_import_enabled, relative_level);\n        PsiElement result = resolveChild(imported_from_module, qName.getComponents().get(0), file, false);\n        if (result != null) return result;\n      }\n    }\n    else if (importStatement instanceof PyImportStatement) { // \"import foo\"\n      PsiElement result = resolveModule(qName, file, absolute_import_enabled, 0);\n      if (result != null) return result;\n    }\n    // in-python resolution failed\n    if (moduleQName != null) {\n      return resolveForeignImport(import_element, StringUtil.join(qName.getComponents(), \".\"), resolveModule(moduleQName, file, false, 0));\n    }\n    return null;\n  }","id":79889,"modified_method":"@Nullable\n  public static PsiElement resolveImportElement(PyImportElement import_element, final PyQualifiedName qName) {\n    if (qName == null) {\n      return null;\n    }\n\n    final PsiFile file = import_element.getContainingFile();\n    final PyStatement importStatement = import_element.getContainingImportStatement();\n\n    boolean absolute_import_enabled = isAbsoluteImportEnabledFor(import_element);\n    PyQualifiedName moduleQName = null;\n\n    if (importStatement instanceof PyFromImportStatement) {\n      PyFromImportStatement from_import_statement = (PyFromImportStatement)importStatement;\n      moduleQName = from_import_statement.getImportSourceQName();\n      final int relative_level = from_import_statement.getRelativeLevel();\n\n      if (relative_level > 0 && moduleQName == null) { // \"from ... import foo\"\n        return resolveChild(stepBackFrom(file, relative_level), qName.getComponents().get(0), file, false);\n      }\n\n      if (moduleQName != null) { // either \"from bar import foo\" or \"from ...bar import foo\"\n        final List<PsiElement> candidates = resolveModule(moduleQName, file, absolute_import_enabled, relative_level);\n        for (PsiElement candidate : candidates) {\n          PsiElement result = resolveChild(candidate, qName.getComponents().get(0), file, false);\n          if (result != null) return result;\n        }\n      }\n    }\n    else if (importStatement instanceof PyImportStatement) { // \"import foo\"\n      List<PsiElement> result = resolveModule(qName, file, absolute_import_enabled, 0);\n      return result.isEmpty() ? null : result.get(0);\n    }\n    // in-python resolution failed\n    if (moduleQName != null) {\n      final List<PsiElement> importFrom = resolveModule(moduleQName, file, false, 0);\n      return resolveForeignImport(import_element, StringUtil.join(qName.getComponents(), \".\"), importFrom.isEmpty() ? null : importFrom.get(0));\n    }\n    return null;\n  }","commit_id":"e51d0db4c425d05495ef54988978b8ae807337c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiElement resolveFromImportStatementSource(PyFromImportStatement from_import_statement, PyQualifiedName qName) {\n    boolean absolute_import_enabled = isAbsoluteImportEnabledFor(from_import_statement);\n    PsiFile file = from_import_statement.getContainingFile();\n    return resolveModule(qName, file, absolute_import_enabled, from_import_statement.getRelativeLevel());\n  }","id":79890,"modified_method":"@Nullable\n  private static PsiElement resolveFromImportStatementSource(PyFromImportStatement from_import_statement, PyQualifiedName qName) {\n    boolean absolute_import_enabled = isAbsoluteImportEnabledFor(from_import_statement);\n    PsiFile file = from_import_statement.getContainingFile();\n    final List<PsiElement> candidates = resolveModule(qName, file, absolute_import_enabled, from_import_statement.getRelativeLevel());\n    return candidates.isEmpty() ? null : candidates.get(0);\n  }","commit_id":"e51d0db4c425d05495ef54988978b8ae807337c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        XWikiDocument inputDocument = this.documentListener.getDocument();\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            XWikiDocument document =\n                xcontext.getWiki().getDocument(inputDocument.getDocumentReferenceWithLocale(), xcontext);\n\n            if (document.isNew()) {\n                document = inputDocument;\n            } else {\n                if (this.properties.isPreviousDeleted() && !this.documentDeleted) {\n                    xcontext.getWiki().deleteDocument(document, xcontext);\n                    this.documentDeleted = true;\n                    document = inputDocument;\n                } else {\n                    document.loadAttachmentsContent(xcontext);\n                    document.apply(inputDocument);\n                }\n            }\n\n            document.setMinorEdit(inputDocument.isMinorEdit());\n\n            // Author\n\n            if (this.properties.isAuthorPreserved()) {\n                document.setAuthorReference(inputDocument.getAuthorReference());\n                document.setContentAuthorReference(inputDocument.getContentAuthorReference());\n            } else {\n                if (document.isNew()) {\n                    document.setCreatorReference(xcontext.getUserReference());\n                }\n                document.setAuthorReference(xcontext.getUserReference());\n                document.setContentAuthorReference(xcontext.getUserReference());\n            }\n\n            // Versions and save document\n\n            // Don't preserve version or history if we don't delete the previous document\n            if (document.isNew() && this.properties.isVersionPreserved()) {\n                document.setMetaDataDirty(false);\n                document.setContentDirty(false);\n\n                xcontext.getWiki().saveDocument(document, document.getComment(), document.isMinorEdit(), xcontext);\n            } else {\n                xcontext.getWiki().saveDocument(document, this.properties.getSaveComment(), xcontext);\n            }\n\n            if (this.properties.isVerbose()) {\n                this.logger.info(\"Saved document [{}]\", document.getDocumentReferenceWithLocale());\n            }\n        } catch (Exception e) {\n            throw new WikiStreamException(\"Failed to save document\", e);\n        }\n    }","id":79891,"modified_method":"@Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        XWikiDocument inputDocument = this.documentListener.getDocument();\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            XWikiDocument document =\n                xcontext.getWiki().getDocument(inputDocument.getDocumentReferenceWithLocale(), xcontext);\n\n            if (document.isNew()) {\n                document = inputDocument;\n            } else {\n                if (this.properties.isPreviousDeleted() && !this.documentDeleted) {\n                    xcontext.getWiki().deleteDocument(document, xcontext);\n                    this.documentDeleted = true;\n                    document = inputDocument;\n                } else {\n                    document.loadAttachmentsContent(xcontext);\n                    document.apply(inputDocument);\n                }\n            }\n\n            document.setMinorEdit(inputDocument.isMinorEdit());\n\n            // Author\n\n            if (this.properties.isAuthorPreserved()) {\n                document.setAuthorReference(inputDocument.getAuthorReference());\n                document.setContentAuthorReference(inputDocument.getContentAuthorReference());\n            } else {\n                if (document.isNew()) {\n                    document.setCreatorReference(xcontext.getUserReference());\n                }\n                document.setAuthorReference(xcontext.getUserReference());\n                document.setContentAuthorReference(xcontext.getUserReference());\n            }\n\n            // Save history\n            if (document.isNew() && document.getDocumentArchive() != null) {\n                // we need to force the saving the document archive\n                if (document.getDocumentArchive() != null) {\n                    xcontext.getWiki().getVersioningStore()\n                        .saveXWikiDocArchive(document.getDocumentArchive(xcontext), true, xcontext);\n                }\n            }\n\n            // Don't preserve version or history if we don't delete the previous document\n            if (document.isNew() && (this.properties.isAuthorPreserved() || this.properties.isVersionPreserved())) {\n                // Make sure version is set\n                document.setVersion(document.getVersion());\n\n                document.setMetaDataDirty(false);\n                document.setContentDirty(false);\n\n                xcontext.getWiki().saveDocument(document, document.getComment(), document.isMinorEdit(), xcontext);\n            } else {\n                xcontext.getWiki().saveDocument(document, this.properties.getSaveComment(), xcontext);\n            }\n\n            if (this.properties.isVerbose()) {\n                this.logger.info(\"Saved document [{}]\", document.getDocumentReferenceWithLocale());\n            }\n        } catch (Exception e) {\n            throw new WikiStreamException(\"Failed to save document\", e);\n        }\n    }","commit_id":"0bf587c6ba616d49ca060041324ec1b4833255e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.currentLocale = null;\n\n        this.currentCreationDate = null;\n        this.currentCreationAuthor = null;\n    }","id":79892,"modified_method":"@Override\n    public void endWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.currentLocale = null;\n        this.currentLocaleParameters = null;\n    }","commit_id":"0bf587c6ba616d49ca060041324ec1b4833255e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void beginWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.currentLocale = locale;\n\n        this.currentCreationDate = getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, parameters, null);\n        this.currentCreationAuthor = getString(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR, parameters, null);\n    }","id":79893,"modified_method":"@Override\n    public void beginWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.currentLocale = locale;\n        this.currentLocaleParameters = parameters;\n    }","commit_id":"0bf587c6ba616d49ca060041324ec1b4833255e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.document =\n            new XWikiDocument(this.entityResolver.resolve(this.currentEntityReference, this.properties != null\n                ? this.properties.getDefaultReference() : null));\n\n        this.document.setCreationDate(this.currentCreationDate);\n        this.document.setCreator(this.currentCreationAuthor);\n        this.document.setDefaultLocale(this.currentDefaultLocale);\n\n        this.document.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));\n\n        this.document.setLocale(this.currentLocale);\n\n        this.document.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));\n        this.document.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));\n        this.document.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));\n        this.document.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));\n        this.document.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));\n        this.document.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));\n\n        this.document.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n        this.document.setAuthor(getString(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR, parameters, null));\n        this.document.setContentAuthor(getString(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, null));\n\n        String revisions = getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, parameters, null);\n        if (revisions != null) {\n            try {\n                this.document.setDocumentArchive(revisions);\n            } catch (XWikiException e) {\n                throw new WikiStreamException(\"Failed to set document archive\", e);\n            }\n        }\n\n        if (version != null && this.properties.isVersionPreserved()) {\n            if (VALID_VERSION.matcher(version).matches()) {\n                this.document.setVersion(version);\n            } else if (NumberUtils.isDigits(version)) {\n                this.document.setVersion(version + \".1\");\n            } else {\n                // TODO: log something, probably a warning\n            }\n        }\n\n        this.document.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n        this.document.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n        this.document.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n        // Content\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {\n            this.document.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));\n        } else {\n            if (this.properties != null && this.properties.getDefaultSyntax() != null) {\n                this.document.setSyntax(this.properties.getDefaultSyntax());\n            } else {\n                // Make sure to set the default syntax if none were provided\n                this.document.setSyntax(this.document.getSyntax());\n            }\n\n            ComponentManager componentManager = this.componentManagerProvider.get();\n\n            if (componentManager.hasComponent(PrintRendererFactory.class, this.document.getSyntax().toIdString())) {\n                PrintRendererFactory rendererFactory;\n                try {\n                    rendererFactory =\n                        componentManager\n                            .getInstance(PrintRendererFactory.class, this.document.getSyntax().toIdString());\n                } catch (ComponentLookupException e) {\n                    throw new WikiStreamException(String.format(\"Failed to find PrintRendererFactory for syntax [%s]\",\n                        this.document.getSyntax()), e);\n                }\n\n                this.currentWikiPrinter = new DefaultWikiPrinter();\n                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));\n            }\n        }\n    }","id":79894,"modified_method":"@Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.document =\n            new XWikiDocument(this.entityResolver.resolve(this.currentEntityReference, this.properties != null\n                ? this.properties.getDefaultReference() : null));\n\n        this.document.setCreationDate(getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, this.currentLocaleParameters,\n            null));\n        this.document.setCreator(getString(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR, this.currentLocaleParameters,\n            null));\n        this.document.setDefaultLocale(this.currentDefaultLocale);\n\n        this.document.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));\n\n        this.document.setLocale(this.currentLocale);\n\n        this.document.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));\n        this.document.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));\n        this.document.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));\n        this.document.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));\n        this.document.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));\n        this.document.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));\n\n        this.document.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n        this.document.setAuthor(getString(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR, parameters, null));\n        this.document.setContentAuthor(getString(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, null));\n\n        String revisions =\n            getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, this.currentLocaleParameters, null);\n        if (revisions != null) {\n            try {\n                this.document.setDocumentArchive(revisions);\n            } catch (XWikiException e) {\n                throw new WikiStreamException(\"Failed to set document archive\", e);\n            }\n        }\n\n        if (version != null && this.properties.isVersionPreserved()) {\n            if (VALID_VERSION.matcher(version).matches()) {\n                this.document.setVersion(version);\n            } else if (NumberUtils.isDigits(version)) {\n                this.document.setVersion(version + \".1\");\n            } else {\n                // TODO: log something, probably a warning\n            }\n        }\n\n        this.document.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n        this.document.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n        this.document.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n        // Content\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {\n            this.document.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));\n        } else {\n            if (this.properties != null && this.properties.getDefaultSyntax() != null) {\n                this.document.setSyntax(this.properties.getDefaultSyntax());\n            } else {\n                // Make sure to set the default syntax if none were provided\n                this.document.setSyntax(this.document.getSyntax());\n            }\n\n            ComponentManager componentManager = this.componentManagerProvider.get();\n\n            if (componentManager.hasComponent(PrintRendererFactory.class, this.document.getSyntax().toIdString())) {\n                PrintRendererFactory rendererFactory;\n                try {\n                    rendererFactory =\n                        componentManager\n                            .getInstance(PrintRendererFactory.class, this.document.getSyntax().toIdString());\n                } catch (ComponentLookupException e) {\n                    throw new WikiStreamException(String.format(\"Failed to find PrintRendererFactory for syntax [%s]\",\n                        this.document.getSyntax()), e);\n                }\n\n                this.currentWikiPrinter = new DefaultWikiPrinter();\n                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));\n            }\n        }\n    }","commit_id":"0bf587c6ba616d49ca060041324ec1b4833255e4","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void beginWikiDocumentLocale(Locale arg0, FilterEventParameters arg1) throws WikiStreamException\n    {\n        // Nothing to do\n    }","id":79895,"modified_method":"@Override\n    public void beginWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.currentLocaleParameters = parameters;\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endWikiDocument(String arg0, FilterEventParameters arg1) throws WikiStreamException\n    {\n        // Nothing to do\n    }","id":79896,"modified_method":"@Override\n    public void endWikiDocument(String name, FilterEventParameters parameters) throws WikiStreamException\n    {\n        // Nothing to do\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endWikiDocumentLocale(Locale arg0, FilterEventParameters arg1) throws WikiStreamException\n    {\n        // Nothing to do\n    }","id":79897,"modified_method":"@Override\n    public void endWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.currentLocaleParameters = null;\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void beginWikiDocument(String arg0, FilterEventParameters arg1) throws WikiStreamException\n    {\n        this.documentDeleted = false;\n    }","id":79898,"modified_method":"@Override\n    public void beginWikiDocument(String name, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.documentDeleted = false;\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void beginWikiDocumentRevision(String arg0, FilterEventParameters arg1) throws WikiStreamException\n    {\n        // Nothing to do\n    }","id":79899,"modified_method":"@Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        // Nothing to do\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        XWikiDocument inputDocument = this.documentListener.getDocument();\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            XWikiDocument document =\n                xcontext.getWiki().getDocument(inputDocument.getDocumentReferenceWithLocale(), xcontext);\n\n            boolean isNew = document.isNew();\n\n            if (document.isNew()) {\n                document = inputDocument;\n            } else {\n                if (this.properties.isPreviousDeleted() && !this.documentDeleted) {\n                    xcontext.getWiki().deleteDocument(document, xcontext);\n                    this.documentDeleted = true;\n                    document = inputDocument;\n                } else {\n                    document.loadAttachmentsContent(xcontext);\n                    document.apply(inputDocument);\n                }\n            }\n\n            document.setMinorEdit(inputDocument.isMinorEdit());\n\n            // Author\n\n            if (this.properties.isAuthorPreserved()) {\n                document.setAuthorReference(inputDocument.getAuthorReference());\n                document.setContentAuthorReference(inputDocument.getContentAuthorReference());\n            } else {\n                if (document.isNew()) {\n                    document.setCreatorReference(xcontext.getUserReference());\n                }\n                document.setAuthorReference(xcontext.getUserReference());\n                document.setContentAuthorReference(xcontext.getUserReference());\n            }\n\n            // Save history\n            if (document.isNew() && document.getDocumentArchive() != null) {\n                // we need to force the saving the document archive\n                if (document.getDocumentArchive() != null) {\n                    xcontext.getWiki().getVersioningStore()\n                        .saveXWikiDocArchive(document.getDocumentArchive(xcontext), true, xcontext);\n                }\n            }\n\n            // Don't preserve version or history if we don't delete the previous document\n            if (document.isNew() && (this.properties.isAuthorPreserved() || this.properties.isVersionPreserved())) {\n                // Make sure version is set\n                document.setVersion(document.getVersion());\n\n                document.setMetaDataDirty(false);\n                document.setContentDirty(false);\n\n                xcontext.getWiki().saveDocument(document, document.getComment(), document.isMinorEdit(), xcontext);\n            } else {\n                xcontext.getWiki().saveDocument(document, this.properties.getSaveComment(), xcontext);\n            }\n\n            if (this.properties.isVerbose()) {\n                if (isNew) {\n                    this.logger.info(LOG_DOCUMENT_CREATED, \"Created document [{}]\",\n                        document.getDocumentReferenceWithLocale());\n                } else {\n                    this.logger.info(LOG_DOCUMENT_UPDATED, \"Updated document [{}]\",\n                        document.getDocumentReferenceWithLocale());\n                }\n            }\n        } catch (Exception e) {\n            throw new WikiStreamException(\"Failed to save document\", e);\n        }\n    }","id":79900,"modified_method":"@Override\n    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        XWikiDocument inputDocument = this.documentListener.getDocument();\n\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        try {\n            XWikiDocument document =\n                xcontext.getWiki().getDocument(inputDocument.getDocumentReferenceWithLocale(), xcontext);\n\n            boolean isNew = document.isNew();\n\n            if (document.isNew()) {\n                document = inputDocument;\n            } else {\n                if (this.properties.isPreviousDeleted() && !this.documentDeleted) {\n                    xcontext.getWiki().deleteDocument(document, xcontext);\n                    this.documentDeleted = true;\n                    document = inputDocument;\n                } else {\n                    document.loadAttachmentsContent(xcontext);\n                    document.apply(inputDocument);\n                }\n            }\n\n            document.setMinorEdit(inputDocument.isMinorEdit());\n\n            // Author\n\n            if (this.properties.isAuthorPreserved()\n                && parameters.containsKey(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR)) {\n                document.setAuthorReference(inputDocument.getAuthorReference());\n            } else {\n                document.setAuthorReference(xcontext.getUserReference());\n            }\n\n            // Content author\n\n            if (this.properties.isAuthorPreserved()\n                && parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR)) {\n                document.setContentAuthorReference(inputDocument.getContentAuthorReference());\n            } else {\n                document.setContentAuthorReference(document.getAuthorReference());\n            }\n\n            // Creator\n\n            if (document.isNew() && !this.properties.isAuthorPreserved()\n                || !this.currentLocaleParameters.containsKey(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR)) {\n                document.setCreatorReference(xcontext.getUserReference());\n            }\n\n            // Save history\n            if (document.isNew() && document.getDocumentArchive() != null) {\n                // we need to force the saving the document archive\n                if (document.getDocumentArchive() != null) {\n                    xcontext.getWiki().getVersioningStore()\n                        .saveXWikiDocArchive(document.getDocumentArchive(xcontext), true, xcontext);\n                }\n            }\n\n            // Don't preserve version or history if we don't delete the previous document\n            if (document.isNew() && (this.properties.isAuthorPreserved() || this.properties.isVersionPreserved())) {\n                // Make sure version is set\n                document.setVersion(document.getVersion());\n\n                document.setMetaDataDirty(false);\n                document.setContentDirty(false);\n\n                xcontext.getWiki().saveDocument(document, document.getComment(), document.isMinorEdit(), xcontext);\n            } else {\n                xcontext.getWiki().saveDocument(document, this.properties.getSaveComment(), xcontext);\n            }\n\n            if (this.properties.isVerbose()) {\n                if (isNew) {\n                    this.logger.info(LOG_DOCUMENT_CREATED, \"Created document [{}]\",\n                        document.getDocumentReferenceWithLocale());\n                } else {\n                    this.logger.info(LOG_DOCUMENT_UPDATED, \"Updated document [{}]\",\n                        document.getDocumentReferenceWithLocale());\n                }\n            }\n        } catch (Exception e) {\n            throw new WikiStreamException(\"Failed to save document\", e);\n        }\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.document =\n            new XWikiDocument(this.entityResolver.resolve(this.currentEntityReference, this.properties != null\n                ? this.properties.getDefaultReference() : null));\n\n        this.document.setCreationDate(getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, this.currentLocaleParameters,\n            null));\n        this.document.setCreator(getString(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR, this.currentLocaleParameters,\n            null));\n        this.document.setDefaultLocale(this.currentDefaultLocale);\n\n        this.document.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));\n\n        this.document.setLocale(this.currentLocale);\n\n        this.document.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));\n        this.document.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));\n        this.document.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));\n        this.document.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));\n        this.document.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));\n        this.document.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));\n\n        this.document.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n        this.document.setAuthor(getString(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR, parameters, null));\n        this.document.setContentAuthor(getString(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, null));\n\n        String revisions =\n            getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, this.currentLocaleParameters, null);\n        if (revisions != null) {\n            try {\n                this.document.setDocumentArchive(revisions);\n            } catch (XWikiException e) {\n                throw new WikiStreamException(\"Failed to set document archive\", e);\n            }\n        }\n\n        if (version != null && this.properties.isVersionPreserved()) {\n            if (VALID_VERSION.matcher(version).matches()) {\n                this.document.setVersion(version);\n            } else if (NumberUtils.isDigits(version)) {\n                this.document.setVersion(version + \".1\");\n            } else {\n                // TODO: log something, probably a warning\n            }\n        }\n\n        this.document.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n        this.document.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n        this.document.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n        // Content\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {\n            this.document.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));\n        } else {\n            if (this.properties != null && this.properties.getDefaultSyntax() != null) {\n                this.document.setSyntax(this.properties.getDefaultSyntax());\n            } else {\n                // Make sure to set the default syntax if none were provided\n                this.document.setSyntax(this.document.getSyntax());\n            }\n\n            ComponentManager componentManager = this.componentManagerProvider.get();\n\n            if (componentManager.hasComponent(PrintRendererFactory.class, this.document.getSyntax().toIdString())) {\n                PrintRendererFactory rendererFactory;\n                try {\n                    rendererFactory =\n                        componentManager\n                            .getInstance(PrintRendererFactory.class, this.document.getSyntax().toIdString());\n                } catch (ComponentLookupException e) {\n                    throw new WikiStreamException(String.format(\"Failed to find PrintRendererFactory for syntax [%s]\",\n                        this.document.getSyntax()), e);\n                }\n\n                this.currentWikiPrinter = new DefaultWikiPrinter();\n                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));\n            }\n        }\n    }","id":79901,"modified_method":"@Override\n    public void beginWikiDocumentRevision(String version, FilterEventParameters parameters) throws WikiStreamException\n    {\n        this.document =\n            new XWikiDocument(this.entityResolver.resolve(this.currentEntityReference, this.properties != null\n                ? this.properties.getDefaultReference() : null));\n\n        this.document.setCreationDate(getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, this.currentLocaleParameters,\n            null));\n        if (this.currentLocaleParameters.containsKey(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR)) {\n            this.document.setCreator(getString(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR,\n                this.currentLocaleParameters, null));\n        }\n        this.document.setDefaultLocale(this.currentDefaultLocale);\n\n        this.document.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));\n\n        this.document.setLocale(this.currentLocale);\n\n        this.document.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));\n        this.document.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));\n        this.document.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));\n        this.document.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));\n        this.document.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));\n        this.document.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));\n\n        this.document.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR)) {\n            this.document.setAuthor(getString(WikiDocumentFilter.PARAMETER_REVISION_AUTHOR, parameters, null));\n        }\n        this.document.setContentAuthor(getString(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, null));\n\n        String revisions =\n            getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, this.currentLocaleParameters, null);\n        if (revisions != null) {\n            try {\n                this.document.setDocumentArchive(revisions);\n            } catch (XWikiException e) {\n                throw new WikiStreamException(\"Failed to set document archive\", e);\n            }\n        }\n\n        if (version != null && this.properties.isVersionPreserved()) {\n            if (VALID_VERSION.matcher(version).matches()) {\n                this.document.setVersion(version);\n            } else if (NumberUtils.isDigits(version)) {\n                this.document.setVersion(version + \".1\");\n            } else {\n                // TODO: log something, probably a warning\n            }\n        }\n\n        this.document.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));\n        this.document.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, \"\"));\n\n        this.document.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));\n\n        // Content\n\n        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {\n            this.document.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));\n        } else {\n            if (this.properties != null && this.properties.getDefaultSyntax() != null) {\n                this.document.setSyntax(this.properties.getDefaultSyntax());\n            } else {\n                // Make sure to set the default syntax if none were provided\n                this.document.setSyntax(this.document.getSyntax());\n            }\n\n            ComponentManager componentManager = this.componentManagerProvider.get();\n\n            if (componentManager.hasComponent(PrintRendererFactory.class, this.document.getSyntax().toIdString())) {\n                PrintRendererFactory rendererFactory;\n                try {\n                    rendererFactory =\n                        componentManager\n                            .getInstance(PrintRendererFactory.class, this.document.getSyntax().toIdString());\n                } catch (ComponentLookupException e) {\n                    throw new WikiStreamException(String.format(\"Failed to find PrintRendererFactory for syntax [%s]\",\n                        this.document.getSyntax()), e);\n                }\n\n                this.currentWikiPrinter = new DefaultWikiPrinter();\n                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));\n            }\n        }\n    }","commit_id":"3584c2079e3e58635c8e5b6be05f74ee3e138d16","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean orderingByUniqueColumns() {\n        if (m_orderingByUniqueColumns) {\n            return true;\n        }\n\n        // assume order by has one child node\n        assert(m_children.size() == 1);\n\n        AbstractPlanNode child = m_children.get(0);\n        // skip plans that are joins or have fanciness\n        if ((child instanceof AbstractScanPlanNode) == false) {\n            return false;\n        }\n\n        AbstractScanPlanNode scanNode = (AbstractScanPlanNode) child;\n\n        String tableName = scanNode.getTargetTableName();\n\n\n\n        // find all tables underneath\n        for (AbstractExpression e : m_sortExpressions) {\n            if (e instanceof TupleValueExpression) {\n\n            }\n        }\n\n        // for each table\n            // for each index\n                // find all expressions\n\n        return false;\n\n\n    }","id":79902,"modified_method":"private boolean orderingByUniqueColumns() {\n        return m_orderingByUniqueColumns;\n    }","commit_id":"aea41f9a9dbbe47cb7746b06081504a8b1c52a18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n        orderByNode.addAndLinkChild(root);\n        orderByNode.generateOutputSchema(m_catalogDb);\n\n        // The method for determining that the ordering is on a unique value or unique combination of values is a little weak, here.\n        // In theory, for a single-table query, there just needs to exist a uniqueness constraint (primary key or other unique index)\n        // on some of the ORDER BY values regardless of whether the associated index is used in the selected plan.\n        // For now, we only recognize such an index if it is currently used in the plan.\n        // Strictly speaking, if it was used at the top of the plan, this function would have already returned without adding an orderByNode.\n        // The interesting case here, addressing issue ENG-3335, is when the index scan is in the distributed part of the plan.\n        // Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        if (m_parsedSelect.tableList.size() == 1) {\n            List<AbstractPlanNode> indexScans = root.findAllNodesOfType(PlanNodeType.INDEXSCAN);\n            if (indexScans.size() == 1) {\n                IndexScanPlanNode ixnode = (IndexScanPlanNode) (indexScans.get(0));\n                // The index must be associated with the expected ordering.\n                if (ixnode.getSortDirection() != SortDirectionType.INVALID) {\n                    Index index = ixnode.getCatalogIndex();\n                    // Index must guarantee uniqueness\n                    if (index.getUnique()) {\n                        orderByNode.setOrderingByUniqueColumns();\n                    }\n                }\n            }\n        }\n        return orderByNode;\n    }","id":79903,"modified_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n        orderByNode.addAndLinkChild(root);\n        orderByNode.generateOutputSchema(m_catalogDb);\n\n        // In theory, for a single-table query, there just needs to exist a uniqueness constraint (primary key or other unique index)\n        // on some of the ORDER BY values regardless of whether the associated index is used in the selected plan.\n        // Strictly speaking, if it was used at the top of the plan, this function would have already returned without adding an orderByNode.\n        // The interesting case here, addressing issue ENG-3335, is when the index scan is in the distributed part of the plan.\n        // Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        if (m_parsedSelect.tableList.size() == 1) {\n\n            Table table = m_parsedSelect.tableList.get(0);\n\n            // get all of the columns in the sort\n            ArrayList<String> orderColNames = new ArrayList<String>();\n            for (AbstractExpression e : orderByNode.getSortExpressions()) {\n                if (e instanceof TupleValueExpression) {\n                    TupleValueExpression tve = (TupleValueExpression) e;\n                    orderColNames.add(tve.getColumnName());\n                }\n            }\n\n            // search indexes for one that makes the order by deterministic\n            for (Index index : table.getIndexes()) {\n                // skip unique indexes\n                if (!index.getUnique()) {\n                    continue;\n                }\n\n                // get the list of columns in this unique index\n                ArrayList<String> indexColNames = new ArrayList<String>();\n                for (ColumnRef cref : index.getColumns()) {\n                    indexColNames.add(cref.getColumn().getTypeName());\n                }\n\n                // if the sort covers the index, then it's a unique sort\n                if (orderColNames.containsAll(indexColNames)) {\n                    orderByNode.setOrderingByUniqueColumns();\n                }\n            }\n        }\n        return orderByNode;\n    }","commit_id":"aea41f9a9dbbe47cb7746b06081504a8b1c52a18","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private boolean orderingByUniqueColumns() {\n        if (m_orderingByUniqueColumns) {\n            return true;\n        }\n\n        // assume order by has one child node\n        assert(m_children.size() == 1);\n\n        AbstractPlanNode child = m_children.get(0);\n        // skip plans that are joins or have fanciness\n        if ((child instanceof AbstractScanPlanNode) == false) {\n            return false;\n        }\n\n        AbstractScanPlanNode scanNode = (AbstractScanPlanNode) child;\n\n        String tableName = scanNode.getTargetTableName();\n\n\n\n        // find all tables underneath\n        for (AbstractExpression e : m_sortExpressions) {\n            if (e instanceof TupleValueExpression) {\n\n            }\n        }\n\n        // for each table\n            // for each index\n                // find all expressions\n\n        return false;\n\n\n    }","id":79904,"modified_method":"private boolean orderingByUniqueColumns() {\n        return m_orderingByUniqueColumns;\n    }","commit_id":"41ce2f6b059f58722c5dd4dd3f24570aebd9b325","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n        orderByNode.addAndLinkChild(root);\n        orderByNode.generateOutputSchema(m_catalogDb);\n\n        // The method for determining that the ordering is on a unique value or unique combination of values is a little weak, here.\n        // In theory, for a single-table query, there just needs to exist a uniqueness constraint (primary key or other unique index)\n        // on some of the ORDER BY values regardless of whether the associated index is used in the selected plan.\n        // For now, we only recognize such an index if it is currently used in the plan.\n        // Strictly speaking, if it was used at the top of the plan, this function would have already returned without adding an orderByNode.\n        // The interesting case here, addressing issue ENG-3335, is when the index scan is in the distributed part of the plan.\n        // Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        if (m_parsedSelect.tableList.size() == 1) {\n            List<AbstractPlanNode> indexScans = root.findAllNodesOfType(PlanNodeType.INDEXSCAN);\n            if (indexScans.size() == 1) {\n                IndexScanPlanNode ixnode = (IndexScanPlanNode) (indexScans.get(0));\n                // The index must be associated with the expected ordering.\n                if (ixnode.getSortDirection() != SortDirectionType.INVALID) {\n                    Index index = ixnode.getCatalogIndex();\n                    // Index must guarantee uniqueness\n                    if (index.getUnique()) {\n                        orderByNode.setOrderingByUniqueColumns();\n                    }\n                }\n            }\n        }\n        return orderByNode;\n    }","id":79905,"modified_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n        orderByNode.addAndLinkChild(root);\n        orderByNode.generateOutputSchema(m_catalogDb);\n\n        // In theory, for a single-table query, there just needs to exist a uniqueness constraint (primary key or other unique index)\n        // on some of the ORDER BY values regardless of whether the associated index is used in the selected plan.\n        // Strictly speaking, if it was used at the top of the plan, this function would have already returned without adding an orderByNode.\n        // The interesting case here, addressing issue ENG-3335, is when the index scan is in the distributed part of the plan.\n        // Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        if (m_parsedSelect.tableList.size() == 1) {\n\n            Table table = m_parsedSelect.tableList.get(0);\n\n            // get all of the columns in the sort\n            ArrayList<String> orderColNames = new ArrayList<String>();\n            for (AbstractExpression e : orderByNode.getSortExpressions()) {\n                if (e instanceof TupleValueExpression) {\n                    TupleValueExpression tve = (TupleValueExpression) e;\n                    orderColNames.add(tve.getColumnName());\n                }\n            }\n\n            // search indexes for one that makes the order by deterministic\n            for (Index index : table.getIndexes()) {\n                // skip unique indexes\n                if (!index.getUnique()) {\n                    continue;\n                }\n\n                // get the list of columns in this unique index\n                ArrayList<String> indexColNames = new ArrayList<String>();\n                for (ColumnRef cref : index.getColumns()) {\n                    indexColNames.add(cref.getColumn().getTypeName());\n                }\n\n                // if the sort covers the index, then it's a unique sort\n                if (orderColNames.containsAll(indexColNames)) {\n                    orderByNode.setOrderingByUniqueColumns();\n                }\n            }\n        }\n        return orderByNode;\n    }","commit_id":"41ce2f6b059f58722c5dd4dd3f24570aebd9b325","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Constructor, creates a new instance.<p>\n     * \n     * @param wp the workplace object\n     * @param query the search query \n     * @param sort the sort by parameter\n     * @param fields the comma separated list of fields to search\n     * @param searchRoots a list of search roots\n     * @param minCreationDate the minimum creation date of the resources to be searched\n     * @param maxCreationDate the maximum creation date of the resources to be searched\n     * @param minLastModificationDate the minimum creation date of the resources to be searched\n     * @param maxLastModificationDate the maximum creation date of the resources to be searched\n     */\n    public CmsSearchResourcesCollector(\n        A_CmsListExplorerDialog wp,\n        String query,\n        String sort,\n        String fields,\n        List searchRoots,\n        String minCreationDate,\n        String maxCreationDate,\n        String minLastModificationDate,\n        String maxLastModificationDate) {\n\n        super(wp);\n        m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n            + PARAM_QUERY\n            + I_CmsListResourceCollector.SEP_KEYVAL\n            + query;\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(sort)) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_SORT\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + sort;\n        }\n        m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n            + PARAM_FIELDS\n            + I_CmsListResourceCollector.SEP_KEYVAL\n            + fields;\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(minCreationDate)) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MINCREATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + minCreationDate;\n        }\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxCreationDate)) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MAXCREATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + maxCreationDate;\n        }\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(minLastModificationDate)) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MINLASTMODIFICATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + minLastModificationDate;\n        }\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxLastModificationDate)) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MAXLASTMODIFICATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + maxLastModificationDate;\n        }\n\n        setResourcesParam(searchRoots);\n    }","id":79906,"modified_method":"/**\n     * Constructor, creates a new instance.<p>\n     * \n     * @param wp the workplace object\n     * @param query the search query \n     * @param sort the sort by parameter\n     * @param fields the comma separated list of fields to search\n     * @param searchRoots a list of search roots\n     * @param minCreationDate the minimum creation date of the resources to be searched\n     * @param maxCreationDate the maximum creation date of the resources to be searched\n     * @param minLastModificationDate the minimum creation date of the resources to be searched\n     * @param maxLastModificationDate the maximum creation date of the resources to be searched\n     */\n    public CmsSearchResourcesCollector(\n        A_CmsListExplorerDialog wp,\n        String query,\n        String sort,\n        String fields,\n        List searchRoots,\n        String minCreationDate,\n        String maxCreationDate,\n        String minLastModificationDate,\n        String maxLastModificationDate) {\n\n        super(wp);\n        m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n            + PARAM_QUERY\n            + I_CmsListResourceCollector.SEP_KEYVAL\n            + query;\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(sort)) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_SORT\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + sort;\n        }\n        m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n            + PARAM_FIELDS\n            + I_CmsListResourceCollector.SEP_KEYVAL\n            + fields;\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(minCreationDate)) && (!minCreationDate.equals(\"0\"))) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MINCREATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + minCreationDate;\n        }\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxCreationDate)) && (!maxCreationDate.equals(\"0\"))) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MAXCREATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + maxCreationDate;\n        }\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(minLastModificationDate))\n            && (!minLastModificationDate.equals(\"0\"))) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MINLASTMODIFICATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + minLastModificationDate;\n        }\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxLastModificationDate))\n            && (!maxLastModificationDate.equals(\"0\"))) {\n            m_collectorParameter += I_CmsListResourceCollector.SEP_PARAM\n                + PARAM_MAXLASTMODIFICATIONDATE\n                + I_CmsListResourceCollector.SEP_KEYVAL\n                + maxLastModificationDate;\n        }\n\n        setResourcesParam(searchRoots);\n    }","commit_id":"b148893d9cd8df200cb125bc5e793a109cbf7086","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the last modification date the resources have to have as maximum.<p>\n     *\n     * @param maxDateLastModified the last modification date the resources have to have as maximum to set\n     */\n    public void setMaxDateLastModified(String maxDateLastModified) {\n\n        m_searchParams.setMaxDateLastModified(Long.parseLong(maxDateLastModified));\n    }","id":79907,"modified_method":"/**\n     * Sets the last modification date the resources have to have as maximum.<p>\n     *\n     * @param maxDateLastModified the last modification date the resources have to have as maximum to set\n     */\n    public void setMaxDateLastModified(String maxDateLastModified) {\n\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxDateLastModified)) && (!maxDateLastModified.equals(\"0\"))) {\n            m_searchParams.setMaxDateLastModified(Long.parseLong(maxDateLastModified));\n        } else {\n            m_searchParams.setMaxDateLastModified(Long.MAX_VALUE);\n        }\n    }","commit_id":"b148893d9cd8df200cb125bc5e793a109cbf7086","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the last modification date the resources have to have as minimum.<p>\n     *\n     * @param minDateLastModified the last modification date the resources have to have as minimum to set\n     */\n    public void setMinDateLastModified(String minDateLastModified) {\n\n        m_searchParams.setMinDateLastModified(Long.parseLong(minDateLastModified));\n    }","id":79908,"modified_method":"/**\n     * Sets the last modification date the resources have to have as minimum.<p>\n     *\n     * @param minDateLastModified the last modification date the resources have to have as minimum to set\n     */\n    public void setMinDateLastModified(String minDateLastModified) {\n\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(minDateLastModified)) && (!minDateLastModified.equals(\"0\"))) {\n            m_searchParams.setMinDateLastModified(Long.parseLong(minDateLastModified));\n        } else {\n            m_searchParams.setMinDateLastModified(Long.MIN_VALUE);\n        }\n    }","commit_id":"b148893d9cd8df200cb125bc5e793a109cbf7086","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the creation date the resources have to have as minimum.<p>\n     *\n     * @param minCreationDate the creation date the resources have to have as minimum to set\n     */\n    public void setMinDateCreated(String minCreationDate) {\n\n        m_searchParams.setMinDateCreated(Long.parseLong(minCreationDate));\n    }","id":79909,"modified_method":"/**\n     * Sets the creation date the resources have to have as minimum.<p>\n     *\n     * @param minCreationDate the creation date the resources have to have as minimum to set\n     */\n    public void setMinDateCreated(String minCreationDate) {\n\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(minCreationDate)) && (!minCreationDate.equals(\"0\"))) {\n            m_searchParams.setMinDateCreated(Long.parseLong(minCreationDate));\n        } else {\n            m_searchParams.setMinDateCreated(Long.MIN_VALUE);\n        }\n    }","commit_id":"b148893d9cd8df200cb125bc5e793a109cbf7086","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the creation date the resources have to have as maximum.<p>\n     *\n     * @param maxCreationDate the creation date the resources have to have as maximum to set\n     */\n    public void setMaxDateCreated(String maxCreationDate) {\n\n        m_searchParams.setMaxDateCreated(Long.parseLong(maxCreationDate));\n    }","id":79910,"modified_method":"/**\n     * Sets the creation date the resources have to have as maximum.<p>\n     *\n     * @param maxCreationDate the creation date the resources have to have as maximum to set\n     */\n    public void setMaxDateCreated(String maxCreationDate) {\n\n        if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(maxCreationDate)) && (!maxCreationDate.equals(\"0\"))) {\n            m_searchParams.setMaxDateCreated(Long.parseLong(maxCreationDate));\n        } else {\n            m_searchParams.setMaxDateCreated(Long.MAX_VALUE);\n        }\n    }","commit_id":"b148893d9cd8df200cb125bc5e793a109cbf7086","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method, Set<Method> lockedMethodSet)\n\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tInnerClassAccessMap icam = InnerClassAccessMap.instance();\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tLockDataflow lockDataflow = classContext.getLockDataflow(method);\n\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\tboolean isGetterMethod = isGetterMethod(classContext, method);\n\n\t\tif (DEBUG) System.out.println(\"**** Analyzing method \" +\n\t\t\tSignatureConverter.convertMethodSignature(classContext.getMethodGen(method)));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\ttry {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\t\tXField xfield = null;\n\t\t\t\tboolean isWrite = false;\n\t\t\t\tboolean isLocal = false;\n\n\t\t\t\tif (ins instanceof FieldInstruction) {\n\t\t\t\t\tFieldInstruction fins = (FieldInstruction) ins;\n\t\t\t\t\txfield = Hierarchy.findXField(fins, cpg);\n\t\t\t\t\tisWrite = ins.getOpcode() == Constants.PUTFIELD;\n\t\t\t\t\tisLocal = fins.getClassName(cpg).equals(classContext.getJavaClass().getClassName());\n\t\t\t\t\tif (DEBUG) System.out.println(\"Handling field access: \" + location.getHandle() +\n\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t} else if (ins instanceof INVOKESTATIC) {\n\t\t\t\t\tINVOKESTATIC inv = (INVOKESTATIC) ins;\n\t\t\t\t\tInnerClassAccess access = icam.getInnerClassAccess(inv, cpg);\n\t\t\t\t\tif (access != null && access.getMethodSignature().equals(inv.getSignature(cpg))) {\n\t\t\t\t\t\txfield = access.getField();\n\t\t\t\t\t\tisWrite = !access.isLoad();\n\t\t\t\t\t\tisLocal = false;\n\t\t\t\t\t\tif (DEBUG) System.out.println(\"Handling inner class access: \" + location.getHandle() +\n\t\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfield == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We only care about mutable nonvolatile nonpublic instance fields.\n\t\t\t\tif (xfield.isStatic() || xfield.isPublic() || xfield.isVolatile() || xfield.isFinal())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The value number frame could be invalid if the basic\n\t\t\t\t// block became unreachable due to edge pruning (dead code).\n\t\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get lock set and instance value\n\t\t\t\tValueNumber thisValue = !method.isStatic() ? vnaDataflow.getAnalysis().getThisValue() : null;\n\t\t\t\tLockSet lockSet = lockDataflow.getFactAtLocation(location);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tValueNumber instance = frame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\n\t\t\t\t// Is the instance locked?\n\t\t\t\t// We consider the access to be locked if either\n\t\t\t\t//   - the object is explicitly locked, or\n\t\t\t\t//   - the field is accessed through the \"this\" reference,\n\t\t\t\t//     and the method is in the locked method set, or\n\t\t\t\t//   - any value returned by a called method is locked;\n\t\t\t\t//     the (conservative) assumption is that the return lock object\n\t\t\t\t//     is correct for synchronizing the access\n\t\t\t\tboolean isExplicitlyLocked = lockSet.getLockCount(instance.getNumber()) > 0;\n\t\t\t\tboolean isAccessedThroughThis = thisValue != null && thisValue.equals(instance);\n\t\t\t\tboolean isLocked = isExplicitlyLocked\n\t\t\t\t\t|| (lockedMethodSet.contains(method) && isAccessedThroughThis)\n\t\t\t\t\t|| lockSet.containsReturnValue(vnaDataflow.getAnalysis().getFactory());\n\n\t\t\t\t// Adjust the field so its class name is the same\n\t\t\t\t// as the type of reference it is accessed through.\n\t\t\t\t// This helps fix false positives produced when a\n\t\t\t\t// threadsafe class is extended by a subclass that\n\t\t\t\t// doesn't care about thread safety.\n\t\t\t\tif (ADJUST_SUBCLASS_ACCESSES) {\n\t\t\t\t\t// Find the type of the object instance\n\t\t\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\tType instanceType = typeFrame.getInstance(handle.getInstruction(), cpg);\n\n\t\t\t\t\t// Note: instance type can be Null,\n\t\t\t\t\t// in which case we won't adjust the field type.\n\t\t\t\t\tif (instanceType != TypeFrame.getNullType()) {\n\t\t\t\t\t\tif (!(instanceType instanceof ObjectType)) {\n\t\t\t\t\t\t\tthrow new AnalysisException(\"Field accessed through non-object reference \" + instanceType,\n\t\t\t\t\t\t\t\tmethodGen, handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectType objType = (ObjectType) instanceType;\n\n\t\t\t\t\t\t// If instance class name is not the same as that of the field,\n\t\t\t\t\t\t// make it so\n\t\t\t\t\t\tString instanceClassName = objType.getClassName();\n\t\t\t\t\t\tif (!instanceClassName.equals(xfield.getClassName())) {\n\t\t\t\t\t\t\txfield = new InstanceField(\n\t\t\t\t\t\t\t\tinstanceClassName,\n\t\t\t\t\t\t\t\txfield.getFieldName(),\n\t\t\t\t\t\t\t\txfield.getFieldSignature(),\n\t\t\t\t\t\t\t\txfield.getAccessFlags()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tint kind = 0;\n\t\t\t\tkind |= isLocked ? LOCKED : UNLOCKED;\n\t\t\t\tkind |= isWrite ? WRITE : READ;\n\t\t\t\n\t\t\t\tif (DEBUG) System.out.println(\"IS2:\\t\" +\n\t\t\t\t\tSignatureConverter.convertMethodSignature(classContext.getMethodGen(method)) +\n\t\t\t\t\t\"\\t\" + xfield + \"\\t\" + ((isWrite ? \"W\" : \"R\") + \"/\" + (isLocked ? \"L\" : \"U\")));\n\t\t\t\n\t\t\t\tFieldStats stats = getStats(xfield);\n\t\t\t\tstats.addAccess(kind);\n\t\t\t\n\t\t\t\tif (isExplicitlyLocked && isLocal)\n\t\t\t\t\tstats.addLocalLock();\n\n\t\t\t\tif (isGetterMethod && !isLocked)\n\t\t\t\t\tstats.addGetterMethodAccess();\n\t\t\t\n\t\t\t\tstats.addAccess(classContext, method, handle, isLocked);\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","id":79911,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method, Set<Method> lockedMethodSet)\n\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tInnerClassAccessMap icam = InnerClassAccessMap.instance();\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tLockDataflow lockDataflow = classContext.getLockDataflow(method);\n\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\tboolean isGetterMethod = isGetterMethod(classContext, method);\n\n\t\tif (DEBUG) System.out.println(\"**** Analyzing method \" +\n\t\t\tSignatureConverter.convertMethodSignature(classContext.getMethodGen(method)));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\ttry {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\t\tXField xfield = null;\n\t\t\t\tboolean isWrite = false;\n\t\t\t\tboolean isLocal = false;\n\n\t\t\t\tif (ins instanceof FieldInstruction) {\n\t\t\t\t\tFieldInstruction fins = (FieldInstruction) ins;\n\t\t\t\t\txfield = Hierarchy.findXField(fins, cpg);\n\t\t\t\t\tisWrite = ins.getOpcode() == Constants.PUTFIELD;\n\t\t\t\t\tisLocal = fins.getClassName(cpg).equals(classContext.getJavaClass().getClassName());\n\t\t\t\t\tif (DEBUG) System.out.println(\"Handling field access: \" + location.getHandle() +\n\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t} else if (ins instanceof INVOKESTATIC) {\n\t\t\t\t\tINVOKESTATIC inv = (INVOKESTATIC) ins;\n\t\t\t\t\tInnerClassAccess access = icam.getInnerClassAccess(inv, cpg);\n\t\t\t\t\tif (access != null && access.getMethodSignature().equals(inv.getSignature(cpg))) {\n\t\t\t\t\t\txfield = access.getField();\n\t\t\t\t\t\tisWrite = !access.isLoad();\n\t\t\t\t\t\tisLocal = false;\n\t\t\t\t\t\tif (DEBUG) System.out.println(\"Handling inner class access: \" + location.getHandle() +\n\t\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfield == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We only care about mutable nonvolatile nonpublic instance fields.\n\t\t\t\tif (xfield.isStatic() || xfield.isPublic() || xfield.isVolatile() || xfield.isFinal())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The value number frame could be invalid if the basic\n\t\t\t\t// block became unreachable due to edge pruning (dead code).\n\t\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get lock set and instance value\n\t\t\t\tValueNumber thisValue = !method.isStatic() ? vnaDataflow.getAnalysis().getThisValue() : null;\n\t\t\t\tLockSet lockSet = lockDataflow.getFactAtLocation(location);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tValueNumber instance = frame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\n\t\t\t\t// Is the instance locked?\n\t\t\t\t// We consider the access to be locked if either\n\t\t\t\t//   - the object is explicitly locked, or\n\t\t\t\t//   - the field is accessed through the \"this\" reference,\n\t\t\t\t//     and the method is in the locked method set, or\n\t\t\t\t//   - any value returned by a called method is locked;\n\t\t\t\t//     the (conservative) assumption is that the return lock object\n\t\t\t\t//     is correct for synchronizing the access\n\t\t\t\tboolean isExplicitlyLocked = lockSet.getLockCount(instance.getNumber()) > 0;\n\t\t\t\tboolean isAccessedThroughThis = thisValue != null && thisValue.equals(instance);\n\t\t\t\tboolean isLocked = isExplicitlyLocked\n\t\t\t\t\t|| (lockedMethodSet.contains(method) && isAccessedThroughThis)\n\t\t\t\t\t|| lockSet.containsReturnValue(vnaDataflow.getAnalysis().getFactory());\n\n\t\t\t\t// Adjust the field so its class name is the same\n\t\t\t\t// as the type of reference it is accessed through.\n\t\t\t\t// This helps fix false positives produced when a\n\t\t\t\t// threadsafe class is extended by a subclass that\n\t\t\t\t// doesn't care about thread safety.\n\t\t\t\tif (ADJUST_SUBCLASS_ACCESSES) {\n\t\t\t\t\t// Find the type of the object instance\n\t\t\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\tType instanceType = typeFrame.getInstance(handle.getInstruction(), cpg);\n\n\t\t\t\t\t// Note: instance type can be Null,\n\t\t\t\t\t// in which case we won't adjust the field type.\n\t\t\t\t\tif (instanceType != TypeFrame.getNullType()) {\n\t\t\t\t\t\tif (!(instanceType instanceof ObjectType)) {\n\t\t\t\t\t\t\tthrow new AnalysisException(\"Field accessed through non-object reference \" + instanceType,\n\t\t\t\t\t\t\t\tmethodGen, handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectType objType = (ObjectType) instanceType;\n\n\t\t\t\t\t\t// If instance class name is not the same as that of the field,\n\t\t\t\t\t\t// make it so\n\t\t\t\t\t\tString instanceClassName = objType.getClassName();\n\t\t\t\t\t\tif (!instanceClassName.equals(xfield.getClassName())) {\n\t\t\t\t\t\t\txfield = new InstanceField(\n\t\t\t\t\t\t\t\tinstanceClassName,\n\t\t\t\t\t\t\t\txfield.getFieldName(),\n\t\t\t\t\t\t\t\txfield.getFieldSignature(),\n\t\t\t\t\t\t\t\txfield.getAccessFlags()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tint kind = 0;\n\t\t\t\tkind |= isLocked ? LOCKED : UNLOCKED;\n\t\t\t\tkind |= isWrite ? WRITE : READ;\n\t\t\t\n\t\t\t\tif (isLocked ||  !isConstructor(method.getName())) {\n\t\t\t\tif (DEBUG) System.out.println(\"IS2:\\t\" +\n\t\t\t\t\tSignatureConverter.convertMethodSignature(classContext.getMethodGen(method)) +\n\t\t\t\t\t\"\\t\" + xfield + \"\\t\" + ((isWrite ? \"W\" : \"R\") + \"/\" + (isLocked ? \"L\" : \"U\")));\n\t\t\t\n\t\t\t\tFieldStats stats = getStats(xfield);\n\t\t\t\tstats.addAccess(kind);\n\t\t\t\n\t\t\t\tif (isExplicitlyLocked && isLocal)\n\t\t\t\t\tstats.addLocalLock();\n\n\t\t\t\tif (isGetterMethod && !isLocked)\n\t\t\t\t\tstats.addGetterMethodAccess();\n\t\t\t\n\t\t\t\tstats.addAccess(classContext, method, handle, isLocked);\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a7c64877ad967689665cc5c07ed33d4c9469472c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\ttry {\n\t\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t\t// Build self-call graph\n\t\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t\tpublic boolean wantCallsFor(Method method) {\n\t\t\t\t\treturn !method.isPublic();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG) System.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\n\t\t\tSet<Method> lockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\n\t\t\tSet<Method> publicReachableMethods \n\t\t\t\t= findPublicReachableMethods(classContext, selfCalls);\n\n\t\t\tIterator<Method> i = publicReachableMethods.iterator();\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tMethod method = i.next();\n\t\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (isConstructor(method.getName()))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\t\tcontinue;\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t}\n\n\t\t} catch (CFGBuilderException e) {\n\t\t\tthrow new AnalysisException(\"FindInconsistentSync2 caught exception: \" + e.toString(), e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\t//e.printStackTrace();\n\t\t\tthrow new AnalysisException(\"FindInconsistentSync2 caught exception: \" + e.toString(), e);\n\t\t}\n\t}","id":79912,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\ttry {\n\t\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t\t// Build self-call graph\n\t\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t\tpublic boolean wantCallsFor(Method method) {\n\t\t\t\t\treturn !method.isPublic();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG) System.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\n\t\t\tSet<Method> lockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\n\t\t\tSet<Method> publicReachableMethods \n\t\t\t\t= findPublicReachableMethods(classContext, selfCalls);\n\n\t\t\tIterator<Method> i = publicReachableMethods.iterator();\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tMethod method = i.next();\n\t\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\tif (isConstructor(method.getName()))\n\t\t\t\t\tcontinue;\n\t\t\t\t*/\n\t\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\t\tcontinue;\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t}\n\n\t\t} catch (CFGBuilderException e) {\n\t\t\tthrow new AnalysisException(\"FindInconsistentSync2 caught exception: \" + e.toString(), e);\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\t//e.printStackTrace();\n\t\t\tthrow new AnalysisException(\"FindInconsistentSync2 caught exception: \" + e.toString(), e);\n\t\t}\n\t}","commit_id":"a7c64877ad967689665cc5c07ed33d4c9469472c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void report() {\n\t\tfor (Iterator<Map.Entry<XField, FieldStats>> i = statMap.entrySet().iterator(); i.hasNext(); ) {\n\t\t\tMap.Entry<XField, FieldStats> entry = i.next();\n\t\t\tXField xfield = entry.getKey();\n\t\t\tFieldStats stats = entry.getValue();\n\n\t\t\tint numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n\t\t\tint numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n\t\t\tint numReadLocked = stats.getNumAccesses(READ_LOCKED);\n\t\t\tint numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n\n\t\t\tint locked =  numReadLocked + numWriteLocked;\n\t\t\tint biasedLocked =  numReadLocked + (int)(WRITE_BIAS * numWriteLocked);\n\t\t\tint unlocked =  numReadUnlocked + numWriteUnlocked;\n\t\t\tint biasedUnlocked =  numReadUnlocked + (int)(WRITE_BIAS * numWriteUnlocked);\n\t\t\tint writes =  numWriteLocked + numWriteUnlocked;\n\n\t\t\tif (locked == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (unlocked == 0) \n\t\t\t\tcontinue;\n\n\t\t\tif (!EVAL && numReadUnlocked > 0 && ((int)(UNSYNC_FACTOR * biasedUnlocked)) > biasedLocked)\n\t\t\t\tcontinue;\n\n\t\t\t// NOTE: we ignore access to public, volatile, and final fields\n\n\t\t\tif (numWriteUnlocked + numWriteLocked == 0)\n\t\t\t\t// No writes outside of constructor\n\t\t\t\tcontinue;\n\n\t\t\tif (stats.getNumLocalLocks() == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint freq = (100 * locked) / (locked + unlocked);\n\t\t\tif (freq < MIN_SYNC_PERCENT) continue;\n\n\t\t\t// At this point, we report the field as being inconsistently synchronized\n\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\tif (stats.getNumGetterMethodAccesses() >= unlocked)\n\t\t\t\t// Unlocked accesses are only in getter method(s).\n\t\t\t\tpriority = LOW_PRIORITY;\n\t\t\tBugInstance bugInstance = new BugInstance(\"IS2_INCONSISTENT_SYNC\", priority)\n\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t.addField(xfield)\n\t\t\t\t.addInt(freq).describe(\"INT_SYNC_PERCENT\");\n\n\t\t\t// Add source lines for unsynchronized accesses\n\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext(); ) {\n\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n\t\t\t}\n\n\t\t\tif (SYNC_ACCESS) {\n\t\t\t\t// Add source line for synchronized accesses;\n\t\t\t\t// useful for figuring out what the detector is doing\n\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext(); ) {\n\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EVAL) {\n\t\t\t\tbugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n\t\t\t\tbugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n\t\t\t}\n\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t}\n\t}","id":79913,"modified_method":"public void report() {\n\t\tfor (Iterator<Map.Entry<XField, FieldStats>> i = statMap.entrySet().iterator(); i.hasNext(); ) {\n\t\t\tMap.Entry<XField, FieldStats> entry = i.next();\n\t\t\tXField xfield = entry.getKey();\n\t\t\tFieldStats stats = entry.getValue();\n\n\t\t\tint numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n\t\t\tint numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n\t\t\tint numReadLocked = stats.getNumAccesses(READ_LOCKED);\n\t\t\tint numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n\n\t\t\tint locked =  numReadLocked + numWriteLocked;\n\t\t\tint biasedLocked =  numReadLocked + (int)(WRITE_BIAS * numWriteLocked);\n\t\t\tint unlocked =  numReadUnlocked + numWriteUnlocked;\n\t\t\tint biasedUnlocked =  numReadUnlocked + (int)(WRITE_BIAS * numWriteUnlocked);\n\t\t\tint writes =  numWriteLocked + numWriteUnlocked;\n\n\t\t\tif (locked == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (unlocked == 0) \n\t\t\t\tcontinue;\n\n\t\t\t\n\n\t\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"IS2: \" + xfield);\n\t\t\tSystem.out.println(\"  RL: \" + numReadLocked);\n\t\t\tSystem.out.println(\"  WL: \" + numWriteLocked);\n\t\t\tSystem.out.println(\"  RU: \" + numReadUnlocked);\n\t\t\tSystem.out.println(\"  WU: \" + numWriteUnlocked);\n\t\t\t}\n\t\t\tif (!EVAL && numReadUnlocked > 0 && ((int)(UNSYNC_FACTOR * biasedUnlocked)) > biasedLocked)\n\t\t\t\tcontinue;\n\n\t\t\t// NOTE: we ignore access to public, volatile, and final fields\n\n\t\t\tif (numWriteUnlocked + numWriteLocked == 0)\n\t\t\t\t// No writes outside of constructor\n\t\t\t\tcontinue;\n\n\t\t\tif (numReadUnlocked + numReadLocked == 0)\n\t\t\t\t// No reads outside of constructor\n\t\t\t\tcontinue;\n\n\t\t\tif (stats.getNumLocalLocks() == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint freq = (100 * locked) / (locked + unlocked);\n\t\t\tif (freq < MIN_SYNC_PERCENT) continue;\n\n\t\t\t// At this point, we report the field as being inconsistently synchronized\n\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\tif (stats.getNumGetterMethodAccesses() >= unlocked)\n\t\t\t\t// Unlocked accesses are only in getter method(s).\n\t\t\t\tpriority = LOW_PRIORITY;\n\t\t\tBugInstance bugInstance = new BugInstance(\"IS2_INCONSISTENT_SYNC\", priority)\n\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t.addField(xfield)\n\t\t\t\t.addInt(freq).describe(\"INT_SYNC_PERCENT\");\n\n\t\t\t// Add source lines for unsynchronized accesses\n\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext(); ) {\n\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n\t\t\t}\n\n\t\t\tif (SYNC_ACCESS) {\n\t\t\t\t// Add source line for synchronized accesses;\n\t\t\t\t// useful for figuring out what the detector is doing\n\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext(); ) {\n\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EVAL) {\n\t\t\t\tbugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n\t\t\t\tbugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n\t\t\t}\n\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t}\n\t}","commit_id":"a7c64877ad967689665cc5c07ed33d4c9469472c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static boolean isConstructor(String methodName) {\n        return methodName.equals(\"<init>\")\n        \t\t||  methodName.equals(\"<clinit>\")\n        \t\t||  methodName.equals(\"readObject\")\n        \t\t||  methodName.equals(\"clone\")\n        \t\t||  methodName.equals(\"close\")\n        \t\t||  methodName.equals(\"finalize\")\n\t\t\t\t||  methodName.equals(\"this\");\n\t}","id":79914,"modified_method":"private static boolean isConstructor(String methodName) {\n        return methodName.equals(\"<init>\")\n        \t\t||  methodName.equals(\"<clinit>\")\n        \t\t||  methodName.equals(\"readObject\")\n        \t\t||  methodName.equals(\"clone\")\n        \t\t||  methodName.equals(\"close\")\n        \t\t||  methodName.equals(\"writeObject\")\n        \t\t||  methodName.equals(\"init\")\n        \t\t||  methodName.equals(\"initialize\")\n        \t\t||  methodName.equals(\"dispose\")\n        \t\t||  methodName.equals(\"finalize\")\n\t\t\t\t||  methodName.equals(\"this\");\n\t}","commit_id":"a7c64877ad967689665cc5c07ed33d4c9469472c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t// Build self-call graph\n\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t@Override\n\t\t\t\t\t\t public boolean wantCallsFor(Method method) {\n\t\t\t\treturn !method.isPublic();\n\t\t\t}\n\t\t};\n\n\t\tSet<Method> lockedMethodSet;\n\t\tSet<Method> publicReachableMethods;\n\n\t\ttry {\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\t\t\tlockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\t\t\tpublicReachableMethods = findPublicReachableMethods(classContext, selfCalls);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Method method : publicReachableMethods) {\n\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t\t\t\t\t\t\t\t\t if (isConstructor(method.getName()))\n\t\t\t\t\t\t\t\t\t\t\t continue;\n\t\t\t\t\t\t\t\t\t\t\t */\n\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\tcontinue;\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t}\n\t\t}\n\t}","id":79915,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif (DEBUG) System.out.println(\"******** Analyzing class \" + javaClass.getClassName());\n\n\t\t// Build self-call graph\n\t\tSelfCalls selfCalls = new SelfCalls(classContext) {\n\t\t\t@Override\n\t\t\t\t\t\t public boolean wantCallsFor(Method method) {\n\t\t\t\treturn !method.isPublic();\n\t\t\t}\n\t\t};\n\n\t\tSet<Method> lockedMethodSet;\n\t\t//Set<Method> publicReachableMethods;\n\t\tSet<Method> allMethods = new HashSet<Method>(Arrays.asList(javaClass.getMethods()));\n\n\t\ttry {\n\t\t\tselfCalls.execute();\n\t\t\tCallGraph callGraph = selfCalls.getCallGraph();\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(\"Call graph (not unlocked methods): \" + callGraph.getNumVertices() + \" nodes, \" +\n\t\t\t\t\t\tcallGraph.getNumEdges() + \" edges\");\n\t\t\t// Find call edges that are obviously locked\n\t\t\tSet<CallSite> obviouslyLockedSites = findObviouslyLockedCallSites(classContext, selfCalls);\n\t\t\tlockedMethodSet = findNotUnlockedMethods(classContext, selfCalls, obviouslyLockedSites);\n\t\t\tlockedMethodSet.retainAll(findLockedMethods(classContext, selfCalls, obviouslyLockedSites));\n\t\t\t//publicReachableMethods = findPublicReachableMethods(classContext, selfCalls);\n\t\t} catch (CFGBuilderException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t} catch (DataflowAnalysisException e) {\n\t\t\tbugReporter.logError(\"Error finding locked call sites\", e);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Method method : allMethods) {\n\t\t\tif (classContext.getMethodGen(method) == null)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t\t\t\t\t\t\t\t\t if (isConstructor(method.getName()))\n\t\t\t\t\t\t\t\t\t\t\t continue;\n\t\t\t\t\t\t\t\t\t\t\t */\n\t\t\tif (method.getName().startsWith(\"access$\"))\n\t\t\t\t// Ignore inner class access methods;\n\t\t\t\t// we will treat calls to them as field accesses\n\t\t\t\tcontinue;\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method, lockedMethodSet);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\"Error analyzing method\", e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1222a1ceac71ec0a0dc38059850973a46131932e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void report() {\n\t\tfor (XField xfield : statMap.keySet()) {\n\t\t\tFieldStats stats = statMap.get(xfield);\n\t\t\tif (!stats.interesting) continue;\n\t\t\tJCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext()\n\t\t\t\t\t\t\t\t.getJCIPAnnotationDatabase();\n\t\t\tboolean guardedByThis = \"this\".equals(jcipAnotationDatabase.getFieldAnnotation(xfield, \"GuardedBy\"));\n\t\t\tboolean notThreadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"NotThreadSafe\");\n\t\t\tboolean threadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName().replace('/','.'), \"ThreadSafe\");\n\t\t\tif (notThreadSafe) continue;\n\n\t\t\tWarningPropertySet<InconsistentSyncWarningProperty> propertySet = new WarningPropertySet<InconsistentSyncWarningProperty>();\n\n\t\t\tint numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n\t\t\tint numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n\t\t\tint numNullCheckUnlocked = stats.getNumAccesses(NULLCHECK_UNLOCKED);\n\t\t\t\n\t\t\tint numReadLocked = stats.getNumAccesses(READ_LOCKED);\n\t\t\tint numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n\t\t\tint numNullCheckLocked = stats.getNumAccesses(NULLCHECK_LOCKED);\n\t\t\t\n\n\t\t\tint extra = 0;\n\t\t\tif (numWriteUnlocked > 0) extra = numNullCheckLocked;\n\t\t\tint locked = numReadLocked + numWriteLocked + numNullCheckLocked;\n\t\t\tint biasedLocked = numReadLocked + (int) (WRITE_BIAS * (numWriteLocked + numNullCheckLocked + extra) );\n\t\t\tint unlocked = numReadUnlocked + numWriteUnlocked + numNullCheckUnlocked;\n\t\t\tint biasedUnlocked = numReadUnlocked + (int) (WRITE_BIAS * (numWriteUnlocked));\n\t\t\tint writes = numWriteLocked + numWriteUnlocked;\n\n\t\t\tif (unlocked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_UNLOCKED);\n\t\t\t}\n\n\n\t\t\tif (guardedByThis) {\n\t\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_GUARDED_BY_THIS);\n\n\t\t\t}\n\n\t\t\tif (threadSafe) {\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_THREAD_SAFE);\n\n\t\t}\n\t\t\tif (!guardedByThis && locked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_LOCKED);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"IS2: \" + xfield);\n\t\t\t\tif (guardedByThis) System.out.println(\"Guarded by this\");\n\t\t\t\tSystem.out.println(\"  RL: \" + numReadLocked);\n\t\t\t\tSystem.out.println(\"  WL: \" + numWriteLocked);\n\t\t\t\tSystem.out.println(\"  NL: \" + numNullCheckLocked);\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"  RU: \" + numReadUnlocked);\n\t\t\t\tSystem.out.println(\"  WU: \" + numWriteUnlocked);\n\t\t\t\tSystem.out.println(\"  NU: \" + numNullCheckUnlocked);\n\t\t\t}\n\t\t\tif (!EVAL && numReadUnlocked > 0 && ((int) (UNSYNC_FACTOR * (biasedUnlocked-1))) > biasedLocked) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.MANY_BIASED_UNLOCKED);\n\t\t\t}\n\n\t\t\t// NOTE: we ignore access to public, volatile, and final fields\n\n\t\t\tif (numWriteUnlocked + numWriteLocked == 0) {\n\t\t\t\t// No writes outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No writes outside of constructor\");\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_WRITTEN);\n//\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (numReadUnlocked + numReadLocked == 0) {\n\t\t\t\t// No reads outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No reads outside of constructor\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_READ);\n\t\t\t}\n\n\t\t\tif (stats.getNumLocalLocks() == 0) {\n\t\t\t\tif (DEBUG) System.out.println(\"  No local locks\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NO_LOCAL_LOCKS);\n\t\t\t}\n\n\t\t\tint freq, printFreq;\n\t\t\tif (locked + unlocked > 0) {\n\t\t\t\tfreq = (100 * locked) / (locked + unlocked);\n\t\t\t\tprintFreq = (100 * locked) / (locked + unlocked + numNullCheckUnlocked);\n\t\t\t} else {\n\t\t\t\tprintFreq = freq = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (freq < MIN_SYNC_PERCENT) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.BELOW_MIN_SYNC_PERCENT);\n\t\t\t}\n\t\t\tif (DEBUG) System.out.println(\"  Sync %: \" + freq);\n\n\t\t\tif (stats.getNumGetterMethodAccesses() >= unlocked) {\n\t\t\t\t// Unlocked accesses are only in getter method(s).\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ONLY_UNSYNC_IN_GETTERS);\n\t\t\t}\n\n\t\t\t// At this point, we report the field as being inconsistently synchronized\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (!propertySet.isFalsePositive(priority)) {\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, guardedByThis? \"IS_FIELD_NOT_GUARDED\" : \"IS2_INCONSISTENT_SYNC\", priority)\n\t\t\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t\t\t.addField(xfield)\n\t\t\t\t\t\t.addInt(printFreq).describe(IntAnnotation.INT_SYNC_PERCENT);\n\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\n\t\t\t\t// Add source lines for unsynchronized accesses\n\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext();) {\n\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n\t\t\t\t}\n\n\t\t\t\tif (SYNC_ACCESS) {\n\t\t\t\t\t// Add source line for synchronized accesses;\n\t\t\t\t\t// useful for figuring out what the detector is doing\n\t\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext();) {\n\t\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (EVAL) {\n\t\t\t\t\tbugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n\t\t\t\t\tbugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n\t\t\t\t}\n\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","id":79916,"modified_method":"public void report() {\n\t\tfor (XField xfield : statMap.keySet()) {\n\t\t\tFieldStats stats = statMap.get(xfield);\n\t\t\tif (!stats.interesting) continue;\n\t\t\tJCIPAnnotationDatabase jcipAnotationDatabase = AnalysisContext.currentAnalysisContext()\n\t\t\t\t\t\t\t\t.getJCIPAnnotationDatabase();\n\t\t\tboolean guardedByThis = \"this\".equals(jcipAnotationDatabase.getFieldAnnotation(xfield, \"GuardedBy\"));\n\t\t\tboolean notThreadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName(), \"NotThreadSafe\");\n\t\t\tboolean threadSafe = jcipAnotationDatabase.hasClassAnnotation(xfield.getClassName().replace('/','.'), \"ThreadSafe\");\n\t\t\tif (notThreadSafe) continue;\n\n\t\t\tWarningPropertySet<InconsistentSyncWarningProperty> propertySet = new WarningPropertySet<InconsistentSyncWarningProperty>();\n\n\t\t\tint numReadUnlocked = stats.getNumAccesses(READ_UNLOCKED);\n\t\t\tint numWriteUnlocked = stats.getNumAccesses(WRITE_UNLOCKED);\n\t\t\tint numNullCheckUnlocked = stats.getNumAccesses(NULLCHECK_UNLOCKED);\n\t\t\t\n\t\t\tint numReadLocked = stats.getNumAccesses(READ_LOCKED);\n\t\t\tint numWriteLocked = stats.getNumAccesses(WRITE_LOCKED);\n\t\t\tint numNullCheckLocked = stats.getNumAccesses(NULLCHECK_LOCKED);\n\t\t\t\n\n\t\t\tint extra = 0;\n\t\t\tif (numWriteUnlocked > 0) extra = numNullCheckLocked;\n\t\t\tint locked = numReadLocked + numWriteLocked + numNullCheckLocked;\n\t\t\tint biasedLocked = numReadLocked + (int) (WRITE_BIAS * (numWriteLocked + numNullCheckLocked + extra) );\n\t\t\tint unlocked = numReadUnlocked + numWriteUnlocked + numNullCheckUnlocked;\n\t\t\tint biasedUnlocked = numReadUnlocked + (int) (WRITE_BIAS * (numWriteUnlocked));\n\t\t\t//int writes = numWriteLocked + numWriteUnlocked;\n\n\t\t\tif (unlocked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_UNLOCKED);\n\t\t\t}\n\n\n\t\t\tif (guardedByThis) {\n\t\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_GUARDED_BY_THIS);\n\n\t\t\t}\n\n\t\t\tif (threadSafe) {\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ANNOTATED_AS_THREAD_SAFE);\n\n\t\t}\n\t\t\tif (!guardedByThis && locked == 0) {\n\t\t\t\tcontinue;\n//\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_LOCKED);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"IS2: \" + xfield);\n\t\t\t\tif (guardedByThis) System.out.println(\"Guarded by this\");\n\t\t\t\tSystem.out.println(\"  RL: \" + numReadLocked);\n\t\t\t\tSystem.out.println(\"  WL: \" + numWriteLocked);\n\t\t\t\tSystem.out.println(\"  NL: \" + numNullCheckLocked);\n\t\t\t\t\n\t\t\t\tSystem.out.println(\"  RU: \" + numReadUnlocked);\n\t\t\t\tSystem.out.println(\"  WU: \" + numWriteUnlocked);\n\t\t\t\tSystem.out.println(\"  NU: \" + numNullCheckUnlocked);\n\t\t\t}\n\t\t\tif (!EVAL && numReadUnlocked > 0 && ((int) (UNSYNC_FACTOR * (biasedUnlocked-1))) > biasedLocked) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.MANY_BIASED_UNLOCKED);\n\t\t\t}\n\n\t\t\t// NOTE: we ignore access to public, volatile, and final fields\n\n\t\t\tif (numWriteUnlocked + numWriteLocked == 0) {\n\t\t\t\t// No writes outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No writes outside of constructor\");\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_WRITTEN);\n//\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (numReadUnlocked + numReadLocked == 0) {\n\t\t\t\t// No reads outside of constructor\n\t\t\t\tif (DEBUG) System.out.println(\"  No reads outside of constructor\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NEVER_READ);\n\t\t\t}\n\n\t\t\tif (stats.getNumLocalLocks() == 0) {\n\t\t\t\tif (DEBUG) System.out.println(\"  No local locks\");\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.NO_LOCAL_LOCKS);\n\t\t\t}\n\n\t\t\tint freq, printFreq;\n\t\t\tif (locked + unlocked > 0) {\n\t\t\t\tfreq = (100 * locked) / (locked + unlocked);\n\t\t\t\tprintFreq = (100 * locked) / (locked + unlocked + numNullCheckUnlocked);\n\t\t\t} else {\n\t\t\t\tprintFreq = freq = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (freq < MIN_SYNC_PERCENT) {\n//\t\t\t\tcontinue;\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.BELOW_MIN_SYNC_PERCENT);\n\t\t\t}\n\t\t\tif (DEBUG) System.out.println(\"  Sync %: \" + freq);\n\n\t\t\tif (stats.getNumGetterMethodAccesses() >= unlocked) {\n\t\t\t\t// Unlocked accesses are only in getter method(s).\n\t\t\t\tpropertySet.addProperty(InconsistentSyncWarningProperty.ONLY_UNSYNC_IN_GETTERS);\n\t\t\t}\n\n\t\t\t// At this point, we report the field as being inconsistently synchronized\n\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\tif (!propertySet.isFalsePositive(priority)) {\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, guardedByThis? \"IS_FIELD_NOT_GUARDED\" : \"IS2_INCONSISTENT_SYNC\", priority)\n\t\t\t\t\t\t.addClass(xfield.getClassName())\n\t\t\t\t\t\t.addField(xfield)\n\t\t\t\t\t\t.addInt(printFreq).describe(IntAnnotation.INT_SYNC_PERCENT);\n\n\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t}\n\n\t\t\t\t// Add source lines for unsynchronized accesses\n\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.unsyncAccessIterator(); j.hasNext();) {\n\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_UNSYNC_ACCESS\");\n\t\t\t\t}\n\n\t\t\t\tif (SYNC_ACCESS) {\n\t\t\t\t\t// Add source line for synchronized accesses;\n\t\t\t\t\t// useful for figuring out what the detector is doing\n\t\t\t\t\tfor (Iterator<SourceLineAnnotation> j = stats.syncAccessIterator(); j.hasNext();) {\n\t\t\t\t\t\tSourceLineAnnotation accessSourceLine = j.next();\n\t\t\t\t\t\tbugInstance.addSourceLine(accessSourceLine).describe(\"SOURCE_LINE_SYNC_ACCESS\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (EVAL) {\n\t\t\t\t\tbugInstance.addInt(biasedLocked).describe(\"INT_BIASED_LOCKED\");\n\t\t\t\t\tbugInstance.addInt(biasedUnlocked).describe(\"INT_BIASED_UNLOCKED\");\n\t\t\t\t}\n\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1222a1ceac71ec0a0dc38059850973a46131932e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method, Set<Method> lockedMethodSet)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tInnerClassAccessMap icam = AnalysisContext.currentAnalysisContext().getInnerClassAccessMap();\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tLockChecker lockChecker = classContext.getLockChecker(method);\n\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\tboolean isGetterMethod = isGetterMethod(classContext, method);\n\t\tMethodDescriptor methodDescriptor = DescriptorFactory.instance().getMethodDescriptor(classContext.getJavaClass(), method);\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(\"**** Analyzing method \" +\n\t\t\t\t\tSignatureConverter.convertMethodSignature(methodGen));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\ttry {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\t\tXField xfield = null;\n\t\t\t\tboolean isWrite = false;\n\t\t\t\tboolean isLocal = false;\n\t\t\t\tboolean isNullCheck = false;\n\n\t\t\t\tif (ins instanceof FieldInstruction) {\n\t\t\t\t\tInstructionHandle n = location.getHandle().getNext();\n\t\t\t\t\tisNullCheck = n.getInstruction() instanceof IFNONNULL || n.getInstruction() instanceof IFNULL;\n\t\t\t\t\tif (DEBUG && isNullCheck) System.out.println(\"is null check\");\n\t\t\t\t\tFieldInstruction fins = (FieldInstruction) ins;\n\t\t\t\t\txfield = Hierarchy.findXField(fins, cpg);\n\t\t\t\t\tisWrite = ins.getOpcode() == Constants.PUTFIELD;\n\t\t\t\t\tisLocal = fins.getClassName(cpg).equals(classContext.getJavaClass().getClassName());\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"Handling field access: \" + location.getHandle() +\n\t\t\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \") :\" + n);\n\t\t\t\t} else if (ins instanceof INVOKESTATIC) {\n\t\t\t\t\tINVOKESTATIC inv = (INVOKESTATIC) ins;\n\t\t\t\t\tInnerClassAccess access = icam.getInnerClassAccess(inv, cpg);\n\t\t\t\t\tif (access != null && access.getMethodSignature().equals(inv.getSignature(cpg))) {\n\t\t\t\t\t\txfield = access.getField();\n\t\t\t\t\t\tisWrite = !access.isLoad();\n\t\t\t\t\t\tisLocal = false;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\"Handling inner class access: \" + location.getHandle() +\n\t\t\t\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfield == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We only care about mutable nonvolatile nonpublic instance fields.\n\t\t\t\tif (xfield.isStatic() || xfield.isPublic() || xfield.isVolatile() || xfield.isFinal())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The value number frame could be invalid if the basic\n\t\t\t\t// block became unreachable due to edge pruning (dead code).\n\t\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get lock set and instance value\n\t\t\t\tValueNumber thisValue = !method.isStatic() ? vnaDataflow.getAnalysis().getThisValue() : null;\n\t\t\t\tLockSet lockSet = lockChecker.getFactAtLocation(location);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tValueNumber instance = frame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Lock set: \" + lockSet);\n\t\t\t\t\tSystem.out.println(\"value number: \" + instance.getNumber());\n\t\t\t\t\tSystem.out.println(\"Lock count: \" + lockSet.getLockCount(instance.getNumber()));\n\t\t\t\t}\n\n\n\t\t\t\t// Is the instance locked?\n\t\t\t\t// We consider the access to be locked if either\n\t\t\t\t//   - the object is explicitly locked, or\n\t\t\t\t//   - the field is accessed through the \"this\" reference,\n\t\t\t\t//     and the method is in the locked method set, or\n\t\t\t\t//   - any value returned by a called method is locked;\n\t\t\t\t//     the (conservative) assumption is that the return lock object\n\t\t\t\t//     is correct for synchronizing the access\n\t\t\t\tboolean isExplicitlyLocked = lockSet.getLockCount(instance.getNumber()) > 0;\n\t\t\t\tboolean isAccessedThroughThis = thisValue != null && thisValue.equals(instance);\n\t\t\t\tboolean isLocked = isExplicitlyLocked\n\t\t\t\t\t\t|| (lockedMethodSet.contains(method) && isAccessedThroughThis)\n\t\t\t\t\t\t|| lockSet.containsReturnValue(vnaDataflow.getAnalysis().getFactory());\n\n\t\t\t\t// Adjust the field so its class name is the same\n\t\t\t\t// as the type of reference it is accessed through.\n\t\t\t\t// This helps fix false positives produced when a\n\t\t\t\t// threadsafe class is extended by a subclass that\n\t\t\t\t// doesn't care about thread safety.\n\t\t\t\tif (ADJUST_SUBCLASS_ACCESSES) {\n\t\t\t\t\t// Find the type of the object instance\n\t\t\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\tif (!typeFrame.isValid()) continue;\n\t\t\t\t\tType instanceType = typeFrame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\t\tif (instanceType instanceof TopType) {\n\t\t\t\t\t\tif (DEBUG) System.out.println(\"Freaky: typeFrame is \" + typeFrame);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Note: instance type can be Null,\n\t\t\t\t\t// in which case we won't adjust the field type.\n\t\t\t\t\tif (instanceType != TypeFrame.getNullType()) {\n\t\t\t\t\t\tif (!(instanceType instanceof ObjectType)) {\n\t\t\t\t\t\t\tthrow new DataflowAnalysisException(\"Field accessed through non-object reference \" + instanceType,\n\t\t\t\t\t\t\t\t\tmethodGen, handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectType objType = (ObjectType) instanceType;\n\n\t\t\t\t\t\t// If instance class name is not the same as that of the field,\n\t\t\t\t\t\t// make it so\n\t\t\t\t\t\tString instanceClassName = objType.getClassName();\n\t\t\t\t\t\tif (!instanceClassName.equals(xfield.getClassName())) {\n\t\t\t\t\t\t\txfield = XFactory.getExactXField(\n\t\t\t\t\t\t\t\t\tinstanceClassName,\n\t\t\t\t\t\t\t\t\txfield.getName(), \n\t\t\t\t\t\t\t\t\txfield.getSignature(),\n\t\t\t\t\t\t\t\t\txfield.isStatic());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint kind = 0;\n\t\t\t\tkind |= isLocked ? LOCKED : UNLOCKED;\n\t\t\t\tkind |= isWrite ? WRITE : isNullCheck ? NULLCHECK : READ;\n\n\t\t\t\tif (isLocked || !isConstructor(method.getName())) {\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"IS2:\\t\" +\n\t\t\t\t\t\t\t\tSignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t\t\t\t\t\"\\t\" + xfield + \"\\t\" + ((isWrite ? \"W\" : \"R\") + \"/\" + (isLocked ? \"L\" : \"U\")));\n\n\t\t\t\t\tFieldStats stats = getStats(xfield);\n\t\t\t\t\tstats.addAccess(kind);\n\n\t\t\t\t\tif (isExplicitlyLocked && isLocal)\n\t\t\t\t\t\tstats.addLocalLock();\n\n\t\t\t\t\tif (isGetterMethod && !isLocked)\n\t\t\t\t\t\tstats.addGetterMethodAccess();\n\n\t\t\t\t\tstats.addAccess(methodDescriptor, handle, isLocked);\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","id":79917,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method, Set<Method> lockedMethodSet)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\n\t\tInnerClassAccessMap icam = AnalysisContext.currentAnalysisContext().getInnerClassAccessMap();\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tLockChecker lockChecker = classContext.getLockChecker(method);\n\t\tValueNumberDataflow vnaDataflow = classContext.getValueNumberDataflow(method);\n\t\tboolean isGetterMethod = isGetterMethod(classContext, method);\n\t\tMethodDescriptor methodDescriptor = DescriptorFactory.instance().getMethodDescriptor(classContext.getJavaClass(), method);\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(\"**** Analyzing method \" +\n\t\t\t\t\tSignatureConverter.convertMethodSignature(methodGen));\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\ttry {\n\t\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\t\tXField xfield = null;\n\t\t\t\tboolean isWrite = false;\n\t\t\t\tboolean isLocal = false;\n\t\t\t\tboolean isNullCheck = false;\n\n\t\t\t\tif (ins instanceof FieldInstruction) {\n\t\t\t\t\tInstructionHandle n = location.getHandle().getNext();\n\t\t\t\t\tisNullCheck = n.getInstruction() instanceof IFNONNULL || n.getInstruction() instanceof IFNULL;\n\t\t\t\t\tif (DEBUG && isNullCheck) System.out.println(\"is null check\");\n\t\t\t\t\tFieldInstruction fins = (FieldInstruction) ins;\n\t\t\t\t\txfield = Hierarchy.findXField(fins, cpg);\n\t\t\t\t\tisWrite = ins.getOpcode() == Constants.PUTFIELD;\n\t\t\t\t\tisLocal = fins.getClassName(cpg).equals(classContext.getJavaClass().getClassName());\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"Handling field access: \" + location.getHandle() +\n\t\t\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \") :\" + n);\n\t\t\t\t} else if (ins instanceof INVOKESTATIC) {\n\t\t\t\t\tINVOKESTATIC inv = (INVOKESTATIC) ins;\n\t\t\t\t\tInnerClassAccess access = icam.getInnerClassAccess(inv, cpg);\n\t\t\t\t\tif (access != null && access.getMethodSignature().equals(inv.getSignature(cpg))) {\n\t\t\t\t\t\txfield = access.getField();\n\t\t\t\t\t\tisWrite = !access.isLoad();\n\t\t\t\t\t\tisLocal = false;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\"Handling inner class access: \" + location.getHandle() +\n\t\t\t\t\t\t\t\t\t\" (frame=\" + vnaDataflow.getFactAtLocation(location) + \")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (xfield == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// We only care about mutable nonvolatile nonpublic instance fields.\n\t\t\t\tif (xfield.isStatic() || xfield.isPublic() || xfield.isVolatile() || xfield.isFinal())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// The value number frame could be invalid if the basic\n\t\t\t\t// block became unreachable due to edge pruning (dead code).\n\t\t\t\tValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get lock set and instance value\n\t\t\t\tValueNumber thisValue = !method.isStatic() ? vnaDataflow.getAnalysis().getThisValue() : null;\n\t\t\t\tLockSet lockSet = lockChecker.getFactAtLocation(location);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tValueNumber instance = frame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Lock set: \" + lockSet);\n\t\t\t\t\tSystem.out.println(\"value number: \" + instance.getNumber());\n\t\t\t\t\tSystem.out.println(\"Lock count: \" + lockSet.getLockCount(instance.getNumber()));\n\t\t\t\t}\n\n\n\t\t\t\t// Is the instance locked?\n\t\t\t\t// We consider the access to be locked if either\n\t\t\t\t//   - the object is explicitly locked, or\n\t\t\t\t//   - the field is accessed through the \"this\" reference,\n\t\t\t\t//     and the method is in the locked method set, or\n\t\t\t\t//   - any value returned by a called method is locked;\n\t\t\t\t//     the (conservative) assumption is that the return lock object\n\t\t\t\t//     is correct for synchronizing the access\n\t\t\t\tboolean isExplicitlyLocked = lockSet.getLockCount(instance.getNumber()) > 0;\n\t\t\t\tboolean isAccessedThroughThis = thisValue != null && thisValue.equals(instance);\n\t\t\t\tboolean isLocked = isExplicitlyLocked\n\t\t\t\t\t\t|| ((isConstructor(method.getName()) || lockedMethodSet.contains(method)) && isAccessedThroughThis)\n\t\t\t\t\t\t|| lockSet.containsReturnValue(vnaDataflow.getAnalysis().getFactory());\n\n\t\t\t\t// Adjust the field so its class name is the same\n\t\t\t\t// as the type of reference it is accessed through.\n\t\t\t\t// This helps fix false positives produced when a\n\t\t\t\t// threadsafe class is extended by a subclass that\n\t\t\t\t// doesn't care about thread safety.\n\t\t\t\tif (ADJUST_SUBCLASS_ACCESSES) {\n\t\t\t\t\t// Find the type of the object instance\n\t\t\t\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\t\t\t\tTypeFrame typeFrame = typeDataflow.getFactAtLocation(location);\n\t\t\t\t\tif (!typeFrame.isValid()) continue;\n\t\t\t\t\tType instanceType = typeFrame.getInstance(handle.getInstruction(), cpg);\n\t\t\t\t\tif (instanceType instanceof TopType) {\n\t\t\t\t\t\tif (DEBUG) System.out.println(\"Freaky: typeFrame is \" + typeFrame);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Note: instance type can be Null,\n\t\t\t\t\t// in which case we won't adjust the field type.\n\t\t\t\t\tif (instanceType != TypeFrame.getNullType()) {\n\t\t\t\t\t\tif (!(instanceType instanceof ObjectType)) {\n\t\t\t\t\t\t\tthrow new DataflowAnalysisException(\"Field accessed through non-object reference \" + instanceType,\n\t\t\t\t\t\t\t\t\tmethodGen, handle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObjectType objType = (ObjectType) instanceType;\n\n\t\t\t\t\t\t// If instance class name is not the same as that of the field,\n\t\t\t\t\t\t// make it so\n\t\t\t\t\t\tString instanceClassName = objType.getClassName();\n\t\t\t\t\t\tif (!instanceClassName.equals(xfield.getClassName())) {\n\t\t\t\t\t\t\txfield = XFactory.getExactXField(\n\t\t\t\t\t\t\t\t\tinstanceClassName,\n\t\t\t\t\t\t\t\t\txfield.getName(), \n\t\t\t\t\t\t\t\t\txfield.getSignature(),\n\t\t\t\t\t\t\t\t\txfield.isStatic());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint kind = 0;\n\t\t\t\tkind |= isLocked ? LOCKED : UNLOCKED;\n\t\t\t\tkind |= isWrite ? WRITE : isNullCheck ? NULLCHECK : READ;\n\n\t\t\t\t//if (isLocked || !isConstructor(method.getName())) {\n\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\tSystem.out.println(\"IS2:\\t\" +\n\t\t\t\t\t\t\t\tSignatureConverter.convertMethodSignature(methodGen) +\n\t\t\t\t\t\t\t\t\"\\t\" + xfield + \"\\t\" + ((isWrite ? \"W\" : \"R\") + \"/\" + (isLocked ? \"L\" : \"U\")));\n\n\t\t\t\t\tFieldStats stats = getStats(xfield);\n\t\t\t\t\t\n\t\t\t\t\t// Don't count a contructor's synchronized access\n\t\t\t\t\t// toward the field statistics because it's\n\t\t\t\t\t// trivially true and doesn't really represent the\n\t\t\t\t\t// programmer's intention \n\t\t\t\t\tif(!(isLocked && isConstructor(method.getName()))) {\n\t\t\t\t\t    stats.addAccess(kind);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isExplicitlyLocked && isLocal)\n\t\t\t\t\t\tstats.addLocalLock();\n\n\t\t\t\t\tif (isGetterMethod && !isLocked)\n\t\t\t\t\t\tstats.addGetterMethodAccess();\n\n\t\t\t\t\tstats.addAccess(methodDescriptor, handle, isLocked);\n\t\t\t\t//}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1222a1ceac71ec0a0dc38059850973a46131932e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Executes the method and return the result. Handle ask for password\n     * when hitting password protected site.\n     * Keep asking for password till user clicks cancel or enters correct\n     * password. When 'remember password' is checked password is saved, if this\n     * password and username are not correct clear them, if there are correct\n     * they stay saved.\n     * @param httpClient the configured http client to use.\n     * @param req the request for now it is get or post.\n     * @return the result http entity.\n     */\n    private static HttpEntity executeMethod(DefaultHttpClient httpClient,\n                                            HttpRequestBase req)\n        throws Throwable\n    {\n        // do it when response (first execution) or till we are unauthorized\n        HttpResponse response = null;\n        int redirects = 0;\n        while(response == null\n              || response.getStatusLine().getStatusCode()\n                    == HttpStatus.SC_UNAUTHORIZED)\n        {\n            // if we were unauthorized, lets clear the method and recreate it\n            // for new connection with new credentials.\n            if(response != null\n               && response.getStatusLine().getStatusCode()\n                    == HttpStatus.SC_UNAUTHORIZED)\n            {\n                if(logger.isDebugEnabled())\n                    logger.debug(\"Will retry http connect and \" +\n                        \"credentials input as latest are not correct!\");\n\n                URI uri = req.getURI();\n                req.abort();\n                req = req.getClass().newInstance();\n                req.setURI(uri);\n\n                httpClient.getCredentialsProvider().clear();\n\n                if(!((HTTPCredentialsProvider)httpClient\n                    .getCredentialsProvider()).isChallengedForCredentials())\n                {\n                    // we were not challenged for credentials\n                    // something other is happening and we are un-authorized\n                    // lets rise an exception and stop current execution.\n                    // and will clear any credentials if any\n                    throw new AuthenticationException(\"Unauthorized\");\n                }\n                else\n                {\n                    // well we were challenged but user entered wrong pass\n                    // lets challenge again\n                    response = httpClient.execute(req);\n                }\n            }\n            else\n                response = httpClient.execute(req);\n\n            // if user click cancel no need to retry, stop trying\n            if(!((HTTPCredentialsProvider)httpClient\n                    .getCredentialsProvider()).retry())\n            {\n                if(logger.isDebugEnabled())\n                    logger.debug(\"User canceled credentials input.\");\n                break;\n            }\n\n            // check for post redirect as post redirects are not handled\n            // automatically\n            // RFC2616 (10.3 Redirection 3xx).\n            // The second request (forwarded method) can only be a GET or HEAD.\n            Header locationHeader = response.getFirstHeader(\"location\");\n\n            if(locationHeader != null\n                && req instanceof HttpPost\n                &&  (response.getStatusLine().getStatusCode()\n                        == HttpStatus.SC_MOVED_PERMANENTLY\n                     || response.getStatusLine().getStatusCode()\n                        == HttpStatus.SC_MOVED_TEMPORARILY\n                     || response.getStatusLine().getStatusCode()\n                        == HttpStatus.SC_SEE_OTHER)\n                && redirects < MAX_REDIRECTS)\n            {\n                HttpRequestBase oldreq = req;\n                oldreq.abort();\n\n                String newLocation = locationHeader.getValue();\n\n                // append query string if any\n                HttpEntity en = ((HttpPost) oldreq).getEntity();\n                if(en != null && en instanceof StringEntity)\n                {\n                    ByteArrayOutputStream out = new ByteArrayOutputStream();\n                    en.writeTo(out);\n                    newLocation += \"?\" + out.toString(\"UTF-8\");\n                }\n\n                req = new HttpGet(newLocation);\n                req.setParams(oldreq.getParams());\n                req.setHeaders(oldreq.getAllHeaders());\n\n                redirects++;\n                response = httpClient.execute(req);\n            }\n        }\n\n        // if we finally managed to login return the result.\n        if(response != null\n            && response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)\n        {\n            return response.getEntity();\n        }\n\n        // is user has canceled no result needed.\n        return null;\n    }","id":79918,"modified_method":"/**\n     * Executes the method and return the result. Handle ask for password\n     * when hitting password protected site.\n     * Keep asking for password till user clicks cancel or enters correct\n     * password. When 'remember password' is checked password is saved, if this\n     * password and username are not correct clear them, if there are correct\n     * they stay saved.\n     * @param httpClient the configured http client to use.\n     * @param req the request for now it is get or post.\n     * @return the result http entity.\n     */\n    private static HttpEntity executeMethod(DefaultHttpClient httpClient,\n                                            HttpRequestBase req)\n        throws Throwable\n    {\n        // do it when response (first execution) or till we are unauthorized\n        HttpResponse response = null;\n        int redirects = 0;\n        while(response == null\n              || response.getStatusLine().getStatusCode()\n                    == HttpStatus.SC_UNAUTHORIZED\n              || response.getStatusLine().getStatusCode()\n                            == HttpStatus.SC_FORBIDDEN)\n        {\n            // if we were unauthorized, lets clear the method and recreate it\n            // for new connection with new credentials.\n            if(response != null\n               && (response.getStatusLine().getStatusCode()\n                    == HttpStatus.SC_UNAUTHORIZED\n                    || response.getStatusLine().getStatusCode()\n                                        == HttpStatus.SC_FORBIDDEN))\n            {\n                if(logger.isDebugEnabled())\n                    logger.debug(\"Will retry http connect and \" +\n                        \"credentials input as latest are not correct!\");\n\n                URI uri = req.getURI();\n                req.abort();\n                req = req.getClass().newInstance();\n                req.setURI(uri);\n\n                httpClient.getCredentialsProvider().clear();\n\n                if(!((HTTPCredentialsProvider)httpClient\n                    .getCredentialsProvider()).isChallengedForCredentials())\n                {\n                    // we were not challenged for credentials\n                    // something other is happening and we are un-authorized\n                    // lets rise an exception and stop current execution.\n                    // and will clear any credentials if any\n                    throw new AuthenticationException(\"Unauthorized\");\n                }\n                else\n                {\n                    // well we were challenged but user entered wrong pass\n                    // lets challenge again\n                    response = httpClient.execute(req);\n                }\n            }\n            else\n                response = httpClient.execute(req);\n\n            // if user click cancel no need to retry, stop trying\n            if(!((HTTPCredentialsProvider)httpClient\n                    .getCredentialsProvider()).retry())\n            {\n                if(logger.isDebugEnabled())\n                    logger.debug(\"User canceled credentials input.\");\n                break;\n            }\n\n            // check for post redirect as post redirects are not handled\n            // automatically\n            // RFC2616 (10.3 Redirection 3xx).\n            // The second request (forwarded method) can only be a GET or HEAD.\n            Header locationHeader = response.getFirstHeader(\"location\");\n\n            if(locationHeader != null\n                && req instanceof HttpPost\n                &&  (response.getStatusLine().getStatusCode()\n                        == HttpStatus.SC_MOVED_PERMANENTLY\n                     || response.getStatusLine().getStatusCode()\n                        == HttpStatus.SC_MOVED_TEMPORARILY\n                     || response.getStatusLine().getStatusCode()\n                        == HttpStatus.SC_SEE_OTHER)\n                && redirects < MAX_REDIRECTS)\n            {\n                HttpRequestBase oldreq = req;\n                oldreq.abort();\n\n                String newLocation = locationHeader.getValue();\n\n                // append query string if any\n                HttpEntity en = ((HttpPost) oldreq).getEntity();\n                if(en != null && en instanceof StringEntity)\n                {\n                    ByteArrayOutputStream out = new ByteArrayOutputStream();\n                    en.writeTo(out);\n                    newLocation += \"?\" + out.toString(\"UTF-8\");\n                }\n\n                req = new HttpGet(newLocation);\n                req.setParams(oldreq.getParams());\n                req.setHeaders(oldreq.getAllHeaders());\n\n                redirects++;\n                response = httpClient.execute(req);\n            }\n        }\n\n        // if we finally managed to login return the result.\n        if(response != null\n            && response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)\n        {\n            return response.getEntity();\n        }\n\n        // is user has canceled no result needed.\n        return null;\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Posting form to <tt>address<\/tt>. For submission we use POST method\n     * which is \"application/x-www-form-urlencoded\" encoded.\n     * @param httpClient the http client\n     * @param postMethod the post method\n     * @param address HTTP address.\n     * @param usernamePropertyName the property to use to retrieve/store\n     * username value if protected site is hit, for username\n     * ConfigurationService service is used.\n     * @param passwordPropertyName the property to use to retrieve/store\n     * password value if protected site is hit, for password\n     * CredentialsStorageService service is used.\n     * @param formParamNames the parameter names to include in post.\n     * @param formParamValues the corresponding parameter values to use.\n     * @param usernameParamIx the index of the username parameter in the\n     * <tt>formParamNames<\/tt> and <tt>formParamValues<\/tt>\n     * if any, otherwise -1.\n     * @param passwordParamIx the index of the password parameter in the\n     * <tt>formParamNames<\/tt> and <tt>formParamValues<\/tt>\n     * if any, otherwise -1.\n     * @return the result or null if send was not possible or\n     * credentials ask if any was canceled.\n     */\n    private static HttpEntity postForm(\n                                   DefaultHttpClient httpClient,\n                                   HttpPost postMethod,\n                                   String address,\n                                   String usernamePropertyName,\n                                   String passwordPropertyName,\n                                   String[] formParamNames,\n                                   String[] formParamValues,\n                                   int usernameParamIx,\n                                   int passwordParamIx)\n        throws Throwable\n    {\n        // if we have username and password in the parameters, lets\n        // retrieve their values\n        Credentials creds = null;\n        if(usernameParamIx != -1\n            && usernameParamIx < formParamNames.length\n            && passwordParamIx != -1\n            && passwordParamIx < formParamNames.length)\n        {\n            URL url = new URL(address);\n            HTTPCredentialsProvider prov = (HTTPCredentialsProvider)\n                    httpClient.getCredentialsProvider();\n\n            creds =  prov.getCredentials(\n                    new AuthScope(url.getHost(), url.getPort()));\n\n            // it was user canceled lets stop processing\n            if(creds == null && !prov.retry())\n            {\n                return null;\n            }\n        }\n\n        // construct the name value pairs we will be sending\n        List<NameValuePair> parameters = new ArrayList<NameValuePair>();\n        // there can be no params\n        if(formParamNames != null)\n        {\n            for(int i = 0; i < formParamNames.length; i++)\n            {\n                // we are on the username index, insert retrieved username value\n                if(i == usernameParamIx && creds != null)\n                {\n                    parameters.add(new BasicNameValuePair(\n                        formParamNames[i], creds.getUserPrincipal().getName()));\n                }// we are on the password index, insert retrieved password val\n                else if(i == passwordParamIx && creds != null)\n                {\n                    parameters.add(new BasicNameValuePair(\n                        formParamNames[i], creds.getPassword()));\n                }\n                else // common name value pair, all info is present\n                {\n                    parameters.add(new BasicNameValuePair(\n                        formParamNames[i], formParamValues[i]));\n                }\n            }\n        }\n\n        String s = URLEncodedUtils.format(parameters, HTTP.UTF_8);\n        StringEntity entity = new StringEntity(s, HTTP.UTF_8);\n        // set content type to \"application/x-www-form-urlencoded\"\n        entity.setContentType(URLEncodedUtils.CONTENT_TYPE);\n\n        // insert post values encoded.\n        postMethod.setEntity(entity);\n\n        // execute post\n        return executeMethod(httpClient, postMethod);\n    }","id":79919,"modified_method":"/**\n     * Posting form to <tt>address<\/tt>. For submission we use POST method\n     * which is \"application/x-www-form-urlencoded\" encoded.\n     * @param httpClient the http client\n     * @param postMethod the post method\n     * @param address HTTP address.\n     * @param usernamePropertyName the property to use to retrieve/store\n     * username value if protected site is hit, for username\n     * ConfigurationService service is used.\n     * @param passwordPropertyName the property to use to retrieve/store\n     * password value if protected site is hit, for password\n     * CredentialsStorageService service is used.\n     * @param formParamNames the parameter names to include in post.\n     * @param formParamValues the corresponding parameter values to use.\n     * @param usernameParamIx the index of the username parameter in the\n     * <tt>formParamNames<\/tt> and <tt>formParamValues<\/tt>\n     * if any, otherwise -1.\n     * @param passwordParamIx the index of the password parameter in the\n     * <tt>formParamNames<\/tt> and <tt>formParamValues<\/tt>\n     * if any, otherwise -1.\n     * @return the result or null if send was not possible or\n     * credentials ask if any was canceled.\n     */\n    private static HttpEntity postForm(\n                                   DefaultHttpClient httpClient,\n                                   HttpPost postMethod,\n                                   String address,\n                                   String usernamePropertyName,\n                                   String passwordPropertyName,\n                                   String[] formParamNames,\n                                   String[] formParamValues,\n                                   int usernameParamIx,\n                                   int passwordParamIx)\n        throws Throwable\n    {\n        // if we have username and password in the parameters, lets\n        // retrieve their values\n        Credentials creds = null;\n        if(usernameParamIx != -1\n            && usernameParamIx < formParamNames.length\n            && passwordParamIx != -1\n            && passwordParamIx < formParamNames.length)\n        {\n            URL url = new URL(address);\n            HTTPCredentialsProvider prov = (HTTPCredentialsProvider)\n                    httpClient.getCredentialsProvider();\n\n            // don't allow empty username\n            while(creds == null\n                  || creds.getUserPrincipal() == null\n                  || StringUtils.isNullOrEmpty(\n                        creds.getUserPrincipal().getName()))\n            {\n                creds =  prov.getCredentials(\n                        new AuthScope(url.getHost(), url.getPort()));\n\n                // it was user canceled lets stop processing\n                if(creds == null && !prov.retry())\n                {\n                    return null;\n                }\n            }\n        }\n\n        // construct the name value pairs we will be sending\n        List<NameValuePair> parameters = new ArrayList<NameValuePair>();\n        // there can be no params\n        if(formParamNames != null)\n        {\n            for(int i = 0; i < formParamNames.length; i++)\n            {\n                // we are on the username index, insert retrieved username value\n                if(i == usernameParamIx && creds != null)\n                {\n                    parameters.add(new BasicNameValuePair(\n                        formParamNames[i], creds.getUserPrincipal().getName()));\n                }// we are on the password index, insert retrieved password val\n                else if(i == passwordParamIx && creds != null)\n                {\n                    parameters.add(new BasicNameValuePair(\n                        formParamNames[i], creds.getPassword()));\n                }\n                else // common name value pair, all info is present\n                {\n                    parameters.add(new BasicNameValuePair(\n                        formParamNames[i], formParamValues[i]));\n                }\n            }\n        }\n\n        String s = URLEncodedUtils.format(parameters, HTTP.UTF_8);\n        StringEntity entity = new StringEntity(s, HTTP.UTF_8);\n        // set content type to \"application/x-www-form-urlencoded\"\n        entity.setContentType(URLEncodedUtils.CONTENT_TYPE);\n\n        // insert post values encoded.\n        postMethod.setEntity(entity);\n\n        // execute post\n        return executeMethod(httpClient, postMethod);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the call button when the mouse exits the component area.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseExited(MouseEvent e)\n    {\n        updateCallIcon(e);\n    }","id":79920,"modified_method":"/**\n     * Updates the call button when the mouse exits the component area.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseExited(MouseEvent e)\n    {\n        super.mouseExited(e);\n\n        if(isCallButtonEnabled)\n            updateCallIcon(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void mouseReleased(MouseEvent e) {}","id":79921,"modified_method":"public void mouseReleased(MouseEvent e)\n    {\n        super.mouseReleased(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void mousePressed(MouseEvent e) {}","id":79922,"modified_method":"public void mousePressed(MouseEvent e)\n    {\n        super.mousePressed(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the delete icon when the mouse is moved over.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseMoved(MouseEvent e)\n    {\n        updateCallIcon(e);\n    }","id":79923,"modified_method":"/**\n     * Updates the delete icon when the mouse is moved over.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseMoved(MouseEvent e)\n    {\n        super.mouseMoved(e);\n\n        if(isCallButtonEnabled)\n            updateCallIcon(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the delete icon when the mouse is dragged over.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseDragged(MouseEvent e)\n    {\n        updateCallIcon(e);\n    }","id":79924,"modified_method":"/**\n     * Updates the delete icon when the mouse is dragged over.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseDragged(MouseEvent e)\n    {\n        super.mouseDragged(e);\n\n        if(isCallButtonEnabled)\n            updateCallIcon(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the call button when the mouse was clicked.\n     * @param e the <tt>MouseEvent<\/tt> that notified us of the click\n     */\n    public void mouseClicked(MouseEvent e)\n    {\n        updateCallIcon(e);\n    }","id":79925,"modified_method":"/**\n     * Updates the call button when the mouse was clicked.\n     * @param e the <tt>MouseEvent<\/tt> that notified us of the click\n     */\n    public void mouseClicked(MouseEvent e)\n    {\n        super.mouseClicked(e);\n\n        if(isCallButtonEnabled)\n            updateCallIcon(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the call button when the mouse is enters the component area.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseEntered(MouseEvent e)\n    {\n        updateCallIcon(e);\n    }","id":79926,"modified_method":"/**\n     * Updates the call button when the mouse is enters the component area.\n     * @param e the <tt>MouseEvent<\/tt> that notified us\n     */\n    public void mouseEntered(MouseEvent e)\n    {\n        super.mouseEntered(e);\n\n        if(isCallButtonEnabled)\n            updateCallIcon(e);\n    }","commit_id":"ff50e5331405eebf38aed85b8d51adad644e8251","url":"https://github.com/jitsi/jitsi"},{"original_method":"public DeprecatedTags() {\n        super(tr(\"Deprecated Tags\"), tr(\"Checks and corrects deprecated tags.\"));\n        checks.add(new DeprecationCheck(2101).\n                testAndRemove(\"barrier\", \"wire_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"chain\"));\n        checks.add(new DeprecationCheck(2102).\n                testAndRemove(\"barrier\", \"wood_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"wood\"));\n        checks.add(new DeprecationCheck(2103).\n                testAndRemove(\"highway\", \"ford\").\n                add(\"highway\", \"road\").\n                add(\"ford\", \"yes\"));\n        // from http://wiki.openstreetmap.org/wiki/Deprecated_features\n        checks.add(new DeprecationCheck(2104).\n                test(\"class\").\n                alternative(\"highway\"));\n        checks.add(new DeprecationCheck(2105).\n                testAndRemove(\"highway\", \"stile\").\n                add(\"barrier\", \"stile\"));\n        checks.add(new DeprecationCheck(2106).\n                testAndRemove(\"highway\", \"incline\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2107).\n                testAndRemove(\"highway\", \"incline_steep\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2108).\n                testAndRemove(\"highway\", \"unsurfaced\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"unpaved\"));\n        checks.add(new DeprecationCheck(2109).\n                test(\"landuse\", \"wood\").\n                alternative(\"landuse\", \"forest\").\n                alternative(\"natural\", \"wood\"));\n        checks.add(new DeprecationCheck(2110).\n                testAndRemove(\"natural\", \"marsh\").\n                add(\"natural\", \"wetland\").\n                add(\"wetland\", \"marsh\"));\n        checks.add(new DeprecationCheck(2111).\n                test(\"highway\", \"byway\"));\n        checks.add(new DeprecationCheck(2112).\n                test(\"power_source\").\n                alternative(\"generator:source\"));\n        checks.add(new DeprecationCheck(2113).\n                test(\"power_rating\").\n                alternative(\"generator:output\"));\n    }","id":79927,"modified_method":"public DeprecatedTags() {\n        super(tr(\"Deprecated Tags\"), tr(\"Checks and corrects deprecated tags.\"));\n        checks.add(new DeprecationCheck(2101).\n                testAndRemove(\"barrier\", \"wire_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"chain\"));\n        checks.add(new DeprecationCheck(2102).\n                testAndRemove(\"barrier\", \"wood_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"wood\"));\n        checks.add(new DeprecationCheck(2103).\n                testAndRemove(\"highway\", \"ford\").\n                add(\"ford\", \"yes\"));\n        // from http://wiki.openstreetmap.org/wiki/Deprecated_features\n        checks.add(new DeprecationCheck(2104).\n                test(\"class\").\n                alternative(\"highway\"));\n        checks.add(new DeprecationCheck(2105).\n                testAndRemove(\"highway\", \"stile\").\n                add(\"barrier\", \"stile\"));\n        checks.add(new DeprecationCheck(2106).\n                testAndRemove(\"highway\", \"incline\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2107).\n                testAndRemove(\"highway\", \"incline_steep\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2108).\n                testAndRemove(\"highway\", \"unsurfaced\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"unpaved\"));\n        checks.add(new DeprecationCheck(2109).\n                test(\"landuse\", \"wood\").\n                alternative(\"landuse\", \"forest\").\n                alternative(\"natural\", \"wood\"));\n        checks.add(new DeprecationCheck(2110).\n                testAndRemove(\"natural\", \"marsh\").\n                add(\"natural\", \"wetland\").\n                add(\"wetland\", \"marsh\"));\n        checks.add(new DeprecationCheck(2111).\n                test(\"highway\", \"byway\"));\n        checks.add(new DeprecationCheck(2112).\n                test(\"power_source\").\n                alternative(\"generator:source\"));\n        checks.add(new DeprecationCheck(2113).\n                test(\"power_rating\").\n                alternative(\"generator:output\"));\n    }","commit_id":"0d4e86ca0d1f3e7a97702c94b463829315a3bab0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Constructs a new {@code DeprecatedTags} test.\n     */\n    public DeprecatedTags() {\n        super(tr(\"Deprecated Tags\"), tr(\"Checks and corrects deprecated tags.\"));\n        checks.add(new DeprecationCheck(2101).\n                testAndRemove(\"barrier\", \"wire_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"chain_link\"));\n        checks.add(new DeprecationCheck(2102).\n                testAndRemove(\"barrier\", \"wood_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"wood\"));\n        checks.add(new DeprecationCheck(2103).\n                testAndRemove(\"highway\", \"ford\").\n                add(\"ford\", \"yes\"));\n        // from http://wiki.openstreetmap.org/wiki/Deprecated_features\n        checks.add(new DeprecationCheck(2104).\n                test(\"class\").\n                alternative(\"highway\"));\n        checks.add(new DeprecationCheck(2105).\n                testAndRemove(\"highway\", \"stile\").\n                add(\"barrier\", \"stile\"));\n        checks.add(new DeprecationCheck(2106).\n                testAndRemove(\"highway\", \"incline\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2107).\n                testAndRemove(\"highway\", \"incline_steep\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2108).\n                testAndRemove(\"highway\", \"unsurfaced\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"unpaved\"));\n        checks.add(new DeprecationCheck(2109).\n                test(\"landuse\", \"wood\").\n                alternative(\"landuse\", \"forest\").\n                alternative(\"natural\", \"wood\"));\n        checks.add(new DeprecationCheck(2110).\n                testAndRemove(\"natural\", \"marsh\").\n                add(\"natural\", \"wetland\").\n                add(\"wetland\", \"marsh\"));\n        checks.add(new DeprecationCheck(2111).\n                test(\"highway\", \"byway\"));\n        checks.add(new DeprecationCheck(2112).\n                test(\"power_source\").\n                alternative(\"generator:source\"));\n        checks.add(new DeprecationCheck(2113).\n                test(\"power_rating\").\n                alternative(\"generator:output\"));\n        // from http://wiki.openstreetmap.org/wiki/Tag:shop=organic\n        checks.add(new DeprecationCheck(2114).\n                testAndRemove(\"shop\", \"organic\").\n                add(\"shop\", \"supermarket\").\n                add(\"organic\", \"only\"));\n        // from http://wiki.openstreetmap.org/wiki/Key:bicycle_parking\n        checks.add(new DeprecationCheck(2115).\n                testAndRemove(\"bicycle_parking\", \"sheffield\").\n                add(\"bicycle_parking\", \"stands\"));\n        // http://wiki.openstreetmap.org/wiki/Tag:emergency=phone\n        checks.add(new DeprecationCheck(2116).\n                testAndRemove(\"amenity\", \"emergency_phone\").\n                add(\"emergency\", \"phone\"));\n        // fix #8132 - http://wiki.openstreetmap.org/wiki/Tag:sport=gaelic_football\n        checks.add(new DeprecationCheck(2117).\n                testAndRemove(\"sport\", \"gaelic_football\").\n                add(\"sport\", \"gaelic_games\"));\n        // see #8847 / #8961 - http://wiki.openstreetmap.org/wiki/Tag:power=station\n        checks.add(new DeprecationCheck(2118).\n                test(\"power\", \"station\").\n                alternative(\"power\", \"plant\").\n                alternative(\"power\", \"sub_station\"));\n        checks.add(new DeprecationCheck(2119).\n                testAndRemove(\"generator:method\", \"dam\").\n                add(\"generator:method\", \"water-storage\"));\n        checks.add(new DeprecationCheck(2120).\n                testAndRemove(\"generator:method\", \"pumped-storage\").\n                add(\"generator:method\", \"water-pumped-storage\"));\n        checks.add(new DeprecationCheck(2121).\n                testAndRemove(\"generator:method\", \"pumping\").\n                add(\"generator:method\", \"water-pumped-storage\"));\n        // see #8962 - http://wiki.openstreetmap.org/wiki/Key:fence_type\n        checks.add(new DeprecationCheck(2122).\n                test(\"fence_type\", \"chain\").\n                alternative(\"barrier\", \"chain\").\n                alternative(\"fence_type\", \"chain_link\"));\n        // see #9000 - http://wiki.openstreetmap.org/wiki/Key:entrance\n        checks.add(new DeprecationCheck(2123).\n                test(\"building\", \"entrance\").\n                alternative(\"entrance\"));\n        // see #9213 - Useless tag proposed in internal preset for years\n        checks.add(new DeprecationCheck(2124).\n                testAndRemove(\"board_type\", \"board\"));\n        // see #8434 - http://wiki.openstreetmap.org/wiki/Proposed_features/monitoring_station\n        checks.add(new DeprecationCheck(2125).\n                testAndRemove(\"man_made\", \"measurement_station\").\n                add(\"man_made\", \"monitoring_station\"));\n        checks.add(new DeprecationCheck(2126).\n                testAndRemove(\"measurement\", \"water_level\").\n                add(\"monitoring:water_level\", \"yes\"));\n        checks.add(new DeprecationCheck(2127).\n                testAndRemove(\"measurement\", \"weather\").\n                add(\"monitoring:weather\", \"yes\"));\n        checks.add(new DeprecationCheck(2128).\n                testAndRemove(\"measurement\", \"seismic\").\n                add(\"monitoring:seismic_activity\", \"yes\"));\n        checks.add(new DeprecationCheck(2129).\n                test(\"monitoring:river_level\").\n                alternative(\"monitoring:water_level\"));\n        // see #9365 - Useless tag layer=0\n        checks.add(new UnnecessaryTagCheck(2130).\n                testAndRemove(\"layer\", \"0\"));\n    }","id":79928,"modified_method":"/**\n     * Constructs a new {@code DeprecatedTags} test.\n     */\n    public DeprecatedTags() {\n        super(tr(\"Deprecated Tags\"), tr(\"Checks and corrects deprecated tags.\"));\n        checks.add(new DeprecationCheck(2101).\n                testAndRemove(\"barrier\", \"wire_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"chain_link\"));\n        checks.add(new DeprecationCheck(2102).\n                testAndRemove(\"barrier\", \"wood_fence\").\n                add(\"barrier\", \"fence\").\n                add(\"fence_type\", \"wood\"));\n        checks.add(new DeprecationCheck(2103).\n                testAndRemove(\"highway\", \"ford\").\n                add(\"ford\", \"yes\"));\n        // from http://wiki.openstreetmap.org/wiki/Deprecated_features\n        checks.add(new DeprecationCheck(2104).\n                test(\"class\").\n                alternative(\"highway\"));\n        checks.add(new DeprecationCheck(2105).\n                testAndRemove(\"highway\", \"stile\").\n                add(\"barrier\", \"stile\"));\n        checks.add(new DeprecationCheck(2106).\n                testAndRemove(\"highway\", \"incline\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2107).\n                testAndRemove(\"highway\", \"incline_steep\").\n                add(\"incline\", \"up\"));\n        checks.add(new DeprecationCheck(2108).\n                testAndRemove(\"highway\", \"unsurfaced\").\n                add(\"highway\", \"road\").\n                add(\"incline\", \"unpaved\"));\n        checks.add(new DeprecationCheck(2109).\n                test(\"landuse\", \"wood\").\n                alternative(\"landuse\", \"forest\").\n                alternative(\"natural\", \"wood\"));\n        checks.add(new DeprecationCheck(2110).\n                testAndRemove(\"natural\", \"marsh\").\n                add(\"natural\", \"wetland\").\n                add(\"wetland\", \"marsh\"));\n        checks.add(new DeprecationCheck(2111).\n                test(\"highway\", \"byway\"));\n        checks.add(new DeprecationCheck(2112).\n                test(\"power_source\").\n                alternative(\"generator:source\"));\n        checks.add(new DeprecationCheck(2113).\n                test(\"power_rating\").\n                alternative(\"generator:output\"));\n        // from http://wiki.openstreetmap.org/wiki/Tag:shop=organic\n        checks.add(new DeprecationCheck(2114).\n                testAndRemove(\"shop\", \"organic\").\n                add(\"shop\", \"supermarket\").\n                add(\"organic\", \"only\"));\n        // from http://wiki.openstreetmap.org/wiki/Key:bicycle_parking\n        checks.add(new DeprecationCheck(2115).\n                testAndRemove(\"bicycle_parking\", \"sheffield\").\n                add(\"bicycle_parking\", \"stands\"));\n        // http://wiki.openstreetmap.org/wiki/Tag:emergency=phone\n        checks.add(new DeprecationCheck(2116).\n                testAndRemove(\"amenity\", \"emergency_phone\").\n                add(\"emergency\", \"phone\"));\n        // fix #8132 - http://wiki.openstreetmap.org/wiki/Tag:sport=gaelic_football\n        checks.add(new DeprecationCheck(2117).\n                testAndRemove(\"sport\", \"gaelic_football\").\n                add(\"sport\", \"gaelic_games\"));\n        // see #8847 / #8961 - http://wiki.openstreetmap.org/wiki/Tag:power=station\n        checks.add(new DeprecationCheck(2118).\n                test(\"power\", \"station\").\n                alternative(\"power\", \"plant\").\n                alternative(\"power\", \"sub_station\"));\n        checks.add(new DeprecationCheck(2119).\n                testAndRemove(\"generator:method\", \"dam\").\n                add(\"generator:method\", \"water-storage\"));\n        checks.add(new DeprecationCheck(2120).\n                testAndRemove(\"generator:method\", \"pumped-storage\").\n                add(\"generator:method\", \"water-pumped-storage\"));\n        checks.add(new DeprecationCheck(2121).\n                testAndRemove(\"generator:method\", \"pumping\").\n                add(\"generator:method\", \"water-pumped-storage\"));\n        // see #8962 - http://wiki.openstreetmap.org/wiki/Key:fence_type\n        checks.add(new DeprecationCheck(2122).\n                test(\"fence_type\", \"chain\").\n                alternative(\"barrier\", \"chain\").\n                alternative(\"fence_type\", \"chain_link\"));\n        // see #9000 - http://wiki.openstreetmap.org/wiki/Key:entrance\n        checks.add(new DeprecationCheck(2123).\n                test(\"building\", \"entrance\").\n                alternative(\"entrance\"));\n        // see #9213 - Useless tag proposed in internal preset for years\n        checks.add(new DeprecationCheck(2124).\n                testAndRemove(\"board_type\", \"board\"));\n        // see #8434 - http://wiki.openstreetmap.org/wiki/Proposed_features/monitoring_station\n        checks.add(new DeprecationCheck(2125).\n                testAndRemove(\"man_made\", \"measurement_station\").\n                add(\"man_made\", \"monitoring_station\"));\n        checks.add(new DeprecationCheck(2126).\n                testAndRemove(\"measurement\", \"water_level\").\n                add(\"monitoring:water_level\", \"yes\"));\n        checks.add(new DeprecationCheck(2127).\n                testAndRemove(\"measurement\", \"weather\").\n                add(\"monitoring:weather\", \"yes\"));\n        checks.add(new DeprecationCheck(2128).\n                testAndRemove(\"measurement\", \"seismic\").\n                add(\"monitoring:seismic_activity\", \"yes\"));\n        checks.add(new DeprecationCheck(2129).\n                test(\"monitoring:river_level\").\n                alternative(\"monitoring:water_level\"));\n        // see #9365 - Useless tag layer=0\n        checks.add(new UnnecessaryTagCheck(2130).\n                testAndRemove(\"layer\", \"0\"));\n    }","commit_id":"c47cdfd9336ab96ee6c97459846d09a70a04ad22","url":"https://github.com/openstreetmap/josm"},{"original_method":"void launchServices(OperationContext context, PathAddress pathAddress, String connectorName, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        //TODO SASL and properties\n\n        final ServiceTarget target = context.getServiceTarget();\n\n        final ServiceName socketBindingName = SocketBinding.JBOSS_BINDING_NAME.append(ConnectorResource.SOCKET_BINDING.resolveModelAttribute(context, model).asString());\n        final OptionMap optionMap = ConnectorResource.getOptions(context, pathAddress);\n        RemotingServices.installConnectorServicesForSocketBinding(target, RemotingServices.SUBSYSTEM_ENDPOINT, connectorName, socketBindingName, optionMap, verificationHandler, newControllers);\n\n        //TODO AuthenticationHandler\n//\n//        final ConnectorService connectorService = new ConnectorService();\n//        connectorService.setOptionMap(createOptionMap(operation));\n//\n//        // Register the service with the container and inject dependencies.\n//        final ServiceName connectorName = RemotingServices.connectorServiceName(name);\n//        try {\n//            newControllers.add(target.addService(connectorName, connectorService)\n//                    .addDependency(connectorName.append(\"auth-provider\"), ServerAuthenticationProvider.class, connectorService.getAuthenticationProviderInjector())\n//                    .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, connectorService.getEndpointInjector())\n//                    .addListener(verificationHandler)\n//                    .setInitialMode(ServiceController.Mode.ACTIVE)\n//                    .install());\n//\n//            // TODO create XNIO connector service from socket-binding, with dependency on connectorName\n//        } catch (ServiceRegistryException e) {\n//            throw new OperationFailedException(new ModelNode().set(e.getLocalizedMessage()));\n//        }\n    }","id":79929,"modified_method":"void launchServices(OperationContext context, String connectorName, ModelNode fullModel, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        //TODO SASL and properties\n\n        OptionMap optionMap = ConnectorResource.getOptions(fullModel.get(CommonAttributes.PROPERTY));\n\n        final ServiceTarget target = context.getServiceTarget();\n\n        final ServiceName socketBindingName = SocketBinding.JBOSS_BINDING_NAME.append(ConnectorResource.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString());\n        RemotingServices.installConnectorServicesForSocketBinding(target, RemotingServices.SUBSYSTEM_ENDPOINT, connectorName, socketBindingName, optionMap, verificationHandler, newControllers);\n\n        //TODO AuthenticationHandler\n//\n//        final ConnectorService connectorService = new ConnectorService();\n//        connectorService.setOptionMap(createOptionMap(operation));\n//\n//        // Register the service with the container and inject dependencies.\n//        final ServiceName connectorName = RemotingServices.connectorServiceName(name);\n//        try {\n//            newControllers.add(target.addService(connectorName, connectorService)\n//                    .addDependency(connectorName.append(\"auth-provider\"), ServerAuthenticationProvider.class, connectorService.getAuthenticationProviderInjector())\n//                    .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, connectorService.getEndpointInjector())\n//                    .addListener(verificationHandler)\n//                    .setInitialMode(ServiceController.Mode.ACTIVE)\n//                    .install());\n//\n//            // TODO create XNIO connector service from socket-binding, with dependency on connectorName\n//        } catch (ServiceRegistryException e) {\n//            throw new OperationFailedException(new ModelNode().set(e.getLocalizedMessage()));\n//        }\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String connectorName = address.getLastElement().getValue();\n        ServiceName tmpDirPath = ServiceName.JBOSS.append(\"server\", \"path\", \"jboss.controller.temp.dir\");\n        final ServiceName securityRealm = model.hasDefined(SECURITY_REALM) ? SecurityRealmService.BASE_SERVICE_NAME\n                .append(model.require(SECURITY_REALM).asString()) : null;\n        RemotingServices.installSecurityServices(context.getServiceTarget(), connectorName, securityRealm, null, tmpDirPath, verificationHandler, newControllers);\n        launchServices(context, address, connectorName, model, verificationHandler, newControllers);\n    }","id":79930,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String connectorName = address.getLastElement().getValue();\n        ServiceName tmpDirPath = ServiceName.JBOSS.append(\"server\", \"path\", \"jboss.controller.temp.dir\");\n        final ServiceName securityRealm = model.hasDefined(SECURITY_REALM) ? SecurityRealmService.BASE_SERVICE_NAME\n                .append(model.require(SECURITY_REALM).asString()) : null;\n        final ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n\n        RemotingServices.installSecurityServices(context.getServiceTarget(), connectorName, securityRealm, null, tmpDirPath, verificationHandler, newControllers);\n        launchServices(context, connectorName, fullModel, verificationHandler, newControllers);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final ServiceController serviceController = installRuntimeService(context, model, verificationHandler);\n        newControllers.add(serviceController);\n    }","id":79931,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model,\n                                  ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers)\n            throws OperationFailedException {\n        final ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final ServiceController serviceController = installRuntimeService(context, operation, fullModel, verificationHandler);\n        newControllers.add(serviceController);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"ServiceController installRuntimeService(OperationContext context, ModelNode operation,\n                                            ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n        final PathAddress pathAddress = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final OptionMap connectionCreationOptions = ConnectorResource.getOptions(context, pathAddress);\n        final String connectionName = pathAddress.getLastElement().getValue();\n\n\n        //final OptionMap connectionCreationOptions = getConnectionCreationOptions(outboundConnection);\n        // Get the destination URI\n        final URI uri = getDestinationURI(context, operation);\n        // create the service\n        final GenericOutboundConnectionService outboundRemotingConnectionService = new GenericOutboundConnectionService(connectionName, uri, connectionCreationOptions);\n        final ServiceName serviceName = AbstractOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        // also add a alias service name to easily distinguish between a generic, remote and local type of connection services\n        final ServiceName aliasServiceName = GenericOutboundConnectionService.GENERIC_OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceBuilder<GenericOutboundConnectionService> svcBuilder = context.getServiceTarget().addService(serviceName, outboundRemotingConnectionService)\n                .addAliases(aliasServiceName)\n                .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, outboundRemotingConnectionService.getEnpointInjector());\n\n        if (verificationHandler != null) {\n            svcBuilder.addListener(verificationHandler);\n        }\n        return svcBuilder.install();\n    }","id":79932,"modified_method":"ServiceController installRuntimeService(final OperationContext context, final ModelNode operation, final ModelNode fullModel,\n                                            ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n\n        final PathAddress pathAddress = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String connectionName = pathAddress.getLastElement().getValue();\n        final OptionMap connectionCreationOptions = ConnectorResource.getOptions(fullModel.get(CommonAttributes.PROPERTY));\n\n\n        //final OptionMap connectionCreationOptions = getConnectionCreationOptions(outboundConnection);\n        // Get the destination URI\n        final URI uri = getDestinationURI(context, operation);\n        // create the service\n        final GenericOutboundConnectionService outboundRemotingConnectionService = new GenericOutboundConnectionService(connectionName, uri, connectionCreationOptions);\n        final ServiceName serviceName = AbstractOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        // also add a alias service name to easily distinguish between a generic, remote and local type of connection services\n        final ServiceName aliasServiceName = GenericOutboundConnectionService.GENERIC_OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceBuilder<GenericOutboundConnectionService> svcBuilder = context.getServiceTarget().addService(serviceName, outboundRemotingConnectionService)\n                .addAliases(aliasServiceName)\n                .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, outboundRemotingConnectionService.getEnpointInjector());\n\n        if (verificationHandler != null) {\n            svcBuilder.addListener(verificationHandler);\n        }\n        return svcBuilder.install();\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void recoverServices(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        GenericOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, null);\n    }","id":79933,"modified_method":"@Override\n    protected void recoverServices(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        GenericOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, model, null);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        applyModelToRuntime(context, operation, attributeName, restored);\n    }","id":79934,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        restored.get(attributeName).set(valueToRestore);\n        applyModelToRuntime(context, operation, attributeName, restored);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> voidHandbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        applyModelToRuntime(context, operation, attributeName, model);\n\n        return false;\n\n    }","id":79935,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> voidHandbackHolder) throws OperationFailedException {\n        final ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        applyModelToRuntime(context, operation, attributeName, fullModel);\n\n        return false;\n\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void applyModelToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode model) throws OperationFailedException {\n\n        final String connectionName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final ServiceName serviceName = GenericOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        ServiceController sc = registry.getService(serviceName);\n        if (sc != null && sc.getState() == ServiceController.State.UP) {\n            GenericOutboundConnectionService svc = GenericOutboundConnectionService.class.cast(sc.getValue());\n            if (GenericOutboundConnectionResourceDefinition.URI.getName().equals(attributeName)) {\n                svc.setDestination(GenericOutboundConnectionAdd.INSTANCE.getDestinationURI(context, model));\n            }\n        } else {\n            // Service isn't up so we can bounce it\n            context.removeService(serviceName); // safe even if the service doesn't exist\n            // install the service with new values\n            GenericOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, null);\n        }\n    }","id":79936,"modified_method":"private void applyModelToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode fullModel) throws OperationFailedException {\n\n        final String connectionName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final ServiceName serviceName = GenericOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        ServiceController sc = registry.getService(serviceName);\n        if (sc != null && sc.getState() == ServiceController.State.UP) {\n            GenericOutboundConnectionService svc = GenericOutboundConnectionService.class.cast(sc.getValue());\n            if (GenericOutboundConnectionResourceDefinition.URI.getName().equals(attributeName)) {\n                svc.setDestination(GenericOutboundConnectionAdd.INSTANCE.getDestinationURI(context, fullModel));\n            }\n        } else {\n            // Service isn't up so we can bounce it\n            context.removeService(serviceName); // safe even if the service doesn't exist\n            // install the service with new values\n            GenericOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, fullModel, null);\n        }\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final ServiceController serviceController = installRuntimeService(context, operation, verificationHandler);\n        newControllers.add(serviceController);\n    }","id":79937,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final ServiceController serviceController = installRuntimeService(context, operation, fullModel, verificationHandler);\n        newControllers.add(serviceController);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"ServiceController installRuntimeService(OperationContext context, ModelNode operation, ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n        final String connectionName = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final String outboundSocketBindingRef = LocalOutboundConnectionResourceDefinition.OUTBOUND_SOCKET_BINDING_REF.resolveModelAttribute(context, operation).asString();\n        final ServiceName outboundSocketBindingDependency = OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBindingRef);\n        // fetch the connection creation options from the model\n        final OptionMap connectionCreationOptions = getConnectionCreationOptions(context,operation);\n        // create the service\n        final LocalOutboundConnectionService outboundConnectionService = new LocalOutboundConnectionService(connectionName, connectionCreationOptions);\n        final ServiceName serviceName = AbstractOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        // also add a alias service name to easily distinguish between a generic, remote and local type of connection services\n        final ServiceName aliasServiceName = LocalOutboundConnectionService.LOCAL_OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceBuilder<LocalOutboundConnectionService> svcBuilder = context.getServiceTarget().addService(serviceName, outboundConnectionService)\n                .addAliases(aliasServiceName)\n                .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, outboundConnectionService.getEnpointInjector())\n                .addDependency(outboundSocketBindingDependency, OutboundSocketBinding.class, outboundConnectionService.getDestinationOutboundSocketBindingInjector());\n\n        if (verificationHandler != null) {\n            svcBuilder.addListener(verificationHandler);\n        }\n        return svcBuilder.install();\n    }","id":79938,"modified_method":"ServiceController installRuntimeService(final OperationContext context,final ModelNode operation,\n                                            final ModelNode fullModel, final ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR));\n        final String connectionName = address.getLastElement().getValue();\n        final String outboundSocketBindingRef = LocalOutboundConnectionResourceDefinition.OUTBOUND_SOCKET_BINDING_REF.resolveModelAttribute(context, operation).asString();\n        final ServiceName outboundSocketBindingDependency = OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBindingRef);\n        // fetch the connection creation options from the model\n        final OptionMap connectionCreationOptions = ConnectorResource.getOptions(fullModel.get(CommonAttributes.PROPERTY));\n        // create the service\n        final LocalOutboundConnectionService outboundConnectionService = new LocalOutboundConnectionService(connectionName, connectionCreationOptions);\n        final ServiceName serviceName = AbstractOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        // also add a alias service name to easily distinguish between a generic, remote and local type of connection services\n        final ServiceName aliasServiceName = LocalOutboundConnectionService.LOCAL_OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceBuilder<LocalOutboundConnectionService> svcBuilder = context.getServiceTarget().addService(serviceName, outboundConnectionService)\n                .addAliases(aliasServiceName)\n                .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, outboundConnectionService.getEnpointInjector())\n                .addDependency(outboundSocketBindingDependency, OutboundSocketBinding.class, outboundConnectionService.getDestinationOutboundSocketBindingInjector());\n\n        if (verificationHandler != null) {\n            svcBuilder.addListener(verificationHandler);\n        }\n        return svcBuilder.install();\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void recoverServices(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        LocalOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, null);\n    }","id":79939,"modified_method":"@Override\n    protected void recoverServices(final OperationContext context, final ModelNode operation, final ModelNode fullModel) throws OperationFailedException {\n        LocalOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, fullModel, null);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Boolean> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        boolean handback = applyModelToRuntime(context, operation, attributeName, model);\n        handbackHolder.setHandback(handback);\n        return handback;\n    }","id":79940,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Boolean> handbackHolder) throws OperationFailedException {\n        final ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        boolean handback = applyModelToRuntime(context, operation, fullModel);\n        handbackHolder.setHandback(handback);\n        return handback;\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Boolean handback) throws OperationFailedException {\n        if (handback != null && !handback.booleanValue()) {\n            final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n            restored.get(attributeName).set(valueToRestore);\n            applyModelToRuntime(context, operation, attributeName, restored);\n        } // else we didn't update the runtime in applyUpdateToRuntime\n    }","id":79941,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Boolean handback) throws OperationFailedException {\n        if (handback != null && !handback.booleanValue()) {\n            final ModelNode restored = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n            restored.get(attributeName).set(valueToRestore);\n            applyModelToRuntime(context, operation, restored);\n        } // else we didn't update the runtime in applyUpdateToRuntime\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean applyModelToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode model) throws OperationFailedException {\n\n        boolean reloadRequired = false;\n        final String connectionName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final ServiceName serviceName = LocalOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        ServiceController sc = registry.getService(serviceName);\n        if (sc != null && sc.getState() == ServiceController.State.UP) {\n                reloadRequired = true;\n        } else {\n            // Service isn't up so we can bounce it\n            context.removeService(serviceName); // safe even if the service doesn't exist\n            // install the service with new values\n            LocalOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, null);\n        }\n        return reloadRequired;\n    }","id":79942,"modified_method":"private boolean applyModelToRuntime(OperationContext context, ModelNode operation, ModelNode fullModel) throws OperationFailedException {\n\n        boolean reloadRequired = false;\n        final String connectionName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final ServiceName serviceName = LocalOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        ServiceController sc = registry.getService(serviceName);\n        if (sc != null && sc.getState() == ServiceController.State.UP) {\n                reloadRequired = true;\n        } else {\n            // Service isn't up so we can bounce it\n            context.removeService(serviceName); // safe even if the service doesn't exist\n            // install the service with new values\n            LocalOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, fullModel, null);\n        }\n        return reloadRequired;\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void recreateParentService(OperationContext context, PathAddress parentAddress, ModelNode parentModel,\n            ServiceVerificationHandler verificationHandler) {\n        try {\n            ConnectorAdd.INSTANCE.launchServices(context, parentAddress, parentAddress.getLastElement().getValue(), parentModel, verificationHandler, null);\n        } catch (OperationFailedException e) {\n            //TODO handle better?\n            throw new RuntimeException(e);\n        }\n    }","id":79943,"modified_method":"private static void recreateParentService(OperationContext context, PathAddress parentAddress, ModelNode parentModel,\n            ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n        ConnectorAdd.INSTANCE.launchServices(context, parentAddress.getLastElement().getValue(), parentModel, verificationHandler, null);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final ServiceController serviceController = installRuntimeService(context, operation, verificationHandler);\n        newControllers.add(serviceController);\n    }","id":79944,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final ServiceController serviceController = installRuntimeService(context, operation, fullModel, verificationHandler);\n        newControllers.add(serviceController);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"ServiceController installRuntimeService(OperationContext context, ModelNode operation,\n                                            ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n        final String connectionName = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n\n        final String outboundSocketBindingRef = RemoteOutboundConnnectionResourceDefinition.OUTBOUND_SOCKET_BINDING_REF.resolveModelAttribute(context, operation).asString();\n        final ServiceName outboundSocketBindingDependency = OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBindingRef);\n        // fetch the connection creation options from the model\n        final OptionMap connectionCreationOptions = getConnectionCreationOptions(context,operation);\n        // create the service\n        final RemoteOutboundConnectionService outboundConnectionService = new RemoteOutboundConnectionService(connectionName, connectionCreationOptions);\n        final ServiceName serviceName = AbstractOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        // also add a alias service name to easily distinguish between a generic, remote and local type of connection services\n        final ServiceName aliasServiceName = RemoteOutboundConnectionService.REMOTE_OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceBuilder<RemoteOutboundConnectionService> svcBuilder = context.getServiceTarget().addService(serviceName, outboundConnectionService)\n                .addAliases(aliasServiceName)\n                .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, outboundConnectionService.getEnpointInjector())\n                .addDependency(outboundSocketBindingDependency, OutboundSocketBinding.class, outboundConnectionService.getDestinationOutboundSocketBindingInjector());\n\n        if (verificationHandler != null) {\n            svcBuilder.addListener(verificationHandler);\n        }\n        return svcBuilder.install();\n\n    }","id":79945,"modified_method":"ServiceController installRuntimeService(final OperationContext context, final ModelNode operation, final ModelNode fullModel,\n                                            ServiceVerificationHandler verificationHandler) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR));\n        final String connectionName = address.getLastElement().getValue();\n\n        final String outboundSocketBindingRef = RemoteOutboundConnnectionResourceDefinition.OUTBOUND_SOCKET_BINDING_REF.resolveModelAttribute(context, operation).asString();\n        final ServiceName outboundSocketBindingDependency = OutboundSocketBinding.OUTBOUND_SOCKET_BINDING_BASE_SERVICE_NAME.append(outboundSocketBindingRef);\n        // fetch the connection creation options from the model\n        final OptionMap connectionCreationOptions = ConnectorResource.getOptions(fullModel.get(CommonAttributes.PROPERTY));\n        // create the service\n        final RemoteOutboundConnectionService outboundConnectionService = new RemoteOutboundConnectionService(connectionName, connectionCreationOptions);\n        final ServiceName serviceName = AbstractOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        // also add a alias service name to easily distinguish between a generic, remote and local type of connection services\n        final ServiceName aliasServiceName = RemoteOutboundConnectionService.REMOTE_OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceBuilder<RemoteOutboundConnectionService> svcBuilder = context.getServiceTarget().addService(serviceName, outboundConnectionService)\n                .addAliases(aliasServiceName)\n                .addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, outboundConnectionService.getEnpointInjector())\n                .addDependency(outboundSocketBindingDependency, OutboundSocketBinding.class, outboundConnectionService.getDestinationOutboundSocketBindingInjector());\n\n        if (verificationHandler != null) {\n            svcBuilder.addListener(verificationHandler);\n        }\n        return svcBuilder.install();\n\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void recoverServices(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        RemoteOutboundConnectionAdd.INSTANCE.installRuntimeService(context,  model, null);\n    }","id":79946,"modified_method":"@Override\n    protected void recoverServices(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        RemoteOutboundConnectionAdd.INSTANCE.installRuntimeService(context,  operation, model, null);\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Boolean> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        boolean handback = applyModelToRuntime(context, operation, attributeName, model);\n        handbackHolder.setHandback(handback);\n        return handback;\n\n    }","id":79947,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Boolean> handbackHolder) throws OperationFailedException {\n        final ModelNode model = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        boolean handback = applyModelToRuntime(context, operation, model);\n        handbackHolder.setHandback(handback);\n        return handback;\n\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Boolean handback) throws OperationFailedException {\n        if (handback != null && !handback.booleanValue()) {\n            final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n            restored.get(attributeName).set(valueToRestore);\n            applyModelToRuntime(context, operation, attributeName, restored);\n        }\n    }","id":79948,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Boolean handback) throws OperationFailedException {\n        if (handback != null && !handback.booleanValue()) {\n            final ModelNode restored = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n            restored.get(attributeName).set(valueToRestore);\n            applyModelToRuntime(context, operation, restored);\n        }\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"private boolean applyModelToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode model) throws OperationFailedException {\n\n        boolean reloadRequired = false;\n        final String connectionName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final ServiceName serviceName = RemoteOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        ServiceController sc = registry.getService(serviceName);\n        if (sc != null && sc.getState() == ServiceController.State.UP) {\n            reloadRequired = true;\n        } else {\n            // Service isn't up so we can bounce it\n            context.removeService(serviceName); // safe even if the service doesn't exist\n            // install the service with new values\n            RemoteOutboundConnectionAdd.INSTANCE.installRuntimeService(context, model, null);\n        }\n\n        return reloadRequired;\n    }","id":79949,"modified_method":"private boolean applyModelToRuntime(OperationContext context, ModelNode operation, ModelNode fullModel) throws OperationFailedException {\n\n        boolean reloadRequired = false;\n        final String connectionName = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        final ServiceName serviceName = RemoteOutboundConnectionService.OUTBOUND_CONNECTION_BASE_SERVICE_NAME.append(connectionName);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        ServiceController sc = registry.getService(serviceName);\n        if (sc != null && sc.getState() == ServiceController.State.UP) {\n            reloadRequired = true;\n        } else {\n            // Service isn't up so we can bounce it\n            context.removeService(serviceName); // safe even if the service doesn't exist\n            // install the service with new values\n            RemoteOutboundConnectionAdd.INSTANCE.installRuntimeService(context, operation, fullModel, null);\n        }\n\n        return reloadRequired;\n    }","commit_id":"8a046071c568bd7559c14d52525d3711b1243c87","url":"https://github.com/wildfly/wildfly"},{"original_method":"public boolean deleteModule(final Module module) {\n    return doRemoveModule(getModuleEditor(module));\n  }","id":79950,"modified_method":"public boolean deleteModule(final Module module) {\n    ModuleEditor moduleEditor = getModuleEditor(module);\n    if (moduleEditor == null) return true;\n    return doRemoveModule(moduleEditor);\n  }","commit_id":"89c24a457ce8f54977e3f7e76d53f672a244bba7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n      final NamedConfigurable namedConfigurable = getSelectedConfugurable();\n      if (namedConfigurable instanceof ModuleConfigurable) {\n        try {\n          final String modulePresentation = IdeBundle.message(\"project.new.wizard.module.identification\");\n          final NamePathComponent component = new NamePathComponent(IdeBundle.message(\"label.project.name\"), IdeBundle.message(\n            \"label.component.file.location\", StringUtil.capitalize(modulePresentation)), IdeBundle.message(\n            \"title.select.project.file.directory\", modulePresentation), IdeBundle.message(\"description.select.project.file.directory\",\n                                                                                          StringUtil.capitalize(modulePresentation)), true, false);\n          final DialogWrapper copyModuleDialog = new DialogWrapper(myTree, false) {\n            {\n              setTitle(ProjectBundle.message(\"copy.module.dialog.title\"));\n              init();\n            }\n\n            public JComponent getPreferredFocusedComponent() {\n              return component.getNameComponent();\n            }\n\n            @Nullable\n            protected JComponent createCenterPanel() {\n              return component;\n            }\n\n            protected void doOKAction() {\n              if (component.getNameValue().length() == 0) {\n                Messages.showErrorDialog(ProjectBundle.message(\"enter.module.copy.name.error.message\"), CommonBundle.message(\"title.error\"));\n                return;\n              }\n\n              if (component.getPath().length() == 0) {\n                Messages.showErrorDialog(IdeBundle.message(\"prompt.enter.project.file.location\", modulePresentation),\n                                         CommonBundle.message(\"title.error\"));\n                return;\n              }\n              if (!ProjectWizardUtil\n                 .createDirectoryIfNotExists(IdeBundle.message(\"directory.project.file.directory\", modulePresentation), component.getPath(), true)) {\n                Messages.showErrorDialog(ProjectBundle.message(\"path.0.is.invalid.error.message\", component.getPath()), CommonBundle.message(\"title.error\"));\n                 return;\n              }\n              super.doOKAction();\n            }\n          };\n          copyModuleDialog.show();\n          if (!copyModuleDialog.isOK()) return;\n          final ModifiableRootModel rootModel = ((ModuleConfigurable)namedConfigurable).getModuleEditor().getModifiableRootModel();\n          final String path = component.getPath();\n          final ModuleBuilder builder = new ModuleBuilder() {\n            public void setupRootModel(final ModifiableRootModel modifiableRootModel) throws ConfigurationException {\n              if (rootModel.isSdkInherited()) {\n                modifiableRootModel.inheritSdk();\n              }\n              else {\n                modifiableRootModel.setSdk(rootModel.getSdk());\n              }\n\n              modifiableRootModel.getModuleExtension(CompilerModuleExtension.class).inheritCompilerOutputPath(true);\n\n              modifiableRootModel.getModuleExtension(LanguageLevelModuleExtension.class).setLanguageLevel(LanguageLevelModuleExtension.getInstance(rootModel.getModule()).getLanguageLevel());\n\n              for (OrderEntry entry : rootModel.getOrderEntries()) {\n                if (entry instanceof JdkOrderEntry) continue;\n                if (entry instanceof ModuleSourceOrderEntry) continue;\n                if (entry instanceof ClonableOrderEntry) {\n                  modifiableRootModel.addOrderEntry(((ClonableOrderEntry)entry).cloneEntry((RootModelImpl)modifiableRootModel,\n                                                                                           (ProjectRootManagerImpl)ProjectRootManager\n                                                                                             .getInstance(myProject),\n                                                                                           VirtualFilePointerManager.getInstance()));\n                }\n              }\n\n              VirtualFile content = LocalFileSystem.getInstance().findFileByPath(component.getPath());\n              if (content == null) {\n                content = LocalFileSystem.getInstance().refreshAndFindFileByPath(component.getPath());\n              }\n              modifiableRootModel.addContentEntry(content);\n            }\n\n            public ModuleType getModuleType() {\n              return ModuleType.get(rootModel.getModule());\n            }\n          };\n          builder.setName(component.getNameValue());\n          builder.setModuleFilePath(path + \"/\" + builder.getName() + ModuleFileType.DOT_DEFAULT_EXTENSION);\n          final Module module = myContext.myModulesConfigurator.addModule(builder);\n          if (module != null) {\n            addModuleNode(module);\n          }\n        }\n        catch (Exception e1) {\n          LOG.error(e1);\n        }\n      }\n      else {\n        copyByExtension(namedConfigurable);\n      }\n    }","id":79951,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n      final NamedConfigurable namedConfigurable = getSelectedConfugurable();\n      if (namedConfigurable instanceof ModuleConfigurable) {\n        try {\n          final ModuleEditor moduleEditor = ((ModuleConfigurable)namedConfigurable).getModuleEditor();\n          final String modulePresentation = IdeBundle.message(\"project.new.wizard.module.identification\");\n          final NamePathComponent component = new NamePathComponent(IdeBundle.message(\"label.module.name\"), IdeBundle.message(\"label.component.file.location\", StringUtil.capitalize(modulePresentation)), IdeBundle.message(\"title.select.project.file.directory\", modulePresentation),\n                                                                    IdeBundle.message(\"description.select.project.file.directory\", StringUtil.capitalize(modulePresentation)), true,\n                                                                    false);\n          final Module originalModule = moduleEditor.getModule();\n          if (originalModule != null) {\n            component.setPath(PathUtil.getParentPath(originalModule.getModuleFilePath()));\n          }\n\n          final DialogBuilder dialogBuilder = new DialogBuilder(myTree);\n          dialogBuilder.setTitle(ProjectBundle.message(\"copy.module.dialog.title\"));\n          dialogBuilder.setCenterPanel(component);\n          dialogBuilder.setPreferedFocusComponent(component.getNameComponent());\n          dialogBuilder.setOkOperation(new Runnable() {\n            @Override\n            public void run() {\n              if (component.getNameValue().length() == 0) {\n                Messages.showErrorDialog(ProjectBundle.message(\"enter.module.copy.name.error.message\"), CommonBundle.message(\"title.error\"));\n                return;\n              }\n\n              if (component.getPath().length() == 0) {\n                Messages.showErrorDialog(IdeBundle.message(\"prompt.enter.project.file.location\", modulePresentation),\n                                         CommonBundle.message(\"title.error\"));\n                return;\n              }\n              if (!ProjectWizardUtil\n                 .createDirectoryIfNotExists(IdeBundle.message(\"directory.project.file.directory\", modulePresentation), component.getPath(),\n                                             true)) {\n                Messages.showErrorDialog(ProjectBundle.message(\"path.0.is.invalid.error.message\", component.getPath()), CommonBundle.message(\"title.error\"));\n                 return;\n              }\n              dialogBuilder.getDialogWrapper().close(DialogWrapper.OK_EXIT_CODE);\n            }\n          });\n          if (dialogBuilder.show() != DialogWrapper.OK_EXIT_CODE) return;\n\n          final ModifiableRootModel rootModel = moduleEditor.getModifiableRootModel();\n          final String path = component.getPath();\n          final ModuleBuilder builder = new ModuleBuilder() {\n            public void setupRootModel(final ModifiableRootModel modifiableRootModel) throws ConfigurationException {\n              if (rootModel.isSdkInherited()) {\n                modifiableRootModel.inheritSdk();\n              }\n              else {\n                modifiableRootModel.setSdk(rootModel.getSdk());\n              }\n\n              modifiableRootModel.getModuleExtension(CompilerModuleExtension.class).inheritCompilerOutputPath(true);\n\n              modifiableRootModel.getModuleExtension(LanguageLevelModuleExtension.class).setLanguageLevel(LanguageLevelModuleExtension.getInstance(rootModel.getModule()).getLanguageLevel());\n\n              for (OrderEntry entry : rootModel.getOrderEntries()) {\n                if (entry instanceof JdkOrderEntry) continue;\n                if (entry instanceof ModuleSourceOrderEntry) continue;\n                if (entry instanceof ClonableOrderEntry) {\n                  modifiableRootModel.addOrderEntry(((ClonableOrderEntry)entry).cloneEntry((RootModelImpl)modifiableRootModel,\n                                                                                           (ProjectRootManagerImpl)ProjectRootManager\n                                                                                             .getInstance(myProject),\n                                                                                           VirtualFilePointerManager.getInstance()));\n                }\n              }\n\n              VirtualFile content = LocalFileSystem.getInstance().findFileByPath(component.getPath());\n              if (content == null) {\n                content = LocalFileSystem.getInstance().refreshAndFindFileByPath(component.getPath());\n              }\n              modifiableRootModel.addContentEntry(content);\n            }\n\n            public ModuleType getModuleType() {\n              return ModuleType.get(rootModel.getModule());\n            }\n          };\n          builder.setName(component.getNameValue());\n          builder.setModuleFilePath(path + \"/\" + builder.getName() + ModuleFileType.DOT_DEFAULT_EXTENSION);\n          final Module module = myContext.myModulesConfigurator.addModule(builder);\n          if (module != null) {\n            addModuleNode(module);\n          }\n        }\n        catch (Exception e1) {\n          LOG.error(e1);\n        }\n      }\n      else {\n        copyByExtension(namedConfigurable);\n      }\n    }","commit_id":"0d6d73347339450bb0631dc32189913946a89762","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void queryPlace(@NotNull final Place place) {\n    getModuleEditor().queryPlace(place);\n  }","id":79952,"modified_method":"public void queryPlace(@NotNull final Place place) {\n    final ModuleEditor editor = getModuleEditor();\n    if (editor != null) {\n      editor.queryPlace(place);\n    }\n  }","commit_id":"5773cfee847f0326121dfd2db524adb1be8b6f08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  @NonNls\n  public String getHelpTopic() {\n    final ModuleEditor moduleEditor = getModuleEditor();\n    return moduleEditor != null ? moduleEditor.getHelpTopic() : null;\n  }","id":79953,"modified_method":"@Override\n  @Nullable\n  @NonNls\n  public String getHelpTopic() {\n    ModuleEditor editor = getModuleEditor();\n    return editor == null ? null : editor.getHelpTopic();\n  }","commit_id":"5b9f5442807443e89ee9bc608b540ff662b7ca96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public JComponent createOptionsPanel() {\n    return getModuleEditor().getPanel();\n  }","id":79954,"modified_method":"@Override\n  public JComponent createOptionsPanel() {\n    ModuleEditor editor = getModuleEditor();\n    return editor == null ? null : editor.getPanel();\n  }","commit_id":"5b9f5442807443e89ee9bc608b540ff662b7ca96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public ActionCallback navigateTo(@Nullable final Place place, final boolean requestFocus) {\n    return getModuleEditor().navigateTo(place, requestFocus);\n  }","id":79955,"modified_method":"@Override\n  public ActionCallback navigateTo(@Nullable final Place place, final boolean requestFocus) {\n    ModuleEditor editor = getModuleEditor();\n    return editor == null ? ActionCallback.REJECTED : editor.navigateTo(place, requestFocus);\n  }","commit_id":"5b9f5442807443e89ee9bc608b540ff662b7ca96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean shouldExecuteOnProject(Project project) {\n    return project.getFileSystem().hasJavaSourceFiles()\n        && !profile.getActiveRulesByRepository(FindbugsConstants.REPOSITORY_KEY).isEmpty();\n  }","id":79956,"modified_method":"public boolean shouldExecuteOnProject(Project project) {\n    return Java.KEY.equals(project.getLanguageKey())\n      && !project.getFileSystem().mainFiles(Java.KEY).isEmpty()\n      && !profile.getActiveRulesByRepository(FindbugsConstants.REPOSITORY_KEY).isEmpty();\n  }","commit_id":"7be34e5e7f9d555da901fb70d36b6effa58f1933","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private File saveXmlFile() {\n    try {\n      StringWriter pmdConfiguration = new StringWriter();\n      pmdProfileExporter.exportProfile(rulesProfile, pmdConfiguration);\n      return project.getFileSystem().writeToWorkingDirectory(pmdConfiguration.toString(), \"pmd.xml\");\n\n    } catch (IOException e) {\n      throw new RuntimeException(\"Fail to save the PMD configuration\", e);\n    }\n  }","id":79957,"modified_method":"private File saveXmlFile() {\n    try {\n      StringWriter pmdConfiguration = new StringWriter();\n      pmdProfileExporter.exportProfile(rulesProfile, pmdConfiguration);\n      return project.getFileSystem().writeToWorkingDirectory(pmdConfiguration.toString(), \"pmd.xml\");\n\n    } catch (IOException e) {\n      throw new SonarException(\"Fail to save the PMD configuration\", e);\n    }\n  }","commit_id":"e563e04cbdce81b04ad09e9ca1212a031846a12a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private InputStream openRuleset(String rulesetPath) {\n    try {\n      File file = new File(rulesetPath);\n      boolean found;\n      if (file.exists()) {\n        found = true;\n      } else {\n        file = new File(project.getFileSystem().getBasedir(), rulesetPath);\n        found = file.exists();\n      }\n      if (found) {\n        return new FileInputStream(file);\n      }\n      InputStream stream = getClass().getResourceAsStream(rulesetPath);\n      if (stream == null) {\n        throw new RuntimeException(\"The PMD ruleset can not be found: \" + rulesetPath);\n      }\n      return stream;\n\n    } catch (FileNotFoundException e) {\n      throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath, e);\n    }\n  }","id":79958,"modified_method":"private InputStream openRuleset(String rulesetPath) {\n    try {\n      File file = new File(rulesetPath);\n      boolean found;\n      if (file.exists()) {\n        found = true;\n      } else {\n        file = new File(project.getFileSystem().getBasedir(), rulesetPath);\n        found = file.exists();\n      }\n      if (found) {\n        return new FileInputStream(file);\n      }\n      InputStream stream = getClass().getResourceAsStream(rulesetPath);\n      if (stream == null) {\n        throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath);\n      }\n      return stream;\n\n    } catch (FileNotFoundException e) {\n      throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath, e);\n    }\n  }","commit_id":"e563e04cbdce81b04ad09e9ca1212a031846a12a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean shouldExecuteOnProject(Project project) {\n    return project.getFileSystem().hasJavaSourceFiles() &&\n        !profile.getActiveRulesByRepository(PmdConstants.REPOSITORY_KEY).isEmpty();\n  }","id":79959,"modified_method":"public boolean shouldExecuteOnProject(Project project) {\n    return !project.getFileSystem().mainFiles(Java.KEY).isEmpty() &&\n      !profile.getActiveRulesByRepository(PmdConstants.REPOSITORY_KEY).isEmpty();\n  }","commit_id":"e563e04cbdce81b04ad09e9ca1212a031846a12a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean shouldExecuteOnProject(Project project) {\n    return project.getFileSystem().hasJavaSourceFiles() &&\n        !profile.getActiveRulesByRepository(CheckstyleConstants.REPOSITORY_KEY).isEmpty();\n  }","id":79960,"modified_method":"public boolean shouldExecuteOnProject(Project project) {\n    return !project.getFileSystem().mainFiles(Java.KEY).isEmpty() &&\n        !profile.getActiveRulesByRepository(CheckstyleConstants.REPOSITORY_KEY).isEmpty();\n  }","commit_id":"2a93969813f040f9072fe261ac94f1c9b65738bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public boolean shouldExecuteOnProject(Project project) {\n    return project.getAnalysisType().equals(Project.AnalysisType.DYNAMIC) && project.getFileSystem().hasTestFiles(Java.INSTANCE);\n  }","id":79961,"modified_method":"@Override\n  public boolean shouldExecuteOnProject(Project project) {\n    return project.getAnalysisType().equals(Project.AnalysisType.DYNAMIC)\n      && !project.getFileSystem().testFiles(Java.KEY).isEmpty();\n  }","commit_id":"2a93969813f040f9072fe261ac94f1c9b65738bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldExecuteMaven() {\n    Project project = mockProject();\n    when(project.getFileSystem().hasTestFiles(argThat(is(Java.INSTANCE)))).thenReturn(true);\n    when(project.getAnalysisType()).thenReturn(Project.AnalysisType.DYNAMIC);\n\n    assertThat(initializer.shouldExecuteOnProject(project), is(true));\n    assertThat(initializer.getMavenPluginHandler(project), instanceOf(JaCoCoMavenPluginHandler.class));\n  }","id":79962,"modified_method":"@Test\n  public void shouldExecuteMaven() {\n    Project project = mockProject();\n    InputFile inputFile = mock(InputFile.class);\n    when(project.getFileSystem().testFiles(Java.KEY)).thenReturn(Collections.singletonList(inputFile));\n    when(project.getAnalysisType()).thenReturn(Project.AnalysisType.DYNAMIC);\n\n    assertThat(initializer.shouldExecuteOnProject(project), is(true));\n    assertThat(initializer.getMavenPluginHandler(project), instanceOf(JaCoCoMavenPluginHandler.class));\n  }","commit_id":"2a93969813f040f9072fe261ac94f1c9b65738bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotExecuteMavenWhenReuseReports() {\n    Project project = mockProject();\n    when(project.getFileSystem().hasTestFiles(argThat(is(Java.INSTANCE)))).thenReturn(true);\n    when(project.getAnalysisType()).thenReturn(Project.AnalysisType.REUSE_REPORTS);\n\n    assertThat(initializer.shouldExecuteOnProject(project), is(false));\n  }","id":79963,"modified_method":"@Test\n  public void shouldNotExecuteMavenWhenReuseReports() {\n    Project project = mockProject();\n    InputFile inputFile = mock(InputFile.class);\n    when(project.getFileSystem().testFiles(Java.KEY)).thenReturn(Collections.singletonList(inputFile));\n    when(project.getAnalysisType()).thenReturn(Project.AnalysisType.REUSE_REPORTS);\n\n    assertThat(initializer.shouldExecuteOnProject(project), is(false));\n  }","commit_id":"2a93969813f040f9072fe261ac94f1c9b65738bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private InputStream openRuleset(String rulesetPath) {\n    try {\n      File file = new File(rulesetPath);\n      boolean found;\n      if (file.exists()) {\n        found = true;\n      } else {\n        file = new File(project.getFileSystem().getBasedir(), rulesetPath);\n        found = file.exists();\n      }\n      if (found) {\n        return new FileInputStream(file);\n      }\n      InputStream stream = getClass().getResourceAsStream(rulesetPath);\n      if (stream == null) {\n        throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath);\n      }\n      return stream;\n\n    } catch (FileNotFoundException e) {\n      throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath, e);\n    }\n  }","id":79964,"modified_method":"private InputStream openRuleset(String rulesetPath) {\n    try {\n      File file = new File(rulesetPath);\n      boolean found;\n      if (file.exists()) {\n        found = true;\n      } else {\n        file = new File(project.getFileSystem().getBasedir(), rulesetPath);\n        found = file.exists();\n      }\n      if (found) {\n        return new FileInputStream(file);\n      }\n      InputStream stream = PmdExecutor.class.getResourceAsStream(rulesetPath);\n      if (stream == null) {\n        throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath);\n      }\n      return stream;\n\n    } catch (FileNotFoundException e) {\n      throw new SonarException(\"The PMD ruleset can not be found: \" + rulesetPath, e);\n    }\n  }","commit_id":"2a93969813f040f9072fe261ac94f1c9b65738bb","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public boolean shouldExecuteOnProject(Project project) {\n    return project.getAnalysisType().isDynamic(true) &&\n        project.getFileSystem().hasJavaSourceFiles();\n  }","id":79965,"modified_method":"@Override\n  public boolean shouldExecuteOnProject(Project project) {\n    return project.getAnalysisType().isDynamic(true) &&\n        !project.getFileSystem().mainFiles(Java.KEY).isEmpty();\n  }","commit_id":"c881206bd9f2edfd6a5586ec735d003bd73d367d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean shouldExecuteOnProject(Project project) {\n    return project.getFileSystem().hasJavaSourceFiles();\n  }","id":79966,"modified_method":"public boolean shouldExecuteOnProject(Project project) {\n    return !project.getFileSystem().mainFiles(Java.KEY).isEmpty();\n  }","commit_id":"c881206bd9f2edfd6a5586ec735d003bd73d367d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public HashedSequence(S base, int[] hashes) {\n    this.base = base;\n    this.hashes = hashes;\n  }","id":79967,"modified_method":"private HashedSequence(S base, int[] hashes) {\n    this.base = base;\n    this.hashes = hashes;\n  }","commit_id":"c881206bd9f2edfd6a5586ec735d003bd73d367d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private ViolationTrackingBlocksRecognizer(StringText a, StringText b, StringTextComparator cmp) {\n    this.a = wrap(a, cmp);\n    this.b = wrap(b, cmp);\n    this.cmp = new HashedSequenceComparator<StringText>(cmp);\n  }","id":79968,"modified_method":"private ViolationTrackingBlocksRecognizer(StringText a, StringText b, StringTextComparator cmp) {\n    this.a = HashedSequence.wrap(a, cmp);\n    this.b = HashedSequence.wrap(b, cmp);\n    this.cmp = new HashedSequenceComparator<StringText>(cmp);\n  }","commit_id":"c881206bd9f2edfd6a5586ec735d003bd73d367d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static public CMJob make(final RFModel model, final int modelSize, final Key datakey, final int classcol, final double[] classWt, final boolean computeOOB) {\n    // Create a unique key for given RFModel, validation data and parameters\n    final Key cmKey = keyForCM(model._selfKey, modelSize, datakey, classcol, computeOOB);\n    // Start a new job\n    final CMJob cmJob = new CMJob(\"CM computation\", cmKey, modelSize);\n    // and start a new confusion matrix computation\n    H2OCountedCompleter fjtask = new H2OCountedCompleter() {\n\n      @Override public void compute2() {\n        Key key = cmJob.dest();\n        Value val = DKV.DputIfMatch(key, new Value(key, CMFinal.make()), null, null);\n        // Reuse cached results\n        if (val == null) {\n          ConfusionTask cmTask = new ConfusionTask(cmJob, model, modelSize, datakey, classcol, classWt, computeOOB);\n          cmTask.invoke(datakey); // Invoke and wait for completion\n          // Create final matrix\n          CMFinal cmResult = CMFinal.make(cmTask._matrix, model, cmTask.domain(), cmTask._errorsPerTree, computeOOB);\n          // Overwrite the dummy result\n          CMFinal.updateDKV(cmJob.dest(), cmResult);\n        }\n        // Remove this jobs - it already finished or it was useless\n        cmJob.remove();\n        tryComplete();\n      }\n\n      @Override public boolean onExceptionalCompletion(Throwable ex, CountedCompleter caller) {\n        cmJob.onException(ex);\n        return super.onExceptionalCompletion(ex, caller);\n      }\n    };\n\n    H2O.submitTask(cmJob.start(fjtask));\n\n    return cmJob;\n  }","id":79969,"modified_method":"static public CMJob make(final RFModel model, final int modelSize, final Key datakey, final int classcol, final double[] classWt, final boolean computeOOB) {\n    // Create a unique key for CM regarding given RFModel, validation data and parameters\n    final Key cmKey = keyForCM(model._selfKey, modelSize, datakey, classcol, computeOOB);\n    // Start a new job if CM is not yet computed\n    final Value dummyCMVal = new Value(cmKey, CMFinal.make());\n    final Value val = DKV.DputIfMatch(cmKey, dummyCMVal, null, null);\n    System.err.println(cmKey + \" : val = \" + (val != null ? val.<CMFinal>get().toString() : \"NULL\"));\n    if (val==null) {\n      final CMJob cmJob = new CMJob(\"CM computation\", cmKey, modelSize);\n      // and start a new confusion matrix computation\n      H2OCountedCompleter fjtask = new H2OCountedCompleter() {\n        @Override public void compute2() {\n          ConfusionTask cmTask = new ConfusionTask(cmJob, model, modelSize, datakey, classcol, classWt, computeOOB);\n          cmTask.invoke(datakey); // Invoke and wait for completion\n          // Create final matrix\n          CMFinal cmResult = CMFinal.make(cmTask._matrix, model, cmTask.domain(), cmTask._errorsPerTree, computeOOB);\n          // Atomically overwrite the dummy result\n          // Doing update via atomic is a bad idea since it can be overwritten by DputIfMatch above - CMFinal.updateDKV(cmJob.dest(), cmResult);\n          // Rather do it directly\n          Value oldVal = DKV.DputIfMatch(cmKey, new Value(cmKey, cmResult), dummyCMVal, null);\n          // Be sure that nobody overwrite the value since I am only one writter\n          assert oldVal == dummyCMVal;\n          // Remove this jobs - it already finished or it was useless\n          cmJob.remove();\n          tryComplete();\n        }\n        @Override public boolean onExceptionalCompletion(Throwable ex, CountedCompleter caller) {\n          cmJob.onException(ex);\n          return super.onExceptionalCompletion(ex, caller);\n        }\n      };\n      H2O.submitTask(cmJob.start(fjtask));\n      return cmJob;\n    } else {\n      // We should return Job which is/was computing the CM with given cmKey\n      return (CMJob) Job.findJobByDest(cmKey);\n    }\n  }","commit_id":"3d8a326d5757c37308ce626ba6ea0390b2fe331d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Split bestCol( UndecidedNode u, DHistogram hs[] ) {\n      // Find the column with the best split (lowest score).  Unlike RF, DRF\n      // scores on all columns and selects splits on all columns.\n      DTree.Split best = new DTree.Split(-1,-1,null,(byte)0,Double.MAX_VALUE,Double.MAX_VALUE,Double.MAX_VALUE,0L,0L,0,0);\n      if( hs == null ) return best;\n      final int maxCols = u._scoreCols == null /* all cols */ ? hs.length : u._scoreCols.length;\n      FindSplits[] findSplits = new FindSplits[maxCols];\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        findSplits[i] = new FindSplits(hs, col);\n        H2O.submitTask(findSplits[i]);\n      }\n      for( int i=0; i<maxCols; i++ ) {\n        if (findSplits[i]==null) continue;\n        findSplits[i].join();\n        DTree.Split s = findSplits[i]._s;\n        if( s == null ) continue;\n        if (s.se() < best.se()) best = s;\n      }\n      return best;\n    }","id":79970,"modified_method":"public Split bestCol( UndecidedNode u, DHistogram hs[] ) {\n      // Find the column with the best split (lowest score).  Unlike RF, DRF\n      // scores on all columns and selects splits on all columns.\n      DTree.Split best = new DTree.Split(-1,-1,null,(byte)0,Double.MAX_VALUE,Double.MAX_VALUE,Double.MAX_VALUE,0L,0L,0,0);\n      if( hs == null ) return best;\n      final int maxCols = u._scoreCols == null /* all cols */ ? hs.length : u._scoreCols.length;\n      FindSplits[] findSplits = new FindSplits[maxCols];\n      //total work is to find the best split across sum_over_cols_to_split(nbins)\n      long nbinsSum = 0;\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        nbinsSum += hs[col].nbins();\n      }\n      // for small work loads, do a serial loop, otherwise, submit work to FJ thread pool\n      final boolean isSmall = (nbinsSum <= 1024); //heuristic - 50 cols with 20 nbins, or 1 column with 1024 bins, etc.\n      for( int i=0; i<maxCols; i++ ) {\n        int col = u._scoreCols == null ? i : u._scoreCols[i];\n        if( hs[col]==null || hs[col].nbins() <= 1 ) continue;\n        findSplits[i] = new FindSplits(hs, col);\n        if (isSmall) findSplits[i].compute2();\n        else H2O.submitTask(findSplits[i]);\n      }\n      for( int i=0; i<maxCols; i++ ) {\n        if (findSplits[i]==null) continue;\n        findSplits[i].join();\n        DTree.Split s = findSplits[i]._s;\n        if( s == null ) continue;\n        if (s.se() < best.se()) best = s;\n      }\n      return best;\n    }","commit_id":"ad041d3b5ff96ed33ea22692035f02c21b461a68","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public static void main( String[] args ) {\n    // To support launching from JUnit, JUnit expects to call main() repeatedly.\n    // We need exactly 1 call to main to startup all the local services.\n    if (IS_SYSTEM_RUNNING) return;\n    IS_SYSTEM_RUNNING = true;\n\n    // Parse args\n    Arguments arguments = new Arguments(args);\n    arguments.extract(OPT_ARGS);\n    ARGS = arguments.toStringArray();\n\n    if(OPT_ARGS.nolog == null)\n      Log.initHeaders();\n\n    startLocalNode(); // start the local node\n    // Load up from disk and initialize the persistence layer\n    initializePersistence();\n    // Start network services, including heartbeats & Paxos\n    startNetworkServices(); // start server services\n\n    initializeExpressionEvaluation(); // starts the expression evaluation system\n\n    startupFinalize(); // finalizes the startup & tests (if any)\n    // Hang out here until the End of Time\n  }","id":79971,"modified_method":"public static void main( String[] args ) {\n    // To support launching from JUnit, JUnit expects to call main() repeatedly.\n    // We need exactly 1 call to main to startup all the local services.\n    if (IS_SYSTEM_RUNNING) return;\n    IS_SYSTEM_RUNNING = true;\n\n    // Parse args\n    Arguments arguments = new Arguments(args);\n    arguments.extract(OPT_ARGS);\n    ARGS = arguments.toStringArray();\n    ParseDataset.PLIMIT = OPT_ARGS.pparse_limit;\n    if(OPT_ARGS.nolog == null)\n      Log.initHeaders();\n\n    startLocalNode(); // start the local node\n    // Load up from disk and initialize the persistence layer\n    initializePersistence();\n    // Start network services, including heartbeats & Paxos\n    startNetworkServices(); // start server services\n\n    initializeExpressionEvaluation(); // starts the expression evaluation system\n\n    startupFinalize(); // finalizes the startup & tests (if any)\n    // Hang out here until the End of Time\n  }","commit_id":"efb2a003fcfd36c83f16b3f22f043012ee7a295d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public void lcompute() {\n      _fileInfo = new FileInfo[_keys.length];\n      subTasks = new UnzipAndParseLocalTask[_keys.length];\n      setPendingCount(subTasks.length);\n      for(int i = 0; i < _keys.length; ++i)\n        H2O.submitTask((subTasks[i] = new UnzipAndParseLocalTask(i)));\n      tryComplete();\n    }","id":79972,"modified_method":"@Override\n    public void lcompute() {\n      _fileInfo = new FileInfo[_keys.length];\n      subTasks = new UnzipAndParseLocalTask[_keys.length];\n      setPendingCount(subTasks.length);\n      int p = 0;\n      for(int i = 0; i < _keys.length; ++i){\n        if(p < ParseDataset.PLIMIT){\n          H2O.submitTask((subTasks[i] = new UnzipAndParseLocalTask(i)));\n          ++p;\n        } else\n          (subTasks[i] = new UnzipAndParseLocalTask(i)).invoke();\n      }\n      tryComplete();\n    }","commit_id":"efb2a003fcfd36c83f16b3f22f043012ee7a295d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public UnzipAndParseTask(ParseDataset job, Compression comp, CsvParser.Setup setup, CustomParser.Type pType) {\n      _job = job;\n      _comp = comp;\n      _sep = setup._separator;\n      _ncolumns = setup._data[0].length;\n      _pType = pType;\n      _headers = (setup._header)?setup._data[0]:null;\n    }","id":79973,"modified_method":"public UnzipAndParseTask(ParseDataset job, Compression comp, CsvParser.Setup setup, CustomParser.Type pType) {\n      this(job,comp,setup,pType,Integer.MAX_VALUE);\n    }","commit_id":"efb2a003fcfd36c83f16b3f22f043012ee7a295d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private boolean createDatasetInstance(DatasetInstanceConfiguration creationProperties,\n                                        String name, HttpResponder responder, String operation) {\n    DatasetTypeMeta typeMeta = implManager.getTypeInfo(creationProperties.getTypeName());\n    if (typeMeta == null) {\n      String message = String.format(\"Cannot %s dataset %s: unknown type %s\",\n                                     operation, name, creationProperties.getTypeName());\n      LOG.warn(message);\n      responder.sendError(HttpResponseStatus.NOT_FOUND, message);\n      return false;\n    }\n    // Note how we execute configure() via opExecutorClient (outside of ds service) to isolate running user code\n    DatasetSpecification spec;\n    try {\n      spec = opExecutorClient.create(name, typeMeta,\n                                     DatasetProperties.builder().addAll(creationProperties.getProperties()).build());\n    } catch (Exception e) {\n      String msg = String.format(\"Cannot %s dataset %s of type %s: executing create() failed, reason: %s\",\n                                 operation, name, creationProperties.getTypeName(), e.getMessage());\n      LOG.error(msg, e);\n      throw new RuntimeException(msg, e);\n    }\n    instanceManager.add(spec);\n    return true;\n  }","id":79974,"modified_method":"private boolean createDatasetInstance(DatasetInstanceConfiguration creationProperties,\n                                        String name, HttpResponder responder, String operation) {\n    DatasetTypeMeta typeMeta = implManager.getTypeInfo(creationProperties.getTypeName());\n    if (typeMeta == null) {\n      String message = String.format(\"Cannot %s dataset %s: unknown type %s\",\n                                     operation, name, creationProperties.getTypeName());\n      LOG.warn(message);\n      responder.sendString(HttpResponseStatus.NOT_FOUND, message);\n      return false;\n    }\n    // Note how we execute configure() via opExecutorClient (outside of ds service) to isolate running user code\n    DatasetSpecification spec;\n    try {\n      spec = opExecutorClient.create(name, typeMeta,\n                                     DatasetProperties.builder().addAll(creationProperties.getProperties()).build());\n    } catch (Exception e) {\n      String msg = String.format(\"Cannot %s dataset %s of type %s: executing create() failed, reason: %s\",\n                                 operation, name, creationProperties.getTypeName(), e.getMessage());\n      LOG.error(msg, e);\n      throw new RuntimeException(msg, e);\n    }\n    instanceManager.add(spec);\n    return true;\n  }","commit_id":"bcffab9ef917d92b7ddce3bce9be1cbac00eeb77","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        LocationFactory locationFactory,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        DatasetTypeManager typeManager,\n                        DatasetInstanceManager instanceManager,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        MDSDatasetsRegistry mdsDatasets,\n                        ExploreFacade exploreFacade,\n                        Set<DatasetMetricsReporter> metricReporters) throws Exception {\n\n    this.typeManager = typeManager;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(typeManager, locationFactory, cConf);\n    DatasetTypeHandlerV2 datasetTypeHandlerV2 = new DatasetTypeHandlerV2(datasetTypeHandler);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler, datasetTypeHandlerV2,\n                                             new DatasetInstanceHandler(typeManager, instanceManager, opExecutorClient,\n                                                                        exploreFacade, cConf)));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.mdsDatasets = mdsDatasets;\n    this.metricReporters = metricReporters;\n  }","id":79975,"modified_method":"@Inject\n  public DatasetService(CConfiguration cConf,\n                        LocationFactory locationFactory,\n                        DiscoveryService discoveryService,\n                        DiscoveryServiceClient discoveryServiceClient,\n                        DatasetTypeManager typeManager,\n                        DatasetInstanceManager instanceManager,\n                        MetricsCollectionService metricsCollectionService,\n                        DatasetOpExecutor opExecutorClient,\n                        MDSDatasetsRegistry mdsDatasets,\n                        ExploreFacade exploreFacade,\n                        Set<DatasetMetricsReporter> metricReporters) throws Exception {\n\n    this.typeManager = typeManager;\n    DatasetTypeHandler datasetTypeHandler = new DatasetTypeHandler(typeManager, locationFactory, cConf);\n    DatasetTypeHandlerV2 datasetTypeHandlerV2 = new DatasetTypeHandlerV2(datasetTypeHandler);\n    DatasetInstanceHandler datasetInstanceHandler = new DatasetInstanceHandler(typeManager, instanceManager,\n                                                                               opExecutorClient, exploreFacade, cConf);\n    DatasetInstanceHandlerV2 datasetInstanceHandlerV2 = new DatasetInstanceHandlerV2(datasetInstanceHandler);\n    NettyHttpService.Builder builder = new CommonNettyHttpServiceBuilder(cConf);\n    builder.addHttpHandlers(ImmutableList.of(datasetTypeHandler, datasetTypeHandlerV2,\n                                             datasetInstanceHandler, datasetInstanceHandlerV2));\n\n    builder.setHandlerHooks(ImmutableList.of(new MetricsReporterHook(metricsCollectionService,\n                                                                     Constants.Service.DATASET_MANAGER)));\n\n    builder.setHost(cConf.get(Constants.Dataset.Manager.ADDRESS));\n\n    builder.setConnectionBacklog(cConf.getInt(Constants.Dataset.Manager.BACKLOG_CONNECTIONS,\n                                              Constants.Dataset.Manager.DEFAULT_BACKLOG));\n    builder.setExecThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.EXEC_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_EXEC_THREADS));\n    builder.setBossThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.BOSS_THREADS,\n                                               Constants.Dataset.Manager.DEFAULT_BOSS_THREADS));\n    builder.setWorkerThreadPoolSize(cConf.getInt(Constants.Dataset.Manager.WORKER_THREADS,\n                                                 Constants.Dataset.Manager.DEFAULT_WORKER_THREADS));\n\n    this.httpService = builder.build();\n    this.discoveryService = discoveryService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.opExecutorClient = opExecutorClient;\n    this.mdsDatasets = mdsDatasets;\n    this.metricReporters = metricReporters;\n  }","commit_id":"bcffab9ef917d92b7ddce3bce9be1cbac00eeb77","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public HttpRequest apply(HttpRequest request) {\n    String path = URI.create(request.getUri()).normalize().getPath();\n    String[] uriParts = StringUtils.split(path, '/');\n    if ((uriParts.length >= 4) && uriParts[1].equals(\"data\") && uriParts[2].equals(\"datasets\")) {\n      // three parts with '/' wrapping them\n      int insertAt = uriParts[0].length() + uriParts[1].length() + uriParts[2].length() + 4;\n      String datasetName = uriParts[3];\n      request.setUri(processDatasetPath(path, insertAt, datasetName));\n    } else if ((uriParts.length == 6) && uriParts[1].equals(\"data\") && uriParts[2].equals(\"explore\")\n      && uriParts[3].equals(\"datasets\") && uriParts[5].equals(\"schema\")) {\n      // four parts with '/' wrapping them\n      int insertAt = uriParts[0].length() + uriParts[1].length() + uriParts[2].length() + uriParts[3].length() + 5;\n      String datasetName = uriParts[4];\n      request.setUri(processDatasetPath(path, insertAt, datasetName));\n    }\n\n    return request;\n  }","id":79976,"modified_method":"@Override\n  public HttpRequest apply(HttpRequest request) {\n    String path = URI.create(request.getUri()).normalize().getPath();\n    String[] uriParts = StringUtils.split(path, '/');\n    if (uriParts[0].equals(Constants.Gateway.API_VERSION_2_TOKEN)) {\n      return applyToV2(request, uriParts, path);\n    } else if (uriParts[0].equals(Constants.Gateway.API_VERSION_3_TOKEN)) {\n      return applyToV3(request, uriParts, path);\n    }\n    return request;\n  }","commit_id":"bcffab9ef917d92b7ddce3bce9be1cbac00eeb77","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testApplyingProxyRules() {\n    assertChange(\"/v2/data/explore/datasets/cdap.user.myTable/schema\",\n                 \"/v2/data/explore/datasets/myTable/schema\");\n    assertChange(\"/v2/data/datasets/cdap.user.myTable\", \"/v2/data/datasets/myTable\");\n    assertChange(\"/v2/data/datasets/cdap.user.myTable/admin\", \"/v2/data/datasets/myTable/admin\");\n    assertChange(\"/v2/data/datasets/cdap.user.myTable/admin/truncate\",\n                 \"/v2/data/datasets/myTable/admin/truncate\");\n    assertSame(\"/v2/data/types/myType\");\n    assertSame(\"/v2/metrics\");\n    assertSame(\"/v2/metrics/data/datasets/myTable\");\n  }","id":79977,"modified_method":"@Test\n  public void testApplyingProxyRulesV3() {\n    assertChange(\"/v3/namespaces/myspace/data/explore/datasets/cdap.user.myTable/schema\",\n                 \"/v3/namespaces/myspace/data/explore/datasets/myTable/schema\");\n    assertChange(\"/v3/namespaces/myspace/data/datasets/cdap.user.myTable\",\n                 \"/v3/namespaces/myspace/data/datasets/myTable\");\n    assertChange(\"/v3/namespaces/myspace/data/datasets/cdap.user.myTable/admin\",\n                 \"/v3/namespaces/myspace/data/datasets/myTable/admin\");\n    assertChange(\"/v3/namespaces/myspace/data/datasets/cdap.user.myTable/admin/truncate\",\n                 \"/v3/namespaces/myspace/data/datasets/myTable/admin/truncate\");\n    assertSame(\"/v3/namespaces/myspace/data/types/myType\");\n    assertSame(\"/v3/namespaces/myspace/metrics\");\n    assertSame(\"/v3/namespaces/myspace/metrics/data/datasets/myTable\");\n  }","commit_id":"bcffab9ef917d92b7ddce3bce9be1cbac00eeb77","url":"https://github.com/caskdata/cdap"},{"original_method":"private FilterResult getFilterResult(IModuleResource resource, Filter filter, File contentSyncRoot,\n            Repository repository) throws SerializationException {\n\n        String filePath = resource.getModuleRelativePath().toOSString();\n\t\tString absFilePath = new File(contentSyncRoot, filePath).getAbsolutePath();\n        if (serializationManager(repository, contentSyncRoot).isSerializationFile(absFilePath)) {\n            filePath = serializationManager.getBaseResourcePath(filePath);\n        }\n        \n        String repositoryPath = resource.getModuleRelativePath().toPortableString();\n\n        Activator.getDefault().getPluginLogger().trace(\"Filtering by {0} for {1}\", repositoryPath, resource);\n\n        return filter.filter(contentSyncRoot, repositoryPath, repository.getRepositoryInfo());\n    }","id":79978,"modified_method":"private FilterResult getFilterResult(IModuleResource resource, Filter filter, File contentSyncRoot,\n            IFolder syncFolder,\n            Repository repository) throws SerializationException {\n\n        String absFilePath = new File(contentSyncRoot, resource.getModuleRelativePath().toOSString()).getAbsolutePath();\n        String filePath = serializationManager.getBaseResourcePath(absFilePath);\n        \n        IPath osPath = Path.fromOSString(filePath);\n        String repositoryPath = osPath.makeRelativeTo(syncFolder.getLocation()).toPortableString();\n\n        Activator.getDefault().getPluginLogger().trace(\"Filtering by {0} for {1}\", repositoryPath, resource);\n\n        return filter.filter(contentSyncRoot, repositoryPath, repository.getRepositoryInfo());\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"private Command<?> addFileCommand(Repository repository, IModuleResource resource) throws CoreException,\n            SerializationException, IOException {\n\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        FileInfo info = createFileInfo(resource, repository);\n\n        IResource res = getResource(resource);\n        if (res == null) {\n            return null;\n        }\n\n        Object ignoreNextUpdate = res.getSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE);\n        if (ignoreNextUpdate != null) {\n            res.setSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE, null);\n            return null;\n        }\n\n        if (res.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getPluginLogger().trace(\"Skipping team-private resource {0}\", res);\n            return null;\n        }\n\n        Activator.getDefault().getPluginLogger().trace(\"For {0} build fileInfo {1}\", resource, info);\n        if (info == null) {\n            return null;\n        }\n\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFullPath(res.getProject()).toFile();\n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(res.getProject());\n\n        if (serializationManager(repository, syncDirectoryAsFile).isSerializationFile(info.getLocation())) {\n            InputStream contents = null;\n            try {\n                IFile file = (IFile) resource.getAdapter(IFile.class);\n                contents = file.getContents();\n                String resourceLocation = file.getFullPath().makeRelativeTo(syncDirectory.getFullPath()).toPortableString();\n                ResourceProxy resourceProxy = serializationManager(repository, syncDirectoryAsFile)\n                        .readSerializationData(resourceLocation, contents);\n                // TODO - not sure if this 100% correct, but we definitely should not refer to the FileInfo as the\n                // .serialization file, since for nt:file/nt:resource nodes this will overwrite the file contents\n                String primaryType = (String) resourceProxy.getProperties().get(Repository.JCR_PRIMARY_TYPE);\n                if (Repository.NT_FILE.equals(primaryType) || Repository.NT_RESOURCE.equals(primaryType)) {\n                    // TODO move logic to serializationManager\n                    File locationFile = new File(info.getLocation());\n                    String locationFileParent = locationFile.getParent();\n                    int endIndex = locationFileParent.length() - \".dir\".length();\n                    File actualFile = new File(locationFileParent.substring(0, endIndex));\n                    String newLocation = actualFile.getAbsolutePath();\n                    String newName = actualFile.getName();\n                    String newRelativeLocation = actualFile.getAbsolutePath().substring(\n                            syncDirectoryAsFile.getAbsolutePath().length());\n                    info = new FileInfo(newLocation, newRelativeLocation, newName);\n                }\n\n                return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n            } catch (IOException e) {\n                // TODO logging\n                e.printStackTrace();\n                return null;\n            } finally {\n                if (contents != null) {\n                    contents.close();\n                }\n            }\n        } else {\n\n            ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder( resource, syncDirectory);\n\n            return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n        }\n    }","id":79979,"modified_method":"private Command<?> addFileCommand(Repository repository, IModuleResource resource) throws CoreException,\n            SerializationException, IOException {\n\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        FileInfo info = createFileInfo(resource, repository);\n\n        IResource res = getResource(resource);\n        if (res == null) {\n            return null;\n        }\n\n        Object ignoreNextUpdate = res.getSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE);\n        if (ignoreNextUpdate != null) {\n            res.setSessionProperty(ResourceUtil.QN_IGNORE_NEXT_CHANGE, null);\n            return null;\n        }\n\n        if (res.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getPluginLogger().trace(\"Skipping team-private resource {0}\", res);\n            return null;\n        }\n\n        Activator.getDefault().getPluginLogger().trace(\"For {0} build fileInfo {1}\", resource, info);\n        if (info == null) {\n            return null;\n        }\n\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFullPath(res.getProject()).toFile();\n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(res.getProject());\n\n        if (serializationManager.isSerializationFile(info.getLocation())) {\n            InputStream contents = null;\n            try {\n                IFile file = (IFile) resource.getAdapter(IFile.class);\n                contents = file.getContents();\n                String resourceLocation = file.getFullPath().makeRelativeTo(syncDirectory.getFullPath()).toPortableString();\n                ResourceProxy resourceProxy = serializationManager.readSerializationData(resourceLocation, contents);\n                // TODO - not sure if this 100% correct, but we definitely should not refer to the FileInfo as the\n                // .serialization file, since for nt:file/nt:resource nodes this will overwrite the file contents\n                String primaryType = (String) resourceProxy.getProperties().get(Repository.JCR_PRIMARY_TYPE);\n                if (Repository.NT_FILE.equals(primaryType) || Repository.NT_RESOURCE.equals(primaryType)) {\n                    // TODO move logic to serializationManager\n                    File locationFile = new File(info.getLocation());\n                    String locationFileParent = locationFile.getParent();\n                    int endIndex = locationFileParent.length() - \".dir\".length();\n                    File actualFile = new File(locationFileParent.substring(0, endIndex));\n                    String newLocation = actualFile.getAbsolutePath();\n                    String newName = actualFile.getName();\n                    String newRelativeLocation = actualFile.getAbsolutePath().substring(\n                            syncDirectoryAsFile.getAbsolutePath().length());\n                    info = new FileInfo(newLocation, newRelativeLocation, newName);\n                }\n\n                return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n            } catch (IOException e) {\n                // TODO logging\n                e.printStackTrace();\n                return null;\n            } finally {\n                if (contents != null) {\n                    contents.close();\n                }\n            }\n        } else {\n\n            ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder( resource, syncDirectory);\n\n            return repository.newAddOrUpdateNodeCommand(info, resourceProxy);\n        }\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"private Command<?> removeFileCommand(Repository repository, IModuleResource resource) throws SerializationException, IOException, CoreException {\n    \t\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        IResource deletedResource = getResource(resource);\n        \n        if ( deletedResource == null ) {\n        \treturn null;\n        }\n        \n        if (deletedResource.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getPluginLogger().trace(\"Skipping team-private resoruce {0}\", deletedResource);\n            return null;\n        }\n        \n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(deletedResource.getProject());\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(deletedResource.getProject());\n        \n        Filter filter = loadFilter(syncDirectory);\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile, repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder(resource, syncDirectory);\n\n        return repository.newDeleteNodeCommand(resourceProxy);\n    }","id":79980,"modified_method":"private Command<?> removeFileCommand(Repository repository, IModuleResource resource) throws SerializationException, IOException, CoreException {\n    \t\n        if (ignoredFileNames.contains(resource.getName())) {\n            return null;\n        }\n\n        IResource deletedResource = getResource(resource);\n        \n        if ( deletedResource == null ) {\n        \treturn null;\n        }\n        \n        if (deletedResource.isTeamPrivateMember(IResource.CHECK_ANCESTORS)) {\n            Activator.getDefault().getPluginLogger().trace(\"Skipping team-private resoruce {0}\", deletedResource);\n            return null;\n        }\n        \n        IFolder syncDirectory = ProjectUtil.getSyncDirectory(deletedResource.getProject());\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(deletedResource.getProject());\n        \n        Filter filter = loadFilter(syncDirectory);\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile, syncDirectory,\n                    repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        ResourceProxy resourceProxy = buildResourceProxyForPlainFileOrFolder(resource, syncDirectory);\n\n        return repository.newDeleteNodeCommand(resourceProxy);\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void publishModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException {\n\n        PluginLogger logger = Activator.getDefault().getPluginLogger();\n        \n        logger.trace(traceOperation(kind, deltaKind, module));\n\n        if (deltaKind==ServerBehaviourDelegate.NO_CHANGE) {\n            // then there's no need to publish\n            return;\n        }\n        \n        if (kind == IServer.PUBLISH_FULL && deltaKind == ServerBehaviourDelegate.REMOVED) {\n            logger.trace(\"Ignoring request to unpublish all of the module resources\");\n            return;\n        }\n\n        try {\n            if (ProjectHelper.isBundleProject(module[0].getProject())) {\n                String serverMode = getServer().getMode();\n                if (!serverMode.equals(ILaunchManager.DEBUG_MODE)) {\n                    // in debug mode, we rely on the hotcode replacement feature of eclipse/jvm\n                    // otherwise, for run and profile modes we explicitly publish the bundle module\n                    // TODO: make this configurable as part of the server config\n            \t\tpublishBundleModule(module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n            \t}\n            } else if (ProjectHelper.isContentProject(module[0].getProject())) {\n                if ((kind == IServer.PUBLISH_AUTO || kind == IServer.PUBLISH_INCREMENTAL) && deltaKind == ServerBehaviourDelegate.NO_CHANGE) {\n                    logger.trace(\"Ignoring request to publish the module when no resources have changed; most likely another module has changed\");\n                    return;\n                }\n                try {\n                    publishContentModule(kind, deltaKind, module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n                } catch (SerializationException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Serialization error for \"\n                            + traceOperation(kind, deltaKind, module).toString(), e));\n                } catch (IOException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"IO error for \"\n                            + traceOperation(kind, deltaKind, module).toString(), e));\n                }\n            }\n        } finally {\n            if (serializationManager != null) {\n                serializationManager.destroy();\n            }\n        }\n    }","id":79981,"modified_method":"@Override\n    protected void publishModule(int kind, int deltaKind, IModule[] module, IProgressMonitor monitor)\n            throws CoreException {\n\n        PluginLogger logger = Activator.getDefault().getPluginLogger();\n        \n        if (serializationManager == null) {\n            serializationManager = Activator.getDefault().getSerializationManager();\n        }\n\n        logger.trace(traceOperation(kind, deltaKind, module));\n\n        if (deltaKind==ServerBehaviourDelegate.NO_CHANGE) {\n            // then there's no need to publish\n            return;\n        }\n        \n        if (kind == IServer.PUBLISH_FULL && deltaKind == ServerBehaviourDelegate.REMOVED) {\n            logger.trace(\"Ignoring request to unpublish all of the module resources\");\n            return;\n        }\n\n        try {\n            if (ProjectHelper.isBundleProject(module[0].getProject())) {\n                String serverMode = getServer().getMode();\n                if (!serverMode.equals(ILaunchManager.DEBUG_MODE)) {\n                    // in debug mode, we rely on the hotcode replacement feature of eclipse/jvm\n                    // otherwise, for run and profile modes we explicitly publish the bundle module\n                    // TODO: make this configurable as part of the server config\n            \t\tpublishBundleModule(module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n            \t}\n            } else if (ProjectHelper.isContentProject(module[0].getProject())) {\n                if ((kind == IServer.PUBLISH_AUTO || kind == IServer.PUBLISH_INCREMENTAL) && deltaKind == ServerBehaviourDelegate.NO_CHANGE) {\n                    logger.trace(\"Ignoring request to publish the module when no resources have changed; most likely another module has changed\");\n                    return;\n                }\n                try {\n                    publishContentModule(kind, deltaKind, module, monitor);\n\t\t\t\t\tBundleStateHelper.resetBundleState(getServer(), module[0].getProject());\n                } catch (SerializationException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"Serialization error for \"\n                            + traceOperation(kind, deltaKind, module).toString(), e));\n                } catch (IOException e) {\n                    throw new CoreException(new Status(IStatus.ERROR, Activator.PLUGIN_ID, \"IO error for \"\n                            + traceOperation(kind, deltaKind, module).toString(), e));\n                }\n            }\n        } finally {\n            if (serializationManager != null) {\n                serializationManager.destroy();\n            }\n        }\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"private FileInfo createFileInfo(IModuleResource resource, Repository repository) throws SerializationException,\n            CoreException {\n\n        IResource file = getResource(resource);\n        if (file == null) {\n            return null;\n        }\n\n        IProject project = file.getProject();\n\n        String syncDirectory = ProjectUtil.getSyncDirectoryValue(project);\n        File syncDirectoryAsFile = ProjectUtil.getSyncDirectoryFile(project);\n\n        Filter filter = loadFilter(project.getFolder(syncDirectory));\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, syncDirectoryAsFile,\n                    repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        IPath relativePath = resource.getModuleRelativePath().removeLastSegments(1);\n\n        FileInfo info = new FileInfo(file.getLocation().toOSString(), relativePath.toOSString(), file.getName());\n\n        Activator.getDefault().getPluginLogger().trace(\"For {1} built fileInfo {2}\", resource, info);\n\n        return info;\n    }","id":79982,"modified_method":"private FileInfo createFileInfo(IModuleResource resource, Repository repository) throws SerializationException,\n            CoreException {\n\n        IResource file = getResource(resource);\n        if (file == null) {\n            return null;\n        }\n\n        IProject project = file.getProject();\n\n        IFolder syncFolder = project.getFolder(ProjectUtil.getSyncDirectoryValue(project));\n        Filter filter = loadFilter(syncFolder);\n\n        if (filter != null) {\n            FilterResult filterResult = getFilterResult(resource, filter, ProjectUtil.getSyncDirectoryFile(project),\n                    syncFolder, repository);\n            if (filterResult == FilterResult.DENY || filterResult == FilterResult.PREREQUISITE) {\n                return null;\n            }\n        }\n\n        IPath relativePath = resource.getModuleRelativePath().removeLastSegments(1);\n\n        FileInfo info = new FileInfo(file.getLocation().toOSString(), relativePath.toOSString(), file.getName());\n\n        Activator.getDefault().getPluginLogger().trace(\"For {1} built fileInfo {2}\", resource, info);\n\n        return info;\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public boolean isSerializationFile(String filePath) {\n        \n        File file = new File(filePath);\n        String fileName = file.getName();\n        if (fileName.equals(Constants.DOT_CONTENT_XML)) {\n            return true;\n        }\n\n        if (!fileName.endsWith(EXTENSION_XML)) {\n            return false;\n        }\n\n        // TODO - refrain from doing I/O here\n        // TODO - copied from TransactionImpl\n        InputStream in = null;\n        try {\n            in = new BufferedInputStream(new FileInputStream(file));\n            SerializationType serType = XmlAnalyzer.analyze(new InputSource(in));\n            return serType == SerializationType.XML_DOCVIEW;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    // don't care\n                }\n            }\n        }\n    }","id":79983,"modified_method":"@Override\n    public boolean isSerializationFile(String filePath) {\n        \n        File file = new File(filePath);\n        String fileName = file.getName();\n        if (fileName.equals(Constants.DOT_CONTENT_XML)) {\n            return true;\n        }\n\n        if (!fileName.endsWith(EXTENSION_XML)) {\n            return false;\n        }\n\n        // TODO - refrain from doing I/O here\n        // TODO - copied from TransactionImpl\n        InputStream in = null;\n        try {\n            in = new BufferedInputStream(new FileInputStream(file));\n            SerializationType serType = XmlAnalyzer.analyze(new InputSource(in));\n            return serType == SerializationType.XML_DOCVIEW;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public String getBaseResourcePath(String serializationFilePath) {\n        // TODO actually calculate the resource path, this fails for full coverage aggregates\n        if (Constants.DOT_CONTENT_XML.equals(serializationFilePath)) {\n            return \"\";\n        }\n\n        return serializationFilePath.substring(0, serializationFilePath.length()\n                - (Constants.DOT_CONTENT_XML.length() + 1));\n    }","id":79984,"modified_method":"@Override\n    public String getBaseResourcePath(String serializationFilePath) {\n\n        File file = new File(serializationFilePath);\n        String fileName = file.getName();\n        if (fileName.equals(Constants.DOT_CONTENT_XML)) {\n            return file.getParent();\n        }\n\n        if (!fileName.endsWith(EXTENSION_XML)) {\n            return file.getAbsolutePath();\n        }\n\n        // TODO - refrain from doing I/O here\n        // TODO - copied from TransactionImpl\n        InputStream in = null;\n        try {\n            in = new BufferedInputStream(new FileInputStream(file));\n            SerializationType serType = XmlAnalyzer.analyze(new InputSource(in));\n            if (serType == SerializationType.XML_DOCVIEW) {\n                return file.getAbsolutePath().substring(0, file.getAbsolutePath().length() - EXTENSION_XML.length());\n            }\n\n            return file.getAbsolutePath();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void getSerializationFilePath_Root() {\n        assertThat(serializationManager.getBaseResourcePath(\".content.xml\"), is(\"\"));\n    }","id":79985,"modified_method":"@Test\n    public void getSerializationFilePath_Root() {\n        assertThat(serializationManager.getBaseResourcePath(\"/.content.xml\"), is(\"/\"));\n    }","commit_id":"21638af92d1f6612c1f37d5be78af29218ad2815","url":"https://github.com/apache/sling"},{"original_method":"static JetType computeType(JetTypeElement alternativeTypeElement, final JetType autoType) {\n        return alternativeTypeElement.accept(new JetVisitor<JetType, Void>() {\n            @Override\n            public JetType visitNullableType(JetNullableType nullableType, Void data) {\n                if (!autoType.isNullable()) {\n                    throw new AlternativeSignatureMismatchException(String.format(\n                            \"Auto type '%s' is not-null, while type in alternative signature is nullable: '%s'\",\n                            DescriptorRenderer.TEXT.renderType(autoType), nullableType.getText()));\n                }\n                return TypeUtils.makeNullable(computeType(nullableType.getInnerType(), autoType));\n            }\n\n            @Override\n            public JetType visitFunctionType(JetFunctionType type, Void data) {\n                return visitCommonType(type.getReceiverTypeRef() == null\n                        ? JetStandardClasses.getFunction(type.getParameters().size())\n                        : JetStandardClasses.getReceiverFunction(type.getParameters().size()), type);\n            }\n\n            @Override\n            public JetType visitTupleType(JetTupleType type, Void data) {\n                return visitCommonType(JetStandardClasses.getTuple(type.getComponentTypeRefs().size()), type);\n            }\n\n            @Override\n            public JetType visitUserType(JetUserType type, Void data) {\n                JetUserType qualifier = type.getQualifier();\n                String shortName = type.getReferenceExpression().getReferencedName();\n                String longName = (qualifier == null ? \"\" : qualifier.getText() + \".\") + shortName;\n                if (JetStandardClasses.UNIT_ALIAS.getName().equals(longName)) {\n                    return visitCommonType(JetStandardClasses.getTuple(0), type);\n                }\n                return visitCommonType(longName, type);\n            }\n\n            private JetType visitCommonType(@NotNull ClassDescriptor classDescriptor, @NotNull JetTypeElement type) {\n                return visitCommonType(DescriptorUtils.getFQName(classDescriptor).toSafe().getFqName(), type);\n            }\n\n            private JetType visitCommonType(@NotNull String expectedFqNamePostfix, @NotNull JetTypeElement type) {\n                String fqName = DescriptorUtils.getFQName(autoType.getConstructor().getDeclarationDescriptor()).toSafe().getFqName();\n                if (!fqName.endsWith(expectedFqNamePostfix)) {\n                    throw new AlternativeSignatureMismatchException(String.format(\n                            \"Alternative signature type mismatch, expected: %s, actual: %s\", expectedFqNamePostfix, fqName));\n                }\n\n                List<TypeProjection> arguments = autoType.getArguments();\n\n                if (arguments.size() != type.getTypeArgumentsAsTypes().size()) {\n                    throw new AlternativeSignatureMismatchException(String.format(\n                            \"'%s' type in method signature has %d type arguments, while '%s' in alternative signature has %d of them\",\n                            DescriptorRenderer.TEXT.renderType(autoType), arguments.size(),\n                            type.getText(), type.getTypeArgumentsAsTypes().size()));\n                }\n\n                List<TypeProjection> altArguments = new ArrayList<TypeProjection>();\n                for (int i = 0, size = arguments.size(); i < size; i++) {\n                    JetTypeElement argumentAlternativeTypeElement = type.getTypeArgumentsAsTypes().get(i).getTypeElement();\n                    TypeProjection argument = arguments.get(i);\n                    JetType alternativeType =\n                            computeType(argumentAlternativeTypeElement, argument.getType());\n                    Variance variance = argument.getProjectionKind();\n                    if (type instanceof JetUserType) {\n                        JetTypeProjection typeProjection = ((JetUserType) type).getTypeArguments().get(i);\n                        Variance altVariance = Variance.INVARIANT;\n                        switch (typeProjection.getProjectionKind()) {\n                            case IN:\n                                altVariance = Variance.IN_VARIANCE;\n                                break;\n                            case OUT:\n                                altVariance = Variance.OUT_VARIANCE;\n                                break;\n                            case STAR:\n                                throw new AlternativeSignatureMismatchException(\n                                        \"Star projection is not available in alternative signatures\");\n                            default:\n                        }\n                        if (altVariance != variance) {\n                            throw new AlternativeSignatureMismatchException(String.format(\n                                    \"Variance mismatch, actual: %s, in alternative signature: %s\", variance, altVariance));\n                        }\n                    }\n                    altArguments.add(new TypeProjection(variance, alternativeType));\n                }\n                return new JetTypeImpl(autoType.getAnnotations(), autoType.getConstructor(), false,\n                                       altArguments, autoType.getMemberScope());\n            }\n\n            @Override\n            public JetType visitSelfType(JetSelfType type, Void data) {\n                throw new UnsupportedOperationException(\"Self-types are not supported yet\");\n            }\n        }, null);\n    }","id":79986,"modified_method":"static JetType computeType(JetTypeElement alternativeTypeElement, final JetType autoType) {\n        return alternativeTypeElement.accept(new JetVisitor<JetType, Void>() {\n            @Override\n            public JetType visitNullableType(JetNullableType nullableType, Void data) {\n                if (!autoType.isNullable()) {\n                    fail(\"Auto type '%s' is not-null, while type in alternative signature is nullable: '%s'\",\n                         DescriptorRenderer.TEXT.renderType(autoType), nullableType.getText());\n                }\n                return TypeUtils.makeNullable(computeType(nullableType.getInnerType(), autoType));\n            }\n\n            @Override\n            public JetType visitFunctionType(JetFunctionType type, Void data) {\n                return visitCommonType(type.getReceiverTypeRef() == null\n                        ? JetStandardClasses.getFunction(type.getParameters().size())\n                        : JetStandardClasses.getReceiverFunction(type.getParameters().size()), type);\n            }\n\n            @Override\n            public JetType visitTupleType(JetTupleType type, Void data) {\n                return visitCommonType(JetStandardClasses.getTuple(type.getComponentTypeRefs().size()), type);\n            }\n\n            @Override\n            public JetType visitUserType(JetUserType type, Void data) {\n                JetUserType qualifier = type.getQualifier();\n                String shortName = type.getReferenceExpression().getReferencedName();\n                String longName = (qualifier == null ? \"\" : qualifier.getText() + \".\") + shortName;\n                if (JetStandardClasses.UNIT_ALIAS.getName().equals(longName)) {\n                    return visitCommonType(JetStandardClasses.getTuple(0), type);\n                }\n                return visitCommonType(longName, type);\n            }\n\n            private JetType visitCommonType(@NotNull ClassDescriptor classDescriptor, @NotNull JetTypeElement type) {\n                return visitCommonType(DescriptorUtils.getFQName(classDescriptor).toSafe().getFqName(), type);\n            }\n\n            private JetType visitCommonType(@NotNull String expectedFqNamePostfix, @NotNull JetTypeElement type) {\n                String fqName = DescriptorUtils.getFQName(autoType.getConstructor().getDeclarationDescriptor()).toSafe().getFqName();\n                if (!fqName.endsWith(expectedFqNamePostfix)) {\n                    fail(\"Alternative signature type mismatch, expected: %s, actual: %s\", expectedFqNamePostfix, fqName);\n                }\n\n                List<TypeProjection> arguments = autoType.getArguments();\n\n                if (arguments.size() != type.getTypeArgumentsAsTypes().size()) {\n                    fail(\"'%s' type in method signature has %d type arguments, while '%s' in alternative signature has %d of them\",\n                         DescriptorRenderer.TEXT.renderType(autoType), arguments.size(), type.getText(), type.getTypeArgumentsAsTypes().size());\n                }\n\n                List<TypeProjection> altArguments = new ArrayList<TypeProjection>();\n                for (int i = 0, size = arguments.size(); i < size; i++) {\n                    JetTypeElement argumentAlternativeTypeElement = type.getTypeArgumentsAsTypes().get(i).getTypeElement();\n                    TypeProjection argument = arguments.get(i);\n                    JetType alternativeType =\n                            computeType(argumentAlternativeTypeElement, argument.getType());\n                    Variance variance = argument.getProjectionKind();\n                    if (type instanceof JetUserType) {\n                        JetTypeProjection typeProjection = ((JetUserType) type).getTypeArguments().get(i);\n                        Variance altVariance = Variance.INVARIANT;\n                        switch (typeProjection.getProjectionKind()) {\n                            case IN:\n                                altVariance = Variance.IN_VARIANCE;\n                                break;\n                            case OUT:\n                                altVariance = Variance.OUT_VARIANCE;\n                                break;\n                            case STAR:\n                                fail(\"Star projection is not available in alternative signatures\");\n                            default:\n                        }\n                        if (altVariance != variance) {\n                            fail(\"Variance mismatch, actual: %s, in alternative signature: %s\", variance, altVariance);\n                        }\n                    }\n                    altArguments.add(new TypeProjection(variance, alternativeType));\n                }\n                return new JetTypeImpl(autoType.getAnnotations(), autoType.getConstructor(), false,\n                                       altArguments, autoType.getMemberScope());\n            }\n\n            @Override\n            public JetType visitSelfType(JetSelfType type, Void data) {\n                throw new UnsupportedOperationException(\"Self-types are not supported yet\");\n            }\n        }, null);\n    }","commit_id":"6f8f62cc9a1010c593d99992a19622ee0a2d00be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void computeReturnType(@NotNull JetType autoType) {\n        JetTypeReference altReturnTypeRef = altFunDeclaration.getReturnTypeRef();\n        if (altReturnTypeRef == null) {\n            if (JetStandardClasses.isUnit(autoType)) {\n                altReturnType = autoType;\n            }\n            else {\n                throw new AlternativeSignatureMismatchException(String.format(\n                        \"Return type in alternative signature is missing, while in real signature it is '%s'\",\n                        DescriptorRenderer.TEXT.renderType(autoType)));\n            }\n        }\n        else {\n            altReturnType = computeType(altReturnTypeRef.getTypeElement(),\n                                        autoType);\n        }\n    }","id":79987,"modified_method":"private void computeReturnType(@NotNull JetType autoType) {\n        JetTypeReference altReturnTypeRef = altFunDeclaration.getReturnTypeRef();\n        if (altReturnTypeRef == null) {\n            if (JetStandardClasses.isUnit(autoType)) {\n                altReturnType = autoType;\n            }\n            else {\n                fail(\"Return type in alternative signature is missing, while in real signature it is '%s'\",\n                     DescriptorRenderer.TEXT.renderType(autoType));\n            }\n        }\n        else {\n            altReturnType = computeType(altReturnTypeRef.getTypeElement(),\n                                        autoType);\n        }\n    }","commit_id":"6f8f62cc9a1010c593d99992a19622ee0a2d00be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkForSyntaxErrors() {\n        List<PsiErrorElement> syntaxErrors = AnalyzingUtils.getSyntaxErrorRanges(altFunDeclaration);\n        if (!syntaxErrors.isEmpty()) {\n            String textSignature = String.format(\"%s(%s)\", method.getName(),\n                    StringUtil.join(method.getPsiMethod().getSignature(PsiSubstitutor.EMPTY).getParameterTypes(),\n                                    new Function<PsiType, String>() {\n                                        @Override\n                                        public String fun(PsiType psiType) {\n                                            return psiType.getPresentableText();\n                                        }\n                                    }, \", \"));\n            int errorOffset = syntaxErrors.get(0).getTextOffset();\n            String syntaxErrorDescription = syntaxErrors.get(0).getErrorDescription();\n\n            String errorText = syntaxErrors.size() == 1\n                    ? String.format(\"Alternative signature for %s has syntax error at %d: %s\", textSignature,\n                                    errorOffset, syntaxErrorDescription)\n                    : String.format(\"Alternative signature for %s has %d syntax errors, first is at %d: %s\", textSignature,\n                                    syntaxErrors.size(), errorOffset, syntaxErrorDescription);\n            throw new AlternativeSignatureMismatchException(errorText);\n        }\n\n        if (!ComparatorUtil.equalsNullable(method.getName(), altFunDeclaration.getName())) {\n            throw new AlternativeSignatureMismatchException(String.format(\n                    \"Function names mismatch, original: %s, alternative: %s\",\n                    method.getName(), altFunDeclaration.getName()));\n        }\n    }","id":79988,"modified_method":"private void checkForSyntaxErrors() {\n        List<PsiErrorElement> syntaxErrors = AnalyzingUtils.getSyntaxErrorRanges(altFunDeclaration);\n        if (!syntaxErrors.isEmpty()) {\n            String textSignature = String.format(\"%s(%s)\", method.getName(),\n                    StringUtil.join(method.getPsiMethod().getSignature(PsiSubstitutor.EMPTY).getParameterTypes(),\n                                    new Function<PsiType, String>() {\n                                        @Override\n                                        public String fun(PsiType psiType) {\n                                            return psiType.getPresentableText();\n                                        }\n                                    }, \", \"));\n            int errorOffset = syntaxErrors.get(0).getTextOffset();\n            String syntaxErrorDescription = syntaxErrors.get(0).getErrorDescription();\n\n            if (syntaxErrors.size() == 1) {\n                fail(\"Alternative signature for %s has syntax error at %d: %s\",\n                     textSignature, errorOffset, syntaxErrorDescription);\n            }\n            else {\n                fail(\"Alternative signature for %s has %d syntax errors, first is at %d: %s\",\n                     textSignature, syntaxErrors.size(), errorOffset, syntaxErrorDescription);\n            }\n        }\n\n        if (!ComparatorUtil.equalsNullable(method.getName(), altFunDeclaration.getName())) {\n            fail(\"Function names mismatch, original: %s, alternative: %s\", method.getName(), altFunDeclaration.getName());\n        }\n    }","commit_id":"6f8f62cc9a1010c593d99992a19622ee0a2d00be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void computeTypeParameters(List<TypeParameterDescriptor> typeParameters) {\n\n        if (typeParameters.size() != altFunDeclaration.getTypeParameters().size()) {\n            throw new AlternativeSignatureMismatchException(\n                    String.format(\"Method signature has %d type parameters, but alternative signature has %d\",\n                                  typeParameters.size(), altFunDeclaration.getTypeParameters().size()));\n        }\n\n        altTypeParameters = new ArrayList<TypeParameterDescriptor>();\n        for (int i = 0, size = typeParameters.size(); i < size; i++) {\n            TypeParameterDescriptor pd = typeParameters.get(i);\n            DeclarationDescriptor containingDeclaration = pd.getContainingDeclaration();\n            assert containingDeclaration != null;\n            TypeParameterDescriptorImpl altParamDescriptor = TypeParameterDescriptorImpl\n                    .createForFurtherModification(containingDeclaration, pd.getAnnotations(),\n                                                  pd.isReified(), pd.getVariance(), pd.getName(), pd.getIndex());\n            int upperBoundIndex = 0;\n            for (JetType upperBound : pd.getUpperBounds()) {\n                JetTypeElement altTypeElement;\n                JetTypeParameter parameter = altFunDeclaration.getTypeParameters().get(i);\n                if (upperBoundIndex == 0) {\n                    JetTypeReference extendsBound = parameter.getExtendsBound();\n                    if (extendsBound == null) { // default upper bound\n                        assert pd.getUpperBounds().size() == 1;\n                        altParamDescriptor.addDefaultUpperBound();\n                        break;\n                    }\n                    else {\n                        altTypeElement = extendsBound.getTypeElement();\n                    }\n                }\n                else {\n                    altTypeElement = findTypeParameterConstraint(altFunDeclaration, parameter.getNameAsName(), upperBoundIndex).getBoundTypeReference().getTypeElement();\n                }\n                altParamDescriptor.addUpperBound(computeType(altTypeElement, upperBound));\n                upperBoundIndex++;\n            }\n\n            altParamDescriptor.setInitialized();\n            altTypeParameters.add(altParamDescriptor);\n        }\n    }","id":79989,"modified_method":"private void computeTypeParameters(List<TypeParameterDescriptor> typeParameters) {\n\n        if (typeParameters.size() != altFunDeclaration.getTypeParameters().size()) {\n            fail(\"Method signature has %d type parameters, but alternative signature has %d\",\n                 typeParameters.size(), altFunDeclaration.getTypeParameters().size());\n        }\n\n        altTypeParameters = new ArrayList<TypeParameterDescriptor>();\n        for (int i = 0, size = typeParameters.size(); i < size; i++) {\n            TypeParameterDescriptor pd = typeParameters.get(i);\n            DeclarationDescriptor containingDeclaration = pd.getContainingDeclaration();\n            assert containingDeclaration != null;\n            TypeParameterDescriptorImpl altParamDescriptor = TypeParameterDescriptorImpl\n                    .createForFurtherModification(containingDeclaration, pd.getAnnotations(),\n                                                  pd.isReified(), pd.getVariance(), pd.getName(), pd.getIndex());\n            int upperBoundIndex = 0;\n            for (JetType upperBound : pd.getUpperBounds()) {\n                JetTypeElement altTypeElement;\n                JetTypeParameter parameter = altFunDeclaration.getTypeParameters().get(i);\n                if (upperBoundIndex == 0) {\n                    JetTypeReference extendsBound = parameter.getExtendsBound();\n                    if (extendsBound == null) { // default upper bound\n                        assert pd.getUpperBounds().size() == 1;\n                        altParamDescriptor.addDefaultUpperBound();\n                        break;\n                    }\n                    else {\n                        altTypeElement = extendsBound.getTypeElement();\n                    }\n                }\n                else {\n                    altTypeElement = findTypeParameterConstraint(altFunDeclaration, parameter.getNameAsName(), upperBoundIndex).getBoundTypeReference().getTypeElement();\n                }\n                altParamDescriptor.addUpperBound(computeType(altTypeElement, upperBound));\n                upperBoundIndex++;\n            }\n\n            altParamDescriptor.setInitialized();\n            altTypeParameters.add(altParamDescriptor);\n        }\n    }","commit_id":"6f8f62cc9a1010c593d99992a19622ee0a2d00be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void computeValueParameters(JavaDescriptorResolver.ValueParameterDescriptors valueParameterDescriptors) {\n        List<ValueParameterDescriptor> parameterDescriptors = valueParameterDescriptors.descriptors;\n\n        if (parameterDescriptors.size() != altFunDeclaration.getValueParameters().size()) {\n            throw new AlternativeSignatureMismatchException(\n                    String.format(\"Method signature has %d value parameters, but alternative signature has %d\",\n                                  parameterDescriptors.size(), altFunDeclaration.getValueParameters().size()));\n        }\n\n        List<ValueParameterDescriptor> altParamDescriptors = new ArrayList<ValueParameterDescriptor>();\n        for (int i = 0, size = parameterDescriptors.size(); i < size; i++) {\n            ValueParameterDescriptor pd = parameterDescriptors.get(i);\n            JetParameter valueParameter = altFunDeclaration.getValueParameters().get(i);\n            JetTypeElement alternativeTypeElement = valueParameter.getTypeReference().getTypeElement();\n            JetType alternativeType;\n            JetType alternativeVarargElementType;\n            if (pd.getVarargElementType() == null) {\n                if (valueParameter.isVarArg()) {\n                    throw new AlternativeSignatureMismatchException(\n                            \"Parameter in method signature is not vararg, but in alternative signature it is vararg\");\n                }\n                alternativeType = computeType(alternativeTypeElement, pd.getType());\n                alternativeVarargElementType = null;\n            }\n            else {\n                if (!valueParameter.isVarArg()) {\n                    throw new AlternativeSignatureMismatchException(\n                            \"Parameter in method signature is vararg, but in alternative signature it is not\");\n                }\n                alternativeVarargElementType = computeType(alternativeTypeElement, pd.getVarargElementType());\n                alternativeType = JetStandardLibrary.getInstance().getArrayType(alternativeVarargElementType);\n            }\n            altParamDescriptors.add(new ValueParameterDescriptorImpl(pd.getContainingDeclaration(), pd.getIndex(), pd.getAnnotations(),\n                                                                     pd.getName(), pd.isVar(), alternativeType, pd.declaresDefaultValue(),\n                                                                     alternativeVarargElementType));\n        }\n        JetType altReceiverType = null;\n        if (valueParameterDescriptors.receiverType != null) {\n            altReceiverType = computeType(altFunDeclaration.getReceiverTypeRef().getTypeElement(),\n                                          valueParameterDescriptors.receiverType);\n        }\n        altValueParameters = new JavaDescriptorResolver.ValueParameterDescriptors(altReceiverType, altParamDescriptors);\n    }","id":79990,"modified_method":"private void computeValueParameters(JavaDescriptorResolver.ValueParameterDescriptors valueParameterDescriptors) {\n        List<ValueParameterDescriptor> parameterDescriptors = valueParameterDescriptors.descriptors;\n\n        if (parameterDescriptors.size() != altFunDeclaration.getValueParameters().size()) {\n            fail(\"Method signature has %d value parameters, but alternative signature has %d\",\n                 parameterDescriptors.size(), altFunDeclaration.getValueParameters().size());\n        }\n\n        List<ValueParameterDescriptor> altParamDescriptors = new ArrayList<ValueParameterDescriptor>();\n        for (int i = 0, size = parameterDescriptors.size(); i < size; i++) {\n            ValueParameterDescriptor pd = parameterDescriptors.get(i);\n            JetParameter valueParameter = altFunDeclaration.getValueParameters().get(i);\n            JetTypeElement alternativeTypeElement = valueParameter.getTypeReference().getTypeElement();\n            JetType alternativeType;\n            JetType alternativeVarargElementType;\n            if (pd.getVarargElementType() == null) {\n                if (valueParameter.isVarArg()) {\n                    fail(\"Parameter in method signature is not vararg, but in alternative signature it is vararg\");\n                }\n                alternativeType = computeType(alternativeTypeElement, pd.getType());\n                alternativeVarargElementType = null;\n            }\n            else {\n                if (!valueParameter.isVarArg()) {\n                    fail(\"Parameter in method signature is vararg, but in alternative signature it is not\");\n                }\n                alternativeVarargElementType = computeType(alternativeTypeElement, pd.getVarargElementType());\n                alternativeType = JetStandardLibrary.getInstance().getArrayType(alternativeVarargElementType);\n            }\n            altParamDescriptors.add(new ValueParameterDescriptorImpl(pd.getContainingDeclaration(), pd.getIndex(), pd.getAnnotations(),\n                                                                     pd.getName(), pd.isVar(), alternativeType, pd.declaresDefaultValue(),\n                                                                     alternativeVarargElementType));\n        }\n        JetType altReceiverType = null;\n        if (valueParameterDescriptors.receiverType != null) {\n            altReceiverType = computeType(altFunDeclaration.getReceiverTypeRef().getTypeElement(),\n                                          valueParameterDescriptors.receiverType);\n        }\n        altValueParameters = new JavaDescriptorResolver.ValueParameterDescriptors(altReceiverType, altParamDescriptors);\n    }","commit_id":"6f8f62cc9a1010c593d99992a19622ee0a2d00be","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static ParserGrammar loadModel(String parserModel, String taggerModel) {\n    if (taggerModel == null) {\n      return ParserGrammar.loadModel(parserModel);\n    } else {\n      return ParserGrammar.loadModel(parserModel, \"-preTag\", \"-taggerSerializedFile\", taggerModel);\n    }\n  }","id":79991,"modified_method":"private static ParserGrammar loadModel(String parserModel, String taggerModel) {\n    ParserGrammar model;\n    if (taggerModel == null) {\n      model = ParserGrammar.loadModel(parserModel);\n    } else {\n      model = ParserGrammar.loadModel(parserModel, \"-preTag\", \"-taggerSerializedFile\", taggerModel);\n    }\n    model.setOptionFlags(model.defaultCoreNLPFlags());\n    return model;\n  }","commit_id":"97c37cf505e4b5bc61b17c8250c9a0b3c85e2614","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) \n    throws IOException\n  {\n    System.setOut(new PrintStream(System.out, true, \"utf-8\"));\n    System.setErr(new PrintStream(System.err, true, \"utf-8\"));\n\n    int port = DEFAULT_PORT;\n    String model = LexicalizedParser.DEFAULT_PARSER_LOC;\n    String tagger = null;\n\n    // TODO: rewrite this a bit to allow for passing flags to the parser\n    for (int i = 0; i < args.length; i += 2) {\n      if (i + 1 >= args.length) {\n        System.err.println(\"Unspecified argument \" + args[i]);\n        System.exit(2);\n      }\n      String arg = args[i];\n      if (arg.startsWith(\"--\")) {\n        arg = arg.substring(2);\n      } else if (arg.startsWith(\"-\")) {\n        arg = arg.substring(1);\n      }\n      if (arg.equalsIgnoreCase(\"model\")) {\n        model = args[i + 1];\n      } else if (arg.equalsIgnoreCase(\"port\")) {\n        port = Integer.valueOf(args[i + 1]);\n      } else if (arg.equalsIgnoreCase(\"tagger\")) {\n        tagger = args[i + 1];\n      } else if (arg.equalsIgnoreCase(\"help\")) {\n        help();\n        System.exit(0);\n      }\n    }\n    \n    LexicalizedParserServer server = new LexicalizedParserServer(port, model, tagger);\n    System.err.println(\"Server ready!\");\n    server.listen();\n  }","id":79992,"modified_method":"public static void main(String[] args) \n    throws IOException\n  {\n    System.setOut(new PrintStream(System.out, true, \"utf-8\"));\n    System.setErr(new PrintStream(System.err, true, \"utf-8\"));\n\n    int port = DEFAULT_PORT;\n    String model = LexicalizedParser.DEFAULT_PARSER_LOC;\n    String tagger = null;\n\n    for (int i = 0; i < args.length; i += 2) {\n      if (i + 1 >= args.length) {\n        System.err.println(\"Unspecified argument \" + args[i]);\n        System.exit(2);\n      }\n      String arg = args[i];\n      if (arg.startsWith(\"--\")) {\n        arg = arg.substring(2);\n      } else if (arg.startsWith(\"-\")) {\n        arg = arg.substring(1);\n      }\n      if (arg.equalsIgnoreCase(\"model\")) {\n        model = args[i + 1];\n      } else if (arg.equalsIgnoreCase(\"port\")) {\n        port = Integer.valueOf(args[i + 1]);\n      } else if (arg.equalsIgnoreCase(\"tagger\")) {\n        tagger = args[i + 1];\n      }\n    }\n    \n    LexicalizedParserServer server = new LexicalizedParserServer(port, model, tagger);\n    System.err.println(\"Server ready!\");\n    server.listen();\n  }","commit_id":"ed30d89578e63bde90a11eb8a023d3e932d607c1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static ParserGrammar loadModel(String parserModel, String taggerModel) {\n    ParserGrammar model;\n    if (taggerModel == null) {\n      model = ParserGrammar.loadModel(parserModel);\n    } else {\n      model = ParserGrammar.loadModel(parserModel, \"-preTag\", \"-taggerSerializedFile\", taggerModel);\n    }\n    model.setOptionFlags(model.defaultCoreNLPFlags());\n    return model;\n  }","id":79993,"modified_method":"private static ParserGrammar loadModel(String parserModel, String taggerModel) {\n    if (taggerModel == null) {\n      return ParserGrammar.loadModel(parserModel);\n    } else {\n      return ParserGrammar.loadModel(parserModel, \"-preTag\", \"-taggerSerializedFile\", taggerModel);\n    }\n  }","commit_id":"ed30d89578e63bde90a11eb8a023d3e932d607c1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static ParserGrammar loadModel(String parserModel, String taggerModel) {\n    if (taggerModel == null) {\n      return ParserGrammar.loadModel(parserModel);\n    } else {\n      return ParserGrammar.loadModel(parserModel, \"-preTag\", \"-taggerSerializedFile\", taggerModel);\n    }\n  }","id":79994,"modified_method":"private static ParserGrammar loadModel(String parserModel, String taggerModel) {\n    ParserGrammar model;\n    if (taggerModel == null) {\n      model = ParserGrammar.loadModel(parserModel);\n    } else {\n      model = ParserGrammar.loadModel(parserModel, \"-preTag\", \"-taggerSerializedFile\", taggerModel);\n    }\n    model.setOptionFlags(model.defaultCoreNLPFlags());\n    return model;\n  }","commit_id":"842001cf5637e193f91cc484bf9ba0cfb1d72a74","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) \n    throws IOException\n  {\n    System.setOut(new PrintStream(System.out, true, \"utf-8\"));\n    System.setErr(new PrintStream(System.err, true, \"utf-8\"));\n\n    int port = DEFAULT_PORT;\n    String model = LexicalizedParser.DEFAULT_PARSER_LOC;\n    String tagger = null;\n\n    for (int i = 0; i < args.length; i += 2) {\n      if (i + 1 >= args.length) {\n        System.err.println(\"Unspecified argument \" + args[i]);\n        System.exit(2);\n      }\n      String arg = args[i];\n      if (arg.startsWith(\"--\")) {\n        arg = arg.substring(2);\n      } else if (arg.startsWith(\"-\")) {\n        arg = arg.substring(1);\n      }\n      if (arg.equalsIgnoreCase(\"model\")) {\n        model = args[i + 1];\n      } else if (arg.equalsIgnoreCase(\"port\")) {\n        port = Integer.valueOf(args[i + 1]);\n      } else if (arg.equalsIgnoreCase(\"tagger\")) {\n        tagger = args[i + 1];\n      }\n    }\n    \n    LexicalizedParserServer server = new LexicalizedParserServer(port, model, tagger);\n    System.err.println(\"Server ready!\");\n    server.listen();\n  }","id":79995,"modified_method":"public static void main(String[] args) \n    throws IOException\n  {\n    System.setOut(new PrintStream(System.out, true, \"utf-8\"));\n    System.setErr(new PrintStream(System.err, true, \"utf-8\"));\n\n    int port = DEFAULT_PORT;\n    String model = LexicalizedParser.DEFAULT_PARSER_LOC;\n    String tagger = null;\n\n    // TODO: rewrite this a bit to allow for passing flags to the parser\n    for (int i = 0; i < args.length; i += 2) {\n      if (i + 1 >= args.length) {\n        System.err.println(\"Unspecified argument \" + args[i]);\n        System.exit(2);\n      }\n      String arg = args[i];\n      if (arg.startsWith(\"--\")) {\n        arg = arg.substring(2);\n      } else if (arg.startsWith(\"-\")) {\n        arg = arg.substring(1);\n      }\n      if (arg.equalsIgnoreCase(\"model\")) {\n        model = args[i + 1];\n      } else if (arg.equalsIgnoreCase(\"port\")) {\n        port = Integer.valueOf(args[i + 1]);\n      } else if (arg.equalsIgnoreCase(\"tagger\")) {\n        tagger = args[i + 1];\n      } else if (arg.equalsIgnoreCase(\"help\")) {\n        help();\n        System.exit(0);\n      }\n    }\n    \n    LexicalizedParserServer server = new LexicalizedParserServer(port, model, tagger);\n    System.err.println(\"Server ready!\");\n    server.listen();\n  }","commit_id":"842001cf5637e193f91cc484bf9ba0cfb1d72a74","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see InsertHTMLExecutable#getParameter()\n     */\n    @Override\n    public String getParameter()\n    {\n        E selectedElement = getSelectedElement();\n        if (selectedElement == null) {\n            return null;\n        }\n        return configJSONSerializer.serialize(configHTMLParser.parse(selectedElement));\n    }","id":79996,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see InsertHTMLExecutable#getParameter()\n     */\n    @Override\n    public String getParameter()\n    {\n        E selectedElement = getSelectedElement();\n        if (selectedElement == null) {\n            return null;\n        }\n        return configJSONSerializer.serialize(configDOMReader.read(selectedElement));\n    }","commit_id":"db215cd02e9372542a6640a1a1a4506363fbc0f1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see InsertHTMLExecutable#execute(String)\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean execute(String json)\n    {\n        String html = configHTMLSerializer.serialize(configJSONParser.parse(json));\n        E element = getSelectedElement();\n        if (element == null) {\n            // Insert a new element.\n            return super.execute(html);\n        } else {\n            // Overwrite an existing element.\n            Element container = Element.as(rta.getDocument().createDivElement());\n            // Inner HTML listeners have to be notified in order to extract the meta data.\n            container.xSetInnerHTML(html);\n            merge(element, (E) container.getFirstChild());\n            return true;\n        }\n    }","id":79997,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see InsertHTMLExecutable#execute(String)\n     */\n    @Override\n    public boolean execute(String json)\n    {\n        C config = configJSONParser.parse(json);\n        E element = getSelectedElement();\n        if (element == null) {\n            // Insert a new element.\n            element = newElement();\n            if (!super.execute(element)) {\n                return false;\n            }\n        }\n        // Update the selected element.\n        configDOMWriter.write(config, element);\n        return true;\n    }","commit_id":"db215cd02e9372542a6640a1a1a4506363fbc0f1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Fills the list with the given data and selects the specified item.\n     * \n     * @param dataList the list of data to fill the list\n     * @param selectedData the data to be selected\n     */\n    protected void fillList(List<L> dataList, L selectedData)\n    {\n        for (L data : dataList) {\n            ListItem<L> item = getListItem(data);\n            list.addItem(item);\n            // Restore the selection.\n            if (data.equals(selectedData) || isSelectedByDefault(data)) {\n                list.setSelectedItem(item);\n            }\n        }\n        ListItem<L> newOptionListItem = getNewOptionListItem();\n        if (newOptionListItem != null) {\n            if (newOptionOnTop) {\n                list.insertItem(newOptionListItem, 0);\n            } else {\n                list.addItem(newOptionListItem);\n            }\n            if (list.getSelectedItem() == null) {\n                list.setSelectedItem(newOptionListItem);\n            }\n        }\n    }","id":79998,"modified_method":"/**\n     * Fills the list with the given data and selects the specified item.\n     * \n     * @param dataList the list of data to fill the list\n     * @param selectedData the data to be selected\n     */\n    protected void fillList(List<L> dataList, L selectedData)\n    {\n        ListItem<L> selectedItem = null;\n        int selectedPriority = 0;\n        for (L data : dataList) {\n            ListItem<L> item = getListItem(data);\n            list.addItem(item);\n            // Restore the selection.\n            int priority = (isSelectedByDefault(data) ? 2 : 0) + (data.equals(selectedData) ? 1 : 0);\n            if (priority > selectedPriority) {\n                selectedPriority = priority;\n                selectedItem = item;\n            }\n        }\n        ListItem<L> newOptionListItem = getNewOptionListItem();\n        if (newOptionListItem != null) {\n            if (newOptionOnTop) {\n                list.insertItem(newOptionListItem, 0);\n            } else {\n                list.addItem(newOptionListItem);\n            }\n            if (selectedItem == null) {\n                selectedItem = newOptionListItem;\n            }\n        }\n        list.setSelectedItem(selectedItem);\n    }","commit_id":"db215cd02e9372542a6640a1a1a4506363fbc0f1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates a new executable that can be used to insert links in the specified rich text area.\n     * \n     * @param rta the execution target\n     */\n    public CreateLinkExecutable(RichTextArea rta)\n    {\n        super(rta);\n\n        configHTMLParser = new LinkConfigHTMLParser();\n        configHTMLSerializer = new LinkConfigHTMLSerializer();\n        configJSONParser = new LinkConfigJSONParser();\n        configJSONSerializer = new LinkConfigJSONSerializer();\n    }","id":79999,"modified_method":"/**\n     * Creates a new executable that can be used to insert links in the specified rich text area.\n     * \n     * @param rta the execution target\n     */\n    public CreateLinkExecutable(RichTextArea rta)\n    {\n        super(rta);\n\n        configDOMReader = new LinkConfigDOMReader();\n        configDOMWriter = new LinkConfigDOMWriter();\n        configJSONParser = new LinkConfigJSONParser();\n        configJSONSerializer = new LinkConfigJSONSerializer();\n    }","commit_id":"db215cd02e9372542a6640a1a1a4506363fbc0f1","url":"https://github.com/xwiki/xwiki-platform"}]