[{"original_method":"public String getSmallDescription(Context ctx) {\n\t\t\tString nm = name == null ? \"\" : name;\n\t\t\t\n\t\t\tString time = AndroidUtils.formatDateTime(ctx,file.lastModified());\n\t\t\tif (isPhoto()) {\n\t\t\t\treturn ctx.getString(R.string.recording_photo_description, nm, time).trim();\n\t\t\t}\n\t\t\treturn ctx.getString(R.string.recording_description, nm, \"\", time).trim();\n\t\t}","id":47000,"modified_method":"public String getSmallDescription(Context ctx) {\n\n\t\t\tString time = AndroidUtils.formatDateTime(ctx,file.lastModified());\n\t\t\tif (isPhoto()) {\n\t\t\t\treturn ctx.getString(R.string.recording_photo_description, \"\", time).trim();\n\t\t\t}\n\t\t\treturn ctx.getString(R.string.recording_description, \"\", \"\", time).trim();\n\t\t}","commit_id":"80be3b8b1c66e134d4fece0278e89ccc7e4202fc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setupNotes() {\n\t\tView mainView = getView();\n\t\tif (plugin == null){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\tList<AudioVideoNotesPlugin.Recording> notes = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tif (notes.size() == 0){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout notesLayout = (LinearLayout) mainView.findViewById(R.id.notes);\n\t\tnotesLayout.removeAllViews();\n\t\tif (notes.size() > 3){\n\t\t\twhile (notes.size() != 3){\n\t\t\t\tnotes.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (final AudioVideoNotesPlugin.Recording recording : notes){\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_audio_video_notes_item, null, false);\n\n\t\t\tgetNoteView(recording, view, getActivity(), plugin);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tgetMyApplication().getSettings().setMapLocationToShow(recording.getLatitude(), recording.getLongitude(), 15, \n\t\t\t\t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_NOTE, \n\t\t\t\t\t\t\t!Algorithms.isEmpty(recording.getName())? recording.getName() : recording.getDescription(getActivity())), true,\n\t\t\t\t\t\t\trecording); //$NON-NLS-1$\n\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t\t}\n\t\t\t});\n\t\t\tnotesLayout.addView(view);\n\t\t}\n\t}","id":47001,"modified_method":"public void setupNotes() {\n\t\tView mainView = getView();\n\t\tif (plugin == null){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\tList<AudioVideoNotesPlugin.Recording> notes = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tif (notes.size() == 0){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout notesLayout = (LinearLayout) mainView.findViewById(R.id.notes);\n\t\tnotesLayout.removeAllViews();\n\t\tif (notes.size() > 3){\n\t\t\twhile (notes.size() != 3){\n\t\t\t\tnotes.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (final AudioVideoNotesPlugin.Recording recording : notes){\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.note, null, false);\n\n\t\t\tgetNoteView(recording, view, getActivity(), plugin);\n\t\t\tview.findViewById(R.id.play).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tplugin.playRecording(getActivity(), recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\tview.findViewById(R.id.options).setVisibility(View.GONE);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tgetMyApplication().getSettings().setMapLocationToShow(recording.getLatitude(), recording.getLongitude(), 15, \n\t\t\t\t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_NOTE, \n\t\t\t\t\t\t\t(recording.getName() != null) ? recording.getName() : recording.getDescription(getActivity())), true,\n\t\t\t\t\t\t\trecording); //$NON-NLS-1$\n\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t\t}\n\t\t\t});\n\t\t\tnotesLayout.addView(view);\n\t\t}\n\t}","commit_id":"80be3b8b1c66e134d4fece0278e89ccc7e4202fc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void getNoteView(final AudioVideoNotesPlugin.Recording recording, View view,\n\t\t\t\t\t\t\t\t   final Context ctx, final AudioVideoNotesPlugin plugin) {\n\t\tif (recording.getName() != null){\n\t\t\t((TextView) view.findViewById(R.id.name)).setText(recording.getName());\n\t\t\t((TextView) view.findViewById(R.id.descr)).setText(recording.getDescription(ctx));\n\t\t} else {\n\t\t\t((TextView) view.findViewById(R.id.name)).setText(recording.getDescription(ctx));\n\t\t\tview.findViewById(R.id.descr).setVisibility(View.GONE);\n\t\t}\n\n\t\tImageView icon = (ImageView) view.findViewById(R.id.icon);\n\t\tif (recording.isAudio()){\n\t\t\ticon.setImageResource(R.drawable.ic_type_audio);\n\t\t} else if (recording.isVideo()){\n\t\t\ticon.setImageResource(R.drawable.ic_type_video);\n\t\t} else {\n\t\t\ticon.setImageResource(R.drawable.ic_type_img);\n\t\t}\n\n\t\tview.findViewById(R.id.play).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tplugin.playRecording(ctx, recording);\n\t\t\t}\n\t\t});\n\t}","id":47002,"modified_method":"public static void getNoteView(final AudioVideoNotesPlugin.Recording recording, View view,\n\t\t\t\t\t\t\t\t   final Context ctx, final AudioVideoNotesPlugin plugin) {\n\t\tString name = recording.getName();\n\t\tTextView nameText = ((TextView) view.findViewById(R.id.name));\n\t\tif (name != null) {\n\t\t\tnameText.setText(name);\n\t\t} else if (recording.isAudio()) {\n\t\t\tnameText.setText(R.string.audio);\n\t\t} else if (recording.isVideo()) {\n\t\t\tnameText.setText(R.string.video);\n\t\t} else if (recording.isPhoto()) {\n\t\t\tnameText.setText(R.string.photo);\n\t\t}\n\t\t((TextView) view.findViewById(R.id.descr)).setText(recording.getDescription(ctx));\n\n\t\tImageView icon = (ImageView) view.findViewById(R.id.icon);\n\t\tif (recording.isAudio()) {\n\t\t\ticon.setImageResource(R.drawable.ic_type_audio);\n\t\t} else if (recording.isVideo()) {\n\t\t\ticon.setImageResource(R.drawable.ic_type_video);\n\t\t} else {\n\t\t\ticon.setImageResource(R.drawable.ic_type_img);\n\t\t}\n\n\t}","commit_id":"80be3b8b1c66e134d4fece0278e89ccc7e4202fc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void editNote(final Recording recording) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n\t\tbuilder.setTitle(R.string.rename_recording);\n\t\tfinal View v = getActivity().getLayoutInflater().inflate(R.layout.note_edit_dialog,\n\t\t\t\tgetListView(), false);\n\t\tfinal EditText editText = (EditText) v.findViewById(R.id.name);\n\t\tbuilder.setView(v);\n\t\teditText.setText(recording.getName());\n\t\tbuilder.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\tbuilder.setPositiveButton(R.string.default_buttons_apply, new DialogInterface.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\trecording.setName(editText.getText().toString());\n\t\t\t\trecording.setDescription();\n\t\t\t\tlistAdapter.notifyDataSetInvalidated();\n\t\t\t}\n\t\t});\n\t\tbuilder.create().show();\n\t\teditText.requestFocus();\n\t}","id":47003,"modified_method":"private void editNote(final Recording recording) {\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n\t\tbuilder.setTitle(R.string.rename_recording);\n\t\tfinal View v = getActivity().getLayoutInflater().inflate(R.layout.note_edit_dialog,\n\t\t\t\tgetListView(), false);\n\t\tfinal EditText editText = (EditText) v.findViewById(R.id.name);\n\t\tbuilder.setView(v);\n\t\tString fileName = recording.getName();\n\t\tint extInd = recording.getName().lastIndexOf(\".\");\n\t\tfinal String extension;\n\t\tif (extInd >= 0){\n\t\t\textension = fileName.substring(extInd, fileName.length());\n\t\t} else {\n\t\t\textension = \"\";\n\t\t}\n\n\t\teditText.setText(recording.getName().substring(0, extInd));\n\t\tbuilder.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\tbuilder.setPositiveButton(R.string.default_buttons_apply, new DialogInterface.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\tif(!recording.setName(editText.getText().toString() + extension)) {\n\t\t\t\t\tToast.makeText(getActivity(),R.string.rename_failed,Toast.LENGTH_SHORT).show();\n\t\t\t\t}\n\t\t\t\trecording.setDescription();\n\t\t\t\tlistAdapter.notifyDataSetInvalidated();\n\t\t\t}\n\t\t});\n\t\tbuilder.create().show();\n\t\teditText.requestFocus();\n\t}","commit_id":"80be3b8b1c66e134d4fece0278e89ccc7e4202fc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\trow = inflater.inflate(R.layout.note, parent, false);\n\t\t\t}\n\n\t\t\tfinal AudioVideoNotesPlugin.Recording recording = getItem(position);\n\t\t\tString name = recording.getName();\n\t\t\tTextView nameText = ((TextView) row.findViewById(R.id.name));\n\t\t\tif (name != null) {\n\t\t\t\tnameText.setText(name);\n\t\t\t} else if (recording.isAudio()) {\n\t\t\t\tnameText.setText(R.string.audio);\n\t\t\t} else if (recording.isVideo()) {\n\t\t\t\tnameText.setText(R.string.video);\n\t\t\t} else if (recording.isPhoto()) {\n\t\t\t\tnameText.setText(R.string.photo);\n\t\t\t}\n\t\t\t((TextView) row.findViewById(R.id.descr)).setText(recording.getDescription(getActivity()));\n\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.icon);\n\t\t\tif (recording.isAudio()) {\n\t\t\t\ticon.setImageResource(R.drawable.ic_type_audio);\n\t\t\t} else if (recording.isVideo()) {\n\t\t\t\ticon.setImageResource(R.drawable.ic_type_video);\n\t\t\t} else {\n\t\t\t\ticon.setImageResource(R.drawable.ic_type_img);\n\t\t\t}\n\t\t\tImageButton options = (ImageButton) row.findViewById(R.id.options);\n\t\t\toptions.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\topenPopUpMenu(v, recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\trow.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tshowOnMap(recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn row;\n\t\t}","id":47004,"modified_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\trow = inflater.inflate(R.layout.note, parent, false);\n\t\t\t}\n\n\t\t\tfinal AudioVideoNotesPlugin.Recording recording = getItem(position);\n\t\t\tDashAudioVideoNotesFragment.getNoteView(recording, row, getActivity(), plugin);\n\t\t\trow.findViewById(R.id.play).setVisibility(View.GONE);\n\t\t\tImageButton options = (ImageButton) row.findViewById(R.id.options);\n\t\t\toptions.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\topenPopUpMenu(v, recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\trow.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tshowOnMap(recording);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn row;\n\t\t}","commit_id":"80be3b8b1c66e134d4fece0278e89ccc7e4202fc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void openPopUpMenu(View v, final AudioVideoNotesPlugin.Recording recording) {\n\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n\t\tDirectionsDialogs.setupPopUpMenuIcon(optionsMenu);\n\t\tMenuItem item;\n\t\tboolean isPhoto = recording.isPhoto();\n\t\tfinal int playIcon;\n\t\tif (isPhoto) {\n\t\t\tplayIcon = light ? R.drawable.ic_action_eye_light : R.drawable.ic_action_eye_dark;\n\t\t} else {\n\t\t\tplayIcon = light ? R.drawable.ic_play_light : R.drawable.ic_play_dark;\n\t\t}\n\t\titem = optionsMenu.getMenu().add(isPhoto ? R.string.watch : R.string.recording_context_menu_play)\n\t\t\t\t.setIcon(playIcon);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tplugin.playRecording(getActivity(), recording);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.search_shown_on_map)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_map_marker_light : R.drawable.ic_action_map_marker_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tshowOnMap(recording);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.share_fav)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_gshare_light : R.drawable.ic_action_gshare_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tIntent sharingIntent = new Intent(Intent.ACTION_SEND);\n\t\t\t\tif (recording.isPhoto()) {\n\t\t\t\t\tUri screenshotUri = Uri.parse(recording.file.getAbsolutePath());\n\t\t\t\t\tsharingIntent.setType(\"image/*\");\n\t\t\t\t\tsharingIntent.putExtra(Intent.EXTRA_STREAM, screenshotUri);\n\t\t\t\t} else if (recording.isAudio()) {\n\t\t\t\t\tUri audioUri = Uri.parse(recording.file.getAbsolutePath());\n\t\t\t\t\tsharingIntent.setType(\"audio/*\");\n\t\t\t\t\tsharingIntent.putExtra(Intent.EXTRA_STREAM, audioUri);\n\t\t\t\t} else if (recording.isVideo()) {\n\t\t\t\t\tUri videoUri = Uri.parse(recording.file.getAbsolutePath());\n\t\t\t\t\tsharingIntent.setType(\"video/*\");\n\t\t\t\t\tsharingIntent.putExtra(Intent.EXTRA_STREAM, videoUri);\n\t\t\t\t}\n\t\t\t\tstartActivity(Intent.createChooser(sharingIntent, getString(R.string.share_note)));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.local_index_mi_rename)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_edit_light : R.drawable.ic_action_edit_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\teditNote(recording);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.recording_context_menu_delete)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_delete_light : R.drawable.ic_action_delete_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n\t\t\t\tbuilder.setMessage(R.string.recording_delete_confirm);\n\t\t\t\tbuilder.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tplugin.deleteRecording(recording);\n\t\t\t\t\t\tlistAdapter.remove(recording);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbuilder.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\t\t\tbuilder.show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\toptionsMenu.show();\n\t}","id":47005,"modified_method":"private void openPopUpMenu(View v, final AudioVideoNotesPlugin.Recording recording) {\n\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n\t\tDirectionsDialogs.setupPopUpMenuIcon(optionsMenu);\n\t\tMenuItem item;\n\t\tboolean isPhoto = recording.isPhoto();\n\t\tfinal int playIcon;\n\t\tif (isPhoto) {\n\t\t\tplayIcon = light ? R.drawable.ic_action_eye_light : R.drawable.ic_action_eye_dark;\n\t\t} else {\n\t\t\tplayIcon = light ? R.drawable.ic_play_light : R.drawable.ic_play_dark;\n\t\t}\n\t\titem = optionsMenu.getMenu().add(isPhoto ? R.string.watch : R.string.recording_context_menu_play)\n\t\t\t\t.setIcon(playIcon);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tplugin.playRecording(getActivity(), recording);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.search_shown_on_map)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_map_marker_light : R.drawable.ic_action_map_marker_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tshowOnMap(recording);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.share_fav)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_gshare_light : R.drawable.ic_action_gshare_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tIntent sharingIntent = new Intent(Intent.ACTION_SEND);\n\t\t\t\tif (recording.isPhoto()) {\n\t\t\t\t\tUri screenshotUri = Uri.parse(recording.getFile().getAbsolutePath());\n\t\t\t\t\tsharingIntent.setType(\"image/*\");\n\t\t\t\t\tsharingIntent.putExtra(Intent.EXTRA_STREAM, screenshotUri);\n\t\t\t\t} else if (recording.isAudio()) {\n\t\t\t\t\tUri audioUri = Uri.parse(recording.getFile().getAbsolutePath());\n\t\t\t\t\tsharingIntent.setType(\"audio/*\");\n\t\t\t\t\tsharingIntent.putExtra(Intent.EXTRA_STREAM, audioUri);\n\t\t\t\t} else if (recording.isVideo()) {\n\t\t\t\t\tUri videoUri = Uri.parse(recording.getFile().getAbsolutePath());\n\t\t\t\t\tsharingIntent.setType(\"video/*\");\n\t\t\t\t\tsharingIntent.putExtra(Intent.EXTRA_STREAM, videoUri);\n\t\t\t\t}\n\t\t\t\tstartActivity(Intent.createChooser(sharingIntent, getString(R.string.share_note)));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.local_index_mi_rename)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_edit_light : R.drawable.ic_action_edit_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\teditNote(recording);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.recording_context_menu_delete)\n\t\t\t\t.setIcon(light ? R.drawable.ic_action_delete_light : R.drawable.ic_action_delete_dark);\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n\t\t\t\tbuilder.setMessage(R.string.recording_delete_confirm);\n\t\t\t\tbuilder.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tplugin.deleteRecording(recording);\n\t\t\t\t\t\tlistAdapter.remove(recording);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbuilder.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\t\t\tbuilder.show();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\toptionsMenu.show();\n\t}","commit_id":"80be3b8b1c66e134d4fece0278e89ccc7e4202fc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);\n\t\tTypeface typeface = FontCache.getRobotoMedium(getActivity());\n\t\t((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);\n\t\t((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);\n\n\t\t(view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tstartMapActivity();\n\t\t\t}\n\n\t\t\t\n\t\t});\n\t\t((ImageView) view.findViewById(R.id.map_image)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartMapActivity();\n\t\t\t}\n\t\t});\n\t\tsetMapImage(view);\n\n\t\treturn view;\n\t}","id":47006,"modified_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_map_fragment, container, false);\n\t\tTypeface typeface = FontCache.getRobotoMedium(getActivity());\n\t\t((TextView) view.findViewById(R.id.map_text)).setTypeface(typeface);\n\t\t((Button) view.findViewById(R.id.show_map)).setTypeface(typeface);\n\n\t\t(view.findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tstartMapActivity();\n\t\t\t}\n\n\t\t\t\n\t\t});\n\t\tview.findViewById(R.id.map_image).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartMapActivity();\n\t\t\t}\n\t\t});\n\t\tsetMapImage(view);\n\n\t\treturn view;\n\t}","commit_id":"2fb651dcabd6b69eb50982936c9b984f6f3d7d78","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * @return the control to be added on a MapInfoLayer \n\t * that shows a distance between \n\t * the current position on the map \n\t * and the location of the parked car\n\t */\n\tprivate TextInfoWidget createParkingPlaceInfoControl(final MapActivity map, Paint paintText, Paint paintSubText) {\n\t\tTextInfoWidget parkingPlaceControl = new TextInfoWidget(map, 0, paintText, paintSubText) {\n\t\t\tprivate float[] calculations = new float[1];\n\t\t\tprivate int cachedMeters = 0;\t\t\t\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\tLatLon parkingPoint = parkingLayer.getParkingPoint();\n\t\t\t\tif( parkingPoint != null && !map.getRoutingHelper().isFollowingMode()) {\n\t\t\t\t\tOsmandMapTileView view = map.getMapView();\n\t\t\t\t\tint d = 0;\n\t\t\t\t\tif (d == 0) {\n\t\t\t\t\t\tLocation.distanceBetween(view.getLatitude(), view.getLongitude(), parkingPoint.getLatitude(), parkingPoint.getLongitude(), calculations);\n\t\t\t\t\t\td = (int) calculations[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (distChanged(cachedMeters, d)) {\n\t\t\t\t\t\tcachedMeters = d;\n\t\t\t\t\t\tif (cachedMeters <= 20) {\n\t\t\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\t\t\tsetText(null, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString ds = OsmAndFormatter.getFormattedDistance(cachedMeters, map.getMyApplication());\n\t\t\t\t\t\t\tint ls = ds.lastIndexOf(' ');\n\t\t\t\t\t\t\tif (ls == -1) {\n\t\t\t\t\t\t\t\tsetText(ds, null);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetText(ds.substring(0, ls), ds.substring(ls + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (cachedMeters != 0) {\n\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\tsetText(null, null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\t\t\n\t\t\t\n\t\t\t/**\n\t\t\t * Utility method.\n\t\t\t * @param oldDist\n\t\t\t * @param dist\n\t\t\t * @return\n\t\t\t */\n\t\t\tprivate boolean distChanged(int oldDist, int dist){\n\t\t\t\tif(oldDist != 0 && Math.abs(oldDist - dist) < 30){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tparkingPlaceControl.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tOsmandMapTileView view = map.getMapView();\n\t\t\t\tAnimateDraggingMapThread thread = view.getAnimatedDraggingThread();\n\t\t\t\tLatLon parkingPoint = getParkingPosition();\n\t\t\t\tif (parkingPoint != null) {\n\t\t\t\t\tfloat fZoom = view.getFloatZoom() < 15 ? 15 : view.getFloatZoom();\n\t\t\t\t\tthread.startMoving(parkingPoint.getLatitude(), parkingPoint.getLongitude(), fZoom, true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tparkingPlaceControl.setText(null, null);\n\t\tparkingPlaceControl.setImageDrawable(map.getResources().getDrawable(R.drawable.list_activities_poi_parking));\n\t\treturn parkingPlaceControl;\n\t}","id":47007,"modified_method":"/**\n\t * @return the control to be added on a MapInfoLayer \n\t * that shows a distance between \n\t * the current position on the map \n\t * and the location of the parked car\n\t */\n\tprivate TextInfoWidget createParkingPlaceInfoControl(final MapActivity map, Paint paintText, Paint paintSubText) {\n\t\tTextInfoWidget parkingPlaceControl = new TextInfoWidget(map, 0, paintText, paintSubText) {\n\t\t\tprivate float[] calculations = new float[1];\n\t\t\tprivate int cachedMeters = 0;\t\t\t\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\tLatLon parkingPoint = parkingLayer.getParkingPoint();\n\t\t\t\tif( parkingPoint != null && !map.getRoutingHelper().isFollowingMode()) {\n\t\t\t\t\tOsmandMapTileView view = map.getMapView();\n\t\t\t\t\tint d = 0;\n\t\t\t\t\tif (d == 0) {\n\t\t\t\t\t\tLocation.distanceBetween(view.getLatitude(), view.getLongitude(), parkingPoint.getLatitude(), parkingPoint.getLongitude(), calculations);\n\t\t\t\t\t\td = (int) calculations[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (distChanged(cachedMeters, d)) {\n\t\t\t\t\t\tcachedMeters = d;\n\t\t\t\t\t\tif (cachedMeters <= 20) {\n\t\t\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\t\t\tsetText(null, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString ds = OsmAndFormatter.getFormattedDistance(cachedMeters, map.getMyApplication());\n\t\t\t\t\t\t\tint ls = ds.lastIndexOf(' ');\n\t\t\t\t\t\t\tif (ls == -1) {\n\t\t\t\t\t\t\t\tsetText(ds, null);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetText(ds.substring(0, ls), ds.substring(ls + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (cachedMeters != 0) {\n\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\tsetText(null, null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\t\t\n\t\t\t\n\t\t\t/**\n\t\t\t * Utility method.\n\t\t\t * @param oldDist\n\t\t\t * @param dist\n\t\t\t * @return\n\t\t\t */\n\t\t\tprivate boolean distChanged(int oldDist, int dist){\n\t\t\t\tif(oldDist != 0 && Math.abs(oldDist - dist) < 30){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tparkingPlaceControl.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tOsmandMapTileView view = map.getMapView();\n\t\t\t\tAnimateDraggingMapThread thread = view.getAnimatedDraggingThread();\n\t\t\t\tLatLon parkingPoint = getParkingPosition();\n\t\t\t\tif (parkingPoint != null) {\n\t\t\t\t\tfloat fZoom = view.getFloatZoom() < 15 ? 15 : view.getFloatZoom();\n\t\t\t\t\tthread.startMoving(parkingPoint.getLatitude(), parkingPoint.getLongitude(), fZoom, true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tparkingPlaceControl.setText(null, null);\n\t\tparkingPlaceControl.setImageDrawable(map.getResources().getDrawable(R.drawable.widget_parking));\n\t\treturn parkingPlaceControl;\n\t}","commit_id":"7d34f11e1765c0c789adeedecfc0e71a2f67d682","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tView v = convertView;\n\t\t\tif (v == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\tv = inflater.inflate(net.osmand.plus.R.layout.plugins_list_item, parent, false);\n\t\t\t}\n\t\t\tOsmandPlugin plugin = getItem(position);\n\t\t\tboolean toBeEnabled = restartPlugins.contains(plugin.getId());\n\t\t\tint resourceId = toBeEnabled ? R.drawable.marker1_enabled : R.drawable.marker1_disabled;\n\t\t\t\n\t\t\tfinal View row = v;\n\t\t\tTextView nameView = (TextView) row.findViewById(R.id.plugin_name);\n\t\t\tnameView.setText(plugin.getName());\n\t\t\tnameView.setCompoundDrawablesWithIntrinsicBounds(getResources().getDrawable(R.drawable.list_activities_plugin_menu_symbol), null, getResources().getDrawable(resourceId), null);\n\t\t\tnameView.setContentDescription(plugin.getName() + \" \" + getString(toBeEnabled ? R.string.item_checked : R.string.item_unchecked));\n\t\t\t\n\t\t\tTextView description = (TextView) row.findViewById(R.id.plugin_descr);\n\t\t\tdescription.setText(plugin.getDescription());\n\t\t\tdescription.setVisibility(clickedPlugins.contains(plugin.getId()) || !restartPlugins.contains(plugin.getId()) ? View.VISIBLE : View.GONE);\n\t\t\tdescription.setTextColor(toBeEnabled? colorGreen : Color.LTGRAY);\n\n\t\t\treturn row;\n\t\t}","id":47008,"modified_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tView v = convertView;\n\t\t\tif (v == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\tv = inflater.inflate(net.osmand.plus.R.layout.plugins_list_item, parent, false);\n\t\t\t}\n\t\t\tOsmandPlugin plugin = getItem(position);\n\t\t\tboolean toBeEnabled = restartPlugins.contains(plugin.getId());\n\t\t\t\n\t\t\tfinal View row = v;\n\t\t\tCheckBox ch = (CheckBox) row.findViewById(R.id.check_item);\n\t\t\tch.setOnClickListener(null);\n\t\t\tch.setChecked(toBeEnabled);\n\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tclick(position);\n\t\t\t\t}\n\t\t\t});\n\t\t\tTextView nameView = (TextView) row.findViewById(R.id.plugin_name);\n\t\t\tnameView.setText(plugin.getName());\n\t\t\tnameView.setContentDescription(plugin.getName() + \" \" + getString(toBeEnabled ? R.string.item_checked : R.string.item_unchecked));\n\t\t\t\n\t\t\t\n\t\t\tTextView description = (TextView) row.findViewById(R.id.plugin_descr);\n\t\t\tdescription.setText(plugin.getDescription());\n\t\t\tdescription.setVisibility(clickedPlugins.contains(plugin.getId()) ||\n\t\t\t\t\t!restartPlugins.contains(plugin.getId()) ? View.VISIBLE : View.GONE);\n\t\t\tdescription.setTextColor(Color.LTGRAY);\n\n\t\t\treturn row;\n\t\t}","commit_id":"7d34f11e1765c0c789adeedecfc0e71a2f67d682","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\t\t\t\t\n\t\tOsmandPlugin item = getListAdapter().getItem(position);\n\t\tboolean enable = !restartPlugins.contains(item.getId());\n\t\tboolean ok = OsmandPlugin.enablePlugin(((OsmandApplication) getApplication()), item, enable);\n\t\tif (ok) {\n\t\t\tif (!enable) {\n\t\t\t\trestartPlugins.remove(item.getId());\n\t\t\t} else {\n\t\t\t\trestartPlugins.add(item.getId());\n\t\t\t}\n\t\t\tsetResult(ACTIVE_PLUGINS_LIST_MODIFIED);\n\t\t}\n\t\tclickedPlugins.add(item.getId());\n\t\tgetListAdapter().notifyDataSetChanged();\n\t}","id":47009,"modified_method":"@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\t\t\t\t\n\t\tclick(position);\n\t}","commit_id":"7d34f11e1765c0c789adeedecfc0e71a2f67d682","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {\n\t\t// customize the sub-preference title according the selected profile\n\t\tString title = \"\";\n\t\tif (preference.getKey() != null && preference instanceof PreferenceScreen\n\t\t\t\t&& SettingsActivity.SCREEN_ID_NAVIGATION_SETTINGS.equals(preference.getKey())) {\n\t\t\tfinal ApplicationMode appMode = osmandSettings.getApplicationMode();\n\t\t\tPreferenceScreen scr = (PreferenceScreen) preference;\n\t\t\ttitle = scr.getTitle().toString();\n\t\t\tif (title.startsWith(\"-\")) {\n\t\t\t\ttitle = title.substring(1);\n\t\t\t}\n\t\t\tBuilder builder = new AlertDialog.Builder(this);\n\t\t\tView view = getLayoutInflater().inflate(R.layout.navigate_mode, null);\n\t\t\tbuilder.setView(view);\n\t\t\tfinal AlertDialog dlg = builder.show();\n\t\t\t\n\t\t\tfinal Button[] buttons = new Button[ApplicationMode.values().length];\n\t\t\tbuttons[ApplicationMode.CAR.ordinal()] = (Button) view.findViewById(R.id.CarButton);\n\t\t\tbuttons[ApplicationMode.BICYCLE.ordinal()] = (Button) view.findViewById(R.id.BicycleButton);\n\t\t\tbuttons[ApplicationMode.PEDESTRIAN.ordinal()] = (Button) view.findViewById(R.id.PedestrianButton);\n\t\t\tfinal Dialog scrDialog = scr.getDialog();\n\t\t\tfinal String tlt = \"   \" + title;\n\t\t\tfor (int i = 0; i < buttons.length; i++) {\n\t\t\t\tif (buttons[i] != null) {\n\t\t\t\t\tfinal int ind = i;\n\t\t\t\t\tfinal Button b = buttons[i];\n\t\t\t\t\tb.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tApplicationMode selected = ApplicationMode.values()[ind];\n\t\t\t\t\t\t\tosmandSettings.APPLICATION_MODE.set(selected);\n\t\t\t\t\t\t\tupdateAllSettings();\n\t\t\t\t\t\t\tscrDialog.setTitle(tlt + \" [\" + selected.toHumanString(getMyApplication()) + \"]\");\n\t\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tscrDialog.setTitle(tlt + \" [\" + appMode  +\"] \");\n\t\t\tscr.getDialog().setOnDismissListener(new OnDismissListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onDismiss(DialogInterface dialog) {\n\t\t\t\t\tosmandSettings.APPLICATION_MODE.set(appMode);\n\t\t\t\t\tupdateAllSettings();\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (preference instanceof PreferenceScreen) {\n\t\t\tfinal PreferenceScreen scr = (PreferenceScreen) preference;\n\t\t\ttitle = scr.getTitle().toString();\n\t\t\tscr.getDialog().setTitle(\"   \" + title);\n\t\t}\n\t\tif (preference instanceof PreferenceScreen) {\n\t\t\tfinal PreferenceScreen scr = (PreferenceScreen) preference;\n\t\t\tCustomTitleBarView titleBar = new CustomTitleBarView(title, R.drawable.tab_settings_screen_icon, null) {\n\t\t\t\t@Override\n\t\t\t\tpublic void backPressed() {\n\t\t\t\t\tscr.getDialog().dismiss();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tView titleView = getLayoutInflater().inflate(titleBar.getTitleBarLayout(), null);\n\t\t\ttitleBar.init(titleView);\n\t\t\t// View decorView = scr.getDialog().getWindow().getDecorView();\n\t\t\t// LinearLayout ll = new LinearLayout(titleView.getContext());\n\t\t\t// scr.getDialog().getWindow().setContentView(ll);\n\t\t\tView dv = scr.getDialog().getWindow().getDecorView();\n\t\t\tListView ls = (ListView) dv.findViewById(android.R.id.list);\n\t\t\tif (ls != null) {\n\t\t\t\tls.addFooterView(titleView);\n\t\t\t}\n\n\t\t\t// LayoutParams lp = new ViewGroup.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n\t\t\t// scr.getDialog().addContentView(titleView, lp);\n\n\t\t\t// ll.setOrientation(LinearLayout.VERTICAL);\n\t\t\t// ll.addView(titleView);\n\t\t\t// ll.addView(decorView);\n\n\t\t}\n\n\t\tif (preference == applicationDir) {\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onPreferenceTreeClick(preferenceScreen, preference);\n\t}","id":47010,"modified_method":"@Override\n\tpublic boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {\n\t\t// customize the sub-preference title according the selected profile\n\t\tString title = \"\";\n\t\tif (preference.getKey() != null && preference instanceof PreferenceScreen\n\t\t\t\t&& SettingsActivity.SCREEN_ID_NAVIGATION_SETTINGS.equals(preference.getKey())) {\n\t\t\tfinal ApplicationMode appMode = osmandSettings.getApplicationMode();\n\t\t\tPreferenceScreen scr = (PreferenceScreen) preference;\n\t\t\ttitle = scr.getTitle().toString();\n\t\t\tif (title.startsWith(\"-\")) {\n\t\t\t\ttitle = title.substring(1);\n\t\t\t}\n\t\t\tBuilder builder = new AlertDialog.Builder(this);\n\t\t\tView view = getLayoutInflater().inflate(R.layout.navigate_mode, null);\n\t\t\tbuilder.setView(view);\n\t\t\tfinal AlertDialog dlg = builder.show();\n\t\t\t\n\t\t\tfinal View[] buttons = new View[ApplicationMode.values().length];\n\t\t\tbuttons[ApplicationMode.CAR.ordinal()] = view.findViewById(R.id.CarButton);\n\t\t\tbuttons[ApplicationMode.BICYCLE.ordinal()] =view.findViewById(R.id.BicycleButton);\n\t\t\tbuttons[ApplicationMode.PEDESTRIAN.ordinal()] = view.findViewById(R.id.PedestrianButton);\n\t\t\tfinal Dialog scrDialog = scr.getDialog();\n\t\t\tfinal String tlt = \"   \" + title;\n\t\t\tfor (int i = 0; i < buttons.length; i++) {\n\t\t\t\tif (buttons[i] != null) {\n\t\t\t\t\tfinal int ind = i;\n\t\t\t\t\tfinal View b = buttons[i];\n\t\t\t\t\tb.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\t\tApplicationMode selected = ApplicationMode.values()[ind];\n\t\t\t\t\t\t\tosmandSettings.APPLICATION_MODE.set(selected);\n\t\t\t\t\t\t\tupdateAllSettings();\n\t\t\t\t\t\t\tscrDialog.setTitle(tlt + \" [\" + selected.toHumanString(getMyApplication()) + \"]\");\n\t\t\t\t\t\t\tdlg.dismiss();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tscrDialog.setTitle(tlt + \" [\" + appMode  +\"] \");\n\t\t\tscr.getDialog().setOnDismissListener(new OnDismissListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onDismiss(DialogInterface dialog) {\n\t\t\t\t\tosmandSettings.APPLICATION_MODE.set(appMode);\n\t\t\t\t\tupdateAllSettings();\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (preference instanceof PreferenceScreen) {\n\t\t\tfinal PreferenceScreen scr = (PreferenceScreen) preference;\n\t\t\ttitle = scr.getTitle().toString();\n\t\t\tscr.getDialog().setTitle(\"   \" + title);\n\t\t}\n\t\tif (preference instanceof PreferenceScreen) {\n\t\t\tfinal PreferenceScreen scr = (PreferenceScreen) preference;\n\t\t\tCustomTitleBarView titleBar = new CustomTitleBarView(title, R.drawable.tab_settings_screen_icon, null) {\n\t\t\t\t@Override\n\t\t\t\tpublic void backPressed() {\n\t\t\t\t\tscr.getDialog().dismiss();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tView titleView = getLayoutInflater().inflate(titleBar.getTitleBarLayout(), null);\n\t\t\ttitleBar.init(titleView);\n\t\t\t// View decorView = scr.getDialog().getWindow().getDecorView();\n\t\t\t// LinearLayout ll = new LinearLayout(titleView.getContext());\n\t\t\t// scr.getDialog().getWindow().setContentView(ll);\n\t\t\tView dv = scr.getDialog().getWindow().getDecorView();\n\t\t\tListView ls = (ListView) dv.findViewById(android.R.id.list);\n\t\t\tif (ls != null) {\n\t\t\t\tls.addFooterView(titleView);\n\t\t\t}\n\n\t\t\t// LayoutParams lp = new ViewGroup.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n\t\t\t// scr.getDialog().addContentView(titleView, lp);\n\n\t\t\t// ll.setOrientation(LinearLayout.VERTICAL);\n\t\t\t// ll.addView(titleView);\n\t\t\t// ll.addView(decorView);\n\n\t\t}\n\n\t\tif (preference == applicationDir) {\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onPreferenceTreeClick(preferenceScreen, preference);\n\t}","commit_id":"7d34f11e1765c0c789adeedecfc0e71a2f67d682","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void deleteObject(OsMoGroup selectedObject) {\n\t\tif (!checkOperationIsNotRunning()) {\n\t\t\treturn;\n\t\t}\n\t\tString operation = osMoPlugin.getGroups().leaveGroup((OsMoGroup) selectedObject);\n\t\tstartLongRunningOperation(operation);\n\t\tadapter.update((OsMoGroup) selectedObject);\n\t\tadapter.notifyDataSetChanged();\n\n\t}","id":47011,"modified_method":"protected void deleteObject(OsMoGroup selectedObject) {\n\t\tif (!checkOperationIsNotRunning()) {\n\t\t\treturn;\n\t\t}\n\t\tString operation = osMoPlugin.getGroups().leaveGroup(selectedObject);\n\t\tstartLongRunningOperation(operation);\n\t\tadapter.update(selectedObject);\n\t\tadapter.notifyDataSetChanged();\n\n\t}","commit_id":"ebaf4e53c53415c786267f25e80c9ec9b59265a5","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void hideProgressBar() {\n\t\tOsMoGroupsActivity.this.operation = null;\n\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t}","id":47012,"modified_method":"public void hideProgressBar() {\n\t\tthis.operation = null;\n\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t}","commit_id":"ebaf4e53c53415c786267f25e80c9ec9b59265a5","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getGroupView(final int groupPosition, final boolean isExpanded, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\trow = inflater.inflate(R.layout.osmo_group_item, parent, false);\n\t\t\t\t//fixBackgroundRepeat(row);\n\t\t\t}\n\t\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\t\tadjustIndicator(groupPosition, isExpanded, row, light);\n\t\t\tTextView label = (TextView) row.findViewById(R.id.category_name);\n\t\t\tfinal OsMoGroup model = getGroup(groupPosition);\n\t\t\tif(selectedObject == model) {\n\t\t\t\trow.setBackgroundColor(getResources().getColor(R.color.row_selection_color));\n\t\t\t} else {\n\t\t\t\trow.setBackgroundColor(Color.TRANSPARENT);\n\t\t\t}\n\t\t\tlabel.setText(model.getVisibleName(OsMoGroupsActivity.this));\n\t\t\tif(model.isMainGroup() || model.isActive()) {\n\t\t\t\tlabel.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t} else {\n\t\t\t\tlabel.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);\n\t\t\t}\n\t\t\tView v = (View) row.findViewById(R.id.settings);\n\t\t\tif(model.isMainGroup()) {\n\t\t\t\tv.setVisibility(View.GONE);\n\t\t\t} else {\n//\t\t\t\t(ImageView) v.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_settings));\n\n\t\t\t\tif((selectedObject == model) != ((CheckBox) v).isChecked()) {\n\t\t\t\t\t((CheckBox) v).setChecked(selectedObject == model);\n\t\t\t\t}\n\t\t\t\tv.setVisibility(View.VISIBLE);\n\t\t\t\tv.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tif (model != selectedObject) {\n\t\t\t\t\t\t\tenterSelectionMode(model);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tquitSelectionMode();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tCompoundButton ci = (CompoundButton) row.findViewById(R.id.check_item);\n\t\t\tif(model.isMainGroup()) {\n\t\t\t\tci.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tci.setVisibility(View.VISIBLE);\n\t\t\t\tci.setOnCheckedChangeListener(null);\n\t\t\t\tci.setChecked(model.isEnabled() && model.isActive());\n\t\t\t\tci.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\tif(isChecked) {\n\t\t\t\t\t\t\tString operation = osMoPlugin.getGroups().connectGroup(model);\n\t\t\t\t\t\t\tstartLongRunningOperation(operation);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString operation = osMoPlugin.getGroups().disconnectGroup(model);\n\t\t\t\t\t\t\tstartLongRunningOperation(operation);\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn row;\n\t\t}","id":47013,"modified_method":"@Override\n\t\tpublic View getGroupView(final int groupPosition, final boolean isExpanded, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\trow = inflater.inflate(R.layout.osmo_group_item, parent, false);\n\t\t\t\t//fixBackgroundRepeat(row);\n\t\t\t}\n\t\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\t\tadjustIndicator(groupPosition, isExpanded, row, light);\n\t\t\tTextView label = (TextView) row.findViewById(R.id.category_name);\n\t\t\tfinal OsMoGroup model = getGroup(groupPosition);\n\t\t\tif(selectedObject == model) {\n\t\t\t\trow.setBackgroundColor(getResources().getColor(R.color.row_selection_color));\n\t\t\t} else {\n\t\t\t\trow.setBackgroundColor(Color.TRANSPARENT);\n\t\t\t}\n\t\t\tlabel.setText(model.getVisibleName(OsMoGroupsActivity.this));\n\t\t\tif(model.isMainGroup() || model.isActive()) {\n\t\t\t\tlabel.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t} else {\n\t\t\t\tlabel.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);\n\t\t\t}\n\t\t\tView v = row.findViewById(R.id.settings);\n\t\t\tif(model.isMainGroup()) {\n\t\t\t\tv.setVisibility(View.GONE);\n\t\t\t} else {\n//\t\t\t\t(ImageView) v.setImageDrawable(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_settings));\n\n\t\t\t\tif((selectedObject == model) != ((CheckBox) v).isChecked()) {\n\t\t\t\t\t((CheckBox) v).setChecked(selectedObject == model);\n\t\t\t\t}\n\t\t\t\tv.setVisibility(View.VISIBLE);\n\t\t\t\tv.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\t\tif (model != selectedObject) {\n\t\t\t\t\t\t\tenterSelectionMode(model);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tquitSelectionMode();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tCompoundButton ci = (CompoundButton) row.findViewById(R.id.check_item);\n\t\t\tif(model.isMainGroup()) {\n\t\t\t\tci.setVisibility(View.GONE);\n\t\t\t} else {\n\t\t\t\tci.setVisibility(View.VISIBLE);\n\t\t\t\tci.setOnCheckedChangeListener(null);\n\t\t\t\tci.setChecked(model.isEnabled() && model.isActive());\n\t\t\t\tci.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n\t\t\t\t\t\tif(isChecked) {\n\t\t\t\t\t\t\tString operation = osMoPlugin.getGroups().connectGroup(model);\n\t\t\t\t\t\t\tstartLongRunningOperation(operation);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString operation = osMoPlugin.getGroups().disconnectGroup(model);\n\t\t\t\t\t\t\tstartLongRunningOperation(operation);\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn row;\n\t\t}","commit_id":"ebaf4e53c53415c786267f25e80c9ec9b59265a5","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onPostExecute(IncrementalChangesManager.IncrementalUpdateList result) {\n\t\tLOG.debug(\"onPostExecute\");\n\t\tif (context instanceof AbstractDownloadActivity) {\n\t\t\tAbstractDownloadActivity activity = (AbstractDownloadActivity) context;\n\t\t\tactivity.setSupportProgressBarIndeterminateVisibility(false);\n\t\t}\n\t\tfinal OsmandApplication application = getMyApplication();\n\t\tfinal OsmandSettings settings = application.getSettings();\n\t\tif (result.errorMessage != null) {\n\t\t\tLOG.info(result.errorMessage);\n\t\t\ttryRescheduleDownload(context, settings, localIndexInfo);\n\t\t} else {\n\t\t\tsettings.LIVE_UPDATES_RETRIES.resetToDefault();\n\t\t\tList<IncrementalChangesManager.IncrementalUpdate> ll = result.getItemsForUpdate();\n\t\t\tif (!ll.isEmpty()) {\n\t\t\t\tArrayList<IndexItem> itemsToDownload = new ArrayList<>(ll.size());\n\t\t\t\tfor (IncrementalChangesManager.IncrementalUpdate iu : ll) {\n\t\t\t\t\tIndexItem indexItem = new IndexItem(iu.fileName, \"Incremental update\",\n\t\t\t\t\t\t\tiu.timestamp, iu.sizeText, iu.contentSize,\n\t\t\t\t\t\t\tiu.containerSize, DownloadActivityType.LIVE_UPDATES_FILE);\n\t\t\t\t\titemsToDownload.add(indexItem);\n\t\t\t\t}\n\t\t\t\tDownloadIndexesThread downloadThread = application.getDownloadThread();\n\t\t\t\tif (context instanceof DownloadIndexesThread.DownloadEvents) {\n\t\t\t\t\tdownloadThread.setUiActivity((DownloadIndexesThread.DownloadEvents) context);\n\t\t\t\t}\n\t\t\t\tboolean downloadViaWiFi =\n\t\t\t\t\t\tLiveUpdatesHelper.preferenceDownloadViaWiFi(localIndexInfo, settings).get();\n\t\t\t\tif (getMyApplication().getSettings().isInternetConnectionAvailable()) {\n\t\t\t\t\tif (forceUpdate || settings.isWifiConnected() || !downloadViaWiFi) {\n\t\t\t\t\t\tlong szLong = 0;\n\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\tfor (IndexItem es : downloadThread.getCurrentDownloadingItems()) {\n\t\t\t\t\t\t\tszLong += es.getContentSize();\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (IndexItem es : itemsToDownload) {\n\t\t\t\t\t\t\tszLong += es.getContentSize();\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble sz = ((double) szLong) / (1 << 20);\n\t\t\t\t\t\t// get availabile space\n\t\t\t\t\t\tdouble asz = downloadThread.getAvailableSpace();\n\t\t\t\t\t\tif (asz == -1 || asz <= 0 || sz / asz <= 0.4) {\n\t\t\t\t\t\t\tIndexItem[] itemsArray = new IndexItem[itemsToDownload.size()];\n\t\t\t\t\t\t\titemsArray = itemsToDownload.toArray(itemsArray);\n\t\t\t\t\t\t\tdownloadThread.runDownloadFiles(itemsArray);\n\t\t\t\t\t\t\tif (context instanceof DownloadIndexesThread.DownloadEvents) {\n\t\t\t\t\t\t\t\t((DownloadIndexesThread.DownloadEvents) context).downloadInProgress();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (context instanceof DownloadIndexesThread.DownloadEvents) {\n\t\t\t\t\t((DownloadIndexesThread.DownloadEvents) context).downloadInProgress();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":47014,"modified_method":"@Override\n\tprotected void onPostExecute(IncrementalChangesManager.IncrementalUpdateList result) {\n\t\tLOG.debug(\"onPostExecute\");\n\t\tif (context instanceof AbstractDownloadActivity) {\n\t\t\tAbstractDownloadActivity activity = (AbstractDownloadActivity) context;\n\t\t\tactivity.setSupportProgressBarIndeterminateVisibility(false);\n\t\t}\n\t\tfinal OsmandApplication application = getMyApplication();\n\t\tfinal OsmandSettings settings = application.getSettings();\n\t\tif (result.errorMessage != null) {\n\t\t\tLOG.info(result.errorMessage);\n\t\t\ttryRescheduleDownload(context, settings, localIndexInfo);\n\t\t} else {\n\t\t\tsettings.LIVE_UPDATES_RETRIES.resetToDefault();\n\t\t\tList<IncrementalChangesManager.IncrementalUpdate> ll = result.getItemsForUpdate();\n\t\t\tif (ll != null && !ll.isEmpty()) {\n\t\t\t\tArrayList<IndexItem> itemsToDownload = new ArrayList<>(ll.size());\n\t\t\t\tfor (IncrementalChangesManager.IncrementalUpdate iu : ll) {\n\t\t\t\t\tIndexItem indexItem = new IndexItem(iu.fileName, \"Incremental update\",\n\t\t\t\t\t\t\tiu.timestamp, iu.sizeText, iu.contentSize,\n\t\t\t\t\t\t\tiu.containerSize, DownloadActivityType.LIVE_UPDATES_FILE);\n\t\t\t\t\titemsToDownload.add(indexItem);\n\t\t\t\t}\n\t\t\t\tDownloadIndexesThread downloadThread = application.getDownloadThread();\n\t\t\t\tif (context instanceof DownloadIndexesThread.DownloadEvents) {\n\t\t\t\t\tdownloadThread.setUiActivity((DownloadIndexesThread.DownloadEvents) context);\n\t\t\t\t}\n\t\t\t\tboolean downloadViaWiFi =\n\t\t\t\t\t\tLiveUpdatesHelper.preferenceDownloadViaWiFi(localIndexInfo, settings).get();\n\t\t\t\tif (getMyApplication().getSettings().isInternetConnectionAvailable()) {\n\t\t\t\t\tif (forceUpdate || settings.isWifiConnected() || !downloadViaWiFi) {\n\t\t\t\t\t\tlong szLong = 0;\n\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\tfor (IndexItem es : downloadThread.getCurrentDownloadingItems()) {\n\t\t\t\t\t\t\tszLong += es.getContentSize();\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (IndexItem es : itemsToDownload) {\n\t\t\t\t\t\t\tszLong += es.getContentSize();\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdouble sz = ((double) szLong) / (1 << 20);\n\t\t\t\t\t\t// get availabile space\n\t\t\t\t\t\tdouble asz = downloadThread.getAvailableSpace();\n\t\t\t\t\t\tif (asz == -1 || asz <= 0 || sz / asz <= 0.4) {\n\t\t\t\t\t\t\tIndexItem[] itemsArray = new IndexItem[itemsToDownload.size()];\n\t\t\t\t\t\t\titemsArray = itemsToDownload.toArray(itemsArray);\n\t\t\t\t\t\t\tdownloadThread.runDownloadFiles(itemsArray);\n\t\t\t\t\t\t\tif (context instanceof DownloadIndexesThread.DownloadEvents) {\n\t\t\t\t\t\t\t\t((DownloadIndexesThread.DownloadEvents) context).downloadInProgress();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (context instanceof DownloadIndexesThread.DownloadEvents) {\n\t\t\t\t\t((DownloadIndexesThread.DownloadEvents) context).downloadInProgress();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"ebaf4e53c53415c786267f25e80c9ec9b59265a5","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void setupButtons(){\n\t\tfinal Activity activity = this;\n\t\tfinal OsmAndAppCustomization appCustomization = getMyApplication().getAppCustomization();\n\n\t\tButton showMap = (Button) findViewById(R.id.show_map);\n\t\tshowMap.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent mapIndent = new Intent(activity, appCustomization.getMapActivity());\n\t\t\t\tactivity.startActivityForResult(mapIndent, 0);\n\t\t\t}\n\t\t});\n\n\t\tButton showFavorites = (Button) findViewById(R.id.show_all);\n\t\tshowFavorites.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent favorites = new Intent(activity, appCustomization.getFavoritesActivity());\n\t\t\t\tfavorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tactivity.startActivity(favorites);\n\t\t\t}\n\t\t});\n\t}","id":47015,"modified_method":"private void setupButtons(){\n\t\tfinal Activity activity = this;\n\t\tfinal OsmAndAppCustomization appCustomization = getMyApplication().getAppCustomization();\n\n\t\t(findViewById(R.id.show_map)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent mapIndent = new Intent(activity, appCustomization.getMapActivity());\n\t\t\t\tactivity.startActivityForResult(mapIndent, 0);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent favorites = new Intent(activity, appCustomization.getFavoritesActivity());\n\t\t\t\tfavorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tactivity.startActivity(favorites);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.poi)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent search = new Intent(activity, appCustomization.getSearchActivity());\n\t\t\t\tsearch.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tgetMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.POI_TAB_INDEX);\n\t\t\t\tactivity.startActivity(search);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.address)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent search = new Intent(activity, appCustomization.getSearchActivity());\n\t\t\t\tsearch.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tgetMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.ADDRESS_TAB_INDEX);\n\t\t\t\tactivity.startActivity(search);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.coord)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent search = new Intent(activity, appCustomization.getSearchActivity());\n\t\t\t\tsearch.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tgetMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.LOCATION_TAB_INDEX);\n\t\t\t\tactivity.startActivity(search);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.fav_btn)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent search = new Intent(activity, appCustomization.getSearchActivity());\n\t\t\t\tsearch.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tgetMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.FAVORITES_TAB_INDEX);\n\t\t\t\tactivity.startActivity(search);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.history)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent search = new Intent(activity, appCustomization.getSearchActivity());\n\t\t\t\tsearch.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tgetMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.HISTORY_TAB_INDEX);\n\t\t\t\tactivity.startActivity(search);\n\t\t\t}\n\t\t});\n\n\t\t(findViewById(R.id.transport)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent search = new Intent(activity, appCustomization.getSearchActivity());\n\t\t\t\tsearch.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tgetMyApplication().getSettings().SEARCH_TAB.set(SearchActivity.TRANSPORT_TAB_INDEX);\n\t\t\t\tactivity.startActivity(search);\n\t\t\t}\n\t\t});\n\t}","commit_id":"7904c139f629bf91ea01a3e4f0118dc0b1059ebc","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\t\tView v = inflater.inflate(R.layout.available_gpx, container, false);\n\t\tlistView =(ExpandableListView) v.findViewById(android.R.id.list);\n\t\tif(this.adapter != null) {\n\t\t\tlistView.setAdapter(this.adapter);\n\t\t}\n\n\t\t((TextView)v.findViewById(R.id.name)).setText(R.string.currently_recording_track);\n\t\tv.findViewById(R.id.time_icon).setVisibility(View.GONE);\n\n\t\tDrawable icon = getResources().getDrawable(R.drawable.ic_action_rec_stop);\n\t\ticon.mutate();\n\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\tif (light){\n\t\t\ticon.setColorFilter(0xff727272, PorterDuff.Mode.MULTIPLY);\n\t\t}\n\t\tImageButton stop = ((ImageButton)v.findViewById(R.id.stop));\n\t\tstop.setImageDrawable(icon);\n\t\tstop.setVisibility(View.VISIBLE);\n\n\t\ticon = getResources().getDrawable(R.drawable.ic_action_gsave_dark);\n\t\ticon.mutate();\n\t\tif  (light) {\n\t\t\ticon.setColorFilter(0xff727272, PorterDuff.Mode.MULTIPLY);\n\t\t}\n\t\tImageButton save = ((ImageButton)v.findViewById(R.id.show_on_map));\n\t\tv.findViewById(R.id.divider).setVisibility(View.GONE);\n\t\tsave.setImageDrawable(icon);\n\t\tupdateCurrentTrack(v);\n\t\treturn v;\n\t}","id":47016,"modified_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\t\tView v = inflater.inflate(R.layout.available_gpx, container, false);\n\t\tlistView = (ExpandableListView) v.findViewById(android.R.id.list);\n\t\tif (this.adapter != null) {\n\t\t\tlistView.setAdapter(this.adapter);\n\t\t}\n\n\t\t((TextView) v.findViewById(R.id.name)).setText(R.string.currently_recording_track);\n\t\tv.findViewById(R.id.time_icon).setVisibility(View.GONE);\n\n\t\tcreateCurrentTrackView(v, getMyApplication());\n\n\t\tv.findViewById(R.id.map_btn).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t}\n\t\t});\n\t\treturn v;\n\t}","commit_id":"ae33cac5bdbcde2748a85bee4abb91e1022da6fd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void updateCurrentTrack(View v){\n\t\tif (v == null){\n\t\t\treturn;\n\t\t}\n\t\tOsmandMonitoringPlugin plugin = OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class);\n\n\t\tGpxSelectionHelper.SelectedGpxFile currentTrack = savingTrackHelper.getCurrentTrack();\n\t\tif (plugin != null && savingTrackHelper.getCurrentGpx() != null) {\n\t\t\tv.findViewById(R.id.current_track).setVisibility(View.VISIBLE);\n\t\t\tString description = GpxUiHelper.getDescription(getMyApplication(), currentTrack.getGpxFile(), null, true);\n\t\t\tint startindex = description.indexOf(\">\");\n\t\t\tint endindex = description.indexOf(\"<\/font>\");\n\t\t\tString distance = description.substring(startindex + 1, endindex);\n\t\t\t((TextView)v.findViewById(R.id.distance)).setText(distance);\n\t\t} else {\n\t\t\tv.findViewById(R.id.current_track).setVisibility(View.GONE);\n\t\t}\n\t}","id":47017,"modified_method":"private void updateCurrentTrack(View v) {\n\t\tif (v == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (app.getSettings().SAVE_GLOBAL_TRACK_TO_GPX.get()) {\n\t\t\tGpxSelectionHelper.SelectedGpxFile currentTrack = savingTrackHelper.getCurrentTrack();\n\t\t\tv.findViewById(R.id.current_track).setVisibility(View.VISIBLE);\n\t\t\tString description = GpxUiHelper.getDescription(getMyApplication(), currentTrack.getGpxFile(), null, true);\n\t\t\tint startindex = description.indexOf(\">\");\n\t\t\tint endindex = description.indexOf(\"<\/font>\");\n\t\t\tString distance = description.substring(startindex + 1, endindex);\n\t\t\tString points = String.valueOf(currentTrack.getGpxFile().points.size());\n\t\t\t((TextView) v.findViewById(R.id.points_count)).setText(points);\n\t\t\t((TextView) v.findViewById(R.id.distance)).setText(distance);\n\t\t} else {\n\t\t\tv.findViewById(R.id.current_track).setVisibility(View.GONE);\n\t\t}\n\t}","commit_id":"ae33cac5bdbcde2748a85bee4abb91e1022da6fd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void setupGpxFiles() {\n\t\tView mainView = getView();\n\t\tfinal File dir = getMyApplication().getAppPath(IndexConstants.GPX_INDEX_DIR);\n\t\tfinal List<String> list = GpxUiHelper.getSortedGPXFilenames(dir);\n\n\n\t\tif (list.size() == 0) {\n\t\t\t(mainView.findViewById(R.id.main_fav)).setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\t(mainView.findViewById(R.id.main_fav)).setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout tracks = (LinearLayout) mainView.findViewById(R.id.items);\n\t\ttracks.removeAllViews();\n\t\tif (list.size() > 3) {\n\t\t\twhile (list.size() != 3) {\n\t\t\t\tlist.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (String filename : list) {\n\t\t\tfinal File f = new File(dir, filename);\n\t\t\tfinal GPXUtilities.GPXFile res = GPXUtilities.loadGPXFile(getMyApplication(), f);\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_gpx_track_item, null, false);\n\t\t\t((TextView) view.findViewById(R.id.name)).setText(filename);\n\t\t\t((TextView) view.findViewById(R.id.points_count)).\n\t\t\t\t\tsetText(res.points.size() + \" \" + getActivity().getString(R.string.points));\n\t\t\tString description = GpxUiHelper.getDescription(getMyApplication(), res, f, true);\n\t\t\tint startindex = description.indexOf(\">\");\n\t\t\tint endindex = description.indexOf(\"<\/font>\");\n\t\t\tString distnace = description.substring(startindex + 1, endindex);\n\t\t\t((TextView) view.findViewById(R.id.distance)).\n\t\t\t\t\tsetText(distnace);\n\t\t\tview.findViewById(R.id.time_icon).setVisibility(View.GONE);\n\n\t\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\t\tDrawable icon = getResources().getDrawable(R.drawable.ic_show_on_map);\n\t\t\tGpxSelectionHelper gpxSelectionHelper = getMyApplication().getSelectedGpxHelper();\n\t\t\tboolean isShowingOnMap = gpxSelectionHelper.getSelectedFileByName(filename) != null;\n\t\t\t//setting proper icon color\n\t\t\tif (isShowingOnMap) {\n\t\t\t\ticon.mutate();\n\t\t\t\tif (light) {\n\t\t\t\t\ticon.setColorFilter(getResources().getColor(R.color.dashboard_gpx_on_map), PorterDuff.Mode.MULTIPLY);\n\t\t\t\t} else {\n\t\t\t\t\ticon.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t\t\t}\n\t\t\t} else if (light) {\n\t\t\t\ticon.mutate();\n\t\t\t\ticon.setColorFilter(getResources().getColor(R.color.icon_color_light), PorterDuff.Mode.MULTIPLY);\n\n\t\t\t}\n\t\t\tfinal ImageButton showOnMap = (ImageButton) view.findViewById(R.id.show_on_map);\n\t\t\tshowOnMap.setImageDrawable(icon);\n\t\t\tshowOnMap.setVisibility(View.VISIBLE);\n\t\t\t//view.findViewById(R.id.distance_icon).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.stop).setVisibility(View.GONE);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tshowOnMap(res);\n\t\t\t\t}\n\t\t\t});\n\t\t\ttracks.addView(view);\n\t\t}\n\t}","id":47018,"modified_method":"private void setupGpxFiles() {\n\t\tView mainView = getView();\n\t\tfinal File dir = getMyApplication().getAppPath(IndexConstants.GPX_INDEX_DIR);\n\t\tfinal List<String> list = GpxUiHelper.getSortedGPXFilenames(dir);\n\n\n\t\tif (list.size() == 0) {\n\t\t\t(mainView.findViewById(R.id.main_fav)).setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\t(mainView.findViewById(R.id.main_fav)).setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout tracks = (LinearLayout) mainView.findViewById(R.id.items);\n\t\ttracks.removeAllViews();\n\t\tif (list.size() > 3) {\n\t\t\twhile (list.size() != 3) {\n\t\t\t\tlist.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tOsmandApplication app = getMyApplication();\n\t\tSavingTrackHelper savingTrackHelper = app.getSavingTrackHelper();\n\t\tif (app.getSettings().SAVE_GLOBAL_TRACK_TO_GPX.get()) {\n\t\t\tlist.remove(2);\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_gpx_track_item, null, false);\n\n\t\t\tAvailableGPXFragment.createCurrentTrackView(view, app);\n\n\t\t\tGpxSelectionHelper.SelectedGpxFile currentTrack = savingTrackHelper.getCurrentTrack();\n\t\t\t((TextView)view.findViewById(R.id.name)).setText(R.string.currently_recording_track);\n\t\t\tString description = GpxUiHelper.getDescription(getMyApplication(), currentTrack.getGpxFile(), null, true);\n\t\t\tint startindex = description.indexOf(\">\");\n\t\t\tint endindex = description.indexOf(\"<\/font>\");\n\t\t\tString distance = description.substring(startindex + 1, endindex);\n\t\t\tString points = String.valueOf(currentTrack.getGpxFile().points.size());\n\n\t\t\t((TextView) view.findViewById(R.id.points_count)).setText(points);\n\t\t\t((TextView)view.findViewById(R.id.distance)).setText(distance);\n\t\t\ttracks.addView(view);\n\t\t}\n\n\t\tfor (String filename : list) {\n\t\t\tfinal File f = new File(dir, filename);\n\t\t\tfinal GPXUtilities.GPXFile res = GPXUtilities.loadGPXFile(getMyApplication(), f);\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_gpx_track_item, null, false);\n\t\t\t((TextView) view.findViewById(R.id.name)).setText(filename);\n\t\t\t((TextView) view.findViewById(R.id.points_count)).\n\t\t\t\t\tsetText(res.points.size() + \" \" + getActivity().getString(R.string.points));\n\t\t\tString description = GpxUiHelper.getDescription(getMyApplication(), res, f, true);\n\t\t\tint startindex = description.indexOf(\">\");\n\t\t\tint endindex = description.indexOf(\"<\/font>\");\n\t\t\tString distnace = description.substring(startindex + 1, endindex);\n\t\t\t((TextView) view.findViewById(R.id.distance)).\n\t\t\t\t\tsetText(distnace);\n\t\t\tview.findViewById(R.id.time_icon).setVisibility(View.GONE);\n\n\t\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\t\tDrawable icon = getResources().getDrawable(R.drawable.ic_show_on_map);\n\t\t\tGpxSelectionHelper gpxSelectionHelper = getMyApplication().getSelectedGpxHelper();\n\t\t\tboolean isShowingOnMap = gpxSelectionHelper.getSelectedFileByName(filename) != null;\n\t\t\t//setting proper icon color\n\t\t\tif (isShowingOnMap) {\n\t\t\t\ticon.mutate();\n\t\t\t\tif (light) {\n\t\t\t\t\ticon.setColorFilter(getResources().getColor(R.color.dashboard_gpx_on_map), PorterDuff.Mode.MULTIPLY);\n\t\t\t\t} else {\n\t\t\t\t\ticon.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t\t\t}\n\t\t\t} else if (light) {\n\t\t\t\ticon.mutate();\n\t\t\t\ticon.setColorFilter(getResources().getColor(R.color.icon_color_light), PorterDuff.Mode.MULTIPLY);\n\n\t\t\t}\n\t\t\tfinal ImageButton showOnMap = (ImageButton) view.findViewById(R.id.show_on_map);\n\t\t\tshowOnMap.setImageDrawable(icon);\n\t\t\tshowOnMap.setVisibility(View.VISIBLE);\n\t\t\t//view.findViewById(R.id.distance_icon).setVisibility(View.GONE);\n\t\t\tview.findViewById(R.id.stop).setVisibility(View.GONE);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tshowOnMap(res);\n\t\t\t\t}\n\t\t\t});\n\t\t\ttracks.addView(view);\n\t\t}\n\t}","commit_id":"ae33cac5bdbcde2748a85bee4abb91e1022da6fd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void controlDialog(final MapActivity map) {\n\t\tfinal boolean wasTrackMonitored = settings.SAVE_GLOBAL_TRACK_TO_GPX.get();\n\t\t\n\t\tBuilder bld = new AlertDialog.Builder(map);\n\t\tfinal TIntArrayList items = new TIntArrayList();\n\t\tif(wasTrackMonitored) {\n\t\t\titems.add(R.string.gpx_monitoring_stop);\n\t\t\titems.add(R.string.gpx_start_new_segment);\n\t\t\tif(settings.LIVE_MONITORING.get()) {\n\t\t\t\titems.add(R.string.live_monitoring_stop);\n\t\t\t} else if(!settings.LIVE_MONITORING_URL.getProfileDefaultValue().equals(settings.LIVE_MONITORING_URL.get())){\n\t\t\t\titems.add(R.string.live_monitoring_start);\n\t\t\t}\n\t\t} else {\n\t\t\titems.add(R.string.gpx_monitoring_start);\n\t\t}\n\t\tif(app.getSavingTrackHelper().hasDataToSave()) {\n\t\t\titems.add(R.string.save_current_track);\n\t\t}\n\t\tString[] strings = new String[items.size()];\n\t\tfor(int i =0; i < strings.length; i++) {\n\t\t\tstrings[i] = app.getString(items.get(i));\n\t\t}\n\t\tfinal int[] holder = new int[] {0};\n\t\tfinal Runnable run = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tint which = holder[0];\n\t\t\t\tint item = items.get(which);\n\t\t\t\tif(item == R.string.save_current_track){\n\t\t\t\t\tapp.getTaskManager().runInBackground(new OsmAndTaskRunnable<Void, Void, Void>() {\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Void doInBackground(Void... params) {\n\t\t\t\t\t\t\tisSaving = true;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tSavingTrackHelper helper = app.getSavingTrackHelper();\n\t\t\t\t\t\t\t\thelper.saveDataToGpx(app.getAppCustomization().getTracksDir());\n\t\t\t\t\t\t\t\thelper.close();\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tisSaving = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, (Void) null);\n\t\t\t\t} else if(item == R.string.gpx_monitoring_start) {\n\t\t\t\t\tstartGPXMonitoring(map);\n\t\t\t\t} else if(item == R.string.gpx_monitoring_stop) {\n\t\t\t\t\tsettings.SAVE_GLOBAL_TRACK_TO_GPX.set(false);\n\t\t\t\t\tif (app.getNavigationService() != null) {\n\t\t\t\t\t\tapp.getNavigationService().stopIfNeeded(app, NavigationService.USED_BY_GPX);\n\t\t\t\t\t}\n\t\t\t\t} else if(item == R.string.gpx_start_new_segment) {\n\t\t\t\t\tapp.getSavingTrackHelper().startNewSegment();\n\t\t\t\t} else if(item == R.string.live_monitoring_stop) {\n\t\t\t\t\tsettings.LIVE_MONITORING.set(false);\n\t\t\t\t} else if(item == R.string.live_monitoring_start) {\n\t\t\t\t\tfinal ValueHolder<Integer> vs = new ValueHolder<Integer>();\n\t\t\t\t\tvs.value = settings.LIVE_MONITORING_INTERVAL.get();\n\t\t\t\t\tshowIntervalChooseDialog(map, app.getString(R.string.live_monitoring_interval) + \" : %s\", \n\t\t\t\t\t\t\tapp.getString(R.string.save_track_to_gpx_globally), SECONDS, MINUTES,\n\t\t\t\t\t\t\tnull, vs, new OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\tsettings.LIVE_MONITORING_INTERVAL.set(vs.value);\n\t\t\t\t\t\t\tsettings.LIVE_MONITORING.set(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tmonitoringControl.updateInfo(null);\n\t\t\t}\n\t\t};\n\t\tif(strings.length == 1) {\n\t\t\trun.run();\n\t\t} else {\n\t\t\tbld.setItems(strings, new OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tholder[0] = which;\n\t\t\t\t\trun.run();\n\t\t\t\t}\n\t\t\t});\n\t\t\tbld.show();\n\t\t}\n\t}","id":47019,"modified_method":"private void controlDialog(final MapActivity map) {\n\t\tfinal boolean wasTrackMonitored = settings.SAVE_GLOBAL_TRACK_TO_GPX.get();\n\t\t\n\t\tBuilder bld = new AlertDialog.Builder(map);\n\t\tfinal TIntArrayList items = new TIntArrayList();\n\t\tif(wasTrackMonitored) {\n\t\t\titems.add(R.string.gpx_monitoring_stop);\n\t\t\titems.add(R.string.gpx_start_new_segment);\n\t\t\tif(settings.LIVE_MONITORING.get()) {\n\t\t\t\titems.add(R.string.live_monitoring_stop);\n\t\t\t} else if(!settings.LIVE_MONITORING_URL.getProfileDefaultValue().equals(settings.LIVE_MONITORING_URL.get())){\n\t\t\t\titems.add(R.string.live_monitoring_start);\n\t\t\t}\n\t\t} else {\n\t\t\titems.add(R.string.gpx_monitoring_start);\n\t\t}\n\t\tif(app.getSavingTrackHelper().hasDataToSave()) {\n\t\t\titems.add(R.string.save_current_track);\n\t\t}\n\t\tString[] strings = new String[items.size()];\n\t\tfor(int i =0; i < strings.length; i++) {\n\t\t\tstrings[i] = app.getString(items.get(i));\n\t\t}\n\t\tfinal int[] holder = new int[] {0};\n\t\tfinal Runnable run = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tint which = holder[0];\n\t\t\t\tint item = items.get(which);\n\t\t\t\tif(item == R.string.save_current_track){\n\t\t\t\t\tsaveCurrentTrack();\n\t\t\t\t} else if(item == R.string.gpx_monitoring_start) {\n\t\t\t\t\tstartGPXMonitoring(map);\n\t\t\t\t} else if(item == R.string.gpx_monitoring_stop) {\n\t\t\t\t\tstopRecording();\n\t\t\t\t} else if(item == R.string.gpx_start_new_segment) {\n\t\t\t\t\tapp.getSavingTrackHelper().startNewSegment();\n\t\t\t\t} else if(item == R.string.live_monitoring_stop) {\n\t\t\t\t\tsettings.LIVE_MONITORING.set(false);\n\t\t\t\t} else if(item == R.string.live_monitoring_start) {\n\t\t\t\t\tfinal ValueHolder<Integer> vs = new ValueHolder<Integer>();\n\t\t\t\t\tvs.value = settings.LIVE_MONITORING_INTERVAL.get();\n\t\t\t\t\tshowIntervalChooseDialog(map, app.getString(R.string.live_monitoring_interval) + \" : %s\", \n\t\t\t\t\t\t\tapp.getString(R.string.save_track_to_gpx_globally), SECONDS, MINUTES,\n\t\t\t\t\t\t\tnull, vs, new OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\tsettings.LIVE_MONITORING_INTERVAL.set(vs.value);\n\t\t\t\t\t\t\tsettings.LIVE_MONITORING.set(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tmonitoringControl.updateInfo(null);\n\t\t\t}\n\t\t};\n\t\tif(strings.length == 1) {\n\t\t\trun.run();\n\t\t} else {\n\t\t\tbld.setItems(strings, new OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tholder[0] = which;\n\t\t\t\t\trun.run();\n\t\t\t\t}\n\t\t\t});\n\t\t\tbld.show();\n\t\t}\n\t}","commit_id":"ae33cac5bdbcde2748a85bee4abb91e1022da6fd","url":"https://github.com/osmandapp/Osmand"},{"original_method":"EmbeddedNeoResource( final EmbeddedNeo neo )\n    {\n        super( neo.getConfig().getPersistenceModule().getPersistenceSource()\n            .getXaDataSource() );\n        this.neo = neo;\n        this.xaDsm = neo.getConfig().getTxModule().getXaDataSourceManager();\n    }","id":47020,"modified_method":"EmbeddedNeoResource( final EmbeddedNeo neo )\n    {\n        super( neo.getConfig().getPersistenceModule().getPersistenceManager()\n            .getPersistenceSource().getXaDataSource() );\n        this.neo = neo;\n        this.xaDsm = neo.getConfig().getTxModule().getXaDataSourceManager();\n    }","commit_id":"92b2fb61e7d6f20f9b5defb1c5a02035f4ff0d56","url":"https://github.com/neo4j/neo4j"},{"original_method":"public XaDataSourceResource getDataSource()\n    {\n        XaDataSource ds = neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource();\n        if ( ds == null )\n        {\n            return null;\n        }\n        return new XaDataSourceResource( ds );\n    }","id":47021,"modified_method":"public XaDataSourceResource getDataSource()\n    {\n        XaDataSource ds = neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource().getXaDataSource();\n        if ( ds == null )\n        {\n            return null;\n        }\n        return new XaDataSourceResource( ds );\n    }","commit_id":"92b2fb61e7d6f20f9b5defb1c5a02035f4ff0d56","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out\n            .println( \"setting up database and backup-copy including Lucene\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        XaDataSource neoStoreXaDataSource = neo.getConfig()\n            .getPersistenceModule().getPersistenceSource().getXaDataSource();\n        neoStoreXaDataSource.keepLogicalLogs( true );\n\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 1 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo, indexService );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","id":47022,"modified_method":"@Before\n    public void setup()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out\n            .println( \"setting up database and backup-copy including Lucene\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        XaDataSource neoStoreXaDataSource = neo.getConfig()\n            .getPersistenceModule().getPersistenceManager()\n            .getPersistenceSource().getXaDataSource();\n        neoStoreXaDataSource.keepLogicalLogs( true );\n\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 1 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo, indexService );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","commit_id":"92b2fb61e7d6f20f9b5defb1c5a02035f4ff0d56","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void backup() throws IOException\n    {\n        System.out.println( \"starting tests\" );\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 2 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 4 );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo, indexService );\n    }","id":47023,"modified_method":"@Test\n    public void backup() throws IOException\n    {\n        System.out.println( \"starting tests\" );\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource()\n            .getXaDataSource()).keepLogicalLogs( true );\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 2 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 4 );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo, indexService );\n    }","commit_id":"92b2fb61e7d6f20f9b5defb1c5a02035f4ff0d56","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void clean()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out.println( \"setting up simple database and backup-copy\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","id":47024,"modified_method":"@Before\n    public void clean()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out.println( \"setting up simple database and backup-copy\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource()\n            .getXaDataSource()).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","commit_id":"92b2fb61e7d6f20f9b5defb1c5a02035f4ff0d56","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void backup() throws IOException\n    {\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo );\n    }","id":47025,"modified_method":"@Test\n    public void backup() throws IOException\n    {\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource().getXaDataSource())\n            .keepLogicalLogs( true );\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo );\n    }","commit_id":"92b2fb61e7d6f20f9b5defb1c5a02035f4ff0d56","url":"https://github.com/neo4j/neo4j"},{"original_method":"public XaDataSourceResource getDataSource()\n    {\n        XaDataSource ds = neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource();\n        if ( ds == null )\n        {\n            return null;\n        }\n        return new XaDataSourceResource( ds );\n    }","id":47026,"modified_method":"public XaDataSourceResource getDataSource()\n    {\n        XaDataSource ds = neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource().getXaDataSource();\n        if ( ds == null )\n        {\n            return null;\n        }\n        return new XaDataSourceResource( ds );\n    }","commit_id":"9b874fd2885a0005177b046feb63f75bfe4ef403","url":"https://github.com/neo4j/neo4j"},{"original_method":"EmbeddedNeoResource( final EmbeddedNeo neo )\n    {\n        super( neo.getConfig().getPersistenceModule().getPersistenceSource()\n            .getXaDataSource() );\n        this.neo = neo;\n        this.xaDsm = neo.getConfig().getTxModule().getXaDataSourceManager();\n    }","id":47027,"modified_method":"EmbeddedNeoResource( final EmbeddedNeo neo )\n    {\n        super( neo.getConfig().getPersistenceModule().getPersistenceManager()\n            .getPersistenceSource().getXaDataSource() );\n        this.neo = neo;\n        this.xaDsm = neo.getConfig().getTxModule().getXaDataSourceManager();\n    }","commit_id":"9b874fd2885a0005177b046feb63f75bfe4ef403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void backup() throws IOException\n    {\n        System.out.println( \"starting tests\" );\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 2 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 4 );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo, indexService );\n    }","id":47028,"modified_method":"@Test\n    public void backup() throws IOException\n    {\n        System.out.println( \"starting tests\" );\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource()\n            .getXaDataSource()).keepLogicalLogs( true );\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 2 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 4 );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo, indexService );\n    }","commit_id":"9b874fd2885a0005177b046feb63f75bfe4ef403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out\n            .println( \"setting up database and backup-copy including Lucene\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        XaDataSource neoStoreXaDataSource = neo.getConfig()\n            .getPersistenceModule().getPersistenceSource().getXaDataSource();\n        neoStoreXaDataSource.keepLogicalLogs( true );\n\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 1 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo, indexService );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","id":47029,"modified_method":"@Before\n    public void setup()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out\n            .println( \"setting up database and backup-copy including Lucene\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        XaDataSource neoStoreXaDataSource = neo.getConfig()\n            .getPersistenceModule().getPersistenceManager()\n            .getPersistenceSource().getXaDataSource();\n        neoStoreXaDataSource.keepLogicalLogs( true );\n\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 1 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo, indexService );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","commit_id":"9b874fd2885a0005177b046feb63f75bfe4ef403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void backup() throws IOException\n    {\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo );\n    }","id":47030,"modified_method":"@Test\n    public void backup() throws IOException\n    {\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource().getXaDataSource())\n            .keepLogicalLogs( true );\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo );\n    }","commit_id":"9b874fd2885a0005177b046feb63f75bfe4ef403","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void clean()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out.println( \"setting up simple database and backup-copy\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","id":47031,"modified_method":"@Before\n    public void clean()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out.println( \"setting up simple database and backup-copy\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource()\n            .getXaDataSource()).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","commit_id":"9b874fd2885a0005177b046feb63f75bfe4ef403","url":"https://github.com/neo4j/neo4j"},{"original_method":"public XaDataSourceResource getDataSource()\n    {\n        XaDataSource ds = neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource();\n        if ( ds == null )\n        {\n            return null;\n        }\n        return new XaDataSourceResource( ds );\n    }","id":47032,"modified_method":"public XaDataSourceResource getDataSource()\n    {\n        XaDataSource ds = neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource().getXaDataSource();\n        if ( ds == null )\n        {\n            return null;\n        }\n        return new XaDataSourceResource( ds );\n    }","commit_id":"4623873e5e0670f49bcd026d6d648446f182c253","url":"https://github.com/neo4j/neo4j"},{"original_method":"EmbeddedNeoResource( final EmbeddedNeo neo )\n    {\n        super( neo.getConfig().getPersistenceModule().getPersistenceSource()\n            .getXaDataSource() );\n        this.neo = neo;\n        this.xaDsm = neo.getConfig().getTxModule().getXaDataSourceManager();\n    }","id":47033,"modified_method":"EmbeddedNeoResource( final EmbeddedNeo neo )\n    {\n        super( neo.getConfig().getPersistenceModule().getPersistenceManager()\n            .getPersistenceSource().getXaDataSource() );\n        this.neo = neo;\n        this.xaDsm = neo.getConfig().getTxModule().getXaDataSourceManager();\n    }","commit_id":"4623873e5e0670f49bcd026d6d648446f182c253","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out\n            .println( \"setting up database and backup-copy including Lucene\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        XaDataSource neoStoreXaDataSource = neo.getConfig()\n            .getPersistenceModule().getPersistenceSource().getXaDataSource();\n        neoStoreXaDataSource.keepLogicalLogs( true );\n\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 1 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo, indexService );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","id":47034,"modified_method":"@Before\n    public void setup()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out\n            .println( \"setting up database and backup-copy including Lucene\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        XaDataSource neoStoreXaDataSource = neo.getConfig()\n            .getPersistenceModule().getPersistenceManager()\n            .getPersistenceSource().getXaDataSource();\n        neoStoreXaDataSource.keepLogicalLogs( true );\n\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 1 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo, indexService );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","commit_id":"4623873e5e0670f49bcd026d6d648446f182c253","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void backup() throws IOException\n    {\n        System.out.println( \"starting tests\" );\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 2 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 4 );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo, indexService );\n    }","id":47035,"modified_method":"@Test\n    public void backup() throws IOException\n    {\n        System.out.println( \"starting tests\" );\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource()\n            .getXaDataSource()).keepLogicalLogs( true );\n        IndexService indexService = new LuceneIndexService( neo );\n        XaDataSourceManager xaDsm = neo.getConfig().getTxModule()\n            .getXaDataSourceManager();\n        XaDataSource ds = xaDsm.getXaDataSource( \"lucene\" );\n        ((LuceneDataSource) ds).keepLogicalLogs( true );\n\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 2 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            indexService.index( addNode( neo ), \"number\", 4 );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo, indexService );\n    }","commit_id":"4623873e5e0670f49bcd026d6d648446f182c253","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void backup() throws IOException\n    {\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo );\n    }","id":47036,"modified_method":"@Test\n    public void backup() throws IOException\n    {\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource().getXaDataSource())\n            .keepLogicalLogs( true );\n        System.out.println( \"backing up original db without any changes\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 1 );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 2 );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"one node added\" );\n\n        tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            System.out.println( \"one node added, not commited\" );\n            tryBackup( neo, BACKUP_LOCATION_DIR, 3 );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        System.out.println( \"previous add commited\" );\n        tryBackup( neo, BACKUP_LOCATION_DIR, 4 );\n\n        Util.stopNeo( neo );\n    }","commit_id":"4623873e5e0670f49bcd026d6d648446f182c253","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void clean()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out.println( \"setting up simple database and backup-copy\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceSource().getXaDataSource()).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","id":47037,"modified_method":"@Before\n    public void clean()\n    {\n        Util.deleteDir( new File( VAR ) );\n\n        System.out.println( \"setting up simple database and backup-copy\" );\n\n        EmbeddedNeo neo = Util.startNeoInstance( STORE_LOCATION_DIR );\n        ((NeoStoreXaDataSource) neo.getConfig().getPersistenceModule()\n            .getPersistenceManager().getPersistenceSource()\n            .getXaDataSource()).keepLogicalLogs( true );\n\n        Transaction tx = neo.beginTx();\n        try\n        {\n            addNode( neo );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        Util.stopNeo( neo );\n\n        Util.copyDir( STORE_LOCATION_DIR, BACKUP_LOCATION_DIR );\n    }","commit_id":"4623873e5e0670f49bcd026d6d648446f182c253","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * This creator looks up a configured status view by name and calls the creator that \n     * accepts the AggregateStatusView model object.\n     * \n     * @see org.opennms.web.svclayer.SiteStatusViewService#createAggregateStatusView(java.lang.String)\n     */\n    public AggregateStatusView createAggregateStatusView(String statusViewName) {\n        \n        AggregateStatusView statusView = new AggregateStatusView();\n        statusViewName = (statusViewName == null ? m_siteStatusViewConfigDao.getDefaultView().getName() : statusViewName);\n        \n        View view = m_siteStatusViewConfigDao.getView(statusViewName);\n        \n\n        statusView.setName(statusViewName);\n        statusView.setColumnName(view.getColumnName());\n        statusView.setColumnValue(view.getColumnValue());\n        statusView.setTableName(view.getTableName());\n        \n        Set<AggregateStatusDefinition> statusDefs = new LinkedHashSet<AggregateStatusDefinition>();\n        final ArrayList rowDefs = view.getRows().getRowDefCollection();\n        \n        //Loop over the defined site status rows\n        for (Iterator it = rowDefs.iterator(); it.hasNext();) {\n            RowDef rowDef = (RowDef) it.next();\n            AggregateStatusDefinition def = new AggregateStatusDefinition();\n            def.setName(rowDef.getLabel());\n            \n            Set<OnmsCategory> categories = new LinkedHashSet<OnmsCategory>();\n            \n            //Loop over the defined categories and create model categories (OnmsCategory)\n            for (Iterator catIter = rowDef.getCategoryCollection().iterator(); catIter.hasNext();) {\n                Category cat = (Category) catIter.next();\n                OnmsCategory category = m_categoryDao.findByName(cat.getName());\n                \n                if (category == null) {\n                    throw new IllegalArgumentException(\"Site status configured category not found: \"+cat.getName());\n                }\n                \n                categories.add(category);\n            }\n            def.setCategories(categories);\n            statusDefs.add(def);\n        }\n        \n        statusView.setStatusDefinitions(statusDefs);\n        return statusView;\n    }","id":47038,"modified_method":"/**\n     * This creator looks up a configured status view by name and calls the creator that \n     * accepts the AggregateStatusView model object.\n     * \n     * @see org.opennms.web.svclayer.SiteStatusViewService#createAggregateStatusView(java.lang.String)\n     */\n    public AggregateStatusView createAggregateStatusView(String statusViewName) {\n        \n        AggregateStatusView statusView = new AggregateStatusView();\n        statusViewName = (statusViewName == null ? m_siteStatusViewConfigDao.getDefaultView().getName() : statusViewName);\n        \n        View view = m_siteStatusViewConfigDao.getView(statusViewName);\n        \n\n        statusView.setName(statusViewName);\n        statusView.setColumnName(view.getColumnName());\n        statusView.setColumnValue(view.getColumnValue());\n        statusView.setTableName(view.getTableName());\n        \n        Set<AggregateStatusDefinition> statusDefs = new LinkedHashSet<AggregateStatusDefinition>();\n        final ArrayList rowDefs = view.getRows().getRowDefCollection();\n        \n        //Loop over the defined site status rows\n        for (Iterator it = rowDefs.iterator(); it.hasNext();) {\n            RowDef rowDef = (RowDef) it.next();\n            AggregateStatusDefinition def = new AggregateStatusDefinition();\n            def.setName(rowDef.getLabel());\n            def.setReportCategory(rowDef.getReportCategory());\n            \n            Set<OnmsCategory> categories = new LinkedHashSet<OnmsCategory>();\n            \n            //Loop over the defined categories and create model categories (OnmsCategory)\n            for (Iterator catIter = rowDef.getCategoryCollection().iterator(); catIter.hasNext();) {\n                Category cat = (Category) catIter.next();\n                OnmsCategory category = m_categoryDao.findByName(cat.getName());\n                \n                if (category == null) {\n                    throw new IllegalArgumentException(\"Site status configured category not found: \"+cat.getName());\n                }\n                \n                categories.add(category);\n            }\n            def.setCategories(categories);\n            statusDefs.add(def);\n        }\n        \n        statusView.setStatusDefinitions(statusDefs);\n        return statusView;\n    }","commit_id":"a288c478c4f4e5a28fbc64f0a1ed65492247bb23","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection<AggregateStatus> createAggregateStatusUsingAssetColumn(AggregateStatusView statusView) {\n        if (statusView == null) {\n            throw new IllegalArgumentException(\"statusView argument cannot be null\");\n        }\n        /*\n         * We'll return this collection populated with all the aggregated statuss for the\n         * devices in the building (site) by for each group of categories.\n         */\n        Collection<AggregateStatus> stati = new ArrayList<AggregateStatus>();\n        \n        /*\n         * Iterate over the status definitions and create aggregated statuss\n         */\n        for (AggregateStatusDefinition statusDef : statusView.getStatusDefinitions()) {\n            \n            Collection<OnmsNode> nodes = m_nodeDao.findAllByVarCharAssetColumnCategoryList(statusView.getColumnName(), statusView.getColumnValue(), statusDef.getCategories());\n            \n            AggregateStatus status = new AggregateStatus(new HashSet<OnmsNode>(nodes));\n            status.setLabel(statusDef.getName());\n            \n            if (AggregateStatus.NODES_ARE_DOWN.equals(status.getStatus())) {\n                status.setLink(createNodePageUrl(statusView, status));\n            }\n            \n            stati.add(status);\n        }\n        \n        return stati;\n    }","id":47039,"modified_method":"public Collection<AggregateStatus> createAggregateStatusUsingAssetColumn(AggregateStatusView statusView) {\n        \n        if (statusView == null) {\n            throw new IllegalArgumentException(\"statusView argument cannot be null\");\n        }\n        \n        /*\n         * We'll return this collection populated with all the aggregated statuss for the\n         * devices in the building (site) by for each group of categories.\n         */\n        Collection<AggregateStatus> stati = new ArrayList<AggregateStatus>();\n        \n        /*\n         * Iterate over the status definitions and create aggregated statuss\n         */\n        for (AggregateStatusDefinition statusDef : statusView.getStatusDefinitions()) {\n            Collection<OnmsNode> nodes = m_nodeDao.findAllByVarCharAssetColumnCategoryList(statusView.getColumnName(), statusView.getColumnValue(), statusDef.getCategories());\n            AggregateStatus status = new AggregateStatus(new HashSet<OnmsNode>(nodes));\n            status.setLabel(statusDef.getName());\n            status.setLink(createNodePageUrl(statusView, status));\n            stati.add(status);\n        }\n        \n        return stati;\n    }","commit_id":"a288c478c4f4e5a28fbc64f0a1ed65492247bb23","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Creates a custom table object containing intersected rows and\n     * columns and categories.\n     */\n    public SimpleWebTable createSurveillanceTable(String surveillanceViewName, ProgressMonitor progressMonitor) {\n\n        surveillanceViewName = (surveillanceViewName == null ? m_surveillanceConfigDao.getDefaultView().getName() : surveillanceViewName);\n        View view = m_surveillanceConfigDao.getView(surveillanceViewName);\n        \n        SurveillanceView sView = new SurveillanceView(surveillanceViewName, m_surveillanceConfigDao, m_categoryDao);\n        \n        progressMonitor.setPhaseCount(sView.getRowCount()+sView.getColumnCount()+2);\n        \n        /*\n         * Initialize a status table \n         */\n        SimpleWebTable webTable = new SimpleWebTable();\n        webTable.setTitle(view.getName());\n        \n        webTable.addColumn(\"Nodes Down\", \"simpleWebTableHeader\");\n        \n        // set up the column headings\n        for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n            webTable.addColumn(sView.getColumnLabel(colIndex), \"simpleWebTableHeader\");\n        }\n        \n\n        // build the set of nodes for each cell\n        \n        CellStatusStrategy strategy = new CellStatusStrategy();\n        \n        AggregateStatus[][] cellStatus = strategy.calculateCellStatus(sView, progressMonitor);\n        \n        progressMonitor.beginNextPhase(\"Calculating Status Values\");\n        \n        for(int rowIndex = 0; rowIndex < sView.getRowCount(); rowIndex++) {\n            \n            webTable.newRow();\n            webTable.addCell(sView.getRowLabel(rowIndex),\n                             \"simpleWebTableRowLabel\");\n\n\n            for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n\n                AggregateStatus aggStatus = cellStatus[rowIndex][colIndex];\n\t\t\t\t\n                SimpleWebTable.Cell cell = webTable.addCell(aggStatus.getDownEntityCount()+\" of \"+aggStatus.getTotalEntityCount(), aggStatus.getStatus());\n\n                if (aggStatus.getDownEntityCount() > 0) {\n                    cell.setLink(createNodePageUrl(sView, colIndex, rowIndex));\n                }\n            }\n                \n        }\n        progressMonitor.finished(webTable);\n        \n        return webTable;\n    }","id":47040,"modified_method":"/**\n     * Creates a custom table object containing intersected rows and\n     * columns and categories.\n     */\n    public SimpleWebTable createSurveillanceTable(String surveillanceViewName, ProgressMonitor progressMonitor) {\n\n        surveillanceViewName = (surveillanceViewName == null ? m_surveillanceConfigDao.getDefaultView().getName() : surveillanceViewName);\n        View view = m_surveillanceConfigDao.getView(surveillanceViewName);\n        \n        SurveillanceView sView = new SurveillanceView(surveillanceViewName, m_surveillanceConfigDao, m_categoryDao);\n        \n        progressMonitor.setPhaseCount(sView.getRowCount()+sView.getColumnCount()+2);\n        \n        /*\n         * Initialize a status table \n         */\n        SimpleWebTable webTable = new SimpleWebTable();\n        webTable.setTitle(view.getName());\n        \n        webTable.addColumn(\"Nodes Down\", \"simpleWebTableHeader\");\n        \n        // set up the column headings\n        for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n            webTable.addColumn(sView.getColumnLabel(colIndex), \"simpleWebTableHeader\")\n              .setLink(computeReportCategoryLink(sView.getColumnReportCategory(colIndex)));\n        }\n        \n\n        // build the set of nodes for each cell\n        \n        CellStatusStrategy strategy = new CellStatusStrategy();\n        \n        AggregateStatus[][] cellStatus = strategy.calculateCellStatus(sView, progressMonitor);\n        \n        progressMonitor.beginNextPhase(\"Calculating Status Values\");\n        \n        for(int rowIndex = 0; rowIndex < sView.getRowCount(); rowIndex++) {\n            \n            webTable.newRow();\n            webTable.addCell(sView.getRowLabel(rowIndex),\n                             \"simpleWebTableRowLabel\").setLink(computeReportCategoryLink(sView.getRowReportCategory(rowIndex)));\n\n\n            for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n\n                AggregateStatus aggStatus = cellStatus[rowIndex][colIndex];\n\t\t\t\t\n                SimpleWebTable.Cell cell = webTable.addCell(aggStatus.getDownEntityCount()+\" of \"+aggStatus.getTotalEntityCount(), aggStatus.getStatus());\n\n                if (aggStatus.getDownEntityCount() > 0) {\n                    cell.setLink(createNodePageUrl(sView, colIndex, rowIndex));\n                }\n            }\n                \n        }\n        progressMonitor.finished(webTable);\n        \n        return webTable;\n    }","commit_id":"a288c478c4f4e5a28fbc64f0a1ed65492247bb23","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection<AggregateStatus> createAggregateStatusUsingAssetColumn(AggregateStatusView statusView) {\n        if (statusView == null) {\n            throw new IllegalArgumentException(\"statusView argument cannot be null\");\n        }\n        /*\n         * We'll return this collection populated with all the aggregated statuss for the\n         * devices in the building (site) by for each group of categories.\n         */\n        Collection<AggregateStatus> stati = new ArrayList<AggregateStatus>();\n        \n        /*\n         * Iterate over the status definitions and create aggregated statuss\n         */\n        for (AggregateStatusDefinition statusDef : statusView.getStatusDefinitions()) {\n            \n            Collection<OnmsNode> nodes = m_nodeDao.findAllByVarCharAssetColumnCategoryList(statusView.getColumnName(), statusView.getColumnValue(), statusDef.getCategories());\n            \n            AggregateStatus status = new AggregateStatus(new HashSet<OnmsNode>(nodes));\n            status.setLabel(statusDef.getName());\n            \n            if (AggregateStatus.NODES_ARE_DOWN.equals(status.getStatus())) {\n                status.setLink(createNodePageUrl(statusView, status));\n            }\n            \n            stati.add(status);\n        }\n        \n        return stati;\n    }","id":47041,"modified_method":"public Collection<AggregateStatus> createAggregateStatusUsingAssetColumn(AggregateStatusView statusView) {\n        \n        if (statusView == null) {\n            throw new IllegalArgumentException(\"statusView argument cannot be null\");\n        }\n        \n        /*\n         * We'll return this collection populated with all the aggregated statuss for the\n         * devices in the building (site) by for each group of categories.\n         */\n        Collection<AggregateStatus> stati = new ArrayList<AggregateStatus>();\n        \n        /*\n         * Iterate over the status definitions and create aggregated statuss\n         */\n        for (AggregateStatusDefinition statusDef : statusView.getStatusDefinitions()) {\n            Collection<OnmsNode> nodes = m_nodeDao.findAllByVarCharAssetColumnCategoryList(statusView.getColumnName(), statusView.getColumnValue(), statusDef.getCategories());\n            AggregateStatus status = new AggregateStatus(new HashSet<OnmsNode>(nodes));\n            status.setLabel(statusDef.getName());\n            status.setLink(createNodePageUrl(statusView, status));\n            stati.add(status);\n        }\n        \n        return stati;\n    }","commit_id":"05c15690501044e4bb7cddd7633132db29d8f6eb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This creator looks up a configured status view by name and calls the creator that \n     * accepts the AggregateStatusView model object.\n     * \n     * @see org.opennms.web.svclayer.SiteStatusViewService#createAggregateStatusView(java.lang.String)\n     */\n    public AggregateStatusView createAggregateStatusView(String statusViewName) {\n        \n        AggregateStatusView statusView = new AggregateStatusView();\n        statusViewName = (statusViewName == null ? m_siteStatusViewConfigDao.getDefaultView().getName() : statusViewName);\n        \n        View view = m_siteStatusViewConfigDao.getView(statusViewName);\n        \n\n        statusView.setName(statusViewName);\n        statusView.setColumnName(view.getColumnName());\n        statusView.setColumnValue(view.getColumnValue());\n        statusView.setTableName(view.getTableName());\n        \n        Set<AggregateStatusDefinition> statusDefs = new LinkedHashSet<AggregateStatusDefinition>();\n        final ArrayList rowDefs = view.getRows().getRowDefCollection();\n        \n        //Loop over the defined site status rows\n        for (Iterator it = rowDefs.iterator(); it.hasNext();) {\n            RowDef rowDef = (RowDef) it.next();\n            AggregateStatusDefinition def = new AggregateStatusDefinition();\n            def.setName(rowDef.getLabel());\n            \n            Set<OnmsCategory> categories = new LinkedHashSet<OnmsCategory>();\n            \n            //Loop over the defined categories and create model categories (OnmsCategory)\n            for (Iterator catIter = rowDef.getCategoryCollection().iterator(); catIter.hasNext();) {\n                Category cat = (Category) catIter.next();\n                OnmsCategory category = m_categoryDao.findByName(cat.getName());\n                \n                if (category == null) {\n                    throw new IllegalArgumentException(\"Site status configured category not found: \"+cat.getName());\n                }\n                \n                categories.add(category);\n            }\n            def.setCategories(categories);\n            statusDefs.add(def);\n        }\n        \n        statusView.setStatusDefinitions(statusDefs);\n        return statusView;\n    }","id":47042,"modified_method":"/**\n     * This creator looks up a configured status view by name and calls the creator that \n     * accepts the AggregateStatusView model object.\n     * \n     * @see org.opennms.web.svclayer.SiteStatusViewService#createAggregateStatusView(java.lang.String)\n     */\n    public AggregateStatusView createAggregateStatusView(String statusViewName) {\n        \n        AggregateStatusView statusView = new AggregateStatusView();\n        statusViewName = (statusViewName == null ? m_siteStatusViewConfigDao.getDefaultView().getName() : statusViewName);\n        \n        View view = m_siteStatusViewConfigDao.getView(statusViewName);\n        \n\n        statusView.setName(statusViewName);\n        statusView.setColumnName(view.getColumnName());\n        statusView.setColumnValue(view.getColumnValue());\n        statusView.setTableName(view.getTableName());\n        \n        Set<AggregateStatusDefinition> statusDefs = new LinkedHashSet<AggregateStatusDefinition>();\n        final ArrayList rowDefs = view.getRows().getRowDefCollection();\n        \n        //Loop over the defined site status rows\n        for (Iterator it = rowDefs.iterator(); it.hasNext();) {\n            RowDef rowDef = (RowDef) it.next();\n            AggregateStatusDefinition def = new AggregateStatusDefinition();\n            def.setName(rowDef.getLabel());\n            def.setReportCategory(rowDef.getReportCategory());\n            \n            Set<OnmsCategory> categories = new LinkedHashSet<OnmsCategory>();\n            \n            //Loop over the defined categories and create model categories (OnmsCategory)\n            for (Iterator catIter = rowDef.getCategoryCollection().iterator(); catIter.hasNext();) {\n                Category cat = (Category) catIter.next();\n                OnmsCategory category = m_categoryDao.findByName(cat.getName());\n                \n                if (category == null) {\n                    throw new IllegalArgumentException(\"Site status configured category not found: \"+cat.getName());\n                }\n                \n                categories.add(category);\n            }\n            def.setCategories(categories);\n            statusDefs.add(def);\n        }\n        \n        statusView.setStatusDefinitions(statusDefs);\n        return statusView;\n    }","commit_id":"05c15690501044e4bb7cddd7633132db29d8f6eb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Creates a custom table object containing intersected rows and\n     * columns and categories.\n     */\n    public SimpleWebTable createSurveillanceTable(String surveillanceViewName, ProgressMonitor progressMonitor) {\n\n        surveillanceViewName = (surveillanceViewName == null ? m_surveillanceConfigDao.getDefaultView().getName() : surveillanceViewName);\n        View view = m_surveillanceConfigDao.getView(surveillanceViewName);\n        \n        SurveillanceView sView = new SurveillanceView(surveillanceViewName, m_surveillanceConfigDao, m_categoryDao);\n        \n        progressMonitor.setPhaseCount(sView.getRowCount()+sView.getColumnCount()+2);\n        \n        /*\n         * Initialize a status table \n         */\n        SimpleWebTable webTable = new SimpleWebTable();\n        webTable.setTitle(view.getName());\n        \n        webTable.addColumn(\"Nodes Down\", \"simpleWebTableHeader\");\n        \n        // set up the column headings\n        for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n            webTable.addColumn(sView.getColumnLabel(colIndex), \"simpleWebTableHeader\");\n        }\n        \n\n        // build the set of nodes for each cell\n        \n        CellStatusStrategy strategy = new CellStatusStrategy();\n        \n        AggregateStatus[][] cellStatus = strategy.calculateCellStatus(sView, progressMonitor);\n        \n        progressMonitor.beginNextPhase(\"Calculating Status Values\");\n        \n        for(int rowIndex = 0; rowIndex < sView.getRowCount(); rowIndex++) {\n            \n            webTable.newRow();\n            webTable.addCell(sView.getRowLabel(rowIndex),\n                             \"simpleWebTableRowLabel\");\n\n\n            for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n\n                AggregateStatus aggStatus = cellStatus[rowIndex][colIndex];\n\t\t\t\t\n                SimpleWebTable.Cell cell = webTable.addCell(aggStatus.getDownEntityCount()+\" of \"+aggStatus.getTotalEntityCount(), aggStatus.getStatus());\n\n                if (aggStatus.getDownEntityCount() > 0) {\n                    cell.setLink(createNodePageUrl(sView, colIndex, rowIndex));\n                }\n            }\n                \n        }\n        progressMonitor.finished(webTable);\n        \n        return webTable;\n    }","id":47043,"modified_method":"/**\n     * Creates a custom table object containing intersected rows and\n     * columns and categories.\n     */\n    public SimpleWebTable createSurveillanceTable(String surveillanceViewName, ProgressMonitor progressMonitor) {\n\n        surveillanceViewName = (surveillanceViewName == null ? m_surveillanceConfigDao.getDefaultView().getName() : surveillanceViewName);\n        View view = m_surveillanceConfigDao.getView(surveillanceViewName);\n        \n        SurveillanceView sView = new SurveillanceView(surveillanceViewName, m_surveillanceConfigDao, m_categoryDao);\n        \n        progressMonitor.setPhaseCount(sView.getRowCount()+sView.getColumnCount()+2);\n        \n        /*\n         * Initialize a status table \n         */\n        SimpleWebTable webTable = new SimpleWebTable();\n        webTable.setTitle(view.getName());\n        \n        webTable.addColumn(\"Nodes Down\", \"simpleWebTableHeader\");\n        \n        // set up the column headings\n        for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n            webTable.addColumn(sView.getColumnLabel(colIndex), \"simpleWebTableHeader\")\n              .setLink(computeReportCategoryLink(sView.getColumnReportCategory(colIndex)));\n        }\n        \n\n        // build the set of nodes for each cell\n        \n        CellStatusStrategy strategy = new CellStatusStrategy();\n        \n        AggregateStatus[][] cellStatus = strategy.calculateCellStatus(sView, progressMonitor);\n        \n        progressMonitor.beginNextPhase(\"Calculating Status Values\");\n        \n        for(int rowIndex = 0; rowIndex < sView.getRowCount(); rowIndex++) {\n            \n            webTable.newRow();\n            webTable.addCell(sView.getRowLabel(rowIndex),\n                             \"simpleWebTableRowLabel\").setLink(computeReportCategoryLink(sView.getRowReportCategory(rowIndex)));\n\n\n            for(int colIndex = 0; colIndex < sView.getColumnCount(); colIndex++) {\n\n                AggregateStatus aggStatus = cellStatus[rowIndex][colIndex];\n\t\t\t\t\n                SimpleWebTable.Cell cell = webTable.addCell(aggStatus.getDownEntityCount()+\" of \"+aggStatus.getTotalEntityCount(), aggStatus.getStatus());\n\n                if (aggStatus.getDownEntityCount() > 0) {\n                    cell.setLink(createNodePageUrl(sView, colIndex, rowIndex));\n                }\n            }\n                \n        }\n        progressMonitor.finished(webTable);\n        \n        return webTable;\n    }","commit_id":"05c15690501044e4bb7cddd7633132db29d8f6eb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\tresponse);\n\n\t\tprocessFilter(\n\t\t\tDynamicCSSFilter.class, request, stringResponse, filterChain);\n\n\t\tObject parsedContent = getDynamicContent(\n\t\t\trequest, stringResponse, filterChain);\n\n\t\tif (parsedContent == null) {\n\t\t\tparsedContent = parseSass(request, stringResponse.getString());\n\t\t}\n\n\t\tif (parsedContent instanceof File) {\n\t\t\tServletResponseUtil.write(response, (File)parsedContent);\n\t\t}\n\t\telse if (parsedContent instanceof String) {\n\t\t\tServletResponseUtil.write(response, (String)parsedContent);\n\t\t}\n\t}","id":47044,"modified_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tObject parsedContent = getDynamicContent(\n\t\t\trequest, response, filterChain);\n\n\t\tif (parsedContent == null) {\n\n\t\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t\tresponse);\n\n\t\t\tprocessFilter(\n\t\t\t\tDynamicCSSFilter.class, request, stringResponse, filterChain);\n\n\t\t\tparsedContent = parseSass(request, stringResponse.getString());\n\t\t}\n\n\t\tif (parsedContent instanceof File) {\n\t\t\tServletResponseUtil.write(response, (File)parsedContent);\n\t\t}\n\t\telse if (parsedContent instanceof String) {\n\t\t\tServletResponseUtil.write(response, (String)parsedContent);\n\t\t}\n\t}","commit_id":"3dcb10e86ea047e06ca1f654857079003deda074","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tlong companyId = PortalInstances.getCompanyId(request);\n\n\t\tNtlmConfiguration ntlmConfiguration =\n\t\t\t_configurationProvider.getConfiguration(\n\t\t\t\tNtlmConfiguration.class,\n\t\t\t\tnew CompanyServiceSettingsLocator(\n\t\t\t\t\tcompanyId, NtlmConstants.SERVICE_NAME));\n\n\t\tif (ntlmConfiguration.enabled() && BrowserSnifferUtil.isIe(request) &&\n\t\t\trequest.getMethod().equals(HttpMethods.POST)) {\n\n\t\t\tString authorization = GetterUtil.getString(\n\t\t\t\trequest.getHeader(HttpHeaders.AUTHORIZATION));\n\n\t\t\tif (authorization.startsWith(\"NTLM \")) {\n\t\t\t\tbyte[] src = Base64.decode(authorization.substring(5));\n\n\t\t\t\tif (src[8] == 1) {\n\t\t\t\t\tType1Message type1 = new Type1Message(src);\n\t\t\t\t\tType2Message type2 = new Type2Message(\n\t\t\t\t\t\ttype1, new byte[8], null);\n\n\t\t\t\t\tauthorization = Base64.encode(type2.toByteArray());\n\n\t\t\t\t\tresponse.setHeader(\n\t\t\t\t\t\tHttpHeaders.WWW_AUTHENTICATE, \"NTLM \" + authorization);\n\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n\t\t\t\t\tresponse.setContentLength(0);\n\n\t\t\t\t\tresponse.flushBuffer();\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprocessFilter(\n\t\t\tNtlmPostFilter.class.getName(), request, response, filterChain);\n\t}","id":47045,"modified_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tString authorization = GetterUtil.getString(\n\t\t\trequest.getHeader(HttpHeaders.AUTHORIZATION));\n\n\t\tif (authorization.startsWith(\"NTLM \")) {\n\t\t\tbyte[] src = Base64.decode(authorization.substring(5));\n\n\t\t\tif (src[8] == 1) {\n\t\t\t\tType1Message type1 = new Type1Message(src);\n\t\t\t\tType2Message type2 = new Type2Message(type1, new byte[8], null);\n\n\t\t\t\tauthorization = Base64.encode(type2.toByteArray());\n\n\t\t\t\tresponse.setHeader(\n\t\t\t\t\tHttpHeaders.WWW_AUTHENTICATE, \"NTLM \" + authorization);\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n\t\t\t\tresponse.setContentLength(0);\n\n\t\t\t\tresponse.flushBuffer();\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tprocessFilter(\n\t\t\tNtlmPostFilter.class.getName(), request, response, filterChain);\n\t}","commit_id":"d028956a2a2a5726ee42fd165bd99bf284d2558e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tObject parsedContent = getDynamicContent(\n\t\t\trequest, response, filterChain);\n\n\t\tif (parsedContent == null) {\n\n\t\t\tStringServletResponse stringResponse = new StringServletResponse(\n\t\t\t\tresponse);\n\n\t\t\tprocessFilter(\n\t\t\t\tDynamicCSSFilter.class, request, stringResponse, filterChain);\n\n\t\t\tparsedContent = parseSass(request, stringResponse.getString());\n\t\t}\n\n\t\tif (parsedContent instanceof File) {\n\t\t\tServletResponseUtil.write(response, (File)parsedContent);\n\t\t}\n\t\telse if (parsedContent instanceof String) {\n\t\t\tServletResponseUtil.write(response, (String)parsedContent);\n\t\t}\n\t}","id":47046,"modified_method":"protected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tObject parsedContent = getDynamicContent(\n\t\t\trequest, response, filterChain);\n\n\t\tif (parsedContent == null) {\n\t\t\tprocessFilter(\n\t\t\t\tDynamicCSSFilter.class, request, response, filterChain);\n\t\t}\n\t\telse {\n\t\t\tif (parsedContent instanceof File) {\n\t\t\t\tServletResponseUtil.write(response, (File)parsedContent);\n\t\t\t}\n\t\t\telse if (parsedContent instanceof String) {\n\t\t\t\tServletResponseUtil.write(response, (String)parsedContent);\n\t\t\t}\n\t\t}\n\t}","commit_id":"32a6d62c599ea0b7153bcba6ec5e6ab285d297e0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void retrofitPorts(List<EndPoint> eps)\n    {\n        for ( EndPoint ep : eps )\n        {\n            ep.setPort(storagePort_);\n        }\n    }","id":47047,"modified_method":"public List<EndPoint> retrofitPorts(List<EndPoint> eps)\n    {\n        List<EndPoint> retrofitted = new ArrayList<EndPoint>();\n        for ( EndPoint ep : eps )\n        {\n            retrofitted.add(new EndPoint(ep.getHost(), ep.getPort()));\n        }\n        return retrofitted;\n    }","commit_id":"d5eaa4e141ea830bbbacc7c249198e58169882e7","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * write endpoints may be different from read endpoints, because read endpoints only need care about the\n     * \"natural\" nodes for a token, but write endpoints also need to account for nodes that are bootstrapping\n     * into the ring, and write data there too so that they stay up to date during the bootstrap process.\n     * Thus, this method may return more nodes than the Replication Factor.\n     *\n     * Only ReplicationStrategy should care about this method (higher level users should only ask for Hinted).\n     */\n    protected EndPoint[] getWriteStorageEndPoints(Token token, EndPoint[] naturalEndpoints)\n    {\n        Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();\n        Map<Token, EndPoint> bootstrapTokensToEndpointMap = tokenMetadata_.cloneBootstrapNodes();\n        ArrayList<EndPoint> list = new ArrayList<EndPoint>(Arrays.asList(naturalEndpoints));\n        for (Token t : bootstrapTokensToEndpointMap.keySet())\n        {\n            EndPoint ep = bootstrapTokensToEndpointMap.get(t);\n            tokenToEndPointMap.put(t, ep);\n            try\n            {\n                for (Range r : getRangeMap(tokenToEndPointMap).get(ep))\n                {\n                    if (r.contains(token))\n                    {\n                        list.add(ep);\n                        break;\n                    }\n                }\n            }\n            finally\n            {\n                tokenToEndPointMap.remove(t);\n            }\n        }\n        retrofitPorts(list);\n        return list.toArray(new EndPoint[list.size()]);\n    }","id":47048,"modified_method":"/**\n     * write endpoints may be different from read endpoints, because read endpoints only need care about the\n     * \"natural\" nodes for a token, but write endpoints also need to account for nodes that are bootstrapping\n     * into the ring, and write data there too so that they stay up to date during the bootstrap process.\n     * Thus, this method may return more nodes than the Replication Factor.\n     *\n     * Only ReplicationStrategy should care about this method (higher level users should only ask for Hinted).\n     */\n    protected EndPoint[] getWriteStorageEndPoints(Token token, EndPoint[] naturalEndpoints)\n    {\n        Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();\n        Map<Token, EndPoint> bootstrapTokensToEndpointMap = tokenMetadata_.cloneBootstrapNodes();\n        ArrayList<EndPoint> list = new ArrayList<EndPoint>(Arrays.asList(naturalEndpoints));\n        for (Token t : bootstrapTokensToEndpointMap.keySet())\n        {\n            EndPoint ep = bootstrapTokensToEndpointMap.get(t);\n            tokenToEndPointMap.put(t, ep);\n            try\n            {\n                for (Range r : getRangeMap(tokenToEndPointMap).get(ep))\n                {\n                    if (r.contains(token))\n                    {\n                        list.add(ep);\n                        break;\n                    }\n                }\n            }\n            finally\n            {\n                tokenToEndPointMap.remove(t);\n            }\n        }\n        return retrofitPorts(list).toArray(new EndPoint[list.size()]);\n    }","commit_id":"d5eaa4e141ea830bbbacc7c249198e58169882e7","url":"https://github.com/apache/cassandra"},{"original_method":"public static void startBootstrap() throws IOException\n    {\n        logger_.info(\"Starting in bootstrap mode (first, sleeping to get load information)\");\n\n        StorageService ss = StorageService.instance();\n        StorageLoadBalancer slb = StorageLoadBalancer.instance();\n\n        slb.waitForLoadInfo();\n\n        // if initialtoken was specified, use that.  otherwise, pick a token to assume half the load of the most-loaded node.\n        if (DatabaseDescriptor.getInitialToken() == null)\n        {\n            double maxLoad = 0;\n            EndPoint maxEndpoint = null;\n            for (Map.Entry<EndPoint,Double> entry : slb.getLoadInfo().entrySet())\n            {\n                if (maxEndpoint == null || entry.getValue() > maxLoad)\n                {\n                    maxEndpoint = entry.getKey();\n                    maxLoad = entry.getValue();\n                }\n            }\n            if (maxEndpoint == null)\n            {\n                throw new RuntimeException(\"No bootstrap sources found\");\n            }\n\n            if (!maxEndpoint.equals(StorageService.getLocalStorageEndPoint()))\n            {\n                StorageService.instance().retrofitPorts(Arrays.asList(maxEndpoint));\n                Token<?> t = getBootstrapTokenFrom(maxEndpoint);\n                logger_.info(\"Setting token to \" + t + \" to assume load from \" + maxEndpoint.getHost());\n                ss.updateToken(t);\n            }\n        }\n\n        BootStrapper bs = new BootStrapper(new EndPoint[] {StorageService.getLocalStorageEndPoint()}, ss.getLocalToken());\n        bootstrapExecutor_.submit(bs);\n        Gossiper.instance().addApplicationState(StorageService.BOOTSTRAP_MODE, new ApplicationState(\"\"));\n    }","id":47049,"modified_method":"public static void startBootstrap() throws IOException\n    {\n        logger_.info(\"Starting in bootstrap mode (first, sleeping to get load information)\");\n\n        StorageService ss = StorageService.instance();\n        StorageLoadBalancer slb = StorageLoadBalancer.instance();\n\n        slb.waitForLoadInfo();\n\n        // if initialtoken was specified, use that.  otherwise, pick a token to assume half the load of the most-loaded node.\n        if (DatabaseDescriptor.getInitialToken() == null)\n        {\n            double maxLoad = 0;\n            EndPoint maxEndpoint = null;\n            for (Map.Entry<EndPoint,Double> entry : slb.getLoadInfo().entrySet())\n            {\n                if (maxEndpoint == null || entry.getValue() > maxLoad)\n                {\n                    maxEndpoint = entry.getKey();\n                    maxLoad = entry.getValue();\n                }\n            }\n            if (maxEndpoint == null)\n            {\n                throw new RuntimeException(\"No bootstrap sources found\");\n            }\n\n            if (!maxEndpoint.equals(StorageService.getLocalStorageEndPoint()))\n            {\n                EndPoint maxStorageEndpoint = new EndPoint(maxEndpoint.getHost(), DatabaseDescriptor.getStoragePort());\n                Token<?> t = getBootstrapTokenFrom(maxStorageEndpoint);\n                logger_.info(\"Setting token to \" + t + \" to assume load from \" + maxEndpoint.getHost());\n                ss.updateToken(t);\n            }\n        }\n\n        BootStrapper bs = new BootStrapper(new EndPoint[] {StorageService.getLocalStorageEndPoint()}, ss.getLocalToken());\n        bootstrapExecutor_.submit(bs);\n        Gossiper.instance().addApplicationState(StorageService.BOOTSTRAP_MODE, new ApplicationState(\"\"));\n    }","commit_id":"d5eaa4e141ea830bbbacc7c249198e58169882e7","url":"https://github.com/apache/cassandra"},{"original_method":"public EndPoint[] getReadStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)\n    {\n        int startIndex;\n        List<EndPoint> list = new ArrayList<EndPoint>();\n        boolean bDataCenter = false;\n        boolean bOtherRack = false;\n        int foundCount = 0;\n        List tokens = new ArrayList(tokenToEndPointMap.keySet());\n        Collections.sort(tokens);\n        int index = Collections.binarySearch(tokens, token);\n        if(index < 0)\n        {\n            index = (index + 1) * (-1);\n            if (index >= tokens.size())\n                index = 0;\n        }\n        int totalNodes = tokens.size();\n        // Add the node at the index by default\n        list.add(tokenToEndPointMap.get(tokens.get(index)));\n        foundCount++;\n        if( replicas_ == 1 )\n        {\n            return list.toArray(new EndPoint[list.size()]);\n        }\n        startIndex = (index + 1)%totalNodes;\n        IEndPointSnitch endPointSnitch = StorageService.instance().getEndPointSnitch();\n        \n        for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)\n        {\n            try\n            {\n                // First try to find one in a different data center\n                if(!endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))\n                {\n                    // If we have already found something in a diff datacenter no need to find another\n                    if( !bDataCenter )\n                    {\n                        list.add(tokenToEndPointMap.get(tokens.get(i)));\n                        bDataCenter = true;\n                        foundCount++;\n                    }\n                    continue;\n                }\n                // Now  try to find one on a different rack\n                if(!endPointSnitch.isOnSameRack(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))) &&\n                        endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))\n                {\n                    // If we have already found something in a diff rack no need to find another\n                    if( !bOtherRack )\n                    {\n                        list.add(tokenToEndPointMap.get(tokens.get(i)));\n                        bOtherRack = true;\n                        foundCount++;\n                    }\n                }\n            }\n            catch (UnknownHostException e)\n            {\n                if (logger_.isDebugEnabled())\n                  logger_.debug(LogUtil.throwableToString(e));\n            }\n\n        }\n        // If we found N number of nodes we are good. This loop wil just exit. Otherwise just\n        // loop through the list and add until we have N nodes.\n        for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)\n        {\n            if( ! list.contains(tokenToEndPointMap.get(tokens.get(i))))\n            {\n                list.add(tokenToEndPointMap.get(tokens.get(i)));\n                foundCount++;\n            }\n        }\n        retrofitPorts(list);\n        return list.toArray(new EndPoint[list.size()]);\n    }","id":47050,"modified_method":"public EndPoint[] getReadStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)\n    {\n        int startIndex;\n        List<EndPoint> list = new ArrayList<EndPoint>();\n        boolean bDataCenter = false;\n        boolean bOtherRack = false;\n        int foundCount = 0;\n        List tokens = new ArrayList(tokenToEndPointMap.keySet());\n        Collections.sort(tokens);\n        int index = Collections.binarySearch(tokens, token);\n        if(index < 0)\n        {\n            index = (index + 1) * (-1);\n            if (index >= tokens.size())\n                index = 0;\n        }\n        int totalNodes = tokens.size();\n        // Add the node at the index by default\n        list.add(tokenToEndPointMap.get(tokens.get(index)));\n        foundCount++;\n        if( replicas_ == 1 )\n        {\n            return list.toArray(new EndPoint[list.size()]);\n        }\n        startIndex = (index + 1)%totalNodes;\n        IEndPointSnitch endPointSnitch = StorageService.instance().getEndPointSnitch();\n        \n        for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)\n        {\n            try\n            {\n                // First try to find one in a different data center\n                if(!endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))\n                {\n                    // If we have already found something in a diff datacenter no need to find another\n                    if( !bDataCenter )\n                    {\n                        list.add(tokenToEndPointMap.get(tokens.get(i)));\n                        bDataCenter = true;\n                        foundCount++;\n                    }\n                    continue;\n                }\n                // Now  try to find one on a different rack\n                if(!endPointSnitch.isOnSameRack(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))) &&\n                        endPointSnitch.isInSameDataCenter(tokenToEndPointMap.get(tokens.get(index)), tokenToEndPointMap.get(tokens.get(i))))\n                {\n                    // If we have already found something in a diff rack no need to find another\n                    if( !bOtherRack )\n                    {\n                        list.add(tokenToEndPointMap.get(tokens.get(i)));\n                        bOtherRack = true;\n                        foundCount++;\n                    }\n                }\n            }\n            catch (UnknownHostException e)\n            {\n                if (logger_.isDebugEnabled())\n                  logger_.debug(LogUtil.throwableToString(e));\n            }\n\n        }\n        // If we found N number of nodes we are good. This loop wil just exit. Otherwise just\n        // loop through the list and add until we have N nodes.\n        for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)\n        {\n            if( ! list.contains(tokenToEndPointMap.get(tokens.get(i))))\n            {\n                list.add(tokenToEndPointMap.get(tokens.get(i)));\n                foundCount++;\n            }\n        }\n        return retrofitPorts(list).toArray(new EndPoint[list.size()]);\n    }","commit_id":"d5eaa4e141ea830bbbacc7c249198e58169882e7","url":"https://github.com/apache/cassandra"},{"original_method":"public EndPoint[] getReadStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)\n    {\n        int startIndex;\n        List<Token> tokenList = new ArrayList<Token>();\n        int foundCount = 0;\n        List tokens = new ArrayList<Token>(tokenToEndPointMap.keySet());\n        List<Token> bsTokens = null;\n\n        Collections.sort(tokens);\n        int index = Collections.binarySearch(tokens, token);\n        if(index < 0)\n        {\n            index = (index + 1) * (-1);\n            if (index >= tokens.size())\n                index = 0;\n        }\n        int totalNodes = tokens.size();\n        // Add the token at the index by default\n        tokenList.add((Token)tokens.get(index));\n        if (bsTokens == null || !bsTokens.contains(tokens.get(index)))\n            foundCount++;\n        startIndex = (index + 1)%totalNodes;\n        // If we found N number of nodes we are good. This loop will just exit. Otherwise just\n        // loop through the list and add until we have N nodes.\n        for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)\n        {\n            if(!tokenList.contains(tokens.get(i)))\n            {\n                tokenList.add((Token)tokens.get(i));\n                //Don't count bootstrapping tokens towards the count\n                if (bsTokens==null || !bsTokens.contains(tokens.get(i)))\n                    foundCount++;\n            }\n        }\n        List<EndPoint> list = new ArrayList<EndPoint>();\n        for (Token t: tokenList)\n            list.add(tokenToEndPointMap.get(t));\n        retrofitPorts(list);\n        return list.toArray(new EndPoint[list.size()]);\n    }","id":47051,"modified_method":"public EndPoint[] getReadStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap)\n    {\n        int startIndex;\n        List<Token> tokenList = new ArrayList<Token>();\n        int foundCount = 0;\n        List tokens = new ArrayList<Token>(tokenToEndPointMap.keySet());\n        List<Token> bsTokens = null;\n\n        Collections.sort(tokens);\n        int index = Collections.binarySearch(tokens, token);\n        if(index < 0)\n        {\n            index = (index + 1) * (-1);\n            if (index >= tokens.size())\n                index = 0;\n        }\n        int totalNodes = tokens.size();\n        // Add the token at the index by default\n        tokenList.add((Token)tokens.get(index));\n        if (bsTokens == null || !bsTokens.contains(tokens.get(index)))\n            foundCount++;\n        startIndex = (index + 1)%totalNodes;\n        // If we found N number of nodes we are good. This loop will just exit. Otherwise just\n        // loop through the list and add until we have N nodes.\n        for (int i = startIndex, count = 1; count < totalNodes && foundCount < replicas_; ++count, i = (i+1)%totalNodes)\n        {\n            if(!tokenList.contains(tokens.get(i)))\n            {\n                tokenList.add((Token)tokens.get(i));\n                //Don't count bootstrapping tokens towards the count\n                if (bsTokens==null || !bsTokens.contains(tokens.get(i)))\n                    foundCount++;\n            }\n        }\n        List<EndPoint> list = new ArrayList<EndPoint>();\n        for (Token t: tokenList)\n            list.add(tokenToEndPointMap.get(t));\n        return retrofitPorts(list).toArray(new EndPoint[list.size()]);\n    }","commit_id":"d5eaa4e141ea830bbbacc7c249198e58169882e7","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * This method is called when the routing message interceptor has intercepted a inbound\n     * message as a DOM Content.  It retreives the header parts as DOM Element\n     * and returns a Element.\n     * @param inMessage\n     * @return Element\n     */\n    protected abstract Element getHeader(T inMessage);","id":47052,"modified_method":"/**\n     * This method is called when the routing message interceptor has intercepted a inbound\n     * message as a DOM Content.  It retreives the header parts as DOM Element\n     * and returns a Element.\n     */\n    protected abstract Element getHeader(T inMessage);","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * This method is called when the routing message interceptor has intercepted a inbound\n     * message as a DOM Content.  It retreives the message parts as DOM Element\n     * and returns a List<Element>\n     * @param inMessage\n     * @param rootElement\n     * @param bindingMessageInfo\n     * @return List<Element>\n     */\n    protected abstract List<Element> getPartList(T inMessage, Element rootElement, BindingMessageInfo boi);","id":47053,"modified_method":"/**\n     * This method is called when the routing message interceptor has intercepted a inbound\n     * message as a DOM Content.  It retreives the message parts as DOM Element\n     * and returns a List of Element.\n     */\n    protected abstract List<Element> getPartList(T inMessage, Element rootElement, BindingMessageInfo boi);","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * This method is called to convert a incoming message format e.g Stax Stream\n     * to a DOM Tree. Default Implementation converts Stax Stream to a DOM\n     * @param inMessage\n     * @param Document\n     */\n    protected Document createDOMMessage(T message) {\n        Document doc = null;\n        try {\n            if (getLogger().isLoggable(Level.INFO)) {\n                getLogger().info(\"AbstractMessageInInterceptor Converting Stax Stream to DOM\");\n            }\n            XMLStreamReader xsr = message.getContent(XMLStreamReader.class);            \n            doc = StaxUtils.read(xsr);\n        } catch (XMLStreamException xe) {\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"STAX_READ_EXC\", LOG), xe);\n        }\n        return doc;\n    }","id":47054,"modified_method":"/**\n     * This method is called to convert a incoming message format e.g Stax Stream\n     * to a DOM Tree. Default Implementation converts Stax Stream to a DOM\n     */\n    protected Document createDOMMessage(T message) {\n        Document doc = null;\n        try {\n            if (getLogger().isLoggable(Level.INFO)) {\n                getLogger().info(\"AbstractMessageInInterceptor Converting Stax Stream to DOM\");\n            }\n            XMLStreamReader xsr = message.getContent(XMLStreamReader.class);            \n            doc = StaxUtils.read(xsr);\n        } catch (XMLStreamException xe) {\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"STAX_READ_EXC\", LOG), xe);\n        }\n        return doc;\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * This method is called when the routing message interceptor has received a inbound message\n     * It infers the binding operation by matching the root Element with a binding operation\n     * from the service model.\n     * @param inMessage\n     * @param resultPayload\n     */\n    protected abstract BindingOperationInfo getBindingOperation(T inMessage, Document document);","id":47055,"modified_method":"/**\n     * This method is called when the routing message interceptor has received a inbound message\n     * It infers the binding operation by matching the root Element with a binding operation\n     * from the service model.\n     */\n    protected abstract BindingOperationInfo getBindingOperation(T inMessage, Document document);","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * This method is called on incoming to check if it is a fault.\n     * @param inMessage\n     * @param boolean\n     */\n    protected abstract boolean isFaultMessage(T message);","id":47056,"modified_method":"/**\n     * This method is called on incoming to check if it is a fault.\n     */\n    protected abstract boolean isFaultMessage(T message);","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"public void deactivate() {\n        try {\n            consumer.stop();\n        } catch (Exception e) {\n            // TODO need to handle the exception somewhere\n            e.printStackTrace();\n        }\n    }","id":47057,"modified_method":"public void deactivate() {\n        try {\n            consumer.stop();\n        } catch (Exception e) {\n            // TODO: Is it okay just to log severe errors such as this?\n            getLogger().log(Level.SEVERE, \"Camel stop failed with Exception : \", e);\n        }\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"public void activate() {\n        getLogger().log(Level.FINE, \"CamelDestination activate().... \");\n\n        try {\n            getLogger().log(Level.FINE, \"establishing Camel connection\");\n            distinationEndpoint = camelContext.getEndpoint(camelDestinationUri);\n            consumer = distinationEndpoint.createConsumer(new ConsumerProcessor());\n            consumer.start();\n\n        } catch (Exception ex) {\n            getLogger().log(Level.SEVERE, \"Camel connect failed with EException : \", ex);\n        }\n    }","id":47058,"modified_method":"public void activate() {\n        getLogger().log(Level.FINE, \"CamelDestination activate().... \");\n\n        try {\n            getLogger().log(Level.FINE, \"establishing Camel connection\");\n            distinationEndpoint = camelContext.getEndpoint(camelDestinationUri);\n            consumer = distinationEndpoint.createConsumer(new ConsumerProcessor());\n            consumer.start();\n\n        } catch (Exception ex) {\n            // TODO: Is it okay just to log severe errors such as this?\n            getLogger().log(Level.SEVERE, \"Camel connect failed with Exception : \", ex);\n        }\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Mark message as a partial message.\n     *\n     * @param partialResponse the partial response message\n     * @param the decoupled target\n     * @return true iff partial responses are supported\n     */\n    protected boolean markPartialResponse(Message partialResponse,\n                                       EndpointReferenceType decoupledTarget) {\n        return true;\n    }","id":47059,"modified_method":"/**\n     * Mark message as a partial message.\n     *\n     * @param partialResponse the partial response message\n     * @param decoupledTarget the decoupled target\n     * @return <tt>true<\/tt> if partial responses is supported\n     */\n    protected boolean markPartialResponse(Message partialResponse,\n                                       EndpointReferenceType decoupledTarget) {\n        return true;\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"public void testCamelDestinationConfiguration() throws Exception {\n        QName testEndpointQName = new QName(\"http://activemq.apache.org/camel-test\", \"port\");\n        // set up the bus with configure file\n        SpringBusFactory bf = new SpringBusFactory();\n        BusFactory.setDefaultBus(null);\n        Bus bus = bf.createBus(\"/org/apache/camel/component/cxf/transport/CamelDestination.xml\");\n        BusFactory.setDefaultBus(bus);\n\n        endpointInfo.setAddress(\"camel://direct:EndpointA\");\n        endpointInfo.setName(testEndpointQName);\n        CamelDestination destination = new CamelDestination(null, bus, null, endpointInfo);\n\n        System.out.println(\"get the destination bean name\" + destination.getBeanName());\n        CamelContext context = destination.getCamelContext();\n\n        assertNotNull(\"The camel context which get from camel destination is not null\", context);\n        assertEquals(\"Get the wrong camel context\", context.getName(), \"dest_context\");\n        assertEquals(\"The camel context should has two routers\", context.getRoutes().size(), 2);\n        assertEquals(\"The router 0 start endpoint is wrong\", context.getRoutes().get(0).getEndpoint().getEndpointUri(), \"direct:EndpointA\");\n        bus.shutdown(false);\n    }","id":47060,"modified_method":"public void testCamelDestinationConfiguration() throws Exception {\n        QName testEndpointQName = new QName(\"http://activemq.apache.org/camel-test\", \"port\");\n        // set up the bus with configure file\n        SpringBusFactory bf = new SpringBusFactory();\n        BusFactory.setDefaultBus(null);\n        Bus bus = bf.createBus(\"/org/apache/camel/component/cxf/transport/CamelDestination.xml\");\n        BusFactory.setDefaultBus(bus);\n\n        endpointInfo.setAddress(\"camel://direct:EndpointA\");\n        endpointInfo.setName(testEndpointQName);\n        CamelDestination destination = new CamelDestination(null, bus, null, endpointInfo);\n\n        assertEquals(\"{http://activemq.apache.org/camel-test}port.camel-destination\", destination.getBeanName());\n        CamelContext context = destination.getCamelContext();\n\n        assertNotNull(\"The camel context which get from camel destination is not null\", context);\n        assertEquals(\"Get the wrong camel context\", context.getName(), \"dest_context\");\n        assertEquals(\"The camel context should has two routers\", context.getRoutes().size(), 2);\n        assertEquals(\"The router 0 start endpoint is wrong\", context.getRoutes().get(0).getEndpoint().getEndpointUri(), \"direct:EndpointA\");\n        bus.shutdown(false);\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * This method is called when the incoming pojo or WebServiceProvider invocation is called\n     * from the service invocation interceptor. The return value is the response\n     * from the processor\n     * @param inMessage\n     * @return outMessage\n     */\n    public Object invoke(Exchange exchange, Object o) {\n\n        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();\n\n        Object params = null;\n\n\n        if (o instanceof List) {\n            params = CastUtils.cast((List<?>)o);\n        } else if (o != null) {\n            params = new MessageContentsList(o);\n        }\n\n\n        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());\n\n        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);\n        MethodDispatcher md = (MethodDispatcher)\n            exchange.get(Service.class).get(MethodDispatcher.class.getName());\n        Method m = md.getMethod(bop);\n\n        // The SEI could be the provider class which will not have the bop information.\n        if (bop != null && bop.getOperationInfo().isOneWay()) {\n            cxfExchange.setPattern(ExchangePattern.InOnly);\n        } else {\n            cxfExchange.setPattern(ExchangePattern.InOut);\n        }\n        cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, m.getName());\n        cxfExchange.getIn().setBody(params);\n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception ex) {\n            // catch the exception and send back to cxf client\n            throw new Fault(ex);\n        }\n\n        Object result = null;\n        if (cxfExchange.isFailed()) {\n            Exception ex = (Exception)cxfExchange.getFault().getBody();\n            if (ex instanceof Fault) {\n                throw (Fault)ex;\n            } else {\n                throw new Fault(ex);\n            }\n        } else {\n            result = cxfExchange.getOut().getBody();\n        }\n        return result;\n    }","id":47061,"modified_method":"/**\n     * This method is called when the incoming pojo or WebServiceProvider invocation is called\n     * from the service invocation interceptor. The return value is the response\n     * from the processor\n     */\n    public Object invoke(Exchange exchange, Object o) {\n        CxfEndpoint endpoint = cxfConsumer.getEndpoint();\n\n        Object params = null;\n        if (o instanceof List) {\n            params = CastUtils.cast((List<?>)o);\n        } else if (o != null) {\n            params = new MessageContentsList(o);\n        }\n\n        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());\n\n        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);\n        MethodDispatcher md = (MethodDispatcher)\n            exchange.get(Service.class).get(MethodDispatcher.class.getName());\n        Method m = md.getMethod(bop);\n\n        // The SEI could be the provider class which will not have the bop information.\n        if (bop != null && bop.getOperationInfo().isOneWay()) {\n            cxfExchange.setPattern(ExchangePattern.InOnly);\n        } else {\n            cxfExchange.setPattern(ExchangePattern.InOut);\n        }\n        cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, m.getName());\n        cxfExchange.getIn().setBody(params);\n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception ex) {\n            // catch the exception and send back to cxf client\n            throw new Fault(ex);\n        }\n\n        Object result = null;\n        if (cxfExchange.isFailed()) {\n            Exception ex = (Exception)cxfExchange.getFault().getBody();\n            if (ex instanceof Fault) {\n                throw (Fault)ex;\n            } else {\n                throw new Fault(ex);\n            }\n        } else {\n            result = cxfExchange.getOut().getBody();\n        }\n        return result;\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n    * This method is called when the incoming message is to\n    * be passed into the camel processor. The return value is the response\n    * from the processor\n    * @param inMessage\n    */\n    public void invoke(Exchange exchange) {\n        Message inMessage = exchange.getInMessage();\n\n        //TODO set the request context here\n        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();\n        CxfExchange cxfExchange = endpoint.createExchange(inMessage);\n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception ex) {\n            // catch the exception and send back to cxf client\n            throw new Fault(ex);\n        }\n\n        // make sure the client has return back the message\n        copybackExchange(cxfExchange, exchange);\n\n        Message outMessage = exchange.getOutMessage();\n        // update the outMessageContext\n        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);\n        BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);\n\n        if (boi != null) {\n            exchange.put(BindingMessageInfo.class, boi.getOutput());\n        }\n    }","id":47062,"modified_method":"/**\n    * This method is called when the incoming message is to\n    * be passed into the camel processor. The return value is the response\n    * from the processor\n    */\n    public void invoke(Exchange exchange) {\n        Message inMessage = exchange.getInMessage();\n\n        //TODO set the request context here\n        CxfEndpoint endpoint = cxfConsumer.getEndpoint();\n        CxfExchange cxfExchange = endpoint.createExchange(inMessage);\n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception ex) {\n            // catch the exception and send back to cxf client\n            throw new Fault(ex);\n        }\n\n        // make sure the client has return back the message\n        copybackExchange(cxfExchange, exchange);\n\n        Message outMessage = exchange.getOutMessage();\n        // update the outMessageContext\n        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);\n        BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);\n\n        if (boi != null) {\n            exchange.put(BindingMessageInfo.class, boi.getOutput());\n        }\n    }","commit_id":"ffbd7a046700c081ddf7d85eb2a7b7283a6c60b0","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Writes the exchange to the servlet response\n     *\n     * @param response\n     * @throws IOException\n     */\n    public void writeResponse(HttpExchange exchange, HttpServletResponse response) throws IOException {\n        Message out = exchange.getOut();\n        if (out != null) {\n\n            // Set the status code in the response.  Default is 200.\n            if (out.getHeader(HttpProducer.HTTP_RESPONSE_CODE) != null) {\n                int responseCode = ((Integer)out.getHeader(HttpProducer.HTTP_RESPONSE_CODE)).intValue();\n                response.setStatus(responseCode);\n            }\n\n            // Write out the headers...\n            for (String key : out.getHeaders().keySet()) {\n                String value = out.getHeader(key, String.class);\n                if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, value)) {\n                    response.setHeader(key, value);\n                }\n            }\n\n            // Write out the body.\n            if (out.getBody() != null) {\n\n                // Try to stream the body since that would be the most\n                // efficient..\n                InputStream is = out.getBody(InputStream.class);\n                if (is != null) {\n                    ServletOutputStream os = response.getOutputStream();\n                    int c;\n                    while ((c = is.read()) >= 0) {\n                        os.write(c);\n                    }\n                } else {\n                    String data = out.getBody(String.class);\n                    if (data != null) {\n                        response.getWriter().print(data);\n                    }\n                }\n            }\n        }\n    }","id":47063,"modified_method":"/**\n     * Writes the exchange to the servlet response\n     */\n    public void writeResponse(HttpExchange exchange, HttpServletResponse response) throws IOException {\n        Message out = exchange.getOut();\n        if (out != null) {\n            // Set the status code in the response. Default is 200.\n            if (out.getHeader(HttpProducer.HTTP_RESPONSE_CODE) != null) {\n                int code = out.getHeader(HttpProducer.HTTP_RESPONSE_CODE, Integer.class);\n                response.setStatus(code);\n            }\n\n            // Write out the headers\n            for (String key : out.getHeaders().keySet()) {\n                String value = out.getHeader(key, String.class);\n                if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToCamelHeaders(key, value)) {\n                    response.setHeader(key, value);\n                }\n            }\n\n            // Write out the body.\n            if (out.getBody() != null) {\n\n                // Try to stream the body since that would be the most efficient\n                InputStream is = out.getBody(InputStream.class);\n                if (is != null) {\n                    ServletOutputStream os = response.getOutputStream();\n                    int c;\n                    while ((c = is.read()) >= 0) {\n                        os.write(c);\n                    }\n                } else {\n                    String data = out.getBody(String.class);\n                    if (data != null) {\n                        response.getWriter().print(data);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Should the {@link HttpServletRequest#getReader()} be exposed as the payload of input messages in the Camel\n     * {@link Message#getBody()} or not. If false then the {@link HttpServletRequest#getInputStream()} will be exposed.\n     *\n     * @param useReaderForPayload\n     */\n    public void setUseReaderForPayload(boolean useReaderForPayload) {\n        this.useReaderForPayload = useReaderForPayload;\n    }","id":47064,"modified_method":"/**\n     * Should the {@link HttpServletRequest#getReader()} be exposed as the payload of input messages in the Camel\n     * {@link Message#getBody()} or not. If false then the {@link HttpServletRequest#getInputStream()} will be exposed.\n     */\n    public void setUseReaderForPayload(boolean useReaderForPayload) {\n        this.useReaderForPayload = useReaderForPayload;\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * @deprecated please use {@link HeaderPropagationStrategy} instead\n     */\n    @Deprecated\n    public Set<String> getIgnoredHeaders() {\n        if (headerFilterStrategy instanceof DefaultHeaderFilterStrategy) {\n            return ((DefaultHeaderFilterStrategy)headerFilterStrategy)\n                    .getOutFilter();\n        } else {\n            return null;\n        }\n\n    }","id":47065,"modified_method":"/**\n     * @deprecated please use {@link org.apache.camel.spi.HeaderFilterStrategy} instead\n     */\n    @Deprecated\n    public Set<String> getIgnoredHeaders() {\n        if (headerFilterStrategy instanceof DefaultHeaderFilterStrategy) {\n            return ((DefaultHeaderFilterStrategy)headerFilterStrategy)\n                    .getOutFilter();\n        } else {\n            return null;\n        }\n\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"protected void initialize() {\n        getOutFilter().add(\"content-length\");\n        getOutFilter().add(\"content-type\");\n        getOutFilter().add(HttpProducer.HTTP_RESPONSE_CODE.toLowerCase());\n        setIsLowercase(true);\n        \n        // filter headers begin with \"org.apache.camel\"\n        setOutFilterPattern(\"(org\\\\.apache\\\\.camel)[\\\\.|a-z|A-z|0-9]*\");    \n    }","id":47066,"modified_method":"protected void initialize() {\n        getOutFilter().add(\"content-length\");\n        getOutFilter().add(\"content-type\");\n        getOutFilter().add(HttpMethods.HTTP_METHOD);\n        getOutFilter().add(HttpProducer.QUERY);\n        getOutFilter().add(HttpProducer.HTTP_RESPONSE_CODE.toLowerCase());\n        setIsLowercase(true);\n        \n        // filter headers begin with \"org.apache.camel\"\n        setOutFilterPattern(\"(org\\\\.apache\\\\.camel)[\\\\.|a-z|A-z|0-9]*\");    \n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            map.put(name, value);\n        }\n    }","id":47067,"modified_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        // populate the http request headers\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            map.put(name, value);\n        }\n\n        // also populate the http request parameters\n        names = request.getParameterNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getParameter(name);\n            map.put(name, value);\n        }\n\n        // store the method and query as well\n        map.put(HttpMethods.HTTP_METHOD, request.getMethod());\n        map.put(HttpProducer.QUERY, request.getQueryString());\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        HttpMethod method = createMethod(exchange);\n        Message in = exchange.getIn();\n        HttpBinding binding = ((HttpEndpoint)getEndpoint()).getBinding();\n        HeaderFilterStrategy strategy = ((HttpEndpoint)getEndpoint()).getHeaderFilterStrategy();\n\n        // propagate headers as HTTP headers\n        for (String headerName : in.getHeaders().keySet()) {\n            String headerValue = in.getHeader(headerName, String.class);\n            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue)) {\n                method.addRequestHeader(headerName, headerValue);\n            }\n        }\n\n        // lets store the result in the output message.\n        Message out = exchange.getOut(true);\n        try {\n            int responseCode = httpClient.executeMethod(method);\n            out.setHeaders(in.getHeaders());\n            out.setHeader(HTTP_RESPONSE_CODE, responseCode);\n            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();\n            InputStream is = method.getResponseBodyAsStream();\n            IOUtils.copy(is, bos);\n            bos.flush();\n            is.close();\n            out.setBody(bos.createInputStream());\n            \n            // propagate HTTP response headers \n            Header[] headers = method.getResponseHeaders();\n            for (Header header : headers) {\n                String name = header.getName();\n                String value = header.getValue();\n                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {\n                    out.setHeader(name, value);\n                }\n            }\n        } finally {\n            method.releaseConnection();\n        }\n    }","id":47068,"modified_method":"public void process(Exchange exchange) throws Exception {\n        HttpMethod method = createMethod(exchange);\n        Message in = exchange.getIn();\n        HeaderFilterStrategy strategy = ((HttpEndpoint)getEndpoint()).getHeaderFilterStrategy();\n\n        // propagate headers as HTTP headers\n        for (String headerName : in.getHeaders().keySet()) {\n            String headerValue = in.getHeader(headerName, String.class);\n            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue)) {\n                method.addRequestHeader(headerName, headerValue);\n            }\n        }\n\n        // lets store the result in the output message.\n        Message out = exchange.getOut(true);\n        try {\n            int responseCode = httpClient.executeMethod(method);\n            out.setHeaders(in.getHeaders());\n            out.setHeader(HTTP_RESPONSE_CODE, responseCode);\n            LoadingByteArrayOutputStream bos = new LoadingByteArrayOutputStream();\n            InputStream is = method.getResponseBodyAsStream();\n            IOUtils.copy(is, bos);\n            bos.flush();\n            is.close();\n            out.setBody(bos.createInputStream());\n            \n            // propagate HTTP response headers \n            Header[] headers = method.getResponseHeaders();\n            for (Header header : headers) {\n                String name = header.getName();\n                String value = header.getValue();\n                if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value)) {\n                    out.setHeader(name, value);\n                }\n            }\n        } finally {\n            method.releaseConnection();\n        }\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                // put the incoming data on the seda queue and return a fixed response that we got the file\n                from(\"jetty:http://localhost:8080/myworld\").to(\"seda:in\").setBody(constant(\"We got the file\"));\n\n                // store the content from the queue as a file\n                from(\"seda:in\").process(new MyJettyProcessor())\n                    .setHeader(FileComponent.HEADER_FILE_NAME, constant(\"hello.txt\"))\n                    .to(\"file://target/myworld?append=false\");\n            }\n        };\n    }","id":47069,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                // put the incoming data on the seda queue and return a fixed response that we got the file\n                from(\"jetty:http://localhost:8080/myworld\").to(\"seda:in\").setBody(constant(\"We got the file\"));\n\n                // store the content from the queue as a file\n                from(\"seda:in\")\n                    .setHeader(FileComponent.HEADER_FILE_NAME, constant(\"hello.txt\"))\n                    .to(\"file://target/myworld?append=false\");\n            }\n        };\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified\n     * processor.\n     *\n     * @throws Exception\n     */\n    @Override\n    public void disconnect(HttpConsumer consumer) throws Exception {\n        camelServlet.disconnect(consumer);\n\n        // If the connector is not needed anymore.. then stop it.\n        HttpEndpoint endpoint = (HttpEndpoint)consumer.getEndpoint();\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef != null) {\n                if (connectorRef.decrement() == 0) {\n                    getServer().removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectors.remove(connectorKey);\n                }\n            }\n        }\n    }","id":47070,"modified_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified\n     * processor.\n     */\n    @Override\n    public void disconnect(HttpConsumer consumer) throws Exception {\n        camelServlet.disconnect(consumer);\n\n        // If the connector is not needed anymore then stop it\n        HttpEndpoint endpoint = consumer.getEndpoint();\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef != null) {\n                if (connectorRef.decrement() == 0) {\n                    getServer().removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectors.remove(connectorKey);\n                }\n            }\n        }\n    }","commit_id":"ae2a5ee41dc456676102d85487e013b5b97d2f17","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"direct:start\").to(\"jetty:http://www.google.com\").to(\"mock:results\");\n            }\n        };\n    }","id":47071,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"direct:start\").to(\"http://www.google.com\").to(\"mock:results\");\n            }\n        };\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        HttpMethod method = createMethod(exchange);\n        Message in = exchange.getIn();\n        HeaderFilterStrategy strategy = ((HttpEndpoint)getEndpoint()).getHeaderFilterStrategy();\n\n        // propagate headers as HTTP headers\n        for (String headerName : in.getHeaders().keySet()) {\n            String headerValue = in.getHeader(headerName, String.class);\n            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue, exchange)) {\n                method.addRequestHeader(headerName, headerValue);\n            }\n        }\n\n        // lets store the result in the output message.\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Executing http \" + method.getName() + \" method: \" + method.getURI().toString());\n            }\n            int responseCode = executeMethod(method);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Http responseCode: \" + responseCode);\n            }\n\n            if (!throwException) {\n                // if we do not use failed exception then populate response for all response codes\n                populateResponse(exchange, method, in, strategy, responseCode);\n            } else {\n                if (responseCode >= 100 && responseCode < 300) {\n                    // only populate reponse for OK response\n                    populateResponse(exchange, method, in, strategy, responseCode);\n                } else {\n                    // operation failed so populate exception to throw\n                    throw populateHttpOperationFailedException(exchange, method, responseCode);\n                }\n            }\n        } finally {\n            method.releaseConnection();\n        }\n    }","id":47072,"modified_method":"public void process(Exchange exchange) throws Exception {\n        HttpMethod method = createMethod(exchange);\n        Message in = exchange.getIn();\n        HeaderFilterStrategy strategy = getEndpoint().getHeaderFilterStrategy();\n\n        // propagate headers as HTTP headers\n        for (String headerName : in.getHeaders().keySet()) {\n            String headerValue = in.getHeader(headerName, String.class);\n            if (strategy != null && !strategy.applyFilterToCamelHeaders(headerName, headerValue, exchange)) {\n                method.addRequestHeader(headerName, headerValue);\n            }\n        }\n\n        // lets store the result in the output message.\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Executing http \" + method.getName() + \" method: \" + method.getURI().toString());\n            }\n            int responseCode = executeMethod(method);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Http responseCode: \" + responseCode);\n            }\n\n            if (!throwException) {\n                // if we do not use failed exception then populate response for all response codes\n                populateResponse(exchange, method, in, strategy, responseCode);\n            } else {\n                if (responseCode >= 100 && responseCode < 300) {\n                    // only populate reponse for OK response\n                    populateResponse(exchange, method, in, strategy, responseCode);\n                } else {\n                    // operation failed so populate exception to throw\n                    throw populateHttpOperationFailedException(exchange, method, responseCode);\n                }\n            }\n        } finally {\n            method.releaseConnection();\n        }\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates the HttpMethod to use to call the remote server, either its GET or POST.\n     *\n     * @param exchange  the exchange\n     * @return the created method as either GET or POST\n     */\n    protected HttpMethod createMethod(Exchange exchange) {\n        // is a query string provided in the endpoint URI or in a header (header\n        // overrules endpoint)\n        String queryString = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class);\n        if (queryString == null) {\n            queryString = ((HttpEndpoint)getEndpoint()).getHttpUri().getQuery();\n        }\n        RequestEntity requestEntity = createRequestEntity(exchange);\n\n        // compute what method to use either GET or POST\n        HttpMethods methodToUse;\n        HttpMethods m = exchange.getIn().getHeader(Exchange.HTTP_METHOD, HttpMethods.class);\n        if (m != null) {\n            // always use what end-user provides in a header\n            methodToUse = m;\n        } else if (queryString != null) {\n            // if a query string is provided then use GET\n            methodToUse = HttpMethods.GET;\n        } else {\n            // fallback to POST if data, otherwise GET\n            methodToUse = requestEntity != null ? HttpMethods.POST : HttpMethods.GET;\n        }\n\n        String uri = null;\n        if (!((HttpEndpoint)getEndpoint()).isBridgeEndpoint()) {\n            uri = exchange.getIn().getHeader(Exchange.HTTP_URI, String.class);\n        }\n        if (uri == null) {\n            uri = ((HttpEndpoint)getEndpoint()).getHttpUri().toString();\n        }\n\n        // append HTTP_PATH to HTTP_URI if it is provided in the header\n        // when the endpoint is not working as a bridge\n        String path = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);\n        if (path != null) {\n            // make sure that there is exactly one \"/\" between HTTP_URI and\n            // HTTP_PATH\n            if (!uri.endsWith(\"/\")) {\n                uri = uri + \"/\";\n            }\n            if (path.startsWith(\"/\")) {\n                path = path.substring(1);\n            }\n            uri = uri.concat(path);\n        }\n\n        HttpMethod method = methodToUse.createMethod(uri);\n\n        if (queryString != null) {\n            method.setQueryString(queryString);\n        }\n        if (methodToUse.isEntityEnclosing()) {\n            ((EntityEnclosingMethod)method).setRequestEntity(requestEntity);\n            if (requestEntity != null && requestEntity.getContentType() == null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No Content-Type provided for URI: \" + uri + \" with exchange: \" + exchange);\n                }\n            }\n        }\n\n        return method;\n    }","id":47073,"modified_method":"/**\n     * Creates the HttpMethod to use to call the remote server, either its GET or POST.\n     *\n     * @param exchange  the exchange\n     * @return the created method as either GET or POST\n     */\n    protected HttpMethod createMethod(Exchange exchange) {\n\n        String url = HttpProducerHelper.createURL(exchange, getEndpoint());\n\n        RequestEntity requestEntity = createRequestEntity(exchange);\n        HttpMethods methodToUse = HttpProducerHelper.createMethod(exchange, getEndpoint(), requestEntity != null);\n        HttpMethod method = methodToUse.createMethod(url);\n\n        // is a query string provided in the endpoint URI or in a header (header overrules endpoint)\n        String queryString = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class);\n        if (queryString == null) {\n            queryString = getEndpoint().getHttpUri().getQuery();\n        }\n        if (queryString != null) {\n            method.setQueryString(queryString);\n        }\n\n        if (methodToUse.isEntityEnclosing()) {\n            ((EntityEnclosingMethod)method).setRequestEntity(requestEntity);\n            if (requestEntity != null && requestEntity.getContentType() == null) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No Content-Type provided for URL: \" + url + \" with exchange: \" + exchange);\n                }\n            }\n        }\n\n        return method;\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testEndpointWithoutHttps() {\n        MockEndpoint mockEndpoint = resolveMandatoryEndpoint(\"mock:a\", MockEndpoint.class);    \n        try {\n            template.sendBodyAndHeader(\"jetty:http://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n            fail(\"expect exception on access to https endpoint via http\");\n        } catch (RuntimeCamelException expected) {\n        }\n        assertTrue(\"mock endpoint was not called\", mockEndpoint.getExchanges().isEmpty());\n    }","id":47074,"modified_method":"@Test\n    public void testEndpointWithoutHttps() {\n        MockEndpoint mockEndpoint = resolveMandatoryEndpoint(\"mock:a\", MockEndpoint.class);    \n        try {\n            template.sendBodyAndHeader(\"http://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n            fail(\"expect exception on access to https endpoint via http\");\n        } catch (RuntimeCamelException expected) {\n        }\n        assertTrue(\"mock endpoint was not called\", mockEndpoint.getExchanges().isEmpty());\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"protected void invokeHttpEndpoint() throws IOException {\n        template.sendBodyAndHeader(\"jetty:https://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n        template.sendBodyAndHeader(\"jetty:https://localhost:9090/test\", expectedBody, \"Content-Type\", \"application/xml\");\n    }","id":47075,"modified_method":"protected void invokeHttpEndpoint() throws IOException {\n        template.sendBodyAndHeader(\"https://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n        template.sendBodyAndHeader(\"https://localhost:9090/test\", expectedBody, \"Content-Type\", \"application/xml\");\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCustomHttpBinding() throws Exception {\n        // assert jetty was configured with our timeout\n        JettyHttpEndpoint jettyEndpoint = (JettyHttpEndpoint) context.getEndpoint(\"jetty:http://localhost:8080/myapp/myservice?httpClient.soTimeout=5555\");\n        assertNotNull(\"Jetty endpoint should not be null \", jettyEndpoint);\n        HttpProducer producer = (HttpProducer)jettyEndpoint.createProducer();\n        assertEquals(\"Get the wrong http client parameter\", 5555, producer.getHttpClient().getParams().getSoTimeout());\n\n        // send and receive\n        Object out = template.requestBody(\"http://localhost:9080/myapp/myservice\", \"Hello World\");\n        assertEquals(\"Bye World\", context.getTypeConverter().convertTo(String.class, out));\n    }","id":47076,"modified_method":"@Test\n    public void testCustomHttpBinding() throws Exception {\n        // assert jetty was configured with our timeout\n        HttpEndpoint jettyEndpoint = context.getEndpoint(\"http://localhost:8080/myapp/myservice?httpClient.soTimeout=5555\", HttpEndpoint.class);\n        assertNotNull(\"Jetty endpoint should not be null \", jettyEndpoint);\n        HttpProducer producer = (HttpProducer)jettyEndpoint.createProducer();\n        assertEquals(\"Get the wrong http client parameter\", 5555, producer.getHttpClient().getParams().getSoTimeout());\n\n        // send and receive\n        Object out = template.requestBody(\"http://localhost:9080/myapp/myservice\", \"Hello World\");\n        assertEquals(\"Bye World\", context.getTypeConverter().convertTo(String.class, out));\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Producer createProducer() throws Exception {\n        return super.createProducer();\n    }","id":47077,"modified_method":"@Override\n    public Producer createProducer() throws Exception {\n        return new JettyHttpProducer(this);\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testEndpointWithoutHttps() {\n        MockEndpoint mockEndpoint = resolveMandatoryEndpoint(\"mock:a\", MockEndpoint.class);    \n        try {\n            template.sendBodyAndHeader(\"jetty:http://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n            fail(\"expect exception on access to https endpoint via http\");\n        } catch (RuntimeCamelException expected) {\n        }\n        assertTrue(\"mock endpoint was not called\", mockEndpoint.getExchanges().isEmpty());\n    }","id":47078,"modified_method":"@Test\n    public void testEndpointWithoutHttps() {\n        MockEndpoint mockEndpoint = resolveMandatoryEndpoint(\"mock:a\", MockEndpoint.class);    \n        try {\n            template.sendBodyAndHeader(\"http://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n            fail(\"expect exception on access to https endpoint via http\");\n        } catch (RuntimeCamelException expected) {\n        }\n        assertTrue(\"mock endpoint was not called\", mockEndpoint.getExchanges().isEmpty());\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"protected void invokeHttpEndpoint() throws IOException {\n        template.sendBodyAndHeader(\"jetty:https://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n    }","id":47079,"modified_method":"protected void invokeHttpEndpoint() throws IOException {\n        template.sendBodyAndHeader(\"https://localhost:9080/test\", expectedBody, \"Content-Type\", \"application/xml\");\n    }","commit_id":"a378d2405114825bfab0a799375737dcd4e6f8be","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     * \n     * @throws Exception\n     */\n    public void connect(CometdProducerConsumer prodcon) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        CometdEndpoint endpoint = (CometdEndpoint) prodcon.getEndpoint();\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getUri().getHost() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"cometds\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector();\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                             + \" Don't you want to use 0.0.0.0 instead (all network interfaces)?\");\n                }\n                getServer().addConnector(connector);\n\n                ContinuationCometdServlet servlet = createServletForConnector(connector, endpoint);\n                connectorRef = new ConnectorRef(connector, servlet);\n                connector.start();\n\n                connectors.put(connectorKey, connectorRef);\n            } else {\n                connectorRef.increment();\n            }\n            AbstractBayeux bayeux = connectorRef.servlet.getBayeux();\n            bayeux.setJSONCommented(endpoint.isJsonCommented());\n            prodcon.setBayeux(bayeux);\n        }\n    }","id":47080,"modified_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    public void connect(CometdProducerConsumer prodcon) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        CometdEndpoint endpoint = (CometdEndpoint) prodcon.getEndpoint();\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getUri().getHost() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"cometds\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector();\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                             + \" Don't you want to use 0.0.0.0 instead (all network interfaces)?\");\n                }\n                getServer().addConnector(connector);\n\n                ContinuationCometdServlet servlet = createServletForConnector(connector, endpoint);\n                connectorRef = new ConnectorRef(connector, servlet);\n                connector.start();\n\n                connectors.put(connectorKey, connectorRef);\n            } else {\n                connectorRef.increment();\n            }\n            AbstractBayeux bayeux = connectorRef.servlet.getBayeux();\n            bayeux.setJSONCommented(endpoint.isJsonCommented());\n            prodcon.setBayeux(bayeux);\n        }\n    }","commit_id":"833f466746fc74a4110601f65fc3189f42b7ec88","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified\n     * processor.\n     */\n    public void disconnect(CometdProducerConsumer prodcon) throws Exception {\n        CometdEndpoint endpoint = (CometdEndpoint) prodcon.getEndpoint();\n\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getUri().getHost() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef != null) {\n                if (connectorRef.decrement() == 0) {\n                    getServer().removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectors.remove(connectorKey);\n                }\n            }\n        }\n    }","id":47081,"modified_method":"/**\n     * Disconnects the URL specified on the endpoint from the specified\n     * processor.\n     */\n    public void disconnect(CometdProducerConsumer prodcon) throws Exception {\n        CometdEndpoint endpoint = prodcon.getEndpoint();\n\n        String connectorKey = endpoint.getProtocol() + \":\" + endpoint.getUri().getHost() + \":\" + endpoint.getPort();\n\n        synchronized (connectors) {\n            ConnectorRef connectorRef = connectors.get(connectorKey);\n            if (connectorRef != null) {\n                if (connectorRef.decrement() == 0) {\n                    getServer().removeConnector(connectorRef.connector);\n                    connectorRef.connector.stop();\n                    connectors.remove(connectorKey);\n                }\n            }\n        }\n    }","commit_id":"833f466746fc74a4110601f65fc3189f42b7ec88","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public CometdEndpoint(CometdComponent component, String uri, String remaining, Map parameters) {\n        super(uri);\n        this.component = component;\n        try {\n            this.uri = new URI(uri);\n        } catch (URISyntaxException e) {\n            e.printStackTrace();\n        }\n    }","id":47082,"modified_method":"public CometdEndpoint(CometdComponent component, String uri, String remaining, Map parameters) {\n        super(uri, component);\n        this.component = component;\n        try {\n            this.uri = new URI(uri);\n        } catch (URISyntaxException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }","commit_id":"833f466746fc74a4110601f65fc3189f42b7ec88","url":"https://github.com/apache/camel"},{"original_method":"public Producer createProducer() throws Exception {\n        CometdProducer producer = new CometdProducer(this);\n        return producer;\n    }","id":47083,"modified_method":"public Producer createProducer() throws Exception {\n        ObjectHelper.notNull(component, \"component\");\n        CometdProducer producer = new CometdProducer(this);\n        return producer;\n    }","commit_id":"833f466746fc74a4110601f65fc3189f42b7ec88","url":"https://github.com/apache/camel"},{"original_method":"public Consumer createConsumer(Processor processor) throws Exception {\n        CometdConsumer consumer =  new CometdConsumer(this, processor);\n        return consumer;\n    }","id":47084,"modified_method":"public Consumer createConsumer(Processor processor) throws Exception {\n        ObjectHelper.notNull(component, \"component\");\n        CometdConsumer consumer =  new CometdConsumer(this, processor);\n        return consumer;\n    }","commit_id":"833f466746fc74a4110601f65fc3189f42b7ec88","url":"https://github.com/apache/camel"},{"original_method":"public void process(final Exchange exchange) {\n        Collection<Client> clients = bayeux.getClients();\n        for (Iterator<Client> iterator = clients.iterator(); iterator.hasNext();) {\n            Client client = (Client) iterator.next();\n            client.deliver(client, endpoint.getPath(), exchange.getIn().getBody(), null);\n        }\n    }","id":47085,"modified_method":"public void process(final Exchange exchange) {\n        ObjectHelper.notNull(bayeux, \"bayeux\");\n\n        Collection<Client> clients = bayeux.getClients();\n        for (Client client : clients) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Delivering to client id: \" + client.getId() + \" path:\" + endpoint.getPath() + \" exchange: \" + exchange);\n            }\n            client.deliver(client, endpoint.getPath(), exchange.getIn().getBody(), null);\n        }\n    }","commit_id":"833f466746fc74a4110601f65fc3189f42b7ec88","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void process(Exchange exchange) throws Exception {\n        @SuppressWarnings(\"unchecked\")\n        T endpoint = (T) getEndpoint();\n        Message in = exchange.getIn();\n        String defaultMetricsName = endpoint.getMetricsName();\n        String finalMetricsName = getMetricsName(in, defaultMetricsName);\n        MetricRegistry registry = endpoint.getRegistry();\n        try {\n            doProcess(exchange, endpoint, registry, finalMetricsName);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to produce metrics for {} in {} - {}\", new Object[] {\n                finalMetricsName, getClass().getSimpleName(), e.getMessage() });\n        }\n        clearMetricsHeaders(in);\n    }","id":47086,"modified_method":"@Override\n    public void process(Exchange exchange) throws Exception {\n        Message in = exchange.getIn();\n        String defaultMetricsName = getEndpoint().getMetricsName();\n        String finalMetricsName = getMetricsName(in, defaultMetricsName);\n        MetricRegistry registry = getEndpoint().getRegistry();\n\n        try {\n            doProcess(exchange, getEndpoint(), registry, finalMetricsName);\n        } catch (Exception e) {\n            exchange.setException(e);\n        } finally {\n            clearMetricsHeaders(in);\n        }\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"protected abstract void doProcess(Exchange exchange, T endpoint, MetricRegistry registry, String metricsName) throws Exception;","id":47087,"modified_method":"protected abstract void doProcess(Exchange exchange, MetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception;","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"public AbstractMetricsProducer(T endpoint) {\n        super(endpoint);\n    }","id":47088,"modified_method":"public AbstractMetricsProducer(MetricsEndpoint endpoint) {\n        super(endpoint);\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        okProducer = new AbstractMetricsProducer<AbstractMetricsEndpoint>(endpoint) {\n            @Override\n            protected void doProcess(Exchange exchange, AbstractMetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception {\n            }\n        };\n        failProducer = new AbstractMetricsProducer<AbstractMetricsEndpoint>(endpoint) {\n\n            @Override\n            protected void doProcess(Exchange exchange, AbstractMetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception {\n                throw new Exception(\"Muchos problemos\");\n            }\n        };\n        inOrder = Mockito.inOrder(endpoint, exchange, in, registry);\n        when(exchange.getIn()).thenReturn(in);\n        when(endpoint.getMetricsName()).thenReturn(METRIC_NAME);\n        when(endpoint.getRegistry()).thenReturn(registry);\n    }","id":47089,"modified_method":"@Before\n    public void setUp() throws Exception {\n        okProducer = new AbstractMetricsProducer(endpoint) {\n            @Override\n            protected void doProcess(Exchange exchange, MetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception {\n            }\n        };\n        failProducer = new AbstractMetricsProducer(endpoint) {\n\n            @Override\n            protected void doProcess(Exchange exchange, MetricsEndpoint endpoint, MetricRegistry registry, String metricsName) throws Exception {\n                throw new Exception(\"Muchos problemos\");\n            }\n        };\n        inOrder = Mockito.inOrder(endpoint, exchange, in, registry);\n        when(exchange.getIn()).thenReturn(in);\n        when(endpoint.getMetricsName()).thenReturn(METRIC_NAME);\n        when(endpoint.getRegistry()).thenReturn(registry);\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        if (metricRegistry == null) {\n            Registry camelRegistry = getCamelContext().getRegistry();\n            metricRegistry = getOrCreateMetricRegistry(camelRegistry, METRIC_REGISTRY_NAME);\n        }\n        String metricsName = getMetricsName(remaining);\n        MetricsType metricsType = getMetricsType(remaining);\n        LOG.info(\"Metrics type: {}; name: {}\", metricsType, metricsName);\n        Endpoint endpoint = createNewEndpoint(metricRegistry, metricsType, metricsName);\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","id":47090,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        if (metricRegistry == null) {\n            Registry camelRegistry = getCamelContext().getRegistry();\n            metricRegistry = getOrCreateMetricRegistry(camelRegistry, METRIC_REGISTRY_NAME);\n        }\n        String metricsName = getMetricsName(remaining);\n        MetricsType metricsType = getMetricsType(remaining);\n\n        LOG.debug(\"Metrics type: {}; name: {}\", metricsType, metricsName);\n        Endpoint endpoint = new MetricsEndpoint(uri, this, metricRegistry, metricsType, metricsName);\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCreateNewEndpointForTimer() throws Exception {\n        Endpoint endpoint = component.createNewEndpoint(metricRegistry, MetricsType.TIMER, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(TimerEndpoint.class)));\n    }","id":47091,"modified_method":"@Test\n    public void testCreateNewEndpointForTimer() throws Exception {\n        Endpoint endpoint = new MetricsEndpoint(null, null, metricRegistry, MetricsType.TIMER, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(MetricsEndpoint.class)));\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCreateNewEndpointForMeter() throws Exception {\n        Endpoint endpoint = component.createNewEndpoint(metricRegistry, MetricsType.METER, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(MeterEndpoint.class)));\n    }","id":47092,"modified_method":"@Test\n    public void testCreateNewEndpointForMeter() throws Exception {\n        Endpoint endpoint = new MetricsEndpoint(null, null, metricRegistry, MetricsType.METER, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(MetricsEndpoint.class)));\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCreateNewEndpointForHistogram() throws Exception {\n        Endpoint endpoint = component.createNewEndpoint(metricRegistry, MetricsType.HISTOGRAM, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(HistogramEndpoint.class)));\n    }","id":47093,"modified_method":"@Test\n    public void testCreateNewEndpointForHistogram() throws Exception {\n        Endpoint endpoint = new MetricsEndpoint(null, null, metricRegistry, MetricsType.HISTOGRAM, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(MetricsEndpoint.class)));\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test(expected = RuntimeCamelException.class)\n    public void testCreateNewEndpointForGauge() throws Exception {\n        component.createNewEndpoint(metricRegistry, MetricsType.GAUGE, \"a name\");\n    }","id":47094,"modified_method":"@Test(expected = IllegalArgumentException.class)\n    public void testCreateNewEndpointForGauge() throws Exception {\n        MetricsEndpoint endpoint = new MetricsEndpoint(null, null, metricRegistry, MetricsType.GAUGE, \"a name\");\n        endpoint.createProducer();\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCreateEndpoints() throws Exception {\n        component.setCamelContext(camelContext);\n        when(camelContext.getRegistry()).thenReturn(camelRegistry);\n        when(camelRegistry.lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class)).thenReturn(metricRegistry);\n        Map<String, Object> params = new HashMap<String, Object>();\n        Long value = System.currentTimeMillis();\n        params.put(\"mark\", value);\n        Endpoint result = component.createEndpoint(\"metrics:meter:long.meter\", \"meter:long.meter\", params);\n        assertThat(result, is(notNullValue()));\n        assertThat(result, is(instanceOf(MeterEndpoint.class)));\n        MeterEndpoint me = (MeterEndpoint) result;\n        assertThat(me.getMark(), is(value));\n        assertThat(me.getMetricsName(), is(\"long.meter\"));\n        assertThat(me.getRegistry(), is(metricRegistry));\n\n        params = new HashMap<String, Object>();\n        params.put(\"increment\", value + 1);\n        params.put(\"decrement\", value - 1);\n\n        result = component.createEndpoint(\"metrics:counter:long.counter\", \"counter:long.counter\", params);\n        assertThat(result, is(notNullValue()));\n        assertThat(result, is(instanceOf(CounterEndpoint.class)));\n        CounterEndpoint ce = (CounterEndpoint) result;\n        assertThat(ce.getIncrement(), is(value + 1));\n        assertThat(ce.getDecrement(), is(value - 1));\n        assertThat(ce.getMetricsName(), is(\"long.counter\"));\n        assertThat(ce.getRegistry(), is(metricRegistry));\n\n        inOrder.verify(camelContext, times(1)).getRegistry();\n        inOrder.verify(camelRegistry, times(1)).lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class);\n        inOrder.verify(camelContext, times(2)).getTypeConverter();\n        inOrder.verifyNoMoreInteractions();\n    }","id":47095,"modified_method":"@Test\n    public void testCreateEndpoints() throws Exception {\n        component.setCamelContext(camelContext);\n        when(camelContext.getRegistry()).thenReturn(camelRegistry);\n        when(camelRegistry.lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class)).thenReturn(metricRegistry);\n        Map<String, Object> params = new HashMap<String, Object>();\n        Long value = System.currentTimeMillis();\n        params.put(\"mark\", value);\n        Endpoint result = component.createEndpoint(\"metrics:meter:long.meter\", \"meter:long.meter\", params);\n        assertThat(result, is(notNullValue()));\n        assertThat(result, is(instanceOf(MetricsEndpoint.class)));\n        MetricsEndpoint me = (MetricsEndpoint) result;\n        assertThat(me.getMark(), is(value));\n        assertThat(me.getMetricsName(), is(\"long.meter\"));\n        assertThat(me.getRegistry(), is(metricRegistry));\n\n        params = new HashMap<String, Object>();\n        params.put(\"increment\", value + 1);\n        params.put(\"decrement\", value - 1);\n\n        result = component.createEndpoint(\"metrics:counter:long.counter\", \"counter:long.counter\", params);\n        assertThat(result, is(notNullValue()));\n        assertThat(result, is(instanceOf(MetricsEndpoint.class)));\n        MetricsEndpoint ce = (MetricsEndpoint) result;\n        assertThat(ce.getIncrement(), is(value + 1));\n        assertThat(ce.getDecrement(), is(value - 1));\n        assertThat(ce.getMetricsName(), is(\"long.counter\"));\n        assertThat(ce.getRegistry(), is(metricRegistry));\n\n        inOrder.verify(camelContext, times(1)).getRegistry();\n        inOrder.verify(camelRegistry, times(1)).lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class);\n        inOrder.verify(camelContext, times(2)).getTypeConverter();\n        inOrder.verifyNoMoreInteractions();\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCreateNewEndpointForCounter() throws Exception {\n        Endpoint endpoint = component.createNewEndpoint(metricRegistry, MetricsType.COUNTER, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(CounterEndpoint.class)));\n    }","id":47096,"modified_method":"@Test\n    public void testCreateNewEndpointForCounter() throws Exception {\n        Endpoint endpoint = new MetricsEndpoint(null, null, metricRegistry, MetricsType.COUNTER, \"a name\");\n        assertThat(endpoint, is(notNullValue()));\n        assertThat(endpoint, is(instanceOf(MetricsEndpoint.class)));\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCreateEndpoint() throws Exception {\n        component.setCamelContext(camelContext);\n        when(camelContext.getRegistry()).thenReturn(camelRegistry);\n        when(camelRegistry.lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class)).thenReturn(metricRegistry);\n        Map<String, Object> params = new HashMap<String, Object>();\n        Long value = System.currentTimeMillis();\n        params.put(\"mark\", value);\n        Endpoint result = component.createEndpoint(\"metrics:meter:long.meter\", \"meter:long.meter\", params);\n        assertThat(result, is(notNullValue()));\n        assertThat(result, is(instanceOf(MeterEndpoint.class)));\n        MeterEndpoint me = (MeterEndpoint) result;\n        assertThat(me.getMark(), is(value));\n        assertThat(me.getMetricsName(), is(\"long.meter\"));\n        assertThat(me.getRegistry(), is(metricRegistry));\n        inOrder.verify(camelContext, times(1)).getRegistry();\n        inOrder.verify(camelRegistry, times(1)).lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class);\n        inOrder.verify(camelContext, times(1)).getTypeConverter();\n        inOrder.verifyNoMoreInteractions();\n    }","id":47097,"modified_method":"@Test\n    public void testCreateEndpoint() throws Exception {\n        component.setCamelContext(camelContext);\n        when(camelContext.getRegistry()).thenReturn(camelRegistry);\n        when(camelRegistry.lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class)).thenReturn(metricRegistry);\n        Map<String, Object> params = new HashMap<String, Object>();\n        Long value = System.currentTimeMillis();\n        params.put(\"mark\", value);\n        Endpoint result = component.createEndpoint(\"metrics:meter:long.meter\", \"meter:long.meter\", params);\n        assertThat(result, is(notNullValue()));\n        assertThat(result, is(instanceOf(MetricsEndpoint.class)));\n        MetricsEndpoint me = (MetricsEndpoint) result;\n        assertThat(me.getMark(), is(value));\n        assertThat(me.getMetricsName(), is(\"long.meter\"));\n        assertThat(me.getRegistry(), is(metricRegistry));\n        inOrder.verify(camelContext, times(1)).getRegistry();\n        inOrder.verify(camelRegistry, times(1)).lookupByNameAndType(MetricsComponent.METRIC_REGISTRY_NAME, MetricRegistry.class);\n        inOrder.verify(camelContext, times(1)).getTypeConverter();\n        inOrder.verifyNoMoreInteractions();\n    }","commit_id":"4a84f061f74f759e77d45c369a95b704f38c1a92","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the user from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getUser(Exchange exchange) {\n        String user = ((JcloudsComputeEndpoint) getEndpoint()).getUser();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.USER) != null) {\n            user = (String) exchange.getIn().getHeader(JcloudsConstants.USER);\n        }\n        return user;\n    }","id":47098,"modified_method":"/**\n     * Retrieves the user from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getUser(Exchange exchange) {\n        String user = getEndpoint().getUser();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.USER) != null) {\n            user = (String) exchange.getIn().getHeader(JcloudsConstants.USER);\n        }\n        return user;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the node state from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    public NodeState getNodeState(Exchange exchange) {\n        NodeState nodeState = null;\n        String state = ((JcloudsComputeEndpoint) getEndpoint()).getNodeState();\n        if (state != null) {\n            nodeState = NodeState.valueOf(state);\n        }\n\n        if (exchange.getIn().getHeader(JcloudsConstants.NODE_STATE) != null) {\n            Object stateHeader = exchange.getIn().getHeader(JcloudsConstants.NODE_STATE);\n            if (stateHeader == null) {\n                nodeState = null;\n            } else if (stateHeader instanceof NodeState) {\n                nodeState = (NodeState) stateHeader;\n            } else {\n                nodeState = NodeState.valueOf(String.valueOf(stateHeader));\n            }\n        }\n        return nodeState;\n    }","id":47099,"modified_method":"/**\n     * Retrieves the node state from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    public NodeState getNodeState(Exchange exchange) {\n        NodeState nodeState = null;\n        String state = getEndpoint().getNodeState();\n        if (state != null) {\n            nodeState = NodeState.valueOf(state);\n        }\n\n        if (exchange.getIn().getHeader(JcloudsConstants.NODE_STATE) != null) {\n            Object stateHeader = exchange.getIn().getHeader(JcloudsConstants.NODE_STATE);\n            if (stateHeader == null) {\n                nodeState = null;\n            } else if (stateHeader instanceof NodeState) {\n                nodeState = (NodeState) stateHeader;\n            } else {\n                nodeState = NodeState.valueOf(String.valueOf(stateHeader));\n            }\n        }\n        return nodeState;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the location id from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getLocationId(Exchange exchange) {\n        String locationId = ((JcloudsComputeEndpoint) getEndpoint()).getLocationId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID) != null) {\n            locationId = (String) exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID);\n        }\n        return locationId;\n    }","id":47100,"modified_method":"/**\n     * Retrieves the location id from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getLocationId(Exchange exchange) {\n        String locationId = getEndpoint().getLocationId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID) != null) {\n            locationId = (String) exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID);\n        }\n        return locationId;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Runs a script on the target node.\n     *\n     * @param exchange\n     * @throws CamelException\n     */\n    protected void runScriptOnNode(Exchange exchange) throws CamelException {\n        String script = exchange.getIn().getBody(String.class);\n        String nodeId = getNodeId(exchange);\n        String user = getUser(exchange);\n\n        Credentials credentials = null;\n\n        if (user != null) {\n            credentials = new Credentials(user, null);\n        }\n        ExecResponse execResponse = null;\n\n        if (credentials == null) {\n            execResponse = computeService.runScriptOnNode(nodeId, script);\n        } else {\n            execResponse = computeService.runScriptOnNode(nodeId, script, RunScriptOptions.Builder.overrideCredentialsWith(credentials).runAsRoot(false));\n        }\n\n        if (execResponse == null) {\n            throw new CamelException(\"Failed to receive response for run script operation.\");\n        }\n\n        exchange.setProperty(JcloudsConstants.RUN_SCRIPT_ERROR, execResponse.getError());\n        exchange.setProperty(JcloudsConstants.RUN_SCRIPT_EXIT_CODE, execResponse.getExitCode());\n        if (execResponse != null) {\n            exchange.getOut().setBody(execResponse.getOutput());\n        }\n    }","id":47101,"modified_method":"/**\n     * Runs a script on the target node.\n     *\n     * @param exchange\n     * @throws CamelException\n     */\n    protected void runScriptOnNode(Exchange exchange) throws CamelException {\n        String script = exchange.getIn().getBody(String.class);\n        String nodeId = getNodeId(exchange);\n        String user = getUser(exchange);\n\n        LoginCredentials credentials = null;\n\n        if (user != null) {\n            credentials = LoginCredentials.builder().user(user).build();\n        }\n        ExecResponse execResponse = null;\n\n        if (credentials == null) {\n            execResponse = computeService.runScriptOnNode(nodeId, script);\n        } else {\n            execResponse = computeService.runScriptOnNode(nodeId, script, RunScriptOptions.Builder.overrideLoginCredentials(credentials).runAsRoot(false));\n        }\n\n        if (execResponse == null) {\n            throw new CamelException(\"Failed to receive response for run script operation.\");\n        }\n\n        exchange.setProperty(JcloudsConstants.RUN_SCRIPT_ERROR, execResponse.getError());\n        exchange.setProperty(JcloudsConstants.RUN_SCRIPT_EXIT_CODE, execResponse.getExitCode());\n        exchange.getOut().setBody(execResponse.getOutput());\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the group from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getGroup(Exchange exchange) {\n        String group = ((JcloudsComputeEndpoint) getEndpoint()).getGroup();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.GROUP) != null) {\n            group = (String) exchange.getIn().getHeader(JcloudsConstants.GROUP);\n        }\n        return group;\n    }","id":47102,"modified_method":"/**\n     * Retrieves the group from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getGroup(Exchange exchange) {\n        String group = getEndpoint().getGroup();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.GROUP) != null) {\n            group = (String) exchange.getIn().getHeader(JcloudsConstants.GROUP);\n        }\n        return group;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the node id from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getNodeId(Exchange exchange) {\n        String nodeId = ((JcloudsComputeEndpoint) getEndpoint()).getNodeId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.NODE_ID) != null) {\n            nodeId = (String) exchange.getIn().getHeader(JcloudsConstants.NODE_ID);\n        }\n        return nodeId;\n    }","id":47103,"modified_method":"/**\n     * Retrieves the node id from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getNodeId(Exchange exchange) {\n        String nodeId = getEndpoint().getNodeId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.NODE_ID) != null) {\n            nodeId = (String) exchange.getIn().getHeader(JcloudsConstants.NODE_ID);\n        }\n        return nodeId;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void process(Exchange exchange) throws Exception {\n        String operation = getOperation(exchange);\n\n        if (operation == null) {\n            throw new CamelException(\"Operation must be specified in the endpoitn URI or as a property on the exchange.\");\n        }\n\n        if (JcloudsConstants.LIST_NODES.equals(operation)) {\n            listNodes(exchange);\n\n        } else if (JcloudsConstants.LIST_IMAGES.equals(operation)) {\n            listImages(exchange);\n\n        } else if (JcloudsConstants.LIST_HARDWARE.equals(operation)) {\n            listHardware(exchange);\n\n        } else if (JcloudsConstants.RUN_SCRIPT.equals(operation)) {\n            runScriptOnNode(exchange);\n\n        } else if (JcloudsConstants.CREATE_NODE.equals(operation)) {\n            createNode(exchange);\n\n        } else if (JcloudsConstants.DESTROY_NODE.equals(operation)) {\n            destroyNode(exchange);\n        } else {\n\n        }\n    }","id":47104,"modified_method":"@Override\n    public void process(Exchange exchange) throws Exception {\n        String operation = getOperation(exchange);\n\n        if (operation == null) {\n            throw new CamelException(\"Operation must be specified in the endpoitn URI or as a property on the exchange.\");\n        }\n\n        if (JcloudsConstants.LIST_NODES.equals(operation)) {\n            listNodes(exchange);\n        } else if (JcloudsConstants.LIST_IMAGES.equals(operation)) {\n            listImages(exchange);\n        } else if (JcloudsConstants.LIST_HARDWARE.equals(operation)) {\n            listHardware(exchange);\n        } else if (JcloudsConstants.RUN_SCRIPT.equals(operation)) {\n            runScriptOnNode(exchange);\n        } else if (JcloudsConstants.CREATE_NODE.equals(operation)) {\n            createNode(exchange);\n        } else if (JcloudsConstants.DESTROY_NODE.equals(operation)) {\n            destroyNode(exchange);\n        }\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the hardware id from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getHardwareId(Exchange exchange) {\n        String hardwareId = ((JcloudsComputeEndpoint) getEndpoint()).getHardwareId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID) != null) {\n            hardwareId = (String) exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID);\n        }\n        return hardwareId;\n    }","id":47105,"modified_method":"/**\n     * Retrieves the hardware id from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getHardwareId(Exchange exchange) {\n        String hardwareId = getEndpoint().getHardwareId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID) != null) {\n            hardwareId = (String) exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID);\n        }\n        return hardwareId;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the operation from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    public String getOperation(Exchange exchange) {\n        String operation = ((JcloudsComputeEndpoint) getEndpoint()).getOperation();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.OPERATION) != null) {\n            operation = (String) exchange.getIn().getHeader(JcloudsConstants.OPERATION);\n        }\n        return operation;\n    }","id":47106,"modified_method":"/**\n     * Retrieves the operation from the URI or from the exchange headers. The header will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    public String getOperation(Exchange exchange) {\n        String operation = getEndpoint().getOperation();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.OPERATION) != null) {\n            operation = (String) exchange.getIn().getHeader(JcloudsConstants.OPERATION);\n        }\n        return operation;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the image id from the URI or from the exchange properties. The property will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getImageId(Exchange exchange) {\n        String imageId = ((JcloudsComputeEndpoint) getEndpoint()).getImageId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID) != null) {\n            imageId = (String) exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID);\n        }\n        return imageId;\n    }","id":47107,"modified_method":"/**\n     * Retrieves the image id from the URI or from the exchange properties. The property will take precedence over the URI.\n     *\n     * @param exchange\n     * @return\n     */\n    protected String getImageId(Exchange exchange) {\n        String imageId = getEndpoint().getImageId();\n\n        if (exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID) != null) {\n            imageId = (String) exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID);\n        }\n        return imageId;\n    }","commit_id":"4be829af1b32f06fdeb9e76afcfb9eeadd3eedcc","url":"https://github.com/apache/camel"},{"original_method":"void processExchange(Exchange exchange) throws Exception {\n        getProcessor().process(exchange);\n    }","id":47108,"modified_method":"void processExchange(Exchange exchange) {\n        try {\n            getProcessor().process(exchange);\n        } catch (Throwable e) {\n            exchange.setException(e);\n        }\n\n        if (exchange.getException() != null) {\n            getExceptionHandler().handleException(\"Error processing exchange.\", exchange, exchange.getException());\n        }\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"protected void doStop() throws Exception {\n        ((MQTTEndpoint) getEndpoint()).removeConsumer(this);\n        super.doStop();\n    }","id":47109,"modified_method":"protected void doStop() throws Exception {\n        getEndpoint().removeConsumer(this);\n        super.doStop();\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"protected void doStart() throws Exception {\n        ((MQTTEndpoint) getEndpoint()).addConsumer(this);\n        super.doStart();\n    }","id":47110,"modified_method":"protected void doStart() throws Exception {\n        getEndpoint().addConsumer(this);\n        super.doStart();\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"void publish(String topic, byte[] payload, QoS qoS, boolean retain) throws Exception {\n        connection.publish(topic, payload, qoS, retain, null);\n    }","id":47111,"modified_method":"void publish(String topic, byte[] payload, QoS qoS, boolean retain, Callback<Void> callback) throws Exception {\n        connection.publish(topic, payload, qoS, retain, callback);\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Consumer createConsumer(Processor processor) throws Exception {\n        MQTTConsumer consumer = new MQTTConsumer(this, processor);\n        return consumer;\n    }","id":47112,"modified_method":"@Override\n    public Consumer createConsumer(Processor processor) throws Exception {\n        return new MQTTConsumer(this, processor);\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"public boolean isSingleton() {\n        return false;\n    }","id":47113,"modified_method":"public boolean isSingleton() {\n        return true;\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Producer createProducer() throws Exception {\n        MQTTProducer producer = new MQTTProducer(this);\n        return producer;\n    }","id":47114,"modified_method":"@Override\n    public Producer createProducer() throws Exception {\n        return new MQTTProducer(this);\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        connection = configuration.callbackConnection();\n\n        connection.listener(new Listener() {\n            public void onConnected() {\n                LOG.info(\"MQTT Endpoint Connected to \" + configuration.getHost());\n            }\n\n            public void onDisconnected() {\n                LOG.debug(\"MQTT Connection disconnected\");\n            }\n\n            public void onPublish(UTF8Buffer topic, Buffer body, Runnable ack) {\n\n                if (!consumers.isEmpty()) {\n                    Exchange exchange = createExchange();\n                    exchange.getIn().setBody(body.toByteArray());\n                    exchange.setProperty(configuration.getMqttTopicPropertyName(), topic.toString());\n                    for (MQTTConsumer consumer : consumers) {\n                        try {\n                            consumer.processExchange(exchange);\n                        } catch (Exception e) {\n                            LOG.error(\"Failed to process exchange \", exchange);\n                        }\n                    }\n                }\n                if (ack != null) {\n                    ack.run();\n                }\n\n            }\n\n            public void onFailure(Throwable value) {\n                connection.disconnect(new Callback<Void>() {\n                    public void onSuccess(Void value) {\n                    }\n\n                    public void onFailure(Throwable value) {\n                        LOG.debug(\"Failed to disconnect from \" + configuration.getHost());\n                    }\n                });\n            }\n        });\n        final Promise<Object> promise = new Promise<Object>();\n        connection.connect(new Callback<Void>() {\n            public void onSuccess(Void value) {\n                String subscribeTopicName = configuration.getSubscribeTopicName();\n                subscribeTopicName = subscribeTopicName != null ? subscribeTopicName.trim() : null;\n\n                if (subscribeTopicName != null && !subscribeTopicName.isEmpty()) {\n                    Topic[] topics = {new Topic(subscribeTopicName, configuration.getQoS())};\n                    connection.subscribe(topics, new Callback<byte[]>() {\n                        public void onSuccess(byte[] value) {\n                            promise.onSuccess(value);\n                        }\n\n                        public void onFailure(Throwable value) {\n                            promise.onFailure(value);\n                            connection.disconnect(null);\n                        }\n                    });\n                } else {\n                    promise.onSuccess(value);\n                }\n\n            }\n\n            public void onFailure(Throwable value) {\n                promise.onFailure(value);\n                connection.disconnect(null);\n            }\n        });\n        promise.await(configuration.getConnectWaitInSeconds(), TimeUnit.SECONDS);\n    }","id":47115,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        connection = configuration.callbackConnection();\n\n        connection.listener(new Listener() {\n            public void onConnected() {\n                LOG.info(\"MQTT Connection connected to {}\", configuration.getHost());\n            }\n\n            public void onDisconnected() {\n                LOG.debug(\"MQTT Connection disconnected from {}\", configuration.getHost());\n            }\n\n            public void onPublish(UTF8Buffer topic, Buffer body, Runnable ack) {\n                if (!consumers.isEmpty()) {\n                    Exchange exchange = createExchange();\n                    exchange.getIn().setBody(body.toByteArray());\n                    exchange.setProperty(configuration.getMqttTopicPropertyName(), topic.toString());\n                    for (MQTTConsumer consumer : consumers) {\n                        consumer.processExchange(exchange);\n                    }\n                }\n                if (ack != null) {\n                    ack.run();\n                }\n            }\n\n            public void onFailure(Throwable value) {\n                connection.disconnect(new Callback<Void>() {\n                    public void onSuccess(Void value) {\n                    }\n\n                    public void onFailure(Throwable e) {\n                        LOG.debug(\"Failed to disconnect from \" + configuration.getHost() + \". This exception is ignored.\", e);\n                    }\n                });\n            }\n        });\n\n        final Promise<Object> promise = new Promise<Object>();\n        connection.connect(new Callback<Void>() {\n            public void onSuccess(Void value) {\n                String subscribeTopicName = configuration.getSubscribeTopicName();\n                subscribeTopicName = subscribeTopicName != null ? subscribeTopicName.trim() : null;\n\n                if (subscribeTopicName != null && !subscribeTopicName.isEmpty()) {\n                    Topic[] topics = {new Topic(subscribeTopicName, configuration.getQoS())};\n                    connection.subscribe(topics, new Callback<byte[]>() {\n                        public void onSuccess(byte[] value) {\n                            promise.onSuccess(value);\n                        }\n\n                        public void onFailure(Throwable value) {\n                            promise.onFailure(value);\n                            connection.disconnect(null);\n                        }\n                    });\n                } else {\n                    promise.onSuccess(value);\n                }\n\n            }\n\n            public void onFailure(Throwable value) {\n                promise.onFailure(value);\n                connection.disconnect(null);\n            }\n        });\n        promise.await(configuration.getConnectWaitInSeconds(), TimeUnit.SECONDS);\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public boolean process(Exchange exchange, AsyncCallback asyncCallback) {\n        try {\n            doProcess(exchange);\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n        asyncCallback.done(true);\n        return true;\n    }","id":47116,"modified_method":"@Override\n    public boolean process(final Exchange exchange, final AsyncCallback callback) {\n        byte[] body = exchange.getIn().getBody(byte[].class);\n        if (body != null) {\n            MQTTConfiguration configuration = mqttEndpoint.getConfiguration();\n            boolean retain = exchange.getProperty(configuration.getMqttRetainPropertyName(), configuration.isByDefaultRetain(), Boolean.class);\n\n            QoS qoS = configuration.getQoS();\n            Object qoSValue = exchange.getProperty(configuration.getMqttQosPropertyName());\n            if (qoSValue != null) {\n                qoS = MQTTConfiguration.getQoS(qoSValue.toString());\n            }\n\n            // where should we publish to\n            String topicName = configuration.getPublishTopicName();\n            Object topicValue = exchange.getProperty(configuration.getMqttTopicPropertyName());\n            if (topicValue != null) {\n                topicName = topicValue.toString();\n            }\n            final String name = topicName;\n\n            try {\n                log.debug(\"Publishing to {}\", name);\n                mqttEndpoint.publish(name, body, qoS, retain, new Callback<Void>() {\n                    @Override\n                    public void onSuccess(Void aVoid) {\n                        log.trace(\"onSuccess from {}\", name);\n                        callback.done(false);\n                    }\n\n                    @Override\n                    public void onFailure(Throwable throwable) {\n                        log.trace(\"onFailure from {}\", name);\n                        exchange.setException(throwable);\n                        callback.done(false);\n                    }\n                });\n            } catch (Exception e) {\n                exchange.setException(e);\n                callback.done(true);\n                return true;\n            }\n\n            // we continue async, as the mqtt endpoint will invoke the callback when its done\n            return false;\n        } else {\n            // no data to send so we are done\n            log.trace(\"No data to publish\");\n            callback.done(true);\n            return true;\n        }\n    }","commit_id":"7c9b538c1fa25cb8bc147fc9be69f0b4573f4d8c","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Poll for files\n     */\n    protected void poll() throws Exception {\n        // must reset for each poll\n        fileExpressionResult = null;\n        shutdownRunningTask = null;\n        pendingExchanges = 0;\n\n        // before we poll is there anything we need to check ? Such as are we\n        // connected to the FTP Server Still ?\n        if (!prePollCheck()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Skipping pool as pre poll check returned false\");\n            }\n        }\n\n        // gather list of files to process\n        List<GenericFile<T>> files = new ArrayList<GenericFile<T>>();\n\n        String name = endpoint.getConfiguration().getDirectory();\n        pollDirectory(name, files);\n\n        // sort files using file comparator if provided\n        if (endpoint.getSorter() != null) {\n            Collections.sort(files, endpoint.getSorter());\n        }\n\n        // sort using build in sorters so we can use expressions\n        LinkedList<Exchange> exchanges = new LinkedList<Exchange>();\n        for (GenericFile<T> file : files) {\n            Exchange exchange = endpoint.createExchange(file);\n            endpoint.configureMessage(file, exchange.getIn());\n            exchanges.add(exchange);\n        }\n        // sort files using exchange comparator if provided\n        if (endpoint.getSortBy() != null) {\n            Collections.sort(exchanges, endpoint.getSortBy());\n        }\n\n        // consume files one by one\n        int total = exchanges.size();\n        if (total > 0 && log.isDebugEnabled()) {\n            log.debug(\"Total \" + total + \" files to consume\");\n        }\n\n        Queue<Exchange> q = exchanges;\n        processBatch(CastUtils.cast(q));\n    }","id":47117,"modified_method":"/**\n     * Poll for files\n     */\n    protected void poll() throws Exception {\n        // must reset for each poll\n        fileExpressionResult = null;\n        shutdownRunningTask = null;\n        pendingExchanges = 0;\n\n        // before we poll is there anything we need to check ? Such as are we\n        // connected to the FTP Server Still ?\n        if (!prePollCheck()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Skipping pool as pre poll check returned false\");\n            }\n        }\n\n        // gather list of files to process\n        List<GenericFile<T>> files = new ArrayList<GenericFile<T>>();\n\n        String name = endpoint.getConfiguration().getDirectory();\n        pollDirectory(name, files);\n\n        // sort files using file comparator if provided\n        if (endpoint.getSorter() != null) {\n            Collections.sort(files, endpoint.getSorter());\n        }\n\n        // sort using build in sorters so we can use expressions\n        LinkedList<Exchange> exchanges = new LinkedList<Exchange>();\n        for (GenericFile<T> file : files) {\n            Exchange exchange = endpoint.createExchange(file);\n            endpoint.configureMessage(file, exchange.getIn());\n            exchanges.add(exchange);\n        }\n        // sort files using exchange comparator if provided\n        if (endpoint.getSortBy() != null) {\n            Collections.sort(exchanges, endpoint.getSortBy());\n        }\n\n        // consume files one by one\n        int total = exchanges.size();\n        if (total > 0 && log.isDebugEnabled()) {\n            log.debug(\"Total \" + total + \" files to consume\");\n        }\n\n        Queue<Exchange> q = exchanges;\n        processBatch(CastUtils.cast(q));\n\n        postPollCheck();\n    }","commit_id":"665325e4ea6ce09d084e64cf72bafabc7cc3d066","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Perform the work to process the fileExchange\n     *\n     * @param exchange fileExchange\n     * @throws Exception is thrown if some error\n     */\n    protected void processExchange(Exchange exchange) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Processing \" + exchange);\n        }\n\n        try {\n            String target = createFileName(exchange);\n\n            preWriteCheck();\n\n            // should we write to a temporary name and then afterwards rename to real target\n            boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());\n            String tempTarget = null;\n            if (writeAsTempAndRename) {\n                // compute temporary name with the temp prefix\n                tempTarget = createTempFileName(exchange, target);\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Writing using tempNameFile: \" + tempTarget);\n                }\n\n                // cater for file exists option on the real target as\n                // the file operations code will work on the temp file\n\n                // if an existing file already exists what should we do?\n                if (operations.existsFile(target)) {\n                    if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                        // ignore but indicate that the file was written\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"An existing file already exists: \" + target + \". Ignore and do not override it.\");\n                        }\n                        return;\n                    } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                        throw new GenericFileOperationFailedException(\"File already exist: \" + target + \". Cannot write new file.\");\n                    } else if (endpoint.getFileExist() == GenericFileExist.Override) {\n                        // we override the target so we do this by deleting it so the temp file can be renamed later\n                        // with success as the existing target file have been deleted\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Deleting existing file: \" + tempTarget);\n                        }\n                        if (!operations.deleteFile(target)) {\n                            throw new GenericFileOperationFailedException(\"Cannot delete file: \" + target);\n                        }\n\n                    }\n                }\n\n                // delete any pre existing temp file\n                if (operations.existsFile(tempTarget)) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Deleting existing temp file: \" + tempTarget);\n                    }\n                    if (!operations.deleteFile(tempTarget)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete file: \" + tempTarget);\n                    }\n                }\n            }\n\n            // write/upload the file\n            writeFile(exchange, tempTarget != null ? tempTarget : target);\n\n            // if we did write to a temporary name then rename it to the real\n            // name after we have written the file\n            if (tempTarget != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Renaming file: [\" + tempTarget + \"] to: [\" + target + \"]\");\n                }\n                boolean renamed = operations.renameFile(tempTarget, target);\n                if (!renamed) {\n                    throw new GenericFileOperationFailedException(\"Cannot rename file from: \" + tempTarget + \" to: \" + target);\n                }\n            }\n\n            // lets store the name we really used in the header, so end-users\n            // can retrieve it\n            exchange.getIn().setHeader(Exchange.FILE_NAME_PRODUCED, target);\n        } catch (Exception e) {\n            handleFailedWrite(exchange, e);\n        }\n    }","id":47118,"modified_method":"/**\n     * Perform the work to process the fileExchange\n     *\n     * @param exchange fileExchange\n     * @throws Exception is thrown if some error\n     */\n    protected void processExchange(Exchange exchange) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Processing \" + exchange);\n        }\n\n        try {\n            String target = createFileName(exchange);\n\n            preWriteCheck();\n\n            // should we write to a temporary name and then afterwards rename to real target\n            boolean writeAsTempAndRename = ObjectHelper.isNotEmpty(endpoint.getTempFileName());\n            String tempTarget = null;\n            if (writeAsTempAndRename) {\n                // compute temporary name with the temp prefix\n                tempTarget = createTempFileName(exchange, target);\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Writing using tempNameFile: \" + tempTarget);\n                }\n\n                // cater for file exists option on the real target as\n                // the file operations code will work on the temp file\n\n                // if an existing file already exists what should we do?\n                if (operations.existsFile(target)) {\n                    if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                        // ignore but indicate that the file was written\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"An existing file already exists: \" + target + \". Ignore and do not override it.\");\n                        }\n                        return;\n                    } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                        throw new GenericFileOperationFailedException(\"File already exist: \" + target + \". Cannot write new file.\");\n                    } else if (endpoint.getFileExist() == GenericFileExist.Override) {\n                        // we override the target so we do this by deleting it so the temp file can be renamed later\n                        // with success as the existing target file have been deleted\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Deleting existing file: \" + tempTarget);\n                        }\n                        if (!operations.deleteFile(target)) {\n                            throw new GenericFileOperationFailedException(\"Cannot delete file: \" + target);\n                        }\n\n                    }\n                }\n\n                // delete any pre existing temp file\n                if (operations.existsFile(tempTarget)) {\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"Deleting existing temp file: \" + tempTarget);\n                    }\n                    if (!operations.deleteFile(tempTarget)) {\n                        throw new GenericFileOperationFailedException(\"Cannot delete file: \" + tempTarget);\n                    }\n                }\n            }\n\n            // write/upload the file\n            writeFile(exchange, tempTarget != null ? tempTarget : target);\n\n            // if we did write to a temporary name then rename it to the real\n            // name after we have written the file\n            if (tempTarget != null) {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Renaming file: [\" + tempTarget + \"] to: [\" + target + \"]\");\n                }\n                boolean renamed = operations.renameFile(tempTarget, target);\n                if (!renamed) {\n                    throw new GenericFileOperationFailedException(\"Cannot rename file from: \" + tempTarget + \" to: \" + target);\n                }\n            }\n\n            // lets store the name we really used in the header, so end-users\n            // can retrieve it\n            exchange.getIn().setHeader(Exchange.FILE_NAME_PRODUCED, target);\n        } catch (Exception e) {\n            handleFailedWrite(exchange, e);\n        }\n\n        postWriteCheck();\n    }","commit_id":"665325e4ea6ce09d084e64cf72bafabc7cc3d066","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void preWriteCheck() throws Exception {\n        // before writing send a noop to see if the connection is alive and works\n        boolean noop = false;\n        try {\n            connectIfNecessary();\n            if (loggedIn) {\n                noop = getOperations().sendNoop();\n            }\n        } catch (Exception e) {\n            // ignore as we will try to recover connection\n            noop = false;\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"preWriteCheck send noop success: \" + noop);\n        }\n\n        // if not alive then force a disconnect so we reconnect again\n        if (!noop) {\n            try {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"preWriteCheck forcing a disconnect as noop failed\");\n                }\n                disconnect();\n            } catch (Exception e) {\n                // ignore for now as we will reconnect below\n            }\n        }\n\n        connectIfNecessary();\n        if (!loggedIn) {\n            // must be logged in to be able to upload the file\n            String message = \"Cannot connect/login to: \" + ((RemoteFileEndpoint) getEndpoint()).remoteServerInformation();\n            throw new GenericFileOperationFailedException(message);\n        }\n    }","id":47119,"modified_method":"@Override\n    protected void preWriteCheck() throws Exception {\n        // before writing send a noop to see if the connection is alive and works\n        boolean noop = false;\n        try {\n            connectIfNecessary();\n            if (loggedIn) {\n                noop = getOperations().sendNoop();\n            }\n        } catch (Exception e) {\n            // ignore as we will try to recover connection\n            noop = false;\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"preWriteCheck send noop success: \" + noop);\n        }\n\n        // if not alive then force a disconnect so we reconnect again\n        if (!noop) {\n            try {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"preWriteCheck forcing a disconnect as noop failed\");\n                }\n                disconnect();\n            } catch (Exception e) {\n                // ignore for now as we will reconnect below\n            }\n        }\n\n        connectIfNecessary();\n        if (!loggedIn) {\n            // must be logged in to be able to upload the file\n            String message = \"Cannot connect/login to: \" + getEndpoint().remoteServerInformation();\n            throw new GenericFileOperationFailedException(message);\n        }\n    }","commit_id":"665325e4ea6ce09d084e64cf72bafabc7cc3d066","url":"https://github.com/apache/camel"},{"original_method":"protected void connectIfNecessary() throws IOException {\n        if (!loggedIn) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Not already connected/logged in. Connecting to: \" + getEndpoint());\n            }\n            RemoteFileEndpoint rfe = (RemoteFileEndpoint) getEndpoint();\n            RemoteFileConfiguration conf = (RemoteFileConfiguration) rfe.getConfiguration();\n            loggedIn = getOperations().connect(conf);\n            if (!loggedIn) {\n                return;\n            }\n            log.info(\"Connected and logged in to: \" + getEndpoint());\n        }\n    }","id":47120,"modified_method":"protected void connectIfNecessary() throws GenericFileOperationFailedException {\n        if (!loggedIn) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Not already connected/logged in. Connecting to: \" + getEndpoint());\n            }\n            RemoteFileConfiguration config = (RemoteFileConfiguration) getEndpoint().getConfiguration();\n            loggedIn = getOperations().connect(config);\n            if (!loggedIn) {\n                return;\n            }\n            log.info(\"Connected and logged in to: \" + getEndpoint());\n        }\n    }","commit_id":"665325e4ea6ce09d084e64cf72bafabc7cc3d066","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n\n            // Is there a consumer registered for the request.\n            HttpConsumer consumer = resolve(request);\n            if (consumer == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            // are we suspended?\n            if (consumer.isSuspended()) {\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                return;\n            }\n\n            // Have the camel process the HTTP exchange.\n            DefaultExchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n            if (((HttpEndpoint)consumer.getEndpoint()).isBridgeEndpoint()) {\n                exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            }\n            exchange.setIn(new HttpMessage(exchange, request, response));\n            consumer.getProcessor().process(exchange);\n\n            // HC: The getBinding() is interesting because it illustrates the\n            // impedance miss-match between\n            // HTTP's stream oriented protocol, and Camels more message oriented\n            // protocol exchanges.\n\n            // now lets output to the response\n            consumer.getBinding().writeResponse(exchange, response);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new ServletException(e);\n        }\n    }","id":47121,"modified_method":"@Override\n    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n\n            // Is there a consumer registered for the request.\n            HttpConsumer consumer = resolve(request);\n            if (consumer == null) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n\n            // are we suspended?\n            if (consumer.isSuspended()) {\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                return;\n            }\n\n            // create exchange and set data on it\n            Exchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n            if ((consumer.getEndpoint()).isBridgeEndpoint()) {\n                exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n            }\n            exchange.setIn(new HttpMessage(exchange, request, response));\n\n            // Have the camel process the HTTP exchange.\n            consumer.getProcessor().process(exchange);\n\n            // now lets output to the response\n            consumer.getBinding().writeResponse(exchange, response);\n\n        } catch (Exception e) {\n            LOG.error(\"Error processing request\", e);\n            throw new ServletException(e);\n        }\n    }","commit_id":"e96b9ed6a153170292d5130db05891d4bcb953bb","url":"https://github.com/apache/camel"},{"original_method":"private String getField(FieldMap fieldMap, int tag) {\n        if (fieldMap.isSetField(tag)) {\n            try {\n                return fieldMap.getString(tag);\n            } catch (Exception e) {\n                // won't happen\n            }\n        }\n        return null;\n    }","id":47122,"modified_method":"private String getField(FieldMap fieldMap, int tag) {\n        if (fieldMap.isSetField(tag)) {\n            try {\n                return fieldMap.getString(tag);\n            } catch (Exception e) {\n                ObjectHelper.wrapRuntimeCamelException(e);\n            }\n        }\n        return null;\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"private boolean evaluate(FieldMap fieldMap, List<Field<String>> criteria) {\n        for (Field<String> c : criteria) {\n            String value = null;\n            try {\n                if (fieldMap.isSetField(c.getField())) {\n                    value = fieldMap.getString(c.getField());\n                }\n            } catch (FieldNotFound e) {\n                // ignored, shouldn't happen\n            }\n            if (!c.getObject().equals(value)) {\n                return false;\n            }\n        }\n        return true;\n    }","id":47123,"modified_method":"private boolean evaluate(FieldMap fieldMap, List<Field<String>> criteria) {\n        for (Field<String> c : criteria) {\n            String value = null;\n            try {\n                if (fieldMap.isSetField(c.getField())) {\n                    value = fieldMap.getString(c.getField());\n                }\n            } catch (FieldNotFound e) {\n                ObjectHelper.wrapRuntimeCamelException(e);\n            }\n            if (!c.getObject().equals(value)) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"private void addHeaderFieldIfPresent(int tag, String value) {\n        if (value != null && !\"\".equals(value)) {\n            withHeaderField(tag, value);\n        }\n    }","id":47124,"modified_method":"private void addHeaderFieldIfPresent(int tag, String value) {\n        if (!ObjectHelper.isEmpty(value)) {\n            withHeaderField(tag, value);\n        }\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"public String transform(Exchange exchange) {\n        SessionID sessionID = (SessionID) exchange.getIn().getHeader(QuickfixjEndpoint.SESSION_ID_KEY);\n        Session session = Session.lookupSession(sessionID);\n        DataDictionary dataDictionary = session.getDataDictionary();\n        \n        if (dataDictionary == null) {\n            throw new IllegalStateException(\"No Data Dictionary. Exchange must reference an existing session\");\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\\\"event\\\": {\\n\");\n        \n        org.apache.camel.Message in = exchange.getIn();\n        for (String key : in.getHeaders().keySet()) {\n            sb.append(\"  \\\"\").append(key).append(\"\\\": \").append(in.getHeader(key)).append(\",\\n\");                \n        }\n        \n        sb.append(renderer.transform(in.getBody(Message.class), \"  \", dataDictionary)).append(\"\\n\");\n        sb.append(\"}\\n\");\n        return sb.toString();\n    }","id":47125,"modified_method":"public String transform(Exchange exchange) {\n        SessionID sessionID = exchange.getIn().getHeader(QuickfixjEndpoint.SESSION_ID_KEY, SessionID.class);\n        Session session = Session.lookupSession(sessionID);\n        DataDictionary dataDictionary = session.getDataDictionary();\n        \n        if (dataDictionary == null) {\n            throw new IllegalStateException(\"No Data Dictionary. Exchange must reference an existing session\");\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        sb.append(\"\\\"event\\\": {\\n\");\n        \n        org.apache.camel.Message in = exchange.getIn();\n        for (String key : in.getHeaders().keySet()) {\n            sb.append(\"  \\\"\").append(key).append(\"\\\": \").append(in.getHeader(key)).append(\",\\n\");                \n        }\n        \n        sb.append(renderer.transform(in.getBody(Message.class), \"  \", dataDictionary)).append(\"\\n\");\n        sb.append(\"}\\n\");\n        return sb.toString();\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"void sendMessage(Exchange exchange, org.apache.camel.Message camelMessage) throws Exception {\n        Message message = camelMessage.getBody(Message.class);\n        log.debug(\"Sending FIX message: {}\", message);\n\n        SessionID messageSessionID = sessionID;\n        if (messageSessionID == null) {\n            messageSessionID = MessageUtils.getSessionID(message);\n        }\n\n        Session session = getSession(messageSessionID);\n        if (session == null) {\n            throw new IllegalStateException(\"Unknown session: \" + messageSessionID);\n        }\n\n        Callable<Message> callable = null;\n\n        if (exchange.getPattern().isOutCapable()) {\n            QuickfixjEndpoint endpoint = (QuickfixjEndpoint) getEndpoint();\n            MessageCorrelator messageCorrelator = endpoint.getEngine().getMessageCorrelator();\n            callable = messageCorrelator.getReply(endpoint.getSessionID(), exchange);\n        }\n\n        if (!session.send(message)) {\n            throw new CannotSendException(\"Cannot send FIX message: \" + message.toString());\n        }\n\n        if (callable != null) {\n            Message reply = callable.call();\n            exchange.getOut().setBody(reply);\n        }\n    }","id":47126,"modified_method":"void sendMessage(Exchange exchange, org.apache.camel.Message camelMessage) throws Exception {\n        Message message = camelMessage.getBody(Message.class);\n        log.debug(\"Sending FIX message: {}\", message);\n\n        SessionID messageSessionID = getEndpoint().getSessionID();\n        if (messageSessionID == null) {\n            messageSessionID = MessageUtils.getSessionID(message);\n        }\n\n        Session session = getSession(messageSessionID);\n        if (session == null) {\n            throw new IllegalStateException(\"Unknown session: \" + messageSessionID);\n        }\n\n        Callable<Message> callable = null;\n\n        if (exchange.getPattern().isOutCapable()) {\n            MessageCorrelator messageCorrelator = getEndpoint().getEngine().getMessageCorrelator();\n            callable = messageCorrelator.getReply(getEndpoint().getSessionID(), exchange);\n        }\n\n        if (!session.send(message)) {\n            throw new CannotSendException(\"Cannot send FIX message: \" + message.toString());\n        }\n\n        if (callable != null) {\n            Message reply = callable.call();\n            exchange.getOut().setBody(reply);\n        }\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"public QuickfixjProducer(Endpoint endpoint) {\n        super(endpoint);\n        sessionID = ((QuickfixjEndpoint) getEndpoint()).getSessionID();\n    }","id":47127,"modified_method":"public QuickfixjProducer(Endpoint endpoint) {\n        super(endpoint);\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"public void run() throws Exception {        \n        DefaultCamelContext context = new DefaultCamelContext();\n        final CountDownLatch logonLatch = new CountDownLatch(1);\n        final String orderStatusServiceUrl = \"http://localhost:9123/order/status\";\n        \n        RouteBuilder routes = new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // Synchronize the logon so we don't start sending status requests too early\n                from(\"quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET\").\n                    filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogon)).\n                    bean(new CountDownLatchDecrementer(\"logon\", logonLatch));\n\n                // Incoming status requests are converted to InOut exchange pattern and passed to the\n                // order status service. The response is sent back to the session making the request.\n                from(\"quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER&exchangePattern=InOut\")\n                    .filter(header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.ORDER_STATUS_REQUEST))\n                    .bean(new MarketOrderStatusService());\n                \n                from(\"jetty:\" + orderStatusServiceUrl)\n                    .bean(new OrderStatusRequestTransformer())\n                    .routingSlip(method(FixSessionRouter.class, \"route\"))\n                    .bean(new QuickfixjMessageJsonTransformer());\n            }\n        };\n        \n        context.addRoutes(routes);\n        \n        LOG.info(\"Starting Camel context\");\n        context.start();\n        \n        if (!logonLatch.await(5L, TimeUnit.SECONDS)) {\n            throw new IllegalStateException(\"Logon did not succeed\");\n        }\n        \n        // Send a request to the order status web service.\n        // Verify that the response is a JSON response.\n        \n        URL orderStatusUrl = new URL(orderStatusServiceUrl + \"?sessionID=FIX.4.2:TRADER->MARKET&orderID=abc\");\n        HttpURLConnection connection = (HttpURLConnection) orderStatusUrl.openConnection();\n        BufferedReader orderStatusReply = IOHelper.buffered(new InputStreamReader(connection.getInputStream()));\n        String line = orderStatusReply.readLine();\n        if (!line.equals(\"\\\"message\\\": {\")) {\n            throw new Exception(\"Don't appear to be a JSON response\");\n        } else {\n            StringBuilder sb = new StringBuilder();\n            while (line != null) {\n                sb.append(line);\n                sb.append('\\n');\n                line = orderStatusReply.readLine();\n            }\n            LOG.info(\"Web request response:\\n\" + sb);\n        }\n        orderStatusReply.close();\n        \n        LOG.info(\"Shutting down Camel context\");\n        context.stop();\n        \n        LOG.info(\"Example complete\");\n    }","id":47128,"modified_method":"public void run() throws Exception {        \n        DefaultCamelContext context = new DefaultCamelContext();\n        final CountDownLatch logonLatch = new CountDownLatch(1);\n        final String orderStatusServiceUrl = \"http://localhost:9123/order/status\";\n        \n        RouteBuilder routes = new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                // Synchronize the logon so we don't start sending status requests too early\n                from(\"quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:TRADER->MARKET\").\n                    filter(header(QuickfixjEndpoint.EVENT_CATEGORY_KEY).isEqualTo(QuickfixjEventCategory.SessionLogon)).\n                    bean(new CountDownLatchDecrementer(\"logon\", logonLatch));\n\n                // Incoming status requests are converted to InOut exchange pattern and passed to the\n                // order status service. The response is sent back to the session making the request.\n                from(\"quickfix:examples/inprocess.cfg?sessionID=FIX.4.2:MARKET->TRADER&exchangePattern=InOut\")\n                    .filter(header(QuickfixjEndpoint.MESSAGE_TYPE_KEY).isEqualTo(MsgType.ORDER_STATUS_REQUEST))\n                    .bean(new MarketOrderStatusService());\n                \n                from(\"jetty:\" + orderStatusServiceUrl)\n                    .bean(new OrderStatusRequestTransformer())\n                    .routingSlip(method(FixSessionRouter.class, \"route\"))\n                    .bean(new QuickfixjMessageJsonTransformer());\n            }\n        };\n        \n        context.addRoutes(routes);\n        \n        LOG.info(\"Starting Camel context\");\n        context.start();\n        \n        if (!logonLatch.await(5L, TimeUnit.SECONDS)) {\n            throw new IllegalStateException(\"Logon did not succeed\");\n        }\n        \n        // Send a request to the order status web service.\n        // Verify that the response is a JSON response.\n        \n        URL orderStatusUrl = new URL(orderStatusServiceUrl + \"?sessionID=FIX.4.2:TRADER->MARKET&orderID=abc\");\n        URLConnection connection = orderStatusUrl.openConnection();\n        BufferedReader orderStatusReply = IOHelper.buffered(new InputStreamReader(connection.getInputStream()));\n        String line = orderStatusReply.readLine();\n        if (!line.equals(\"\\\"message\\\": {\")) {\n            throw new Exception(\"Don't appear to be a JSON response\");\n        } else {\n            StringBuilder sb = new StringBuilder();\n            while (line != null) {\n                sb.append(line);\n                sb.append('\\n');\n                line = orderStatusReply.readLine();\n            }\n            LOG.info(\"Web request response:\\n\" + sb);\n        }\n        orderStatusReply.close();\n        \n        LOG.info(\"Shutting down Camel context\");\n        context.stop();\n        \n        LOG.info(\"Example complete\");\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"public void transform(Exchange exchange) throws FieldNotFound {\n            String sessionID = (String) exchange.getIn().getHeader(\"sessionID\");\n            String orderID = (String) exchange.getIn().getHeader(\"orderID\");\n\n            OrderStatusRequest request = new OrderStatusRequest(new ClOrdID(\"XYZ\"), new Symbol(\"GOOG\"), new Side(Side.BUY));\n            request.set(new OrderID(orderID));\n             \n            // Look for a reply execution report back to the requester session\n            // and having the requested OrderID. This is a loose correlation but the best\n            // we can do with FIX 4.2. Newer versions of FIX have an optional explicit correlation field.\n            exchange.setProperty(QuickfixjProducer.CORRELATION_CRITERIA_KEY, new MessagePredicate(\n                new SessionID(sessionID), MsgType.EXECUTION_REPORT).withField(OrderID.FIELD, request.getString(OrderID.FIELD)));\n            \n            exchange.getIn().setBody(request);\n        }","id":47129,"modified_method":"public void transform(Exchange exchange) throws FieldNotFound {\n            // For the reply take the reverse sessionID into the account, that's the reverse of\n            // exchange.getIn().getHeader(\"sessionID\", String.class) which is equal to \"FIX.4.2:TRADER->MARKET\"\n            String sessionID = \"FIX.4.2:MARKET->TRADER\";\n            String orderID = exchange.getIn().getHeader(\"orderID\", String.class);\n\n            OrderStatusRequest request = new OrderStatusRequest(new ClOrdID(\"XYZ\"), new Symbol(\"GOOG\"), new Side(Side.BUY));\n            request.set(new OrderID(orderID));\n             \n            // Look for a reply execution report back to the requester session\n            // and having the requested OrderID. This is a loose correlation but the best\n            // we can do with FIX 4.2. Newer versions of FIX have an optional explicit correlation field.\n            exchange.setProperty(QuickfixjProducer.CORRELATION_CRITERIA_KEY, new MessagePredicate(\n                new SessionID(sessionID), MsgType.ORDER_STATUS_REQUEST).withField(OrderID.FIELD, request.getString(OrderID.FIELD)));\n            \n            exchange.getIn().setBody(request);\n        }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"serial\")\n    public TradeExecutor() throws ConfigError, FieldConvertError {\n        setAlwaysFillLimitOrders(true);\n        setValidOrderTypes(new HashSet<String>() { { add(OrdType.LIMIT + \"\"); add(OrdType.MARKET + \"\"); } });\n        setMarketQuoteProvider(new DefaultMarketQuoteProvider(10.00));\n    }","id":47130,"modified_method":"public TradeExecutor() throws ConfigError, FieldConvertError {\n        setAlwaysFillLimitOrders(true);\n\n        Set<String> validOrderTypes = new HashSet<String>();\n        validOrderTypes.add(OrdType.LIMIT + \"\");\n        validOrderTypes.add(OrdType.MARKET + \"\");\n        setValidOrderTypes(validOrderTypes);\n\n        setMarketQuoteProvider(new DefaultMarketQuoteProvider(10.00));\n    }","commit_id":"db72f9145110342ca69df92c111bbe832b90a032","url":"https://github.com/apache/camel"},{"original_method":"@Override\n        public void done(boolean sync) {\n            try {\n                Message response = SjmsExchangeMessageHelper.createMessage(exchange, getSession(), ((SjmsEndpoint) getEndpoint()).getJmsKeyFormatStrategy(), ((SjmsEndpoint) getEndpoint()).getCamelContext().getTypeConverter());\n                response.setJMSCorrelationID(exchange.getIn().getHeader(\"JMSCorrelationID\", String.class));\n                localProducer.send(response);\n            } catch (Exception e) {\n                exchange.setException(e);\n            }\n        }","id":47131,"modified_method":"@Override\n        public void done(boolean sync) {\n            try {\n                Message response = SjmsExchangeMessageHelper.createMessage(exchange, getSession(),\n                        getEndpoint().getJmsKeyFormatStrategy(), getEndpoint().getCamelContext().getTypeConverter());\n                response.setJMSCorrelationID(exchange.getIn().getHeader(\"JMSCorrelationID\", String.class));\n                localProducer.send(response);\n            } catch (Exception e) {\n                exchange.setException(e);\n            }\n        }","commit_id":"a9e987fe2eb6201b154d7cffb2ee8cd67fc9019f","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Adds or updates the {@link Message} headers. Header names and values are\n     * checked for JMS 1.1 compliance.\n     *\n     * @param jmsMessage        the {@link Message} to add or update the headers on\n     * @param messageHeaders    a {@link Map} of String/Object pairs\n     * @param keyFormatStrategy the a {@link KeyFormatStrategy} to used to\n     *                          format keys in a JMS 1.1 compliant manner. If null the\n     *                          {@link DefaultJmsKeyFormatStrategy} will be used.\n     * @return {@link Message}\n     * @throws Exception a\n     */\n    public static Message setJmsMessageHeaders(final Message jmsMessage, Map<String, Object> messageHeaders, KeyFormatStrategy keyFormatStrategy) throws IllegalHeaderException {\n        // Support for the null keyFormatStrategy\n        KeyFormatStrategy localKeyFormatStrategy = null;\n        if (keyFormatStrategy == null) {\n            localKeyFormatStrategy = new DefaultJmsKeyFormatStrategy();\n        } else {\n            localKeyFormatStrategy = keyFormatStrategy;\n        }\n\n        Map<String, Object> headers = new HashMap<String, Object>(messageHeaders);\n        Set<String> keys = headers.keySet();\n        for (String headerName : keys) {\n            Object headerValue = headers.get(headerName);\n\n            if (headerName.equalsIgnoreCase(JMS_CORRELATION_ID)) {\n                if (headerValue == null) {\n                    // Value can be null but we can't cast a null to a String\n                    // so pass null to the setter\n                    setCorrelationId(jmsMessage, null);\n                } else if (headerValue instanceof String) {\n                    setCorrelationId(jmsMessage, (String) headerValue);\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_CORRELATION_ID + \" must either be a String or null.  Found: \" + headerValue.getClass().getName());\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_REPLY_TO)) {\n                if (headerValue instanceof String) {\n                    // FIXME Setting the reply to appears broken. walk back\n                    // through it. If the value is a String we must normalize it\n                    // first\n                } else {\n                    // TODO write destination converter\n                    // Destination replyTo =\n                    // ExchangeHelper.convertToType(exchange,\n                    // Destination.class,\n                    // headerValue);\n                    // jmsMessage.setJMSReplyTo(replyTo);\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_TYPE)) {\n                if (headerValue == null) {\n                    // Value can be null but we can't cast a null to a String\n                    // so pass null to the setter\n                    setMessageType(jmsMessage, null);\n                } else if (headerValue instanceof String) {\n                    // Not null but is a String\n                    setMessageType(jmsMessage, (String) headerValue);\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_TYPE + \" must either be a String or null.  Found: \" + headerValue.getClass().getName());\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_PRIORITY)) {\n                if (headerValue instanceof Integer) {\n                    try {\n                        jmsMessage.setJMSPriority((Integer) headerValue);\n                    } catch (JMSException e) {\n                        throw new IllegalHeaderException(\"Failed to set the \" + JMS_PRIORITY + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                    }\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_PRIORITY + \" must be a Integer.  Type found: \" + headerValue.getClass().getName());\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_DELIVERY_MODE)) {\n                try {\n                    JmsMessageHelper.setJMSDeliveryMode(jmsMessage, headerValue);\n                } catch (JMSException e) {\n                    throw new IllegalHeaderException(\"Failed to set the \" + JMS_DELIVERY_MODE + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_EXPIRATION)) {\n                if (headerValue instanceof Long) {\n                    try {\n                        jmsMessage.setJMSExpiration((Long) headerValue);\n                    } catch (JMSException e) {\n                        throw new IllegalHeaderException(\"Failed to set the \" + JMS_EXPIRATION + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                    }\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_EXPIRATION + \" must be a Long.  Type found: \" + headerValue.getClass().getName());\n                }\n            } else {\n                LOGGER.trace(\"Ignoring JMS header: {} with value: {}\", headerName, headerValue);\n                if (headerName.equalsIgnoreCase(JMS_DESTINATION) || headerName.equalsIgnoreCase(JMS_MESSAGE_ID) || headerName.equalsIgnoreCase(\"JMSTimestamp\")\n                        || headerName.equalsIgnoreCase(\"JMSRedelivered\")) {\n                    // The following properties are set by the\n                    // MessageProducer:\n                    // JMSDestination\n                    // The following are set on the underlying JMS provider:\n                    // JMSMessageID, JMSTimestamp, JMSRedelivered\n                    // log at trace level to not spam log\n                    LOGGER.trace(\"Ignoring JMS header: {} with value: {}\", headerName, headerValue);\n                } else {\n                    if (!(headerValue instanceof JmsMessageType)) {\n                        String encodedName = localKeyFormatStrategy.encodeKey(headerName);\n                        try {\n                            JmsMessageHelper.setProperty(jmsMessage, encodedName, headerValue);\n                        } catch (JMSException e) {\n                            throw new IllegalHeaderException(\"Failed to set the header \" + encodedName + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                        }\n                    }\n                }\n                // }\n            }\n        }\n        return jmsMessage;\n    }","id":47132,"modified_method":"/**\n     * Adds or updates the {@link Message} headers. Header names and values are\n     * checked for JMS 1.1 compliance.\n     *\n     * @param jmsMessage        the {@link Message} to add or update the headers on\n     * @param messageHeaders    a {@link Map} of String/Object pairs\n     * @param keyFormatStrategy the a {@link KeyFormatStrategy} to used to\n     *                          format keys in a JMS 1.1 compliant manner. If null the\n     *                          {@link DefaultJmsKeyFormatStrategy} will be used.\n     * @return {@link Message}\n     */\n    public static Message setJmsMessageHeaders(final Message jmsMessage, Map<String, Object> messageHeaders, KeyFormatStrategy keyFormatStrategy) throws IllegalHeaderException {\n        // Support for the null keyFormatStrategy\n        KeyFormatStrategy localKeyFormatStrategy = null;\n        if (keyFormatStrategy == null) {\n            localKeyFormatStrategy = new DefaultJmsKeyFormatStrategy();\n        } else {\n            localKeyFormatStrategy = keyFormatStrategy;\n        }\n\n        Map<String, Object> headers = new HashMap<String, Object>(messageHeaders);\n        Set<String> keys = headers.keySet();\n        for (String headerName : keys) {\n            Object headerValue = headers.get(headerName);\n\n            if (headerName.equalsIgnoreCase(JMS_CORRELATION_ID)) {\n                if (headerValue == null) {\n                    // Value can be null but we can't cast a null to a String\n                    // so pass null to the setter\n                    setCorrelationId(jmsMessage, null);\n                } else if (headerValue instanceof String) {\n                    setCorrelationId(jmsMessage, (String) headerValue);\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_CORRELATION_ID + \" must either be a String or null.  Found: \" + headerValue.getClass().getName());\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_REPLY_TO)) {\n                if (headerValue instanceof String) {\n                    // FIXME Setting the reply to appears broken. walk back\n                    // through it. If the value is a String we must normalize it\n                    // first\n                } else {\n                    // TODO write destination converter\n                    // Destination replyTo =\n                    // ExchangeHelper.convertToType(exchange,\n                    // Destination.class,\n                    // headerValue);\n                    // jmsMessage.setJMSReplyTo(replyTo);\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_TYPE)) {\n                if (headerValue == null) {\n                    // Value can be null but we can't cast a null to a String\n                    // so pass null to the setter\n                    setMessageType(jmsMessage, null);\n                } else if (headerValue instanceof String) {\n                    // Not null but is a String\n                    setMessageType(jmsMessage, (String) headerValue);\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_TYPE + \" must either be a String or null.  Found: \" + headerValue.getClass().getName());\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_PRIORITY)) {\n                if (headerValue instanceof Integer) {\n                    try {\n                        jmsMessage.setJMSPriority((Integer) headerValue);\n                    } catch (JMSException e) {\n                        throw new IllegalHeaderException(\"Failed to set the \" + JMS_PRIORITY + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                    }\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_PRIORITY + \" must be a Integer.  Type found: \" + headerValue.getClass().getName());\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_DELIVERY_MODE)) {\n                try {\n                    JmsMessageHelper.setJMSDeliveryMode(jmsMessage, headerValue);\n                } catch (JMSException e) {\n                    throw new IllegalHeaderException(\"Failed to set the \" + JMS_DELIVERY_MODE + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                }\n            } else if (headerName.equalsIgnoreCase(JMS_EXPIRATION)) {\n                if (headerValue instanceof Long) {\n                    try {\n                        jmsMessage.setJMSExpiration((Long) headerValue);\n                    } catch (JMSException e) {\n                        throw new IllegalHeaderException(\"Failed to set the \" + JMS_EXPIRATION + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                    }\n                } else {\n                    throw new IllegalHeaderException(\"The \" + JMS_EXPIRATION + \" must be a Long.  Type found: \" + headerValue.getClass().getName());\n                }\n            } else {\n                LOGGER.trace(\"Ignoring JMS header: {} with value: {}\", headerName, headerValue);\n                if (headerName.equalsIgnoreCase(JMS_DESTINATION) || headerName.equalsIgnoreCase(JMS_MESSAGE_ID) || headerName.equalsIgnoreCase(\"JMSTimestamp\")\n                        || headerName.equalsIgnoreCase(\"JMSRedelivered\")) {\n                    // The following properties are set by the\n                    // MessageProducer:\n                    // JMSDestination\n                    // The following are set on the underlying JMS provider:\n                    // JMSMessageID, JMSTimestamp, JMSRedelivered\n                    // log at trace level to not spam log\n                    LOGGER.trace(\"Ignoring JMS header: {} with value: {}\", headerName, headerValue);\n                } else {\n                    if (!(headerValue instanceof JmsMessageType)) {\n                        String encodedName = localKeyFormatStrategy.encodeKey(headerName);\n                        try {\n                            JmsMessageHelper.setProperty(jmsMessage, encodedName, headerValue);\n                        } catch (JMSException e) {\n                            throw new IllegalHeaderException(\"Failed to set the header \" + encodedName + \" header. Cause: \" + e.getLocalizedMessage(), e);\n                        }\n                    }\n                }\n                // }\n            }\n        }\n        return jmsMessage;\n    }","commit_id":"a9e987fe2eb6201b154d7cffb2ee8cd67fc9019f","url":"https://github.com/apache/camel"},{"original_method":"public static Message createMessage(Session session, Object payload, Map<String, Object> messageHeaders, KeyFormatStrategy keyFormatStrategy, TypeConverter typeConverter) throws Exception {\n        Message answer = null;\n        JmsMessageType messageType = JmsMessageHelper.discoverMessageTypeFromPayload(payload);\n        try {\n\n            switch (messageType) {\n            case Bytes:\n            \tBytesMessage bytesMessage = session.createBytesMessage();\n                bytesMessage = typeConverter.convertTo(BytesMessage.class, payload);\n                answer = bytesMessage;\n                break;\n            case Map:\n                MapMessage mapMessage = session.createMapMessage();\n                Map<String, Object> objMap = (Map<String, Object>) payload;\n                Set<String> keys = objMap.keySet();\n                for (String key : keys) {\n                    Object value = objMap.get(key);\n                    mapMessage.setObject(key, value);\n                }\n                answer = mapMessage;\n                break;\n            case Object:\n                ObjectMessage objectMessage = session.createObjectMessage();\n                objectMessage.setObject((Serializable) payload);\n                answer = objectMessage;\n                break;\n            case Text:\n                TextMessage textMessage = session.createTextMessage();\n                textMessage.setText((String) payload);\n                answer = textMessage;\n                break;\n            case Stream:\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                InputStream is = typeConverter.convertTo(InputStream.class, payload);\n                int reads = is.read();\n                while (reads != -1) {\n                    baos.write(reads);\n                    reads = is.read();\n                }\n\n                BytesMessage bytesStreamMessage = session.createBytesMessage();\n                bytesStreamMessage.writeBytes(baos.toByteArray());\n                baos.close();\n                is.close();\n                answer = bytesStreamMessage;\n                break;\n            default:\n                break;\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error creating a message of type: {}\", messageType, e);\n            throw e;\n        }\n        if (messageHeaders != null && !messageHeaders.isEmpty()) {\n            answer = JmsMessageHelper.setJmsMessageHeaders(answer, messageHeaders, keyFormatStrategy);\n        }\n        return answer;\n    }","id":47133,"modified_method":"public static Message createMessage(Session session, Object payload, Map<String, Object> messageHeaders, KeyFormatStrategy keyFormatStrategy, TypeConverter typeConverter) throws Exception {\n        Message answer = null;\n        JmsMessageType messageType = JmsMessageHelper.discoverMessageTypeFromPayload(payload);\n        try {\n\n            switch (messageType) {\n            case Bytes:\n                BytesMessage bytesMessage = typeConverter.convertTo(BytesMessage.class, payload);\n                answer = bytesMessage;\n                break;\n            case Map:\n                MapMessage mapMessage = session.createMapMessage();\n                Map<String, Object> objMap = (Map<String, Object>) payload;\n                Set<String> keys = objMap.keySet();\n                for (String key : keys) {\n                    Object value = objMap.get(key);\n                    mapMessage.setObject(key, value);\n                }\n                answer = mapMessage;\n                break;\n            case Object:\n                ObjectMessage objectMessage = session.createObjectMessage();\n                objectMessage.setObject((Serializable) payload);\n                answer = objectMessage;\n                break;\n            case Text:\n                TextMessage textMessage = session.createTextMessage();\n                textMessage.setText((String) payload);\n                answer = textMessage;\n                break;\n            case Stream:\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                InputStream is = typeConverter.convertTo(InputStream.class, payload);\n                int reads = is.read();\n                while (reads != -1) {\n                    baos.write(reads);\n                    reads = is.read();\n                }\n                BytesMessage bytesStreamMessage = session.createBytesMessage();\n                bytesStreamMessage.writeBytes(baos.toByteArray());\n                baos.close();\n                is.close();\n                answer = bytesStreamMessage;\n                break;\n            default:\n                break;\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error creating a message of type: {}\", messageType, e);\n            throw e;\n        }\n        if (messageHeaders != null && !messageHeaders.isEmpty()) {\n            answer = JmsMessageHelper.setJmsMessageHeaders(answer, messageHeaders, keyFormatStrategy);\n        }\n        return answer;\n    }","commit_id":"a9e987fe2eb6201b154d7cffb2ee8cd67fc9019f","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sets the JMSDeliveryMode on the message.\n     *\n     * @param exchange     the exchange\n     * @param message      the message\n     * @param deliveryMode the delivery mode, either as a String or integer\n     * @throws javax.jms.JMSException is thrown if error setting the delivery\n     *                                mode\n     */\n    public static void setJMSDeliveryMode(Message message, Object deliveryMode) throws JMSException {\n        Integer mode = null;\n\n        if (deliveryMode instanceof String) {\n            String s = (String) deliveryMode;\n            if (\"PERSISTENT\".equalsIgnoreCase(s)) {\n                mode = DeliveryMode.PERSISTENT;\n            } else if (\"NON_PERSISTENT\".equalsIgnoreCase(s)) {\n                mode = DeliveryMode.NON_PERSISTENT;\n            } else {\n                // it may be a number in the String so try that\n                Integer value = null;\n                try {\n                    value = Integer.valueOf(s);\n                } catch (NumberFormatException e) {\n                    // Do nothing. The error handler below is sufficient\n                }\n                if (value != null) {\n                    mode = value;\n                } else {\n                    throw new IllegalArgumentException(\"Unknown delivery mode with value: \" + deliveryMode);\n                }\n            }\n        } else if (deliveryMode instanceof Integer) {\n            // fallback and try to convert to a number\n            mode = (Integer) deliveryMode;\n        } else {\n            throw new IllegalArgumentException(\"Unable to convert the given delivery mode of type \" + deliveryMode.getClass().getName() + \" with value: \" + deliveryMode);\n        }\n\n        if (mode != null) {\n            message.setJMSDeliveryMode(mode);\n        }\n    }","id":47134,"modified_method":"/**\n     * Sets the JMSDeliveryMode on the message.\n     *\n     * @param message      the message\n     * @param deliveryMode the delivery mode, either as a String or integer\n     * @throws javax.jms.JMSException is thrown if error setting the delivery mode\n     */\n    public static void setJMSDeliveryMode(Message message, Object deliveryMode) throws JMSException {\n        Integer mode;\n\n        if (deliveryMode instanceof String) {\n            String s = (String) deliveryMode;\n            if (\"PERSISTENT\".equalsIgnoreCase(s)) {\n                mode = DeliveryMode.PERSISTENT;\n            } else if (\"NON_PERSISTENT\".equalsIgnoreCase(s)) {\n                mode = DeliveryMode.NON_PERSISTENT;\n            } else {\n                // it may be a number in the String so try that\n                Integer value = null;\n                try {\n                    value = Integer.valueOf(s);\n                } catch (NumberFormatException e) {\n                    // Do nothing. The error handler below is sufficient\n                }\n                if (value != null) {\n                    mode = value;\n                } else {\n                    throw new IllegalArgumentException(\"Unknown delivery mode with value: \" + deliveryMode);\n                }\n            }\n        } else if (deliveryMode instanceof Integer) {\n            // fallback and try to convert to a number\n            mode = (Integer) deliveryMode;\n        } else {\n            throw new IllegalArgumentException(\"Unable to convert the given delivery mode of type \" + deliveryMode.getClass().getName() + \" with value: \" + deliveryMode);\n        }\n\n        message.setJMSDeliveryMode(mode);\n    }","commit_id":"a9e987fe2eb6201b154d7cffb2ee8cd67fc9019f","url":"https://github.com/apache/camel"},{"original_method":"public void populateExchangeFromRestletResponse(Exchange exchange, Response response) throws Exception {\n        for (Map.Entry<String, Object> entry : response.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                exchange.getOut().setHeader(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate exchange from Restlet response header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        // set response code\n        int responseCode = response.getStatus().getCode();\n        exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, responseCode);\n\n        if (response.getEntity() != null) {\n            // get content type\n            MediaType mediaType = response.getEntity().getMediaType();\n            if (mediaType != null) {\n                exchange.getOut().setHeader(Exchange.CONTENT_TYPE, mediaType.toString());\n            }\n\n            // get content text\n            String text = response.getEntity().getText();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Populate exchange from Restlet response: \" + text);\n            }\n            exchange.getOut().setBody(text);\n        }\n    }","id":47135,"modified_method":"public void populateExchangeFromRestletResponse(Exchange exchange, Response response) throws Exception {\n        for (Map.Entry<String, Object> entry : response.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                exchange.getOut().setHeader(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate exchange from Restlet response header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        // set response code\n        int responseCode = response.getStatus().getCode();\n        exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, responseCode);\n\n        // set restlet response as header so end user have access to it if needed\n        exchange.getOut().setHeader(RestletConstants.RESTLET_RESPONSE, response);\n\n        if (response.getEntity() != null) {\n            // get content type\n            MediaType mediaType = response.getEntity().getMediaType();\n            if (mediaType != null) {\n                exchange.getOut().setHeader(Exchange.CONTENT_TYPE, mediaType.toString());\n            }\n\n            // get content text\n            String text = response.getEntity().getText();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Populate exchange from Restlet response: \" + text);\n            }\n            exchange.getOut().setBody(text);\n        }\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"public void populateRestletResponseFromExchange(Exchange exchange, Response response) {\n        Message out;\n        if (exchange.isFailed()) {\n            // 500 for internal server error which can be overridden by response code in header\n            response.setStatus(Status.valueOf(500));\n            if (exchange.hasOut() && exchange.getOut().isFault()) {\n                out = exchange.getOut();\n            } else {\n                // print exception as message and stacktrace\n                Exception t = exchange.getException();\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                t.printStackTrace(pw);\n                response.setEntity(sw.toString(), MediaType.TEXT_PLAIN);\n                return;\n            }\n        } else {\n            out = exchange.getOut();\n        }\n\n        // get content type\n        MediaType mediaType = out.getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            Object body = out.getBody();\n            mediaType = MediaType.TEXT_PLAIN;\n            if (body instanceof String) {\n                mediaType = MediaType.TEXT_PLAIN;\n            } else if (body instanceof StringSource || body instanceof DOMSource) {\n                mediaType = MediaType.TEXT_XML;\n            }\n        }\n\n        // get response code\n        Integer responseCode = out.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);\n        if (responseCode != null) {\n            response.setStatus(Status.valueOf(responseCode));\n        }\n\n        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                response.getAttributes().put(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet response from exchange header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        // set response body according to the message body\n        Object body = out.getBody();\n        if (body instanceof GenericFile) {\n            // grab body from generic file holder\n            GenericFile gf = (GenericFile) body;\n            body = gf.getBody();\n        }\n\n        if (body == null) {\n            // empty response\n            response.setEntity(\"\", MediaType.TEXT_PLAIN);\n        } else if (body instanceof InputStream) {\n            response.setEntity(new InputRepresentation(out.getBody(InputStream.class), mediaType));\n        } else if (body instanceof File) {\n            response.setEntity(new FileRepresentation(out.getBody(File.class), mediaType));\n        } else if (body != null) {\n            // fallback and use string\n            String text = out.getBody(String.class);\n            response.setEntity(text, mediaType);\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet response from exchange body: \" + body);\n        }\n\n        if (exchange.getProperty(Exchange.CHARSET_NAME) != null) {\n            CharacterSet cs = CharacterSet.valueOf(exchange.getProperty(Exchange.CHARSET_NAME, String.class));\n            response.getEntity().setCharacterSet(cs);\n        }\n    }","id":47136,"modified_method":"public void populateRestletResponseFromExchange(Exchange exchange, Response response) {\n        Message out;\n        if (exchange.isFailed()) {\n            // 500 for internal server error which can be overridden by response code in header\n            response.setStatus(Status.valueOf(500));\n            if (exchange.hasOut() && exchange.getOut().isFault()) {\n                out = exchange.getOut();\n            } else {\n                // print exception as message and stacktrace\n                Exception t = exchange.getException();\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                t.printStackTrace(pw);\n                response.setEntity(sw.toString(), MediaType.TEXT_PLAIN);\n                return;\n            }\n        } else {\n            out = exchange.getOut();\n        }\n\n        // get content type\n        MediaType mediaType = out.getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            Object body = out.getBody();\n            mediaType = MediaType.TEXT_PLAIN;\n            if (body instanceof String) {\n                mediaType = MediaType.TEXT_PLAIN;\n            } else if (body instanceof StringSource || body instanceof DOMSource) {\n                mediaType = MediaType.TEXT_XML;\n            }\n        }\n\n        // get response code\n        Integer responseCode = out.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);\n        if (responseCode != null) {\n            response.setStatus(Status.valueOf(responseCode));\n        }\n\n        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                response.getAttributes().put(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet response from exchange header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        // set response body according to the message body\n        Object body = out.getBody();\n        if (body instanceof GenericFile) {\n            // grab body from generic file holder\n            GenericFile gf = (GenericFile) body;\n            body = gf.getBody();\n        }\n\n        if (body == null) {\n            // empty response\n            response.setEntity(\"\", MediaType.TEXT_PLAIN);\n        } else if (body instanceof Response) {\n            // its already a restlet response, so dont do anything\n            LOG.debug(\"Using existing Restlet Response from exchange body: {}\", body);\n        } else if (body instanceof InputStream) {\n            response.setEntity(new InputRepresentation(out.getBody(InputStream.class), mediaType));\n        } else if (body instanceof File) {\n            response.setEntity(new FileRepresentation(out.getBody(File.class), mediaType));\n        } else {\n            // fallback and use string\n            String text = out.getBody(String.class);\n            response.setEntity(text, mediaType);\n        }\n        LOG.debug(\"Populate Restlet response from exchange body: {}\", body);\n\n        if (exchange.getProperty(Exchange.CHARSET_NAME) != null) {\n            CharacterSet cs = CharacterSet.valueOf(exchange.getProperty(Exchange.CHARSET_NAME, String.class));\n            response.getEntity().setCharacterSet(cs);\n        }\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"public void populateExchangeFromRestletRequest(Request request, Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n\n        // extract headers from restlet\n        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                inMessage.setHeader(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate exchange from Restlet request header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        // copy query string to header\n        String query = request.getResourceRef().getQuery();\n        if (query != null) {\n            inMessage.setHeader(Exchange.HTTP_QUERY, query);\n        }\n\n        // copy URI to header\n        inMessage.setHeader(Exchange.HTTP_URI, request.getResourceRef().getIdentifier(true));\n\n        // copy HTTP method to header\n        inMessage.setHeader(Exchange.HTTP_METHOD, request.getMethod().toString());\n\n        if (!request.isEntityAvailable()) {\n            return;\n        }\n\n        // only deal with the form if the content type is \"application/x-www-form-urlencoded\"\n        if (request.getEntity().getMediaType() != null && request.getEntity().getMediaType().equals(MediaType.APPLICATION_WWW_FORM)) {\n            Form form = new Form(request.getEntity());\n            for (Map.Entry<String, String> entry : form.getValuesMap().entrySet()) {\n                if (entry.getValue() == null) {\n                    inMessage.setBody(entry.getKey());\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Populate exchange from Restlet request body: \" + entry.getValue());\n                    }\n                } else {\n                    if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                        inMessage.setHeader(entry.getKey(), entry.getValue());\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Populate exchange from Restlet request user header: \"\n                                    + entry.getKey() + \" value: \" + entry.getValue());\n                        }\n                    }\n                }\n            }\n        } else {\n            inMessage.setBody(request.getEntity().getStream());\n        }\n\n    }","id":47137,"modified_method":"public void populateExchangeFromRestletRequest(Request request, Response response, Exchange exchange) throws Exception {\n        Message inMessage = exchange.getIn();\n\n        inMessage.setHeader(RestletConstants.RESTLET_REQUEST, request);\n        inMessage.setHeader(RestletConstants.RESTLET_RESPONSE, response);\n\n        // extract headers from restlet\n        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                inMessage.setHeader(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate exchange from Restlet request header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        // copy query string to header\n        String query = request.getResourceRef().getQuery();\n        if (query != null) {\n            inMessage.setHeader(Exchange.HTTP_QUERY, query);\n        }\n\n        // copy URI to header\n        inMessage.setHeader(Exchange.HTTP_URI, request.getResourceRef().getIdentifier(true));\n\n        // copy HTTP method to header\n        inMessage.setHeader(Exchange.HTTP_METHOD, request.getMethod().toString());\n\n        if (!request.isEntityAvailable()) {\n            return;\n        }\n\n        // only deal with the form if the content type is \"application/x-www-form-urlencoded\"\n        if (request.getEntity().getMediaType() != null && request.getEntity().getMediaType().equals(MediaType.APPLICATION_WWW_FORM)) {\n            Form form = new Form(request.getEntity());\n            for (Map.Entry<String, String> entry : form.getValuesMap().entrySet()) {\n                if (entry.getValue() == null) {\n                    inMessage.setBody(entry.getKey());\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Populate exchange from Restlet request body: \" + entry.getValue());\n                    }\n                } else {\n                    if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                        inMessage.setHeader(entry.getKey(), entry.getValue());\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Populate exchange from Restlet request user header: \"\n                                    + entry.getKey() + \" value: \" + entry.getValue());\n                        }\n                    }\n                }\n            }\n        } else {\n            inMessage.setBody(request.getEntity().getStream());\n        }\n\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n        String body = exchange.getIn().getBody(String.class);\n        Form form = new Form();\n        // add the body as the key in the form with null value\n        form.add(body, null);\n\n        MediaType mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            mediaType = MediaType.APPLICATION_WWW_FORM;\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet request from exchange body: \" + body + \" using media type \" + mediaType);\n        }\n\n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n\n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Basic HTTP Authentication has been applied\");\n            }\n        }\n\n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                // Use forms only for GET and POST/x-www-form-urlencoded\n                if (request.getMethod() == Method.GET || (request.getMethod() == Method.POST && mediaType == MediaType.APPLICATION_WWW_FORM)) {\n                    if (entry.getKey().startsWith(\"org.restlet.\")) {\n                        // put the org.restlet headers in attributes\n                        request.getAttributes().put(entry.getKey(), entry.getValue());\n                    } else {\n                        // put the user stuff in the form\n                        form.add(entry.getKey(), entry.getValue().toString());\n                    }\n                } else {\n                    // For non-form post put all the headers in attributes\n                    request.getAttributes().put(entry.getKey(), entry.getValue());\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet request from exchange header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Using Content Type: \" + mediaType + \" for POST data: \" + body);\n        }\n\n        // Only URL Encode for GET and form POST\n        if (request.getMethod() == Method.GET || (request.getMethod() == Method.POST && mediaType == MediaType.APPLICATION_WWW_FORM)) {\n            request.setEntity(form.getWebRepresentation());\n        } else {\n            request.setEntity(body, mediaType);\n        }\n    }","id":47138,"modified_method":"public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n        String body = exchange.getIn().getBody(String.class);\n        Form form = new Form();\n        // add the body as the key in the form with null value\n        form.add(body, null);\n\n        MediaType mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            mediaType = MediaType.APPLICATION_WWW_FORM;\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet request from exchange body: \" + body + \" using media type \" + mediaType);\n        }\n\n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n\n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            LOG.debug(\"Basic HTTP Authentication has been applied\");\n        }\n\n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), exchange)) {\n                // Use forms only for GET and POST/x-www-form-urlencoded\n                if (request.getMethod() == Method.GET || (request.getMethod() == Method.POST && mediaType == MediaType.APPLICATION_WWW_FORM)) {\n                    if (entry.getKey().startsWith(\"org.restlet.\")) {\n                        // put the org.restlet headers in attributes\n                        request.getAttributes().put(entry.getKey(), entry.getValue());\n                    } else {\n                        // put the user stuff in the form\n                        form.add(entry.getKey(), entry.getValue().toString());\n                    }\n                } else {\n                    // For non-form post put all the headers in attributes\n                    request.getAttributes().put(entry.getKey(), entry.getValue());\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet request from exchange header: \"\n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Using Content Type: \" + mediaType + \" for POST data: \" + body);\n        }\n\n        // Only URL Encode for GET and form POST\n        if (request.getMethod() == Method.GET || (request.getMethod() == Method.POST && mediaType == MediaType.APPLICATION_WWW_FORM)) {\n            request.setEntity(form.getWebRepresentation());\n        } else {\n            request.setEntity(body, mediaType);\n        }\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void doStop() throws Exception {\n        ((RestletEndpoint)getEndpoint()).disconnect(this);\n        super.doStop();\n    }","id":47139,"modified_method":"@Override\n    public void doStop() throws Exception {\n        getEndpoint().disconnect(this);\n        super.doStop();\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        ((RestletEndpoint)getEndpoint()).connect(this);\n    }","id":47140,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        getEndpoint().connect(this);\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"public RestletConsumer(Endpoint endpoint, Processor processor) \n        throws Exception {\n        super(endpoint, processor);\n        \n        restlet = new Restlet() {\n            @Override\n            public void handle(Request request, Response response) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Consumer restlet handle request method: \" + request.getMethod());\n                }\n                \n                try {\n                    Exchange exchange = getEndpoint().createExchange();\n                    RestletBinding binding = ((RestletEndpoint)getEndpoint()).getRestletBinding();\n                    binding.populateExchangeFromRestletRequest(request, exchange);\n                    getProcessor().process(exchange);\n                    binding.populateRestletResponseFromExchange(exchange, response);\n                } catch (Exception e) {\n                    throw new RuntimeCamelException(e);\n                }\n            }\n        };\n    }","id":47141,"modified_method":"public RestletConsumer(Endpoint endpoint, Processor processor) \n        throws Exception {\n        super(endpoint, processor);\n        \n        restlet = new Restlet() {\n            @Override\n            public void handle(Request request, Response response) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Consumer restlet handle request method: \" + request.getMethod());\n                }\n                \n                try {\n                    Exchange exchange = getEndpoint().createExchange();\n\n                    RestletBinding binding = getEndpoint().getRestletBinding();\n                    binding.populateExchangeFromRestletRequest(request, response, exchange);\n\n                    try {\n                        getProcessor().process(exchange);\n                    } catch (Exception e) {\n                        exchange.setException(e);\n                    }\n                    binding.populateRestletResponseFromExchange(exchange, response);\n\n                } catch (Exception e) {\n                    throw new RuntimeCamelException(\"Cannot process request\", e);\n                }\n            }\n        };\n    }","commit_id":"e39f8050297585461960938602f06c5bb8257c0a","url":"https://github.com/apache/camel"},{"original_method":"protected void popluateAttachments(HttpServletRequest request, HttpMessage message) {\n        // check if there is multipart files, if so will put it into DataHandler\n        Enumeration names = request.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            Object object = request.getAttribute(name);\n            if (object instanceof File) {\n                String fileName = request.getParameter(name);\n                message.addAttachment(fileName, new DataHandler(new CamelFileDataSource((File)object, fileName)));\n            }\n        }\n    }","id":47142,"modified_method":"protected void populateAttachments(HttpServletRequest request, HttpMessage message) {\n        // check if there is multipart files, if so will put it into DataHandler\n        Enumeration names = request.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            Object object = request.getAttribute(name);\n            if (object instanceof File) {\n                String fileName = request.getParameter(name);\n                message.addAttachment(fileName, new DataHandler(new CamelFileDataSource((File) object, fileName)));\n            }\n        }\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"public void readRequest(HttpServletRequest request, HttpMessage message) {\n\n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getHeader(name);\n            // mapping the content-type \n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n        \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }        \n\n        popluateRequestParameters(request, message);\n        // reset the stream cache\n        StreamCache cache = message.getBody(StreamCache.class);\n        if (cache != null) {\n            cache.reset();\n        }\n        \n        // store the method and query and other info in headers\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n        \n        popluateAttachments(request, message);\n    }","id":47143,"modified_method":"public void readRequest(HttpServletRequest request, HttpMessage message) {\n\n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n\n        //apply the headerFilterStrategy\n        Enumeration names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            Object value = request.getHeader(name);\n            // mapping the content-type \n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                    && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n\n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }\n\n        populateRequestParameters(request, message);\n        // reset the stream cache\n        StreamCache cache = message.getBody(StreamCache.class);\n        if (cache != null) {\n            cache.reset();\n        }\n\n        // store the method and query and other info in headers\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n\n        populateAttachments(request, message);\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"protected void popluateRequestParameters(HttpServletRequest request, HttpMessage message) {\n        //we populate the http request parameters without checking the request method\n        Map<String, Object> headers = message.getHeaders();\n        Enumeration names = request.getParameterNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            Object value = request.getParameter(name);\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n        if (request.getMethod().equals(\"POST\") && request.getContentType() != null && request.getContentType().startsWith(\"application/x-www-form-urlencoded\")) {\n            String charset = request.getCharacterEncoding();\n            if (charset == null) {\n                charset = \"UTF-8\";\n            }\n            // Push POST form params into the headers to retain compatibility with DefaultHttpBinding\n            String body = message.getBody(String.class);\n            try {\n                for (String param : body.split(\"&\")) {\n                    String[] pair = param.split(\"=\", 2);\n                    String name = URLDecoder.decode(pair[0], charset);\n                    String value = URLDecoder.decode(pair[1], charset);\n                    if (headerFilterStrategy != null\n                        && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                        headers.put(name, value);\n                    }\n                }\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }","id":47144,"modified_method":"protected void populateRequestParameters(HttpServletRequest request, HttpMessage message) {\n        //we populate the http request parameters without checking the request method\n        Map<String, Object> headers = message.getHeaders();\n        Enumeration names = request.getParameterNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            Object value = request.getParameter(name);\n            if (headerFilterStrategy != null\n                    && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                headers.put(name, value);\n            }\n        }\n        if (request.getMethod().equals(\"POST\") && request.getContentType() != null\n                && request.getContentType().startsWith(HttpConstants.CONTENT_TYPE_WWW_FORM_URLENCODED)) {\n            String charset = request.getCharacterEncoding();\n            if (charset == null) {\n                charset = \"UTF-8\";\n            }\n            // Push POST form params into the headers to retain compatibility with DefaultHttpBinding\n            String body = message.getBody(String.class);\n            try {\n                for (String param : body.split(\"&\")) {\n                    String[] pair = param.split(\"=\", 2);\n                    String name = URLDecoder.decode(pair[0], charset);\n                    String value = URLDecoder.decode(pair[1], charset);\n                    if (headerFilterStrategy != null\n                            && !headerFilterStrategy.applyFilterToExternalHeaders(name, value, message.getExchange())) {\n                        headers.put(name, value);\n                    }\n                }\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"public void doWriteExceptionResponse(Throwable exception, HttpServletResponse response) throws IOException {\n        response.setStatus(500); // 500 for internal server error\n        response.setContentType(\"text/plain\");\n\n        // append the stacktrace as response\n        PrintWriter pw = response.getWriter();\n        exception.printStackTrace(pw);\n\n        pw.flush();\n    }","id":47145,"modified_method":"public void doWriteExceptionResponse(Throwable exception, HttpServletResponse response) throws IOException {\n        // 500 for internal server error\n        response.setStatus(500);\n        if (endpoint != null && endpoint.isTransferException()) {\n            // transfer the exception as a serialized java object\n            response.setContentType(HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT);\n            ObjectOutputStream oos = new ObjectOutputStream(response.getOutputStream());\n            oos.writeObject(exception);\n            oos.flush();\n            IOHelper.close(oos);\n        } else {\n            // write stacktrace as plain text\n            response.setContentType(\"text/plain\");\n            PrintWriter pw = response.getWriter();\n            exception.printStackTrace(pw);\n            pw.flush();\n        }\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = uri;\n        if (!uri.startsWith(\"http4:\") && !uri.startsWith(\"https4:\")) {\n            addressUri = remaining;\n        }\n        Map<String, Object> httpClientParameters = new HashMap<String, Object>(parameters);\n        // http client can be configured from URI options\n        HttpParams clientParams = configureHttpParams(parameters);\n\n        // must extract well known parameters before we create the endpoint\n        HttpBinding binding = resolveAndRemoveReferenceParameter(parameters, \"httpBindingRef\", HttpBinding.class);\n        if (binding == null) {\n            // try without ref\n            binding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        }\n        Boolean throwExceptionOnFailure = getAndRemoveParameter(parameters, \"throwExceptionOnFailure\", Boolean.class);\n        Boolean bridgeEndpoint = getAndRemoveParameter(parameters, \"bridgeEndpoint\", Boolean.class);\n        Boolean matchOnUriPrefix = getAndRemoveParameter(parameters, \"matchOnUriPrefix\", Boolean.class);\n        Boolean disableStreamCache = getAndRemoveParameter(parameters, \"disableStreamCache\", Boolean.class);\n\n        // validate that we could resolve all httpClient. parameters as this component is lenient\n        validateParameters(uri, parameters, \"httpClient.\");\n        // create the configurer to use for this endpoint\n        HttpClientConfigurer configurer = createHttpClientConfigurer(parameters);\n        URI endpointUri = URISupport.createRemainingURI(new URI(addressUri), CastUtils.cast(httpClientParameters));\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), CastUtils.cast(parameters));\n        \n        // validate http uri that end-user did not duplicate the http part that can be a common error\n        String part = httpUri.getSchemeSpecificPart();\n        if (part != null) {\n            part = part.toLowerCase();\n            if (part.startsWith(\"//http//\") || part.startsWith(\"//https//\")) {\n                throw new ResolveEndpointFailedException(uri,\n                        \"The uri part is not configured correctly. You have duplicated the http(s) protocol.\");\n            }\n        }\n\n        // register port on schema registry\n        boolean secure = isSecureConnection(uri);\n        int port = getPort(httpUri);\n        registerPort(secure, port);\n\n        // create the endpoint\n        HttpEndpoint endpoint = new HttpEndpoint(endpointUri.toString(), this, httpUri, clientParams, clientConnectionManager, configurer);\n        setEndpointHeaderFilterStrategy(endpoint);\n\n        // prefer to use endpoint configured over component configured\n        if (binding == null) {\n            // fallback to component configured\n            binding = getHttpBinding();\n        }\n        if (binding != null) {\n            endpoint.setBinding(binding);\n        }\n        // should we use an exception for failed error codes?\n        if (throwExceptionOnFailure != null) {\n            endpoint.setThrowExceptionOnFailure(throwExceptionOnFailure);\n        }\n        if (bridgeEndpoint != null) {\n            endpoint.setBridgeEndpoint(bridgeEndpoint);\n        }\n        if (matchOnUriPrefix != null) {\n            endpoint.setMatchOnUriPrefix(matchOnUriPrefix);\n        }\n        if (disableStreamCache != null) {\n            endpoint.setDisableStreamCache(disableStreamCache);\n        }\n\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","id":47146,"modified_method":"@Override\n    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n        String addressUri = uri;\n        if (!uri.startsWith(\"http4:\") && !uri.startsWith(\"https4:\")) {\n            addressUri = remaining;\n        }\n        Map<String, Object> httpClientParameters = new HashMap<String, Object>(parameters);\n        // http client can be configured from URI options\n        HttpParams clientParams = configureHttpParams(parameters);\n\n        // must extract well known parameters before we create the endpoint\n        HttpBinding binding = resolveAndRemoveReferenceParameter(parameters, \"httpBindingRef\", HttpBinding.class);\n        if (binding == null) {\n            // try without ref\n            binding = resolveAndRemoveReferenceParameter(parameters, \"httpBinding\", HttpBinding.class);\n        }\n        Boolean throwExceptionOnFailure = getAndRemoveParameter(parameters, \"throwExceptionOnFailure\", Boolean.class);\n        Boolean transferException = getAndRemoveParameter(parameters, \"transferException\", Boolean.class);\n        Boolean bridgeEndpoint = getAndRemoveParameter(parameters, \"bridgeEndpoint\", Boolean.class);\n        Boolean matchOnUriPrefix = getAndRemoveParameter(parameters, \"matchOnUriPrefix\", Boolean.class);\n        Boolean disableStreamCache = getAndRemoveParameter(parameters, \"disableStreamCache\", Boolean.class);\n\n        // validate that we could resolve all httpClient. parameters as this component is lenient\n        validateParameters(uri, parameters, \"httpClient.\");\n        // create the configurer to use for this endpoint\n        HttpClientConfigurer configurer = createHttpClientConfigurer(parameters);\n        URI endpointUri = URISupport.createRemainingURI(new URI(addressUri), CastUtils.cast(httpClientParameters));\n        // restructure uri to be based on the parameters left as we dont want to include the Camel internal options\n        URI httpUri = URISupport.createRemainingURI(new URI(addressUri), CastUtils.cast(parameters));\n\n        // validate http uri that end-user did not duplicate the http part that can be a common error\n        String part = httpUri.getSchemeSpecificPart();\n        if (part != null) {\n            part = part.toLowerCase();\n            if (part.startsWith(\"//http//\") || part.startsWith(\"//https//\")) {\n                throw new ResolveEndpointFailedException(uri,\n                        \"The uri part is not configured correctly. You have duplicated the http(s) protocol.\");\n            }\n        }\n\n        // register port on schema registry\n        boolean secure = isSecureConnection(uri);\n        int port = getPort(httpUri);\n        registerPort(secure, port);\n\n        // create the endpoint\n        HttpEndpoint endpoint = new HttpEndpoint(endpointUri.toString(), this, httpUri, clientParams, clientConnectionManager, configurer);\n        setEndpointHeaderFilterStrategy(endpoint);\n\n        // prefer to use endpoint configured over component configured\n        if (binding == null) {\n            // fallback to component configured\n            binding = getHttpBinding();\n        }\n        if (binding != null) {\n            endpoint.setBinding(binding);\n        }\n        // should we use an exception for failed error codes?\n        if (throwExceptionOnFailure != null) {\n            endpoint.setThrowExceptionOnFailure(throwExceptionOnFailure);\n        }\n        // should we transfer exception as serialized object\n        if (transferException != null) {\n            endpoint.setTransferException(transferException);\n        }\n        if (bridgeEndpoint != null) {\n            endpoint.setBridgeEndpoint(bridgeEndpoint);\n        }\n        if (matchOnUriPrefix != null) {\n            endpoint.setMatchOnUriPrefix(matchOnUriPrefix);\n        }\n        if (disableStreamCache != null) {\n            endpoint.setDisableStreamCache(disableStreamCache);\n        }\n\n        setProperties(endpoint, parameters);\n        return endpoint;\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"public HttpBinding getBinding() {\n        if (binding == null) {\n            binding = new DefaultHttpBinding(getHeaderFilterStrategy());\n        }\n        return binding;\n    }","id":47147,"modified_method":"public HttpBinding getBinding() {\n        if (binding == null) {\n            binding = new DefaultHttpBinding(this);\n        }\n        return binding;\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        if (((HttpEndpoint)getEndpoint()).isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n        }\n        HttpRequestBase httpRequest = createMethod(exchange);\n        Message in = exchange.getIn();\n        String httpProtocolVersion = in.getHeader(Exchange.HTTP_PROTOCOL_VERSION, String.class);\n        if (httpProtocolVersion != null) {\n            // set the HTTP protocol version\n            httpRequest.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpProducerHelper.parserHttpVersion(httpProtocolVersion));\n        }\n        HeaderFilterStrategy strategy = getEndpoint().getHeaderFilterStrategy();\n\n        // propagate headers as HTTP headers\n        for (Map.Entry<String, Object> entry : in.getHeaders().entrySet()) {\n            String headerValue = in.getHeader(entry.getKey(), String.class);\n            if (strategy != null && !strategy.applyFilterToCamelHeaders(entry.getKey(), headerValue, exchange)) {\n                httpRequest.addHeader(entry.getKey(), headerValue);\n            }\n        }\n        \n        // lets store the result in the output message.\n        HttpResponse httpResponse = null;\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Executing http \" + httpRequest.getMethod() + \" method: \" + httpRequest.getURI().toString());\n            }\n            httpResponse = executeMethod(httpRequest);\n            int responseCode = httpResponse.getStatusLine().getStatusCode();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Http responseCode: \" + responseCode);\n            }\n\n            if (throwException && (responseCode < 100 || responseCode >= 300)) {\n                throw populateHttpOperationFailedException(exchange, httpRequest, httpResponse, responseCode);\n            } else {\n                populateResponse(exchange, httpRequest, httpResponse, in, strategy, responseCode);\n            }\n        } finally {\n            if (httpResponse != null && httpResponse.getEntity() != null) {\n                try {\n                    httpResponse.getEntity().consumeContent();\n                } catch (IOException e) {\n                    // nothing we could do\n                }\n            }\n        }\n    }","id":47148,"modified_method":"public void process(Exchange exchange) throws Exception {\n        if (getEndpoint().isBridgeEndpoint()) {\n            exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n        }\n        HttpRequestBase httpRequest = createMethod(exchange);\n        Message in = exchange.getIn();\n        String httpProtocolVersion = in.getHeader(Exchange.HTTP_PROTOCOL_VERSION, String.class);\n        if (httpProtocolVersion != null) {\n            // set the HTTP protocol version\n            httpRequest.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpProducerHelper.parserHttpVersion(httpProtocolVersion));\n        }\n        HeaderFilterStrategy strategy = getEndpoint().getHeaderFilterStrategy();\n\n        // propagate headers as HTTP headers\n        for (Map.Entry<String, Object> entry : in.getHeaders().entrySet()) {\n            String headerValue = in.getHeader(entry.getKey(), String.class);\n            if (strategy != null && !strategy.applyFilterToCamelHeaders(entry.getKey(), headerValue, exchange)) {\n                httpRequest.addHeader(entry.getKey(), headerValue);\n            }\n        }\n\n        // lets store the result in the output message.\n        HttpResponse httpResponse = null;\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Executing http \" + httpRequest.getMethod() + \" method: \" + httpRequest.getURI().toString());\n            }\n            httpResponse = executeMethod(httpRequest);\n            int responseCode = httpResponse.getStatusLine().getStatusCode();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Http responseCode: \" + responseCode);\n            }\n\n            if (throwException && (responseCode < 100 || responseCode >= 300)) {\n                throw populateHttpOperationFailedException(exchange, httpRequest, httpResponse, responseCode);\n            } else {\n                populateResponse(exchange, httpRequest, httpResponse, in, strategy, responseCode);\n            }\n        } finally {\n            if (httpResponse != null && httpResponse.getEntity() != null) {\n                try {\n                    httpResponse.getEntity().consumeContent();\n                } catch (IOException e) {\n                    // nothing we could do\n                }\n            }\n        }\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Extracts the response from the method as a InputStream.\n     *\n     * @param httpRequest the method that was executed\n     * @return the response as a stream\n     * @throws IOException can be thrown\n     */\n    protected static InputStream extractResponseBody(HttpRequestBase httpRequest, HttpResponse httpResponse, Exchange exchange) throws IOException {\n        HttpEntity entity = httpResponse.getEntity();\n        if (entity == null) {\n            return null;\n        }\n\n        InputStream is = entity.getContent();\n        if (is == null) {\n            return null;\n        }\n\n        Header header = httpResponse.getFirstHeader(Exchange.CONTENT_ENCODING);\n        String contentEncoding = header != null ? header.getValue() : null;\n\n        if (!exchange.getProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.FALSE, Boolean.class)) {\n            is = GZIPHelper.uncompressGzip(contentEncoding, is);\n        }\n        // Honor the character encoding\n        header = httpRequest.getFirstHeader(\"content-type\");\n        if (header != null) {\n            String contentType = header.getValue();\n            // find the charset and set it to the Exchange\n            HttpHelper.setCharsetFromContentType(contentType, exchange);\n        }\n        return doExtractResponseBody(is, exchange);\n    }","id":47149,"modified_method":"/**\n     * Extracts the response from the method as a InputStream.\n     *\n     * @param httpRequest the method that was executed\n     * @return the response either as a stream, or as a deserialized java object\n     * @throws IOException can be thrown\n     */\n    protected static Object extractResponseBody(HttpRequestBase httpRequest, HttpResponse httpResponse, Exchange exchange) throws IOException, ClassNotFoundException {\n        HttpEntity entity = httpResponse.getEntity();\n        if (entity == null) {\n            return null;\n        }\n\n        InputStream is = entity.getContent();\n        if (is == null) {\n            return null;\n        }\n\n        Header header = httpResponse.getFirstHeader(Exchange.CONTENT_ENCODING);\n        String contentEncoding = header != null ? header.getValue() : null;\n\n        if (!exchange.getProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.FALSE, Boolean.class)) {\n            is = GZIPHelper.uncompressGzip(contentEncoding, is);\n        }\n        // Honor the character encoding\n        String contentType = null;\n        header = httpRequest.getFirstHeader(\"content-type\");\n        if (header != null) {\n            contentType = header.getValue();\n            // find the charset and set it to the Exchange\n            HttpHelper.setCharsetFromContentType(contentType, exchange);\n        }\n        InputStream response = doExtractResponseBodyAsStream(is, exchange);\n        if (contentType != null && contentType.equals(HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT)) {\n            return doDeserializeJavaObjectFromResponse(response);\n        } else {\n            return response;\n        }\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"private static InputStream doExtractResponseBody(InputStream is, Exchange exchange) throws IOException {\n        // As httpclient is using a AutoCloseInputStream, it will be closed when the connection is closed\n        // we need to cache the stream for it.\n        try {\n            // This CachedOutputStream will not be closed when the exchange is onCompletion\n            CachedOutputStream cos = new CachedOutputStream(exchange, false);\n            IOHelper.copy(is, cos);\n            // When the InputStream is closed, the CachedOutputStream will be closed\n            return cos.getWrappedInputStream();\n        } finally {\n            IOHelper.close(is, \"Extracting response body\", LOG);\n        }\n    }","id":47150,"modified_method":"private static InputStream doExtractResponseBodyAsStream(InputStream is, Exchange exchange) throws IOException {\n        // As httpclient is using a AutoCloseInputStream, it will be closed when the connection is closed\n        // we need to cache the stream for it.\n        try {\n            // This CachedOutputStream will not be closed when the exchange is onCompletion\n            CachedOutputStream cos = new CachedOutputStream(exchange, false);\n            IOHelper.copy(is, cos);\n            // When the InputStream is closed, the CachedOutputStream will be closed\n            return cos.getWrappedInputStream();\n        } finally {\n            IOHelper.close(is, \"Extracting response body\", LOG);\n        }\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"protected HttpOperationFailedException populateHttpOperationFailedException(Exchange exchange, HttpRequestBase httpRequest, HttpResponse httpResponse, int responseCode) throws IOException {\n        HttpOperationFailedException exception;\n        String uri = httpRequest.getURI().toString();\n        String statusText = httpResponse.getStatusLine() != null ? httpResponse.getStatusLine().getReasonPhrase() : null;\n        Map<String, String> headers = extractResponseHeaders(httpResponse.getAllHeaders());\n        InputStream is = extractResponseBody(httpRequest, httpResponse, exchange);\n        // make a defensive copy of the response body in the exception so its detached from the cache\n        String copy = null;\n        if (is != null) {\n            copy = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, is);\n        }\n\n        Header locationHeader = httpResponse.getFirstHeader(\"location\");\n        if (locationHeader != null && (responseCode >= 300 && responseCode < 400)) {\n            exception = new HttpOperationFailedException(uri, responseCode, statusText, locationHeader.getValue(), headers, copy);\n        } else {\n            exception = new HttpOperationFailedException(uri, responseCode, statusText, null, headers, copy);\n        }\n\n        return exception;\n    }","id":47151,"modified_method":"protected Exception populateHttpOperationFailedException(Exchange exchange, HttpRequestBase httpRequest, HttpResponse httpResponse, int responseCode) throws IOException, ClassNotFoundException {\n        Exception answer;\n\n        String uri = httpRequest.getURI().toString();\n        String statusText = httpResponse.getStatusLine() != null ? httpResponse.getStatusLine().getReasonPhrase() : null;\n        Map<String, String> headers = extractResponseHeaders(httpResponse.getAllHeaders());\n\n        Object responseBody = extractResponseBody(httpRequest, httpResponse, exchange);\n        if (transferException && responseBody != null && responseBody instanceof Exception) {\n            // if the response was a serialized exception then use that\n            return (Exception) responseBody;\n        }\n\n        // make a defensive copy of the response body in the exception so its detached from the cache\n        String copy = null;\n        if (responseBody != null) {\n            copy = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, responseBody);\n        }\n\n        Header locationHeader = httpResponse.getFirstHeader(\"location\");\n        if (locationHeader != null && (responseCode >= 300 && responseCode < 400)) {\n            answer = new HttpOperationFailedException(uri, responseCode, statusText, locationHeader.getValue(), headers, copy);\n        } else {\n            answer = new HttpOperationFailedException(uri, responseCode, statusText, null, headers, copy);\n        }\n\n        return answer;\n    }","commit_id":"8ef30e395e683c6c5bbbeaeeb72fd02f1bfa9d84","url":"https://github.com/apache/camel"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected void onBeforeRender()\n\t{\n\t\tif (tabs.size() == 0)\n\t\t{\n\t\t\t// force an empty container to be created every time if we have no tabs\n\t\t\tsetSelectedTab(0);\n\t\t}\n\t\telse if ((getSelectedTab() == -1) || (isTabVisible(getSelectedTab()) == false))\n\t\t{\n\t\t\t// find first visible selected tab\n\t\t\tint selected = 0;\n\t\t\tfor (int i = 0; i < tabs.size(); i++)\n\t\t\t{\n\t\t\t\tif (isTabVisible(i))\n\t\t\t\t{\n\t\t\t\t\tselected = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selected == tabs.size())\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * none of the tabs are selected...\n\t\t\t\t * \n\t\t\t\t * we do not need to do anything special because the check in setSelectedTab() will\n\t\t\t\t * replace the current tab panel with an empty one\n\t\t\t\t */\n\t\t\t\tselected = 0;\n\t\t\t}\n\n\t\t\tsetSelectedTab(selected);\n\t\t}\n\n\t\tsuper.onBeforeRender();\n\t}","id":47152,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tprotected void onBeforeRender()\n\t{\n\t\tint index = getSelectedTab();\n\n\t\tif (index == -1 || isTabVisible(index) == false)\n\t\t{\n\t\t\t// find first visible selected tab\n\t\t\tindex = 0;\n\t\t\tfor (int i = 0; i < tabs.size(); i++)\n\t\t\t{\n\t\t\t\tif (isTabVisible(i))\n\t\t\t\t{\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (index == tabs.size())\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * none of the tabs are selected...\n\t\t\t\t */\n\t\t\t\tindex = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsetModelObject(index);\n\t\t\t}\n\t\t}\n\n\t\t// updating the tab will do no harm if the index hasn't changed\n\t\tupdateTab(index);\n\n\t\tsuper.onBeforeRender();\n\t}","commit_id":"bf96810d00d0eb916a0425dc413afef6f2fb5b57","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            component id\n\t * @param tabs\n\t *            list of ITab objects used to represent tabs\n\t */\n\tpublic TabbedPanel(final String id, final List<T> tabs)\n\t{\n\t\tsuper(id, new Model<Integer>(-1));\n\n\t\tthis.tabs = Args.notNull(tabs, \"tabs\");\n\n\t\tfinal IModel<Integer> tabCount = new AbstractReadOnlyModel<Integer>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Integer getObject()\n\t\t\t{\n\t\t\t\treturn TabbedPanel.this.tabs.size();\n\t\t\t}\n\t\t};\n\n\t\tWebMarkupContainer tabsContainer = newTabsContainer(\"tabs-container\");\n\t\tadd(tabsContainer);\n\n\t\t// add the loop used to generate tab names\n\t\ttabsContainer.add(new Loop(\"tabs\", tabCount)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final LoopItem item)\n\t\t\t{\n\t\t\t\tfinal int index = item.getIndex();\n\t\t\t\tfinal T tab = TabbedPanel.this.tabs.get(index);\n\n\t\t\t\tfinal WebMarkupContainer titleLink = newLink(\"link\", index);\n\n\t\t\t\ttitleLink.add(newTitle(\"title\", tab.getTitle(), index));\n\t\t\t\titem.add(titleLink);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected LoopItem newItem(final int iteration)\n\t\t\t{\n\t\t\t\treturn newTabContainer(iteration);\n\t\t\t}\n\t\t});\n\t}","id":47153,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            component id\n\t * @param tabs\n\t *            list of ITab objects used to represent tabs\n\t */\n\tpublic TabbedPanel(final String id, final List<T> tabs)\n\t{\n\t\tthis(id, tabs, null);\n\t}","commit_id":"bf96810d00d0eb916a0425dc413afef6f2fb5b57","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * sets the selected tab\n\t * \n\t * @param index\n\t *            index of the tab to select\n\t * @return this for chaining\n\t */\n\tpublic TabbedPanel setSelectedTab(final int index)\n\t{\n\t\tif ((index < 0) || ((index >= tabs.size()) && (index > 0)))\n\t\t{\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\n\t\tsetDefaultModelObject(index);\n\n\t\tfinal Component component;\n\n\t\tif ((tabs.size() == 0) || !isTabVisible(index))\n\t\t{\n\t\t\t// no tabs or the currently selected tab is not visible\n\t\t\tcomponent = new WebMarkupContainer(TAB_PANEL_ID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// show panel from selected tab\n\t\t\tT tab = tabs.get(index);\n\t\t\tcomponent = tab.getPanel(TAB_PANEL_ID);\n\t\t\tif (component == null)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"ITab.getPanel() returned null. TabbedPanel [\" +\n\t\t\t\t\tgetPath() + \"] ITab index [\" + index + \"]\");\n\t\t\t}\n\t\t}\n\n\t\tif (!component.getId().equals(TAB_PANEL_ID))\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\"ITab.getPanel() returned a panel with invalid id [\" +\n\t\t\t\t\tcomponent.getId() +\n\t\t\t\t\t\"]. You must always return a panel with id equal to the provided panelId parameter. TabbedPanel [\" +\n\t\t\t\t\tgetPath() + \"] ITab index [\" + index + \"]\");\n\t\t}\n\n\t\taddOrReplace(component);\n\n\t\treturn this;\n\t}","id":47154,"modified_method":"/**\n\t * sets the selected tab\n\t * \n\t * @param index\n\t *            index of the tab to select\n\t * @return this for chaining\n\t */\n\tpublic TabbedPanel<T> setSelectedTab(int index)\n\t{\n\t\tif (index < 0 || index >= tabs.size())\n\t\t{\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\n\t\tsetModelObject(index);\n\n\t\tupdateTab(index);\n\n\t\treturn this;\n\t}","commit_id":"bf96810d00d0eb916a0425dc413afef6f2fb5b57","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t */\n\tpublic TabbedPanelPage()\n\t{\n\t\tsetDefaultModel(new Model<String>(\"tabpanel\"));\n\n\t\t// create links used to switch between css variations\n\t\taddCssSwitchingLinks();\n\n\t\t// create a list of ITab objects used to feed the tabbed panel\n\t\tList<ITab> tabs = new ArrayList<ITab>();\n\t\ttabs.add(new AbstractTab(new Model<String>(\"first tab\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Panel getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TabPanel1(panelId);\n\t\t\t}\n\n\t\t});\n\n\t\ttabs.add(new AbstractTab(new Model<String>(\"second tab\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Panel getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TabPanel2(panelId);\n\t\t\t}\n\n\t\t});\n\n\t\ttabs.add(new AbstractTab(new Model<String>(\"third tab\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Panel getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TabPanel3(panelId);\n\t\t\t}\n\n\t\t});\n\n\t\t// add the new tabbed panel, attribute modifier only used to switch\n\t\t// between different css variations\n\t\tadd(new TabbedPanel(\"tabs\", tabs).add(AttributeModifier.replace(\"class\",\n\t\t\tTabbedPanelPage.this.getDefaultModel())));\n\n\t}","id":47155,"modified_method":"/**\n\t * Constructor\n\t */\n\tpublic TabbedPanelPage()\n\t{\n\t\tsetDefaultModel(new Model<String>(\"tabpanel\"));\n\n\t\t// create links used to switch between css variations\n\t\taddCssSwitchingLinks();\n\n\t\t// create a list of ITab objects used to feed the tabbed panel\n\t\tfinal List<ITab> tabs = new ArrayList<ITab>();\n\t\ttabs.add(new AbstractTab(new Model<String>(\"first tab\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Panel getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TabPanel1(panelId);\n\t\t\t}\n\n\t\t});\n\n\t\ttabs.add(new AbstractTab(new Model<String>(\"second tab\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Panel getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TabPanel2(panelId);\n\t\t\t}\n\n\t\t});\n\n\t\ttabs.add(new AbstractTab(new Model<String>(\"third tab\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic Panel getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TabPanel3(panelId);\n\t\t\t}\n\n\t\t});\n\n\t\t// add the new tabbed panel, attribute modifier only used to switch\n\t\t// between different css variations\n\t\tfinal TabbedPanel<ITab> tabbedPanel = new TabbedPanel<ITab>(\"tabs\", tabs);\n\t\ttabbedPanel.add(AttributeModifier.replace(\"class\", TabbedPanelPage.this.getDefaultModel()));\n\t\tadd(tabbedPanel);\n\n\t\tadd(new Link<Void>(\"skip\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onClick()\n\t\t\t{\n\t\t\t\tint index = tabbedPanel.getModelObject();\n\n\t\t\t\ttabbedPanel.setModelObject((index + 1) % tabs.size());\n\t\t\t}\n\t\t});\n\t}","commit_id":"bf96810d00d0eb916a0425dc413afef6f2fb5b57","url":"https://github.com/apache/wicket"},{"original_method":"@Test\n\tpublic void renderDefaultTabsOnly() throws Exception\n\t{\n\t\ttester.startPage(new TestPage());\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">default 1<\/span><\/a>\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"label\\\">default 1<\/span>\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">default 2<\/span><\/a>\");\n\t\ttester.clickLink(\"tabpanel:tabs-container:tabs:1:link\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"label\\\">default 2<\/span>\");\n\t}","id":47156,"modified_method":"@Test\n\tpublic void renderDefaultTabsOnly() throws Exception\n\t{\n\t\tTestPage page = tester.startPage(new TestPage());\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">default 1<\/span><\/a>\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"label\\\">default 1<\/span>\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">default 2<\/span><\/a>\");\n\n\t\tassertEquals(Integer.valueOf(0), page.tabbedPanel.getModelObject());\n\n\t\ttester.clickLink(\"tabpanel:tabs-container:tabs:1:link\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"label\\\">default 2<\/span>\");\n\n\t\tassertEquals(Integer.valueOf(1), page.tabbedPanel.getModelObject());\n\t}","commit_id":"bf96810d00d0eb916a0425dc413afef6f2fb5b57","url":"https://github.com/apache/wicket"},{"original_method":"@Test\n\tpublic void renderAdditionalTabs() throws Exception\n\t{\n\t\tTestPage page = (TestPage)tester.startPage(new TestPage());\n\t\tpage.tabbedPanel.getTabs().add(new AbstractTab(Model.of(\"added 1\"))\n\t\t{\n\t\t\t@Override\n\t\t\tpublic WebMarkupContainer getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TestPanel(panelId, \"added 1\");\n\t\t\t}\n\t\t});\n\t\t// the additional tab isn't rendered yet\n\t\ttester.assertContainsNot(\"<span wicket:id=\\\"title\\\">added 1<\/span><\/a>\");\n\t\ttester.assertContainsNot(\"<span wicket:id=\\\"label\\\">added 1<\/span>\");\n\n\t\t// now its title is visible, but the contents not\n\t\ttester.clickLink(\"tabpanel:tabs-container:tabs:1:link\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">added 1<\/span><\/a>\");\n\t\ttester.assertContainsNot(\"<span wicket:id=\\\"label\\\">added 1<\/span>\");\n\n\t\t// now the entire panel should be there\n\t\ttester.clickLink(\"tabpanel:tabs-container:tabs:2:link\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">added 1<\/span><\/a>\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"label\\\">added 1<\/span>\");\n\t}","id":47157,"modified_method":"@Test\n\tpublic void renderAdditionalTabs() throws Exception\n\t{\n\t\tTestPage page = tester.startPage(new TestPage());\n\t\tpage.tabbedPanel.getTabs().add(new AbstractTab(Model.of(\"added 1\"))\n\t\t{\n\t\t\t@Override\n\t\t\tpublic WebMarkupContainer getPanel(String panelId)\n\t\t\t{\n\t\t\t\treturn new TestPanel(panelId, \"added 1\");\n\t\t\t}\n\t\t});\n\t\t// the additional tab isn't rendered yet\n\t\ttester.assertContainsNot(\"<span wicket:id=\\\"title\\\">added 1<\/span><\/a>\");\n\t\ttester.assertContainsNot(\"<span wicket:id=\\\"label\\\">added 1<\/span>\");\n\n\t\tassertEquals(Integer.valueOf(0), page.tabbedPanel.getModelObject());\n\n\t\t// now its title is visible, but the contents not\n\t\ttester.clickLink(\"tabpanel:tabs-container:tabs:1:link\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">added 1<\/span><\/a>\");\n\t\ttester.assertContainsNot(\"<span wicket:id=\\\"label\\\">added 1<\/span>\");\n\n\t\tassertEquals(Integer.valueOf(1), page.tabbedPanel.getModelObject());\n\n\t\t// now the entire panel should be there\n\t\ttester.clickLink(\"tabpanel:tabs-container:tabs:2:link\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"title\\\">added 1<\/span><\/a>\");\n\t\ttester.assertContains(\"<span wicket:id=\\\"label\\\">added 1<\/span>\");\n\n\t\tassertEquals(Integer.valueOf(2), page.tabbedPanel.getModelObject());\n\t}","commit_id":"bf96810d00d0eb916a0425dc413afef6f2fb5b57","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected String getModelValue()\n\t{\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tfinal Collection<T> ts = getModelObject();\n\n\t\tvisitChildren(Check.class, new IVisitor<Check<T>, Void>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void component(Check<T> check, IVisit<Void> visit)\n\t\t\t{\n\t\t\t\tif (ts.contains(check.getModelObject()))\n\t\t\t\t{\n\t\t\t\t\tif (builder.length() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuilder.append(VALUE_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.append(check.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn builder.toString();\n\t}","id":47158,"modified_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\t@Override\n\tprotected String getModelValue()\n\t{\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tfinal Collection<T> ts = getModelObject();\n\n\t\tvisitChildren(Check.class, new IVisitor<Check<T>, Void>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void component(Check<T> check, IVisit<Void> visit)\n\t\t\t{\n\t\t\t\tif (ts.contains(check.getModelObject()))\n\t\t\t\t{\n\t\t\t\t\tif (builder.length() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuilder.append(VALUE_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.append(check.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn builder.toString();\n\t}","commit_id":"c9845b23802c461ff8ec486fbbc33a18457a5788","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test page for FormTester.select()\n\t * \n\t * @param candidateChoices\n\t */\n\tpublic ChoicePage(List<Book> candidateChoices)\n\t{\n\t\tChoiceRenderer<Book> bookChoiceRenderer = new ChoiceRenderer<Book>(\"name\", \"id\");\n\n\t\tForm<ChoicePage> form = new Form<ChoicePage>(\"choiceForm\");\n\t\tadd(form);\n\n\t\tform.setDefaultModel(new CompoundPropertyModel<ChoicePage>(this));\n\n\t\t// setting initial values\n\t\tdropDownChoice = candidateChoices.get(1);\n\t\tlistChoice = candidateChoices.get(3);\n\t\tradioChoice = candidateChoices.get(2);\n\t\tcheckBox = true;\n\t\tinitialListMultipleChoice.add(candidateChoices.get(1));\n\t\tinitialListMultipleChoice.add(candidateChoices.get(2));\n\t\tinitialCheckBoxMultipleChoice.add(candidateChoices.get(0));\n\t\tinitialCheckBoxMultipleChoice.add(candidateChoices.get(3));\n\t\tinitialCheckGroup.add(candidateChoices.get(2));\n\t\tinitialCheckGroup.add(candidateChoices.get(3));\n\n\t\t// single select family\n\t\tform.add(new DropDownChoice<Book>(\"dropDownChoice\", candidateChoices, bookChoiceRenderer));\n\t\tform.add(new ListChoice<Book>(\"listChoice\", candidateChoices, bookChoiceRenderer).setMaxRows(4));\n\t\tform.add(new RadioChoice<Book>(\"radioChoice\", candidateChoices, bookChoiceRenderer));\n\t\tform.add(new CheckBox(\"checkBox\"));\n\t\tform.add(newRadioGroup(candidateChoices));\n\n\t\t// multiple select family\n\t\tform.add(new ListMultipleChoice<Book>(\"initialListMultipleChoice\", candidateChoices,\n\t\t\tbookChoiceRenderer));\n\t\tform.add(new CheckBoxMultipleChoice<Book>(\"initialCheckBoxMultipleChoice\",\n\t\t\tcandidateChoices, bookChoiceRenderer));\n\t\tform.add(newCheckGroup(\"initialCheckGroup\", candidateChoices));\n\t\tform.add(new ListMultipleChoice<Book>(\"listMultipleChoice\", candidateChoices,\n\t\t\tbookChoiceRenderer).setMaxRows(4));\n\t\tform.add(new CheckBoxMultipleChoice<Book>(\"checkBoxMultipleChoice\", candidateChoices,\n\t\t\tbookChoiceRenderer));\n\t\tform.add(newCheckGroup(\"checkGroup\", candidateChoices));\n\t\tform.add(new Button(\"anotherButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onSubmit()\n\t\t\t{\n\t\t\t\tanotherButtonPressed = true;\n\t\t\t}\n\t\t});\n\t}","id":47159,"modified_method":"/**\n\t * Test page for FormTester.select()\n\t * \n\t * @param candidateChoices\n\t */\n\tpublic ChoicePage(List<Book> candidateChoices)\n\t{\n\t\tChoiceRenderer<Book> bookChoiceRenderer = new ChoiceRenderer<Book>(\"name\", \"id\");\n\n\t\tForm<ChoicePage> form = new Form<ChoicePage>(\"choiceForm\");\n\t\tadd(form);\n\n\t\tform.setDefaultModel(new CompoundPropertyModel<ChoicePage>(this));\n\n\t\t// setting initial values\n\t\tdropDownChoice = candidateChoices.get(1);\n\t\tlistChoice = candidateChoices.get(3);\n\t\tradioChoice = candidateChoices.get(2);\n\t\tcheckBox = true;\n\t\tinitialListMultipleChoice.add(candidateChoices.get(1));\n\t\tinitialListMultipleChoice.add(candidateChoices.get(2));\n\t\tinitialCheckBoxMultipleChoice.add(candidateChoices.get(0));\n\t\tinitialCheckBoxMultipleChoice.add(candidateChoices.get(3));\n\t\tinitialCheckGroup.add(candidateChoices.get(2));\n\t\tinitialCheckGroup.add(candidateChoices.get(3));\n\n\t\t// single select family\n\t\tform.add(new DropDownChoice<Book>(\"dropDownChoice\", candidateChoices, bookChoiceRenderer));\n\t\tform.add(new ListChoice<Book>(\"listChoice\", candidateChoices, bookChoiceRenderer).setMaxRows(4));\n\t\tform.add(new RadioChoice<Book>(\"radioChoice\", candidateChoices, bookChoiceRenderer));\n\t\tform.add(new CheckBox(\"checkBox\"));\n\t\tform.add(newRadioGroup(candidateChoices));\n\n\t\t// multiple select family\n\t\tform.add(new ListMultipleChoice<Book>(\"initialListMultipleChoice\", candidateChoices,\n\t\t\tbookChoiceRenderer));\n\t\tform.add(new CheckBoxMultipleChoice<Book>(\"initialCheckBoxMultipleChoice\",\n\t\t\tcandidateChoices, bookChoiceRenderer));\n\t\tform.add(newCheckGroup(\"initialCheckGroup\", candidateChoices));\n\t\tform.add(new ListMultipleChoice<Book>(\"listMultipleChoice\", candidateChoices,\n\t\t\tbookChoiceRenderer).setMaxRows(4));\n\t\tform.add(new CheckBoxMultipleChoice<Book>(\"checkBoxMultipleChoice\", candidateChoices,\n\t\t\tbookChoiceRenderer));\n\t\tform.add(newCheckGroup(\"checkGroup\", candidateChoices));\n\t\tform.add(new Button(\"buttonWithModel\", Model.of(\"ButtonWithModel\"))\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onSubmit()\n\t\t\t{\n\t\t\t\tbuttonPressed = true;\n\t\t\t}\n\t\t});\n\t\tform.add(new Button(\"anotherButton\")\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onSubmit()\n\t\t\t{\n\t\t\t\tanotherButtonPressed = true;\n\t\t\t}\n\t\t});\n\t}","commit_id":"c9845b23802c461ff8ec486fbbc33a18457a5788","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets request parameter values for the form component that represents its current model value\n\t * \n\t * @param formComponent\n\t * @return array containing parameter values\n\t */\n\tpublic static String[] getInputValue(FormComponent<?> formComponent)\n\t{\n\t\t// the browser sends parameters for visible and enabled components only\n\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isEnabledInHierarchy())\n\t\t{\n\t\t\t// TODO are text components the only ones with an inherent single value\n\t\t\tif (formComponent instanceof AbstractTextComponent)\n\t\t\t{\n\t\t\t\treturn new String[] { getFormComponentValue(formComponent) };\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tString value = getFormComponentValue(formComponent);\n\t\t\t\tif (!Strings.isEmpty(value))\n\t\t\t\t{\n\t\t\t\t\treturn value.split(FormComponent.VALUE_SEPARATOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new String[] { };\n\t}","id":47160,"modified_method":"/**\n\t * Gets request parameter values for the form component that represents its current model value\n\t * \n\t * @param formComponent\n\t * @return array containing parameter values\n\t */\n\tpublic static String[] getInputValue(FormComponent<?> formComponent)\n\t{\n\t\t// the browser sends parameters for visible and enabled components only\n\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isEnabledInHierarchy())\n\t\t{\n\t\t\tif (formComponent instanceof IFormSubmittingComponent)\n\t\t\t{\n\t\t\t\t// buttons have to be sumitted explicitely\n\t\t\t}\n\t\t\telse if (formComponent instanceof AbstractTextComponent)\n\t\t\t{\n\t\t\t\treturn new String[] { getFormComponentValue(formComponent) };\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO is it safe to assume that all other components' values can be split?\n\t\t\t\tString value = getFormComponentValue(formComponent);\n\t\t\t\tif (!Strings.isEmpty(value))\n\t\t\t\t{\n\t\t\t\t\treturn value.split(FormComponent.VALUE_SEPARATOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new String[] { };\n\t}","commit_id":"c9845b23802c461ff8ec486fbbc33a18457a5788","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void multipleButtonSubmit() throws Exception\n\t{\n\t\tformTester.submit();\n\t\tassertFalse(choicePage.anotherButtonPressed);\n\n\t\tformTester = tester.newFormTester(\"choiceForm\");\n\t\tformTester.submit(\"anotherButton\");\n\t\tassertTrue(choicePage.anotherButtonPressed);\n\t}","id":47161,"modified_method":"/**\n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void multipleButtonSubmit() throws Exception\n\t{\n\t\tformTester.submit();\n\n\t\tassertFalse(choicePage.buttonPressed);\n\t\tassertFalse(choicePage.anotherButtonPressed);\n\n\t\tformTester = tester.newFormTester(\"choiceForm\");\n\t\tformTester.submit(\"anotherButton\");\n\n\t\tassertFalse(choicePage.buttonPressed);\n\t\tassertTrue(choicePage.anotherButtonPressed);\n\t}","commit_id":"c9845b23802c461ff8ec486fbbc33a18457a5788","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t */\n\t@Before\n\tpublic void before()\n\t{\n\t\tbooks = new Book[] { new Book(\"1\", \"book1\"), new Book(\"2\", \"book2\"),\n\t\t\t\tnew Book(\"3\", \"book3\"), new Book(\"4\", \"book4\") };\n\n\t\tchoicePage = (ChoicePage)tester.startPage(new ChoicePage(Arrays.asList(books)));\n\t\tformTester = tester.newFormTester(\"choiceForm\");\n\t}","id":47162,"modified_method":"/**\n\t * \n\t */\n\t@Before\n\tpublic void before()\n\t{\n\t\tbooks = new Book[] { new Book(\"1\", \"book1\"), new Book(\"2\", \"book2\"),\n\t\t\t\tnew Book(\"3\", \"book3\"), new Book(\"4\", \"book4\") };\n\n\t\tchoicePage = tester.startPage(new ChoicePage(Arrays.asList(books)));\n\t\tformTester = tester.newFormTester(\"choiceForm\");\n\t}","commit_id":"c9845b23802c461ff8ec486fbbc33a18457a5788","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param context\n\t */\n\tpublic AbstractPageManager(IPageManagerContext context)\n\t{\n\t\tthis.context = (IPageManagerContext)Args.notNull(context, \"context\");\n\t}","id":47163,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param context\n\t */\n\tpublic AbstractPageManager(IPageManagerContext context)\n\t{\n\t\tthis.context = Args.notNull(context, \"context\");\n\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Tests that Image re-rendered in Ajax request have 'wicket:antiCache' parameter in its 'src'\n\t * attribute value\n\t */\n\t@Test\n\tpublic void wicket1382()\n\t{\n\t\tWicketTester tester = new WicketTester();\n\t\tAjaxyImagesPage page = (AjaxyImagesPage)tester.startPage(AjaxyImagesPage.class);\n\n\t\tTagTester tagTester = tester.getTagById(page.image.getMarkupId());\n\t\tfinal String srcAttr = tagTester.getAttribute(\"src\");\n\t\tassertFalse(\n\t\t\t\"Image has not be rendered in Ajax request so it has no wicket:antiCache' parameter\",\n\t\t\tsrcAttr.contains(\"wicket:antiCache\"));\n\n\t\t// make an ajax call\n\t\ttester.clickLink(\"link\", true);\n\t\tpage = (AjaxyImagesPage)tester.getLastRenderedPage();\n\t\ttagTester = tester.getTagById(page.image.getMarkupId());\n\t\tfinal String imageAjaxComponent = tagTester.getValue();\n\t\tassertTrue(\n\t\t\t\"Image has not be rendered in Ajax request so it has no wicket:antiCache' parameter\",\n\t\t\timageAjaxComponent.contains(\"wicket:antiCache\"));\n\t}","id":47164,"modified_method":"/**\n\t * Tests that Image re-rendered in Ajax request have 'wicket:antiCache' parameter in its 'src'\n\t * attribute value\n\t */\n\t@Test\n\tpublic void wicket1382()\n\t{\n\t\tWicketTester tester = new WicketTester();\n\t\tAjaxyImagesPage page = tester.startPage(AjaxyImagesPage.class);\n\n\t\tTagTester tagTester = tester.getTagById(page.image.getMarkupId());\n\t\tfinal String srcAttr = tagTester.getAttribute(\"src\");\n\t\tassertFalse(\n\t\t\t\"Image has not be rendered in Ajax request so it has no wicket:antiCache' parameter\",\n\t\t\tsrcAttr.contains(\"wicket:antiCache\"));\n\n\t\t// make an ajax call\n\t\ttester.clickLink(\"link\", true);\n\t\tpage = (AjaxyImagesPage)tester.getLastRenderedPage();\n\t\ttagTester = tester.getTagById(page.image.getMarkupId());\n\t\tfinal String imageAjaxComponent = tagTester.getValue();\n\t\tassertTrue(\n\t\t\t\"Image has not be rendered in Ajax request so it has no wicket:antiCache' parameter\",\n\t\t\timageAjaxComponent.contains(\"wicket:antiCache\"));\n\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.authorization.IAuthorizationStrategy#isActionAuthorized(org.apache.wicket.Component,\n\t *      org.apache.wicket.authorization.Action)\n\t */\n\tpublic final boolean isActionAuthorized(Component component, Action action)\n\t{\n\t\tint size = strategies.size();\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tIAuthorizationStrategy strategy = strategies.get(i);\n\t\t\tif (!strategy.isActionAuthorized(component, action))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":47165,"modified_method":"/**\n\t * @see org.apache.wicket.authorization.IAuthorizationStrategy#isActionAuthorized(org.apache.wicket.Component,\n\t *      org.apache.wicket.authorization.Action)\n\t */\n\tpublic final boolean isActionAuthorized(Component component, Action action)\n\t{\n\t\tfor (IAuthorizationStrategy strategy : strategies)\n\t\t{\n\t\t\tif (!strategy.isActionAuthorized(component, action))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"public void dispatchEvent(IEventSink sink, IEvent<?> event)\r\n\t\t{\r\n\t\t\tMethod[] sinkMethods = sink.getClass().getMethods();\r\n\t\t\tfor (int i = 0; i < sinkMethods.length; i++)\r\n\t\t\t{\r\n\t\t\t\tif (sinkMethods[i].isAnnotationPresent(EventCallback.class))\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsinkMethods[i].invoke(sink);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (Exception e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}","id":47166,"modified_method":"public void dispatchEvent(IEventSink sink, IEvent<?> event)\r\n\t\t{\r\n\t\t\tMethod[] sinkMethods = sink.getClass().getMethods();\r\n\t\t\tfor (Method sinkMethod : sinkMethods)\r\n\t\t\t{\r\n\t\t\t\tif (sinkMethod.isAnnotationPresent(EventCallback.class))\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsinkMethod.invoke(sink);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (Exception e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Iterates through the document searching for tokens. Returns the type of token that was found.\n\t * If an unexpected token was encountered then the parser writes this fact to the console and\n\t * continues\n\t * \n\t * @return The token that was found\n\t */\n\tpublic int getNextToken()\n\t{\n\t\twhile (pos < document.length())\n\t\t{\n\t\t\tchar ch = document.charAt(pos);\n\t\t\tif (ch == '<')\n\t\t\t{\n\t\t\t\treturn processDirective();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn processText();\n\t\t\t}\n\t\t}\n\t\treturn END;\n\t}","id":47167,"modified_method":"/**\n\t * Iterates through the document searching for tokens. Returns the type of token that was found.\n\t * If an unexpected token was encountered then the parser writes this fact to the console and\n\t * continues\n\t * \n\t * @return The token that was found\n\t */\n\tpublic int getNextToken()\n\t{\n\t\tif (pos < document.length())\n\t\t{\n\t\t\tchar ch = document.charAt(pos);\n\t\t\tif (ch == '<')\n\t\t\t{\n\t\t\t\treturn processDirective();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn processText();\n\t\t\t}\n\t\t}\n\t\treturn END;\n\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Merge inherited and base markup.\n\t * \n\t * @param markup\n\t *            The inherited markup\n\t * @param baseMarkup\n\t *            The base markup\n\t * @param extendIndex\n\t *            Index where <wicket:extend> has been found\n\t */\n\tprivate void merge(final IMarkupFragment markup, final IMarkupFragment baseMarkup,\n\t\tint extendIndex)\n\t{\n\t\t// True if either <wicket:head> or <head> has been processed\n\t\tboolean wicketHeadProcessed = false;\n\n\t\t// True, if <head> was found\n\t\tboolean foundHeadTag = false;\n\n\t\t// Add all elements from the base markup to the new list\n\t\t// until <wicket:child/> is found. Convert <wicket:child/>\n\t\t// into <wicket:child> and add it as well.\n\t\tWicketTag childTag = null;\n\t\tint baseIndex = 0;\n\t\tfor (; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\tif (element instanceof RawMarkup)\n\t\t\t{\n\t\t\t\t// Add the element to the merged list\n\t\t\t\taddMarkupElement(element);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal ComponentTag tag = (ComponentTag)element;\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((baseMarkup.getMarkupResourceStream().getResource() != null) &&\n\t\t\t\t(tag.getMarkupClass() == null))\n\t\t\t{\n\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\t}\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\n\t\t\t\t// Found org.apache.wicket.child in base markup. In case of 3+\n\t\t\t\t// level inheritance make sure the child tag is not from one of\n\t\t\t\t// the deeper levels\n\t\t\t\tif (wtag.isChildTag() &&\n\t\t\t\t\t(tag.getMarkupClass() == baseMarkup.getMarkupResourceStream().getMarkupClass()))\n\t\t\t\t{\n\t\t\t\t\tif (wtag.isOpenClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child /> => <wicket:child>...<\/wicket:child>\n\t\t\t\t\t\tchildTag = wtag;\n\t\t\t\t\t\tWicketTag childOpenTag = (WicketTag)wtag.mutable();\n\t\t\t\t\t\tchildOpenTag.getXmlTag().setType(TagType.OPEN);\n\t\t\t\t\t\tchildOpenTag.setMarkupClass(baseMarkup.getMarkupResourceStream()\n\t\t\t\t\t\t\t.getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(childOpenTag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (wtag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child>\n\t\t\t\t\t\taddMarkupElement(wtag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Did not expect a <\/wicket:child> tag in \" + baseMarkup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Process the head of the extended markup only once\n\t\t\t\tif (wicketHeadProcessed == false)\n\t\t\t\t{\n\t\t\t\t\t// if <\/wicket:head> in base markup and no <head>\n\t\t\t\t\tif (wtag.isClose() && wtag.isHeadTag() && (foundHeadTag == false))\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the current close tag\n\t\t\t\t\t\taddMarkupElement(wtag);\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\n\t\t\t\t\t\t// Do not add the current tag. It has already been\n\t\t\t\t\t\t// added.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if <wicket:panel> or ... in base markup\n\t\t\t\t\tif (wtag.isOpen() && wtag.isMajorWicketComponentTag())\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process the head of the extended markup only once\n\t\t\tif (wicketHeadProcessed == false)\n\t\t\t{\n\t\t\t\t// Remember that we found <head> in the base markup\n\t\t\t\tif (tag.isOpen() && TagUtils.isHeadTag(tag))\n\t\t\t\t{\n\t\t\t\t\tfoundHeadTag = true;\n\t\t\t\t}\n\n\t\t\t\t// if <head> in base markup\n\t\t\t\tif ((tag.isClose() && TagUtils.isHeadTag(tag)) ||\n\t\t\t\t\t(tag.isOpen() && TagUtils.isBodyTag(tag)))\n\t\t\t\t{\n\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the element to the merged list\n\t\t\taddMarkupElement(element);\n\t\t}\n\n\t\tif (baseIndex == baseMarkup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Expected to find <wicket:child/> in base markup: \" +\n\t\t\t\tbaseMarkup.toString());\n\t\t}\n\n\t\t// Now append all elements from the derived markup starting with\n\t\t// <wicket:extend> until <\/wicket:extend> to the list\n\t\tfor (; extendIndex < markup.size(); extendIndex++)\n\t\t{\n\t\t\tMarkupElement element = markup.get(extendIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\t\t\t\tif (wtag.isExtendTag() && wtag.isClose())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (extendIndex == markup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\"Missing close tag <\/wicket:extend> in derived markup: \" + markup.toString());\n\t\t}\n\n\t\t// If <wicket:child> than skip the body and find <\/wicket:child>\n\t\tif (((ComponentTag)baseMarkup.get(baseIndex)).isOpen())\n\t\t{\n\t\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t\t{\n\t\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\t\tif (element instanceof WicketTag)\n\t\t\t\t{\n\t\t\t\t\tWicketTag tag = (WicketTag)element;\n\t\t\t\t\tif (tag.isChildTag() && tag.isClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Ok, skipped the childs content\n\t\t\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(tag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Wicket tags like <wicket:xxx> are not allowed in between <wicket:child> and <\/wicket:child> tags: \" +\n\t\t\t\t\t\t\t\tmarkup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (element instanceof ComponentTag)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"Wicket tags identified by wicket:id are not allowed in between <wicket:child> and <\/wicket:child> tags: \" +\n\t\t\t\t\t\t\tmarkup.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// <\/wicket:child> not found\n\t\t\tif (baseIndex == baseMarkup.size())\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"Expected to find <\/wicket:child> in base markup: \" + baseMarkup.toString());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// And now all remaining elements from the derived markup.\n\t\t\t// But first add <\/wicket:child>\n\t\t\tWicketTag childCloseTag = (WicketTag)childTag.mutable();\n\t\t\tchildCloseTag.getXmlTag().setType(TagType.CLOSE);\n\t\t\tchildCloseTag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\taddMarkupElement(childCloseTag);\n\t\t}\n\n\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((element instanceof ComponentTag) &&\n\t\t\t\t(baseMarkup.getMarkupResourceStream().getResource() != null))\n\t\t\t{\n\t\t\t\tComponentTag tag = (ComponentTag)element;\n\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\t}\n\t\t}\n\n\t\t// Automatically add <head> if missing and required. On a Page\n\t\t// it must enclose ALL of the <wicket:head> tags.\n\t\t// Note: HtmlHeaderSectionHandler does something similar, but because\n\t\t// markup filters are not called for merged markup again, ...\n\t\tif (Page.class.isAssignableFrom(markup.getMarkupResourceStream().getMarkupClass()))\n\t\t{\n\t\t\t// Find the position inside the markup for first <wicket:head>,\n\t\t\t// last <\/wicket:head> and <head>\n\t\t\tint hasOpenWicketHead = -1;\n\t\t\tint hasCloseWicketHead = -1;\n\t\t\tint hasHead = -1;\n\t\t\tfor (int i = 0; i < size(); i++)\n\t\t\t{\n\t\t\t\tMarkupElement element = get(i);\n\n\t\t\t\tif ((hasOpenWicketHead == -1) && (element instanceof WicketTag) &&\n\t\t\t\t\t((WicketTag)element).isHeadTag())\n\t\t\t\t{\n\t\t\t\t\thasOpenWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((element instanceof WicketTag) && ((WicketTag)element).isHeadTag() &&\n\t\t\t\t\t((WicketTag)element).isClose())\n\t\t\t\t{\n\t\t\t\t\thasCloseWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead == -1) && (element instanceof ComponentTag) &&\n\t\t\t\t\tTagUtils.isHeadTag((ComponentTag)element))\n\t\t\t\t{\n\t\t\t\t\thasHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead != -1) && (hasOpenWicketHead != -1))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a <head> tag is missing, insert it automatically\n\t\t\tif ((hasOpenWicketHead != -1) && (hasHead == -1))\n\t\t\t{\n\t\t\t\tfinal XmlTag headOpenTag = new XmlTag();\n\t\t\t\theadOpenTag.setName(\"head\");\n\t\t\t\theadOpenTag.setType(TagType.OPEN);\n\t\t\t\tfinal ComponentTag openTag = new ComponentTag(headOpenTag);\n\t\t\t\topenTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\t\t\t\topenTag.setAutoComponentTag(true);\n\n\t\t\t\tfinal XmlTag headCloseTag = new XmlTag();\n\t\t\t\theadCloseTag.setName(headOpenTag.getName());\n\t\t\t\theadCloseTag.setType(TagType.CLOSE);\n\t\t\t\tfinal ComponentTag closeTag = new ComponentTag(headCloseTag);\n\t\t\t\tcloseTag.setOpenTag(openTag);\n\t\t\t\tcloseTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\n\t\t\t\taddMarkupElement(hasOpenWicketHead, openTag);\n\t\t\t\taddMarkupElement(hasCloseWicketHead + 2, closeTag);\n\t\t\t}\n\t\t}\n\t}","id":47168,"modified_method":"/**\n\t * Merge inherited and base markup.\n\t * \n\t * @param markup\n\t *            The inherited markup\n\t * @param baseMarkup\n\t *            The base markup\n\t * @param extendIndex\n\t *            Index where <wicket:extend> has been found\n\t */\n\tprivate void merge(final IMarkupFragment markup, final IMarkupFragment baseMarkup,\n\t\tint extendIndex)\n\t{\n\t\t// True if either <wicket:head> or <head> has been processed\n\t\tboolean wicketHeadProcessed = false;\n\n\t\t// True, if <head> was found\n\t\tboolean foundHeadTag = false;\n\n\t\t// Add all elements from the base markup to the new list\n\t\t// until <wicket:child/> is found. Convert <wicket:child/>\n\t\t// into <wicket:child> and add it as well.\n\t\tWicketTag childTag = null;\n\t\tint baseIndex = 0;\n\t\tfor (; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\tif (element instanceof RawMarkup)\n\t\t\t{\n\t\t\t\t// Add the element to the merged list\n\t\t\t\taddMarkupElement(element);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal ComponentTag tag = (ComponentTag)element;\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((baseMarkup.getMarkupResourceStream().getResource() != null) &&\n\t\t\t\t(tag.getMarkupClass() == null))\n\t\t\t{\n\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\t}\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\n\t\t\t\t// Found org.apache.wicket.child in base markup. In case of 3+\n\t\t\t\t// level inheritance make sure the child tag is not from one of\n\t\t\t\t// the deeper levels\n\t\t\t\tif (wtag.isChildTag() &&\n\t\t\t\t\t(tag.getMarkupClass() == baseMarkup.getMarkupResourceStream().getMarkupClass()))\n\t\t\t\t{\n\t\t\t\t\tif (wtag.isOpenClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child /> => <wicket:child>...<\/wicket:child>\n\t\t\t\t\t\tchildTag = wtag;\n\t\t\t\t\t\tWicketTag childOpenTag = (WicketTag)wtag.mutable();\n\t\t\t\t\t\tchildOpenTag.getXmlTag().setType(TagType.OPEN);\n\t\t\t\t\t\tchildOpenTag.setMarkupClass(baseMarkup.getMarkupResourceStream()\n\t\t\t\t\t\t\t.getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(childOpenTag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (wtag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child>\n\t\t\t\t\t\taddMarkupElement(wtag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Did not expect a <\/wicket:child> tag in \" + baseMarkup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Process the head of the extended markup only once\n\t\t\t\tif (wicketHeadProcessed == false)\n\t\t\t\t{\n\t\t\t\t\t// if <\/wicket:head> in base markup and no <head>\n\t\t\t\t\tif (wtag.isClose() && wtag.isHeadTag() && (foundHeadTag == false))\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the current close tag\n\t\t\t\t\t\taddMarkupElement(wtag);\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\n\t\t\t\t\t\t// Do not add the current tag. It has already been\n\t\t\t\t\t\t// added.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if <wicket:panel> or ... in base markup\n\t\t\t\t\tif (wtag.isOpen() && wtag.isMajorWicketComponentTag())\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process the head of the extended markup only once\n\t\t\tif (wicketHeadProcessed == false)\n\t\t\t{\n\t\t\t\t// Remember that we found <head> in the base markup\n\t\t\t\tif (tag.isOpen() && TagUtils.isHeadTag(tag))\n\t\t\t\t{\n\t\t\t\t\tfoundHeadTag = true;\n\t\t\t\t}\n\n\t\t\t\t// if <head> in base markup\n\t\t\t\tif ((tag.isClose() && TagUtils.isHeadTag(tag)) ||\n\t\t\t\t\t(tag.isOpen() && TagUtils.isBodyTag(tag)))\n\t\t\t\t{\n\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the element to the merged list\n\t\t\taddMarkupElement(element);\n\t\t}\n\n\t\tif (baseIndex == baseMarkup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Expected to find <wicket:child/> in base markup: \" +\n\t\t\t\tbaseMarkup.toString());\n\t\t}\n\n\t\t// Now append all elements from the derived markup starting with\n\t\t// <wicket:extend> until <\/wicket:extend> to the list\n\t\tfor (; extendIndex < markup.size(); extendIndex++)\n\t\t{\n\t\t\tMarkupElement element = markup.get(extendIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\t\t\t\tif (wtag.isExtendTag() && wtag.isClose())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (extendIndex == markup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\"Missing close tag <\/wicket:extend> in derived markup: \" + markup.toString());\n\t\t}\n\n\t\t// If <wicket:child> than skip the body and find <\/wicket:child>\n\t\tif (((ComponentTag)baseMarkup.get(baseIndex)).isOpen())\n\t\t{\n\t\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t\t{\n\t\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\t\tif (element instanceof WicketTag)\n\t\t\t\t{\n\t\t\t\t\tWicketTag tag = (WicketTag)element;\n\t\t\t\t\tif (tag.isChildTag() && tag.isClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Ok, skipped the childs content\n\t\t\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(tag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Wicket tags like <wicket:xxx> are not allowed in between <wicket:child> and <\/wicket:child> tags: \" +\n\t\t\t\t\t\t\t\tmarkup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (element instanceof ComponentTag)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"Wicket tags identified by wicket:id are not allowed in between <wicket:child> and <\/wicket:child> tags: \" +\n\t\t\t\t\t\t\tmarkup.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// <\/wicket:child> not found\n\t\t\tif (baseIndex == baseMarkup.size())\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"Expected to find <\/wicket:child> in base markup: \" + baseMarkup.toString());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// And now all remaining elements from the derived markup.\n\t\t\t// But first add <\/wicket:child>\n\t\t\tWicketTag childCloseTag = (WicketTag)childTag.mutable();\n\t\t\tchildCloseTag.getXmlTag().setType(TagType.CLOSE);\n\t\t\tchildCloseTag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\taddMarkupElement(childCloseTag);\n\t\t}\n\n\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((element instanceof ComponentTag) &&\n\t\t\t\t(baseMarkup.getMarkupResourceStream().getResource() != null))\n\t\t\t{\n\t\t\t\tComponentTag tag = (ComponentTag)element;\n\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceStream().getMarkupClass());\n\t\t\t}\n\t\t}\n\n\t\t// Automatically add <head> if missing and required. On a Page\n\t\t// it must enclose ALL of the <wicket:head> tags.\n\t\t// Note: HtmlHeaderSectionHandler does something similar, but because\n\t\t// markup filters are not called for merged markup again, ...\n\t\tif (Page.class.isAssignableFrom(markup.getMarkupResourceStream().getMarkupClass()))\n\t\t{\n\t\t\t// Find the position inside the markup for first <wicket:head>,\n\t\t\t// last <\/wicket:head> and <head>\n\t\t\tint hasOpenWicketHead = -1;\n\t\t\tint hasCloseWicketHead = -1;\n\t\t\tint hasHead = -1;\n\t\t\tfor (int i = 0; i < size(); i++)\n\t\t\t{\n\t\t\t\tMarkupElement element = get(i);\n\n\t\t\t\tif ((hasOpenWicketHead == -1) && (element instanceof WicketTag) &&\n\t\t\t\t\t((WicketTag)element).isHeadTag())\n\t\t\t\t{\n\t\t\t\t\thasOpenWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((element instanceof WicketTag) && ((WicketTag)element).isHeadTag() &&\n\t\t\t\t\t((WicketTag)element).isClose())\n\t\t\t\t{\n\t\t\t\t\thasCloseWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead == -1) && (element instanceof ComponentTag) &&\n\t\t\t\t\tTagUtils.isHeadTag(element))\n\t\t\t\t{\n\t\t\t\t\thasHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead != -1) && (hasOpenWicketHead != -1))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a <head> tag is missing, insert it automatically\n\t\t\tif ((hasOpenWicketHead != -1) && (hasHead == -1))\n\t\t\t{\n\t\t\t\tfinal XmlTag headOpenTag = new XmlTag();\n\t\t\t\theadOpenTag.setName(\"head\");\n\t\t\t\theadOpenTag.setType(TagType.OPEN);\n\t\t\t\tfinal ComponentTag openTag = new ComponentTag(headOpenTag);\n\t\t\t\topenTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\t\t\t\topenTag.setAutoComponentTag(true);\n\n\t\t\t\tfinal XmlTag headCloseTag = new XmlTag();\n\t\t\t\theadCloseTag.setName(headOpenTag.getName());\n\t\t\t\theadCloseTag.setType(TagType.CLOSE);\n\t\t\t\tfinal ComponentTag closeTag = new ComponentTag(headCloseTag);\n\t\t\t\tcloseTag.setOpenTag(openTag);\n\t\t\t\tcloseTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\n\t\t\t\taddMarkupElement(hasOpenWicketHead, openTag);\n\t\t\t\taddMarkupElement(hasCloseWicketHead + 2, closeTag);\n\t\t\t}\n\t\t}\n\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"protected boolean isMetaInfResourcesSupported()\r\n\t{\r\n\t\tif (META_INF_RESOURCES_SUPPORTED == null)\r\n\t\t{\r\n\t\t\tint majorVersion = WebApplication.get().getServletContext().getMajorVersion();\r\n\t\t\tMETA_INF_RESOURCES_SUPPORTED = majorVersion >= 3;\r\n\t\t}\r\n\r\n\t\treturn META_INF_RESOURCES_SUPPORTED.booleanValue();\r\n\t}","id":47169,"modified_method":"protected boolean isMetaInfResourcesSupported()\r\n\t{\r\n\t\tif (META_INF_RESOURCES_SUPPORTED == null)\r\n\t\t{\r\n\t\t\tint majorVersion = WebApplication.get().getServletContext().getMajorVersion();\r\n\t\t\tMETA_INF_RESOURCES_SUPPORTED = majorVersion >= 3;\r\n\t\t}\r\n\r\n\t\treturn META_INF_RESOURCES_SUPPORTED;\r\n\t}","commit_id":"70e9b9abe3e21ad2f7d2bfe8dd6a2658b3136c20","url":"https://github.com/apache/wicket"},{"original_method":"public void test() throws Exception\n\t{\n\t\tWicketTester tester = new WicketTester();\n\n\t\tStringArrayPage page = (StringArrayPage)tester.startPage(StringArrayPage.class);\n\n\t\ttester.submitForm(\"form\");\n\n\t\tassertNotNull(page.array);\n\t\tassertEquals(0, page.array.length);\n\t}","id":47170,"modified_method":"public void test() throws Exception\n\t{\n\t\tWicketTester tester = new WicketTester();\n\n\t\tStringArrayPage page = tester.startPage(StringArrayPage.class);\n\n\t\ttester.submitForm(\"form\");\n\n\t\tassertNotNull(page.array);\n\t\tassertEquals(0, page.array.length);\n\t}","commit_id":"307377f01f6a9e8a164c90b4596b5d7b3ac1121a","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tlong companyId = PortalInstances.getCompanyId(request);\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString originalFriendlyURL = request.getRequestURI();\n\n\t\tString friendlyURL = originalFriendlyURL;\n\n\t\tif (Validator.isNotNull(contextPath) &&\n\t\t\tfriendlyURL.contains(contextPath)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(contextPath.length());\n\t\t}\n\n\t\tint pos = friendlyURL.indexOf(StringPool.SEMICOLON);\n\n\t\tif (pos != -1) {\n\t\t\tfriendlyURL = friendlyURL.substring(0, pos);\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tString i18nLanguageId = null;\n\n\t\tSet<String> languageIds = I18nServlet.getLanguageIds();\n\n\t\tfor (String languageId : languageIds) {\n\t\t\tif (StringUtil.startsWith(friendlyURL, languageId)) {\n\t\t\t\tpos = friendlyURL.indexOf(CharPool.SLASH, 1);\n\n\t\t\t\tif (((pos != -1) && (pos != languageId.length())) ||\n\t\t\t\t\t((pos == -1) &&\n\t\t\t\t\t !StringUtil.equalsIgnoreCase(friendlyURL, languageId))) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\ti18nLanguageId = languageId;\n\t\t\t\t\tfriendlyURL = StringPool.SLASH;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti18nLanguageId = languageId.substring(0, pos);\n\t\t\t\t\tfriendlyURL = friendlyURL.substring(pos);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, PropsValues.WIDGET_SERVLET_MAPPING, StringPool.BLANK);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!friendlyURL.equals(StringPool.SLASH) &&\n\t\t\t!isValidFriendlyURL(friendlyURL)) {\n\n\t\t\t_log.debug(\"Friendly URL is not valid\");\n\n\t\t\tprocessFilter(\n\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\tfilterChain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)request.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Layout set \" + layoutSet);\n\t\t}\n\n\t\tif (layoutSet == null) {\n\t\t\tprocessFilter(\n\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\tfilterChain);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tLastPath lastPath = new LastPath(\n\t\t\t\tcontextPath, friendlyURL, request.getParameterMap());\n\n\t\t\trequest.setAttribute(WebKeys.LAST_PATH, lastPath);\n\n\t\t\tStringBundler forwardURL = new StringBundler(5);\n\n\t\t\tif (i18nLanguageId != null) {\n\t\t\t\tforwardURL.append(i18nLanguageId);\n\t\t\t}\n\n\t\t\tif (originalFriendlyURL.startsWith(\n\t\t\t\t\tPropsValues.WIDGET_SERVLET_MAPPING)) {\n\n\t\t\t\tforwardURL.append(PropsValues.WIDGET_SERVLET_MAPPING);\n\n\t\t\t\tfriendlyURL = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURL, PropsValues.WIDGET_SERVLET_MAPPING,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\n\t\t\tlong plid = PortalUtil.getPlidFromFriendlyURL(\n\t\t\t\tcompanyId, friendlyURL);\n\n\t\t\tif (plid <= 0) {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tlayoutSet.getGroupId());\n\n\t\t\t\tif (isDocumentFriendlyURL(\n\t\t\t\t\t\trequest, group.getGroupId(), friendlyURL)) {\n\n\t\t\t\t\tprocessFilter(\n\t\t\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\t\t\tfilterChain);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (group.isGuest() && friendlyURL.equals(StringPool.SLASH) &&\n\t\t\t\t\t!layoutSet.isPrivateLayout()) {\n\n\t\t\t\t\tString homeURL = PortalUtil.getRelativeHomeURL(request);\n\n\t\t\t\t\tif (Validator.isNotNull(homeURL)) {\n\t\t\t\t\t\tfriendlyURL = homeURL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t\t\tforwardURL.append(_PRIVATE_USER_SERVLET_MAPPING);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tforwardURL.append(_PRIVATE_GROUP_SERVLET_MAPPING);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tforwardURL.append(_PUBLIC_GROUP_SERVLET_MAPPING);\n\t\t\t\t\t}\n\n\t\t\t\t\tforwardURL.append(group.getFriendlyURL());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforwardURL.append(friendlyURL);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Forward to \" + forwardURL);\n\t\t\t}\n\n\t\t\tRequestDispatcher requestDispatcher =\n\t\t\t\t_servletContext.getRequestDispatcher(forwardURL.toString());\n\n\t\t\trequestDispatcher.forward(request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tprocessFilter(\n\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\tfilterChain);\n\t\t}\n\t}","id":47171,"modified_method":"@Override\n\tprotected void processFilter(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tFilterChain filterChain)\n\t\tthrows Exception {\n\n\t\tlong companyId = PortalInstances.getCompanyId(request);\n\n\t\tString proxyPath = PortalUtil.getPathProxy();\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString originalFriendlyURL = request.getRequestURI();\n\n\t\tString friendlyURL = originalFriendlyURL;\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (!friendlyURL.equals(StringPool.SLASH) &&\n\t\t\t\tValidator.isNotNull(contextPath)) {\n\n\t\t\tif (Validator.isNotNull(proxyPath) &&\n\t\t\t\tcontextPath.startsWith(proxyPath)) {\n\n\t\t\t\tcontextPath = contextPath.substring(proxyPath.length());\n\t\t\t}\n\n\t\t\tif (friendlyURL.startsWith(contextPath)) {\n\n\t\t\t\tfriendlyURL = friendlyURL.substring(contextPath.length());\n\t\t\t}\n\t\t}\n\n\t\tint pos = friendlyURL.indexOf(StringPool.SEMICOLON);\n\n\t\tif (pos != -1) {\n\t\t\tfriendlyURL = friendlyURL.substring(0, pos);\n\t\t}\n\n\t\tString i18nLanguageId = null;\n\n\t\tSet<String> languageIds = I18nServlet.getLanguageIds();\n\n\t\tfor (String languageId : languageIds) {\n\t\t\tif (StringUtil.startsWith(friendlyURL, languageId)) {\n\t\t\t\tpos = friendlyURL.indexOf(CharPool.SLASH, 1);\n\n\t\t\t\tif (((pos != -1) && (pos != languageId.length())) ||\n\t\t\t\t\t((pos == -1) &&\n\t\t\t\t\t !StringUtil.equalsIgnoreCase(friendlyURL, languageId))) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\ti18nLanguageId = languageId;\n\t\t\t\t\tfriendlyURL = StringPool.SLASH;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti18nLanguageId = languageId.substring(0, pos);\n\t\t\t\t\tfriendlyURL = friendlyURL.substring(pos);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, PropsValues.WIDGET_SERVLET_MAPPING, StringPool.BLANK);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!friendlyURL.equals(StringPool.SLASH) &&\n\t\t\t!isValidFriendlyURL(friendlyURL)) {\n\n\t\t\t_log.debug(\"Friendly URL is not valid\");\n\n\t\t\tprocessFilter(\n\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\tfilterChain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)request.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Layout set \" + layoutSet);\n\t\t}\n\n\t\tif (layoutSet == null) {\n\t\t\tprocessFilter(\n\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\tfilterChain);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tLastPath lastPath = new LastPath(\n\t\t\t\tcontextPath, friendlyURL, request.getParameterMap());\n\n\t\t\trequest.setAttribute(WebKeys.LAST_PATH, lastPath);\n\n\t\t\tStringBundler forwardURL = new StringBundler(5);\n\n\t\t\tif (i18nLanguageId != null) {\n\t\t\t\tforwardURL.append(i18nLanguageId);\n\t\t\t}\n\n\t\t\tif (originalFriendlyURL.startsWith(\n\t\t\t\t\tPropsValues.WIDGET_SERVLET_MAPPING)) {\n\n\t\t\t\tforwardURL.append(PropsValues.WIDGET_SERVLET_MAPPING);\n\n\t\t\t\tfriendlyURL = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURL, PropsValues.WIDGET_SERVLET_MAPPING,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\n\t\t\tlong plid = PortalUtil.getPlidFromFriendlyURL(\n\t\t\t\tcompanyId, friendlyURL);\n\n\t\t\tif (plid <= 0) {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tlayoutSet.getGroupId());\n\n\t\t\t\tif (isDocumentFriendlyURL(\n\t\t\t\t\t\trequest, group.getGroupId(), friendlyURL)) {\n\n\t\t\t\t\tprocessFilter(\n\t\t\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\t\t\tfilterChain);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (group.isGuest() && friendlyURL.equals(StringPool.SLASH) &&\n\t\t\t\t\t!layoutSet.isPrivateLayout()) {\n\n\t\t\t\t\tString homeURL = PortalUtil.getRelativeHomeURL(request);\n\n\t\t\t\t\tif (Validator.isNotNull(homeURL)) {\n\t\t\t\t\t\tfriendlyURL = homeURL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\t\t\tif (group.isUser()) {\n\t\t\t\t\t\t\tforwardURL.append(_PRIVATE_USER_SERVLET_MAPPING);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tforwardURL.append(_PRIVATE_GROUP_SERVLET_MAPPING);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tforwardURL.append(_PUBLIC_GROUP_SERVLET_MAPPING);\n\t\t\t\t\t}\n\n\t\t\t\t\tforwardURL.append(group.getFriendlyURL());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforwardURL.append(friendlyURL);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Forward to \" + forwardURL);\n\t\t\t}\n\n\t\t\tRequestDispatcher requestDispatcher =\n\t\t\t\t_servletContext.getRequestDispatcher(forwardURL.toString());\n\n\t\t\trequestDispatcher.forward(request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tprocessFilter(\n\t\t\t\tVirtualHostFilter.class.getName(), request, response,\n\t\t\t\tfilterChain);\n\t\t}\n\t}","commit_id":"730df8179fa7d5e1f21eec2e5558d5d5560ff224","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _sortJSPAttributes(\r\n\t\tString fileName, String line, int lineCount) {\r\n\r\n\t\tString s = line;\r\n\r\n\t\tint x = s.indexOf(StringPool.SPACE);\r\n\r\n\t\tif (x == -1) {\r\n\t\t\treturn line;\r\n\t\t}\r\n\r\n\t\ts = s.substring(x + 1);\r\n\r\n\t\tString previousAttribute = null;\r\n\t\tString previousAttributeAndValue = null;\r\n\r\n\t\tboolean wrongOrder = false;\r\n\r\n\t\tfor (x = 0;;) {\r\n\t\t\tx = s.indexOf(StringPool.EQUAL);\r\n\r\n\t\t\tif ((x == -1) || (s.length() <= (x + 1))) {\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\tString attribute = s.substring(0, x);\r\n\r\n\t\t\tif (!_isJSPAttributName(attribute)) {\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\tif (Validator.isNotNull(previousAttribute) &&\r\n\t\t\t\t(previousAttribute.compareTo(attribute) > 0)) {\r\n\r\n\t\t\t\twrongOrder = true;\r\n\t\t\t}\r\n\r\n\t\t\ts = s.substring(x + 1);\r\n\r\n\t\t\tchar delimeter = s.charAt(0);\r\n\r\n\t\t\tif ((delimeter != CharPool.APOSTROPHE) &&\r\n\t\t\t\t(delimeter != CharPool.QUOTE)) {\r\n\r\n\t\t\t\t_sourceFormatterHelper.printError(\r\n\t\t\t\t\tfileName, \"delimeter: \" + fileName + \" \" + lineCount);\r\n\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\ts = s.substring(1);\r\n\r\n\t\t\tint y = s.indexOf(delimeter);\r\n\r\n\t\t\tif ((y == -1) || (s.length() <= (y + 1))) {\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\tString value = s.substring(0, y);\r\n\r\n\t\t\tif ((delimeter == CharPool.APOSTROPHE) &&\r\n\t\t\t\t!value.contains(StringPool.QUOTE)) {\r\n\r\n\t\t\t\treturn StringUtil.replace(\r\n\t\t\t\t\tline, StringPool.APOSTROPHE + value + StringPool.APOSTROPHE,\r\n\t\t\t\t\tStringPool.QUOTE + value + StringPool.QUOTE);\r\n\t\t\t}\r\n\r\n\t\t\tif (value.contains(\"<%\") && !value.contains(\"%>\")) {\r\n\t\t\t\tint z = s.indexOf(\"%>\");\r\n\r\n\t\t\t\tif (z == -1) {\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ty = s.substring(z).indexOf(delimeter);\r\n\r\n\t\t\t\tvalue = s.substring(0, y + z);\r\n\t\t\t}\r\n\r\n\t\t\tStringBundler sb = new StringBundler(5);\r\n\r\n\t\t\tsb.append(attribute);\r\n\t\t\tsb.append(StringPool.EQUAL);\r\n\t\t\tsb.append(delimeter);\r\n\t\t\tsb.append(value);\r\n\t\t\tsb.append(delimeter);\r\n\r\n\t\t\tString currentAttributeAndValue = sb.toString();\r\n\r\n\t\t\tif (wrongOrder) {\r\n\t\t\t\tif (line.contains(currentAttributeAndValue) &&\r\n\t\t\t\t\tline.contains(previousAttributeAndValue)) {\r\n\r\n\t\t\t\t\tline = StringUtil.replaceFirst(\r\n\t\t\t\t\t\tline, previousAttributeAndValue,\r\n\t\t\t\t\t\tcurrentAttributeAndValue);\r\n\r\n\t\t\t\t\tline = StringUtil.replaceLast(\r\n\t\t\t\t\t\tline, currentAttributeAndValue,\r\n\t\t\t\t\t\tpreviousAttributeAndValue);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\ts = s.substring(y + 1);\r\n\r\n\t\t\ts = StringUtil.trimLeading(s);\r\n\r\n\t\t\tpreviousAttribute = attribute;\r\n\t\t\tpreviousAttributeAndValue = currentAttributeAndValue;\r\n\t\t}\r\n\t}","id":47172,"modified_method":"private static String _sortJSPAttributes(\r\n\t\tString fileName, String line, int lineCount) {\r\n\r\n\t\tString s = line;\r\n\r\n\t\tint x = s.indexOf(StringPool.SPACE);\r\n\r\n\t\tif (x == -1) {\r\n\t\t\treturn line;\r\n\t\t}\r\n\r\n\t\ts = s.substring(x + 1);\r\n\r\n\t\tString previousAttribute = null;\r\n\t\tString previousAttributeAndValue = null;\r\n\r\n\t\tboolean wrongOrder = false;\r\n\r\n\t\tfor (x = 0;;) {\r\n\t\t\tx = s.indexOf(StringPool.EQUAL);\r\n\r\n\t\t\tif ((x == -1) || (s.length() <= (x + 1))) {\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\tString attribute = s.substring(0, x);\r\n\r\n\t\t\tif (!_isJSPAttributName(attribute)) {\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\tif (Validator.isNotNull(previousAttribute) &&\r\n\t\t\t\t(previousAttribute.compareTo(attribute) > 0)) {\r\n\r\n\t\t\t\twrongOrder = true;\r\n\t\t\t}\r\n\r\n\t\t\ts = s.substring(x + 1);\r\n\r\n\t\t\tchar delimeter = s.charAt(0);\r\n\r\n\t\t\tif ((delimeter != CharPool.APOSTROPHE) &&\r\n\t\t\t\t(delimeter != CharPool.QUOTE)) {\r\n\r\n\t\t\t\t_sourceFormatterHelper.printError(\r\n\t\t\t\t\tfileName, \"delimeter: \" + fileName + \" \" + lineCount);\r\n\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\ts = s.substring(1);\r\n\r\n\t\t\tString value = null;\r\n\t\t\tint y = -1;\r\n\r\n\t\t\tfor (;;) {\r\n\t\t\t\ty = s.indexOf(delimeter, y + 1);\r\n\r\n\t\t\t\tif ((y == -1) || (s.length() <= (y + 1))) {\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue = s.substring(0, y);\r\n\r\n\t\t\t\tif (value.startsWith(\"<%\")) {\r\n\t\t\t\t\tint endJavaCodeSignCount = StringUtil.count(value, \"%>\");\r\n\t\t\t\t\tint startJavaCodeSignCount = StringUtil.count(value, \"<%\");\r\n\r\n\t\t\t\t\tif (endJavaCodeSignCount == startJavaCodeSignCount) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tint greaterThanCount = StringUtil.count(\r\n\t\t\t\t\t\tvalue, StringPool.GREATER_THAN);\r\n\t\t\t\t\tint lessThanCount = StringUtil.count(\r\n\t\t\t\t\t\tvalue, StringPool.LESS_THAN);\r\n\r\n\t\t\t\t\tif (greaterThanCount == lessThanCount) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ((delimeter == CharPool.APOSTROPHE) &&\r\n\t\t\t\t!value.contains(StringPool.QUOTE)) {\r\n\r\n\t\t\t\treturn StringUtil.replace(\r\n\t\t\t\t\tline, StringPool.APOSTROPHE + value + StringPool.APOSTROPHE,\r\n\t\t\t\t\tStringPool.QUOTE + value + StringPool.QUOTE);\r\n\t\t\t}\r\n\r\n\t\t\tStringBundler sb = new StringBundler(5);\r\n\r\n\t\t\tsb.append(attribute);\r\n\t\t\tsb.append(StringPool.EQUAL);\r\n\t\t\tsb.append(delimeter);\r\n\t\t\tsb.append(value);\r\n\t\t\tsb.append(delimeter);\r\n\r\n\t\t\tString currentAttributeAndValue = sb.toString();\r\n\r\n\t\t\tif (wrongOrder) {\r\n\t\t\t\tif ((StringUtil.count(line, currentAttributeAndValue) == 1) &&\r\n\t\t\t\t\t(StringUtil.count(line, previousAttributeAndValue) == 1)) {\r\n\r\n\t\t\t\t\tline = StringUtil.replaceFirst(\r\n\t\t\t\t\t\tline, previousAttributeAndValue,\r\n\t\t\t\t\t\tcurrentAttributeAndValue);\r\n\r\n\t\t\t\t\tline = StringUtil.replaceLast(\r\n\t\t\t\t\t\tline, currentAttributeAndValue,\r\n\t\t\t\t\t\tpreviousAttributeAndValue);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn line;\r\n\t\t\t}\r\n\r\n\t\t\ts = s.substring(y + 1);\r\n\r\n\t\t\ts = StringUtil.trimLeading(s);\r\n\r\n\t\t\tpreviousAttribute = attribute;\r\n\t\t\tpreviousAttributeAndValue = currentAttributeAndValue;\r\n\t\t}\r\n\t}","commit_id":"dd02ddb9fb5b913a7ad773db2ad7ae30c928b109","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Checks that the unit tests are running with a version of OpenSSL that\n     * includes all the expected ciphers and does not include any unexpected\n     * ones.\n     */\n    @Test\n    public void testOpenSSLCipherAvailability() throws Exception {\n        Set<String> availableCipherSuites = getOpenSSLCiphersAsSet(\"ALL:eNULL\");\n        Set<String> expectedCipherSuites = new HashSet<>();\n        for (Cipher cipher : Cipher.values()) {\n            String openSSLAlias = cipher.getOpenSSLAlias();\n            // OpenSSL does not implement any FORTEZZA algorithms so exclude\n            // them from the expected list\n            if (openSSLAlias.contains(\"FZA\")) {\n                continue;\n            }\n            // GOST algorithms are not enabled by default and no JSSE\n            // implementation supports them so exclude them from the expected\n            // list\n            if (openSSLAlias.contains(\"GOST\")) {\n                continue;\n            }\n            // OpenSSL does not implement any DH_DSS or DH_RSA algorithms so\n            // exclude them from the expected list\n            if (openSSLAlias.contains(\"DH-DSS\")) {\n                continue;\n            }\n            if (openSSLAlias.contains(\"DH-RSA\")) {\n                continue;\n            }\n            // OpenSSL does not enable the experimental EXP1024 and\n            // DHE-DSS-RC4-SHA cipher suites unless the source is explicitly\n            // patched so exclude them from the expected list\n            if (openSSLAlias.contains(\"EXP1024\")) {\n                continue;\n            }\n            if (openSSLAlias.contains(\"DHE-DSS-RC4-SHA\")) {\n                continue;\n            }\n            // RC2-MD5 is not referenced in the OpenSSL source so exclude it\n            // from the expected list\n            if (openSSLAlias.contains(\"RC2-MD5\")) {\n                continue;\n            }\n            expectedCipherSuites.add(openSSLAlias);\n        }\n\n        Set<String> unavailableCipherSuites = new HashSet<>();\n        unavailableCipherSuites.addAll(expectedCipherSuites);\n        unavailableCipherSuites.removeAll(availableCipherSuites);\n        StringBuilder unavailableList = new StringBuilder();\n        for (String cipher : unavailableCipherSuites) {\n            unavailableList.append(cipher);\n            unavailableList.append(' ');\n        }\n        Assert.assertEquals(unavailableList.toString(), 0,  unavailableCipherSuites.size());\n    }","id":47173,"modified_method":"/**\n     * Checks that the unit tests are running with a version of OpenSSL that\n     * includes all the expected ciphers and does not include any unexpected\n     * ones.\n     */\n    @Test\n    public void testOpenSSLCipherAvailability() throws Exception {\n        Set<String> availableCipherSuites = getOpenSSLCiphersAsSet(\"ALL:eNULL\");\n        Set<String> expectedCipherSuites = new HashSet<>();\n        for (Cipher cipher : Cipher.values()) {\n            String openSSLAlias = cipher.getOpenSSLAlias();\n            // OpenSSL does not implement any FORTEZZA algorithms so exclude\n            // them from the expected list\n            if (openSSLAlias.contains(\"FZA\")) {\n                continue;\n            }\n            // GOST algorithms are not enabled by default and no JSSE\n            // implementation supports them so exclude them from the expected\n            // list\n            if (openSSLAlias.contains(\"GOST\")) {\n                continue;\n            }\n            // OpenSSL does not implement any DH-DSS or DH-RSA algorithms so\n            // exclude them from the expected list\n            if (openSSLAlias.startsWith(\"DH-DSS\") || openSSLAlias.startsWith(\"EXP-DH-DSS\")) {\n                continue;\n            }\n            if (openSSLAlias.startsWith(\"DH-RSA\") || openSSLAlias.startsWith(\"EXP-DH-RSA\")) {\n                continue;\n            }\n            // OpenSSL does not enable the experimental EXP1024 and\n            // DHE-DSS-RC4-SHA cipher suites unless the source is explicitly\n            // patched so exclude them from the expected list\n            if (openSSLAlias.contains(\"EXP1024\")) {\n                continue;\n            }\n            if (openSSLAlias.contains(\"DHE-DSS-RC4-SHA\")) {\n                continue;\n            }\n            // RC2-MD5 is not referenced in the OpenSSL source so exclude it\n            // from the expected list\n            if (openSSLAlias.contains(\"RC2-MD5\")) {\n                continue;\n            }\n            expectedCipherSuites.add(openSSLAlias);\n        }\n\n        Set<String> unavailableCipherSuites = new HashSet<>();\n        unavailableCipherSuites.addAll(expectedCipherSuites);\n        unavailableCipherSuites.removeAll(availableCipherSuites);\n        StringBuilder unavailableList = new StringBuilder();\n        for (String cipher : unavailableCipherSuites) {\n            unavailableList.append(cipher);\n            unavailableList.append(' ');\n        }\n        Assert.assertEquals(unavailableList.toString(), 0,  unavailableCipherSuites.size());\n\n        Set<String> unexpectedCipherSuites = new HashSet<>();\n        unexpectedCipherSuites.addAll(availableCipherSuites);\n        unexpectedCipherSuites.removeAll(expectedCipherSuites);\n        StringBuilder unexpectedList = new StringBuilder();\n        for (String cipher : unexpectedCipherSuites) {\n            unexpectedList.append(cipher);\n            unexpectedList.append(' ');\n        }\n        Assert.assertEquals(unexpectedList.toString(), 0,  unexpectedCipherSuites.size());\n\n    }","commit_id":"c3605957950e219a3c1451aeb09bb839335bdf9f","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Execute an XForms action.\n     *\n     * @param pipelineContext       current PipelineContext\n     * @param targetId              id of the target control\n     * @param eventHandlerContainer event handler containe this action is running in\n     * @param actionElement         Element specifying the action to execute\n     * @param actionContext         ActionContext instance for deferred updates, or null\n     */\n    public void runAction(final PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement, ActionContext actionContext) {\n\n        // Check that we understand the action element\n        final String actionNamespaceURI = actionElement.getNamespaceURI();\n        if (!XFormsConstants.XFORMS_NAMESPACE_URI.equals(actionNamespaceURI)) {\n            throw new OXFException(\"Invalid action namespace: \" + actionNamespaceURI);\n        }\n\n        // Set binding context\n        setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n\n        final String actionEventName = actionElement.getName();\n\n        if (XFormsServer.logger.isDebugEnabled())\n            XFormsServer.logger.debug(\"XForms - executing action: \" + actionEventName);\n\n        if (XFormsActions.XFORMS_SETVALUE_ACTION.equals(actionEventName)) {\n            // 10.1.9 The setvalue Element\n            // xforms:setvalue\n\n            final String value = actionElement.attributeValue(\"value\");\n            final String content = actionElement.getStringValue();\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String valueToSet;\n            if (value != null) {\n                // Value to set is computed with an XPath expression\n                Map namespaceContext = Dom4jUtils.getNamespaceContextNoDefault(actionElement);\n                valueToSet = currentInstance.evaluateXPathAsString(pipelineContext,\n                        xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                        value, namespaceContext, null, xformsControls.getFunctionLibrary(), null);\n            } else {\n                // Value to set is static content\n                valueToSet = content;\n            }\n\n            // Set value on current node\n            final Node currentNode = xformsControls.getCurrentSingleNode();\n            XFormsInstance.setValueForNode(pipelineContext, currentNode, valueToSet, null);\n\n            if (actionContext != null) {\n                // \"XForms Actions that change only the value of an instance node results in setting\n                // the flags for recalculate, revalidate, and refresh to true and making no change to\n                // the flag for rebuild\".\n                actionContext.recalculate = true;\n                actionContext.revalidate = true;\n                actionContext.refresh = true;\n            } else {\n                // Send events directly\n                final XFormsModel model = xformsControls.getCurrentModel();\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_RESET_ACTION.equals(actionEventName)) {\n            // 10.1.11 The reset Element\n\n            final String modelId = actionElement.attributeValue(\"model\");\n\n            final Object modelObject = containingDocument.getObjectById(pipelineContext, modelId);\n            if (modelObject instanceof XFormsModel) {\n                final XFormsModel model = (XFormsModel) modelObject;\n                containingDocument.dispatchEvent(pipelineContext, new XFormsResetEvent(model));\n            } else {\n                throw new OXFException(\"xforms:reset model attribute must point to an xforms:model element.\");\n            }\n\n            // \"the reset action takes effect immediately and clears all of the flags.\"\n            if (actionContext != null)\n                actionContext.setAll(false);\n\n        } else if (XFormsActions.XFORMS_ACTION_ACTION.equals(actionEventName)) {\n            // 10.1.1 The action Element\n\n            final ActionContext newActionContext = (actionContext == null) ? new ActionContext() : null;\n            for (Iterator i = actionElement.elementIterator(); i.hasNext();) {\n                final Element embeddedActionElement = (Element) i.next();\n                runAction(pipelineContext, targetId, eventHandlerContainer, embeddedActionElement, (newActionContext == null) ? actionContext : newActionContext );\n            }\n            if (newActionContext != null) {\n                // Binding context has to be reset as it may have been modified by sub-actions\n                setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                final XFormsModel model = xformsControls.getCurrentModel();\n\n                // Process deferred behavior\n                if (newActionContext.rebuild)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                if (newActionContext.recalculate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                if (newActionContext.revalidate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                if (newActionContext.refresh)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_REBUILD_ACTION.equals(actionEventName)) {\n            // 10.1.3 The rebuild Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.rebuild = false;\n\n        } else if (XFormsActions.XFORMS_RECALCULATE_ACTION.equals(actionEventName)) {\n            // 10.1.4 The recalculate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.recalculate = false;\n\n        } else if (XFormsActions.XFORMS_REVALIDATE_ACTION.equals(actionEventName)) {\n            // 10.1.5 The revalidate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.revalidate = false;\n\n        } else if (XFormsActions.XFORMS_REFRESH_ACTION.equals(actionEventName)) {\n            // 10.1.6 The refresh Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.refresh = false;\n\n        } else if (XFormsActions.XFORMS_TOGGLE_ACTION.equals(actionEventName)) {\n            // 9.2.3 The toggle Element\n\n            // TODO: Handle repeat controls, AKA \"switch within repeat\"\n            final String caseId = actionElement.attributeValue(\"case\");\n\n            // Update xforms:switch info and dispatch events\n            xformsControls.updateSwitchInfo(pipelineContext, caseId);\n\n        } else if (XFormsActions.XFORMS_INSERT_ACTION.equals(actionEventName)) {\n            // 9.3.5 The insert Element\n            final String atAttribute = actionElement.attributeValue(\"at\");\n            final String positionAttribute = actionElement.attributeValue(\"position\");\n            final String originAttribute = actionElement.attributeValue(\"origin\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the insert action has no effect.\"\n\n                // \"2. The node-set binding identifies a homogeneous collection in the instance\n                // data. The final member of this collection is cloned to produce the node that will\n                // be inserted.\"\n                final Element clonedElement;\n                {\n                    if (originAttribute == null) {\n                        final Element lastElement = (Element) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1);\n                        clonedElement = (Element) lastElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                    } else {\n                        xformsControls.pushBinding(pipelineContext, null, originAttribute, null, null, null, Dom4jUtils.getNamespaceContextNoDefault(actionElement));\n                        final Element templateElement =  (Element) xformsControls.getCurrentSingleNode();// TODO: for now only support Elemewnt\n                        clonedElement = templateElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                        xformsControls.popBinding();\n                    }\n                }\n\n                // \"Finally, this newly created node is inserted into the instance data at the location\n                // specified by attributes position and at.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final String insertionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                        xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                // Don't think we will get NaN with XPath 2.0...\n                int insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                // Adjust index to be in range\n                if (insertionIndex > collectionToBeUpdated.size())\n                    insertionIndex = collectionToBeUpdated.size();\n\n                if (insertionIndex < 1)\n                    insertionIndex = 1;\n\n                // Find actual insertion point and insert\n                final Element indexElement = (Element) collectionToBeUpdated.get(insertionIndex - 1);\n\n                final Element parentElement = indexElement.getParent();\n                final List siblingElements = parentElement.content();\n                final int actualIndex = siblingElements.indexOf(indexElement);\n\n                // Prepare insertion of new element\n                final int actualInsertionIndex;\n                if (\"after\".equals(positionAttribute) || \"NaN\".equals(insertionIndexString)) {\n                    actualInsertionIndex = actualIndex + 1;\n                } else if (\"before\".equals(positionAttribute)) {\n                    actualInsertionIndex = actualIndex;\n                } else {\n                    throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after'.\");\n                }\n\n                // \"3. The index for any repeating sequence that is bound to the homogeneous\n                // collection where the node was added is updated to point to the newly added node.\n                // The indexes for inner nested repeat collections are re-initialized to\n                // startindex.\"\n\n                // Perform the insertion\n                siblingElements.add(actualInsertionIndex, clonedElement);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat indexes\n                // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n                currentControlsState.visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n                    private XFormsControls.ControlInfo foundControl;\n\n                    public void startVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            // Found an xforms:repeat\n                            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) controlInfo;\n                            final String repeatId = repeatControlInfo.getOriginalId();\n                            final List repeatNodeSet = xformsControls.getCurrentNodeset();\n\n                            if (foundControl == null) {\n                                // We are not yet inside a matching xforms:repeat\n\n                                if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                                    // Find whether one node of the repeat node-set contains the inserted node\n                                    int index = 1;\n                                    for (Iterator i = repeatNodeSet.iterator(); i.hasNext(); index++) {\n                                        final Element currentNode = (Element) i.next();\n                                        if (currentNode == clonedElement) {\n                                            // Found xforms:repeat affected by the change\n\n                                            // \"The index for any repeating sequence that is bound\n                                            // to the homogeneous collection where the node was\n                                            // added is updated to point to the newly added node.\"\n                                            currentControlsState.updateRepeatIndex(repeatId, index);\n\n                                            // First step: set all children indexes to 0\n                                            final List nestedRepeatIds = currentControlsState.getNestedRepeatIds(xformsControls, repeatId);\n                                            if (nestedRepeatIds != null) {\n                                                for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                                    final String nestedRepeatId = (String) j.next();\n                                                    currentControlsState.updateRepeatIndex(nestedRepeatId, 0);\n                                                }\n                                            }\n\n                                            foundControl = controlInfo;\n                                            break;\n                                        }\n                                    }\n\n                                    if (foundControl == null) {\n                                        // Still not found a control. Make sure the bounds of this\n                                        // xforms:repeat are correct for the rest of the visit.\n\n                                        final int adjustedNewIndex;\n                                        {\n                                            final int newIndex = ((Integer) xformsControls.getCurrentControlsState().getRepeatIdToIndex().get(repeatId)).intValue();\n\n                                            // Adjust bounds if necessary\n                                            if (newIndex < 1)\n                                                adjustedNewIndex = 1;\n                                            else if (newIndex > repeatNodeSet.size())\n                                                adjustedNewIndex = repeatNodeSet.size();\n                                            else\n                                                adjustedNewIndex = newIndex;\n                                        }\n\n                                        // Set index\n                                        xformsControls.getCurrentControlsState().updateRepeatIndex(repeatId, adjustedNewIndex);\n                                    }\n\n                                } else {\n                                    // Make sure the index is set to zero when the node-set is empty\n                                    currentControlsState.updateRepeatIndex(repeatId, 0);\n                                }\n                            } else {\n                                // This is a child xforms:repeat of a matching xforms:repeat\n                                // Second step: update non-empty repeat indexes to the appropriate value\n\n                                // \"The indexes for inner nested repeat collections are re-initialized to startindex.\"\n\n                                // NOTE: We do this, but we also adjust the index:\n                                // \"The index for this repeating structure is initialized to the\n                                // value of startindex. If the initial startindex is less than 1 it\n                                // defaults to 1. If the index is greater than the initial node-set\n                                // then it defaults to the size of the node-set.\"\n\n                                if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                                    int newIndex = repeatControlInfo.getStartIndex();\n\n                                    if (newIndex < 1)\n                                        newIndex = 1;\n                                    if (newIndex > repeatNodeSet.size())\n                                        newIndex = repeatNodeSet.size();\n\n                                    currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                                } else {\n                                    // Make sure the index is set to zero when the node-set is empty\n                                    // (although this should already have been done above by the\n                                    // enclosing xforms:repeat)\n                                    currentControlsState.updateRepeatIndex(repeatId, 0);\n                                }\n                            }\n                        }\n                    }\n\n                    public void endVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            if (foundControl == controlInfo)\n                                foundControl = null;\n                        }\n                    }\n                });\n\n                // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_DELETE_ACTION.equals(actionEventName)) {\n            // 9.3.6 The delete Element\n\n            final String atAttribute = actionElement.attributeValue(\"at\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToUpdate = xformsControls.getCurrentNodeset();\n\n            if (collectionToUpdate != null && collectionToUpdate.size() > 0) {\n                // \"If the collection is empty, the delete action has no effect.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final Element elementToRemove;\n                final List siblingElements;\n                final int actualIndexInCollection;\n                {\n                    final String deletionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                            xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                            \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // We will not get NaN with XPath 2.0...\n                    int tempDeletionIndex = \"NaN\".equals(deletionIndexString) ? collectionToUpdate.size() : Integer.parseInt(deletionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (tempDeletionIndex > collectionToUpdate.size())\n                        tempDeletionIndex = collectionToUpdate.size();\n\n                    if (tempDeletionIndex < 1)\n                        tempDeletionIndex = 1;\n\n                    // Find actual deletion point\n                    elementToRemove = (Element) collectionToUpdate.get(tempDeletionIndex - 1);\n                    final Element parentElement = elementToRemove.getParent();\n                    siblingElements = parentElement.elements();\n                    actualIndexInCollection = siblingElements.indexOf(elementToRemove);\n                }\n\n                // Get current repeat indexes\n                final Map previousRepeatIdToIndex = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n                // Find updates to repeat indexes\n                final Map repeatIndexUpdates = new HashMap();\n                final Map nestedRepeatIndexUpdates = new HashMap();\n                // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n                xformsControls.getCurrentControlsState().visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n                    private XFormsControls.ControlInfo foundControl;\n                    private boolean reinitializeInner;\n\n                    public void startVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            // Found an xforms:repeat\n                            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) controlInfo;\n                            final String repeatId = repeatControlInfo.getOriginalId();\n\n                            final List repeatNodeSet = xformsControls.getCurrentNodeset();\n                            if (foundControl == null) {\n                                // We are not yet inside a matching xforms:repeat\n\n                                if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                                    // Find whether one node of the repeat node-set contains the inserted node\n                                    for (Iterator i = repeatNodeSet.iterator(); i.hasNext();) {\n                                        final Element currentNode = (Element) i.next();\n                                        if (currentNode == elementToRemove) {\n                                            // Found xforms:repeat affected by the change\n\n                                            final int newIndex;\n                                            if (repeatNodeSet.size() == 1) {\n                                                // Delete the last element of the collection: the index must be set to 0\n                                                newIndex = 0;\n                                                reinitializeInner = false;\n                                            } else {\n                                                // Current index for this repeat\n                                                final int currentIndex = ((Integer) previousRepeatIdToIndex.get(repeatId)).intValue();\n\n                                                // Index of deleted element for this repeat\n                                                final int deletionIndexInRepeat = repeatNodeSet.indexOf(elementToRemove) + 1;\n\n                                                if (currentIndex == deletionIndexInRepeat) {\n                                                    if (deletionIndexInRepeat == repeatNodeSet.size()) {\n\n                                                        // o \"When the last remaining item in the collection is removed,\n                                                        // the index position becomes 0.\"\n\n                                                        // o \"When the index was pointing to the deleted node, which was\n                                                        // the last item in the collection, the index will point to the new\n                                                        // last node of the collection and the index of inner repeats is\n                                                        // reinitialized.\"\n\n                                                        newIndex = currentIndex - 1;\n                                                        reinitializeInner = true;\n                                                    } else {\n                                                        // o \"When the index was pointing to the deleted node, which was\n                                                        // not the last item in the collection, the index position is not\n                                                        // changed and the index of inner repeats is re-initialized.\"\n\n                                                        newIndex = currentIndex;\n                                                        reinitializeInner = true;\n                                                    }\n                                                } else {\n                                                    // \"The index should point to the same node\n                                                    // after a delete as it did before the delete\"\n\n                                                    if (currentIndex < deletionIndexInRepeat) {\n                                                        newIndex = currentIndex;\n                                                    } else {\n                                                        newIndex = currentIndex - 1;\n                                                    }\n                                                    reinitializeInner = false;\n                                                }\n                                            }\n\n                                            repeatIndexUpdates.put(repeatId, new Integer(newIndex));\n\n                                            // Handle children\n                                            if (reinitializeInner) {\n                                                // First step: set all children indexes to 0\n                                                final List nestedRepeatIds = xformsControls.getCurrentControlsState().getNestedRepeatIds(xformsControls, repeatId);\n                                                if (nestedRepeatIds != null) {\n                                                    for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                                        final String nestedRepeatId = (String) j.next();\n                                                        repeatIndexUpdates.put(nestedRepeatId, new Integer(0));\n                                                        nestedRepeatIndexUpdates.put(nestedRepeatId, \"\");\n                                                    }\n                                                }\n                                            }\n\n                                            foundControl = controlInfo;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    public void endVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            if (foundControl == controlInfo)\n                                foundControl = null;\n                        }\n                    }\n                });\n\n                // Then only perform the deletion\n                siblingElements.remove(actualIndexInCollection);\n\n                // Update affected repeat index information\n                if (repeatIndexUpdates.size() > 0) {\n                    for (Iterator i = repeatIndexUpdates.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry = (Map.Entry) i.next();\n                        xformsControls.getCurrentControlsState().updateRepeatIndex((String) currentEntry.getKey(), ((Integer) currentEntry.getValue()).intValue());\n                    }\n                }\n\n                // Adjust controls ids that could have gone out of bounds\n                adjustRepeatIndexes(pipelineContext, xformsControls, nestedRepeatIndexUpdates);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsDeleteEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETINDEX_ACTION.equals(actionEventName)) {\n            // 9.3.7 The setindex Element\n\n            final String repeatId = actionElement.attributeValue(\"repeat\");\n            final String indexXPath = actionElement.attributeValue(\"index\");\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String indexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                    xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                    \"string(number(\" + indexXPath + \"))\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n            executeSetindexAction(pipelineContext, containingDocument, repeatId, indexString);\n\n        } else if (XFormsActions.XFORMS_SEND_ACTION.equals(actionEventName)) {\n            // 10.1.10 The send Element\n\n            // Find submission object\n            final String submissionId = actionElement.attributeValue(\"submission\");\n            if (submissionId == null)\n                throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n            final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n            if (submission == null || !(submission instanceof XFormsModelSubmission))\n                throw new OXFException(\"submission attribute on xforms:send element does not refer to existing xforms:submission element.\");\n\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n\n        } else if (XFormsActions.XFORMS_DISPATCH_ACTION.equals(actionEventName)) {\n            // 10.1.2 The dispatch Element\n\n            // Mandatory attributes\n            final String newEventName = actionElement.attributeValue(\"name\");\n            if (newEventName == null)\n                throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n            final String newEventTargetId = actionElement.attributeValue(\"target\");\n            if (newEventTargetId == null)\n                throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n            // Optional attributes\n            final boolean newEventBubbles; {\n                final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n            }\n            final boolean newEventCancelable; {\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n                newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n            }\n\n            // Find actual target\n            final Object xformsEventTarget;\n            {\n                final Object tempXFormsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetId);\n                if (tempXFormsEventTarget != null) {\n                    // Object with this id exists \n                    xformsEventTarget = tempXFormsEventTarget;\n                } else {\n                    // Otherwise, try effective id\n                    final String newEventTargetEffectiveId = xformsControls.getCurrentControlsState().findEffectiveControlId(newEventTargetId);\n                    xformsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetEffectiveId);\n                }\n            }\n\n            if (xformsEventTarget == null)\n                throw new OXFException(\"Could not find actual event target on xforms:dispatch element for id: \" + newEventTargetId);\n\n            if (xformsEventTarget instanceof XFormsEventTarget) {\n                // This can be anything\n                containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(newEventName, (XFormsEventTarget) xformsEventTarget, newEventBubbles, newEventCancelable));\n            } else {\n                throw new OXFException(\"Invalid event target for id: \" + newEventTargetId);\n            }\n\n        } else if (XFormsActions.XFORMS_MESSAGE_ACTION.equals(actionEventName)) {\n            // 10.1.12 The message Element\n\n            final String level;\n            {\n                final String levelAttribute = actionElement.attributeValue(\"level\");;\n                if (levelAttribute == null)\n                    throw new OXFException(\"xforms:message element is missing mandatory 'level' attribute.\");\n                final QName levelQName = Dom4jUtils.extractAttributeValueQName(actionElement, \"level\");\n                if (levelQName.getNamespacePrefix().equals(\"\")) {\n                    if (!(\"ephemeral\".equals(levelAttribute) || \"modeless\".equals(levelAttribute) || \"modal\".equals(levelAttribute))) {\n                        throw new OXFException(\"xforms:message element's 'level' attribute must have value: 'ephemeral'|'modeless'|'modal'|QName-but-not-NCName.\");\n                    }\n                    level = levelAttribute;\n                } else {\n                    level = \"{\" + levelQName.getNamespaceURI() + \"}\" + levelQName.getName();\n                }\n            }\n\n            final String src = actionElement.attributeValue(\"src\");\n            final String ref = actionElement.attributeValue(\"ref\");\n\n            String message = null;\n\n            // Try to get message from single-node binding if any\n            if (ref != null) {\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null)\n                    message = XFormsInstance.getValueForNode(currentNode);\n            }\n\n            // Try to get message from linking attribute\n            boolean linkException = false;\n            if (message == null && src != null) {\n                try {\n                    message = XFormsUtils.retrieveSrcValue(src);\n                } catch (IOException e) {\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), src, null, e));\n                    linkException = true;\n                }\n            }\n\n            if (!linkException) {\n                // Try to get inline message\n                if (message == null) {\n                    message = actionElement.getStringValue();\n                }\n\n                if (message != null) {\n                    // Store message for sending to client\n                    containingDocument.addClientMessage(message, level);\n\n                    // NOTE: In the future, we *may* want to save and resume the event state before and\n                    // after displaying a message, in order to possibly provide a behavior which is more\n                    // consistent with what users may expect regarding actions executed after\n                    // xforms:message.\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETFOCUS_ACTION.equals(actionEventName)) {\n\n            // 10.1.7 The setfocus Element\n\n            final String controlId = actionElement.attributeValue(\"control\");\n            if (controlId == null)\n                throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n            final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(controlId);\n            if (effectiveControlId == null)\n                throw new OXFException(\"Could not find actual control on xforms:setfocus element for control: \" + controlId);\n\n            final Object controlObject = containingDocument.getObjectById(pipelineContext, effectiveControlId);\n\n            if (!(controlObject instanceof XFormsControls.ControlInfo))\n                throw new OXFException(\"xforms:setfocus attribute 'control' must refer to a control: \" + controlId);\n\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n\n        } else if (XFormsActions.XFORMS_LOAD_ACTION.equals(actionEventName)) {\n\n            // 10.1.8 The load Element\n\n            final String ref = actionElement.attributeValue(\"ref\");\n            final String resource = actionElement.attributeValue(\"resource\");\n            final String showAttribute;\n            {\n                final String rawShowAttribute = actionElement.attributeValue(\"show\");\n                showAttribute = (rawShowAttribute == null) ? \"replace\" : rawShowAttribute;\n                if (!(\"replace\".equals(showAttribute) || \"new\".equals(showAttribute)))\n                    throw new OXFException(\"Invalid value for 'show' attribute on xforms:load element: \" + showAttribute);\n            }\n            final boolean doReplace = \"replace\".equals(showAttribute);\n            final String target = actionElement.attributeValue(XFormsConstants.XXFORMS_TARGET_QNAME);\n            final String urlType = actionElement.attributeValue(new QName(\"url-type\", new Namespace(\"f\", XMLConstants.OPS_FORMATTING_URI)));\n\n            if (ref != null && resource != null) {\n                // \"If both are present, the action has no effect.\"\n                // NOP\n            } else if (ref != null) {\n                // Use single-node binding\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null) {\n                    final String value = XFormsInstance.getValueForNode(currentNode);\n                    resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, value, target, urlType);\n                } else {\n                    // Should we do this here?\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), \"\", null, null));\n                }\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else if (resource != null) {\n                // Use linking attribute\n                resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, resource, target, urlType);\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else {\n                // \"Either the single node binding attributes, pointing to a URI in the instance\n                // data, or the linking attributes are required.\"\n                throw new OXFException(\"Missing 'resource' or 'ref' attribute on xforms:load element.\");\n            }\n        } else {\n            throw new OXFException(\"Invalid action requested: \" + actionEventName);\n        }\n    }","id":47174,"modified_method":"/**\n     * Execute an XForms action.\n     *\n     * @param pipelineContext       current PipelineContext\n     * @param targetId              id of the target control\n     * @param eventHandlerContainer event handler containe this action is running in\n     * @param actionElement         Element specifying the action to execute\n     * @param actionContext         ActionContext instance for deferred updates, or null\n     */\n    public void runAction(final PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement, ActionContext actionContext) {\n\n        // Check that we understand the action element\n        final String actionNamespaceURI = actionElement.getNamespaceURI();\n        if (!XFormsConstants.XFORMS_NAMESPACE_URI.equals(actionNamespaceURI)) {\n            throw new OXFException(\"Invalid action namespace: \" + actionNamespaceURI);\n        }\n\n        // Set binding context\n        setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n\n        final String actionEventName = actionElement.getName();\n\n        if (XFormsServer.logger.isDebugEnabled())\n            XFormsServer.logger.debug(\"XForms - executing action: \" + actionEventName);\n\n        if (XFormsActions.XFORMS_SETVALUE_ACTION.equals(actionEventName)) {\n            // 10.1.9 The setvalue Element\n            // xforms:setvalue\n\n            final String value = actionElement.attributeValue(\"value\");\n            final String content = actionElement.getStringValue();\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String valueToSet;\n            if (value != null) {\n                // Value to set is computed with an XPath expression\n                Map namespaceContext = Dom4jUtils.getNamespaceContextNoDefault(actionElement);\n                valueToSet = currentInstance.evaluateXPathAsString(pipelineContext,\n                        xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                        value, namespaceContext, null, xformsControls.getFunctionLibrary(), null);\n            } else {\n                // Value to set is static content\n                valueToSet = content;\n            }\n\n            // Set value on current node\n            final Node currentNode = xformsControls.getCurrentSingleNode();\n            XFormsInstance.setValueForNode(pipelineContext, currentNode, valueToSet, null);\n\n            if (actionContext != null) {\n                // \"XForms Actions that change only the value of an instance node results in setting\n                // the flags for recalculate, revalidate, and refresh to true and making no change to\n                // the flag for rebuild\".\n                actionContext.recalculate = true;\n                actionContext.revalidate = true;\n                actionContext.refresh = true;\n            } else {\n                // Send events directly\n                final XFormsModel model = xformsControls.getCurrentModel();\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_RESET_ACTION.equals(actionEventName)) {\n            // 10.1.11 The reset Element\n\n            final String modelId = actionElement.attributeValue(\"model\");\n\n            final Object modelObject = containingDocument.getObjectById(pipelineContext, modelId);\n            if (modelObject instanceof XFormsModel) {\n                final XFormsModel model = (XFormsModel) modelObject;\n                containingDocument.dispatchEvent(pipelineContext, new XFormsResetEvent(model));\n            } else {\n                throw new OXFException(\"xforms:reset model attribute must point to an xforms:model element.\");\n            }\n\n            // \"the reset action takes effect immediately and clears all of the flags.\"\n            if (actionContext != null)\n                actionContext.setAll(false);\n\n        } else if (XFormsActions.XFORMS_ACTION_ACTION.equals(actionEventName)) {\n            // 10.1.1 The action Element\n\n            final ActionContext newActionContext = (actionContext == null) ? new ActionContext() : null;\n            for (Iterator i = actionElement.elementIterator(); i.hasNext();) {\n                final Element embeddedActionElement = (Element) i.next();\n                runAction(pipelineContext, targetId, eventHandlerContainer, embeddedActionElement, (newActionContext == null) ? actionContext : newActionContext );\n            }\n            if (newActionContext != null) {\n                // Binding context has to be reset as it may have been modified by sub-actions\n                setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                final XFormsModel model = xformsControls.getCurrentModel();\n\n                // Process deferred behavior\n                if (newActionContext.rebuild)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                if (newActionContext.recalculate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                if (newActionContext.revalidate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                if (newActionContext.refresh)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_REBUILD_ACTION.equals(actionEventName)) {\n            // 10.1.3 The rebuild Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.rebuild = false;\n\n        } else if (XFormsActions.XFORMS_RECALCULATE_ACTION.equals(actionEventName)) {\n            // 10.1.4 The recalculate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.recalculate = false;\n\n        } else if (XFormsActions.XFORMS_REVALIDATE_ACTION.equals(actionEventName)) {\n            // 10.1.5 The revalidate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.revalidate = false;\n\n        } else if (XFormsActions.XFORMS_REFRESH_ACTION.equals(actionEventName)) {\n            // 10.1.6 The refresh Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.refresh = false;\n\n        } else if (XFormsActions.XFORMS_TOGGLE_ACTION.equals(actionEventName)) {\n            // 9.2.3 The toggle Element\n\n            // TODO: Handle repeat controls, AKA \"switch within repeat\"\n            final String caseId = actionElement.attributeValue(\"case\");\n\n            // Update xforms:switch info and dispatch events\n            xformsControls.updateSwitchInfo(pipelineContext, caseId);\n\n        } else if (XFormsActions.XFORMS_INSERT_ACTION.equals(actionEventName)) {\n            // 9.3.5 The insert Element\n            final String atAttribute = actionElement.attributeValue(\"at\");\n            final String positionAttribute = actionElement.attributeValue(\"position\");\n            final String originAttribute = actionElement.attributeValue(\"origin\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the insert action has no effect.\"\n\n                // \"2. The node-set binding identifies a homogeneous collection in the instance\n                // data. The final member of this collection is cloned to produce the node that will\n                // be inserted.\"\n                final Element clonedElement;\n                {\n                    if (originAttribute == null) {\n                        final Element lastElement = (Element) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1);\n                        clonedElement = (Element) lastElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                    } else {\n                        xformsControls.pushBinding(pipelineContext, null, originAttribute, null, null, null, Dom4jUtils.getNamespaceContextNoDefault(actionElement));\n                        final Element templateElement =  (Element) xformsControls.getCurrentSingleNode();// TODO: for now only support Elemewnt\n                        clonedElement = templateElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                        xformsControls.popBinding();\n                    }\n                }\n\n                // \"Finally, this newly created node is inserted into the instance data at the location\n                // specified by attributes position and at.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final String insertionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                        xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                // Don't think we will get NaN with XPath 2.0...\n                int insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                // Adjust index to be in range\n                if (insertionIndex > collectionToBeUpdated.size())\n                    insertionIndex = collectionToBeUpdated.size();\n\n                if (insertionIndex < 1)\n                    insertionIndex = 1;\n\n                // Find actual insertion point and insert\n                final Element indexElement = (Element) collectionToBeUpdated.get(insertionIndex - 1);\n\n                final Element parentElement = indexElement.getParent();\n                final List siblingElements = parentElement.content();\n                final int actualIndex = siblingElements.indexOf(indexElement);\n\n                // Prepare insertion of new element\n                final int actualInsertionIndex;\n                if (\"after\".equals(positionAttribute) || \"NaN\".equals(insertionIndexString)) {\n                    actualInsertionIndex = actualIndex + 1;\n                } else if (\"before\".equals(positionAttribute)) {\n                    actualInsertionIndex = actualIndex;\n                } else {\n                    throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after'.\");\n                }\n\n                // \"3. The index for any repeating sequence that is bound to the homogeneous\n                // collection where the node was added is updated to point to the newly added node.\n                // The indexes for inner nested repeat collections are re-initialized to\n                // startindex.\"\n\n                // Perform the insertion\n                siblingElements.add(actualInsertionIndex, clonedElement);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat indexes\n                // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n                currentControlsState.visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n                    private XFormsControls.ControlInfo foundControl;\n\n                    public void startVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            // Found an xforms:repeat\n                            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) controlInfo;\n                            final String repeatId = repeatControlInfo.getOriginalId();\n                            final List repeatNodeSet = xformsControls.getCurrentNodeset();\n\n                            if (foundControl == null) {\n                                // We are not yet inside a matching xforms:repeat\n\n                                if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                                    // Find whether one node of the repeat node-set contains the inserted node\n                                    int index = 1;\n                                    for (Iterator i = repeatNodeSet.iterator(); i.hasNext(); index++) {\n                                        final Element currentNode = (Element) i.next();\n                                        if (currentNode == clonedElement) {\n                                            // Found xforms:repeat affected by the change\n\n                                            // \"The index for any repeating sequence that is bound\n                                            // to the homogeneous collection where the node was\n                                            // added is updated to point to the newly added node.\"\n                                            currentControlsState.updateRepeatIndex(repeatId, index);\n\n                                            // First step: set all children indexes to 0\n                                            final List nestedRepeatIds = currentControlsState.getNestedRepeatIds(xformsControls, repeatId);\n                                            if (nestedRepeatIds != null) {\n                                                for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                                    final String nestedRepeatId = (String) j.next();\n                                                    currentControlsState.updateRepeatIndex(nestedRepeatId, 0);\n                                                }\n                                            }\n\n                                            foundControl = controlInfo;\n                                            break;\n                                        }\n                                    }\n\n                                    if (foundControl == null) {\n                                        // Still not found a control. Make sure the bounds of this\n                                        // xforms:repeat are correct for the rest of the visit.\n\n                                        final int adjustedNewIndex;\n                                        {\n                                            final int newIndex = ((Integer) currentControlsState.getRepeatIdToIndex().get(repeatId)).intValue();\n\n                                            // Adjust bounds if necessary\n                                            if (newIndex < 1)\n                                                adjustedNewIndex = 1;\n                                            else if (newIndex > repeatNodeSet.size())\n                                                adjustedNewIndex = repeatNodeSet.size();\n                                            else\n                                                adjustedNewIndex = newIndex;\n                                        }\n\n                                        // Set index\n                                        currentControlsState.updateRepeatIndex(repeatId, adjustedNewIndex);\n                                    }\n\n                                } else {\n                                    // Make sure the index is set to zero when the node-set is empty\n                                    currentControlsState.updateRepeatIndex(repeatId, 0);\n                                }\n                            } else {\n                                // This is a child xforms:repeat of a matching xforms:repeat\n                                // Second step: update non-empty repeat indexes to the appropriate value\n\n                                // \"The indexes for inner nested repeat collections are re-initialized to startindex.\"\n\n                                // NOTE: We do this, but we also adjust the index:\n                                // \"The index for this repeating structure is initialized to the\n                                // value of startindex. If the initial startindex is less than 1 it\n                                // defaults to 1. If the index is greater than the initial node-set\n                                // then it defaults to the size of the node-set.\"\n\n                                if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                                    int newIndex = repeatControlInfo.getStartIndex();\n\n                                    if (newIndex < 1)\n                                        newIndex = 1;\n                                    if (newIndex > repeatNodeSet.size())\n                                        newIndex = repeatNodeSet.size();\n\n                                    currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                                } else {\n                                    // Make sure the index is set to zero when the node-set is empty\n                                    // (although this should already have been done above by the\n                                    // enclosing xforms:repeat)\n                                    currentControlsState.updateRepeatIndex(repeatId, 0);\n                                }\n                            }\n                        }\n                    }\n\n                    public void endVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            if (foundControl == controlInfo)\n                                foundControl = null;\n                        }\n                    }\n                });\n\n                // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_DELETE_ACTION.equals(actionEventName)) {\n            // 9.3.6 The delete Element\n\n            final String atAttribute = actionElement.attributeValue(\"at\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToUpdate = xformsControls.getCurrentNodeset();\n\n            if (collectionToUpdate != null && collectionToUpdate.size() > 0) {\n                // \"If the collection is empty, the delete action has no effect.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final Element elementToRemove;\n                final List siblingElements;\n                final int actualIndexInCollection;\n                {\n                    final String deletionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                            xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                            \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // We will not get NaN with XPath 2.0...\n                    int tempDeletionIndex = \"NaN\".equals(deletionIndexString) ? collectionToUpdate.size() : Integer.parseInt(deletionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (tempDeletionIndex > collectionToUpdate.size())\n                        tempDeletionIndex = collectionToUpdate.size();\n\n                    if (tempDeletionIndex < 1)\n                        tempDeletionIndex = 1;\n\n                    // Find actual deletion point\n                    elementToRemove = (Element) collectionToUpdate.get(tempDeletionIndex - 1);\n                    final Element parentElement = elementToRemove.getParent();\n                    siblingElements = parentElement.elements();\n                    actualIndexInCollection = siblingElements.indexOf(elementToRemove);\n                }\n\n                // Get current repeat indexes\n                final Map previousRepeatIdToIndex = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n                // Find updates to repeat indexes\n                final Map repeatIndexUpdates = new HashMap();\n                final Map nestedRepeatIndexUpdates = new HashMap();\n                // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n                xformsControls.getCurrentControlsState().visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n                    private XFormsControls.ControlInfo foundControl;\n                    private boolean reinitializeInner;\n\n                    public void startVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            // Found an xforms:repeat\n                            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) controlInfo;\n                            final String repeatId = repeatControlInfo.getOriginalId();\n\n                            final List repeatNodeSet = xformsControls.getCurrentNodeset();\n                            if (foundControl == null) {\n                                // We are not yet inside a matching xforms:repeat\n\n                                if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                                    // Find whether one node of the repeat node-set contains the inserted node\n                                    for (Iterator i = repeatNodeSet.iterator(); i.hasNext();) {\n                                        final Element currentNode = (Element) i.next();\n                                        if (currentNode == elementToRemove) {\n                                            // Found xforms:repeat affected by the change\n\n                                            final int newIndex;\n                                            if (repeatNodeSet.size() == 1) {\n                                                // Delete the last element of the collection: the index must be set to 0\n                                                newIndex = 0;\n                                                reinitializeInner = false;\n                                            } else {\n                                                // Current index for this repeat\n                                                final int currentIndex = ((Integer) previousRepeatIdToIndex.get(repeatId)).intValue();\n\n                                                // Index of deleted element for this repeat\n                                                final int deletionIndexInRepeat = repeatNodeSet.indexOf(elementToRemove) + 1;\n\n                                                if (currentIndex == deletionIndexInRepeat) {\n                                                    if (deletionIndexInRepeat == repeatNodeSet.size()) {\n\n                                                        // o \"When the last remaining item in the collection is removed,\n                                                        // the index position becomes 0.\"\n\n                                                        // o \"When the index was pointing to the deleted node, which was\n                                                        // the last item in the collection, the index will point to the new\n                                                        // last node of the collection and the index of inner repeats is\n                                                        // reinitialized.\"\n\n                                                        newIndex = currentIndex - 1;\n                                                        reinitializeInner = true;\n                                                    } else {\n                                                        // o \"When the index was pointing to the deleted node, which was\n                                                        // not the last item in the collection, the index position is not\n                                                        // changed and the index of inner repeats is re-initialized.\"\n\n                                                        newIndex = currentIndex;\n                                                        reinitializeInner = true;\n                                                    }\n                                                } else {\n                                                    // \"The index should point to the same node\n                                                    // after a delete as it did before the delete\"\n\n                                                    if (currentIndex < deletionIndexInRepeat) {\n                                                        newIndex = currentIndex;\n                                                    } else {\n                                                        newIndex = currentIndex - 1;\n                                                    }\n                                                    reinitializeInner = false;\n                                                }\n                                            }\n\n                                            repeatIndexUpdates.put(repeatId, new Integer(newIndex));\n\n                                            // Handle children\n                                            if (reinitializeInner) {\n                                                // First step: set all children indexes to 0\n                                                final List nestedRepeatIds = xformsControls.getCurrentControlsState().getNestedRepeatIds(xformsControls, repeatId);\n                                                if (nestedRepeatIds != null) {\n                                                    for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                                        final String nestedRepeatId = (String) j.next();\n                                                        repeatIndexUpdates.put(nestedRepeatId, new Integer(0));\n                                                        nestedRepeatIndexUpdates.put(nestedRepeatId, \"\");\n                                                    }\n                                                }\n                                            }\n\n                                            foundControl = controlInfo;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    public void endVisitControl(XFormsControls.ControlInfo controlInfo) {\n                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                            if (foundControl == controlInfo)\n                                foundControl = null;\n                        }\n                    }\n                });\n\n                // Then only perform the deletion\n                siblingElements.remove(actualIndexInCollection);\n\n                // Update affected repeat index information\n                if (repeatIndexUpdates.size() > 0) {\n                    for (Iterator i = repeatIndexUpdates.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry = (Map.Entry) i.next();\n                        xformsControls.getCurrentControlsState().updateRepeatIndex((String) currentEntry.getKey(), ((Integer) currentEntry.getValue()).intValue());\n                    }\n                }\n\n                // Adjust controls ids that could have gone out of bounds\n                adjustRepeatIndexes(pipelineContext, xformsControls, nestedRepeatIndexUpdates);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsDeleteEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETINDEX_ACTION.equals(actionEventName)) {\n            // 9.3.7 The setindex Element\n\n            final String repeatId = actionElement.attributeValue(\"repeat\");\n            final String indexXPath = actionElement.attributeValue(\"index\");\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String indexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                    xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                    \"string(number(\" + indexXPath + \"))\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n            executeSetindexAction(pipelineContext, containingDocument, repeatId, indexString);\n\n        } else if (XFormsActions.XFORMS_SEND_ACTION.equals(actionEventName)) {\n            // 10.1.10 The send Element\n\n            // Find submission object\n            final String submissionId = actionElement.attributeValue(\"submission\");\n            if (submissionId == null)\n                throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n            final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n            if (submission == null || !(submission instanceof XFormsModelSubmission))\n                throw new OXFException(\"submission attribute on xforms:send element does not refer to existing xforms:submission element.\");\n\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n\n        } else if (XFormsActions.XFORMS_DISPATCH_ACTION.equals(actionEventName)) {\n            // 10.1.2 The dispatch Element\n\n            // Mandatory attributes\n            final String newEventName = actionElement.attributeValue(\"name\");\n            if (newEventName == null)\n                throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n            final String newEventTargetId = actionElement.attributeValue(\"target\");\n            if (newEventTargetId == null)\n                throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n            // Optional attributes\n            final boolean newEventBubbles; {\n                final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n            }\n            final boolean newEventCancelable; {\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n                newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n            }\n\n            // Find actual target\n            final Object xformsEventTarget;\n            {\n                final Object tempXFormsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetId);\n                if (tempXFormsEventTarget != null) {\n                    // Object with this id exists \n                    xformsEventTarget = tempXFormsEventTarget;\n                } else {\n                    // Otherwise, try effective id\n                    final String newEventTargetEffectiveId = xformsControls.getCurrentControlsState().findEffectiveControlId(newEventTargetId);\n                    xformsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetEffectiveId);\n                }\n            }\n\n            if (xformsEventTarget == null)\n                throw new OXFException(\"Could not find actual event target on xforms:dispatch element for id: \" + newEventTargetId);\n\n            if (xformsEventTarget instanceof XFormsEventTarget) {\n                // This can be anything\n                containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(newEventName, (XFormsEventTarget) xformsEventTarget, newEventBubbles, newEventCancelable));\n            } else {\n                throw new OXFException(\"Invalid event target for id: \" + newEventTargetId);\n            }\n\n        } else if (XFormsActions.XFORMS_MESSAGE_ACTION.equals(actionEventName)) {\n            // 10.1.12 The message Element\n\n            final String level;\n            {\n                final String levelAttribute = actionElement.attributeValue(\"level\");;\n                if (levelAttribute == null)\n                    throw new OXFException(\"xforms:message element is missing mandatory 'level' attribute.\");\n                final QName levelQName = Dom4jUtils.extractAttributeValueQName(actionElement, \"level\");\n                if (levelQName.getNamespacePrefix().equals(\"\")) {\n                    if (!(\"ephemeral\".equals(levelAttribute) || \"modeless\".equals(levelAttribute) || \"modal\".equals(levelAttribute))) {\n                        throw new OXFException(\"xforms:message element's 'level' attribute must have value: 'ephemeral'|'modeless'|'modal'|QName-but-not-NCName.\");\n                    }\n                    level = levelAttribute;\n                } else {\n                    level = \"{\" + levelQName.getNamespaceURI() + \"}\" + levelQName.getName();\n                }\n            }\n\n            final String src = actionElement.attributeValue(\"src\");\n            final String ref = actionElement.attributeValue(\"ref\");\n\n            String message = null;\n\n            // Try to get message from single-node binding if any\n            if (ref != null) {\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null)\n                    message = XFormsInstance.getValueForNode(currentNode);\n            }\n\n            // Try to get message from linking attribute\n            boolean linkException = false;\n            if (message == null && src != null) {\n                try {\n                    message = XFormsUtils.retrieveSrcValue(src);\n                } catch (IOException e) {\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), src, null, e));\n                    linkException = true;\n                }\n            }\n\n            if (!linkException) {\n                // Try to get inline message\n                if (message == null) {\n                    message = actionElement.getStringValue();\n                }\n\n                if (message != null) {\n                    // Store message for sending to client\n                    containingDocument.addClientMessage(message, level);\n\n                    // NOTE: In the future, we *may* want to save and resume the event state before and\n                    // after displaying a message, in order to possibly provide a behavior which is more\n                    // consistent with what users may expect regarding actions executed after\n                    // xforms:message.\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETFOCUS_ACTION.equals(actionEventName)) {\n\n            // 10.1.7 The setfocus Element\n\n            final String controlId = actionElement.attributeValue(\"control\");\n            if (controlId == null)\n                throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n            final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(controlId);\n            if (effectiveControlId == null)\n                throw new OXFException(\"Could not find actual control on xforms:setfocus element for control: \" + controlId);\n\n            final Object controlObject = containingDocument.getObjectById(pipelineContext, effectiveControlId);\n\n            if (!(controlObject instanceof XFormsControls.ControlInfo))\n                throw new OXFException(\"xforms:setfocus attribute 'control' must refer to a control: \" + controlId);\n\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n\n        } else if (XFormsActions.XFORMS_LOAD_ACTION.equals(actionEventName)) {\n\n            // 10.1.8 The load Element\n\n            final String ref = actionElement.attributeValue(\"ref\");\n            final String resource = actionElement.attributeValue(\"resource\");\n            final String showAttribute;\n            {\n                final String rawShowAttribute = actionElement.attributeValue(\"show\");\n                showAttribute = (rawShowAttribute == null) ? \"replace\" : rawShowAttribute;\n                if (!(\"replace\".equals(showAttribute) || \"new\".equals(showAttribute)))\n                    throw new OXFException(\"Invalid value for 'show' attribute on xforms:load element: \" + showAttribute);\n            }\n            final boolean doReplace = \"replace\".equals(showAttribute);\n            final String target = actionElement.attributeValue(XFormsConstants.XXFORMS_TARGET_QNAME);\n            final String urlType = actionElement.attributeValue(new QName(\"url-type\", new Namespace(\"f\", XMLConstants.OPS_FORMATTING_URI)));\n\n            if (ref != null && resource != null) {\n                // \"If both are present, the action has no effect.\"\n                // NOP\n            } else if (ref != null) {\n                // Use single-node binding\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null) {\n                    final String value = XFormsInstance.getValueForNode(currentNode);\n                    resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, value, target, urlType);\n                } else {\n                    // Should we do this here?\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), \"\", null, null));\n                }\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else if (resource != null) {\n                // Use linking attribute\n                resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, resource, target, urlType);\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else {\n                // \"Either the single node binding attributes, pointing to a URI in the instance\n                // data, or the linking attributes are required.\"\n                throw new OXFException(\"Missing 'resource' or 'ref' attribute on xforms:load element.\");\n            }\n        } else {\n            throw new OXFException(\"Invalid action requested: \" + actionEventName);\n        }\n    }","commit_id":"b98c864b5b826462fe72bca561889fcab7b586a1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            boolean isDeferredSubmissionSecondPass = false;\n            try {\n                // Make sure submission element info is extracted\n                extractSubmissionElement();\n\n                final boolean isReplaceAll = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isHandlingOptimizedGet = XFormsUtils.isOptimizeGetAllSubmission() && XFormsSubmissionUtils.isGet(method) && isReplaceAll;\n\n                //noinspection UnnecessaryLocalVariable\n                final boolean isDeferredSubmission = isReplaceAll;\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName) && !isHandlingOptimizedGet;\n                isDeferredSubmissionSecondPass = isDeferredSubmission && !isDeferredSubmissionFirstPass;\n\n                // Select node based on ref or bind\n                final XFormsControls xformsControls = containingDocument.getXFormsControls();\n                xformsControls.setBinding(pipelineContext, submissionElement); // TODO FIXME: the submission element is not a control...\n\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n\n                if (!(currentNode instanceof Document || currentNode instanceof Element)) {\n                    throw new OXFException(\"xforms:submission: single-node binding must refer to a document node or an element.\");\n                }\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n\n                final Document initialDocumentToSubmit;\n                if (!isDeferredSubmissionSecondPass) {\n                    // Create document to submit\n                    final Document backupInstanceDocument = currentInstance.getDocument();\n                    try {\n                        initialDocumentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n                        currentInstance.setInstanceDocument(initialDocumentToSubmit);\n\n                        // Revalidate instance\n                        containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, false));\n                        // TODO: The \"false\" attribute is no longer used. The above will cause events to be\n                        // sent out. Check if the validation state can really change. If so, find a\n                        // solution.\n                        // \"no notification events are marked for dispatching due to this operation\"\n\n                        // Check that there are no validation errors\n                        final boolean instanceSatisfiesValidRequired = isDocumentSatisfiesValidRequired(initialDocumentToSubmit);\n                        if (!instanceSatisfiesValidRequired) {\n//                            {\n//                                currentInstance.readOut();\n//                            }\n                            if (XFormsServer.logger.isDebugEnabled()) {\n                                final LocationDocumentResult documentResult = new LocationDocumentResult();\n                                final TransformerHandler identity = TransformerUtils.getIdentityTransformerHandler();\n                                identity.setResult(documentResult);\n                                currentInstance.read(identity);\n                                final String documentString = Dom4jUtils.domToString(documentResult.getDocument());\n\n                                XFormsServer.logger.debug(\"XForms - instance document or subset thereof cannot be submitted:\\n\" + documentString);\n                            }\n                            throw new OXFException(\"xforms:submission: instance to submit does not satisfy valid and/or required model item properties.\");\n                        }\n                    } finally {\n                        currentInstance.restoreInstanceDocument(backupInstanceDocument);\n                    }\n                } else {\n                    initialDocumentToSubmit = null;\n                }\n\n                // Deferred submission: end of the first pass\n                if (isDeferredSubmissionFirstPass) {\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                final Document documentToSubmit;\n                if (isDeferredSubmissionSecondPass) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmissionEvent) ? ((XXFormsSubmissionEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        for (Iterator i = filesElement.elements().iterator(); i.hasNext();) {\n                            final Element parameterElement = (Element) i.next();\n                            final String name = parameterElement.element(\"name\").getTextTrim();\n\n                            final Element valueElement = parameterElement.element(\"value\");\n                            final String value = valueElement.getTextTrim();\n                            final String paramValueType = Dom4jUtils.qNameToexplodedQName(Dom4jUtils.extractAttributeValueQName(valueElement, XMLConstants.XSI_TYPE_QNAME));\n\n                            final String filename = parameterElement.element(\"filename\").getTextTrim();\n                            final String mediatype = parameterElement.element(\"content-type\").getTextTrim();\n                            final String size = parameterElement.element(\"content-length\").getTextTrim();\n\n                            final XFormsControls.UploadControlInfo uploadControl\n                                    = (XFormsControls.UploadControlInfo) containingDocument.getObjectById(pipelineContext, name);\n\n                            if (uploadControl != null)\n                            { // in case of xforms:repeat, the name of the template will not match an existing control\n                                // Set value into the instance\n                                xformsControls.setBinding(pipelineContext, uploadControl);\n                                {\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, value, paramValueType);\n                                }\n\n                                // Handle filename if any\n                                if (uploadControl.getFilenameElement() != null) {\n                                    xformsControls.pushBinding(pipelineContext, uploadControl.getFilenameElement());\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, filename, null);\n                                    xformsControls.popBinding();\n                                }\n\n                                // Handle mediatype if any\n                                if (uploadControl.getMediatypeElement() != null) {\n                                    xformsControls.pushBinding(pipelineContext, uploadControl.getMediatypeElement());\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, mediatype, null);\n                                    xformsControls.popBinding();\n                                }\n\n                                // Handle file size if any\n                                if (uploadControl.getSizeElement() != null) {\n                                    xformsControls.pushBinding(pipelineContext, uploadControl.getSizeElement());\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, size, null);\n                                    xformsControls.popBinding();\n                                }\n                            }\n                        }\n                    }\n\n                    // Create document to submit\n                    final Document backupInstanceDocument = currentInstance.getDocument();\n                    try {\n                        documentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n                        currentInstance.setInstanceDocument(documentToSubmit);\n\n                        // Revalidate instance\n                        containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, false));\n                        // TODO: The \"false\" attribute is no longer used. The above will cause events to be\n                        // sent out. Check if the validation state can really change. If so, find a\n                        // solution.\n                        // \"no notification events are marked for dispatching due to this operation\"\n\n                        // Check that there are no validation errors\n                        final boolean instanceSatisfiesValidRequired = isDocumentSatisfiesValidRequired(documentToSubmit);\n                        if (!instanceSatisfiesValidRequired) {\n    //                        currentInstance.readOut();// FIXME: DEBUG\n                            throw new OXFException(\"xforms:submission: instance to submit does not satisfy valid and/or required model item properties.\");\n                        }\n                    } finally {\n                        currentInstance.restoreInstanceDocument(backupInstanceDocument);\n                    }\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = initialDocumentToSubmit;\n                }\n\n                // Serialize\n                // To support: application/xml, application/x-www-form-urlencoded, multipart/related, multipart/form-data\n                final byte[] serializedInstance;\n                final String serializedInstanceString;\n                {\n                    if (XFormsSubmissionUtils.isPost(method) || XFormsSubmissionUtils.isPut(method)) {\n\n                        try {\n                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                            TransformerUtils.applyOutputProperties(identity,\n                                    \"xml\", version, null, null, encoding, omitxmldeclaration, standalone, indent, 4);\n\n                            // TODO: use cdata-section-elements\n\n                            final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                            identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                            serializedInstance = os.toByteArray();\n                        } catch (Exception e) {\n                            throw new OXFException(\"xforms:submission: exception while serializing instance to XML.\", e);\n                        }\n                        serializedInstanceString = null;\n\n                    } else if (XFormsSubmissionUtils.isGet(method)) {\n\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        serializedInstanceString = createWwwFormUrlEncoded(documentToSubmit);\n                        serializedInstance = null;\n\n                    } else if (method.equals(\"multipart-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"form-data-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"urlencoded-post\")) {\n                        throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                    } else {\n                        throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                    }\n                }\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                \n                // Result information\n                ConnectionResult connectionResult = null;\n                try {\n                    if (isHandlingOptimizedGet) {\n                        // GET with replace=\"all\": we can optimize and tell the client to just load the URL\n                        connectionResult = doOptimizedGet(pipelineContext, serializedInstanceString);\n                    } else if (!NetUtils.urlHasProtocol(action)\n                               && (externalContext.getRequest().getContainerType().equals(\"portlet\")\n                                    || (externalContext.getRequest().getContainerType().equals(\"servlet\")\n                                        && (XFormsUtils.isOptimizeLocalSubmission() || isMethodOptimizedLocalSubmission())\n                                        &&  isReplaceAll))) {\n\n                        // This is an \"optimized\" submission, i.e. one that does not use an actual\n                        // protocol handler to access the resource\n\n                        // NOTE: Optimizing with include() for servlets doesn't allow detecting\n                        // errors caused by the included resource, so we don't allow this for now.\n\n                        // NOTE: For portlets, paths are served directly by the portlet, NOT as\n                        // resources.\n\n                        // Current limitations:\n                        // o Portlets cannot access resources outside the portlet except by using absolute URLs\n                        // o Servlets cannot access resources on the same serer but not in the current application\n                        //   except by using absolute URLs\n\n                        final URI resolvedURI = XFormsUtils.resolveURI(submissionElement, action);\n                        connectionResult = XFormsSubmissionUtils.doOptimized(pipelineContext, externalContext,\n                                this, method, resolvedURI.toString(), mediatype, isReplaceAll,\n                                serializedInstance, serializedInstanceString);\n\n                    } else {\n                        // This is a regular remote submission going through a protocol handler\n\n                        // Absolute URLs or absolute paths are allowed to a local servlet\n                        final String resolvedURL = XFormsUtils.resolveURL(containingDocument, pipelineContext, submissionElement, false, action);\n                        connectionResult = XFormsSubmissionUtils.doRegular(pipelineContext, externalContext,\n                                method, resolvedURL, mediatype, isReplaceAll,\n                                serializedInstance, serializedInstanceString);\n                    }\n\n                    if (!connectionResult.dontHandleResponse) {\n                        // Handle response\n                        if (connectionResult.resultCode == 200) {\n                            // Sucessful response\n\n                            final boolean hasContent;\n                            {\n                                if (connectionResult.resultInputStream == null) {\n                                    hasContent = false;\n                                } else {\n                                    if (!connectionResult.resultInputStream.markSupported())\n                                        connectionResult.resultInputStream = new BufferedInputStream(connectionResult.resultInputStream);\n\n                                    connectionResult.resultInputStream.mark(1);\n                                    hasContent = connectionResult.resultInputStream.read() != -1;\n                                    connectionResult.resultInputStream.reset();\n                                }\n                            }\n\n                            if (hasContent) {\n                                // There is a body\n\n                                if (isReplaceAll) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n\n                                    final ExternalContext.Response response = externalContext.getResponse();\n\n                                    // Forward headers to response\n                                    if (connectionResult.resultHeaders != null) {\n                                        for (Iterator i = connectionResult.resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                            final Map.Entry currentEntry = (Map.Entry) i.next();\n                                            final String headerName = (String) currentEntry.getKey();\n                                            final List headerValues = (List) currentEntry.getValue();\n\n                                            if (headerName != null && headerValues != null) {\n                                                for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                                    response.addHeader(headerName, (String) j.next());\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    // Forward content to response\n                                    NetUtils.copyStream(connectionResult.resultInputStream, response.getOutputStream());\n\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE)) {\n\n                                    final ByteArrayOutputStream resultByteArrayOutputStream = new ByteArrayOutputStream();\n                                    NetUtils.copyStream(connectionResult.resultInputStream, resultByteArrayOutputStream);\n                                    byte[] submissionResponse = resultByteArrayOutputStream.toByteArray();\n\n                                    if (ProcessorUtils.isXMLContentType(connectionResult.resultMediaType)) {\n                                        // Handling of XML media type\n                                        try {\n                                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                                            final LocationDocumentResult documentResult = new LocationDocumentResult();\n                                            identity.transform(new StreamSource(new ByteArrayInputStream(submissionResponse)), documentResult);\n                                            final Document resultingInstanceDocument = documentResult.getDocument();\n\n                                            // Set new instance document to replace the one submitted\n                                            final XFormsInstance replaceInstance = (replaceInstanceId == null) ? currentInstance : model.getInstance(replaceInstanceId);\n                                            if (replaceInstance == null) {\n                                                containingDocument.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                            } else {\n                                                // Get repeat index information just before insertion\n                                                final Map previousRepeatIdToIndex;\n                                                {\n                                                    final Map map = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n                                                    previousRepeatIdToIndex = (map == null) ? null : new HashMap(map);\n                                                }\n\n                                                // Set new instance\n//                                                replaceInstance.logMIPs();\n                                                replaceInstance.setInstanceDocument(resultingInstanceDocument);\n\n                                                // Mark all values as changed so that refresh sends appropriate events\n                                                XFormsUtils.markAllValuesChanged(replaceInstance.getDocument());\n\n                                                // Rebuild ControlsState\n                                                xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n                                                // \"Once the XML instance data has been replaced,\n                                                // the rebuild, recalculate, revalidate and refresh\n                                                // operations are performed on the model, without\n                                                // dispatching events to invoke those four\n                                                // operations.\"\n\n                                                model.doRebuild(pipelineContext);\n                                                model.doRecalculate(pipelineContext);\n                                                model.doRevalidate(pipelineContext);\n                                                model.doRefresh(pipelineContext);\n\n//                                                replaceInstance.logMIPs();\n\n                                                // Update repeat indexes if necessary\n\n                                                // The idea is that if a repeat index was set to 0\n                                                // (which can only happen when a repeat node-set is\n                                                // empty) and instance replacement causes the\n                                                // node-set to be non-empty, then the repeat index\n                                                // must be set to the initial repeat index for that\n                                                // repeat.\n                                                if (previousRepeatIdToIndex != null) {\n                                                    final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                                                    final Map currentRepeatIdToIndex = currentControlsState.getRepeatIdToIndex();\n                                                    final Map intialRepeatIdToIndex = currentControlsState.getDefaultRepeatIdToIndex();\n                                                    final Map effectiveRepeatIdToIterations = currentControlsState.getEffectiveRepeatIdToIterations();\n                                                    if (currentRepeatIdToIndex != null && currentRepeatIdToIndex.size() != 0) {\n                                                        for (Iterator i = previousRepeatIdToIndex.entrySet().iterator(); i.hasNext();) {\n                                                            final Map.Entry currentEntry = (Map.Entry) i.next();\n                                                            final String repeatId = (String) currentEntry.getKey();\n                                                            final Integer previouslIndex = (Integer) currentEntry.getValue();\n\n//                                                            final Integer newIndex = (Integer) currentRepeatIdToIndex.get(repeatId);\n                                                             // TODO FIXME: repeatId is a control id, but effectiveRepeatIdToIterations contains effective ids\n                                                            // -> this doesn't work and can throw exceptions!\n                                                            final Integer newIterations = (Integer) effectiveRepeatIdToIterations.get(repeatId);\n\n                                                            if (previouslIndex.intValue() == 0 && newIterations != null && newIterations.intValue() > 0) {\n                                                                // Set index to defaul value\n                                                                final Integer initialRepeatIndex = (Integer) intialRepeatIdToIndex.get(repeatId);\n//                                                                XFormsActionInterpreter.executeSetindexAction(pipelineContext, containingDocument, repeatId, initialRepeatIndex.toString());\n                                                                // TODO: Here we need to check that the index is within bounds and to send the appropriate events\n                                                                currentControlsState.updateRepeatIndex(repeatId, initialRepeatIndex.intValue());\n                                                            } else {\n                                                                // Just reset index and make sure it is within bounds\n//                                                                XFormsActionInterpreter.executeSetindexAction(pipelineContext, containingDocument, repeatId, previousRepeatIndex.toString());\n                                                                // TODO: Here we need to check that the index is within bounds and to send the appropriate events\n//                                                                final Integer previousRepeatIndex = (Integer) previousRepeatIdToIndex.get(repeatId);\n//                                                                currentControlsState.updateRepeatIndex(repeatId, previousRepeatIndex.intValue());\n                                                                final Integer initialRepeatIndex = (Integer) intialRepeatIdToIndex.get(repeatId);\n                                                                currentControlsState.updateRepeatIndex(repeatId, initialRepeatIndex.intValue());\n                                                            }\n                                                            // TODO: Adjust controls ids that could have gone out of bounds?\n                                                            // adjustRepeatIndexes(pipelineContext, xformsControls);\n                                                        }\n                                                    }\n                                                }\n\n                                                // Notify that submission is done\n                                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                            }\n                                        } catch (Exception e) {\n                                            throw new OXFException(\"xforms:submission: exception while serializing XML to instance.\", e);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        throw new OXFException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + connectionResult.resultMediaType);\n                                    }\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE)) {\n                                    // Just notify that processing is terminated\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                } else {\n                                    throw new OXFException(\"xforms:submission: invalid replace attribute: \" + replace);\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                            }\n                        } else if (connectionResult.resultCode == 302 || connectionResult.resultCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            // TODO: this is duplicated from above\n                            if (connectionResult.resultHeaders != null) {\n                                for (Iterator i = connectionResult.resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                    final Map.Entry currentEntry = (Map.Entry) i.next();\n                                    final String headerName = (String) currentEntry.getKey();\n                                    final List headerValues = (List) currentEntry.getValue();\n\n                                    if (headerName != null && headerValues != null) {\n                                        for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                            response.addHeader(headerName, (String) j.next());\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Forward redirect\n                            response.setStatus(connectionResult.resultCode);\n\n                        } else {\n                            // Error code received\n                            throw new OXFException(\"Error code received when submitting instance: \" + connectionResult.resultCode);\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (connectionResult != null) {\n                        connectionResult.close();\n                    }\n                }\n            } catch (Throwable e) {\n                if (isDeferredSubmissionSecondPass && XFormsUtils.isOptimizePostAllSubmission()) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new OXFException(e);\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitErrorEvent(XFormsModelSubmission.this, action, e));\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new OXFException(\"Binding exception.\");\n        }\n    }","id":47175,"modified_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            boolean isDeferredSubmissionSecondPass = false;\n            try {\n                // Make sure submission element info is extracted\n                extractSubmissionElement();\n\n                final boolean isReplaceAll = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isHandlingOptimizedGet = XFormsUtils.isOptimizeGetAllSubmission() && XFormsSubmissionUtils.isGet(method) && isReplaceAll;\n\n                //noinspection UnnecessaryLocalVariable\n                final boolean isDeferredSubmission = isReplaceAll;\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName) && !isHandlingOptimizedGet;\n                isDeferredSubmissionSecondPass = isDeferredSubmission && !isDeferredSubmissionFirstPass;\n\n                // Select node based on ref or bind\n                final XFormsControls xformsControls = containingDocument.getXFormsControls();\n                xformsControls.setBinding(pipelineContext, submissionElement); // TODO FIXME: the submission element is not a control...\n\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n\n                if (!(currentNode instanceof Document || currentNode instanceof Element)) {\n                    throw new OXFException(\"xforms:submission: single-node binding must refer to a document node or an element.\");\n                }\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n\n                final Document initialDocumentToSubmit;\n                if (!isDeferredSubmissionSecondPass) {\n                    // Create document to submit\n                    final Document backupInstanceDocument = currentInstance.getDocument();\n                    try {\n                        initialDocumentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n                        currentInstance.setInstanceDocument(initialDocumentToSubmit);\n\n                        // Revalidate instance\n                        containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, false));\n                        // TODO: The \"false\" attribute is no longer used. The above will cause events to be\n                        // sent out. Check if the validation state can really change. If so, find a\n                        // solution.\n                        // \"no notification events are marked for dispatching due to this operation\"\n\n                        // Check that there are no validation errors\n                        final boolean instanceSatisfiesValidRequired = isDocumentSatisfiesValidRequired(initialDocumentToSubmit);\n                        if (!instanceSatisfiesValidRequired) {\n//                            {\n//                                currentInstance.readOut();\n//                            }\n                            if (XFormsServer.logger.isDebugEnabled()) {\n                                final LocationDocumentResult documentResult = new LocationDocumentResult();\n                                final TransformerHandler identity = TransformerUtils.getIdentityTransformerHandler();\n                                identity.setResult(documentResult);\n                                currentInstance.read(identity);\n                                final String documentString = Dom4jUtils.domToString(documentResult.getDocument());\n\n                                XFormsServer.logger.debug(\"XForms - instance document or subset thereof cannot be submitted:\\n\" + documentString);\n                            }\n                            throw new OXFException(\"xforms:submission: instance to submit does not satisfy valid and/or required model item properties.\");\n                        }\n                    } finally {\n                        currentInstance.restoreInstanceDocument(backupInstanceDocument);\n                    }\n                } else {\n                    initialDocumentToSubmit = null;\n                }\n\n                // Deferred submission: end of the first pass\n                if (isDeferredSubmissionFirstPass) {\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                final Document documentToSubmit;\n                if (isDeferredSubmissionSecondPass) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmissionEvent) ? ((XXFormsSubmissionEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        for (Iterator i = filesElement.elements().iterator(); i.hasNext();) {\n                            final Element parameterElement = (Element) i.next();\n                            final String name = parameterElement.element(\"name\").getTextTrim();\n\n                            final Element valueElement = parameterElement.element(\"value\");\n                            final String value = valueElement.getTextTrim();\n                            final String paramValueType = Dom4jUtils.qNameToexplodedQName(Dom4jUtils.extractAttributeValueQName(valueElement, XMLConstants.XSI_TYPE_QNAME));\n\n                            final String filename = parameterElement.element(\"filename\").getTextTrim();\n                            final String mediatype = parameterElement.element(\"content-type\").getTextTrim();\n                            final String size = parameterElement.element(\"content-length\").getTextTrim();\n\n                            final XFormsControls.UploadControlInfo uploadControl\n                                    = (XFormsControls.UploadControlInfo) containingDocument.getObjectById(pipelineContext, name);\n\n                            if (uploadControl != null)\n                            { // in case of xforms:repeat, the name of the template will not match an existing control\n                                // Set value into the instance\n                                xformsControls.setBinding(pipelineContext, uploadControl);\n                                {\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, value, paramValueType);\n                                }\n\n                                // Handle filename if any\n                                if (uploadControl.getFilenameElement() != null) {\n                                    xformsControls.pushBinding(pipelineContext, uploadControl.getFilenameElement());\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, filename, null);\n                                    xformsControls.popBinding();\n                                }\n\n                                // Handle mediatype if any\n                                if (uploadControl.getMediatypeElement() != null) {\n                                    xformsControls.pushBinding(pipelineContext, uploadControl.getMediatypeElement());\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, mediatype, null);\n                                    xformsControls.popBinding();\n                                }\n\n                                // Handle file size if any\n                                if (uploadControl.getSizeElement() != null) {\n                                    xformsControls.pushBinding(pipelineContext, uploadControl.getSizeElement());\n                                    final Node currentSingleNode = xformsControls.getCurrentSingleNode();\n                                    XFormsInstance.setValueForNode(pipelineContext, currentSingleNode, size, null);\n                                    xformsControls.popBinding();\n                                }\n                            }\n                        }\n                    }\n\n                    // Create document to submit\n                    final Document backupInstanceDocument = currentInstance.getDocument();\n                    try {\n                        documentToSubmit = createDocumentToSubmit(currentNode, currentInstance);\n                        currentInstance.setInstanceDocument(documentToSubmit);\n\n                        // Revalidate instance\n                        containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, false));\n                        // TODO: The \"false\" attribute is no longer used. The above will cause events to be\n                        // sent out. Check if the validation state can really change. If so, find a\n                        // solution.\n                        // \"no notification events are marked for dispatching due to this operation\"\n\n                        // Check that there are no validation errors\n                        final boolean instanceSatisfiesValidRequired = isDocumentSatisfiesValidRequired(documentToSubmit);\n                        if (!instanceSatisfiesValidRequired) {\n    //                        currentInstance.readOut();// FIXME: DEBUG\n                            throw new OXFException(\"xforms:submission: instance to submit does not satisfy valid and/or required model item properties.\");\n                        }\n                    } finally {\n                        currentInstance.restoreInstanceDocument(backupInstanceDocument);\n                    }\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = initialDocumentToSubmit;\n                }\n\n                // Serialize\n                // To support: application/xml, application/x-www-form-urlencoded, multipart/related, multipart/form-data\n                final byte[] serializedInstance;\n                final String serializedInstanceString;\n                {\n                    if (XFormsSubmissionUtils.isPost(method) || XFormsSubmissionUtils.isPut(method)) {\n\n                        try {\n                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                            TransformerUtils.applyOutputProperties(identity,\n                                    \"xml\", version, null, null, encoding, omitxmldeclaration, standalone, indent, 4);\n\n                            // TODO: use cdata-section-elements\n\n                            final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                            identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                            serializedInstance = os.toByteArray();\n                        } catch (Exception e) {\n                            throw new OXFException(\"xforms:submission: exception while serializing instance to XML.\", e);\n                        }\n                        serializedInstanceString = null;\n\n                    } else if (XFormsSubmissionUtils.isGet(method)) {\n\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        serializedInstanceString = createWwwFormUrlEncoded(documentToSubmit);\n                        serializedInstance = null;\n\n                    } else if (method.equals(\"multipart-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"form-data-post\")) {\n                        // TODO\n                        throw new OXFException(\"xforms:submission: submission method not yet implemented: \" + method);\n                    } else if (method.equals(\"urlencoded-post\")) {\n                        throw new OXFException(\"xforms:submission: deprecated submission method requested: \" + method);\n                    } else {\n                        throw new OXFException(\"xforms:submission: invalid submission method requested: \" + method);\n                    }\n                }\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                \n                // Result information\n                ConnectionResult connectionResult = null;\n                try {\n                    if (isHandlingOptimizedGet) {\n                        // GET with replace=\"all\": we can optimize and tell the client to just load the URL\n                        connectionResult = doOptimizedGet(pipelineContext, serializedInstanceString);\n                    } else if (!NetUtils.urlHasProtocol(action)\n                               && (externalContext.getRequest().getContainerType().equals(\"portlet\")\n                                    || (externalContext.getRequest().getContainerType().equals(\"servlet\")\n                                        && (XFormsUtils.isOptimizeLocalSubmission() || isMethodOptimizedLocalSubmission())\n                                        &&  isReplaceAll))) {\n\n                        // This is an \"optimized\" submission, i.e. one that does not use an actual\n                        // protocol handler to access the resource\n\n                        // NOTE: Optimizing with include() for servlets doesn't allow detecting\n                        // errors caused by the included resource, so we don't allow this for now.\n\n                        // NOTE: For portlets, paths are served directly by the portlet, NOT as\n                        // resources.\n\n                        // Current limitations:\n                        // o Portlets cannot access resources outside the portlet except by using absolute URLs\n                        // o Servlets cannot access resources on the same serer but not in the current application\n                        //   except by using absolute URLs\n\n                        final URI resolvedURI = XFormsUtils.resolveURI(submissionElement, action);\n                        connectionResult = XFormsSubmissionUtils.doOptimized(pipelineContext, externalContext,\n                                this, method, resolvedURI.toString(), mediatype, isReplaceAll,\n                                serializedInstance, serializedInstanceString);\n\n                    } else {\n                        // This is a regular remote submission going through a protocol handler\n\n                        // Absolute URLs or absolute paths are allowed to a local servlet\n                        final String resolvedURL = XFormsUtils.resolveURL(containingDocument, pipelineContext, submissionElement, false, action);\n                        connectionResult = XFormsSubmissionUtils.doRegular(pipelineContext, externalContext,\n                                method, resolvedURL, mediatype, isReplaceAll,\n                                serializedInstance, serializedInstanceString);\n                    }\n\n                    if (!connectionResult.dontHandleResponse) {\n                        // Handle response\n                        if (connectionResult.resultCode == 200) {\n                            // Sucessful response\n\n                            final boolean hasContent;\n                            {\n                                if (connectionResult.resultInputStream == null) {\n                                    hasContent = false;\n                                } else {\n                                    if (!connectionResult.resultInputStream.markSupported())\n                                        connectionResult.resultInputStream = new BufferedInputStream(connectionResult.resultInputStream);\n\n                                    connectionResult.resultInputStream.mark(1);\n                                    hasContent = connectionResult.resultInputStream.read() != -1;\n                                    connectionResult.resultInputStream.reset();\n                                }\n                            }\n\n                            if (hasContent) {\n                                // There is a body\n\n                                if (isReplaceAll) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n\n                                    final ExternalContext.Response response = externalContext.getResponse();\n\n                                    // Forward headers to response\n                                    if (connectionResult.resultHeaders != null) {\n                                        for (Iterator i = connectionResult.resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                            final Map.Entry currentEntry = (Map.Entry) i.next();\n                                            final String headerName = (String) currentEntry.getKey();\n                                            final List headerValues = (List) currentEntry.getValue();\n\n                                            if (headerName != null && headerValues != null) {\n                                                for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                                    response.addHeader(headerName, (String) j.next());\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    // Forward content to response\n                                    NetUtils.copyStream(connectionResult.resultInputStream, response.getOutputStream());\n\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE)) {\n\n                                    final ByteArrayOutputStream resultByteArrayOutputStream = new ByteArrayOutputStream();\n                                    NetUtils.copyStream(connectionResult.resultInputStream, resultByteArrayOutputStream);\n                                    byte[] submissionResponse = resultByteArrayOutputStream.toByteArray();\n\n                                    if (ProcessorUtils.isXMLContentType(connectionResult.resultMediaType)) {\n                                        // Handling of XML media type\n                                        try {\n                                            final Transformer identity = TransformerUtils.getIdentityTransformer();\n                                            final LocationDocumentResult documentResult = new LocationDocumentResult();\n                                            identity.transform(new StreamSource(new ByteArrayInputStream(submissionResponse)), documentResult);\n                                            final Document resultingInstanceDocument = documentResult.getDocument();\n\n                                            // Set new instance document to replace the one submitted\n                                            final XFormsInstance replaceInstance = (replaceInstanceId == null) ? currentInstance : model.getInstance(replaceInstanceId);\n                                            if (replaceInstance == null) {\n                                                containingDocument.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                            } else {\n                                                // Get repeat index information just before insertion\n                                                final Map previousRepeatIdToIndex;\n                                                {\n                                                    final Map map = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n                                                    previousRepeatIdToIndex = (map == null) ? null : new HashMap(map);\n                                                }\n\n                                                // Set new instance\n//                                                replaceInstance.logMIPs();\n                                                replaceInstance.setInstanceDocument(resultingInstanceDocument);\n\n                                                // Mark all values as changed so that refresh sends appropriate events\n                                                XFormsUtils.markAllValuesChanged(replaceInstance.getDocument());\n\n                                                // \"Once the XML instance data has been replaced,\n                                                // the rebuild, recalculate, revalidate and refresh\n                                                // operations are performed on the model, without\n                                                // dispatching events to invoke those four\n                                                // operations.\"\n\n                                                model.doRebuild(pipelineContext);\n                                                model.doRecalculate(pipelineContext);\n                                                model.doRevalidate(pipelineContext);\n\n                                                // Rebuild ControlsState\n                                                xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n                                                model.doRefresh(pipelineContext);\n\n                                                // NOTE: You can imagine really complicated stuff related to index\n                                                // updates. Here, we assume that repeat iterations do\n                                                // *not* depend on instance values that themselves depend on the index()\n                                                // function. This scenario is not impossible, but fairly far-fetched I\n                                                // think, and we haven't seen it yet. So once an instance structure and\n                                                // content is determined, we assume that it won't change in a\n                                                // significant way with index updates performed below.\n\n                                                // However, one scenario we want to allow is a repeat \"detail\" on the\n                                                // same level as a repeat \"master\", where the repeat detail iteration\n                                                // depends on index('master').\n\n//                                                replaceInstance.logMIPs();\n\n                                                // Update repeat indexes if necessary\n\n                                                // TODO: detect use of index() function\n                                                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n                                                currentControlsState.visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n                                                    private int level = 0;\n\n                                                    public void startVisitControl(XFormsControls.ControlInfo controlInfo) {\n                                                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                                                            // Found an xforms:repeat\n                                                            final XFormsControls.RepeatControlInfo repeatControlInfo = (XFormsControls.RepeatControlInfo) controlInfo;\n                                                            final String repeatId = repeatControlInfo.getOriginalId();\n                                                            final List repeatNodeSet = xformsControls.getCurrentNodeset();\n\n                                                            // Make sure the bounds of this xforms:repeat are correct\n                                                            // for the rest of the visit.\n\n                                                            final int adjustedNewIndex;\n                                                            {\n                                                                final int newIndex = ((Integer) currentControlsState.getRepeatIdToIndex().get(repeatId)).intValue();\n\n                                                                // Adjust bounds if necessary\n                                                                if (repeatNodeSet.size() == 0)\n                                                                    adjustedNewIndex = 0;\n                                                                else if (newIndex < 1)\n                                                                    adjustedNewIndex = 1;\n                                                                else if (newIndex > repeatNodeSet.size())\n                                                                    adjustedNewIndex = repeatNodeSet.size();\n                                                                else\n                                                                    adjustedNewIndex = newIndex;\n                                                            }\n\n                                                            // Set index\n                                                            currentControlsState.updateRepeatIndex(repeatId, adjustedNewIndex);\n\n                                                            level++;\n                                                        }\n                                                    }\n\n                                                    public void endVisitControl(XFormsControls.ControlInfo controlInfo) {\n                                                        if (controlInfo instanceof XFormsControls.RepeatControlInfo) {\n                                                            level--;\n                                                        }\n                                                    }\n                                                });\n\n                                                // The idea is that if a repeat index was set to 0 (which can only\n                                                // happen when a repeat node-set is empty) and instance replacement\n                                                // causes the node-set to be non-empty, then the repeat index must be\n                                                // set to the initial repeat index for that repeat.\n//                                                if (previousRepeatIdToIndex != null) {\n//                                                    final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n//\n//                                                    final Map currentRepeatIdToIndex = currentControlsState.getRepeatIdToIndex();\n//                                                    final Map intialRepeatIdToIndex = currentControlsState.getDefaultRepeatIdToIndex();\n//                                                    final Map effectiveRepeatIdToIterations = currentControlsState.getEffectiveRepeatIdToIterations();\n//                                                    if (currentRepeatIdToIndex != null && currentRepeatIdToIndex.size() != 0) {\n//                                                        for (Iterator i = previousRepeatIdToIndex.entrySet().iterator(); i.hasNext();) {\n//                                                            final Map.Entry currentEntry = (Map.Entry) i.next();\n//                                                            final String repeatId = (String) currentEntry.getKey();\n//                                                            final Integer previouslIndex = (Integer) currentEntry.getValue();\n//\n////                                                            final Integer newIndex = (Integer) currentRepeatIdToIndex.get(repeatId);\n//                                                             // TODO FIXME: repeatId is a control id, but effectiveRepeatIdToIterations contains effective ids\n//                                                            // -> this doesn't work and can throw exceptions!\n//                                                            final Integer newIterations = (Integer) effectiveRepeatIdToIterations.get(repeatId);\n//\n//                                                            if (previouslIndex.intValue() == 0 && newIterations != null && newIterations.intValue() > 0) {\n//                                                                // Set index to defaul value\n//                                                                final Integer initialRepeatIndex = (Integer) intialRepeatIdToIndex.get(repeatId);\n////                                                                XFormsActionInterpreter.executeSetindexAction(pipelineContext, containingDocument, repeatId, initialRepeatIndex.toString());\n//                                                                // TODO: Here we need to check that the index is within bounds and to send the appropriate events\n//                                                                currentControlsState.updateRepeatIndex(repeatId, initialRepeatIndex.intValue());\n//                                                            } else {\n//                                                                // Just reset index and make sure it is within bounds\n////                                                                XFormsActionInterpreter.executeSetindexAction(pipelineContext, containingDocument, repeatId, previousRepeatIndex.toString());\n//                                                                // TODO: Here we need to check that the index is within bounds and to send the appropriate events\n////                                                                final Integer previousRepeatIndex = (Integer) previousRepeatIdToIndex.get(repeatId);\n////                                                                currentControlsState.updateRepeatIndex(repeatId, previousRepeatIndex.intValue());\n//                                                                final Integer initialRepeatIndex = (Integer) intialRepeatIdToIndex.get(repeatId);\n//                                                                currentControlsState.updateRepeatIndex(repeatId, initialRepeatIndex.intValue());\n//                                                            }\n//                                                            // TODO: Adjust controls ids that could have gone out of bounds?\n//                                                            // adjustRepeatIndexes(pipelineContext, xformsControls);\n//                                                        }\n//                                                    }\n//                                                }\n\n                                                // Notify that submission is done\n                                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                            }\n                                        } catch (Exception e) {\n                                            throw new OXFException(\"xforms:submission: exception while serializing XML to instance.\", e);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        throw new OXFException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + connectionResult.resultMediaType);\n                                    }\n                                } else if (replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE)) {\n                                    // Just notify that processing is terminated\n                                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                                } else {\n                                    throw new OXFException(\"xforms:submission: invalid replace attribute: \" + replace);\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n                                containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this));\n                            }\n                        } else if (connectionResult.resultCode == 302 || connectionResult.resultCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            // TODO: this is duplicated from above\n                            if (connectionResult.resultHeaders != null) {\n                                for (Iterator i = connectionResult.resultHeaders.entrySet().iterator(); i.hasNext();) {\n                                    final Map.Entry currentEntry = (Map.Entry) i.next();\n                                    final String headerName = (String) currentEntry.getKey();\n                                    final List headerValues = (List) currentEntry.getValue();\n\n                                    if (headerName != null && headerValues != null) {\n                                        for (Iterator j = headerValues.iterator(); j.hasNext();) {\n                                            response.addHeader(headerName, (String) j.next());\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Forward redirect\n                            response.setStatus(connectionResult.resultCode);\n\n                        } else {\n                            // Error code received\n                            throw new OXFException(\"Error code received when submitting instance: \" + connectionResult.resultCode);\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (connectionResult != null) {\n                        connectionResult.close();\n                    }\n                }\n            } catch (Throwable e) {\n                if (isDeferredSubmissionSecondPass && XFormsUtils.isOptimizePostAllSubmission()) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new OXFException(e);\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitErrorEvent(XFormsModelSubmission.this, action, e));\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new OXFException(\"Binding exception.\");\n        }\n    }","commit_id":"b98c864b5b826462fe72bca561889fcab7b586a1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Object clone() throws CloneNotSupportedException {\n        final InstanceData result = (InstanceData) super.clone();\n\n        try {\n            result.relevant = (RelevantModelItemProperty) this.relevant.clone();\n            result.required = (RequiredModelItemProperty) this.required.clone();\n            result.readonly = (ReadonlyModelItemProperty) this.readonly.clone();\n            result.valueValid = (ValidModelItemProperty) this.valueValid.clone();\n            result.constraint = (ValidModelItemProperty) this.constraint.clone();\n            result.type = (TypeModelItemProperty) this.type.clone();\n\n            result.xxformsExternalize = (this.xxformsExternalize != null) ? (XXFormsExternalizeModelItemProperty) this.xxformsExternalize.clone() : null;\n        } catch (CloneNotSupportedException e) {\n            // This should not happen because the classes cloned are Cloneable\n            throw new OXFException(e);\n        }\n\n        result.valueChanged = this.valueChanged;\n        result.idToNodeMap = (this.idToNodeMap == null) ? null : new HashMap(this.idToNodeMap);\n        result.schemaErrors = (this.schemaErrors == null) ? null : new ArrayList(this.schemaErrors);\n\n        return result;\n    }","id":47176,"modified_method":"public Object clone() throws CloneNotSupportedException {\n        final InstanceData result = (InstanceData) super.clone();\n\n        try {\n            result.relevant = (RelevantModelItemProperty) this.relevant.clone();\n            result.required = (RequiredModelItemProperty) this.required.clone();\n            result.readonly = (ReadonlyModelItemProperty) this.readonly.clone();\n            result.valueValid = (ValidModelItemProperty) this.valueValid.clone();\n            result.constraint = (ValidModelItemProperty) this.constraint.clone();\n            result.type = (TypeModelItemProperty) this.type.clone();\n\n            result.xxformsExternalize = (this.xxformsExternalize != null) ? (XXFormsExternalizeModelItemProperty) this.xxformsExternalize.clone() : null;\n            \n            if (this.switchIdsToCaseIds != null)\n                result.switchIdsToCaseIds = new HashMap(this.switchIdsToCaseIds);\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen because the classes cloned are Cloneable\n            throw new OXFException(e);\n        }\n\n        result.valueChanged = this.valueChanged;\n        result.idToNodeMap = (this.idToNodeMap == null) ? null : new HashMap(this.idToNodeMap);\n        result.schemaErrors = (this.schemaErrors == null) ? null : new ArrayList(this.schemaErrors);\n\n        return result;\n    }","commit_id":"6e843632c529709328c82fadc6112034124692f3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void clearOtherState() {\n        relevant.set(relevant.getDefaultValue());\n        readonly.set(readonly.getDefaultValue());\n        required.set(required.getDefaultValue(), null);\n    }","id":47177,"modified_method":"public void clearOtherState() {\n        relevant.set(relevant.getDefaultValue());\n        readonly.set(readonly.getDefaultValue());\n        required.set(required.getDefaultValue(), null);\n\n        switchIdsToCaseIds = null;\n    }","commit_id":"6e843632c529709328c82fadc6112034124692f3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Execute an XForms action.\n     *\n     * @param pipelineContext       current PipelineContext\n     * @param targetId              id of the target control\n     * @param eventHandlerContainer event handler containe this action is running in\n     * @param actionElement         Element specifying the action to execute\n     * @param actionContext         ActionContext instance for deferred updates, or null\n     */\n    public void runAction(final PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement, ActionContext actionContext) {\n\n        // Check that we understand the action element\n        final String actionNamespaceURI = actionElement.getNamespaceURI();\n        if (!XFormsConstants.XFORMS_NAMESPACE_URI.equals(actionNamespaceURI)) {\n            throw new OXFException(\"Invalid action namespace: \" + actionNamespaceURI);\n        }\n\n        // Set binding context\n        setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n\n        final String actionEventName = actionElement.getName();\n\n        if (XFormsServer.logger.isDebugEnabled())\n            XFormsServer.logger.debug(\"XForms - executing action: \" + actionEventName);\n\n        if (XFormsActions.XFORMS_SETVALUE_ACTION.equals(actionEventName)) {\n            // 10.1.9 The setvalue Element\n            // xforms:setvalue\n\n            final String value = actionElement.attributeValue(\"value\");\n            final String content = actionElement.getStringValue();\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String valueToSet;\n            if (value != null) {\n                // Value to set is computed with an XPath expression\n                final Map namespaceContext = Dom4jUtils.getNamespaceContextNoDefault(actionElement);\n\n                final List currentNodeset = (xformsControls.getCurrentNodeset()!= null) ?\n                        xformsControls.getCurrentNodeset() : Collections.singletonList(currentInstance.getInstanceDocument());\n                // NOTE: The above is actually not correct: the context should not become null. This is therefore just\n                // a workaround for a bug we hit:\n\n                // o Do 2 setvalue in sequence\n                // o The first one changes the context around the control containing the actions\n                // o When the second one runs, context is empty, and setvalue either crashes or does nothing\n                //\n                // The correct solution is probably to NOT reevaluate the context of actions unless a rebuild is done.\n                // This would require an update to the way we impelement the processing model.\n\n                valueToSet = currentInstance.evaluateXPathAsString(pipelineContext,\n                        currentNodeset, xformsControls.getCurrentPosition(),\n                        value, namespaceContext, null, xformsControls.getFunctionLibrary(), null);\n            } else {\n                // Value to set is static content\n                valueToSet = content;\n            }\n\n            // Set value on current node\n            final Node currentNode = xformsControls.getCurrentSingleNode();\n            if (currentNode != null) {\n                // Node exists, we can set the value\n                XFormsInstance.setValueForNode(pipelineContext, currentNode, valueToSet, null);\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change only the value of an instance node results in setting\n                    // the flags for recalculate, revalidate, and refresh to true and making no change to\n                    // the flag for rebuild\".\n                    actionContext.recalculate = true;\n                    actionContext.revalidate = true;\n                    actionContext.refresh = true;\n                } else {\n                    // Send events directly\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            } else {\n                // Node doesn't exist, don't do anything\n                // NOP\n            }\n\n        } else if (XFormsActions.XFORMS_RESET_ACTION.equals(actionEventName)) {\n            // 10.1.11 The reset Element\n\n            final String modelId = actionElement.attributeValue(\"model\");\n\n            final Object modelObject = containingDocument.getObjectById(pipelineContext, modelId);\n            if (modelObject instanceof XFormsModel) {\n                final XFormsModel model = (XFormsModel) modelObject;\n                containingDocument.dispatchEvent(pipelineContext, new XFormsResetEvent(model));\n            } else {\n                throw new OXFException(\"xforms:reset model attribute must point to an xforms:model element.\");\n            }\n\n            // \"the reset action takes effect immediately and clears all of the flags.\"\n            if (actionContext != null)\n                actionContext.setAll(false);\n\n        } else if (XFormsActions.XFORMS_ACTION_ACTION.equals(actionEventName)) {\n            // 10.1.1 The action Element\n\n            final ActionContext newActionContext = (actionContext == null) ? new ActionContext() : null;\n            for (Iterator i = actionElement.elementIterator(); i.hasNext();) {\n                final Element embeddedActionElement = (Element) i.next();\n                runAction(pipelineContext, targetId, eventHandlerContainer, embeddedActionElement, (newActionContext == null) ? actionContext : newActionContext );\n            }\n            if (newActionContext != null) {\n                // Binding context has to be reset as it may have been modified by sub-actions\n                setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                final XFormsModel model = xformsControls.getCurrentModel();\n\n                // Process deferred behavior\n                if (newActionContext.rebuild)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                if (newActionContext.recalculate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                if (newActionContext.revalidate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                if (newActionContext.refresh)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_REBUILD_ACTION.equals(actionEventName)) {\n            // 10.1.3 The rebuild Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.rebuild = false;\n\n        } else if (XFormsActions.XFORMS_RECALCULATE_ACTION.equals(actionEventName)) {\n            // 10.1.4 The recalculate Element\n\n            // TODO: handle optional \"model\" attribute\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.recalculate = false;\n\n        } else if (XFormsActions.XFORMS_REVALIDATE_ACTION.equals(actionEventName)) {\n            // 10.1.5 The revalidate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.revalidate = false;\n\n        } else if (XFormsActions.XFORMS_REFRESH_ACTION.equals(actionEventName)) {\n            // 10.1.6 The refresh Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.refresh = false;\n\n        } else if (XFormsActions.XFORMS_TOGGLE_ACTION.equals(actionEventName)) {\n            // 9.2.3 The toggle Element\n\n            final String caseId = actionElement.attributeValue(\"case\");\n            final String effectiveCaseId = xformsControls.findEffectiveCaseId(caseId);\n\n            // Update xforms:switch info and dispatch events\n            xformsControls.updateSwitchInfo(pipelineContext, effectiveCaseId);\n\n        } else if (XFormsActions.XFORMS_INSERT_ACTION.equals(actionEventName)) {\n            // 9.3.5 The insert Element\n            final String atAttribute = actionElement.attributeValue(\"at\");\n            final String positionAttribute = actionElement.attributeValue(\"position\");\n            final String originAttribute = actionElement.attributeValue(\"origin\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the insert action has no effect.\"\n\n                // \"2. The node-set binding identifies a homogeneous collection in the instance\n                // data. The final member of this collection is cloned to produce the node that will\n                // be inserted.\"\n                final Element clonedElement;\n                {\n                    if (originAttribute == null) {\n                        final Element lastElement = (Element) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1);\n                        clonedElement = (Element) lastElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                    } else {\n                        xformsControls.pushBinding(pipelineContext, null, originAttribute, null, null, null, Dom4jUtils.getNamespaceContextNoDefault(actionElement));\n                        final Element templateElement =  (Element) xformsControls.getCurrentSingleNode();// TODO: for now only support Element\n                        clonedElement = templateElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                        xformsControls.popBinding();\n                    }\n                }\n\n                // \"Finally, this newly created node is inserted into the instance data at the location\n                // specified by attributes position and at.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final String insertionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                        xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                // Don't think we will get NaN with XPath 2.0...\n                int insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                // Adjust index to be in range\n                if (insertionIndex > collectionToBeUpdated.size())\n                    insertionIndex = collectionToBeUpdated.size();\n\n                if (insertionIndex < 1)\n                    insertionIndex = 1;\n\n                // Find actual insertion point and insert\n                final Element indexElement = (Element) collectionToBeUpdated.get(insertionIndex - 1);\n\n                final Element parentElement = indexElement.getParent();\n                final List siblingElements = parentElement.content();\n                final int actualIndex = siblingElements.indexOf(indexElement);\n\n                // Prepare insertion of new element\n                final int actualInsertionIndex;\n                if (\"after\".equals(positionAttribute) || \"NaN\".equals(insertionIndexString)) {\n                    actualInsertionIndex = actualIndex + 1;\n                } else if (\"before\".equals(positionAttribute)) {\n                    actualInsertionIndex = actualIndex;\n                } else {\n                    throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after'.\");\n                }\n\n                // \"3. The index for any repeating sequence that is bound to the homogeneous\n                // collection where the node was added is updated to point to the newly added node.\n                // The indexes for inner nested repeat collections are re-initialized to\n                // startindex.\"\n\n                // Perform the insertion\n                siblingElements.add(actualInsertionIndex, clonedElement);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat indexes\n                XFormsIndexUtils.ajustIndexesAfterRepeat(pipelineContext, xformsControls, currentControlsState, clonedElement);\n\n                // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_DELETE_ACTION.equals(actionEventName)) {\n            // 9.3.6 The delete Element\n\n            final String atAttribute = actionElement.attributeValue(\"at\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToUpdate = xformsControls.getCurrentNodeset();\n\n            if (collectionToUpdate != null && collectionToUpdate.size() > 0) {\n                // \"If the collection is empty, the delete action has no effect.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final Element elementToRemove;\n                final List siblingElements;\n                final int actualIndexInCollection;\n                {\n                    final String deletionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                            xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                            \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // We will not get NaN with XPath 2.0...\n                    int tempDeletionIndex = \"NaN\".equals(deletionIndexString) ? collectionToUpdate.size() : Integer.parseInt(deletionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (tempDeletionIndex > collectionToUpdate.size())\n                        tempDeletionIndex = collectionToUpdate.size();\n\n                    if (tempDeletionIndex < 1)\n                        tempDeletionIndex = 1;\n\n                    // Find actual deletion point\n                    elementToRemove = (Element) collectionToUpdate.get(tempDeletionIndex - 1);\n                    final Element parentElement = elementToRemove.getParent();\n                    siblingElements = parentElement.elements();\n                    actualIndexInCollection = siblingElements.indexOf(elementToRemove);\n                }\n\n                // Get current repeat indexes\n                final Map previousRepeatIdToIndex = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n                // Find updates to repeat indexes\n                final Map repeatIndexUpdates = new HashMap();\n                final Map nestedRepeatIndexUpdates = new HashMap();\n                XFormsIndexUtils.adjustIndexesAfterDelete(pipelineContext, xformsControls, previousRepeatIdToIndex,\n                        repeatIndexUpdates, nestedRepeatIndexUpdates, elementToRemove);\n\n                // Then only perform the deletion\n                siblingElements.remove(actualIndexInCollection);\n\n                // Update affected repeat index information\n                if (repeatIndexUpdates.size() > 0) {\n                    for (Iterator i = repeatIndexUpdates.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry = (Map.Entry) i.next();\n                        xformsControls.getCurrentControlsState().updateRepeatIndex((String) currentEntry.getKey(), ((Integer) currentEntry.getValue()).intValue());\n                    }\n                }\n\n                // Adjust controls ids that could have gone out of bounds\n                adjustRepeatIndexes(pipelineContext, xformsControls, nestedRepeatIndexUpdates);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsDeleteEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETINDEX_ACTION.equals(actionEventName)) {\n            // 9.3.7 The setindex Element\n\n            final String repeatId = actionElement.attributeValue(\"repeat\");\n            final String indexXPath = actionElement.attributeValue(\"index\");\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String indexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                    xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                    \"string(number(\" + indexXPath + \"))\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n            executeSetindexAction(pipelineContext, containingDocument, repeatId, indexString);\n\n        } else if (XFormsActions.XFORMS_SEND_ACTION.equals(actionEventName)) {\n            // 10.1.10 The send Element\n\n            // Find submission object\n            final String submissionId = actionElement.attributeValue(\"submission\");\n            if (submissionId == null)\n                throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n            final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n            if (submission == null || !(submission instanceof XFormsModelSubmission))\n                throw new OXFException(\"submission attribute on xforms:send element does not refer to existing xforms:submission element.\");\n\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n\n        } else if (XFormsActions.XFORMS_DISPATCH_ACTION.equals(actionEventName)) {\n            // 10.1.2 The dispatch Element\n\n            // Mandatory attributes\n            final String newEventName = actionElement.attributeValue(\"name\");\n            if (newEventName == null)\n                throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n            final String newEventTargetId = actionElement.attributeValue(\"target\");\n            if (newEventTargetId == null)\n                throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n            // Optional attributes\n            final boolean newEventBubbles; {\n                final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n            }\n            final boolean newEventCancelable; {\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n                newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n            }\n\n            // Find actual target\n            final Object xformsEventTarget;\n            {\n                final Object tempXFormsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetId);\n                if (tempXFormsEventTarget != null) {\n                    // Object with this id exists \n                    xformsEventTarget = tempXFormsEventTarget;\n                } else {\n                    // Otherwise, try effective id\n                    final String newEventTargetEffectiveId = xformsControls.getCurrentControlsState().findEffectiveControlId(newEventTargetId);\n                    xformsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetEffectiveId);\n                }\n            }\n\n            if (xformsEventTarget == null)\n                throw new OXFException(\"Could not find actual event target on xforms:dispatch element for id: \" + newEventTargetId);\n\n            if (xformsEventTarget instanceof XFormsEventTarget) {\n                // This can be anything\n                containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(newEventName, (XFormsEventTarget) xformsEventTarget, newEventBubbles, newEventCancelable));\n            } else {\n                throw new OXFException(\"Invalid event target for id: \" + newEventTargetId);\n            }\n\n        } else if (XFormsActions.XFORMS_MESSAGE_ACTION.equals(actionEventName)) {\n            // 10.1.12 The message Element\n\n            final String level;\n            {\n                final String levelAttribute = actionElement.attributeValue(\"level\");;\n                if (levelAttribute == null)\n                    throw new OXFException(\"xforms:message element is missing mandatory 'level' attribute.\");\n                final QName levelQName = Dom4jUtils.extractAttributeValueQName(actionElement, \"level\");\n                if (levelQName.getNamespacePrefix().equals(\"\")) {\n                    if (!(\"ephemeral\".equals(levelAttribute) || \"modeless\".equals(levelAttribute) || \"modal\".equals(levelAttribute))) {\n                        throw new OXFException(\"xforms:message element's 'level' attribute must have value: 'ephemeral'|'modeless'|'modal'|QName-but-not-NCName.\");\n                    }\n                    level = levelAttribute;\n                } else {\n                    level = \"{\" + levelQName.getNamespaceURI() + \"}\" + levelQName.getName();\n                }\n            }\n\n            final String src = actionElement.attributeValue(\"src\");\n            final String ref = actionElement.attributeValue(\"ref\");\n\n            String message = null;\n\n            // Try to get message from single-node binding if any\n            if (ref != null) {\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null)\n                    message = XFormsInstance.getValueForNode(currentNode);\n            }\n\n            // Try to get message from linking attribute\n            boolean linkException = false;\n            if (message == null && src != null) {\n                try {\n                    message = XFormsUtils.retrieveSrcValue(src);\n                } catch (IOException e) {\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), src, null, e));\n                    linkException = true;\n                }\n            }\n\n            if (!linkException) {\n                // Try to get inline message\n                if (message == null) {\n                    message = actionElement.getStringValue();\n                }\n\n                if (message != null) {\n                    // Store message for sending to client\n                    containingDocument.addClientMessage(message, level);\n\n                    // NOTE: In the future, we *may* want to save and resume the event state before and\n                    // after displaying a message, in order to possibly provide a behavior which is more\n                    // consistent with what users may expect regarding actions executed after\n                    // xforms:message.\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETFOCUS_ACTION.equals(actionEventName)) {\n\n            // 10.1.7 The setfocus Element\n\n            final String controlId = actionElement.attributeValue(\"control\");\n            if (controlId == null)\n                throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n            final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(controlId);\n            if (effectiveControlId == null)\n                throw new OXFException(\"Could not find actual control on xforms:setfocus element for control: \" + controlId);\n\n            final Object controlObject = containingDocument.getObjectById(pipelineContext, effectiveControlId);\n\n            if (!(controlObject instanceof ControlInfo))\n                throw new OXFException(\"xforms:setfocus attribute 'control' must refer to a control: \" + controlId);\n\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n\n        } else if (XFormsActions.XFORMS_LOAD_ACTION.equals(actionEventName)) {\n\n            // 10.1.8 The load Element\n\n            final String ref = actionElement.attributeValue(\"ref\");\n            final String resource = actionElement.attributeValue(\"resource\");\n            final String showAttribute;\n            {\n                final String rawShowAttribute = actionElement.attributeValue(\"show\");\n                showAttribute = (rawShowAttribute == null) ? \"replace\" : rawShowAttribute;\n                if (!(\"replace\".equals(showAttribute) || \"new\".equals(showAttribute)))\n                    throw new OXFException(\"Invalid value for 'show' attribute on xforms:load element: \" + showAttribute);\n            }\n            final boolean doReplace = \"replace\".equals(showAttribute);\n            final String target = actionElement.attributeValue(XFormsConstants.XXFORMS_TARGET_QNAME);\n            final String urlType = actionElement.attributeValue(new QName(\"url-type\", new Namespace(\"f\", XMLConstants.OPS_FORMATTING_URI)));\n\n            if (ref != null && resource != null) {\n                // \"If both are present, the action has no effect.\"\n                // NOP\n            } else if (ref != null) {\n                // Use single-node binding\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null) {\n                    final String value = XFormsInstance.getValueForNode(currentNode);\n                    resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, value, target, urlType);\n                } else {\n                    // Should we do this here?\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), \"\", null, null));\n                }\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else if (resource != null) {\n                // Use linking attribute\n                resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, resource, target, urlType);\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else {\n                // \"Either the single node binding attributes, pointing to a URI in the instance\n                // data, or the linking attributes are required.\"\n                throw new OXFException(\"Missing 'resource' or 'ref' attribute on xforms:load element.\");\n            }\n        } else {\n            throw new OXFException(\"Invalid action requested: \" + actionEventName);\n        }\n    }","id":47178,"modified_method":"/**\n     * Execute an XForms action.\n     *\n     * @param pipelineContext       current PipelineContext\n     * @param targetId              id of the target control\n     * @param eventHandlerContainer event handler containe this action is running in\n     * @param actionElement         Element specifying the action to execute\n     * @param actionContext         ActionContext instance for deferred updates, or null\n     */\n    public void runAction(final PipelineContext pipelineContext, String targetId, XFormsEventHandlerContainer eventHandlerContainer, Element actionElement, ActionContext actionContext) {\n\n        // Check that we understand the action element\n        final String actionNamespaceURI = actionElement.getNamespaceURI();\n        if (!XFormsConstants.XFORMS_NAMESPACE_URI.equals(actionNamespaceURI)) {\n            throw new OXFException(\"Invalid action namespace: \" + actionNamespaceURI);\n        }\n\n        // Set binding context\n        setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n\n        final String actionEventName = actionElement.getName();\n\n        if (XFormsServer.logger.isDebugEnabled())\n            XFormsServer.logger.debug(\"XForms - executing action: \" + actionEventName);\n\n        if (XFormsActions.XFORMS_SETVALUE_ACTION.equals(actionEventName)) {\n            // 10.1.9 The setvalue Element\n            // xforms:setvalue\n\n            final String value = actionElement.attributeValue(\"value\");\n            final String content = actionElement.getStringValue();\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String valueToSet;\n            if (value != null) {\n                // Value to set is computed with an XPath expression\n                final Map namespaceContext = Dom4jUtils.getNamespaceContextNoDefault(actionElement);\n\n                final List currentNodeset = (xformsControls.getCurrentNodeset()!= null) ?\n                        xformsControls.getCurrentNodeset() : Collections.singletonList(currentInstance.getInstanceDocument());\n                // NOTE: The above is actually not correct: the context should not become null. This is therefore just\n                // a workaround for a bug we hit:\n\n                // o Do 2 setvalue in sequence\n                // o The first one changes the context around the control containing the actions\n                // o When the second one runs, context is empty, and setvalue either crashes or does nothing\n                //\n                // The correct solution is probably to NOT reevaluate the context of actions unless a rebuild is done.\n                // This would require an update to the way we impelement the processing model.\n\n                valueToSet = currentInstance.evaluateXPathAsString(pipelineContext,\n                        currentNodeset, xformsControls.getCurrentPosition(),\n                        value, namespaceContext, null, xformsControls.getFunctionLibrary(), null);\n            } else {\n                // Value to set is static content\n                valueToSet = content;\n            }\n\n            // Set value on current node\n            final Node currentNode = xformsControls.getCurrentSingleNode();\n            if (currentNode != null) {\n                // Node exists, we can set the value\n                XFormsInstance.setValueForNode(pipelineContext, currentNode, valueToSet, null);\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change only the value of an instance node results in setting\n                    // the flags for recalculate, revalidate, and refresh to true and making no change to\n                    // the flag for rebuild\".\n                    actionContext.recalculate = true;\n                    actionContext.revalidate = true;\n                    actionContext.refresh = true;\n                } else {\n                    // Send events directly\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            } else {\n                // Node doesn't exist, don't do anything\n                // NOP\n            }\n\n        } else if (XFormsActions.XFORMS_RESET_ACTION.equals(actionEventName)) {\n            // 10.1.11 The reset Element\n\n            final String modelId = actionElement.attributeValue(\"model\");\n\n            final Object modelObject = containingDocument.getObjectById(pipelineContext, modelId);\n            if (modelObject instanceof XFormsModel) {\n                final XFormsModel model = (XFormsModel) modelObject;\n                containingDocument.dispatchEvent(pipelineContext, new XFormsResetEvent(model));\n            } else {\n                throw new OXFException(\"xforms:reset model attribute must point to an xforms:model element.\");\n            }\n\n            // \"the reset action takes effect immediately and clears all of the flags.\"\n            if (actionContext != null)\n                actionContext.setAll(false);\n\n        } else if (XFormsActions.XFORMS_ACTION_ACTION.equals(actionEventName)) {\n            // 10.1.1 The action Element\n\n            final ActionContext newActionContext = (actionContext == null) ? new ActionContext() : null;\n            for (Iterator i = actionElement.elementIterator(); i.hasNext();) {\n                final Element embeddedActionElement = (Element) i.next();\n                runAction(pipelineContext, targetId, eventHandlerContainer, embeddedActionElement, (newActionContext == null) ? actionContext : newActionContext );\n            }\n            if (newActionContext != null) {\n                // Binding context has to be reset as it may have been modified by sub-actions\n                setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                final XFormsModel model = xformsControls.getCurrentModel();\n\n                // Process deferred behavior\n                if (newActionContext.rebuild)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                if (newActionContext.recalculate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                if (newActionContext.revalidate)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                if (newActionContext.refresh)\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsActions.XFORMS_REBUILD_ACTION.equals(actionEventName)) {\n            // 10.1.3 The rebuild Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.rebuild = false;\n\n        } else if (XFormsActions.XFORMS_RECALCULATE_ACTION.equals(actionEventName)) {\n            // 10.1.4 The recalculate Element\n\n            // TODO: handle optional \"model\" attribute\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.recalculate = false;\n\n        } else if (XFormsActions.XFORMS_REVALIDATE_ACTION.equals(actionEventName)) {\n            // 10.1.5 The revalidate Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.revalidate = false;\n\n        } else if (XFormsActions.XFORMS_REFRESH_ACTION.equals(actionEventName)) {\n            // 10.1.6 The refresh Element\n\n            final XFormsModel model = xformsControls.getCurrentModel();\n            containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n            // \"Actions that directly invoke rebuild, recalculate, revalidate, or refresh always\n            // have an immediate effect, and clear the corresponding flag.\"\n            if (actionContext != null)\n                actionContext.refresh = false;\n\n        } else if (XFormsActions.XFORMS_TOGGLE_ACTION.equals(actionEventName)) {\n            // 9.2.3 The toggle Element\n\n            final String caseId = actionElement.attributeValue(\"case\");\n            final String effectiveCaseId = xformsControls.findEffectiveCaseId(caseId);\n\n            // Update xforms:switch info and dispatch events\n            xformsControls.updateSwitchInfo(pipelineContext, effectiveCaseId);\n\n        } else if (XFormsActions.XFORMS_INSERT_ACTION.equals(actionEventName)) {\n            // 9.3.5 The insert Element\n            final String atAttribute = actionElement.attributeValue(\"at\");\n            final String positionAttribute = actionElement.attributeValue(\"position\");\n            final String originAttribute = actionElement.attributeValue(\"origin\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToBeUpdated = xformsControls.getCurrentNodeset();\n\n            if (collectionToBeUpdated.size() > 0) {\n                // \"If the collection is empty, the insert action has no effect.\"\n\n                // \"2. The node-set binding identifies a homogeneous collection in the instance\n                // data. The final member of this collection is cloned to produce the node that will\n                // be inserted.\"\n                final Element sourceElement;\n                final Element clonedElement;\n                {\n                    if (originAttribute == null) {\n                        sourceElement = (Element) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1);\n                        clonedElement = (Element) sourceElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                    } else {\n                        xformsControls.pushBinding(pipelineContext, null, originAttribute, null, null, null, Dom4jUtils.getNamespaceContextNoDefault(actionElement));\n                        sourceElement =  (Element) xformsControls.getCurrentSingleNode();// TODO: for now only support Element\n                        clonedElement = sourceElement.createCopy();\n                        XFormsUtils.setInitialDecoration(clonedElement);\n                        xformsControls.popBinding();\n                    }\n                }\n\n                // \"Finally, this newly created node is inserted into the instance data at the location\n                // specified by attributes position and at.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final String insertionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                        xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                        \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                // Don't think we will get NaN with XPath 2.0...\n                int insertionIndex = \"NaN\".equals(insertionIndexString) ? collectionToBeUpdated.size() : Integer.parseInt(insertionIndexString) ;\n\n                // Adjust index to be in range\n                if (insertionIndex > collectionToBeUpdated.size())\n                    insertionIndex = collectionToBeUpdated.size();\n\n                if (insertionIndex < 1)\n                    insertionIndex = 1;\n\n                // Find actual insertion point and insert\n                final Element indexElement = (Element) collectionToBeUpdated.get(insertionIndex - 1);\n\n                final Element parentElement = indexElement.getParent();\n                final List siblingElements = parentElement.content();\n                final int actualIndex = siblingElements.indexOf(indexElement);\n\n                // Prepare insertion of new element\n                final int actualInsertionIndex;\n                if (\"after\".equals(positionAttribute) || \"NaN\".equals(insertionIndexString)) {\n                    actualInsertionIndex = actualIndex + 1;\n                } else if (\"before\".equals(positionAttribute)) {\n                    actualInsertionIndex = actualIndex;\n                } else {\n                    throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after'.\");\n                }\n\n                // Prepare switches\n                XFormsSwitchUtils.prepareSwitches(pipelineContext, xformsControls, sourceElement, clonedElement);\n\n                // \"3. The index for any repeating sequence that is bound to the homogeneous\n                // collection where the node was added is updated to point to the newly added node.\n                // The indexes for inner nested repeat collections are re-initialized to\n                // startindex.\"\n\n                // Perform the insertion\n                siblingElements.add(actualInsertionIndex, clonedElement);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n                final XFormsControls.ControlsState currentControlsState = xformsControls.getCurrentControlsState();\n\n                // Update repeat indexes\n                XFormsIndexUtils.ajustIndexesAfterInsert(pipelineContext, xformsControls, currentControlsState, clonedElement);\n\n                // Update switches\n                XFormsSwitchUtils.updateSwitches(pipelineContext, xformsControls);\n\n                // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsInsertEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_DELETE_ACTION.equals(actionEventName)) {\n            // 9.3.6 The delete Element\n\n            final String atAttribute = actionElement.attributeValue(\"at\");\n\n            // Set current binding in order to evaluate the current nodeset\n            // \"1. The homogeneous collection to be updated is determined by evaluating the Node Set Binding.\"\n\n            final List collectionToUpdate = xformsControls.getCurrentNodeset();\n\n            if (collectionToUpdate != null && collectionToUpdate.size() > 0) {\n                // \"If the collection is empty, the delete action has no effect.\"\n\n                final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n                final Element elementToRemove;\n                final List siblingElements;\n                final int actualIndexInCollection;\n                {\n                    final String deletionIndexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                            xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                            \"round(\" + atAttribute + \")\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n                    // We will not get NaN with XPath 2.0...\n                    int tempDeletionIndex = \"NaN\".equals(deletionIndexString) ? collectionToUpdate.size() : Integer.parseInt(deletionIndexString) ;\n\n                    // Adjust index to be in range\n                    if (tempDeletionIndex > collectionToUpdate.size())\n                        tempDeletionIndex = collectionToUpdate.size();\n\n                    if (tempDeletionIndex < 1)\n                        tempDeletionIndex = 1;\n\n                    // Find actual deletion point\n                    elementToRemove = (Element) collectionToUpdate.get(tempDeletionIndex - 1);\n                    final Element parentElement = elementToRemove.getParent();\n                    siblingElements = parentElement.elements();\n                    actualIndexInCollection = siblingElements.indexOf(elementToRemove);\n                }\n\n                // Get current repeat indexes\n                final Map previousRepeatIdToIndex = xformsControls.getCurrentControlsState().getRepeatIdToIndex();\n\n                // Find updates to repeat indexes\n                final Map repeatIndexUpdates = new HashMap();\n                final Map nestedRepeatIndexUpdates = new HashMap();\n                XFormsIndexUtils.adjustIndexesForDelete(pipelineContext, xformsControls, previousRepeatIdToIndex,\n                        repeatIndexUpdates, nestedRepeatIndexUpdates, elementToRemove);\n\n                // Prepare switches\n                XFormsSwitchUtils.prepareSwitches(pipelineContext, xformsControls);\n\n                // Then only perform the deletion\n                siblingElements.remove(actualIndexInCollection);\n\n                // Rebuild ControlsState\n                xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n                // Update switches\n                XFormsSwitchUtils.updateSwitches(pipelineContext, xformsControls);\n\n                // Update affected repeat index information\n                if (repeatIndexUpdates.size() > 0) {\n                    for (Iterator i = repeatIndexUpdates.entrySet().iterator(); i.hasNext();) {\n                        final Map.Entry currentEntry = (Map.Entry) i.next();\n                        xformsControls.getCurrentControlsState().updateRepeatIndex((String) currentEntry.getKey(), ((Integer) currentEntry.getValue()).intValue());\n                    }\n                }\n\n                // Adjust indexes that could have gone out of bounds\n                adjustRepeatIndexes(pipelineContext, xformsControls, nestedRepeatIndexUpdates);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                containingDocument.dispatchEvent(pipelineContext, new XFormsDeleteEvent(currentInstance, atAttribute));\n\n                if (actionContext != null) {\n                    // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                    actionContext.setAll(true);\n                } else {\n                    // Binding context has to be reset as the controls have been updated\n                    setBindingContext(pipelineContext, containingDocument, eventHandlerContainer.getId(), actionElement);\n                    final XFormsModel model = xformsControls.getCurrentModel();\n                    // Send events directly\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRebuildEvent(model));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETINDEX_ACTION.equals(actionEventName)) {\n            // 9.3.7 The setindex Element\n\n            final String repeatId = actionElement.attributeValue(\"repeat\");\n            final String indexXPath = actionElement.attributeValue(\"index\");\n\n            final XFormsInstance currentInstance = xformsControls.getCurrentInstance();\n            final String indexString = currentInstance.evaluateXPathAsString(pipelineContext,\n                    xformsControls.getCurrentNodeset(), xformsControls.getCurrentPosition(),\n                    \"string(number(\" + indexXPath + \"))\", Dom4jUtils.getNamespaceContextNoDefault(actionElement), null, xformsControls.getFunctionLibrary(), null);\n\n            executeSetindexAction(pipelineContext, containingDocument, repeatId, indexString);\n\n        } else if (XFormsActions.XFORMS_SEND_ACTION.equals(actionEventName)) {\n            // 10.1.10 The send Element\n\n            // Find submission object\n            final String submissionId = actionElement.attributeValue(\"submission\");\n            if (submissionId == null)\n                throw new OXFException(\"Missing mandatory submission attribute on xforms:send element.\");\n            final Object submission = containingDocument.getObjectById(pipelineContext, submissionId);\n            if (submission == null || !(submission instanceof XFormsModelSubmission))\n                throw new OXFException(\"submission attribute on xforms:send element does not refer to existing xforms:submission element.\");\n\n            // Dispatch event to submission object\n            containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitEvent((XFormsEventTarget) submission));\n\n        } else if (XFormsActions.XFORMS_DISPATCH_ACTION.equals(actionEventName)) {\n            // 10.1.2 The dispatch Element\n\n            // Mandatory attributes\n            final String newEventName = actionElement.attributeValue(\"name\");\n            if (newEventName == null)\n                throw new OXFException(\"Missing mandatory name attribute on xforms:dispatch element.\");\n            final String newEventTargetId = actionElement.attributeValue(\"target\");\n            if (newEventTargetId == null)\n                throw new OXFException(\"Missing mandatory target attribute on xforms:dispatch element.\");\n\n            // Optional attributes\n            final boolean newEventBubbles; {\n                final String newEventBubblesString = actionElement.attributeValue(\"bubbles\");\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                newEventBubbles = Boolean.valueOf((newEventBubblesString == null) ? \"true\" : newEventBubblesString).booleanValue();\n            }\n            final boolean newEventCancelable; {\n                // \"The default value depends on the definition of a custom event. For predefined events, this attribute has no effect.\"\n                // The event factory makes sure that those values are ignored for predefined events\n                final String newEventCancelableString = actionElement.attributeValue(\"cancelable\");\n                newEventCancelable = Boolean.valueOf((newEventCancelableString == null) ? \"true\" : newEventCancelableString).booleanValue();\n            }\n\n            // Find actual target\n            final Object xformsEventTarget;\n            {\n                final Object tempXFormsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetId);\n                if (tempXFormsEventTarget != null) {\n                    // Object with this id exists \n                    xformsEventTarget = tempXFormsEventTarget;\n                } else {\n                    // Otherwise, try effective id\n                    final String newEventTargetEffectiveId = xformsControls.getCurrentControlsState().findEffectiveControlId(newEventTargetId);\n                    xformsEventTarget = (XFormsEventTarget) containingDocument.getObjectById(pipelineContext, newEventTargetEffectiveId);\n                }\n            }\n\n            if (xformsEventTarget == null)\n                throw new OXFException(\"Could not find actual event target on xforms:dispatch element for id: \" + newEventTargetId);\n\n            if (xformsEventTarget instanceof XFormsEventTarget) {\n                // This can be anything\n                containingDocument.dispatchEvent(pipelineContext, XFormsEventFactory.createEvent(newEventName, (XFormsEventTarget) xformsEventTarget, newEventBubbles, newEventCancelable));\n            } else {\n                throw new OXFException(\"Invalid event target for id: \" + newEventTargetId);\n            }\n\n        } else if (XFormsActions.XFORMS_MESSAGE_ACTION.equals(actionEventName)) {\n            // 10.1.12 The message Element\n\n            final String level;\n            {\n                final String levelAttribute = actionElement.attributeValue(\"level\");;\n                if (levelAttribute == null)\n                    throw new OXFException(\"xforms:message element is missing mandatory 'level' attribute.\");\n                final QName levelQName = Dom4jUtils.extractAttributeValueQName(actionElement, \"level\");\n                if (levelQName.getNamespacePrefix().equals(\"\")) {\n                    if (!(\"ephemeral\".equals(levelAttribute) || \"modeless\".equals(levelAttribute) || \"modal\".equals(levelAttribute))) {\n                        throw new OXFException(\"xforms:message element's 'level' attribute must have value: 'ephemeral'|'modeless'|'modal'|QName-but-not-NCName.\");\n                    }\n                    level = levelAttribute;\n                } else {\n                    level = \"{\" + levelQName.getNamespaceURI() + \"}\" + levelQName.getName();\n                }\n            }\n\n            final String src = actionElement.attributeValue(\"src\");\n            final String ref = actionElement.attributeValue(\"ref\");\n\n            String message = null;\n\n            // Try to get message from single-node binding if any\n            if (ref != null) {\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null)\n                    message = XFormsInstance.getValueForNode(currentNode);\n            }\n\n            // Try to get message from linking attribute\n            boolean linkException = false;\n            if (message == null && src != null) {\n                try {\n                    message = XFormsUtils.retrieveSrcValue(src);\n                } catch (IOException e) {\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), src, null, e));\n                    linkException = true;\n                }\n            }\n\n            if (!linkException) {\n                // Try to get inline message\n                if (message == null) {\n                    message = actionElement.getStringValue();\n                }\n\n                if (message != null) {\n                    // Store message for sending to client\n                    containingDocument.addClientMessage(message, level);\n\n                    // NOTE: In the future, we *may* want to save and resume the event state before and\n                    // after displaying a message, in order to possibly provide a behavior which is more\n                    // consistent with what users may expect regarding actions executed after\n                    // xforms:message.\n                }\n            }\n\n        } else if (XFormsActions.XFORMS_SETFOCUS_ACTION.equals(actionEventName)) {\n\n            // 10.1.7 The setfocus Element\n\n            final String controlId = actionElement.attributeValue(\"control\");\n            if (controlId == null)\n                throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n            final String effectiveControlId = xformsControls.getCurrentControlsState().findEffectiveControlId(controlId);\n            if (effectiveControlId == null)\n                throw new OXFException(\"Could not find actual control on xforms:setfocus element for control: \" + controlId);\n\n            final Object controlObject = containingDocument.getObjectById(pipelineContext, effectiveControlId);\n\n            if (!(controlObject instanceof ControlInfo))\n                throw new OXFException(\"xforms:setfocus attribute 'control' must refer to a control: \" + controlId);\n\n            containingDocument.dispatchEvent(pipelineContext, new XFormsFocusEvent((XFormsEventTarget) controlObject));\n\n        } else if (XFormsActions.XFORMS_LOAD_ACTION.equals(actionEventName)) {\n\n            // 10.1.8 The load Element\n\n            final String ref = actionElement.attributeValue(\"ref\");\n            final String resource = actionElement.attributeValue(\"resource\");\n            final String showAttribute;\n            {\n                final String rawShowAttribute = actionElement.attributeValue(\"show\");\n                showAttribute = (rawShowAttribute == null) ? \"replace\" : rawShowAttribute;\n                if (!(\"replace\".equals(showAttribute) || \"new\".equals(showAttribute)))\n                    throw new OXFException(\"Invalid value for 'show' attribute on xforms:load element: \" + showAttribute);\n            }\n            final boolean doReplace = \"replace\".equals(showAttribute);\n            final String target = actionElement.attributeValue(XFormsConstants.XXFORMS_TARGET_QNAME);\n            final String urlType = actionElement.attributeValue(new QName(\"url-type\", new Namespace(\"f\", XMLConstants.OPS_FORMATTING_URI)));\n\n            if (ref != null && resource != null) {\n                // \"If both are present, the action has no effect.\"\n                // NOP\n            } else if (ref != null) {\n                // Use single-node binding\n                final Node currentNode = xformsControls.getCurrentSingleNode();\n                if (currentNode != null) {\n                    final String value = XFormsInstance.getValueForNode(currentNode);\n                    resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, value, target, urlType);\n                } else {\n                    // Should we do this here?\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsLinkErrorEvent(xformsControls.getCurrentModel(), \"\", null, null));\n                }\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else if (resource != null) {\n                // Use linking attribute\n                resolveLoadValue(containingDocument, pipelineContext, actionElement, doReplace, resource, target, urlType);\n                // NOTE: We are supposed to throw an xforms-link-error in case of failure. Can we do it?\n            } else {\n                // \"Either the single node binding attributes, pointing to a URI in the instance\n                // data, or the linking attributes are required.\"\n                throw new OXFException(\"Missing 'resource' or 'ref' attribute on xforms:load element.\");\n            }\n        } else {\n            throw new OXFException(\"Invalid action requested: \" + actionEventName);\n        }\n    }","commit_id":"6e843632c529709328c82fadc6112034124692f3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Adjust indexes after a deletion.\n     *\n     * @param pipelineContext\n     * @param xformsControls\n     * @param previousRepeatIdToIndex\n     * @param repeatIndexUpdates\n     * @param nestedRepeatIndexUpdates\n     * @param elementToRemove\n     */\n    public static void adjustIndexesAfterDelete(PipelineContext pipelineContext, final XFormsControls xformsControls,\n                                                final Map previousRepeatIdToIndex, final Map repeatIndexUpdates,\n                                                final Map nestedRepeatIndexUpdates, final Element elementToRemove) {\n\n        // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n        xformsControls.getCurrentControlsState().visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n            private ControlInfo foundControl;\n            private boolean reinitializeInner;\n\n            public void startVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    // Found an xforms:repeat\n                    final RepeatControlInfo repeatControlInfo = (RepeatControlInfo) controlInfo;\n                    final String repeatId = repeatControlInfo.getOriginalId();\n\n                    final List repeatNodeSet = xformsControls.getCurrentNodeset();\n                    if (foundControl == null) {\n                        // We are not yet inside a matching xforms:repeat\n\n                        if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                            // Find whether one node of the repeat node-set contains the inserted node\n                            for (Iterator i = repeatNodeSet.iterator(); i.hasNext();) {\n                                final Element currentNode = (Element) i.next();\n                                if (currentNode == elementToRemove) {\n                                    // Found xforms:repeat affected by the change\n\n                                    final int newIndex;\n                                    if (repeatNodeSet.size() == 1) {\n                                        // Delete the last element of the collection: the index must be set to 0\n                                        newIndex = 0;\n                                        reinitializeInner = false;\n                                    } else {\n                                        // Current index for this repeat\n                                        final int currentIndex = ((Integer) previousRepeatIdToIndex.get(repeatId)).intValue();\n\n                                        // Index of deleted element for this repeat\n                                        final int deletionIndexInRepeat = repeatNodeSet.indexOf(elementToRemove) + 1;\n\n                                        if (currentIndex == deletionIndexInRepeat) {\n                                            if (deletionIndexInRepeat == repeatNodeSet.size()) {\n\n                                                // o \"When the last remaining item in the collection is removed,\n                                                // the index position becomes 0.\"\n\n                                                // o \"When the index was pointing to the deleted node, which was\n                                                // the last item in the collection, the index will point to the new\n                                                // last node of the collection and the index of inner repeats is\n                                                // reinitialized.\"\n\n                                                newIndex = currentIndex - 1;\n                                                reinitializeInner = true;\n                                            } else {\n                                                // o \"When the index was pointing to the deleted node, which was\n                                                // not the last item in the collection, the index position is not\n                                                // changed and the index of inner repeats is re-initialized.\"\n\n                                                newIndex = currentIndex;\n                                                reinitializeInner = true;\n                                            }\n                                        } else {\n                                            // \"The index should point to the same node\n                                            // after a delete as it did before the delete\"\n\n                                            if (currentIndex < deletionIndexInRepeat) {\n                                                newIndex = currentIndex;\n                                            } else {\n                                                newIndex = currentIndex - 1;\n                                            }\n                                            reinitializeInner = false;\n                                        }\n                                    }\n\n                                    repeatIndexUpdates.put(repeatId, new Integer(newIndex));\n\n                                    // Handle children\n                                    if (reinitializeInner) {\n                                        // First step: set all children indexes to 0\n                                        final List nestedRepeatIds = xformsControls.getCurrentControlsState().getNestedRepeatIds(xformsControls, repeatId);\n                                        if (nestedRepeatIds != null) {\n                                            for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                                final String nestedRepeatId = (String) j.next();\n                                                repeatIndexUpdates.put(nestedRepeatId, new Integer(0));\n                                                nestedRepeatIndexUpdates.put(nestedRepeatId, \"\");\n                                            }\n                                        }\n                                    }\n\n                                    foundControl = controlInfo;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            public void endVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    if (foundControl == controlInfo)\n                        foundControl = null;\n                }\n            }\n        });\n    }","id":47179,"modified_method":"/**\n     * Adjust indexes after a deletion.\n     *\n     * @param pipelineContext\n     * @param xformsControls\n     * @param previousRepeatIdToIndex\n     * @param repeatIndexUpdates\n     * @param nestedRepeatIndexUpdates\n     * @param elementToRemove\n     */\n    public static void adjustIndexesForDelete(PipelineContext pipelineContext, final XFormsControls xformsControls,\n                                              final Map previousRepeatIdToIndex, final Map repeatIndexUpdates,\n                                              final Map nestedRepeatIndexUpdates, final Element elementToRemove) {\n\n        // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n        xformsControls.getCurrentControlsState().visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n            private ControlInfo foundControl;\n            private boolean reinitializeInner;\n\n            public void startVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    // Found an xforms:repeat\n                    final RepeatControlInfo repeatControlInfo = (RepeatControlInfo) controlInfo;\n                    final String repeatId = repeatControlInfo.getOriginalId();\n\n                    final List repeatNodeSet = xformsControls.getCurrentNodeset();\n                    if (foundControl == null) {\n                        // We are not yet inside a matching xforms:repeat\n\n                        if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                            // Find whether one node of the repeat node-set contains the inserted node\n                            for (Iterator i = repeatNodeSet.iterator(); i.hasNext();) {\n                                final Element currentNode = (Element) i.next();\n                                if (currentNode == elementToRemove) {\n                                    // Found xforms:repeat affected by the change\n\n                                    final int newIndex;\n                                    if (repeatNodeSet.size() == 1) {\n                                        // Delete the last element of the collection: the index must be set to 0\n                                        newIndex = 0;\n                                        reinitializeInner = false;\n                                    } else {\n                                        // Current index for this repeat\n                                        final int currentIndex = ((Integer) previousRepeatIdToIndex.get(repeatId)).intValue();\n\n                                        // Index of deleted element for this repeat\n                                        final int deletionIndexInRepeat = repeatNodeSet.indexOf(elementToRemove) + 1;\n\n                                        if (currentIndex == deletionIndexInRepeat) {\n                                            if (deletionIndexInRepeat == repeatNodeSet.size()) {\n\n                                                // o \"When the last remaining item in the collection is removed,\n                                                // the index position becomes 0.\"\n\n                                                // o \"When the index was pointing to the deleted node, which was\n                                                // the last item in the collection, the index will point to the new\n                                                // last node of the collection and the index of inner repeats is\n                                                // reinitialized.\"\n\n                                                newIndex = currentIndex - 1;\n                                                reinitializeInner = true;\n                                            } else {\n                                                // o \"When the index was pointing to the deleted node, which was\n                                                // not the last item in the collection, the index position is not\n                                                // changed and the index of inner repeats is re-initialized.\"\n\n                                                newIndex = currentIndex;\n                                                reinitializeInner = true;\n                                            }\n                                        } else {\n                                            // \"The index should point to the same node\n                                            // after a delete as it did before the delete\"\n\n                                            if (currentIndex < deletionIndexInRepeat) {\n                                                newIndex = currentIndex;\n                                            } else {\n                                                newIndex = currentIndex - 1;\n                                            }\n                                            reinitializeInner = false;\n                                        }\n                                    }\n\n                                    repeatIndexUpdates.put(repeatId, new Integer(newIndex));\n\n                                    // Handle children\n                                    if (reinitializeInner) {\n                                        // First step: set all children indexes to 0\n                                        final List nestedRepeatIds = xformsControls.getCurrentControlsState().getNestedRepeatIds(xformsControls, repeatId);\n                                        if (nestedRepeatIds != null) {\n                                            for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                                final String nestedRepeatId = (String) j.next();\n                                                repeatIndexUpdates.put(nestedRepeatId, new Integer(0));\n                                                nestedRepeatIndexUpdates.put(nestedRepeatId, \"\");\n                                            }\n                                        }\n                                    }\n\n                                    foundControl = controlInfo;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            public void endVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    if (foundControl == controlInfo)\n                        foundControl = null;\n                }\n            }\n        });\n    }","commit_id":"6e843632c529709328c82fadc6112034124692f3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Adjust repeat indexes after an insertion.\n     *\n     * @param pipelineContext\n     * @param xformsControls\n     * @param currentControlsState\n     * @param clonedElement\n     */\n    public static void ajustIndexesAfterRepeat(PipelineContext pipelineContext, final XFormsControls xformsControls,\n                                               final XFormsControls.ControlsState currentControlsState, final Element clonedElement) {\n\n        // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n        currentControlsState.visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n            private ControlInfo foundControl;\n\n            public void startVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    // Found an xforms:repeat\n                    final RepeatControlInfo repeatControlInfo = (RepeatControlInfo) controlInfo;\n                    final String repeatId = repeatControlInfo.getOriginalId();\n                    final List repeatNodeSet = xformsControls.getCurrentNodeset();\n\n                    if (foundControl == null) {\n                        // We are not yet inside a matching xforms:repeat\n\n                        if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                            // Find whether one node of the repeat node-set contains the inserted node\n                            int index = 1;\n                            for (Iterator i = repeatNodeSet.iterator(); i.hasNext(); index++) {\n                                final Element currentNode = (Element) i.next();\n                                if (currentNode == clonedElement) {\n                                    // Found xforms:repeat affected by the change\n\n                                    // \"The index for any repeating sequence that is bound\n                                    // to the homogeneous collection where the node was\n                                    // added is updated to point to the newly added node.\"\n                                    currentControlsState.updateRepeatIndex(repeatId, index);\n\n                                    // First step: set all children indexes to 0\n                                    final List nestedRepeatIds = currentControlsState.getNestedRepeatIds(xformsControls, repeatId);\n                                    if (nestedRepeatIds != null) {\n                                        for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                            final String nestedRepeatId = (String) j.next();\n                                            currentControlsState.updateRepeatIndex(nestedRepeatId, 0);\n                                        }\n                                    }\n\n                                    foundControl = controlInfo;\n                                    break;\n                                }\n                            }\n\n                            if (foundControl == null) {\n                                // Still not found a control. Make sure the bounds of this\n                                // xforms:repeat are correct for the rest of the visit.\n\n                                final int adjustedNewIndex;\n                                {\n                                    final int newIndex = ((Integer) currentControlsState.getRepeatIdToIndex().get(repeatId)).intValue();\n\n                                    // Adjust bounds if necessary\n                                    if (newIndex < 1)\n                                        adjustedNewIndex = 1;\n                                    else if (newIndex > repeatNodeSet.size())\n                                        adjustedNewIndex = repeatNodeSet.size();\n                                    else\n                                        adjustedNewIndex = newIndex;\n                                }\n\n                                // Set index\n                                currentControlsState.updateRepeatIndex(repeatId, adjustedNewIndex);\n                            }\n\n                        } else {\n                            // Make sure the index is set to zero when the node-set is empty\n                            currentControlsState.updateRepeatIndex(repeatId, 0);\n                        }\n                    } else {\n                        // This is a child xforms:repeat of a matching xforms:repeat\n                        // Second step: update non-empty repeat indexes to the appropriate value\n\n                        // \"The indexes for inner nested repeat collections are re-initialized to startindex.\"\n\n                        // NOTE: We do this, but we also adjust the index:\n                        // \"The index for this repeating structure is initialized to the\n                        // value of startindex. If the initial startindex is less than 1 it\n                        // defaults to 1. If the index is greater than the initial node-set\n                        // then it defaults to the size of the node-set.\"\n\n                        if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                            int newIndex = repeatControlInfo.getStartIndex();\n\n                            if (newIndex < 1)\n                                newIndex = 1;\n                            if (newIndex > repeatNodeSet.size())\n                                newIndex = repeatNodeSet.size();\n\n                            currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                        } else {\n                            // Make sure the index is set to zero when the node-set is empty\n                            // (although this should already have been done above by the\n                            // enclosing xforms:repeat)\n                            currentControlsState.updateRepeatIndex(repeatId, 0);\n                        }\n                    }\n                }\n            }\n\n            public void endVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    if (foundControl == controlInfo)\n                        foundControl = null;\n                }\n            }\n        });\n    }","id":47180,"modified_method":"/**\n     * Adjust repeat indexes after an insertion.\n     *\n     * @param pipelineContext\n     * @param xformsControls\n     * @param currentControlsState\n     * @param clonedElement\n     */\n    public static void ajustIndexesAfterInsert(PipelineContext pipelineContext, final XFormsControls xformsControls,\n                                               final XFormsControls.ControlsState currentControlsState, final Element clonedElement) {\n\n        // NOTE: The code below assumes that there are no nested repeats bound to node-sets that intersect\n        currentControlsState.visitControlInfoFollowRepeats(pipelineContext, xformsControls, new XFormsControls.ControlInfoVisitorListener() {\n\n            private ControlInfo foundControl;\n\n            public void startVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    // Found an xforms:repeat\n                    final RepeatControlInfo repeatControlInfo = (RepeatControlInfo) controlInfo;\n                    final String repeatId = repeatControlInfo.getOriginalId();\n                    final List repeatNodeSet = xformsControls.getCurrentNodeset();\n\n                    if (foundControl == null) {\n                        // We are not yet inside a matching xforms:repeat\n\n                        if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                            // Find whether one node of the repeat node-set contains the inserted node\n                            int index = 1;\n                            for (Iterator i = repeatNodeSet.iterator(); i.hasNext(); index++) {\n                                final Element currentNode = (Element) i.next();\n                                if (currentNode == clonedElement) {\n                                    // Found xforms:repeat affected by the change\n\n                                    // \"The index for any repeating sequence that is bound\n                                    // to the homogeneous collection where the node was\n                                    // added is updated to point to the newly added node.\"\n                                    currentControlsState.updateRepeatIndex(repeatId, index);\n\n                                    // First step: set all children indexes to 0\n                                    final List nestedRepeatIds = currentControlsState.getNestedRepeatIds(xformsControls, repeatId);\n                                    if (nestedRepeatIds != null) {\n                                        for (Iterator j = nestedRepeatIds.iterator(); j.hasNext();) {\n                                            final String nestedRepeatId = (String) j.next();\n                                            currentControlsState.updateRepeatIndex(nestedRepeatId, 0);\n                                        }\n                                    }\n\n                                    foundControl = controlInfo;\n                                    break;\n                                }\n                            }\n\n                            if (foundControl == null) {\n                                // Still not found a control. Make sure the bounds of this\n                                // xforms:repeat are correct for the rest of the visit.\n\n                                final int adjustedNewIndex;\n                                {\n                                    final int newIndex = ((Integer) currentControlsState.getRepeatIdToIndex().get(repeatId)).intValue();\n\n                                    // Adjust bounds if necessary\n                                    if (newIndex < 1)\n                                        adjustedNewIndex = 1;\n                                    else if (newIndex > repeatNodeSet.size())\n                                        adjustedNewIndex = repeatNodeSet.size();\n                                    else\n                                        adjustedNewIndex = newIndex;\n                                }\n\n                                // Set index\n                                currentControlsState.updateRepeatIndex(repeatId, adjustedNewIndex);\n                            }\n\n                        } else {\n                            // Make sure the index is set to zero when the node-set is empty\n                            currentControlsState.updateRepeatIndex(repeatId, 0);\n                        }\n                    } else {\n                        // This is a child xforms:repeat of a matching xforms:repeat\n                        // Second step: update non-empty repeat indexes to the appropriate value\n\n                        // \"The indexes for inner nested repeat collections are re-initialized to startindex.\"\n\n                        // NOTE: We do this, but we also adjust the index:\n                        // \"The index for this repeating structure is initialized to the\n                        // value of startindex. If the initial startindex is less than 1 it\n                        // defaults to 1. If the index is greater than the initial node-set\n                        // then it defaults to the size of the node-set.\"\n\n                        if (repeatNodeSet != null && repeatNodeSet.size() > 0) {\n                            int newIndex = repeatControlInfo.getStartIndex();\n\n                            if (newIndex < 1)\n                                newIndex = 1;\n                            if (newIndex > repeatNodeSet.size())\n                                newIndex = repeatNodeSet.size();\n\n                            currentControlsState.updateRepeatIndex(repeatId, newIndex);\n                        } else {\n                            // Make sure the index is set to zero when the node-set is empty\n                            // (although this should already have been done above by the\n                            // enclosing xforms:repeat)\n                            currentControlsState.updateRepeatIndex(repeatId, 0);\n                        }\n                    }\n                }\n            }\n\n            public void endVisitControl(ControlInfo controlInfo) {\n                if (controlInfo instanceof RepeatControlInfo) {\n                    if (foundControl == controlInfo)\n                        foundControl = null;\n                }\n            }\n        });\n    }","commit_id":"6e843632c529709328c82fadc6112034124692f3","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void interpretEvent(final PipelineContext pipelineContext, XFormsEvent xformsEvent) {\n        final String eventName = xformsEvent.getEventName();\n        if (XFormsEvents.XFORMS_DOM_ACTIVATE.equals(eventName)\n            || XFormsEvents.XFORMS_DOM_FOCUS_OUT.equals(eventName)\n            || XFormsEvents.XFORMS_DOM_FOCUS_IN.equals(eventName)\n            || XFormsEvents.XFORMS_VALUE_CHANGED.equals(eventName)) { // TODO: check if xforms-value-changed is actually ever sent by client\n\n            // These are events we allow directly from the client and actually handle\n\n            dispatchEvent(pipelineContext, xformsEvent);\n\n        } else if (XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE.equals(eventName)) {\n            // 4.6.7 Sequence: Value Change\n\n            // What we want to do here is set the value on the initial controls state, as the value\n            // has already been changed on the client. This means that this event(s) must be the\n            // first to come!\n\n            final XXFormsValueChangeWithFocusChangeEvent concreteEvent = (XXFormsValueChangeWithFocusChangeEvent) xformsEvent;\n\n            // 1. xforms-recalculate\n            // 2. xforms-revalidate\n            // 3. xforms-refresh performs reevaluation of UI binding expressions then dispatches\n            // these events according to value changes, model item property changes and validity\n            // changes\n            // [n] xforms-value-changed, [n] xforms-valid or xforms-invalid, [n] xforms-enabled or\n            // xforms-disabled, [n] xforms-optional or xforms-required, [n] xforms-readonly or\n            // xforms-readwrite, [n] xforms-out-of-range or xforms-in-range\n\n            {\n                // Set current context to control\n                final XFormsControls.ControlInfo valueControlInfo = (XFormsControls.ControlInfo) concreteEvent.getTargetObject();\n                xformsControls.setBinding(pipelineContext, valueControlInfo);\n\n                // Set value into the instance\n                XFormsInstance.setValueForNode(pipelineContext, xformsControls.getCurrentSingleNode(), concreteEvent.getNewValue(), null);\n\n                // Update this particular control's value\n                valueControlInfo.evaluateValue(pipelineContext);\n                valueControlInfo.evaluateDisplayValue(pipelineContext);\n            }\n\n            // Make sure controls are not in the initial state before sending events\n            xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n            // Recalculate and revalidate\n            final XFormsModel model = xformsControls.getCurrentModel();\n            dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n            dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n            // Handle focus change DOMFocusOut / DOMFocusIn\n            if (concreteEvent.getOtherTargetObject() != null) {\n                // We have a focus change (otherwise, the focus is assumed to remain the same)\n                dispatchEvent(pipelineContext, new XFormsDOMFocusOutEvent(concreteEvent.getTargetObject()));\n                dispatchEvent(pipelineContext, new XFormsDOMFocusInEvent(concreteEvent.getOtherTargetObject()));\n            }\n\n            // Refresh (this will send update events)\n            dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n\n        } else if (XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // Internal submission event\n            dispatchEvent(pipelineContext, xformsEvent);\n\n        } else if (XFormsEvents.XXFORMS_LOAD.equals(eventName)) {\n            // Internal load event\n            dispatchEvent(pipelineContext, xformsEvent);\n        } else {\n            throw new OXFException(\"Invalid event dispatched by client: \" + eventName);\n        }\n    }","id":47181,"modified_method":"private void interpretEvent(final PipelineContext pipelineContext, XFormsEvent xformsEvent) {\n        final String eventName = xformsEvent.getEventName();\n        if (XFormsEvents.XFORMS_DOM_ACTIVATE.equals(eventName)\n            || XFormsEvents.XFORMS_DOM_FOCUS_OUT.equals(eventName)\n            || XFormsEvents.XFORMS_DOM_FOCUS_IN.equals(eventName)\n            || XFormsEvents.XFORMS_VALUE_CHANGED.equals(eventName)) { // TODO: check if xforms-value-changed is actually ever sent by client\n\n            // These are events we allow directly from the client and actually handle\n\n            dispatchEvent(pipelineContext, xformsEvent);\n\n        } else if (XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE.equals(eventName)) {\n            // 4.6.7 Sequence: Value Change\n\n            // What we want to do here is set the value on the initial controls state, as the value\n            // has already been changed on the client. This means that this event(s) must be the\n            // first to come!\n\n            final XXFormsValueChangeWithFocusChangeEvent concreteEvent = (XXFormsValueChangeWithFocusChangeEvent) xformsEvent;\n\n            // 1. xforms-recalculate\n            // 2. xforms-revalidate\n            // 3. xforms-refresh performs reevaluation of UI binding expressions then dispatches\n            // these events according to value changes, model item property changes and validity\n            // changes\n            // [n] xforms-value-changed, [n] xforms-valid or xforms-invalid, [n] xforms-enabled or\n            // xforms-disabled, [n] xforms-optional or xforms-required, [n] xforms-readonly or\n            // xforms-readwrite, [n] xforms-out-of-range or xforms-in-range\n\n            {\n                // Set current context to control\n                final XFormsControls.ControlInfo valueControlInfo = (XFormsControls.ControlInfo) concreteEvent.getTargetObject();\n                xformsControls.setBinding(pipelineContext, valueControlInfo);\n\n                // Set value into the instance\n                XFormsInstance.setValueForNode(pipelineContext, xformsControls.getCurrentSingleNode(), concreteEvent.getNewValue(), null);\n\n                // Update this particular control's value\n                valueControlInfo.evaluateValue(pipelineContext);\n                valueControlInfo.evaluateDisplayValue(pipelineContext);\n            }\n\n            // Make sure controls are not in the initial state before sending events\n            xformsControls.rebuildCurrentControlsState(pipelineContext);\n\n            {\n                // Reset current context to control (necessary after rebuild)\n                final XFormsControls.ControlInfo valueControlInfo\n                        = (XFormsControls.ControlInfo) getObjectById(pipelineContext,\n                                ((XFormsControls.ControlInfo) concreteEvent.getTargetObject()).getId());\n                xformsControls.setBinding(pipelineContext, valueControlInfo);\n\n                // Recalculate and revalidate\n                final XFormsModel model = xformsControls.getCurrentModel();\n                dispatchEvent(pipelineContext, new XFormsRecalculateEvent(model, true));\n                dispatchEvent(pipelineContext, new XFormsRevalidateEvent(model, true));\n\n                // Handle focus change DOMFocusOut / DOMFocusIn\n                if (concreteEvent.getOtherTargetObject() != null) {\n\n                    final XFormsControls.ControlInfo otherTargetControlInfo\n                        = (XFormsControls.ControlInfo) getObjectById(pipelineContext,\n                                ((XFormsControls.ControlInfo) concreteEvent.getOtherTargetObject()).getId());\n\n                    // We have a focus change (otherwise, the focus is assumed to remain the same)\n                    dispatchEvent(pipelineContext, new XFormsDOMFocusOutEvent(valueControlInfo));\n                    dispatchEvent(pipelineContext, new XFormsDOMFocusInEvent(otherTargetControlInfo));\n                }\n\n                // Refresh (this will send update events)\n                dispatchEvent(pipelineContext, new XFormsRefreshEvent(model));\n            }\n\n        } else if (XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // Internal submission event\n            dispatchEvent(pipelineContext, xformsEvent);\n\n        } else if (XFormsEvents.XXFORMS_LOAD.equals(eventName)) {\n            // Internal load event\n            dispatchEvent(pipelineContext, xformsEvent);\n        } else {\n            throw new OXFException(\"Invalid event dispatched by client: \" + eventName);\n        }\n    }","commit_id":"2592bcb5c3808ac8bad4139369e527f75ad3d56e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void doIt(final PipelineContext pipelineContext, ContentHandler contentHandler) {\n\n        final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n        final Element filesElement;\n        final Element actionElement;\n        final XFormsContainingDocument containingDocument;\n        final XFormsState xformsState;\n        final String requestPageGenerationId;\n\n        // Use request input provided by client\n        final Document requestDocument = readInputAsDOM4J(pipelineContext, INPUT_REQUEST);\n\n        // Get action\n        actionElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_ACTION_QNAME);\n\n        // Get files if any (those come from xforms-server-submit.xpl upon submission)\n        filesElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_FILES_QNAME);\n\n        // Retrieve state\n        {\n            // Get static state\n            final String staticStateString;\n            {\n                final Element staticStateElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_STATIC_STATE_QNAME);\n                staticStateString = staticStateElement.getTextTrim();\n            }\n\n            // Get dynamic state\n            final String dynamicStateString;\n            {\n                final Element dynamicStateElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_DYNAMIC_STATE_QNAME);\n                dynamicStateString = dynamicStateElement.getTextTrim();\n            }\n\n            if (dynamicStateString.startsWith(SESSION_STATE_PREFIX)) {\n                // State doesn't come with the request, we should look it up in the repository\n                final String requestId = dynamicStateString.substring(SESSION_STATE_PREFIX.length());\n\n                // Extract page generation id\n                requestPageGenerationId = staticStateString.substring(SESSION_STATE_PREFIX.length());\n\n                // We don't create the cache at this point as it may not be necessary\n                final XFormsServerSessionCache sessionCache = XFormsServerSessionCache.instance(externalContext.getSession(false), false);\n                final XFormsState sessionFormsState = (sessionCache == null) ? null : sessionCache.find(requestPageGenerationId, requestId);\n\n                // This is not going to be good when it happens, and we must create a caching heuristic that minimizes this\n                if (sessionFormsState == null)\n                    throw new OXFException(\"Unable to retrieve XForms engine state.\");\n\n                xformsState = sessionFormsState;\n            } else {\n                // State comes with request\n                requestPageGenerationId = null;\n                xformsState = new XFormsState(staticStateString, dynamicStateString);\n            }\n        }\n\n        if (XFormsUtils.isCacheDocument()) {\n            // Try to obtain containing document from cache\n            if (filesElement == null) {\n                // No fileElements, this may have been cached\n                containingDocument = XFormsServerDocumentCache.instance().find(pipelineContext, xformsState);\n            } else  {\n                // If there are filesElement, then we know this was not cached\n                logger.debug(\"XForms - containing document cache (getContainingDocument): fileElements present.\");\n                containingDocument = createXFormsContainingDocument(pipelineContext, xformsState, filesElement);\n            }\n        } else {\n            // Otherwise we recreate the containindg document from scratch\n            containingDocument = createXFormsContainingDocument(pipelineContext, xformsState, filesElement);\n        }\n\n\n        try {\n            // Run event if any\n            boolean allEvents = false;\n            final Map valueChangeControlIds = new HashMap();\n            if (actionElement != null) {\n                final List eventElements = actionElement.elements(XFormsConstants.XXFORMS_EVENT_QNAME);\n                if (eventElements != null && eventElements.size() > 0) {\n                    // NOTE: We store here the last xxforms-value-change-with-focus-change event so\n                    // we can coalesce values in case several such events are sent for the same\n                    // control. The client should not send us such series of events, but currently\n                    // it may happen.\n                    String lastSourceControlId = null;\n                    String lastValueChangeEventValue = null;\n                    for (Iterator i = eventElements.iterator(); i.hasNext();) {\n                        final Element eventElement = (Element) i.next();\n                        final String sourceControlId = eventElement.attributeValue(\"source-control-id\");\n                        final String otherControlId = eventElement.attributeValue(\"other-control-id\");\n                        final String eventName = eventElement.attributeValue(\"name\");\n                        final String value = eventElement.getText();\n\n                        if (XFormsEvents.XXFORMS_ALL_EVENTS_REQUIRED.equals(eventName)) {\n                            // Special event telling us to resend the client all the events since initialization\n                            allEvents = true;\n                        } else if (sourceControlId != null && eventName != null) {\n                            // An event is passed\n                            if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE) && otherControlId == null) {\n                                // xxforms-value-change-with-focus-change event\n                                if (lastSourceControlId == null) {\n                                    // Rember event\n                                    lastSourceControlId = sourceControlId;\n                                    lastValueChangeEventValue = value;\n                                } else if (lastSourceControlId.equals(sourceControlId)) {\n                                    // Update event\n                                    lastValueChangeEventValue = value;\n                                } else {\n                                    // Send old event\n                                    containingDocument.executeExternalEvent(pipelineContext, XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE, lastSourceControlId, null, lastValueChangeEventValue, null);\n                                    // Remember new event\n                                    lastSourceControlId = sourceControlId;\n                                    lastValueChangeEventValue = value;\n                                }\n                                // Remember id of control of which value changed\n                                valueChangeControlIds.put(sourceControlId, \"\");\n                            } else {\n                                if (lastSourceControlId != null) {\n                                    // Send old event\n                                    containingDocument.executeExternalEvent(pipelineContext, XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE, lastSourceControlId, null, lastValueChangeEventValue, null);\n                                    lastSourceControlId = null;\n                                    lastValueChangeEventValue = null;\n                                }\n                                // Send new event\n                                containingDocument.executeExternalEvent(pipelineContext, eventName, sourceControlId, otherControlId, value, null);\n                            }\n                        } else if (!(sourceControlId == null && eventName == null)) {\n                            throw new OXFException(\"<event> element must either have source-control-id and name attributes, or no attribute.\");\n                        }\n                    }\n                    // Flush stored event if needed\n                    if (lastSourceControlId != null) {\n                        // Send old event\n                        containingDocument.executeExternalEvent(pipelineContext, XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE, lastSourceControlId, null, lastValueChangeEventValue, null);\n                    }\n                }\n            }\n\n            // Create resulting document if there is a ContentHandler\n            if (contentHandler != null) {\n                outputResponse(containingDocument, allEvents, valueChangeControlIds, pipelineContext, contentHandler, requestPageGenerationId, externalContext, xformsState);\n            }\n        } catch (Throwable e) {\n            // If an exception is caught, we need to discard the object as its state may be inconsistent\n            final ObjectPool sourceObjectPool = containingDocument.getSourceObjectPool();\n            if (sourceObjectPool != null) {\n                logger.debug(\"XForms - containing document cache: throwable caught, discarding document from pool.\");\n                try {\n                    sourceObjectPool.invalidateObject(containingDocument);\n                    containingDocument.setSourceObjectPool(null);\n                } catch (Exception e1) {\n                    throw new OXFException(e1);\n                }\n            }\n            throw new OXFException(e);\n        }\n    }","id":47182,"modified_method":"private void doIt(final PipelineContext pipelineContext, ContentHandler contentHandler) {\n\n        final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n        final Element filesElement;\n        final Element actionElement;\n        final XFormsContainingDocument containingDocument;\n        final XFormsState xformsState;\n        final String requestPageGenerationId;\n\n        // Use request input provided by client\n        final Document requestDocument = readInputAsDOM4J(pipelineContext, INPUT_REQUEST);\n\n        // Get action\n        actionElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_ACTION_QNAME);\n\n        // Get files if any (those come from xforms-server-submit.xpl upon submission)\n        filesElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_FILES_QNAME);\n\n        // Retrieve state\n        {\n            // Get static state\n            final String staticStateString;\n            {\n                final Element staticStateElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_STATIC_STATE_QNAME);\n                staticStateString = staticStateElement.getTextTrim();\n            }\n\n            // Get dynamic state\n            final String dynamicStateString;\n            {\n                final Element dynamicStateElement = requestDocument.getRootElement().element(XFormsConstants.XXFORMS_DYNAMIC_STATE_QNAME);\n                dynamicStateString = dynamicStateElement.getTextTrim();\n            }\n\n            if (dynamicStateString.startsWith(SESSION_STATE_PREFIX)) {\n                // State doesn't come with the request, we should look it up in the repository\n                final String requestId = dynamicStateString.substring(SESSION_STATE_PREFIX.length());\n\n                // Extract page generation id\n                requestPageGenerationId = staticStateString.substring(SESSION_STATE_PREFIX.length());\n\n                // We don't create the cache at this point as it may not be necessary\n                final XFormsServerSessionCache sessionCache = XFormsServerSessionCache.instance(externalContext.getSession(false), false);\n                final XFormsState sessionFormsState = (sessionCache == null) ? null : sessionCache.find(requestPageGenerationId, requestId);\n\n                // This is not going to be good when it happens, and we must create a caching heuristic that minimizes this\n                if (sessionFormsState == null)\n                    throw new OXFException(\"Unable to retrieve XForms engine state.\");\n\n                xformsState = sessionFormsState;\n            } else {\n                // State comes with request\n                requestPageGenerationId = null;\n                xformsState = new XFormsState(staticStateString, dynamicStateString);\n            }\n        }\n\n        if (XFormsUtils.isCacheDocument()) {\n            // Try to obtain containing document from cache\n            if (filesElement == null) {\n                // No fileElements, this may have been cached\n                containingDocument = XFormsServerDocumentCache.instance().find(pipelineContext, xformsState);\n            } else  {\n                // If there are filesElement, then we know this was not cached\n                logger.debug(\"XForms - containing document cache (getContainingDocument): fileElements present.\");\n                containingDocument = createXFormsContainingDocument(pipelineContext, xformsState, filesElement);\n            }\n        } else {\n            // Otherwise we recreate the containindg document from scratch\n            containingDocument = createXFormsContainingDocument(pipelineContext, xformsState, filesElement);\n        }\n\n\n        try {\n            // Run event if any\n            boolean allEvents = false;\n            final Map valueChangeControlIds = new HashMap();\n            if (actionElement != null) {\n                final List eventElements = actionElement.elements(XFormsConstants.XXFORMS_EVENT_QNAME);\n                if (eventElements != null && eventElements.size() > 0) {\n                    // NOTE: We store here the last xxforms-value-change-with-focus-change event so\n                    // we can coalesce values in case several such events are sent for the same\n                    // control. The client should not send us such series of events, but currently\n                    // it may happen.\n                    String lastSourceControlId = null;\n                    String lastValueChangeEventValue = null;\n                    for (Iterator i = eventElements.iterator(); i.hasNext();) {\n                        final Element eventElement = (Element) i.next();\n                        final String sourceControlId = eventElement.attributeValue(\"source-control-id\");\n                        final String otherControlId = eventElement.attributeValue(\"other-control-id\");\n                        final String eventName = eventElement.attributeValue(\"name\");\n                        final String value = eventElement.getText();\n\n                        if (XFormsEvents.XXFORMS_ALL_EVENTS_REQUIRED.equals(eventName)) {\n                            // Special event telling us to resend the client all the events since initialization\n                            allEvents = true;\n                        } else if (sourceControlId != null && eventName != null) {\n                            // An event is passed\n                            if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE) && otherControlId == null) {\n                                // xxforms-value-change-with-focus-change event\n                                if (lastSourceControlId == null) {\n                                    // Rember event\n                                    lastSourceControlId = sourceControlId;\n                                    lastValueChangeEventValue = value;\n                                } else if (lastSourceControlId.equals(sourceControlId)) {\n                                    // Update event\n                                    lastValueChangeEventValue = value;\n                                } else {\n                                    // Send old event\n                                    containingDocument.executeExternalEvent(pipelineContext, XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE, lastSourceControlId, null, lastValueChangeEventValue, null);\n                                    // Remember new event\n                                    lastSourceControlId = sourceControlId;\n                                    lastValueChangeEventValue = value;\n                                }\n                            } else {\n                                if (lastSourceControlId != null) {\n                                    // Send old event\n                                    containingDocument.executeExternalEvent(pipelineContext, XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE, lastSourceControlId, null, lastValueChangeEventValue, null);\n                                    lastSourceControlId = null;\n                                    lastValueChangeEventValue = null;\n                                }\n                                // Send new event\n                                containingDocument.executeExternalEvent(pipelineContext, eventName, sourceControlId, otherControlId, value, null);\n                            }\n\n                            if (eventName.equals(XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE)) {\n                                // Remember id of control of which value changed\n                                valueChangeControlIds.put(sourceControlId, \"\");\n                            }\n                        } else if (!(sourceControlId == null && eventName == null)) {\n                            throw new OXFException(\"<event> element must either have source-control-id and name attributes, or no attribute.\");\n                        }\n                    }\n                    // Flush stored event if needed\n                    if (lastSourceControlId != null) {\n                        // Send old event\n                        containingDocument.executeExternalEvent(pipelineContext, XFormsEvents.XXFORMS_VALUE_CHANGE_WITH_FOCUS_CHANGE, lastSourceControlId, null, lastValueChangeEventValue, null);\n                    }\n                }\n            }\n\n            // Create resulting document if there is a ContentHandler\n            if (contentHandler != null) {\n                outputResponse(containingDocument, allEvents, valueChangeControlIds, pipelineContext, contentHandler, requestPageGenerationId, externalContext, xformsState);\n            }\n        } catch (Throwable e) {\n            // If an exception is caught, we need to discard the object as its state may be inconsistent\n            final ObjectPool sourceObjectPool = containingDocument.getSourceObjectPool();\n            if (sourceObjectPool != null) {\n                logger.debug(\"XForms - containing document cache: throwable caught, discarding document from pool.\");\n                try {\n                    sourceObjectPool.invalidateObject(containingDocument);\n                    containingDocument.setSourceObjectPool(null);\n                } catch (Exception e1) {\n                    throw new OXFException(e1);\n                }\n            }\n            throw new OXFException(e);\n        }\n    }","commit_id":"2592bcb5c3808ac8bad4139369e527f75ad3d56e","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Nullable\n  private static PsiElement resolveChild(final PsiElement parent, final String referencedName, final PyReferenceExpression importRef) {\n    if (parent instanceof PyFile) {\n      return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), parent, null, importRef);\n    }\n    else if (parent instanceof PsiDirectory) {\n      final PsiDirectory dir = (PsiDirectory)parent;\n      final PsiFile file = dir.findFile(referencedName + \".py\");\n      if (file != null) return file;\n      return dir.findSubdirectory(referencedName);\n    }\n    else {\n      return null;\n    }\n  }","id":47183,"modified_method":"@Nullable\n  private static PsiElement resolveChild(final PsiElement parent, final String referencedName, final PyReferenceExpression importRef) {\n    if (parent instanceof PyFile) {\n      return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), parent, null, importRef);\n    }\n    else if (parent instanceof PsiDirectory) {\n      final PsiDirectory dir = (PsiDirectory)parent;\n      final PsiFile file = dir.findFile(referencedName + \".py\");\n      if (file != null) return file;\n      final PsiDirectory subdir = dir.findSubdirectory(referencedName);\n      if (subdir != null) return subdir;\n      final PsiFile initPy = dir.findFile(\"__init__.py\");\n      if (initPy != null) {\n        return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), initPy, null, importRef);\n      }\n    }\n    return null;\n  }","commit_id":"3c4dd8905f46f3d1184bda7c650d2d573ce9c1ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiDirectory getTemplatesDirectory(PsiElement element) {\n    PsiDirectory directory = element.getContainingFile().getContainingDirectory();\n    return directory.findSubdirectory(FlaskNames.TEMPLATES);\n  }","id":47184,"modified_method":"@Nullable\n  public static PsiDirectory getTemplatesDirectory(PsiElement element) {\n    PsiDirectory directory = element.getContainingFile().getContainingDirectory();\n    return directory == null ? null : directory.findSubdirectory(FlaskNames.TEMPLATES);\n  }","commit_id":"b3cc0dc6fe32756cfb92857f360554bf7625513d","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  protected PsiElementVisitor createFileSearcher() {\n    final FileIndex fileIndex = getFileIndex();\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.setText(AnalysisScopeBundle.message(\"scanning.scope.progress.title\"));\n    }\n\n    return new PsiElementVisitor() {\n      @Override\n      public void visitFile(@NotNull PsiFile file) {\n        if (mySearchInLibraries || !(file instanceof PsiCompiledElement)) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile == null) return;\n          if (isFiltered(virtualFile, fileIndex)) {\n            return;\n          }\n          if (!shouldHighlightFile(file)) return;\n          myFilesSet.add(virtualFile);\n        }\n      }\n    };\n  }","id":47185,"modified_method":"@NotNull\n  protected PsiElementVisitor createFileSearcher() {\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      indicator.setText(AnalysisScopeBundle.message(\"scanning.scope.progress.title\"));\n    }\n\n    return new PsiElementVisitor() {\n      @Override\n      public void visitFile(@NotNull PsiFile file) {\n        if (mySearchInLibraries || !(file instanceof PsiCompiledElement)) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile == null) return;\n          if (isFiltered(virtualFile)) {\n            return;\n          }\n          if (!shouldHighlightFile(file)) return;\n          myFilesSet.add(virtualFile);\n        }\n      }\n    };\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean contains(@NotNull VirtualFile file) {\n    if (myFilesSet == null) {\n      if (myType == CUSTOM) {\n        // optimization\n        if (myScope instanceof GlobalSearchScope) return ((GlobalSearchScope)myScope).contains(file);\n        if (myScope instanceof LocalSearchScope) return ((LocalSearchScope)myScope).isInScope(file);\n      }\n      if (myType == PROJECT) {  //optimization\n        final ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n        return index.isInContent(file) && !isFiltered(file, index);\n      }\n      initFilesSet();\n    }\n\n    return myFilesSet.contains(file);\n  }","id":47186,"modified_method":"public boolean contains(@NotNull VirtualFile file) {\n    if (myFilesSet == null) {\n      if (myType == CUSTOM) {\n        // optimization\n        if (myScope instanceof GlobalSearchScope) return ((GlobalSearchScope)myScope).contains(file);\n        if (myScope instanceof LocalSearchScope) return ((LocalSearchScope)myScope).isInScope(file);\n      }\n      if (myType == PROJECT) {  //optimization\n        final ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n        return index.isInContent(file) && !isFiltered(file);\n      }\n      initFilesSet();\n    }\n\n    return myFilesSet.contains(file);\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void accept(@NotNull final PsiElementVisitor visitor, final boolean clearResolveCache) {\n    final boolean needReadAction = !ApplicationManager.getApplication().isReadAccessAllowed();\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    final FileIndex fileIndex = getFileIndex();\n    accept(file -> {\n      if (file.isDirectory()) return true;\n      if (ProjectCoreUtil.isProjectOrWorkspaceFile(file)) return true;\n      if (fileIndex.isInContent(file) && !isFiltered(file, fileIndex)\n          && !GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(file, myProject)) {\n        return processFile(file, visitor, psiManager, needReadAction, clearResolveCache);\n      }\n      return true;\n    });\n  }","id":47187,"modified_method":"private void accept(@NotNull final PsiElementVisitor visitor, final boolean clearResolveCache) {\n    final boolean needReadAction = !ApplicationManager.getApplication().isReadAccessAllowed();\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    final FileIndex fileIndex = getFileIndex();\n    accept(file -> {\n      if (file.isDirectory()) return true;\n      if (ProjectCoreUtil.isProjectOrWorkspaceFile(file)) return true;\n      if (fileIndex.isInContent(file) && !isFiltered(file)\n          && !GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(file, myProject)) {\n        return processFile(file, visitor, psiManager, needReadAction, clearResolveCache);\n      }\n      return true;\n    });\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean accept(@NotNull final Processor<VirtualFile> processor) {\n    if (myType == VIRTUAL_FILES) {\n      if (myFilesSet == null) initFilesSet();\n      final FileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n      for (final VirtualFile file : myFilesSet) {\n        if (isFiltered(file, index)) continue;\n        if (!processor.process(file)) return false;\n      }\n      return true;\n    }\n    final FileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    if (myScope instanceof GlobalSearchScope) {\n      final ContentIterator contentIterator = createScopeIterator(processor, projectFileIndex, myScope);\n      if (!projectFileIndex.iterateContent(contentIterator)) return false;\n      if (mySearchInLibraries) {\n        final VirtualFile[] libraryRoots = LibraryUtil.getLibraryRoots(myProject, false, false);\n        for (VirtualFile libraryRoot : libraryRoots) {\n          if (!VfsUtilCore.iterateChildrenRecursively(libraryRoot, VirtualFileFilter.ALL, contentIterator)) return false;\n        }\n      }\n      return true;\n    }\n    if (myScope instanceof LocalSearchScope) {\n      final PsiElement[] psiElements = ((LocalSearchScope)myScope).getScope();\n      final Set<VirtualFile> files = new THashSet<VirtualFile>();\n      for (final PsiElement element : psiElements) {\n        VirtualFile file = ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n          @Override\n          public VirtualFile compute() {\n            return PsiUtilCore.getVirtualFile(element);\n          }\n        });\n        if (file != null && files.add(file)) {\n          if (!processor.process(file)) return false;\n        }\n      }\n      return true;\n    }\n    List<Module> modules = myModule != null ? Collections.singletonList(myModule) : myModules;\n    if (modules != null) {\n      for (final Module module : modules) {\n        final FileIndex moduleFileIndex = ModuleRootManager.getInstance(module).getFileIndex();\n        if (!moduleFileIndex.iterateContent(createScopeIterator(processor, moduleFileIndex, null))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    if (myElement instanceof PsiDirectory) {\n      return accept((PsiDirectory)myElement, processor);\n    }\n    if (myElement != null) {\n      VirtualFile file = ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n        @Override\n        public VirtualFile compute() {\n          return PsiUtilCore.getVirtualFile(myElement);\n        }\n      });\n      return file == null || processor.process(file);\n    }\n\n    return projectFileIndex.iterateContent(createScopeIterator(processor, projectFileIndex, null));\n  }","id":47188,"modified_method":"public boolean accept(@NotNull final Processor<VirtualFile> processor) {\n    if (myType == VIRTUAL_FILES) {\n      if (myFilesSet == null) initFilesSet();\n      for (final VirtualFile file : myFilesSet) {\n        if (isFiltered(file)) continue;\n        if (!processor.process(file)) return false;\n      }\n      return true;\n    }\n    final FileIndex projectFileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    if (myScope instanceof GlobalSearchScope) {\n      final ContentIterator contentIterator = createScopeIterator(processor, myScope);\n      if (!projectFileIndex.iterateContent(contentIterator)) return false;\n      if (mySearchInLibraries) {\n        final VirtualFile[] libraryRoots = LibraryUtil.getLibraryRoots(myProject, false, false);\n        for (VirtualFile libraryRoot : libraryRoots) {\n          if (!VfsUtilCore.iterateChildrenRecursively(libraryRoot, VirtualFileFilter.ALL, contentIterator)) return false;\n        }\n      }\n      return true;\n    }\n    if (myScope instanceof LocalSearchScope) {\n      final PsiElement[] psiElements = ((LocalSearchScope)myScope).getScope();\n      final Set<VirtualFile> files = new THashSet<VirtualFile>();\n      for (final PsiElement element : psiElements) {\n        VirtualFile file = ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n          @Override\n          public VirtualFile compute() {\n            return PsiUtilCore.getVirtualFile(element);\n          }\n        });\n        if (file != null && files.add(file)) {\n          if (!processor.process(file)) return false;\n        }\n      }\n      return true;\n    }\n    List<Module> modules = myModule != null ? Collections.singletonList(myModule) : myModules;\n    if (modules != null) {\n      for (final Module module : modules) {\n        final FileIndex moduleFileIndex = ModuleRootManager.getInstance(module).getFileIndex();\n        if (!moduleFileIndex.iterateContent(createScopeIterator(processor, null))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    if (myElement instanceof PsiDirectory) {\n      return accept((PsiDirectory)myElement, processor);\n    }\n    if (myElement != null) {\n      VirtualFile file = ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n        @Override\n        public VirtualFile compute() {\n          return PsiUtilCore.getVirtualFile(myElement);\n        }\n      });\n      return file == null || processor.process(file);\n    }\n\n    return projectFileIndex.iterateContent(createScopeIterator(processor, null));\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean accept(@NotNull final PsiDirectory dir, @NotNull final Processor<VirtualFile> processor) {\n    final Project project = dir.getProject();\n    final ProjectFileIndex index = ProjectRootManager.getInstance(project).getFileIndex();\n    //we should analyze generated source files only if the action is explicitly invoked for a directory located under generated roots\n    final boolean processGeneratedFiles = GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(dir.getVirtualFile(), project);\n    return VfsUtilCore.iterateChildrenRecursively(dir.getVirtualFile(), VirtualFileFilter.ALL, new ContentIterator() {\n      @Override\n      @SuppressWarnings({\"SimplifiableIfStatement\"})\n      public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n        if (isFiltered(fileOrDir, index)) return true;\n        if (!processGeneratedFiles && GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(fileOrDir, project)) return true;\n        if (!fileOrDir.isDirectory()) {\n          return processor.process(fileOrDir);\n        }\n        return true;\n      }\n    });\n  }","id":47189,"modified_method":"protected boolean accept(@NotNull final PsiDirectory dir, @NotNull final Processor<VirtualFile> processor) {\n    final Project project = dir.getProject();\n    //we should analyze generated source files only if the action is explicitly invoked for a directory located under generated roots\n    final boolean processGeneratedFiles = GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(dir.getVirtualFile(), project);\n    return VfsUtilCore.iterateChildrenRecursively(dir.getVirtualFile(), VirtualFileFilter.ALL, new ContentIterator() {\n      @Override\n      @SuppressWarnings({\"SimplifiableIfStatement\"})\n      public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n        if (isFiltered(fileOrDir)) return true;\n        if (!processGeneratedFiles && GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(fileOrDir, project)) return true;\n        if (!fileOrDir.isDirectory()) {\n          return processor.process(fileOrDir);\n        }\n        return true;\n      }\n    });\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private ContentIterator createScopeIterator(@NotNull final Processor<VirtualFile> processor,\n                                              @NotNull final FileIndex projectFileIndex,\n                                              @Nullable final SearchScope searchScope) {\n    return new ContentIterator() {\n        @Override\n        public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n          final boolean isInScope = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n            @Override\n            public Boolean compute() {\n              if (isFiltered(fileOrDir, projectFileIndex)) return false;\n              if (GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(fileOrDir, myProject)) return false;\n              return searchScope == null || ((GlobalSearchScope)searchScope).contains(fileOrDir);\n            }\n          }).booleanValue();\n          return !isInScope || processor.process(fileOrDir);\n        }\n      };\n  }","id":47190,"modified_method":"@NotNull\n  private ContentIterator createScopeIterator(@NotNull final Processor<VirtualFile> processor, \n                                              @Nullable final SearchScope searchScope) {\n    return new ContentIterator() {\n        @Override\n        public boolean processFile(@NotNull final VirtualFile fileOrDir) {\n          final boolean isInScope = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n            @Override\n            public Boolean compute() {\n              if (isFiltered(fileOrDir)) return false;\n              if (GeneratedSourcesFilter.isGeneratedSourceByAnyFilter(fileOrDir, myProject)) return false;\n              return searchScope == null || ((GlobalSearchScope)searchScope).contains(fileOrDir);\n            }\n          }).booleanValue();\n          return !isInScope || processor.process(fileOrDir);\n        }\n      };\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isFiltered(VirtualFile virtualFile, FileIndex fileIndex) {\n    if (myFilter != null && !myFilter.contains(virtualFile)) {\n      return true;\n    }\n    return !myIncludeTestSource && TestSourcesFilter.isTestSources(virtualFile, myProject);\n  }","id":47191,"modified_method":"private boolean isFiltered(VirtualFile virtualFile) {\n    if (myFilter != null && !myFilter.contains(virtualFile)) {\n      return true;\n    }\n    return !myIncludeTestSource && TestSourcesFilter.isTestSources(virtualFile, myProject);\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void analyze() {\n    AnalysisScope scope = myForwardScope;\n    final DependenciesBuilder builder = new ForwardDependenciesBuilder(getProject(), scope, getScopeOfInterest());\n    builder.setTotalFileCount(myTotalFileCount);\n    builder.analyze();\n\n    subtractScope(builder, getScope());\n    final PsiManager psiManager = PsiManager.getInstance(getProject());\n    psiManager.startBatchFilesProcessingMode();\n    try {\n      final int fileCount = getScope().getFileCount();\n      final boolean includeTestSource = getScope().isIncludeTestSource();\n      getScope().accept(virtualFile -> {\n        if (!includeTestSource && TestSourcesFilter.isTestSources(virtualFile, getProject())) {\n          return true;\n        }\n        ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n        if (indicator != null) {\n          if (indicator.isCanceled()) {\n            throw new ProcessCanceledException();\n          }\n          indicator.setText(AnalysisScopeBundle.message(\"package.dependencies.progress.text\"));\n          indicator.setText2(getRelativeToProjectPath(virtualFile));\n          if (fileCount > 0) {\n            indicator.setFraction(((double)++myFileCount) / myTotalFileCount);\n          }\n        }\n        ApplicationManager.getApplication().runReadAction(() -> {\n          PsiFile file = psiManager.findFile(virtualFile);\n          if (file != null) {\n            final PsiElement navigationElement = file.getNavigationElement();\n            if (navigationElement instanceof PsiFile) {\n              file = (PsiFile)navigationElement;\n            }\n            final Map<PsiFile, Set<PsiFile>> dependencies = builder.getDependencies();\n            for (final PsiFile psiFile : dependencies.keySet()) {\n              if (dependencies.get(psiFile).contains(file)) {\n                Set<PsiFile> fileDeps = getDependencies().get(file);\n                if (fileDeps == null) {\n                  fileDeps = new HashSet<PsiFile>();\n                  getDependencies().put(file, fileDeps);\n                }\n                fileDeps.add(psiFile);\n              }\n            }\n            psiManager.dropResolveCaches();\n          }\n        });\n        return true;\n      });\n    }\n    finally {\n      psiManager.finishBatchFilesProcessingMode();\n    }\n  }","id":47192,"modified_method":"@Override\n  public void analyze() {\n    final DependenciesBuilder builder = new ForwardDependenciesBuilder(getProject(), myForwardScope, getScopeOfInterest());\n    builder.setTotalFileCount(myTotalFileCount);\n    builder.analyze();\n\n    subtractScope(builder, getScope());\n    final PsiManager psiManager = PsiManager.getInstance(getProject());\n    psiManager.startBatchFilesProcessingMode();\n    try {\n      final int fileCount = getScope().getFileCount();\n      final boolean includeTestSource = getScope().isIncludeTestSource();\n      getScope().accept(virtualFile -> {\n        if (!includeTestSource && TestSourcesFilter.isTestSources(virtualFile, getProject())) {\n          return true;\n        }\n        ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n        if (indicator != null) {\n          if (indicator.isCanceled()) {\n            throw new ProcessCanceledException();\n          }\n          indicator.setText(AnalysisScopeBundle.message(\"package.dependencies.progress.text\"));\n          indicator.setText2(getRelativeToProjectPath(virtualFile));\n          if (fileCount > 0) {\n            indicator.setFraction(((double)++myFileCount) / myTotalFileCount);\n          }\n        }\n        ApplicationManager.getApplication().runReadAction(() -> {\n          PsiFile file = psiManager.findFile(virtualFile);\n          if (file != null) {\n            final PsiElement navigationElement = file.getNavigationElement();\n            if (navigationElement instanceof PsiFile) {\n              file = (PsiFile)navigationElement;\n            }\n            final Map<PsiFile, Set<PsiFile>> dependencies = builder.getDependencies();\n            for (final PsiFile psiFile : dependencies.keySet()) {\n              if (dependencies.get(psiFile).contains(file)) {\n                Set<PsiFile> fileDeps = getDependencies().get(file);\n                if (fileDeps == null) {\n                  fileDeps = new HashSet<PsiFile>();\n                  getDependencies().put(file, fileDeps);\n                }\n                fileDeps.add(psiFile);\n              }\n            }\n            psiManager.dropResolveCaches();\n          }\n        });\n        return true;\n      });\n    }\n    finally {\n      psiManager.finishBatchFilesProcessingMode();\n    }\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiDirectory findOrCreateDirectoryForPackage(@NotNull final Project project,\n                                                             @Nullable Module module,\n                                                             GlobalSearchScope scope,\n                                                             String packageName,\n                                                             PsiDirectory baseDir,\n                                                             boolean askUserToCreate,\n                                                             ThreeState chooseFlag) throws IncorrectOperationException {\n    PsiDirectory psiDirectory = null;\n    if (chooseFlag == ThreeState.UNSURE && !\"\".equals(packageName)) {\n      String rootPackage = findLongestExistingPackage(project, packageName, scope);\n      if (rootPackage != null) {\n        int beginIndex = rootPackage.length() + 1;\n        packageName = beginIndex < packageName.length() ? packageName.substring(beginIndex) : \"\";\n        String postfixToShow = packageName.replace('.', File.separatorChar);\n        if (packageName.length() > 0) {\n          postfixToShow = File.separatorChar + postfixToShow;\n        }\n        psiDirectory =\n          DirectoryChooserUtil.selectDirectory(project, getPackageDirectories(project, rootPackage, scope), baseDir, postfixToShow);\n        if (psiDirectory == null) return null;\n      }\n    }\n\n    if (psiDirectory == null) {\n      if (chooseFlag == ThreeState.NO && baseDir != null) {\n        VirtualFile sourceRoot = ProjectRootManager.getInstance(project).getFileIndex().getSourceRootForFile(baseDir.getVirtualFile());\n        psiDirectory = PsiManager.getInstance(project).findDirectory(sourceRoot);\n      }\n      else {\n        if (module != null && !checkSourceRootsConfigured(module)) return null;\n        final GlobalSearchScope scope_ = scope;\n        List<PsiDirectory> dirs =\n          ContainerUtil\n            .mapNotNull(ProjectRootManager.getInstance(project).getContentSourceRoots(),\n                        virtualFile -> scope_.contains(virtualFile) ? PsiManager.getInstance(project).findDirectory(virtualFile) : null);\n        psiDirectory = DirectoryChooserUtil.selectDirectory(project, dirs.toArray(new PsiDirectory[dirs.size()]), baseDir,\n                                                            File.separatorChar + packageName.replace('.', File.separatorChar));\n        if (psiDirectory == null) return null;\n        final VirtualFile sourceRoot = ProjectRootManager.getInstance(project).getFileIndex().getSourceRootForFile(psiDirectory.getVirtualFile());\n        psiDirectory = PsiManager.getInstance(project).findDirectory(sourceRoot);\n      }\n    }\n\n    String restOfName = packageName;\n    boolean askedToCreate = false;\n    while (restOfName.length() > 0) {\n      final String name = getLeftPart(restOfName);\n      PsiDirectory foundExistingDirectory = psiDirectory.findSubdirectory(name);\n      if (foundExistingDirectory == null) {\n        if (!askedToCreate && askUserToCreate) {\n          if (!ApplicationManager.getApplication().isUnitTestMode()) {\n            int toCreate = Messages.showYesNoDialog(project,\n                                                    IdeBundle.message(\"prompt.create.non.existing.package\", packageName),\n                                                    IdeBundle.message(\"title.package.not.found\"),\n                                                    Messages.getQuestionIcon());\n            if (toCreate != Messages.YES) {\n              return null;\n            }\n          }\n          askedToCreate = true;\n        }\n\n        final PsiDirectory psiDirectory_ = psiDirectory;\n        try {\n          psiDirectory = ActionRunner.runInsideWriteAction(new ActionRunner.InterruptibleRunnableWithResult<PsiDirectory>() {\n            @Override\n            public PsiDirectory run() throws Exception {\n              return psiDirectory_.createSubdirectory(name);\n            }\n          });\n        }\n        catch (IncorrectOperationException e) {\n          throw e;\n        }\n        catch (IOException e) {\n          throw new IncorrectOperationException(e);\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n      }\n      else {\n        psiDirectory = foundExistingDirectory;\n      }\n      restOfName = cutLeftPart(restOfName);\n    }\n    return psiDirectory;\n  }","id":47193,"modified_method":"@Nullable\n  public static PsiDirectory findOrCreateDirectoryForPackage(@NotNull final Project project,\n                                                             @Nullable Module module,\n                                                             GlobalSearchScope scope,\n                                                             String packageName,\n                                                             PsiDirectory baseDir,\n                                                             boolean askUserToCreate,\n                                                             ThreeState chooseFlag) throws IncorrectOperationException {\n    PsiDirectory psiDirectory = null;\n    if (chooseFlag == ThreeState.UNSURE && StringUtil.isNotEmpty(packageName)) {\n      String rootPackage = findLongestExistingPackage(project, packageName, scope);\n      if (rootPackage != null) {\n        int beginIndex = rootPackage.length() + 1;\n        packageName = beginIndex < packageName.length() ? packageName.substring(beginIndex) : \"\";\n        String postfixToShow = packageName.replace('.', File.separatorChar);\n        if (packageName.length() > 0) {\n          postfixToShow = File.separatorChar + postfixToShow;\n        }\n        psiDirectory =\n          DirectoryChooserUtil.selectDirectory(project, getPackageDirectories(project, rootPackage, scope), baseDir, postfixToShow);\n        if (psiDirectory == null) return null;\n      }\n    }\n\n    if (psiDirectory == null) {\n      if (chooseFlag == ThreeState.NO && baseDir != null) {\n        VirtualFile sourceRoot = ProjectRootManager.getInstance(project).getFileIndex().getSourceRootForFile(baseDir.getVirtualFile());\n        psiDirectory = sourceRoot != null ? PsiManager.getInstance(project).findDirectory(sourceRoot) : null;\n      }\n      else {\n        if (module != null && !checkSourceRootsConfigured(module)) return null;\n        final GlobalSearchScope scope_ = scope;\n        List<PsiDirectory> dirs =\n          ContainerUtil\n            .mapNotNull(ProjectRootManager.getInstance(project).getContentSourceRoots(),\n                        virtualFile -> scope_.contains(virtualFile) ? PsiManager.getInstance(project).findDirectory(virtualFile) : null);\n        psiDirectory = DirectoryChooserUtil.selectDirectory(project, dirs.toArray(new PsiDirectory[dirs.size()]), baseDir,\n                                                            File.separatorChar + packageName.replace('.', File.separatorChar));\n        if (psiDirectory == null) return null;\n        final VirtualFile sourceRoot = ProjectRootManager.getInstance(project).getFileIndex().getSourceRootForFile(psiDirectory.getVirtualFile());\n        psiDirectory = sourceRoot != null ? PsiManager.getInstance(project).findDirectory(sourceRoot) : null;\n      }\n    }\n\n    String restOfName = packageName;\n    boolean askedToCreate = false;\n    while (restOfName.length() > 0) {\n      final String name = getLeftPart(restOfName);\n      PsiDirectory foundExistingDirectory = psiDirectory != null ? psiDirectory.findSubdirectory(name) : null;\n      if (foundExistingDirectory == null) {\n        if (!askedToCreate && askUserToCreate) {\n          if (!ApplicationManager.getApplication().isUnitTestMode()) {\n            int toCreate = Messages.showYesNoDialog(project,\n                                                    IdeBundle.message(\"prompt.create.non.existing.package\", packageName),\n                                                    IdeBundle.message(\"title.package.not.found\"),\n                                                    Messages.getQuestionIcon());\n            if (toCreate != Messages.YES) {\n              return null;\n            }\n          }\n          askedToCreate = true;\n        }\n\n        final PsiDirectory psiDirectory_ = psiDirectory;\n        try {\n          psiDirectory = ActionRunner.runInsideWriteAction(new ActionRunner.InterruptibleRunnableWithResult<PsiDirectory>() {\n            @Override\n            public PsiDirectory run() throws Exception {\n              return psiDirectory_ != null ? psiDirectory_.createSubdirectory(name) : null;\n            }\n          });\n        }\n        catch (IncorrectOperationException e) {\n          throw e;\n        }\n        catch (IOException e) {\n          throw new IncorrectOperationException(e);\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n      }\n      else {\n        psiDirectory = foundExistingDirectory;\n      }\n      restOfName = cutLeftPart(restOfName);\n    }\n    return psiDirectory;\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiDirectory[] getPackageDirectories(Project project, String rootPackage, final GlobalSearchScope scope) {\n    final PsiManager manager = PsiManager.getInstance(project);\n\n    Query<VirtualFile> query = DirectoryIndex.getInstance(scope.getProject()).getDirectoriesByPackageName(rootPackage, true);\n    query = new FilteredQuery<VirtualFile>(query, virtualFile -> scope.contains(virtualFile));\n\n    List<PsiDirectory> directories = ContainerUtil.mapNotNull(query.findAll(), virtualFile -> manager.findDirectory(virtualFile));\n    return directories.toArray(new PsiDirectory[directories.size()]);\n  }","id":47194,"modified_method":"private static PsiDirectory[] getPackageDirectories(Project project, String rootPackage, final GlobalSearchScope scope) {\n    final PsiManager manager = PsiManager.getInstance(project);\n\n    Query<VirtualFile> query = DirectoryIndex.getInstance(scope.getProject()).getDirectoriesByPackageName(rootPackage, true);\n    query = new FilteredQuery<VirtualFile>(query, scope::contains);\n\n    List<PsiDirectory> directories = ContainerUtil.mapNotNull(query.findAll(), manager::findDirectory);\n    return directories.toArray(new PsiDirectory[directories.size()]);\n  }","commit_id":"715fd9c8a2034077c0aed806cd74a735fce27ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void set_unique_flag(CollectionSchema field, SolrInputDocument sid, SolrDocument d) {\n        Object sb = sid.getFieldValue(field.getSolrFieldName());\n        boolean sbb = sb != null && ((Boolean) sb).booleanValue();\n        Object ob = d == null ? null : d.getFieldValue(field.getSolrFieldName());\n        boolean obb = ob != null && ((Boolean) ob).booleanValue();\n        if (sbb == obb) sid.setField(field.getSolrFieldName(), !sbb);\n    }","id":47195,"modified_method":"private void set_unique_flag(CollectionSchema field, final SolrDocument doc, final SolrInputDocument sid, final SolrDocument d) {\n        Object sb = doc.getFieldValue(field.getSolrFieldName());\n        boolean sbb = sb != null && ((Boolean) sb).booleanValue();\n        Object ob = d == null ? null : d.getFieldValue(field.getSolrFieldName());\n        boolean obb = ob != null && ((Boolean) ob).booleanValue();\n        if (sbb == obb) sid.setField(field.getSolrFieldName(), !sbb);\n    }","commit_id":"2e09da9832145f49261800c437c31bd8e5af6cb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void postprocessing_www_unique(Segment segment, SolrInputDocument sid, DigestURL url) {\n        if (!this.contains(CollectionSchema.www_unique_b)) return;\n        final String us = url.urlstub(true, true);\n        try {\n            DigestURL u = new DigestURL(url.getProtocol() + (us.startsWith(\"www.\") ? \"://\" + us.substring(4) : \"://www.\" + us));\n            SolrDocument d = segment.fulltext().getDefaultConnector().getDocumentById(ASCII.String(u.hash()), CollectionSchema.www_unique_b.getSolrFieldName());\n            set_unique_flag(CollectionSchema.www_unique_b, sid, d);\n        } catch (final IOException e) {}\n    }","id":47196,"modified_method":"public void postprocessing_www_unique(final Segment segment, final SolrDocument doc, final SolrInputDocument sid, final DigestURL url) {\n        if (!this.contains(CollectionSchema.www_unique_b)) return;\n        final String us = url.urlstub(true, true);\n        try {\n            DigestURL u = new DigestURL(url.getProtocol() + (us.startsWith(\"www.\") ? \"://\" + us.substring(4) : \"://www.\" + us));\n            SolrDocument d = segment.fulltext().getDefaultConnector().getDocumentById(ASCII.String(u.hash()), CollectionSchema.www_unique_b.getSolrFieldName());\n            set_unique_flag(CollectionSchema.www_unique_b, doc, sid, d);\n        } catch (final IOException e) {}\n    }","commit_id":"2e09da9832145f49261800c437c31bd8e5af6cb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * post-processing steps for all entries that have a process tag assigned\n     * @param connector\n     * @param urlCitation\n     * @return\n     */\n    public int postprocessing(final Segment segment, final ReferenceReportCache rrCache, final String harvestkey) {\n        if (!this.contains(CollectionSchema.process_sxt)) return 0;\n        if (!segment.connectedCitation() && !segment.fulltext().useWebgraph()) return 0;\n        final SolrConnector collectionConnector = segment.fulltext().getDefaultConnector();\n        collectionConnector.commit(false); // make sure that we have latest information that can be found\n        if (segment.fulltext().useWebgraph()) segment.fulltext().getWebgraphConnector().commit(false);\n        final CollectionConfiguration collection = segment.fulltext().getDefaultConfiguration();\n        final WebgraphConfiguration webgraph = segment.fulltext().getWebgraphConfiguration();\n        \n        // calculate the number of documents to be processed\n        String collection1query = collection1query(segment, harvestkey);\n        String webgraphquery = webgraphquery(segment, harvestkey);\n        postprocessingRunning = true;\n        postprocessingStartTime = System.currentTimeMillis();\n        postprocessingActivity = \"collecting counts\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        try {\n            postprocessingCollection1Count = (int) collectionConnector.getCountByQuery(collection1query);\n            postprocessingWebgraphCount = segment.fulltext().useWebgraph() ? (int) segment.fulltext().getWebgraphConnector().getCountByQuery(webgraphquery) : 0;\n        } catch (IOException e) {\n            postprocessingCollection1Count = -1;\n            postprocessingWebgraphCount = -1;\n        }\n        \n        // collect hosts from index which shall take part in citation computation\n        postprocessingActivity = \"collecting host facets for collection\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        ReversibleScoreMap<String> collection1hosts;\n        try {\n            Map<String, ReversibleScoreMap<String>> hostfacet = collectionConnector.getFacets(collection1query, 10000000, CollectionSchema.host_s.getSolrFieldName());\n            collection1hosts = hostfacet.get(CollectionSchema.host_s.getSolrFieldName());\n        } catch (final IOException e2) {\n            ConcurrentLog.logException(e2);\n            collection1hosts = new ClusteredScoreMap<String>();\n        }\n\n        postprocessingActivity = \"create ranking map\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        boolean shallComputeCR = (segment.fulltext().useWebgraph() &&\n                ((webgraph.contains(WebgraphSchema.source_id_s) && webgraph.contains(WebgraphSchema.source_cr_host_norm_i)) ||\n                        (webgraph.contains(WebgraphSchema.target_id_s) && webgraph.contains(WebgraphSchema.target_cr_host_norm_i))) ||\n                      (collection.contains(CollectionSchema.cr_host_count_i) &&\n                       collection.contains(CollectionSchema.cr_host_chance_d) &&\n                       collection.contains(CollectionSchema.cr_host_norm_i)));\n        // create the ranking map\n        final Map<String, CRV> rankings = new ConcurrentHashMap<String, CRV>();\n        if (shallComputeCR) try {\n            int concurrency = Math.min(collection1hosts.size(), Runtime.getRuntime().availableProcessors());\n            postprocessingActivity = \"collecting cr for \" + collection1hosts.size() + \" hosts, concurrency = \" + concurrency;\n            ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n            int countcheck = 0;\n            for (String host: collection1hosts.keyList(true)) {\n                // Patch the citation index for links with canonical tags.\n                // This shall fulfill the following requirement:\n                // If a document A links to B and B contains a 'canonical C', then the citation rank computation shall consider that A links to C and B does not link to C.\n                // To do so, we first must collect all canonical links, find all references to them, get the anchor list of the documents and patch the citation reference of these links\n                String patchquery = CollectionSchema.host_s.getSolrFieldName() + \":\" + host + \" AND \" + CollectionSchema.canonical_s.getSolrFieldName() + AbstractSolrConnector.CATCHALL_DTERM;\n                long patchquerycount = collectionConnector.getCountByQuery(patchquery);\n                BlockingQueue<SolrDocument> documents_with_canonical_tag = collectionConnector.concurrentDocumentsByQuery(patchquery, CollectionSchema.url_chars_i.getSolrFieldName() + \" asc\", 0, 100000000, Long.MAX_VALUE, 20, 1, true,\n                        CollectionSchema.id.getSolrFieldName(), CollectionSchema.sku.getSolrFieldName(), CollectionSchema.canonical_s.getSolrFieldName());\n                SolrDocument doc_B;\n                int patchquerycountcheck = 0;\n                try {\n                    while ((doc_B = documents_with_canonical_tag.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                        // find all documents which link to the canonical doc\n                        DigestURL doc_C_url = new DigestURL((String) doc_B.getFieldValue(CollectionSchema.canonical_s.getSolrFieldName()));\n                        byte[] doc_B_id = ASCII.getBytes(((String) doc_B.getFieldValue(CollectionSchema.id.getSolrFieldName())));\n                        // we remove all references to B, because these become references to C\n                        if (segment.connectedCitation()) {\n                            ReferenceContainer<CitationReference> doc_A_ids = segment.urlCitation().remove(doc_B_id);\n                            if (doc_A_ids == null) {\n                                //System.out.println(\"*** document with canonical but no referrer: \" + doc_B.getFieldValue(CollectionSchema.sku.getSolrFieldName()));\n                                continue; // the document has a canonical tag but no referrer?\n                            }\n                            Iterator<CitationReference> doc_A_ids_iterator = doc_A_ids.entries();\n                            // for each of the referrer A of B, set A as a referrer of C\n                            while (doc_A_ids_iterator.hasNext()) {\n                                CitationReference doc_A_citation = doc_A_ids_iterator.next();\n                                segment.urlCitation().add(doc_C_url.hash(), doc_A_citation);\n                            }\n                        }\n                        patchquerycountcheck++;\n                        if (MemoryControl.shortStatus()) {\n                            ConcurrentLog.warn(\"CollectionConfiguration\", \"terminated canonical collection during postprocessing because of short memory\");\n                            break;\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    ConcurrentLog.logException(e);\n                } catch (SpaceExceededException e) {\n                    ConcurrentLog.logException(e);\n                }\n                if (patchquerycount != patchquerycountcheck) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous patchquery count for host \" + host + \": expected=\" + patchquerycount + \", counted=\" + patchquerycountcheck);\n                \n                // do the citation rank computation\n                if (collection1hosts.get(host) <= 0) continue;\n                // select all documents for each host\n                CRHost crh = new CRHost(segment, rrCache, host, 0.85d, 6);\n                int convergence_attempts = 0;\n                while (convergence_attempts++ < 30) {\n                    ConcurrentLog.info(\"CollectionConfiguration\", \"convergence step \" + convergence_attempts + \" for host \" + host + \" ...\");\n                    if (crh.convergenceStep()) break;\n                    if (MemoryControl.shortStatus()) {\n                        ConcurrentLog.warn(\"CollectionConfiguration\", \"terminated convergenceStep during postprocessing because of short memory\");\n                        break;\n                    }\n                }\n                ConcurrentLog.info(\"CollectionConfiguration\", \"convergence for host \" + host + \" after \" + convergence_attempts + \" steps\");\n                // we have now the cr for all documents of a specific host; we store them for later use\n                Map<String, CRV> crn = crh.normalize();\n                //crh.log(crn);\n                rankings.putAll(crn); // accumulate this here for usage in document update later\n                if (MemoryControl.shortStatus()) {\n                    ConcurrentLog.warn(\"CollectionConfiguration\", \"terminated crn akkumulation during postprocessing because of short memory\");\n                    break;\n                }\n                countcheck++;\n            }\n            if (collection1hosts.size() != countcheck) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous host count: expected=\" + collection1hosts.size() + \", counted=\" + countcheck);\n        } catch (final IOException e2) {\n            ConcurrentLog.logException(e2);\n            collection1hosts = new ClusteredScoreMap<String>();\n        }\n        \n        // process all documents at the webgraph for the outgoing links of this document\n        final AtomicInteger allcount = new AtomicInteger(0);\n        if (segment.fulltext().useWebgraph() && shallComputeCR) {\n            postprocessingActivity = \"collecting host facets for webgraph cr calculation\";\n            ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n            final Set<String> omitFields = new HashSet<String>();\n            omitFields.add(WebgraphSchema.process_sxt.getSolrFieldName());\n            omitFields.add(WebgraphSchema.harvestkey_s.getSolrFieldName());\n            \n            // collect hosts from index which shall take part in citation computation\n            ReversibleScoreMap<String> webgraphhosts;\n            try {\n                Map<String, ReversibleScoreMap<String>> hostfacet = segment.fulltext().getWebgraphConnector().getFacets(webgraphquery, 10000000, WebgraphSchema.source_host_s.getSolrFieldName());\n                webgraphhosts = hostfacet.get(WebgraphSchema.source_host_s.getSolrFieldName());\n            } catch (final IOException e2) {\n                ConcurrentLog.logException(e2);\n                webgraphhosts = new ClusteredScoreMap<String>();\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                for (String host: webgraphhosts.keyList(true)) {\n                    if (webgraphhosts.get(host) <= 0) continue;\n                    final String hostfinal = host;\n                    // select all webgraph edges and modify their cr value\n                    postprocessingActivity = \"writing cr values to webgraph for host \" + host;\n                    ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n                    String patchquery = WebgraphSchema.source_host_s.getSolrFieldName() + \":\\\"\" + host + \"\\\" AND \" + WebgraphSchema.process_sxt.getSolrFieldName() + AbstractSolrConnector.CATCHALL_DTERM;\n                    final long count = segment.fulltext().getWebgraphConnector().getCountByQuery(patchquery);\n                    int concurrency = Math.min((int) count, Math.max(1, Runtime.getRuntime().availableProcessors() / 4));\n                    ConcurrentLog.info(\"CollectionConfiguration\", \"collecting \" + count + \" documents from the webgraph, concurrency = \" + concurrency);\n                    final BlockingQueue<SolrDocument> docs = segment.fulltext().getWebgraphConnector().concurrentDocumentsByQuery(\n                            patchquery,\n                            WebgraphSchema.source_chars_i.getSolrFieldName() + \" asc\",\n                            0, 100000000, Long.MAX_VALUE, concurrency + 1, concurrency, true\n                            // TODO: add field list and do partial updates\n                            );\n                    final AtomicInteger proccount = new AtomicInteger(0);\n                    Thread[] t = new Thread[concurrency];\n                    for (final AtomicInteger i = new AtomicInteger(0); i.get() < t.length; i.incrementAndGet()) {\n                        t[i.get()] = new Thread() {\n                            private String name = \"CollectionConfiguration.postprocessing.webgraph-\" + i.get();\n                            @Override\n                            public void run() {\n                                Thread.currentThread().setName(name);\n                                SolrDocument doc; String id;\n                                try {\n                                    processloop: while ((doc = docs.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                                        try {\n                                            SolrInputDocument sid = webgraph.toSolrInputDocument(doc, omitFields);\n                                            Collection<Object> proctags = doc.getFieldValues(WebgraphSchema.process_sxt.getSolrFieldName());\n    \n                                            for (Object tag: proctags) try {\n                                                \n                                                // switch over tag types\n                                                ProcessType tagtype = ProcessType.valueOf((String) tag);\n                                                    \n                                                // set cr values\n                                                if (tagtype == ProcessType.CITATION) {\n                                                    if (segment.fulltext().useWebgraph() && webgraph.contains(WebgraphSchema.source_id_s) && webgraph.contains(WebgraphSchema.source_cr_host_norm_i)) {\n                                                        id = (String) doc.getFieldValue(WebgraphSchema.source_id_s.getSolrFieldName());\n                                                        CRV crv = rankings.get(id);\n                                                        if (crv != null) {\n                                                            sid.setField(WebgraphSchema.source_cr_host_norm_i.getSolrFieldName(), crv.crn);\n                                                        }\n                                                    }\n                                                    if (webgraph.contains(WebgraphSchema.target_id_s) && webgraph.contains(WebgraphSchema.target_cr_host_norm_i)) {\n                                                        id = (String) doc.getFieldValue(WebgraphSchema.target_id_s.getSolrFieldName());\n                                                        CRV crv = rankings.get(id);\n                                                        if (crv != null) {\n                                                            sid.setField(WebgraphSchema.target_cr_host_norm_i.getSolrFieldName(), crv.crn);\n                                                        }\n                                                    }\n                                                }\n                                            } catch (IllegalArgumentException e) {\n                                                ConcurrentLog.logException(e);\n                                            }\n                                            \n                                            // write document back to index\n                                            try {\n                                                sid.removeField(WebgraphSchema.process_sxt.getSolrFieldName());\n                                                sid.removeField(WebgraphSchema.harvestkey_s.getSolrFieldName());\n                                                //segment.fulltext().getWebgraphConnector().deleteById((String) sid.getFieldValue(WebgraphSchema.id.getSolrFieldName()));\n                                                segment.fulltext().getWebgraphConnector().add(sid);\n                                            } catch (SolrException e) {\n                                                ConcurrentLog.logException(e);\n                                            } catch (IOException e) {\n                                                ConcurrentLog.logException(e);\n                                            }\n                                            proccount.incrementAndGet();\n                                            allcount.incrementAndGet();\n                                            if (proccount.get() % 1000 == 0) {\n                                                postprocessingActivity = \"writing cr values to webgraph for host \" + hostfinal + \"postprocessed \" + proccount + \" from \" + count + \" documents; \" +\n                                                    (proccount.get() * 1000 / (System.currentTimeMillis() - start)) + \" docs/second; \" +\n                                                    ((System.currentTimeMillis() - start) * (count - proccount.get()) / proccount.get() / 60000) + \" minutes remaining\";\n                                                ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n                                            }\n                                        } catch (Throwable e) {\n                                            ConcurrentLog.logException(e);\n                                            continue processloop;\n                                        }\n                                    }\n                                } catch (InterruptedException e) {\n                                    ConcurrentLog.warn(\"CollectionConfiguration\", e.getMessage(), e);\n                                }\n                            }\n                        };\n                        t[i.get()].start();\n                    }\n                    for (int i = 0; i < t.length; i++) try {\n                        t[i].join(10000);\n                        if (t[i].isAlive()) t[i].interrupt();\n                    } catch (InterruptedException e) {}\n                    \n                    if (count != proccount.get()) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous webgraph document count for host \" + host + \": expected=\" + count + \", counted=\" + proccount);\n                }\n            } catch (final IOException e2) {\n                ConcurrentLog.warn(\"CollectionConfiguration\", e2.getMessage(), e2);\n            }\n        }\n        \n        // process all documents in collection\n        final Map<String, Long> hostExtentCache = new HashMap<String, Long>(); // a mapping from the host id to the number of documents which contain this host-id\n        final Set<String> uniqueURLs = new ConcurrentHashSet<String>(); // will be used in a concurrent environment\n        try {\n            final Set<String> omitFields = new HashSet<String>();\n            omitFields.add(CollectionSchema.process_sxt.getSolrFieldName());\n            omitFields.add(CollectionSchema.harvestkey_s.getSolrFieldName());\n            final long count = collectionConnector.getCountByQuery(collection1query);\n            final long start = System.currentTimeMillis();\n            final int concurrency = Math.max(1, Math.min((int) (MemoryControl.available() / (100L * 1024L * 1024L)), Runtime.getRuntime().availableProcessors()));\n            //final int concurrency = 1;\n            final boolean reference_computation = this.contains(CollectionSchema.references_i) &&\n                    this.contains(CollectionSchema.references_internal_i) &&\n                    this.contains(CollectionSchema.references_external_i) &&\n                    this.contains(CollectionSchema.references_exthosts_i);\n            postprocessingActivity = \"collecting \" + count + \" documents from the collection for harvestkey \" + harvestkey;\n            ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n            final BlockingQueue<SolrDocument> docs = collectionConnector.concurrentDocumentsByQuery(\n                    collection1query,\n                    (this.contains(CollectionSchema.http_unique_b) || this.contains(CollectionSchema.www_unique_b)) ?\n                    CollectionSchema.host_subdomain_s.getSolrFieldName() + \" asc,\" + // sort on subdomain to get hosts without subdomain first; that gives an opportunity to set www_unique_b flag to false\n                    CollectionSchema.url_protocol_s.getSolrFieldName() + \" asc\" // sort on protocol to get http before https; that gives an opportunity to set http_unique_b flag to false\n                    : null, // null sort is faster!\n                    0, 100000000, Long.MAX_VALUE, concurrency + 1, concurrency, true,\n                    CollectionSchema.id.getSolrFieldName(),\n                    CollectionSchema.sku.getSolrFieldName(),\n                    CollectionSchema.harvestkey_s.getSolrFieldName(),\n                    CollectionSchema.process_sxt.getSolrFieldName(),\n                    CollectionSchema.canonical_equal_sku_b.getSolrFieldName(),\n                    CollectionSchema.canonical_s.getSolrFieldName(),\n                    CollectionSchema.exact_signature_l.getSolrFieldName(),\n                    CollectionSchema.fuzzy_signature_l.getSolrFieldName(),\n                    CollectionSchema.title_exact_signature_l.getSolrFieldName(),\n                    CollectionSchema.description_exact_signature_l.getSolrFieldName(),\n                    CollectionSchema.host_id_s.getSolrFieldName(),\n                    CollectionSchema.host_s.getSolrFieldName(),\n                    CollectionSchema.host_subdomain_s.getSolrFieldName(),\n                    CollectionSchema.url_chars_i.getSolrFieldName(),\n                    CollectionSchema.url_protocol_s.getSolrFieldName(),\n                    CollectionSchema.httpstatus_i.getSolrFieldName(),\n                    CollectionSchema.inboundlinkscount_i.getSolrFieldName(),\n                    CollectionSchema.robots_i.getSolrFieldName());\n            final AtomicInteger proccount = new AtomicInteger();\n            final AtomicInteger proccount_referencechange = new AtomicInteger();\n            final AtomicInteger proccount_citationchange = new AtomicInteger();\n            final AtomicInteger countcheck = new AtomicInteger(0);\n            final Collection<String> failids = new ArrayList<String>();\n            final Thread rewriteThread[] = new Thread[concurrency];\n            for (int rewrite_start = 0; rewrite_start < concurrency; rewrite_start++) {\n                rewriteThread[rewrite_start] = new Thread() {\n                    @Override\n                    public void run() {\n                        SolrDocument doc;\n                        try {\n                            while ((doc = docs.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                                // for each to-be-processed entry work on the process tag\n                                Collection<Object> proctags = doc.getFieldValues(CollectionSchema.process_sxt.getSolrFieldName());\n                                final String u = (String) doc.getFieldValue(CollectionSchema.sku.getSolrFieldName());\n                                final String i = (String) doc.getFieldValue(CollectionSchema.id.getSolrFieldName());\n                                if (proctags == null || proctags.size() == 0) {\n                                    // this should not happen since we collected the documents using a process_sxt:[* TO *] term\n                                    ConcurrentLog.warn(\"CollectionConfiguration\", \"no process_sxt entry for url \" + u + \", id=\" + i);\n                                    continue;\n                                }\n                                try {\n                                    DigestURL url = new DigestURL(u, ASCII.getBytes(i));\n                                    byte[] id = url.hash();\n                                    SolrInputDocument sid = new SolrInputDocument(); //collection.toSolrInputDocument(doc, omitFields);\n                                    sid.setField(CollectionSchema.id.getSolrFieldName(), i);\n                                    for (Object tag: proctags) try {\n                                        \n                                        // switch over tag types\n                                        ProcessType tagtype = ProcessType.valueOf((String) tag);\n    \n                                        if (tagtype == ProcessType.CITATION &&\n                                            collection.contains(CollectionSchema.cr_host_count_i) &&\n                                            collection.contains(CollectionSchema.cr_host_chance_d) &&\n                                            collection.contains(CollectionSchema.cr_host_norm_i)) {\n                                            CRV crv = rankings.remove(ASCII.String(id)); // instead of 'get'ting the CRV, we also remove it because we will not need it again and free some memory here\n                                            if (crv != null) {\n                                                sid.setField(CollectionSchema.cr_host_count_i.getSolrFieldName(), crv.count);\n                                                sid.setField(CollectionSchema.cr_host_chance_d.getSolrFieldName(), crv.cr);\n                                                sid.setField(CollectionSchema.cr_host_norm_i.getSolrFieldName(), crv.crn);\n                                                proccount_citationchange.incrementAndGet();\n                                            }\n                                        }\n    \n                                        if (tagtype == ProcessType.UNIQUE) {\n                                            postprocessing_http_unique(segment, sid, url);\n                                            postprocessing_www_unique(segment, sid, url);\n                                            postprocessing_doublecontent(segment, uniqueURLs, sid, url);\n                                        }\n                                        \n                                    } catch (IllegalArgumentException e) {}\n                                    \n                                    // compute references\n                                    if (reference_computation) {\n                                        String hosthash = url.hosthash();\n                                        if (!hostExtentCache.containsKey(hosthash)) {\n                                            StringBuilder q = new StringBuilder();\n                                            q.append(CollectionSchema.host_id_s.getSolrFieldName()).append(\":\\\"\").append(hosthash).append(\"\\\" AND \").append(CollectionSchema.httpstatus_i.getSolrFieldName()).append(\":200\");\n                                            long hostExtentCount = segment.fulltext().getDefaultConnector().getCountByQuery(q.toString());\n                                            hostExtentCache.put(hosthash, hostExtentCount);\n                                        }\n                                        if (postprocessing_references(rrCache, sid, url, hostExtentCache)) proccount_referencechange.incrementAndGet();\n                                    }\n                                    \n                                    // all processing steps checked, remove the processing and harvesting key\n                                    sid.setField(CollectionSchema.process_sxt.getSolrFieldName(), null); // setting this to null will cause a removal when doing a partial update\n                                    sid.setField(CollectionSchema.harvestkey_s.getSolrFieldName(), null);\n                                    \n                                    // send back to index\n                                    //collectionConnector.deleteById(i);\n                                    collectionConnector.update(sid);\n                                    \n                                    long thiscount = proccount.incrementAndGet(); allcount.incrementAndGet();\n                                    if (thiscount % 100 == 0) {\n                                        postprocessingActivity = \"postprocessed \" + thiscount + \" from \" + count + \" collection documents; \" +\n                                            (thiscount * 60000L / (System.currentTimeMillis() - start)) + \" ppm; \" +\n                                            ((System.currentTimeMillis() - start) * (count - thiscount) / thiscount / 60000) + \" minutes remaining\";\n                                        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n                                    }\n                                } catch (final Throwable e1) {\n                                    ConcurrentLog.logException(e1);\n                                    failids.add(i);\n                                }\n                                countcheck.incrementAndGet();\n                            }\n                        } catch (InterruptedException e) {\n                            ConcurrentLog.logException(e);\n                        }\n                    }\n                };\n                rewriteThread[rewrite_start].start();\n            }\n            // wait for termination\n            for (int rewrite_start = 0; rewrite_start < concurrency; rewrite_start++) rewriteThread[rewrite_start].join();\n            \n            if (failids.size() > 0) {\n                ConcurrentLog.info(\"CollectionConfiguration\", \"cleanup_processing: deleting \" + failids.size() + \" documents which have permanent execution fails\");\n                collectionConnector.deleteByIds(failids);\n            }\n            if (count != countcheck.get()) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous collection document count for harvestkey \" + harvestkey + \": expected=\" + count + \", counted=\" + countcheck); // big gap for harvestkey = null\n            ConcurrentLog.info(\"CollectionConfiguration\", \"cleanup_processing: re-calculated \" + proccount + \" new documents, \" +\n                        proccount_referencechange + \" reference-count changes, \" +\n                        proccount_citationchange + \" citation ranking changes.\");\n        } catch (final InterruptedException e2) {\n            ConcurrentLog.warn(\"CollectionConfiguration\", e2.getMessage(), e2);\n        } catch (IOException e3) {\n            ConcurrentLog.warn(\"CollectionConfiguration\", e3.getMessage(), e3);\n        }\n        collectionConnector.commit(true); // make changes available directly to prevent that the process repeats again\n        postprocessingCollection1Count = 0;\n        postprocessingWebgraphCount = 0;\n        postprocessingActivity = \"postprocessing terminated\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        postprocessingRunning = false;\n        return allcount.get();\n    }","id":47197,"modified_method":"/**\n     * post-processing steps for all entries that have a process tag assigned\n     * @param connector\n     * @param urlCitation\n     * @return\n     */\n    public int postprocessing(final Segment segment, final ReferenceReportCache rrCache, final String harvestkey) {\n        if (!this.contains(CollectionSchema.process_sxt)) return 0;\n        if (!segment.connectedCitation() && !segment.fulltext().useWebgraph()) return 0;\n        final SolrConnector collectionConnector = segment.fulltext().getDefaultConnector();\n        collectionConnector.commit(false); // make sure that we have latest information that can be found\n        if (segment.fulltext().useWebgraph()) segment.fulltext().getWebgraphConnector().commit(false);\n        final CollectionConfiguration collection = segment.fulltext().getDefaultConfiguration();\n        final WebgraphConfiguration webgraph = segment.fulltext().getWebgraphConfiguration();\n        \n        // calculate the number of documents to be processed\n        String collection1query = collection1query(segment, harvestkey);\n        String webgraphquery = webgraphquery(segment, harvestkey);\n        postprocessingRunning = true;\n        postprocessingStartTime = System.currentTimeMillis();\n        postprocessingActivity = \"collecting counts\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        try {\n            postprocessingCollection1Count = (int) collectionConnector.getCountByQuery(collection1query);\n            postprocessingWebgraphCount = segment.fulltext().useWebgraph() ? (int) segment.fulltext().getWebgraphConnector().getCountByQuery(webgraphquery) : 0;\n        } catch (IOException e) {\n            postprocessingCollection1Count = -1;\n            postprocessingWebgraphCount = -1;\n        }\n        \n        // collect hosts from index which shall take part in citation computation\n        postprocessingActivity = \"collecting host facets for collection\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        ReversibleScoreMap<String> collection1hosts;\n        try {\n            Map<String, ReversibleScoreMap<String>> hostfacet = collectionConnector.getFacets(collection1query, 10000000, CollectionSchema.host_s.getSolrFieldName());\n            collection1hosts = hostfacet.get(CollectionSchema.host_s.getSolrFieldName());\n        } catch (final IOException e2) {\n            ConcurrentLog.logException(e2);\n            collection1hosts = new ClusteredScoreMap<String>();\n        }\n\n        postprocessingActivity = \"create ranking map\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        boolean shallComputeCR = (segment.fulltext().useWebgraph() &&\n                ((webgraph.contains(WebgraphSchema.source_id_s) && webgraph.contains(WebgraphSchema.source_cr_host_norm_i)) ||\n                        (webgraph.contains(WebgraphSchema.target_id_s) && webgraph.contains(WebgraphSchema.target_cr_host_norm_i))) ||\n                      (collection.contains(CollectionSchema.cr_host_count_i) &&\n                       collection.contains(CollectionSchema.cr_host_chance_d) &&\n                       collection.contains(CollectionSchema.cr_host_norm_i)));\n        // create the ranking map\n        final Map<String, CRV> rankings = new ConcurrentHashMap<String, CRV>();\n        if (shallComputeCR) try {\n            int concurrency = Math.min(collection1hosts.size(), Runtime.getRuntime().availableProcessors());\n            postprocessingActivity = \"collecting cr for \" + collection1hosts.size() + \" hosts, concurrency = \" + concurrency;\n            ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n            int countcheck = 0;\n            for (String host: collection1hosts.keyList(true)) {\n                // Patch the citation index for links with canonical tags.\n                // This shall fulfill the following requirement:\n                // If a document A links to B and B contains a 'canonical C', then the citation rank computation shall consider that A links to C and B does not link to C.\n                // To do so, we first must collect all canonical links, find all references to them, get the anchor list of the documents and patch the citation reference of these links\n                String patchquery = CollectionSchema.host_s.getSolrFieldName() + \":\" + host + \" AND \" + CollectionSchema.canonical_s.getSolrFieldName() + AbstractSolrConnector.CATCHALL_DTERM;\n                long patchquerycount = collectionConnector.getCountByQuery(patchquery);\n                BlockingQueue<SolrDocument> documents_with_canonical_tag = collectionConnector.concurrentDocumentsByQuery(patchquery, CollectionSchema.url_chars_i.getSolrFieldName() + \" asc\", 0, 100000000, Long.MAX_VALUE, 20, 1, true,\n                        CollectionSchema.id.getSolrFieldName(), CollectionSchema.sku.getSolrFieldName(), CollectionSchema.canonical_s.getSolrFieldName());\n                SolrDocument doc_B;\n                int patchquerycountcheck = 0;\n                try {\n                    while ((doc_B = documents_with_canonical_tag.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                        // find all documents which link to the canonical doc\n                        DigestURL doc_C_url = new DigestURL((String) doc_B.getFieldValue(CollectionSchema.canonical_s.getSolrFieldName()));\n                        byte[] doc_B_id = ASCII.getBytes(((String) doc_B.getFieldValue(CollectionSchema.id.getSolrFieldName())));\n                        // we remove all references to B, because these become references to C\n                        if (segment.connectedCitation()) {\n                            ReferenceContainer<CitationReference> doc_A_ids = segment.urlCitation().remove(doc_B_id);\n                            if (doc_A_ids == null) {\n                                //System.out.println(\"*** document with canonical but no referrer: \" + doc_B.getFieldValue(CollectionSchema.sku.getSolrFieldName()));\n                                continue; // the document has a canonical tag but no referrer?\n                            }\n                            Iterator<CitationReference> doc_A_ids_iterator = doc_A_ids.entries();\n                            // for each of the referrer A of B, set A as a referrer of C\n                            while (doc_A_ids_iterator.hasNext()) {\n                                CitationReference doc_A_citation = doc_A_ids_iterator.next();\n                                segment.urlCitation().add(doc_C_url.hash(), doc_A_citation);\n                            }\n                        }\n                        patchquerycountcheck++;\n                        if (MemoryControl.shortStatus()) {\n                            ConcurrentLog.warn(\"CollectionConfiguration\", \"terminated canonical collection during postprocessing because of short memory\");\n                            break;\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    ConcurrentLog.logException(e);\n                } catch (SpaceExceededException e) {\n                    ConcurrentLog.logException(e);\n                }\n                if (patchquerycount != patchquerycountcheck) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous patchquery count for host \" + host + \": expected=\" + patchquerycount + \", counted=\" + patchquerycountcheck);\n                \n                // do the citation rank computation\n                if (collection1hosts.get(host) <= 0) continue;\n                // select all documents for each host\n                CRHost crh = new CRHost(segment, rrCache, host, 0.85d, 6);\n                int convergence_attempts = 0;\n                while (convergence_attempts++ < 30) {\n                    ConcurrentLog.info(\"CollectionConfiguration\", \"convergence step \" + convergence_attempts + \" for host \" + host + \" ...\");\n                    if (crh.convergenceStep()) break;\n                    if (MemoryControl.shortStatus()) {\n                        ConcurrentLog.warn(\"CollectionConfiguration\", \"terminated convergenceStep during postprocessing because of short memory\");\n                        break;\n                    }\n                }\n                ConcurrentLog.info(\"CollectionConfiguration\", \"convergence for host \" + host + \" after \" + convergence_attempts + \" steps\");\n                // we have now the cr for all documents of a specific host; we store them for later use\n                Map<String, CRV> crn = crh.normalize();\n                //crh.log(crn);\n                rankings.putAll(crn); // accumulate this here for usage in document update later\n                if (MemoryControl.shortStatus()) {\n                    ConcurrentLog.warn(\"CollectionConfiguration\", \"terminated crn akkumulation during postprocessing because of short memory\");\n                    break;\n                }\n                countcheck++;\n            }\n            if (collection1hosts.size() != countcheck) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous host count: expected=\" + collection1hosts.size() + \", counted=\" + countcheck);\n        } catch (final IOException e2) {\n            ConcurrentLog.logException(e2);\n            collection1hosts = new ClusteredScoreMap<String>();\n        }\n        \n        // process all documents at the webgraph for the outgoing links of this document\n        final AtomicInteger allcount = new AtomicInteger(0);\n        if (segment.fulltext().useWebgraph() && shallComputeCR) {\n            postprocessingActivity = \"collecting host facets for webgraph cr calculation\";\n            ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n            final Set<String> omitFields = new HashSet<String>();\n            omitFields.add(WebgraphSchema.process_sxt.getSolrFieldName());\n            omitFields.add(WebgraphSchema.harvestkey_s.getSolrFieldName());\n            \n            // collect hosts from index which shall take part in citation computation\n            ReversibleScoreMap<String> webgraphhosts;\n            try {\n                Map<String, ReversibleScoreMap<String>> hostfacet = segment.fulltext().getWebgraphConnector().getFacets(webgraphquery, 10000000, WebgraphSchema.source_host_s.getSolrFieldName());\n                webgraphhosts = hostfacet.get(WebgraphSchema.source_host_s.getSolrFieldName());\n            } catch (final IOException e2) {\n                ConcurrentLog.logException(e2);\n                webgraphhosts = new ClusteredScoreMap<String>();\n            }\n            try {\n                final long start = System.currentTimeMillis();\n                for (String host: webgraphhosts.keyList(true)) {\n                    if (webgraphhosts.get(host) <= 0) continue;\n                    final String hostfinal = host;\n                    // select all webgraph edges and modify their cr value\n                    postprocessingActivity = \"writing cr values to webgraph for host \" + host;\n                    ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n                    String patchquery = WebgraphSchema.source_host_s.getSolrFieldName() + \":\\\"\" + host + \"\\\" AND \" + WebgraphSchema.process_sxt.getSolrFieldName() + AbstractSolrConnector.CATCHALL_DTERM;\n                    final long count = segment.fulltext().getWebgraphConnector().getCountByQuery(patchquery);\n                    int concurrency = Math.min((int) count, Math.max(1, Runtime.getRuntime().availableProcessors() / 4));\n                    ConcurrentLog.info(\"CollectionConfiguration\", \"collecting \" + count + \" documents from the webgraph, concurrency = \" + concurrency);\n                    final BlockingQueue<SolrDocument> docs = segment.fulltext().getWebgraphConnector().concurrentDocumentsByQuery(\n                            patchquery,\n                            WebgraphSchema.source_chars_i.getSolrFieldName() + \" asc\",\n                            0, 100000000, Long.MAX_VALUE, concurrency + 1, concurrency, true\n                            // TODO: add field list and do partial updates\n                            );\n                    final AtomicInteger proccount = new AtomicInteger(0);\n                    Thread[] t = new Thread[concurrency];\n                    for (final AtomicInteger i = new AtomicInteger(0); i.get() < t.length; i.incrementAndGet()) {\n                        t[i.get()] = new Thread() {\n                            private String name = \"CollectionConfiguration.postprocessing.webgraph-\" + i.get();\n                            @Override\n                            public void run() {\n                                Thread.currentThread().setName(name);\n                                SolrDocument doc; String id;\n                                try {\n                                    processloop: while ((doc = docs.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                                        try {\n                                            SolrInputDocument sid = webgraph.toSolrInputDocument(doc, omitFields);\n                                            Collection<Object> proctags = doc.getFieldValues(WebgraphSchema.process_sxt.getSolrFieldName());\n    \n                                            for (Object tag: proctags) try {\n                                                \n                                                // switch over tag types\n                                                ProcessType tagtype = ProcessType.valueOf((String) tag);\n                                                    \n                                                // set cr values\n                                                if (tagtype == ProcessType.CITATION) {\n                                                    if (segment.fulltext().useWebgraph() && webgraph.contains(WebgraphSchema.source_id_s) && webgraph.contains(WebgraphSchema.source_cr_host_norm_i)) {\n                                                        id = (String) doc.getFieldValue(WebgraphSchema.source_id_s.getSolrFieldName());\n                                                        CRV crv = rankings.get(id);\n                                                        if (crv != null) {\n                                                            sid.setField(WebgraphSchema.source_cr_host_norm_i.getSolrFieldName(), crv.crn);\n                                                        }\n                                                    }\n                                                    if (webgraph.contains(WebgraphSchema.target_id_s) && webgraph.contains(WebgraphSchema.target_cr_host_norm_i)) {\n                                                        id = (String) doc.getFieldValue(WebgraphSchema.target_id_s.getSolrFieldName());\n                                                        CRV crv = rankings.get(id);\n                                                        if (crv != null) {\n                                                            sid.setField(WebgraphSchema.target_cr_host_norm_i.getSolrFieldName(), crv.crn);\n                                                        }\n                                                    }\n                                                }\n                                            } catch (IllegalArgumentException e) {\n                                                ConcurrentLog.logException(e);\n                                            }\n                                            \n                                            // write document back to index\n                                            try {\n                                                sid.removeField(WebgraphSchema.process_sxt.getSolrFieldName());\n                                                sid.removeField(WebgraphSchema.harvestkey_s.getSolrFieldName());\n                                                //segment.fulltext().getWebgraphConnector().deleteById((String) sid.getFieldValue(WebgraphSchema.id.getSolrFieldName()));\n                                                segment.fulltext().getWebgraphConnector().add(sid);\n                                            } catch (SolrException e) {\n                                                ConcurrentLog.logException(e);\n                                            } catch (IOException e) {\n                                                ConcurrentLog.logException(e);\n                                            }\n                                            proccount.incrementAndGet();\n                                            allcount.incrementAndGet();\n                                            if (proccount.get() % 1000 == 0) {\n                                                postprocessingActivity = \"writing cr values to webgraph for host \" + hostfinal + \"postprocessed \" + proccount + \" from \" + count + \" documents; \" +\n                                                    (proccount.get() * 1000 / (System.currentTimeMillis() - start)) + \" docs/second; \" +\n                                                    ((System.currentTimeMillis() - start) * (count - proccount.get()) / proccount.get() / 60000) + \" minutes remaining\";\n                                                ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n                                            }\n                                        } catch (Throwable e) {\n                                            ConcurrentLog.logException(e);\n                                            continue processloop;\n                                        }\n                                    }\n                                } catch (InterruptedException e) {\n                                    ConcurrentLog.warn(\"CollectionConfiguration\", e.getMessage(), e);\n                                }\n                            }\n                        };\n                        t[i.get()].start();\n                    }\n                    for (int i = 0; i < t.length; i++) try {\n                        t[i].join(10000);\n                        if (t[i].isAlive()) t[i].interrupt();\n                    } catch (InterruptedException e) {}\n                    \n                    if (count != proccount.get()) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous webgraph document count for host \" + host + \": expected=\" + count + \", counted=\" + proccount);\n                }\n            } catch (final IOException e2) {\n                ConcurrentLog.warn(\"CollectionConfiguration\", e2.getMessage(), e2);\n            }\n        }\n        \n        // process all documents in collection\n        final Map<String, Long> hostExtentCache = new HashMap<String, Long>(); // a mapping from the host id to the number of documents which contain this host-id\n        final Set<String> uniqueURLs = new ConcurrentHashSet<String>(); // will be used in a concurrent environment\n        try {\n            final Set<String> omitFields = new HashSet<String>();\n            omitFields.add(CollectionSchema.process_sxt.getSolrFieldName());\n            omitFields.add(CollectionSchema.harvestkey_s.getSolrFieldName());\n            final long count = collectionConnector.getCountByQuery(collection1query);\n            final long start = System.currentTimeMillis();\n            final int concurrency = Math.max(1, Math.min((int) (MemoryControl.available() / (100L * 1024L * 1024L)), Runtime.getRuntime().availableProcessors()));\n            //final int concurrency = 1;\n            final boolean reference_computation = this.contains(CollectionSchema.references_i) &&\n                    this.contains(CollectionSchema.references_internal_i) &&\n                    this.contains(CollectionSchema.references_external_i) &&\n                    this.contains(CollectionSchema.references_exthosts_i);\n            postprocessingActivity = \"collecting \" + count + \" documents from the collection for harvestkey \" + harvestkey;\n            ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n            final BlockingQueue<SolrDocument> docs = collectionConnector.concurrentDocumentsByQuery(\n                    collection1query,\n                    (this.contains(CollectionSchema.http_unique_b) || this.contains(CollectionSchema.www_unique_b)) ?\n                    CollectionSchema.host_subdomain_s.getSolrFieldName() + \" asc,\" + // sort on subdomain to get hosts without subdomain first; that gives an opportunity to set www_unique_b flag to false\n                    CollectionSchema.url_protocol_s.getSolrFieldName() + \" asc\" // sort on protocol to get http before https; that gives an opportunity to set http_unique_b flag to false\n                    : null, // null sort is faster!\n                    0, 100000000, Long.MAX_VALUE, concurrency + 1, concurrency, true,\n                    CollectionSchema.id.getSolrFieldName(),\n                    CollectionSchema.sku.getSolrFieldName(),\n                    CollectionSchema.harvestkey_s.getSolrFieldName(),\n                    CollectionSchema.process_sxt.getSolrFieldName(),\n                    CollectionSchema.canonical_equal_sku_b.getSolrFieldName(),\n                    CollectionSchema.canonical_s.getSolrFieldName(),\n                    CollectionSchema.exact_signature_l.getSolrFieldName(),\n                    CollectionSchema.fuzzy_signature_l.getSolrFieldName(),\n                    CollectionSchema.title_exact_signature_l.getSolrFieldName(),\n                    CollectionSchema.description_exact_signature_l.getSolrFieldName(),\n                    CollectionSchema.host_id_s.getSolrFieldName(),\n                    CollectionSchema.host_s.getSolrFieldName(),\n                    CollectionSchema.host_subdomain_s.getSolrFieldName(),\n                    CollectionSchema.url_chars_i.getSolrFieldName(),\n                    CollectionSchema.url_protocol_s.getSolrFieldName(),\n                    CollectionSchema.httpstatus_i.getSolrFieldName(),\n                    CollectionSchema.inboundlinkscount_i.getSolrFieldName(),\n                    CollectionSchema.robots_i.getSolrFieldName());\n            final AtomicInteger proccount = new AtomicInteger();\n            final AtomicInteger proccount_referencechange = new AtomicInteger();\n            final AtomicInteger proccount_citationchange = new AtomicInteger();\n            final AtomicInteger countcheck = new AtomicInteger(0);\n            final Collection<String> failids = new ArrayList<String>();\n            final Thread rewriteThread[] = new Thread[concurrency];\n            for (int rewrite_start = 0; rewrite_start < concurrency; rewrite_start++) {\n                rewriteThread[rewrite_start] = new Thread() {\n                    @Override\n                    public void run() {\n                        SolrDocument doc;\n                        try {\n                            while ((doc = docs.take()) != AbstractSolrConnector.POISON_DOCUMENT) {\n                                // for each to-be-processed entry work on the process tag\n                                Collection<Object> proctags = doc.getFieldValues(CollectionSchema.process_sxt.getSolrFieldName());\n                                final String u = (String) doc.getFieldValue(CollectionSchema.sku.getSolrFieldName());\n                                final String i = (String) doc.getFieldValue(CollectionSchema.id.getSolrFieldName());\n                                if (proctags == null || proctags.size() == 0) {\n                                    // this should not happen since we collected the documents using a process_sxt:[* TO *] term\n                                    ConcurrentLog.warn(\"CollectionConfiguration\", \"no process_sxt entry for url \" + u + \", id=\" + i);\n                                    continue;\n                                }\n                                try {\n                                    DigestURL url = new DigestURL(u, ASCII.getBytes(i));\n                                    byte[] id = url.hash();\n                                    SolrInputDocument sid = new SolrInputDocument(); //collection.toSolrInputDocument(doc, omitFields);\n                                    sid.setField(CollectionSchema.id.getSolrFieldName(), i);\n                                    for (Object tag: proctags) try {\n                                        \n                                        // switch over tag types\n                                        ProcessType tagtype = ProcessType.valueOf((String) tag);\n    \n                                        if (tagtype == ProcessType.CITATION &&\n                                            collection.contains(CollectionSchema.cr_host_count_i) &&\n                                            collection.contains(CollectionSchema.cr_host_chance_d) &&\n                                            collection.contains(CollectionSchema.cr_host_norm_i)) {\n                                            CRV crv = rankings.remove(ASCII.String(id)); // instead of 'get'ting the CRV, we also remove it because we will not need it again and free some memory here\n                                            if (crv != null) {\n                                                sid.setField(CollectionSchema.cr_host_count_i.getSolrFieldName(), crv.count);\n                                                sid.setField(CollectionSchema.cr_host_chance_d.getSolrFieldName(), crv.cr);\n                                                sid.setField(CollectionSchema.cr_host_norm_i.getSolrFieldName(), crv.crn);\n                                                proccount_citationchange.incrementAndGet();\n                                            }\n                                        }\n    \n                                        if (tagtype == ProcessType.UNIQUE) {\n                                            postprocessing_http_unique(segment, doc, sid, url);\n                                            postprocessing_www_unique(segment, doc, sid, url);\n                                            postprocessing_doublecontent(segment, uniqueURLs, doc, sid, url);\n                                        }\n                                        \n                                    } catch (IllegalArgumentException e) {}\n                                    \n                                    // compute references\n                                    if (reference_computation) {\n                                        String hosthash = url.hosthash();\n                                        if (!hostExtentCache.containsKey(hosthash)) {\n                                            StringBuilder q = new StringBuilder();\n                                            q.append(CollectionSchema.host_id_s.getSolrFieldName()).append(\":\\\"\").append(hosthash).append(\"\\\" AND \").append(CollectionSchema.httpstatus_i.getSolrFieldName()).append(\":200\");\n                                            long hostExtentCount = segment.fulltext().getDefaultConnector().getCountByQuery(q.toString());\n                                            hostExtentCache.put(hosthash, hostExtentCount);\n                                        }\n                                        if (postprocessing_references(rrCache, sid, url, hostExtentCache)) proccount_referencechange.incrementAndGet();\n                                    }\n                                    \n                                    // all processing steps checked, remove the processing and harvesting key\n                                    sid.setField(CollectionSchema.process_sxt.getSolrFieldName(), null); // setting this to null will cause a removal when doing a partial update\n                                    sid.setField(CollectionSchema.harvestkey_s.getSolrFieldName(), null);\n                                    \n                                    // send back to index\n                                    //collectionConnector.deleteById(i);\n                                    collectionConnector.update(sid);\n                                    \n                                    long thiscount = proccount.incrementAndGet(); allcount.incrementAndGet();\n                                    if (thiscount % 100 == 0) {\n                                        postprocessingActivity = \"postprocessed \" + thiscount + \" from \" + count + \" collection documents; \" +\n                                            (thiscount * 60000L / (System.currentTimeMillis() - start)) + \" ppm; \" +\n                                            ((System.currentTimeMillis() - start) * (count - thiscount) / thiscount / 60000) + \" minutes remaining\";\n                                        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n                                    }\n                                } catch (final Throwable e1) {\n                                    ConcurrentLog.logException(e1);\n                                    failids.add(i);\n                                }\n                                countcheck.incrementAndGet();\n                            }\n                        } catch (InterruptedException e) {\n                            ConcurrentLog.logException(e);\n                        }\n                    }\n                };\n                rewriteThread[rewrite_start].start();\n            }\n            // wait for termination\n            for (int rewrite_start = 0; rewrite_start < concurrency; rewrite_start++) rewriteThread[rewrite_start].join();\n            \n            if (failids.size() > 0) {\n                ConcurrentLog.info(\"CollectionConfiguration\", \"cleanup_processing: deleting \" + failids.size() + \" documents which have permanent execution fails\");\n                collectionConnector.deleteByIds(failids);\n            }\n            if (count != countcheck.get()) ConcurrentLog.warn(\"CollectionConfiguration\", \"ambiguous collection document count for harvestkey \" + harvestkey + \": expected=\" + count + \", counted=\" + countcheck); // big gap for harvestkey = null\n            ConcurrentLog.info(\"CollectionConfiguration\", \"cleanup_processing: re-calculated \" + proccount + \" new documents, \" +\n                        proccount_referencechange + \" reference-count changes, \" +\n                        proccount_citationchange + \" citation ranking changes.\");\n        } catch (final InterruptedException e2) {\n            ConcurrentLog.warn(\"CollectionConfiguration\", e2.getMessage(), e2);\n        } catch (IOException e3) {\n            ConcurrentLog.warn(\"CollectionConfiguration\", e3.getMessage(), e3);\n        }\n        collectionConnector.commit(true); // make changes available directly to prevent that the process repeats again\n        postprocessingCollection1Count = 0;\n        postprocessingWebgraphCount = 0;\n        postprocessingActivity = \"postprocessing terminated\";\n        ConcurrentLog.info(\"CollectionConfiguration\", postprocessingActivity);\n        postprocessingRunning = false;\n        return allcount.get();\n    }","commit_id":"2e09da9832145f49261800c437c31bd8e5af6cb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void postprocessing_doublecontent(Segment segment, Set<String> uniqueURLs, SolrInputDocument sid, DigestURL url) {\n        // FIND OUT IF THIS IS A DOUBLE DOCUMENT\n        String urlhash = ASCII.String(url.hash());\n        String hostid = url.hosthash();\n        Conjunction con = new Conjunction();\n        Disjunction dnf = new Disjunction();\n        CollectionSchema[][] doccheckschema = new CollectionSchema[][]{\n                {CollectionSchema.exact_signature_l, CollectionSchema.exact_signature_unique_b, CollectionSchema.exact_signature_copycount_i},\n                {CollectionSchema.fuzzy_signature_l, CollectionSchema.fuzzy_signature_unique_b, CollectionSchema.fuzzy_signature_copycount_i}};\n        uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) sid.getField(signaturefield.getSolrFieldName()).getValue();\n                if (signature == null) continue uniquecheck;\n                //con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n                //con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n                dnf.addOperand(new Literal(signaturefield, signature.toString()));\n            }\n        }\n        con.addOperand(dnf);\n        con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n        con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n        String query = con.toString();\n        SolrDocumentList docsAkk;\n        try {\n             docsAkk = segment.fulltext().getDefaultConnector().getDocumentListByQuery(query, null, 0, 200,\n                     CollectionSchema.id.getSolrFieldName(), CollectionSchema.exact_signature_l.getSolrFieldName(), CollectionSchema.fuzzy_signature_l.getSolrFieldName());\n        } catch (final IOException e) {\n            ConcurrentLog.logException(e);\n            docsAkk = new SolrDocumentList(); \n        }\n        if (docsAkk.getNumFound() > 0) uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) sid.getField(signaturefield.getSolrFieldName()).getValue();\n                if (signature == null) continue uniquecheck;\n                SolrDocumentList docs = new Literal(signaturefield, signature.toString()).apply(docsAkk);\n                if (docs.getNumFound() == 0) {\n                    sid.setField(uniquefield.getSolrFieldName(), true);\n                    sid.setField(countfield.getSolrFieldName(), 1);\n                } else {\n                    boolean firstappearance = true;\n                    for (SolrDocument d: docs) {if (uniqueURLs.contains(d.getFieldValue(CollectionSchema.id.getSolrFieldName()))) firstappearance = false; break;}\n                    sid.setField(uniquefield.getSolrFieldName(), firstappearance);\n                    sid.setField(countfield.getSolrFieldName(), docs.getNumFound() + 1); // the current url was excluded from search but is included in count\n                }\n            }\n        }\n        \n        // CHECK IF TITLE AND DESCRIPTION IS UNIQUE (this is by default not switched on)\n        // in case that the document has no status code 200, has a noindex attribute\n        // or a canonical tag which does not point to the document itself,\n        // then the unique-field is not written at all!\n        Integer robots_i = this.contains(CollectionSchema.robots_i) ? (Integer) sid.getFieldValue(CollectionSchema.robots_i.getSolrFieldName()) : null;\n        Integer httpstatus_i = this.contains(CollectionSchema.httpstatus_i) ? (Integer) sid.getFieldValue(CollectionSchema.httpstatus_i.getSolrFieldName()) : null;\n        String canonical_s = this.contains(CollectionSchema.canonical_s) ? (String) sid.getFieldValue(CollectionSchema.canonical_s.getSolrFieldName()) : null;\n        Boolean canonical_equal_sku_b = this.contains(CollectionSchema.canonical_equal_sku_b) ? (Boolean) sid.getFieldValue(CollectionSchema.canonical_equal_sku_b.getSolrFieldName()) : null;\n\n        CollectionSchema[][] metadatacheckschema = new CollectionSchema[][]{\n                {CollectionSchema.title, CollectionSchema.title_exact_signature_l, CollectionSchema.title_unique_b},\n                {CollectionSchema.description_txt, CollectionSchema.description_exact_signature_l, CollectionSchema.description_unique_b}};\n        if (segment.fulltext().getDefaultConfiguration().contains(CollectionSchema.host_id_s) &&\n            (robots_i == null || (robots_i.intValue() & (1 << 9)) == 0 /*noindex in http X-ROBOTS*/ && (robots_i.intValue() & (1 << 3)) == 0 /*noindex in html metas*/ ) &&\n            (canonical_s == null || canonical_s.length() == 0 || (canonical_equal_sku_b != null && canonical_equal_sku_b.booleanValue()) || url.toNormalform(true).equals(canonical_s)) &&\n            (httpstatus_i == null || httpstatus_i.intValue() == 200)) {\n            uniquecheck: for (CollectionSchema[] checkfields: metadatacheckschema) {\n                CollectionSchema checkfield = checkfields[0];\n                CollectionSchema signaturefield = checkfields[1];\n                CollectionSchema uniquefield = checkfields[2];\n                if (this.contains(checkfield) && this.contains(signaturefield) && this.contains(uniquefield)) {\n                    // lookup in the index within the same hosts for the same title or description\n                    //String checkstring = checkfield == CollectionSchema.title ? document.dc_title() : document.dc_description();\n                    Long signature = (Long) sid.getFieldValue(signaturefield.getSolrFieldName());\n                    if (signature == null) {\n                        continue uniquecheck;\n                    }\n                    try {\n                        String doccountquery = \n                                CollectionSchema.host_id_s.getSolrFieldName() + \":\\\"\" + hostid + \"\\\" AND \" +\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":8 AND \" + // bit 3 (noindex)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":24 AND \" + // bit 3 + 4 (noindex + nofollow)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":512 AND \" + // bit 9 (noindex)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":1536 AND \" + // bit 9 + 10 (noindex + nofollow)\n                                \"((-\" + CollectionSchema.canonical_equal_sku_b.getSolrFieldName() + \":\" + AbstractSolrConnector.CATCHALL_TERM + \") OR (\" + CollectionSchema.canonical_equal_sku_b.getSolrFieldName() + \":true)) AND \" +\n                                CollectionSchema.httpstatus_i.getSolrFieldName() + \":200 AND \" +\n                                \"-\" + CollectionSchema.id.getSolrFieldName() + \":\\\"\" + urlhash + \"\\\" AND \" +\n                                signaturefield.getSolrFieldName() + \":\\\"\" + signature.toString() + \"\\\"\";\n                        long doccount = segment.fulltext().getDefaultConnector().getCountByQuery(doccountquery);\n                        sid.setField(uniquefield.getSolrFieldName(), doccount  == 0);\n                    } catch (final IOException e) {}\n                }\n            }\n        }\n        uniqueURLs.add(urlhash);\n    }","id":47198,"modified_method":"public void postprocessing_doublecontent(Segment segment, Set<String> uniqueURLs, SolrDocument doc, final SolrInputDocument sid, final DigestURL url) {\n        // FIND OUT IF THIS IS A DOUBLE DOCUMENT\n        String urlhash = ASCII.String(url.hash());\n        String hostid = url.hosthash();\n        Conjunction con = new Conjunction();\n        Disjunction dnf = new Disjunction();\n        CollectionSchema[][] doccheckschema = new CollectionSchema[][]{\n                {CollectionSchema.exact_signature_l, CollectionSchema.exact_signature_unique_b, CollectionSchema.exact_signature_copycount_i},\n                {CollectionSchema.fuzzy_signature_l, CollectionSchema.fuzzy_signature_unique_b, CollectionSchema.fuzzy_signature_copycount_i}};\n        uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                if (signature == null) continue uniquecheck;\n                //con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n                //con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n                dnf.addOperand(new Literal(signaturefield, signature.toString()));\n            }\n        }\n        con.addOperand(dnf);\n        con.addOperand(new Negation(new Literal(CollectionSchema.id, urlhash)));\n        con.addOperand(new Literal(CollectionSchema.host_id_s, hostid));\n        String query = con.toString();\n        SolrDocumentList docsAkk;\n        try {\n             docsAkk = segment.fulltext().getDefaultConnector().getDocumentListByQuery(query, null, 0, 200,\n                     CollectionSchema.id.getSolrFieldName(), CollectionSchema.exact_signature_l.getSolrFieldName(), CollectionSchema.fuzzy_signature_l.getSolrFieldName());\n        } catch (final IOException e) {\n            ConcurrentLog.logException(e);\n            docsAkk = new SolrDocumentList(); \n        }\n        if (docsAkk.getNumFound() > 0) uniquecheck: for (CollectionSchema[] checkfields: doccheckschema) {\n            CollectionSchema signaturefield = checkfields[0];\n            CollectionSchema uniquefield = checkfields[1];\n            CollectionSchema countfield = checkfields[2];\n\n            if (this.contains(signaturefield) && this.contains(uniquefield) && this.contains(countfield)) {\n                // lookup the document with the same signature\n                Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                if (signature == null) continue uniquecheck;\n                SolrDocumentList docs = new Literal(signaturefield, signature.toString()).apply(docsAkk);\n                if (docs.getNumFound() == 0) {\n                    sid.setField(uniquefield.getSolrFieldName(), true);\n                    sid.setField(countfield.getSolrFieldName(), 1);\n                } else {\n                    boolean firstappearance = true;\n                    for (SolrDocument d: docs) {if (uniqueURLs.contains(d.getFieldValue(CollectionSchema.id.getSolrFieldName()))) firstappearance = false; break;}\n                    sid.setField(uniquefield.getSolrFieldName(), firstappearance);\n                    sid.setField(countfield.getSolrFieldName(), docs.getNumFound() + 1); // the current url was excluded from search but is included in count\n                }\n            }\n        }\n        \n        // CHECK IF TITLE AND DESCRIPTION IS UNIQUE (this is by default not switched on)\n        // in case that the document has no status code 200, has a noindex attribute\n        // or a canonical tag which does not point to the document itself,\n        // then the unique-field is not written at all!\n        Integer robots_i = this.contains(CollectionSchema.robots_i) ? (Integer) doc.getFieldValue(CollectionSchema.robots_i.getSolrFieldName()) : null;\n        Integer httpstatus_i = this.contains(CollectionSchema.httpstatus_i) ? (Integer) doc.getFieldValue(CollectionSchema.httpstatus_i.getSolrFieldName()) : null;\n        String canonical_s = this.contains(CollectionSchema.canonical_s) ? (String) doc.getFieldValue(CollectionSchema.canonical_s.getSolrFieldName()) : null;\n        Boolean canonical_equal_sku_b = this.contains(CollectionSchema.canonical_equal_sku_b) ? (Boolean) doc.getFieldValue(CollectionSchema.canonical_equal_sku_b.getSolrFieldName()) : null;\n\n        CollectionSchema[][] metadatacheckschema = new CollectionSchema[][]{\n                {CollectionSchema.title, CollectionSchema.title_exact_signature_l, CollectionSchema.title_unique_b},\n                {CollectionSchema.description_txt, CollectionSchema.description_exact_signature_l, CollectionSchema.description_unique_b}};\n        if (segment.fulltext().getDefaultConfiguration().contains(CollectionSchema.host_id_s) &&\n            (robots_i == null || (robots_i.intValue() & (1 << 9)) == 0 /*noindex in http X-ROBOTS*/ && (robots_i.intValue() & (1 << 3)) == 0 /*noindex in html metas*/ ) &&\n            (canonical_s == null || canonical_s.length() == 0 || (canonical_equal_sku_b != null && canonical_equal_sku_b.booleanValue()) || url.toNormalform(true).equals(canonical_s)) &&\n            (httpstatus_i == null || httpstatus_i.intValue() == 200)) {\n            uniquecheck: for (CollectionSchema[] checkfields: metadatacheckschema) {\n                CollectionSchema checkfield = checkfields[0];\n                CollectionSchema signaturefield = checkfields[1];\n                CollectionSchema uniquefield = checkfields[2];\n                if (this.contains(checkfield) && this.contains(signaturefield) && this.contains(uniquefield)) {\n                    // lookup in the index within the same hosts for the same title or description\n                    //String checkstring = checkfield == CollectionSchema.title ? document.dc_title() : document.dc_description();\n                    Long signature = (Long) doc.getFieldValue(signaturefield.getSolrFieldName());\n                    if (signature == null) {\n                        continue uniquecheck;\n                    }\n                    try {\n                        String doccountquery = \n                                CollectionSchema.host_id_s.getSolrFieldName() + \":\\\"\" + hostid + \"\\\" AND \" +\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":8 AND \" + // bit 3 (noindex)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":24 AND \" + // bit 3 + 4 (noindex + nofollow)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":512 AND \" + // bit 9 (noindex)\n                                \"-\" + CollectionSchema.robots_i.getSolrFieldName() + \":1536 AND \" + // bit 9 + 10 (noindex + nofollow)\n                                \"((-\" + CollectionSchema.canonical_equal_sku_b.getSolrFieldName() + \":\" + AbstractSolrConnector.CATCHALL_TERM + \") OR (\" + CollectionSchema.canonical_equal_sku_b.getSolrFieldName() + \":true)) AND \" +\n                                CollectionSchema.httpstatus_i.getSolrFieldName() + \":200 AND \" +\n                                \"-\" + CollectionSchema.id.getSolrFieldName() + \":\\\"\" + urlhash + \"\\\" AND \" +\n                                signaturefield.getSolrFieldName() + \":\\\"\" + signature.toString() + \"\\\"\";\n                        long doccount = segment.fulltext().getDefaultConnector().getCountByQuery(doccountquery);\n                        sid.setField(uniquefield.getSolrFieldName(), doccount  == 0);\n                    } catch (final IOException e) {}\n                }\n            }\n        }\n        uniqueURLs.add(urlhash);\n    }","commit_id":"2e09da9832145f49261800c437c31bd8e5af6cb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void postprocessing_http_unique(Segment segment, SolrInputDocument sid, DigestURL url) {\n        if (!this.contains(CollectionSchema.http_unique_b)) return;\n        if (!url.isHTTPS() && !url.isHTTP()) return;\n        try {\n            DigestURL u = new DigestURL((url.isHTTP() ? \"https://\" : \"http://\") + url.urlstub(true, true));\n            SolrDocument d = segment.fulltext().getDefaultConnector().getDocumentById(ASCII.String(u.hash()), CollectionSchema.http_unique_b.getSolrFieldName());\n            set_unique_flag(CollectionSchema.http_unique_b, sid, d);\n        } catch (final IOException e) {}\n    }","id":47199,"modified_method":"public void postprocessing_http_unique(final Segment segment, final SolrDocument doc, final SolrInputDocument sid, final DigestURL url) {\n        if (!this.contains(CollectionSchema.http_unique_b)) return;\n        if (!url.isHTTPS() && !url.isHTTP()) return;\n        try {\n            DigestURL u = new DigestURL((url.isHTTP() ? \"https://\" : \"http://\") + url.urlstub(true, true));\n            SolrDocument d = segment.fulltext().getDefaultConnector().getDocumentById(ASCII.String(u.hash()), CollectionSchema.http_unique_b.getSolrFieldName());\n            set_unique_flag(CollectionSchema.http_unique_b, doc, sid, d);\n        } catch (final IOException e) {}\n    }","commit_id":"2e09da9832145f49261800c437c31bd8e5af6cb9","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void doVerify() throws Exception {\n\t\tVerifyProcess verifyProcess = getVerifyProcess();\n\n\t\tverifyProcess.verify();\n\t}","id":47200,"modified_method":"protected void doVerify() throws VerifyException {\n\t\tVerifyProcess verifyProcess = getVerifyProcess();\n\n\t\tverifyProcess.verify();\n\t}","commit_id":"949dd05c5e964c8fadc45ca92db40e497330b1a3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@After\n\tpublic void tearDown() throws Exception {\n\t\tif (_pacl == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\n\t\tField field = ReflectionTestUtil.getField(DataAccess.class, \"_pacl\");\n\n\t\tfield.set(null, _pacl);\n\t}","id":47201,"modified_method":"@After\n\tpublic void tearDown() throws Exception {\n\t\tif (_pacl == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\n\t\tReflectionTestUtil.setFieldValue(DataAccess.class, \"_pacl\", _pacl);\n\t}","commit_id":"949dd05c5e964c8fadc45ca92db40e497330b1a3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tField field = ReflectionTestUtil.getField(DataAccess.class, \"_pacl\");\n\n\t\t_pacl = (DataAccess.PACL)field.get(null);\n\n\t\tfield.set(null, new PACLWrapper(_pacl));\n\t}","id":47202,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t_pacl = ReflectionTestUtil.getFieldValue(DataAccess.class, \"_pacl\");\n\n\t\tReflectionTestUtil.setFieldValue(\n\t\t\tDataAccess.class, \"_pacl\", new PACLWrapper(_pacl));\n\t}","commit_id":"949dd05c5e964c8fadc45ca92db40e497330b1a3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void assertAllConnectionsClosed() throws Exception {\n\t\tfor (Connection con : _connections) {\n\t\t\tAssert.assertTrue(\"A connection was not closed\", con.isClosed());\n\t\t}\n\t}","id":47203,"modified_method":"protected void assertAllConnectionsClosed() throws SQLException {\n\t\tfor (Connection con : _connections) {\n\t\t\tAssert.assertTrue(\"A connection was not closed\", con.isClosed());\n\t\t}\n\t}","commit_id":"949dd05c5e964c8fadc45ca92db40e497330b1a3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Resolves a module reference in a general case.\n   *\n   * @param qualifiedName      qualified name of the module reference to resolve\n   * @param source_file        where that reference resides; serves as PSI foothold to determine module, project, etc.\n   * @param import_is_absolute if false, try old python 2.x's \"relative first, absolute next\" approach.\n   * @param relative_level     if > 0, step back from source_file and resolve from there (even if import_is_absolute is false!).\n   * @return list of possible candidates\n   */\n  @NotNull\n  public static List<PsiElement> resolveModule(@Nullable PyQualifiedName qualifiedName, PsiFile source_file,\n                                               boolean import_is_absolute, int relative_level) {\n    if (qualifiedName == null) return Collections.emptyList();\n    String marker = StringUtil.join(qualifiedName.getComponents(), \".\") + \"#\" + Integer.toString(relative_level);\n    Set<String> being_imported = ourBeingImported.get();\n    if (being_imported.contains(marker)) return Collections.emptyList(); // break endless loop in import\n    try {\n      being_imported.add(marker);\n      if (relative_level > 0) {\n        // \"from ...module import\"\n        final PsiElement module = resolveModuleAt(stepBackFrom(source_file, relative_level), source_file, qualifiedName);\n        return module != null ? Collections.singletonList(module) : Collections.<PsiElement>emptyList();\n      }\n      else { // \"from module import\"\n        if (import_is_absolute) {\n          return resolveModulesInRoots(qualifiedName, source_file);\n        }\n        else {\n          final PsiDirectory dir = source_file.getOriginalFile().getContainingDirectory();\n          PsiElement module = resolveModuleAt(dir, source_file, qualifiedName);\n          if (module != null) {\n            return Collections.singletonList(module);\n          }\n          List<PsiElement> found_in_roots = resolveModulesInRoots(qualifiedName, source_file);\n          if (found_in_roots.size() > 0) return found_in_roots;\n          // TODO: resolve the name considering every source root as a package dir, as if it's a deployed package. django console does so.\n          // TODO: move this to project settings some day\n          ResolveInRootVisitor visitor = new ResolveInRootAsTopPackageVisitor(qualifiedName, source_file.getManager(), source_file, true);\n          visitRoots(source_file, visitor);\n          return visitor.results;\n        }\n      }\n    }\n    finally {\n      being_imported.remove(marker);\n    }\n  }","id":47204,"modified_method":"/**\n   * Resolves a module reference in a general case.\n   *\n   * @param qualifiedName      qualified name of the module reference to resolve\n   * @param source_file        where that reference resides; serves as PSI foothold to determine module, project, etc.\n   * @param import_is_absolute if false, try old python 2.x's \"relative first, absolute next\" approach.\n   * @param relative_level     if > 0, step back from source_file and resolve from there (even if import_is_absolute is false!).\n   * @return list of possible candidates\n   */\n  @NotNull\n  public static List<PsiElement> resolveModule(@Nullable PyQualifiedName qualifiedName, PsiFile source_file,\n                                               boolean import_is_absolute, int relative_level) {\n    if (qualifiedName == null) return Collections.emptyList();\n    String marker = StringUtil.join(qualifiedName.getComponents(), \".\") + \"#\" + Integer.toString(relative_level);\n    Set<String> being_imported = ourBeingImported.get();\n    if (being_imported.contains(marker)) return Collections.emptyList(); // break endless loop in import\n    try {\n      being_imported.add(marker);\n      if (relative_level > 0) {\n        // \"from ...module import\"\n        final PsiElement module = resolveModuleAt(stepBackFrom(source_file, relative_level), source_file, qualifiedName);\n        return module != null ? Collections.singletonList(module) : Collections.<PsiElement>emptyList();\n      }\n      else { // \"from module import\"\n        if (import_is_absolute) {\n          return resolveModulesInRoots(qualifiedName, source_file);\n        }\n        else {\n          final PsiDirectory dir = source_file.getOriginalFile().getContainingDirectory();\n          PsiElement module = resolveModuleAt(dir, source_file, qualifiedName);\n          if (module != null) {\n            return Collections.singletonList(module);\n          }\n          List<PsiElement> found_in_roots = resolveModulesInRoots(qualifiedName, source_file);\n          if (found_in_roots.size() > 0) return found_in_roots;\n          // resolve the name considering every source root as a package dir, as if it's a deployed package. django console does so.\n          boolean has_djando_facet = false;\n          final Module source_module = ModuleUtil.findModuleForPsiElement(source_file);\n          if (source_module != null) {\n            has_djando_facet = FacetManager.getInstance(source_module).getFacetByType(DjangoFacetType.ID) != null;\n          }\n          if (has_djando_facet) {\n            ResolveInRootVisitor visitor = new ResolveInRootAsTopPackageVisitor(qualifiedName, source_file.getManager(), source_file, true);\n            visitRoots(source_file, visitor);\n            return visitor.results;\n          }\n          return Collections.emptyList();\n        }\n      }\n    }\n    finally {\n      being_imported.remove(marker);\n    }\n  }","commit_id":"d51fa95bf1c0181066ff50d703481e5708ff1628","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, @Nullable PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    PythonPathCache cache = getPathCache(foothold, footholdFile);\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n\n    List<PsiElement> results =\n      visitRoots(moduleQualifiedName, foothold.getManager(), ModuleUtil.findModuleForPsiElement(foothold), foothold, true);\n\n    if (cache != null) {\n      cache.put(moduleQualifiedName, results);\n    }\n    return results;\n  }","id":47205,"modified_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, @Nullable PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    PythonPathCache cache = getPathCache(foothold, footholdFile);\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n    List<PsiElement> results = visitRoots(moduleQualifiedName, foothold.getManager(), module, foothold, true);\n\n    if (cache != null) {\n      cache.put(moduleQualifiedName, results);\n    }\n    return results;\n  }","commit_id":"7adce93c06f99c2bd763b26f2654713303363321","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, @Nullable PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    PythonPathCache cache = getPathCache(foothold, footholdFile);\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n    List<PsiElement> results = visitRoots(moduleQualifiedName, foothold.getManager(), module, foothold, true);\n\n    if (cache != null) {\n      cache.put(moduleQualifiedName, results);\n    }\n    return results;\n  }","id":47206,"modified_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, @Nullable PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    PythonPathCache cache = getPathCache(foothold, footholdFile);\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n\n    List<PsiElement> results;\n\n    if (isConsole(footholdFile)) {\n      results = visitRootsInAllModules(moduleQualifiedName, foothold, footholdFile);\n    }\n    else {\n      results = visitRoots(moduleQualifiedName, foothold.getManager(), module, foothold, true);\n    }\n\n    if (cache != null) {\n      cache.put(moduleQualifiedName, results);\n    }\n    return results;\n  }","commit_id":"f37be5ef364fea7ea52a2e90a49d6145fb939b4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void visitSdkRoots(PsiElement elt, RootVisitor visitor) {\n    // no module, another way to look in SDK roots\n    final PsiFile elt_psifile = elt.getContainingFile();\n    if (elt_psifile != null) {  // formality\n      final VirtualFile elt_vfile = elt_psifile.getOriginalFile().getVirtualFile();\n      if (elt_vfile != null) { // reality\n        final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(elt.getProject()).getFileIndex();\n        final List<OrderEntry> orderEntries = fileIndex.getOrderEntriesForFile(elt_vfile);\n        if (orderEntries.size() > 0) {\n          for (OrderEntry entry : orderEntries) {\n            if (!visitOrderEntryRoots(visitor, entry)) break;\n          }\n        }\n        else {\n          // out-of-project file - use roots of SDK assigned to project\n          final Sdk sdk = PyBuiltinCache.findSdkForFile(elt_psifile);\n          if (sdk != null) {\n            visitSdkRoots(visitor, sdk);\n          }\n        }\n      }\n    }\n  }","id":47207,"modified_method":"private static void visitSdkRoots(PsiElement elt, RootVisitor visitor) {\n    // no module, another way to look in SDK roots\n    final PsiFile elt_psifile = elt.getContainingFile();\n    if (elt_psifile != null) {  // formality\n      final VirtualFile elt_vfile = elt_psifile.getOriginalFile().getVirtualFile();\n      List<OrderEntry> orderEntries = null;\n      if (elt_vfile != null) { // reality\n        final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(elt.getProject()).getFileIndex();\n        orderEntries = fileIndex.getOrderEntriesForFile(elt_vfile);\n        if (orderEntries.size() > 0) {\n          for (OrderEntry entry : orderEntries) {\n            if (!visitOrderEntryRoots(visitor, entry)) break;\n          }\n        }\n        else {\n          orderEntries = null;\n        }\n      }\n\n      // out-of-project file or non-file(e.g. console) - use roots of SDK assigned to project\n      if (orderEntries == null) {\n        final Sdk sdk = PyBuiltinCache.findSdkForFile(elt_psifile);\n        if (sdk != null) {\n          visitSdkRoots(visitor, sdk);\n        }\n      }\n    }\n  }","commit_id":"f37be5ef364fea7ea52a2e90a49d6145fb939b4a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void drop(DatasetSpecification spec, DatasetTypeMeta typeMeta) throws Exception {\n    DatasetDefinition def = client.getDatasetDefinition(typeMeta, null);\n\n    if (def == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    DatasetAdmin admin = def.getAdmin(spec, null);\n    admin.drop();\n  }","id":47208,"modified_method":"@Override\n  public void drop(DatasetSpecification spec, DatasetTypeMeta typeMeta) throws Exception {\n    DatasetDefinition def = client.getDatasetDefinition(typeMeta, null).getFirst();\n\n    if (def == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    DatasetAdmin admin = def.getAdmin(spec, null);\n    admin.drop();\n  }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DatasetSpecification create(String instanceName, DatasetTypeMeta typeMeta, DatasetProperties props)\n    throws Exception {\n\n    DatasetDefinition def = client.getDatasetDefinition(typeMeta, null);\n\n    if (def == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    DatasetSpecification spec = def.configure(instanceName, props);\n    DatasetAdmin admin = def.getAdmin(spec, null);\n    admin.create();\n\n    return spec;\n  }","id":47209,"modified_method":"@Override\n  public DatasetSpecification create(String instanceName, DatasetTypeMeta typeMeta, DatasetProperties props)\n    throws Exception {\n\n    DatasetDefinition def = client.getDatasetDefinition(typeMeta, null).getFirst();\n\n    if (def == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    DatasetSpecification spec = def.configure(instanceName, props);\n    DatasetAdmin admin = def.getAdmin(spec, null);\n    admin.create();\n\n    return spec;\n  }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public <T extends DatasetAdmin> T getAdmin(String datasetInstanceName, ClassLoader classLoader)\n    throws DatasetManagementException, IOException {\n\n    DatasetInstanceMeta instanceInfo = client.getInstance(namespace(datasetInstanceName));\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    DatasetDefinition impl = getDatasetDefinition(instanceInfo.getType(), classLoader);\n    return (T) impl.getAdmin(instanceInfo.getSpec(), classLoader);\n  }","id":47210,"modified_method":"@Override\n  public <T extends DatasetAdmin> T getAdmin(String datasetInstanceName, ClassLoader classLoader)\n    throws DatasetManagementException, IOException {\n\n    DatasetInstanceMeta instanceInfo = client.getInstance(namespace(datasetInstanceName));\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    ImmutablePair<DatasetDefinition, ClassLoader> datasetDefinition = getDatasetDefinition(instanceInfo.getType(),\n                                                                                           classLoader);\n\n    return (T) datasetDefinition.getFirst().getAdmin(instanceInfo.getSpec(), datasetDefinition.getSecond());\n  }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public <T extends Dataset> T getDataset(String datasetInstanceName, ClassLoader classLoader)\n    throws DatasetManagementException, IOException {\n\n    DatasetInstanceMeta instanceInfo = client.getInstance(namespace(datasetInstanceName));\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    DatasetDefinition impl = getDatasetDefinition(instanceInfo.getType(), classLoader);\n    return (T) impl.getDataset(instanceInfo.getSpec(), classLoader);\n  }","id":47211,"modified_method":"@Override\n  public <T extends Dataset> T getDataset(String datasetInstanceName, ClassLoader classLoader)\n    throws DatasetManagementException, IOException {\n\n    DatasetInstanceMeta instanceInfo = client.getInstance(namespace(datasetInstanceName));\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    ImmutablePair<DatasetDefinition, ClassLoader> datasetDefinition = getDatasetDefinition(instanceInfo.getType(),\n                                                                                           classLoader);\n\n    return (T) datasetDefinition.getFirst().getDataset(instanceInfo.getSpec(), datasetDefinition.getSecond());\n  }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"public <T extends DatasetDefinition> T getDatasetDefinition(DatasetTypeMeta implementationInfo,\n                                                              ClassLoader classLoader)\n    throws DatasetManagementException {\n\n    DatasetDefinitionRegistry registry = registryFactory.create();\n    List<DatasetModuleMeta> modulesToLoad = implementationInfo.getModules();\n    for (DatasetModuleMeta moduleMeta : modulesToLoad) {\n      if (moduleMeta.getJarLocation() != null) {\n        // adding dataset module jar to classloader\n        try {\n          classLoader = classLoader == null ?\n            new JarClassLoader(locationFactory.create(moduleMeta.getJarLocation())) :\n            new JarClassLoader(locationFactory.create(moduleMeta.getJarLocation()), classLoader);\n        } catch (IOException e) {\n          LOG.error(\"Was not able to init classloader for module {} while trying to load type {}\",\n                    moduleMeta, implementationInfo, e);\n          throw Throwables.propagate(e);\n        }\n      }\n      DatasetModule module;\n      try {\n        Class<?> moduleClass = ClassLoaders.loadClass(moduleMeta.getClassName(), classLoader, this);\n        module = DatasetModules.getDatasetModule(moduleClass);\n      } catch (Exception e) {\n        LOG.error(\"Was not able to load dataset module class {} while trying to load type {}\",\n                  moduleMeta.getClassName(), implementationInfo, e);\n        throw Throwables.propagate(e);\n      }\n      module.register(registry);\n    }\n\n    return registry.get(implementationInfo.getName());\n  }","id":47212,"modified_method":"public <T extends DatasetDefinition> ImmutablePair<T, ClassLoader>\n  getDatasetDefinition(DatasetTypeMeta implementationInfo, ClassLoader classLoader)\n    throws DatasetManagementException {\n\n    DatasetDefinitionRegistry registry = registryFactory.create();\n    List<DatasetModuleMeta> modulesToLoad = implementationInfo.getModules();\n    for (DatasetModuleMeta moduleMeta : modulesToLoad) {\n      if (moduleMeta.getJarLocation() != null) {\n        // adding dataset module jar to classloader\n        try {\n          classLoader = classLoader == null ?\n            new JarClassLoader(locationFactory.create(moduleMeta.getJarLocation())) :\n            new JarClassLoader(locationFactory.create(moduleMeta.getJarLocation()), classLoader);\n        } catch (IOException e) {\n          LOG.error(\"Was not able to init classloader for module {} while trying to load type {}\",\n                    moduleMeta, implementationInfo, e);\n          throw Throwables.propagate(e);\n        }\n      }\n      DatasetModule module;\n      try {\n        Class<?> moduleClass = ClassLoaders.loadClass(moduleMeta.getClassName(), classLoader, this);\n        module = DatasetModules.getDatasetModule(moduleClass);\n      } catch (Exception e) {\n        LOG.error(\"Was not able to load dataset module class {} while trying to load type {}\",\n                  moduleMeta.getClassName(), implementationInfo, e);\n        throw Throwables.propagate(e);\n      }\n      module.register(registry);\n    }\n\n    return new ImmutablePair<T, ClassLoader>((T) registry.get(implementationInfo.getName()), classLoader);\n  }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"Object getValue(Map<String, DatasetDefinition> defs, DatasetSpecification spec) throws IOException;","id":47213,"modified_method":"Object getValue(Map<String, DatasetDefinition> defs, DatasetSpecification spec, ClassLoader cl)\n      throws IOException;","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void register(DatasetDefinitionRegistry registry) {\n\n    final Constructor ctor = findSuitableCtorOrFail(dataSetClass);\n\n    DataSetType typeAnn = dataSetClass.getAnnotation(DataSetType.class);\n    // default type name to dataset class name\n    String typeName = typeAnn != null ? typeAnn.value() : dataSetClass.getName();\n\n    final Map<String, DatasetDefinition> defs = Maps.newHashMap();\n\n    Class<?>[] paramTypes = ctor.getParameterTypes();\n    Annotation[][] paramAnns = ctor.getParameterAnnotations();\n\n    // computing parameters for dataset constructor:\n    // if param is of type DatasetSpecification we'll need to set spec as a value\n    // if param has EmbeddedDataSet annotation we need to set instance of embedded dataset as a value\n    final DatasetCtorParam[] ctorParams = new DatasetCtorParam[paramTypes.length];\n    for (int i = 0; i < paramTypes.length; i++) {\n      if (DatasetSpecification.class.isAssignableFrom(paramTypes[i])) {\n        ctorParams[i] = new DatasetSpecificationParam();\n        continue;\n      }\n      for (Annotation ann : paramAnns[i]) {\n        if (ann instanceof EmbeddedDataSet) {\n          String type = ((EmbeddedDataSet) ann).type();\n          if (EmbeddedDataSet.DEFAULT_TYPE_NAME.equals(type)) {\n            // default to dataset class name\n            type = paramTypes[i].getName();\n          }\n          DatasetDefinition def = registry.get(type);\n          if (def == null) {\n            String msg = String.format(\"Unknown data set type used with @Dataset: \" + type);\n            LOG.error(msg);\n            throw new IllegalStateException(msg);\n          }\n          defs.put(((EmbeddedDataSet) ann).value(), def);\n          ctorParams[i] = new DatasetParam(((EmbeddedDataSet) ann).value());\n          break;\n        }\n      }\n    }\n\n    CompositeDatasetDefinition def = new CompositeDatasetDefinition(typeName, defs) {\n      @Override\n      public Dataset getDataset(DatasetSpecification spec, ClassLoader classLoader) throws IOException {\n        Object[] params = new Object[ctorParams.length];\n        for (int i = 0; i < ctorParams.length; i++) {\n          params[i] = ctorParams[i] != null ? ctorParams[i].getValue(defs, spec) : null;\n        }\n\n        try {\n          return (Dataset) ctor.newInstance(params);\n        } catch (Exception e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    };\n\n    registry.add(def);\n  }","id":47214,"modified_method":"@Override\n  public void register(DatasetDefinitionRegistry registry) {\n\n    final Constructor ctor = findSuitableCtorOrFail(dataSetClass);\n\n    DataSetType typeAnn = dataSetClass.getAnnotation(DataSetType.class);\n    // default type name to dataset class name\n    String typeName = typeAnn != null ? typeAnn.value() : dataSetClass.getName();\n\n    final Map<String, DatasetDefinition> defs = Maps.newHashMap();\n\n    Class<?>[] paramTypes = ctor.getParameterTypes();\n    Annotation[][] paramAnns = ctor.getParameterAnnotations();\n\n    // computing parameters for dataset constructor:\n    // if param is of type DatasetSpecification we'll need to set spec as a value\n    // if param has EmbeddedDataSet annotation we need to set instance of embedded dataset as a value\n    final DatasetCtorParam[] ctorParams = new DatasetCtorParam[paramTypes.length];\n    for (int i = 0; i < paramTypes.length; i++) {\n      if (DatasetSpecification.class.isAssignableFrom(paramTypes[i])) {\n        ctorParams[i] = new DatasetSpecificationParam();\n        continue;\n      }\n      for (Annotation ann : paramAnns[i]) {\n        if (ann instanceof EmbeddedDataSet) {\n          String type = ((EmbeddedDataSet) ann).type();\n          if (EmbeddedDataSet.DEFAULT_TYPE_NAME.equals(type)) {\n            // default to dataset class name\n            type = paramTypes[i].getName();\n          }\n          DatasetDefinition def = registry.get(type);\n          if (def == null) {\n            String msg = String.format(\"Unknown data set type used with @Dataset: \" + type);\n            LOG.error(msg);\n            throw new IllegalStateException(msg);\n          }\n          defs.put(((EmbeddedDataSet) ann).value(), def);\n          ctorParams[i] = new DatasetParam(((EmbeddedDataSet) ann).value());\n          break;\n        }\n      }\n    }\n\n    CompositeDatasetDefinition def = new CompositeDatasetDefinition(typeName, defs) {\n      @Override\n      public Dataset getDataset(DatasetSpecification spec, ClassLoader classLoader) throws IOException {\n        Object[] params = new Object[ctorParams.length];\n        for (int i = 0; i < ctorParams.length; i++) {\n          params[i] = ctorParams[i] != null ? ctorParams[i].getValue(defs, spec, classLoader) : null;\n        }\n\n        try {\n          return (Dataset) ctor.newInstance(params);\n        } catch (Exception e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    };\n\n    registry.add(def);\n  }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public Object getValue(Map<String, DatasetDefinition> defs, DatasetSpecification spec) throws IOException {\n      return defs.get(name).getDataset(spec.getSpecification(name), null);\n    }","id":47215,"modified_method":"@Override\n    public Object getValue(Map<String, DatasetDefinition> defs, DatasetSpecification spec, ClassLoader cl)\n      throws IOException {\n\n      return defs.get(name).getDataset(spec.getSpecification(name), cl);\n    }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public Object getValue(Map<String, DatasetDefinition> defs, DatasetSpecification spec) {\n      return spec;\n    }","id":47216,"modified_method":"@Override\n    public Object getValue(Map<String, DatasetDefinition> defs, DatasetSpecification spec, ClassLoader cl) {\n      return spec;\n    }","commit_id":"8b01930b984eeeb24a0e8b91b1e002e644fe9ab8","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @param path                project file path\n   * @param projectToClose      currently active project\n   * @param forceOpenInNewFrame forces opening in new frame\n   * @return project by path if the path was recognized as IDEA project file or one of the project formats supported by\n   *         installed importers (regardless of opening/import result)\n   *         null otherwise\n   */\n  @Nullable\n  public static Project openOrImport(@NotNull final String path, final Project projectToClose, boolean forceOpenInNewFrame) {\n    final VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n\n    if (virtualFile == null) return null;\n    ProjectOpenProcessor strong = ProjectOpenProcessor.getStrongImportProvider(virtualFile);\n    if (strong != null) {\n      return strong.doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame);\n    }\n\n    if (path.endsWith(ProjectFileType.DOT_DEFAULT_EXTENSION) ||\n        virtualFile.isDirectory() && virtualFile.findChild(com.intellij.openapi.project.ProjectUtil.DIRECTORY_BASED_PROJECT_DIR) != null) {\n      return openProject(path, projectToClose, forceOpenInNewFrame);\n    }\n\n    if (virtualFile.isDirectory()) {\n      for (VirtualFile child : virtualFile.getChildren()) {\n        final String childPath = child.getPath();\n        if (childPath.endsWith(ProjectFileType.DOT_DEFAULT_EXTENSION)) {\n          return openProject(childPath, projectToClose, forceOpenInNewFrame);\n        }\n      }\n    }\n\n    ProjectOpenProcessor provider = ProjectOpenProcessor.getImportProvider(virtualFile);\n    if (provider != null) {\n      return provider.doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame);\n    }\n    return null;\n  }","id":47217,"modified_method":"/**\n   * @param path                project file path\n   * @param projectToClose      currently active project\n   * @param forceOpenInNewFrame forces opening in new frame\n   * @return project by path if the path was recognized as IDEA project file or one of the project formats supported by\n   *         installed importers (regardless of opening/import result)\n   *         null otherwise\n   */\n  @Nullable\n  public static Project openOrImport(@NotNull final String path, final Project projectToClose, boolean forceOpenInNewFrame) {\n    final VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n\n    if (virtualFile == null) return null;\n    ProjectOpenProcessor strong = ProjectOpenProcessor.getStrongImportProvider(virtualFile);\n    if (strong != null) {\n      return strong.doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame);\n    }\n\n    if (path.endsWith(ProjectFileType.DOT_DEFAULT_EXTENSION) ||\n        virtualFile.isDirectory() && virtualFile.findChild(com.intellij.openapi.project.ProjectUtil.DIRECTORY_BASED_PROJECT_DIR) != null) {\n      return openProject(path, projectToClose, forceOpenInNewFrame);\n    }\n\n    if (virtualFile.isDirectory()) {\n      for (VirtualFile child : virtualFile.getChildren()) {\n        final String childPath = child.getPath();\n        if (childPath.endsWith(ProjectFileType.DOT_DEFAULT_EXTENSION)) {\n          return openProject(childPath, projectToClose, forceOpenInNewFrame);\n        }\n      }\n    }\n\n    ProjectOpenProcessor provider = ProjectOpenProcessor.getImportProvider(virtualFile);\n    if (provider != null) {\n      final Project project = provider.doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame);\n\n      if (project != null) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (!project.isDisposed()) {\n              final ToolWindow toolWindow = ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.PROJECT_VIEW);\n              if (toolWindow != null) {\n                toolWindow.activate(null);\n              }\n            }\n          }\n        }, ModalityState.NON_MODAL);\n      }\n\n      return project;\n    }\n    return null;\n  }","commit_id":"d687512b89cc0ff79584a25383b46c7fe864bc10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected AbstractNewProjectStep(@NotNull Customization customization) {\n    super(\"Select Project Type\", true);\n\n    NullableConsumer<ProjectSettingsStepBase> callback = customization.createCallback();\n    ProjectSpecificAction projectSpecificAction = customization.createProjectSpecificAction(callback);\n    addProjectSpecificAction(projectSpecificAction);\n\n    DirectoryProjectGenerator[] generators = customization.getProjectGenerators();\n    customization.setUpBasicAction(projectSpecificAction, generators);\n\n    addAll(customization.getActions(generators, callback));\n    addAll(customization.getExtraActions(callback));\n  }","id":47218,"modified_method":"protected AbstractNewProjectStep(@NotNull Customization customization) {\n    super(\"Select Project Type\", true);\n\n    NullableConsumer<ProjectSettingsStepBase> callback = customization.createCallback();\n    ProjectSpecificAction projectSpecificAction = customization.createProjectSpecificAction(callback);\n    addProjectSpecificAction(projectSpecificAction);\n\n    DirectoryProjectGenerator[] generators = customization.getProjectGenerators();\n    customization.setUpBasicAction(projectSpecificAction, generators);\n\n    addAll(customization.getActions(generators, callback));\n    if (customization.showUserDefinedProjects()) {\n      ArchivedTemplatesFactory factory = new ArchivedTemplatesFactory();\n      ProjectTemplate[] templates = factory.createTemplates(CUSTOM_GROUP, null);\n      for (ProjectTemplate template : templates) {\n        TemplateProjectDirectoryGenerator generator = new TemplateProjectDirectoryGenerator((LocalArchivedTemplate)template);\n        addAll(customization.getActions(generator, callback));\n      }\n    }\n    addAll(customization.getExtraActions(callback));\n  }","commit_id":"bcd268070694dbf1261bb37cf7f44e965bc10808","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Project doGenerateProject(@Nullable final Project project,\n                                          @NotNull final String locationString,\n                                          @Nullable final DirectoryProjectGenerator generator,\n                                          @NotNull final Function<VirtualFile, Object> settingsComputable) {\n    final File location = new File(FileUtil.toSystemDependentName(locationString));\n    if (!location.exists() && !location.mkdirs()) {\n      String message = ActionsBundle.message(\"action.NewDirectoryProject.cannot.create.dir\", location.getAbsolutePath());\n      Messages.showErrorDialog(project, message, ActionsBundle.message(\"action.NewDirectoryProject.title\"));\n      return null;\n    }\n\n    final VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n      public VirtualFile compute() {\n        return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(location);\n      }\n    });\n    if (baseDir == null) {\n      LOG.error(\"Couldn't find '\" + location + \"' in VFS\");\n      return null;\n    }\n    baseDir.refresh(false, true);\n\n    if (baseDir.getChildren().length > 0) {\n      String message = ActionsBundle.message(\"action.NewDirectoryProject.not.empty\", location.getAbsolutePath());\n      int rc = Messages.showYesNoDialog(project, message, ActionsBundle.message(\"action.NewDirectoryProject.title\"), Messages.getQuestionIcon());\n      if (rc == Messages.YES) {\n        return PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n      }\n    }\n\n    String generatorName = generator == null ? \"empty\" : ConvertUsagesUtil.ensureProperKey(generator.getName());\n    UsageTrigger.trigger(\"AbstractNewProjectStep.\" + generatorName);\n\n    Object settings = null;\n    if (generator != null) {\n      try {\n        settings = settingsComputable.fun(baseDir);\n      }\n      catch (ProcessCanceledException e) {\n        return null;\n      }\n    }\n    RecentProjectsManager.getInstance().setLastProjectCreationLocation(location.getParent());\n    final Object finalSettings = settings;\n    return PlatformProjectOpenProcessor.doOpenProject(baseDir, null, false, -1, new ProjectOpenedCallback() {\n      @Override\n      public void projectOpened(Project project, Module module) {\n        if (generator != null) {\n          generator.generateProject(project, baseDir, finalSettings, module);\n        }\n      }\n    }, false);\n  }","id":47219,"modified_method":"public static Project doGenerateProject(@Nullable final Project project,\n                                          @NotNull final String locationString,\n                                          @Nullable final DirectoryProjectGenerator generator,\n                                          @NotNull final Function<VirtualFile, Object> settingsComputable) {\n    final File location = new File(FileUtil.toSystemDependentName(locationString));\n    if (!location.exists() && !location.mkdirs()) {\n      String message = ActionsBundle.message(\"action.NewDirectoryProject.cannot.create.dir\", location.getAbsolutePath());\n      Messages.showErrorDialog(project, message, ActionsBundle.message(\"action.NewDirectoryProject.title\"));\n      return null;\n    }\n\n    final VirtualFile baseDir = ApplicationManager.getApplication().runWriteAction(new Computable<VirtualFile>() {\n      public VirtualFile compute() {\n        return LocalFileSystem.getInstance().refreshAndFindFileByIoFile(location);\n      }\n    });\n    if (baseDir == null) {\n      LOG.error(\"Couldn't find '\" + location + \"' in VFS\");\n      return null;\n    }\n    baseDir.refresh(false, true);\n\n    if (baseDir.getChildren().length > 0) {\n      String message = ActionsBundle.message(\"action.NewDirectoryProject.not.empty\", location.getAbsolutePath());\n      int rc = Messages.showYesNoDialog(project, message, ActionsBundle.message(\"action.NewDirectoryProject.title\"), Messages.getQuestionIcon());\n      if (rc == Messages.YES) {\n        return PlatformProjectOpenProcessor.getInstance().doOpenProject(baseDir, null, false);\n      }\n    }\n\n    String generatorName = generator == null ? \"empty\" : ConvertUsagesUtil.ensureProperKey(generator.getName());\n    UsageTrigger.trigger(\"AbstractNewProjectStep.\" + generatorName);\n\n    Object settings = null;\n    if (generator != null) {\n      try {\n        settings = settingsComputable.fun(baseDir);\n      }\n      catch (ProcessCanceledException e) {\n        return null;\n      }\n    }\n\n    RecentProjectsManager.getInstance().setLastProjectCreationLocation(location.getParent());\n\n    ProjectOpenedCallback callback = null;\n    if(generator instanceof TemplateProjectDirectoryGenerator){\n      ((TemplateProjectDirectoryGenerator)generator).generateProject(baseDir.getName(), locationString);\n    } else {\n      final Object finalSettings = settings;\n      callback = new ProjectOpenedCallback() {\n        @Override\n        public void projectOpened(Project project, Module module) {\n          if (generator != null) {\n            generator.generateProject(project, baseDir, finalSettings, module);\n          }\n        }\n      };\n    }\n    return PlatformProjectOpenProcessor.doOpenProject(baseDir, null, false, -1, callback, false);\n  }","commit_id":"bcd268070694dbf1261bb37cf7f44e965bc10808","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JPanel createAndFillContentPanel() {\n    if (!(myProjectGenerator instanceof WebProjectTemplate)) return createContentPanelWithAdvancedSettingsPanel();\n\n    WebProjectSettingsStepWrapper settingsStep = new WebProjectSettingsStepWrapper();\n    ((WebProjectTemplate)myProjectGenerator).getPeer().buildUI(settingsStep);\n\n    //back compatibility: some plugins can implement only GeneratorPeer#getComponent() method\n    if (settingsStep.isEmpty()) return createContentPanelWithAdvancedSettingsPanel();\n\n    final JPanel jPanel = new JPanel(new VerticalFlowLayout(0, 5));\n    List<LabeledComponent> labeledComponentList = ContainerUtil.newArrayList();\n    labeledComponentList.add(createLocationComponent());\n    labeledComponentList.addAll(settingsStep.getFields());\n\n    final JPanel scrollPanel = new JPanel(new BorderLayout());\n    scrollPanel.add(jPanel, BorderLayout.NORTH);\n\n    for (LabeledComponent component : labeledComponentList) {\n      component.setLabelLocation(BorderLayout.WEST);\n      jPanel.add(component);\n    }\n\n    for (JComponent component : settingsStep.getComponents()) {\n      jPanel.add(component);\n    }\n\n    UIUtil.mergeComponentsWithAnchor(labeledComponentList);\n\n    return scrollPanel;\n  }","id":47220,"modified_method":"protected JPanel createAndFillContentPanel() {\n    WebProjectSettingsStepWrapper settingsStep = new WebProjectSettingsStepWrapper();\n    if (myProjectGenerator instanceof WebProjectTemplate) {\n      ((WebProjectTemplate)myProjectGenerator).getPeer().buildUI(settingsStep);\n    }\n    else if (myProjectGenerator instanceof TemplateProjectDirectoryGenerator) {\n      ((TemplateProjectDirectoryGenerator)myProjectGenerator).buildUI(settingsStep);\n    }\n    else {\n      return createContentPanelWithAdvancedSettingsPanel();\n    }\n\n    //back compatibility: some plugins can implement only GeneratorPeer#getComponent() method\n    if (settingsStep.isEmpty()) return createContentPanelWithAdvancedSettingsPanel();\n\n    final JPanel jPanel = new JPanel(new VerticalFlowLayout(0, 5));\n    List<LabeledComponent> labeledComponentList = ContainerUtil.newArrayList();\n    labeledComponentList.add(createLocationComponent());\n    labeledComponentList.addAll(settingsStep.getFields());\n\n    final JPanel scrollPanel = new JPanel(new BorderLayout());\n    scrollPanel.add(jPanel, BorderLayout.NORTH);\n\n    for (LabeledComponent component : labeledComponentList) {\n      component.setLabelLocation(BorderLayout.WEST);\n      jPanel.add(component);\n    }\n\n    for (JComponent component : settingsStep.getComponents()) {\n      jPanel.add(component);\n    }\n\n    UIUtil.mergeComponentsWithAnchor(labeledComponentList);\n\n    return scrollPanel;\n  }","commit_id":"bcd268070694dbf1261bb37cf7f44e965bc10808","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void saveProject(final Project project,\n                                 final File zipFile,\n                                 Module moduleToSave,\n                                 final String description,\n                                 boolean replaceParameters,\n                                 final ProgressIndicator indicator) {\n\n    final Map<String, String> parameters = computeParameters(project, replaceParameters);\n    indicator.setText(\"Saving project...\");\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            project.save();\n          }\n        });\n      }\n    });\n    indicator.setText(\"Processing project files...\");\n    ZipOutputStream stream = null;\n    try {\n      FileUtil.ensureExists(zipFile.getParentFile());\n      stream = new ZipOutputStream(new FileOutputStream(zipFile));\n\n      final VirtualFile dir = getDirectoryToSave(project, moduleToSave);\n      writeFile(LocalArchivedTemplate.DESCRIPTION_PATH, description, project, dir, stream, true);\n      if (replaceParameters) {\n        String text = getInputFieldsText(parameters);\n        writeFile(LocalArchivedTemplate.TEMPLATE_DESCRIPTOR, text, project, dir, stream, false);\n      }\n\n      FileIndex index = moduleToSave == null\n                        ? ProjectRootManager.getInstance(project).getFileIndex()\n                        : ModuleRootManager.getInstance(moduleToSave).getFileIndex();\n      final ZipOutputStream finalStream = stream;\n\n      index.iterateContent(new ContentIterator() {\n        @Override\n        public boolean processFile(final VirtualFile virtualFile) {\n          if (!virtualFile.isDirectory()) {\n            final String fileName = virtualFile.getName();\n            indicator.setText2(fileName);\n            try {\n              String relativePath = VfsUtilCore.getRelativePath(virtualFile, dir, '/');\n              if (relativePath == null) {\n                throw new RuntimeException(\"Can't find relative path for \" + virtualFile + \" in \" + dir);\n              }\n              final boolean system = Project.DIRECTORY_STORE_FOLDER.equals(virtualFile.getParent().getName());\n              if (system) {\n                if (!fileName.equals(\"description.html\") &&\n                    !fileName.equals(PROJECT_TEMPLATE_XML) &&\n                    !fileName.equals(\"misc.xml\") &&\n                    !fileName.equals(\"modules.xml\") &&\n                    !fileName.equals(\"workspace.xml\")) {\n                  return true;\n                }\n              }\n\n              ZipUtil.addFileToZip(finalStream, new File(virtualFile.getPath()), dir.getName() + \"/\" + relativePath, null, null, new ZipUtil.FileContentProcessor() {\n                @Override\n                public InputStream getContent(final File file) throws IOException {\n                  if (virtualFile.getFileType().isBinary() || PROJECT_TEMPLATE_XML.equals(virtualFile.getName())) return STANDARD.getContent(file);\n                  String result = getEncodedContent(virtualFile, project, parameters);\n                  return new ByteArrayInputStream(result.getBytes(CharsetToolkit.UTF8_CHARSET));\n                }\n              });\n            }\n            catch (IOException e) {\n              LOG.error(e);\n            }\n          }\n          indicator.checkCanceled();\n          return true;\n        }\n      });\n    }\n    catch (Exception ex) {\n      LOG.error(ex);\n      UIUtil.invokeLaterIfNeeded(new Runnable() {\n        public void run() {\n          Messages.showErrorDialog(project, \"Can't save project as template\", \"Internal Error\");\n        }\n      });\n    }\n    finally {\n      StreamUtil.closeStream(stream);\n    }\n  }","id":47221,"modified_method":"public static void saveProject(final Project project,\n                                 final File zipFile,\n                                 Module moduleToSave,\n                                 final String description,\n                                 boolean replaceParameters,\n                                 final ProgressIndicator indicator) {\n\n    final Map<String, String> parameters = computeParameters(project, replaceParameters);\n    indicator.setText(\"Saving project...\");\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            project.save();\n          }\n        });\n      }\n    });\n    indicator.setText(\"Processing project files...\");\n    ZipOutputStream stream = null;\n    try {\n      FileUtil.ensureExists(zipFile.getParentFile());\n      stream = new ZipOutputStream(new FileOutputStream(zipFile));\n\n      final VirtualFile dir = getDirectoryToSave(project, moduleToSave);\n      writeFile(LocalArchivedTemplate.DESCRIPTION_PATH, description, project, dir, stream, true);\n      if (replaceParameters) {\n        String text = getInputFieldsText(parameters);\n        writeFile(LocalArchivedTemplate.TEMPLATE_DESCRIPTOR, text, project, dir, stream, false);\n      }\n\n      FileIndex index = moduleToSave == null\n                        ? ProjectRootManager.getInstance(project).getFileIndex()\n                        : ModuleRootManager.getInstance(moduleToSave).getFileIndex();\n      final ZipOutputStream finalStream = stream;\n\n      index.iterateContent(new ContentIterator() {\n        @Override\n        public boolean processFile(final VirtualFile virtualFile) {\n          if (!virtualFile.isDirectory()) {\n            final String fileName = virtualFile.getName();\n            indicator.setText2(fileName);\n            try {\n              String relativePath = VfsUtilCore.getRelativePath(virtualFile, dir, '/');\n              if (relativePath == null) {\n                throw new RuntimeException(\"Can't find relative path for \" + virtualFile + \" in \" + dir);\n              }\n              final boolean system = Project.DIRECTORY_STORE_FOLDER.equals(virtualFile.getParent().getName());\n              if (system) {\n                if (!fileName.equals(\"description.html\") &&\n                    !fileName.equals(PROJECT_TEMPLATE_XML) &&\n                    !fileName.equals(\"misc.xml\") &&\n                    !fileName.equals(\"modules.xml\") &&\n                    !fileName.equals(\"workspace.xml\") &&\n                    !fileName.endsWith(\".iml\")) {\n                  return true;\n                }\n              }\n\n              ZipUtil.addFileToZip(finalStream, new File(virtualFile.getPath()), dir.getName() + \"/\" + relativePath, null, null, new ZipUtil.FileContentProcessor() {\n                @Override\n                public InputStream getContent(final File file) throws IOException {\n                  if (virtualFile.getFileType().isBinary() || PROJECT_TEMPLATE_XML.equals(virtualFile.getName())) return STANDARD.getContent(file);\n                  String result = getEncodedContent(virtualFile, project, parameters);\n                  return new ByteArrayInputStream(result.getBytes(CharsetToolkit.UTF8_CHARSET));\n                }\n              });\n            }\n            catch (IOException e) {\n              LOG.error(e);\n            }\n          }\n          indicator.checkCanceled();\n          return true;\n        }\n      });\n    }\n    catch (Exception ex) {\n      LOG.error(ex);\n      UIUtil.invokeLaterIfNeeded(new Runnable() {\n        public void run() {\n          Messages.showErrorDialog(project, \"Can't save project as template\", \"Internal Error\");\n        }\n      });\n    }\n    finally {\n      StreamUtil.closeStream(stream);\n    }\n  }","commit_id":"bcd268070694dbf1261bb37cf7f44e965bc10808","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void loadProject() {\n    GeneralSettings generalSettings = GeneralSettings.getInstance();\n\n    if (myArgs != null && myArgs.length > 0 && myArgs[0] != null) {\n      if (ProjectUtil.openOrImport(myArgs[0], null, false)) {\n        return;\n      }\n    }\n\n    if (generalSettings.isReopenLastProject()) {\n      String lastProjectPath = RecentProjectsManager.getInstance().getLastProjectPath();\n      if (lastProjectPath != null) {\n        ProjectUtil.openProject(lastProjectPath, null, false);\n      }\n    }\n  }","id":47222,"modified_method":"private void loadProject() {\n    GeneralSettings generalSettings = GeneralSettings.getInstance();\n\n    if (myArgs != null && myArgs.length > 0 && myArgs[0] != null) {\n      if (ProjectUtil.openOrImport(myArgs[0], null, false) != null) {\n        return;\n      }\n    }\n\n    if (generalSettings.isReopenLastProject()) {\n      String lastProjectPath = RecentProjectsManager.getInstance().getLastProjectPath();\n      if (lastProjectPath != null) {\n        ProjectUtil.openProject(lastProjectPath, null, false);\n      }\n    }\n  }","commit_id":"1e71c37da78858e6e227c3f13d50ed7f4dbdf7d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run() {\n    try {\n      myProjectPath = myProjectPath.replace(File.separatorChar, '/');\n      VirtualFile vfsProject = LocalFileSystem.getInstance().findFileByPath(myProjectPath);\n      if (vfsProject == null) {\n        logError(InspectionsBundle.message(\"inspection.application.file.cannot.be.found\", myProjectPath));\n        InspectionMain.printHelp();\n      }\n\n      logMessage(1, InspectionsBundle.message(\"inspection.application.opening.project\"));\n      if (!ProjectConversionUtil.convertSilently(myProjectPath, createConversionListener())) {\n        System.exit(1);\n      }\n      myProject = ProjectManagerEx.getInstanceEx().loadAndOpenProject(myProjectPath, false);\n\n      VirtualFileManager.getInstance().refresh(false);\n\n      //fetch profile by name from project file (project profiles can be disabled)\n      Profile inspectionProfile = InspectionProjectProfileManager.getInstance(myProject).getProfiles().get(myProfileName);\n\n      //otherwise look for profile file or use default\n      if (inspectionProfile == null) {\n        inspectionProfile = InspectionProfileManager.getInstance().loadProfile(myProfileName);\n      }\n\n      if (inspectionProfile == null) {\n        logError(InspectionsBundle.message(\"inspection.application.file.cannot.be.found\", myProfileName));\n        InspectionMain.printHelp();\n      }\n\n      patchProject(loadPatterns(\"idea.exclude.patterns\"), loadPatterns(\"idea.include.patterns\"));\n\n      logMessageLn(1, InspectionsBundle.message(\"inspection.done\"));\n      logMessage(1, InspectionsBundle.message(\"inspection.application.initializing.project\"));\n\n      final InspectionManagerEx im = (InspectionManagerEx)InspectionManager.getInstance(myProject);\n      final AnalysisScope scope;\n\n      final GlobalInspectionContextImpl inspectionContext = im.createNewGlobalContext(true);\n      inspectionContext.setExternalProfile((InspectionProfile)inspectionProfile);\n      im.setProfile(inspectionProfile.getName());\n\n      if (mySourceDirectory == null) {\n        scope = new AnalysisScope(myProject);\n      }\n      else {\n        mySourceDirectory = mySourceDirectory.replace(File.separatorChar, '/');\n\n        VirtualFile vfsDir = LocalFileSystem.getInstance().findFileByPath(mySourceDirectory);\n        if (vfsDir == null) {\n          logError(InspectionsBundle.message(\"inspection.application.directory.cannot.be.found\", mySourceDirectory));\n          InspectionMain.printHelp();\n        }\n\n        PsiDirectory psiDirectory = PsiManager.getInstance(myProject).findDirectory(vfsDir);\n        scope = new AnalysisScope(psiDirectory);\n      }\n\n      logMessageLn(1, InspectionsBundle.message(\"inspection.done\"));\n\n      ProgressManager.getInstance().runProcess(new Runnable() {\n        public void run() {\n          PsiClass psiObjectClass = PsiManager.getInstance(myProject).findClass(\"java.lang.Object\", GlobalSearchScope.allScope(myProject));\n          if (psiObjectClass == null) {\n            if (ModuleManager.getInstance(myProject).getModules().length == 0) {\n              logError(InspectionsBundle.message(\"inspection.no.modules.error.message\"));\n              if (myErrorCodeRequired) System.exit(1);\n              return;\n            }\n            logError(InspectionsBundle.message(\"inspection.no.jdk.error.message\"));\n            logError(InspectionsBundle.message(\"offline.inspections.jdk.not.found\",\n                                               ProjectRootManager.getInstance(myProject).getProjectJdkName()));\n            if (myErrorCodeRequired) System.exit(1);\n            return;\n          }\n          final Module[] modules = ModuleManager.getInstance(myProject).getModules();\n          for (Module module : modules) {\n            final ModuleRootManager rootManager = ModuleRootManager.getInstance(module);\n            final ProjectJdk jdk = rootManager.getJdk();\n            final OrderEntry[] entries = rootManager.getOrderEntries();\n            for (OrderEntry entry : entries) {\n              if (entry instanceof JdkOrderEntry) {\n                if (jdk == null) {\n                  logError(InspectionsBundle.message(\"offline.inspections.module.jdk.not.found\",\n                                                     ((JdkOrderEntry)entry).getJdkName(),\n                                                     module.getName()));\n                  if (myErrorCodeRequired) System.exit(1);\n                  return;\n                }\n              } else if (entry instanceof LibraryOrderEntry) {\n                final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)entry;\n                final Library library = libraryOrderEntry.getLibrary();\n                if (library == null || library.getFiles(OrderRootType.CLASSES).length != library.getUrls(OrderRootType.CLASSES).length) {\n                  logError(InspectionsBundle.message(\"offline.inspections.library.was.not.resolved\",\n                                                     libraryOrderEntry.getPresentableName(),\n                                                     module.getName()));\n                }\n              }\n            }\n          }\n          inspectionContext.launchInspectionsOffline(scope, myOutPath, myRunWithEditorSettings, myRunGlobalToolsOnly, im);\n          logMessageLn(1, \"\\n\" +\n                          InspectionsBundle.message(\"inspection.capitalized.done\") +\n                          \"\\n\");\n        }\n      }, new ProgressIndicatorBase() {\n        private String lastPrefix = \"\";\n        private int myLastPercent = -1;\n\n        public void setText(String text) {\n          if (myVerboseLevel == 0) return;\n\n          if (myVerboseLevel == 1) {\n            String prefix = getPrefix(text);\n            if (prefix == null) return;\n            if (prefix.equals(lastPrefix)) {\n              logMessage(1, \".\");\n              return;\n            }\n            lastPrefix = prefix;\n            logMessageLn(1, \"\");\n            logMessageLn(1, prefix);\n            return;\n          }\n\n          if (myVerboseLevel == 3) {\n            if (!isIndeterminate() && getFraction() > 0) {\n              final StringBuilder buf = StringBuilderSpinAllocator.alloc();\n              try {\n                final int percent = (int)(getFraction() * 100);\n                if (myLastPercent == percent) return;\n                myLastPercent = percent;\n                buf.append(InspectionsBundle.message(\"inspection.display.name\")).append(\" \").append(percent).append(\"%\");\n                logMessageLn(2, buf.toString());\n              }\n              finally {\n                StringBuilderSpinAllocator.dispose(buf);\n              }\n            }\n            return;\n          }\n\n          logMessageLn(2, text);\n        }\n      });\n      describeInspections(myOutPath + File.separatorChar + DESCRIPTIONS + XmlFileType.DOT_DEFAULT_EXTENSION, !myRunWithEditorSettings ? inspectionProfile.getName() : null);\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      logError(e.getMessage());\n      InspectionMain.printHelp();\n    }\n    catch (Throwable e) {\n      LOG.error(e);\n      logError(e.getMessage());\n      if (myErrorCodeRequired) System.exit(1);\n    }\n  }","id":47223,"modified_method":"public void run() {\n    try {\n      myProjectPath = myProjectPath.replace(File.separatorChar, '/');\n      VirtualFile vfsProject = LocalFileSystem.getInstance().findFileByPath(myProjectPath);\n      if (vfsProject == null) {\n        logError(InspectionsBundle.message(\"inspection.application.file.cannot.be.found\", myProjectPath));\n        InspectionMain.printHelp();\n      }\n\n      logMessage(1, InspectionsBundle.message(\"inspection.application.opening.project\"));\n      if (!ProjectConversionUtil.convertSilently(myProjectPath, createConversionListener())) {\n        System.exit(1);\n      }\n      myProject = ProjectUtil.openOrImport(myProjectPath, null, false);\n\n      VirtualFileManager.getInstance().refresh(false);\n\n      //fetch profile by name from project file (project profiles can be disabled)\n      Profile inspectionProfile = InspectionProjectProfileManager.getInstance(myProject).getProfiles().get(myProfileName);\n\n      //otherwise look for profile file or use default\n      if (inspectionProfile == null) {\n        inspectionProfile = InspectionProfileManager.getInstance().loadProfile(myProfileName);\n      }\n\n      if (inspectionProfile == null) {\n        logError(InspectionsBundle.message(\"inspection.application.file.cannot.be.found\", myProfileName));\n        InspectionMain.printHelp();\n      }\n\n      patchProject(loadPatterns(\"idea.exclude.patterns\"), loadPatterns(\"idea.include.patterns\"));\n\n      logMessageLn(1, InspectionsBundle.message(\"inspection.done\"));\n      logMessage(1, InspectionsBundle.message(\"inspection.application.initializing.project\"));\n\n      final InspectionManagerEx im = (InspectionManagerEx)InspectionManager.getInstance(myProject);\n      final AnalysisScope scope;\n\n      final GlobalInspectionContextImpl inspectionContext = im.createNewGlobalContext(true);\n      inspectionContext.setExternalProfile((InspectionProfile)inspectionProfile);\n      im.setProfile(inspectionProfile.getName());\n\n      if (mySourceDirectory == null) {\n        scope = new AnalysisScope(myProject);\n      }\n      else {\n        mySourceDirectory = mySourceDirectory.replace(File.separatorChar, '/');\n\n        VirtualFile vfsDir = LocalFileSystem.getInstance().findFileByPath(mySourceDirectory);\n        if (vfsDir == null) {\n          logError(InspectionsBundle.message(\"inspection.application.directory.cannot.be.found\", mySourceDirectory));\n          InspectionMain.printHelp();\n        }\n\n        PsiDirectory psiDirectory = PsiManager.getInstance(myProject).findDirectory(vfsDir);\n        scope = new AnalysisScope(psiDirectory);\n      }\n\n      logMessageLn(1, InspectionsBundle.message(\"inspection.done\"));\n\n      ProgressManager.getInstance().runProcess(new Runnable() {\n        public void run() {\n          PsiClass psiObjectClass = PsiManager.getInstance(myProject).findClass(\"java.lang.Object\", GlobalSearchScope.allScope(myProject));\n          if (psiObjectClass == null) {\n            if (ModuleManager.getInstance(myProject).getModules().length == 0) {\n              logError(InspectionsBundle.message(\"inspection.no.modules.error.message\"));\n              if (myErrorCodeRequired) System.exit(1);\n              return;\n            }\n            logError(InspectionsBundle.message(\"inspection.no.jdk.error.message\"));\n            logError(InspectionsBundle.message(\"offline.inspections.jdk.not.found\",\n                                               ProjectRootManager.getInstance(myProject).getProjectJdkName()));\n            if (myErrorCodeRequired) System.exit(1);\n            return;\n          }\n          final Module[] modules = ModuleManager.getInstance(myProject).getModules();\n          for (Module module : modules) {\n            final ModuleRootManager rootManager = ModuleRootManager.getInstance(module);\n            final ProjectJdk jdk = rootManager.getJdk();\n            final OrderEntry[] entries = rootManager.getOrderEntries();\n            for (OrderEntry entry : entries) {\n              if (entry instanceof JdkOrderEntry) {\n                if (jdk == null) {\n                  logError(InspectionsBundle.message(\"offline.inspections.module.jdk.not.found\",\n                                                     ((JdkOrderEntry)entry).getJdkName(),\n                                                     module.getName()));\n                  if (myErrorCodeRequired) System.exit(1);\n                  return;\n                }\n              } else if (entry instanceof LibraryOrderEntry) {\n                final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)entry;\n                final Library library = libraryOrderEntry.getLibrary();\n                if (library == null || library.getFiles(OrderRootType.CLASSES).length != library.getUrls(OrderRootType.CLASSES).length) {\n                  logError(InspectionsBundle.message(\"offline.inspections.library.was.not.resolved\",\n                                                     libraryOrderEntry.getPresentableName(),\n                                                     module.getName()));\n                }\n              }\n            }\n          }\n          inspectionContext.launchInspectionsOffline(scope, myOutPath, myRunWithEditorSettings, myRunGlobalToolsOnly, im);\n          logMessageLn(1, \"\\n\" +\n                          InspectionsBundle.message(\"inspection.capitalized.done\") +\n                          \"\\n\");\n        }\n      }, new ProgressIndicatorBase() {\n        private String lastPrefix = \"\";\n        private int myLastPercent = -1;\n\n        public void setText(String text) {\n          if (myVerboseLevel == 0) return;\n\n          if (myVerboseLevel == 1) {\n            String prefix = getPrefix(text);\n            if (prefix == null) return;\n            if (prefix.equals(lastPrefix)) {\n              logMessage(1, \".\");\n              return;\n            }\n            lastPrefix = prefix;\n            logMessageLn(1, \"\");\n            logMessageLn(1, prefix);\n            return;\n          }\n\n          if (myVerboseLevel == 3) {\n            if (!isIndeterminate() && getFraction() > 0) {\n              final StringBuilder buf = StringBuilderSpinAllocator.alloc();\n              try {\n                final int percent = (int)(getFraction() * 100);\n                if (myLastPercent == percent) return;\n                myLastPercent = percent;\n                buf.append(InspectionsBundle.message(\"inspection.display.name\")).append(\" \").append(percent).append(\"%\");\n                logMessageLn(2, buf.toString());\n              }\n              finally {\n                StringBuilderSpinAllocator.dispose(buf);\n              }\n            }\n            return;\n          }\n\n          logMessageLn(2, text);\n        }\n      });\n      describeInspections(myOutPath + File.separatorChar + DESCRIPTIONS + XmlFileType.DOT_DEFAULT_EXTENSION, !myRunWithEditorSettings ? inspectionProfile.getName() : null);\n    }\n    catch (IOException e) {\n      LOG.error(e);\n      logError(e.getMessage());\n      InspectionMain.printHelp();\n    }\n    catch (Throwable e) {\n      LOG.error(e);\n      logError(e.getMessage());\n      if (myErrorCodeRequired) System.exit(1);\n    }\n  }","commit_id":"1e71c37da78858e6e227c3f13d50ed7f4dbdf7d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void initMacApplication() {\n      Application application = new Application();\n      application.addApplicationListener(new ApplicationAdapter() {\n        public void handleAbout(ApplicationEvent applicationEvent) {\n          AboutAction.showAbout();\n          applicationEvent.setHandled(true);\n        }\n\n        public void handlePreferences(ApplicationEvent applicationEvent) {\n          Project project = getProject();\n\n          if (project == null) {\n            project = ProjectManager.getInstance().getDefaultProject();\n          }\n\n          ConfigurableGroup[] group = new ConfigurableGroup[]{\n            new ProjectConfigurablesGroup(project),\n            new IdeConfigurablesGroup()\n          };\n\n          ShowSettingsUtil.getInstance().showSettingsDialog(project, group);\n          applicationEvent.setHandled(true);\n        }\n\n        public void handleQuit(ApplicationEvent applicationEvent) {\n          ApplicationManagerEx.getApplicationEx().exit();\n        }\n\n        public void handleOpenFile(ApplicationEvent applicationEvent) {\n          Project project = getProject();\n          String filename = applicationEvent.getFilename();\n          if (filename == null) return;\n\n          File file = new File(filename);\n          if (ProjectUtil.openOrImport(file.getAbsolutePath(), project, false)) {\n            return;\n          }\n          if (project != null && file.exists()) {\n            OpenFileAction.openFile(filename, project);\n            applicationEvent.setHandled(true);\n          }\n        }\n      });\n\n      application.addAboutMenuItem();\n      application.addPreferencesMenuItem();\n      application.setEnabledAboutMenu(true);\n      application.setEnabledPreferencesMenu(true);\n    }","id":47224,"modified_method":"public static void initMacApplication() {\n      Application application = new Application();\n      application.addApplicationListener(new ApplicationAdapter() {\n        public void handleAbout(ApplicationEvent applicationEvent) {\n          AboutAction.showAbout();\n          applicationEvent.setHandled(true);\n        }\n\n        public void handlePreferences(ApplicationEvent applicationEvent) {\n          Project project = getProject();\n\n          if (project == null) {\n            project = ProjectManager.getInstance().getDefaultProject();\n          }\n\n          ConfigurableGroup[] group = new ConfigurableGroup[]{\n            new ProjectConfigurablesGroup(project),\n            new IdeConfigurablesGroup()\n          };\n\n          ShowSettingsUtil.getInstance().showSettingsDialog(project, group);\n          applicationEvent.setHandled(true);\n        }\n\n        public void handleQuit(ApplicationEvent applicationEvent) {\n          ApplicationManagerEx.getApplicationEx().exit();\n        }\n\n        public void handleOpenFile(ApplicationEvent applicationEvent) {\n          Project project = getProject();\n          String filename = applicationEvent.getFilename();\n          if (filename == null) return;\n\n          File file = new File(filename);\n          if (ProjectUtil.openOrImport(file.getAbsolutePath(), project, false) != null) {\n            return;\n          }\n          if (project != null && file.exists()) {\n            OpenFileAction.openFile(filename, project);\n            applicationEvent.setHandled(true);\n          }\n        }\n      });\n\n      application.addAboutMenuItem();\n      application.addPreferencesMenuItem();\n      application.setEnabledAboutMenu(true);\n      application.setEnabledPreferencesMenu(true);\n    }","commit_id":"1e71c37da78858e6e227c3f13d50ed7f4dbdf7d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Project loadAndOpenProject(final String filePath, final boolean convert) throws IOException, JDOMException, InvalidDataException {\n    try {\n\n      final ProjectConversionHelper conversionHelper;\n      final String fp = canonicalize(filePath);\n\n      final File f = new File(fp);\n      if (convert && f.exists() && f.isFile()) {\n        final ProjectConversionUtil.ProjectConversionResult result = ProjectConversionUtil.convertProject(fp);\n        if (result.isOpeningCancelled()) {\n          return null;\n        }\n        conversionHelper = result.getConversionHelper();\n      }\n      else {\n        conversionHelper = null;\n      }\n\n      final Project[] project = new Project[1];\n\n      final IOException[] io = new IOException[]{null};\n      final JDOMException[] jdom = new JDOMException[]{null};\n      final InvalidDataException[] invalidData = new InvalidDataException[]{null};\n      final StateStorage.StateStorageException[] stateStorage = new StateStorage.StateStorageException[]{null};\n\n      boolean ok = ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        public void run() {\n          final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n          try {\n            if (indicator != null) {\n              indicator.setText(\"Loading components for '\" + filePath + \"'\");\n              indicator.setIndeterminate(true);\n            }\n\n            project[0] = loadProject(filePath, conversionHelper);\n          }\n          catch (IOException e) {\n            io[0] = e;\n            return;\n          }\n          catch (JDOMException e) {\n            jdom[0] = e;\n            return;\n          }\n          catch (InvalidDataException e) {\n            invalidData[0] = e;\n            return;\n          }\n          catch (StateStorage.StateStorageException e) {\n            stateStorage[0] = e;\n            return;\n          }\n\n          if (indicator != null) {\n            indicator.setText(\"Initializing components\");\n          }\n        }\n      }, \"Loading Project\", true, null);\n\n      if (!ok) {\n        if (project[0] != null) {\n          Disposer.dispose(project[0]);\n          project[0] = null;\n        }\n        updateLastProjectToReopen();\n      }\n\n      if (io[0] != null) throw io[0];\n      if (jdom[0] != null) throw jdom[0];\n      if (invalidData[0] != null) throw invalidData[0];\n      if (stateStorage[0] != null) throw stateStorage[0];\n\n      if (project[0] == null || !ok) {\n        return null;\n      }\n\n      else if (!openProject(project[0])) {\n        Disposer.dispose(project[0]);\n        return null;\n      }\n\n      return project[0];\n    }\n    catch (StateStorage.StateStorageException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","id":47225,"modified_method":"@Nullable\n  public Project loadAndOpenProject(final String filePath, final boolean convert) throws IOException, JDOMException, InvalidDataException {\n    try {\n\n      final ProjectConversionHelper conversionHelper;\n      final String fp = canonicalize(filePath);\n\n      final File f = new File(fp);\n      if (convert && f.exists() && f.isFile() && !ApplicationManager.getApplication().isHeadlessEnvironment()) {\n        final ProjectConversionUtil.ProjectConversionResult result = ProjectConversionUtil.convertProject(fp);\n        if (result.isOpeningCancelled()) {\n          return null;\n        }\n        conversionHelper = result.getConversionHelper();\n      }\n      else {\n        conversionHelper = null;\n      }\n\n      final Project[] project = new Project[1];\n\n      final IOException[] io = new IOException[]{null};\n      final JDOMException[] jdom = new JDOMException[]{null};\n      final InvalidDataException[] invalidData = new InvalidDataException[]{null};\n      final StateStorage.StateStorageException[] stateStorage = new StateStorage.StateStorageException[]{null};\n\n      boolean ok = ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        public void run() {\n          final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n          try {\n            if (indicator != null) {\n              indicator.setText(\"Loading components for '\" + filePath + \"'\");\n              indicator.setIndeterminate(true);\n            }\n\n            project[0] = loadProject(filePath, conversionHelper);\n          }\n          catch (IOException e) {\n            io[0] = e;\n            return;\n          }\n          catch (JDOMException e) {\n            jdom[0] = e;\n            return;\n          }\n          catch (InvalidDataException e) {\n            invalidData[0] = e;\n            return;\n          }\n          catch (StateStorage.StateStorageException e) {\n            stateStorage[0] = e;\n            return;\n          }\n\n          if (indicator != null) {\n            indicator.setText(\"Initializing components\");\n          }\n        }\n      }, \"Loading Project\", true, null);\n\n      if (!ok) {\n        if (project[0] != null) {\n          Disposer.dispose(project[0]);\n          project[0] = null;\n        }\n        updateLastProjectToReopen();\n      }\n\n      if (io[0] != null) throw io[0];\n      if (jdom[0] != null) throw jdom[0];\n      if (invalidData[0] != null) throw invalidData[0];\n      if (stateStorage[0] != null) throw stateStorage[0];\n\n      if (project[0] == null || !ok) {\n        return null;\n      }\n\n      else if (!openProject(project[0])) {\n        Disposer.dispose(project[0]);\n        return null;\n      }\n\n      return project[0];\n    }\n    catch (StateStorage.StateStorageException e) {\n      throw new IOException(e.getMessage());\n    }\n  }","commit_id":"1e71c37da78858e6e227c3f13d50ed7f4dbdf7d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param path                project file path\n   * @param projectToClose      currently active project\n   * @param forceOpenInNewFrame forces opening in new frame\n   * @return true if the path was recognized as IDEA project file or one of the project formats supported by\n   *         installed importers (regardless of opening/import result)\n   */\n  public static boolean openOrImport(@NotNull final String path, final Project projectToClose, boolean forceOpenInNewFrame) {\n    final VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n\n    if (virtualFile == null) return false;\n\n    if (path.endsWith(ProjectFileType.DOT_DEFAULT_EXTENSION) || virtualFile.isDirectory()) {\n      openProject(path, projectToClose, forceOpenInNewFrame);\n      return true;\n    }\n    else {\n      ProjectOpenProcessor provider = getImportProvider(virtualFile);\n      if (provider != null) {\n        provider.doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame);\n        return true;\n      }\n      return false;\n    }\n  }","id":47226,"modified_method":"/**\n   * @param path                project file path\n   * @param projectToClose      currently active project\n   * @param forceOpenInNewFrame forces opening in new frame\n   * @return project by path if the path was recognized as IDEA project file or one of the project formats supported by\n   *         installed importers (regardless of opening/import result)\n   *         null otherwise\n   */\n  @Nullable\n  public static Project openOrImport(@NotNull final String path, final Project projectToClose, boolean forceOpenInNewFrame) {\n    final VirtualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByPath(path);\n\n    if (virtualFile == null) return null;\n\n    if (path.endsWith(ProjectFileType.DOT_DEFAULT_EXTENSION) || virtualFile.isDirectory()) {\n      return openProject(path, projectToClose, forceOpenInNewFrame);\n    }\n    else {\n      ProjectOpenProcessor provider = getImportProvider(virtualFile);\n      if (provider != null) {\n        return provider.doOpenProject(virtualFile, projectToClose, forceOpenInNewFrame);\n      }\n    }\n    return null;\n  }","commit_id":"1e71c37da78858e6e227c3f13d50ed7f4dbdf7d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized Integer[] getKeyNumbersAtRetryLevel(int retryCount) {\n\t\tVector<Integer> v = new Vector<Integer>();\n\t\tfor(int i=0;i<dataRetries.length;i++) {\n\t\t\tif(dataKeys[i] == null) continue;\n\t\t\tif(dataRetries[i] == retryCount)\n\t\t\t\tv.add(new Integer(i));\n\t\t}\n\t\tfor(int i=0;i<checkRetries.length;i++) {\n\t\t\tif(checkKeys[i] == null) continue;\n\t\t\tif(checkRetries[i] == retryCount)\n\t\t\t\tv.add(new Integer(i+dataKeys.length));\n\t\t}\n\t\treturn (Integer[]) v.toArray(new Integer[v.size()]);\n\t}","id":47227,"modified_method":"public synchronized Integer[] getKeyNumbersAtRetryLevel(int retryCount) {\n\t\tVector<Integer> v = new Vector<Integer>();\n\t\tfor(int i=0;i<dataRetries.length;i++) {\n\t\t\tif(dataKeys[i] == null) continue;\n\t\t\tif(dataRetries[i] == retryCount)\n\t\t\t\tv.add(new Integer(i));\n\t\t}\n\t\tfor(int i=0;i<checkRetries.length;i++) {\n\t\t\tif(checkKeys[i] == null) continue;\n\t\t\tif(checkRetries[i] == retryCount)\n\t\t\t\tv.add(new Integer(i+dataKeys.length));\n\t\t}\n\t\treturn v.toArray(new Integer[v.size()]);\n\t}","commit_id":"334f5dda61dd482cff2636baf872c7cfed229d84","url":"https://github.com/freenet/fred"},{"original_method":"private void queueHeal(Bucket data, ClientContext context) {\n\t\tif(logMINOR) Logger.minor(this, \"Queueing healing insert for \"+data+\" on \"+this);\n\t\tcontext.healingQueue.queue(data, context);\n\t}","id":47228,"modified_method":"/**\n\t * Queue the data for a healing insert. The data will be freed when it the healing insert completes,\n\t * or immediately if a healing insert isn't queued. If we are persistent, copies the data.\n\t * @param data\n\t * @param container\n\t * @param context\n\t */\n\tprivate void queueHeal(Bucket data, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\ttry {\n\t\t\t\tBucket copy = context.tempBucketFactory.makeBucket(data.size());\n\t\t\t\tBucketTools.copy(data, copy);\n\t\t\t\tdata.free();\n\t\t\t\tdata.removeFrom(container);\n\t\t\t\tdata = copy;\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.normal(this, \"Failed to copy data for healing: \"+e, e);\n\t\t\t\tdata.free();\n\t\t\t\tdata.removeFrom(container);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Queueing healing insert for \"+data+\" on \"+this);\n\t\tcontext.healingQueue.queue(data, context);\n\t}","commit_id":"334f5dda61dd482cff2636baf872c7cfed229d84","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * @return True if we fetched a block.\n\t * Hold the lock for the whole duration of this method. If a transient request\n\t * has two copies of onGotKey() run in parallel, we want only one of them to\n\t * return true, otherwise SFFKL will remove the keys from the main bloom\n\t * filter twice, resulting in collateral damage to other overlapping keys,\n\t * and then \"NOT IN BLOOM FILTER\" errors, or worse, false negatives.\n\t */\n\tpublic boolean onGotKey(Key key, KeyBlock block, ObjectContainer container, ClientContext context) {\n\t\tClientCHKBlock cb;\n\t\tint blockNum;\n\t\tBucket data;\n\t\tSplitFileFetcherSubSegment seg;\n\t\tsynchronized(this) {\n\t\t\tif(finished || startedDecode) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tblockNum = this.getBlockNumber(key, container);\n\t\t\tif(blockNum < 0) return false;\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Found key for block \"+blockNum+\" on \"+this+\" in onGotKey() for \"+key);\n\t\t\tClientCHK ckey = this.getBlockKey(blockNum, container);\n\t\t\tint retryCount = getBlockRetryCount(blockNum);\n\t\t\tseg = this.getSubSegment(retryCount, container, true, null);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(seg, 1);\n\t\t\tif(seg != null) {\n\t\t\t\tseg.removeBlockNum(blockNum, container, false);\n\t\t\t\tseg.possiblyRemoveFromParent(container, context);\n\t\t\t}\n\t\t\tfor(int i=0;i<subSegments.size();i++) {\n\t\t\t\tSplitFileFetcherSubSegment checkSeg = (SplitFileFetcherSubSegment) subSegments.get(i);\n\t\t\t\tif(checkSeg == seg) continue;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(checkSeg, 1);\n\t\t\t\tif(checkSeg.removeBlockNum(blockNum, container, false))\n\t\t\t\t\tLogger.error(this, \"Block number \"+blockNum+\" was registered to wrong subsegment \"+checkSeg+\" should be \"+seg);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(checkSeg, 1);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(seg, 1);\n\t\t\ttry {\n\t\t\t\tcb = new ClientCHKBlock((CHKBlock)block, ckey);\n\t\t\t} catch (CHKVerifyException e) {\n\t\t\t\tthis.onFatalFailure(new FetchException(FetchException.BLOCK_DECODE_ERROR, e), blockNum, null, container, context);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdata = extract(cb, blockNum, container, context);\n\t\t\tif(data == null) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Extract failed\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(!cb.isMetadata()) {\n\t\t\tthis.onSuccess(data, blockNum, cb, container, context, seg);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.onFatalFailure(new FetchException(FetchException.INVALID_METADATA, \"Metadata where expected data\"), blockNum, null, container, context);\n\t\t\treturn true;\n\t\t}\n\t}","id":47229,"modified_method":"/**\n\t * @return True if we fetched a block.\n\t * Hold the lock for the whole duration of this method. If a transient request\n\t * has two copies of onGotKey() run in parallel, we want only one of them to\n\t * return true, otherwise SFFKL will remove the keys from the main bloom\n\t * filter twice, resulting in collateral damage to other overlapping keys,\n\t * and then \"NOT IN BLOOM FILTER\" errors, or worse, false negatives.\n\t */\n\tpublic boolean onGotKey(Key key, KeyBlock block, ObjectContainer container, ClientContext context) {\n\t\tClientCHKBlock cb;\n\t\tint blockNum;\n\t\tBucket data;\n\t\tSplitFileFetcherSubSegment seg;\n\t\tsynchronized(this) {\n\t\t\tif(finished || startedDecode) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tblockNum = this.getBlockNumber(key, container);\n\t\t\tif(blockNum < 0) return false;\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Found key for block \"+blockNum+\" on \"+this+\" in onGotKey() for \"+key);\n\t\t\tClientCHK ckey = this.getBlockKey(blockNum, container);\n\t\t\tint retryCount = getBlockRetryCount(blockNum);\n\t\t\tseg = this.getSubSegment(retryCount, container, true, null);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(seg, 1);\n\t\t\tif(seg != null) {\n\t\t\t\tseg.removeBlockNum(blockNum, container, false);\n\t\t\t\tseg.possiblyRemoveFromParent(container, context);\n\t\t\t}\n\t\t\tfor(int i=0;i<subSegments.size();i++) {\n\t\t\t\tSplitFileFetcherSubSegment checkSeg = subSegments.get(i);\n\t\t\t\tif(checkSeg == seg) continue;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(checkSeg, 1);\n\t\t\t\tif(checkSeg.removeBlockNum(blockNum, container, false))\n\t\t\t\t\tLogger.error(this, \"Block number \"+blockNum+\" was registered to wrong subsegment \"+checkSeg+\" should be \"+seg);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(checkSeg, 1);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(seg, 1);\n\t\t\ttry {\n\t\t\t\tcb = new ClientCHKBlock((CHKBlock)block, ckey);\n\t\t\t} catch (CHKVerifyException e) {\n\t\t\t\tthis.onFatalFailure(new FetchException(FetchException.BLOCK_DECODE_ERROR, e), blockNum, null, container, context);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdata = extract(cb, blockNum, container, context);\n\t\t\tif(data == null) {\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Extract failed\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(!cb.isMetadata()) {\n\t\t\tthis.onSuccess(data, blockNum, cb, container, context, seg);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.onFatalFailure(new FetchException(FetchException.INVALID_METADATA, \"Metadata where expected data\"), blockNum, null, container, context);\n\t\t\treturn true;\n\t\t}\n\t}","commit_id":"334f5dda61dd482cff2636baf872c7cfed229d84","url":"https://github.com/freenet/fred"},{"original_method":"void fail(FetchException e, ObjectContainer container, ClientContext context, boolean dontDeactivateParent) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tfinished = true;\n\t\t\tthis.failureException = e;\n\t\t\tif(startedDecode) {\n\t\t\t\tLogger.error(this, \"Failing with \"+e+\" but already started decode\", e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tMinimalSplitfileBlock b = dataBuckets[i];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(b, 2);\n\t\t\t\tif(b != null) {\n\t\t\t\t\tBucket d = b.getData();\n\t\t\t\t\tif(d != null) d.free();\n\t\t\t\t}\n\t\t\t\tdataBuckets[i] = null;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tMinimalSplitfileBlock b = checkBuckets[i];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(b, 2);\n\t\t\t\tif(b != null) {\n\t\t\t\t\tBucket d = b.getData();\n\t\t\t\t\tif(d != null) d.free();\n\t\t\t\t}\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t}\n\t\t}\n\t\tremoveSubSegments(container, context);\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t}\n\t\tparentFetcher.removeMyPendingKeys(this, container, context);\n\t\tparentFetcher.segmentFinished(this, container, context);\n\t\tif(persistent && !dontDeactivateParent)\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t}","id":47230,"modified_method":"void fail(FetchException e, ObjectContainer container, ClientContext context, boolean dontDeactivateParent) {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return;\n\t\t\tfinished = true;\n\t\t\tthis.failureException = e;\n\t\t\tif(startedDecode) {\n\t\t\t\tLogger.error(this, \"Failing with \"+e+\" but already started decode\", e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tMinimalSplitfileBlock b = dataBuckets[i];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(b, 2);\n\t\t\t\tif(b != null) {\n\t\t\t\t\tBucket d = b.getData();\n\t\t\t\t\tif(d != null) d.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tb.removeFrom(container);\n\t\t\t\tdataBuckets[i] = null;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tMinimalSplitfileBlock b = checkBuckets[i];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(b, 2);\n\t\t\t\tif(b != null) {\n\t\t\t\t\tBucket d = b.getData();\n\t\t\t\t\tif(d != null) d.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tb.removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t}\n\t\t}\n\t\tremoveSubSegments(container, context);\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t}\n\t\tparentFetcher.removeMyPendingKeys(this, container, context);\n\t\tparentFetcher.segmentFinished(this, container, context);\n\t\tif(persistent && !dontDeactivateParent)\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t}","commit_id":"334f5dda61dd482cff2636baf872c7cfed229d84","url":"https://github.com/freenet/fred"},{"original_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, context);\n\t\t\t\t} else {\n\t\t\t\t\tdataBuckets[i].data.free();\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tdataBuckets[i].data.removeFrom(container);\n\t\t\t\t\tdataBuckets[i].data = null;\n\t\t\t\t}\n\t\t\t\tdataBuckets[i] = null;\n\t\t\t\tdataKeys[i] = null;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, i, true, container, context);\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, context);\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tdata.removeFrom(container);\n\t\t\t\t}\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t}\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t}","id":47231,"modified_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tdataBuckets[i].data = null; // So that it doesn't remove the data\n\t\t\t\t} else {\n\t\t\t\t\tdataBuckets[i].data.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tdataBuckets[i].removeFrom(container);\n\t\t\t\tdataBuckets[i] = null;\n\t\t\t\tdataKeys[i] = null;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, i, true, container, context);\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t}\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t}","commit_id":"334f5dda61dd482cff2636baf872c7cfed229d84","url":"https://github.com/freenet/fred"},{"original_method":"public HomePage logout() {\n        userAvatar.click();\n\n        clickLinkAfterAnimation(BY_SIGN_OUT);\n        return new HomePage(getDriver());\n    }","id":47232,"modified_method":"public HomePage logout() {\n        scrollIntoView(userAvatar);\n        userAvatar.click();\n\n        clickLinkAfterAnimation(BY_SIGN_OUT);\n        return new HomePage(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void clickNavMenuItem(final WebElement menuItem) {\n        if (!menuItem.isDisplayed()) {\n            // screen is too small the menu become dropdown\n            getDriver().findElement(By.id(\"nav-main\"))\n                    .findElement(By.tagName(\"a\")).click();\n        }\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return menuItem.isDisplayed();\n            }\n        });\n        menuItem.click();\n    }","id":47233,"modified_method":"private void clickNavMenuItem(final WebElement menuItem) {\n        scrollIntoView(menuItem);\n        if (!menuItem.isDisplayed()) {\n            // screen is too small the menu become dropdown\n            getDriver().findElement(By.id(\"nav-main\"))\n                    .findElement(By.tagName(\"a\")).click();\n        }\n        waitForTenSec().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return menuItem.isDisplayed();\n            }\n        });\n        menuItem.click();\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void idStartsAndEndsWithAlphanumeric() {\n        CreateVersionPage createVersionPage =\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").goToProjects()\n                        .goToProject(\"about fedora\").clickCreateVersionLink()\n                        .inputVersionId(\"-A\");\n        createVersionPage.defocus();\n        String formatError =\n                \"must start and end with letter or number, \"\n                        + \"and contain only letters, numbers, underscores and hyphens.\";\n\n        assertThat(\"The input is rejected\", createVersionPage.getErrors(),\n                hasItem(formatError));\n\n        createVersionPage =\n                createVersionPage.inputVersionId(\"B-\").waitForNumErrors(1);\n        createVersionPage.defocus();\n\n        assertThat(\"The input is rejected\", createVersionPage.getErrors(),\n                hasItem(formatError));\n\n        createVersionPage =\n                createVersionPage.inputVersionId(\"_C_\").waitForNumErrors(1);\n        createVersionPage.defocus();\n\n        assertThat(\"The input is rejected\", createVersionPage.getErrors(),\n                hasItem(formatError));\n\n        createVersionPage =\n                createVersionPage.inputVersionId(\"A-B_C\").waitForNumErrors(0);\n        createVersionPage.defocus();\n\n        assertThat(\"The input is acceptable\", createVersionPage.getErrors(),\n                not(hasItem(formatError)));\n    }","id":47234,"modified_method":"@Test\n    public void idStartsAndEndsWithAlphanumeric() {\n        CreateVersionPage createVersionPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .clickCreateVersionLink()\n                .inputVersionId(\"-A\");\n        createVersionPage.defocus();\n\n        assertThat(\"The input is rejected\", createVersionPage.getErrors(),\n                hasItem(CreateVersionPage.VALIDATION_ERROR));\n\n        createVersionPage = createVersionPage.inputVersionId(\"B-\");\n        createVersionPage.defocus();\n        createVersionPage = createVersionPage.waitForNumErrors(1);\n\n        assertThat(\"The input is rejected\", createVersionPage.getErrors(),\n                hasItem(CreateVersionPage.VALIDATION_ERROR));\n\n        createVersionPage = createVersionPage.inputVersionId(\"_C_\");\n        createVersionPage.defocus();\n        createVersionPage = createVersionPage.waitForNumErrors(1);\n\n        assertThat(\"The input is rejected\", createVersionPage.getErrors(),\n                hasItem(CreateVersionPage.VALIDATION_ERROR));\n\n        createVersionPage = createVersionPage.inputVersionId(\"A-B_C\");\n        createVersionPage.defocus();\n        createVersionPage = createVersionPage.waitForNumErrors(0);\n\n        assertThat(\"The input is acceptable\", createVersionPage.getErrors(),\n                not(hasItem(CreateVersionPage.VALIDATION_ERROR)));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void setAProjectObsolete() {\n\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"setobsoleteproject\");\n        projectSettings.put(\"Name\", \"Obsolete Project Test\");\n        projectSettings.put(\"Project Type\", \"File\");\n\n        assertThat(\"Translator can log in\",\n                new LoginWorkFlow()\n                        .signIn(\"translator\", \"translator\")\n                        .loggedInAs(),\n                equalTo(\"translator\"));\n\n        assertThat(\"Archiving is not available to non admin\",\n                new ProjectWorkFlow()\n                        .createNewProject(projectSettings)\n                        .gotoSettingsTab()\n                        .gotoSettingsGeneral()\n                        .isArchiveButtonAvailable(),\n                not(true));\n\n        new BasicWorkFlow().goToHome().logout();\n\n        ProjectsPage projectsPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(projectSettings.get(\"Name\"))\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .archiveProject()\n                .goToProjects();\n\n        assertThat(\"The project is not displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                not(hasItem(projectSettings.get(\"Name\"))));\n\n        projectsPage = projectsPage.setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(false)\n                .setObsoleteFilterEnabled(true);\n\n        projectsPage\n                .waitForProjectVisibility(projectSettings.get(\"Name\"), true);\n\n        assertThat(\"The project is now displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                hasItem(projectSettings.get(\"Name\")));\n\n        projectsPage.logout();\n\n        assertThat(\"User cannot navigate to a project\",\n                new LoginWorkFlow()\n                        .signIn(\"translator\", \"translator\")\n                        .goToProjects()\n                        .getProjectNamesOnCurrentPage(),\n                not(hasItem(projectSettings.get(\"Name\"))));\n    }","id":47235,"modified_method":"@Test\n    public void setAProjectObsolete() {\n        ProjectsPage projectsPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .archiveProject()\n                .goToProjects();\n\n        assertThat(\"The project is not displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                not(hasItem(\"about fedora\")));\n\n        projectsPage = projectsPage.setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(false)\n                .setObsoleteFilterEnabled(true);\n\n        projectsPage.waitForProjectVisibility(\"about fedora\", true);\n\n        assertThat(\"The project is now displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                hasItem(\"about fedora\"));\n\n        projectsPage.logout();\n\n        assertThat(\"User cannot navigate to a project\", new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToProjects()\n                .getProjectNamesOnCurrentPage(),\n                not(hasItem(\"about fedora\")));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void setAProjectToReadOnly() {\n\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"deactivateproject\");\n        projectSettings.put(\"Name\", \"Deactivate Project Test\");\n\n        assertThat(\"Admin can log in\",\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").loggedInAs(),\n                equalTo(\"admin\"));\n\n        new ProjectWorkFlow()\n                .createNewProject(projectSettings)\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject();\n\n        ProjectsPage projectsPage = new BasicWorkFlow()\n                .goToHome()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(projectSettings.get(\"Name\"), false);\n\n        assertThat(\"The project is not displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                not(hasItem(projectSettings.get(\"Name\"))));\n\n        projectsPage = projectsPage.setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(projectSettings.get(\"Name\"), true);\n\n        assertThat(\"The project is now displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                hasItem(projectSettings.get(\"Name\")));\n    }","id":47236,"modified_method":"@Test\n    public void setAProjectToReadOnly() {\n        ProjectsPage projectsPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(\"about fedora\", false);\n\n        assertThat(\"The project is not displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                not(hasItem(\"about fedora\")));\n\n        projectsPage = projectsPage.setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(\"about fedora\", true);\n\n        assertThat(\"The project is now displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                hasItem(\"about fedora\"));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changeSourceLinks() {\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"changeLinks\");\n        projectSettings.put(\"Name\", \"Project Links Test\");\n\n        assertThat(\"Admin can log in\",\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").loggedInAs(),\n                Matchers.equalTo(\"admin\"));\n\n        ProjectVersionsPage projectVersionsPage =\n                new ProjectWorkFlow()\n                .createNewProject(projectSettings)\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .enterHomePage(\"http://www.example.com\")\n                .enterRepository(\"http://www.test.com\")\n                .updateProject()\n                .goToProjects()\n                .goToProject(projectSettings.get(\"Name\"));\n\n        assertThat(\"The homepage is correct\",\n                projectVersionsPage.getHomepage(),\n                Matchers.equalTo(\"http://www.example.com\"));\n\n        assertThat(\"The git url is correct\",\n                projectVersionsPage.getGitUrl(),\n                Matchers.equalTo(\"http://www.test.com\"));\n    }","id":47237,"modified_method":"@Test\n    public void changeSourceLinks() {\n        ProjectVersionsPage projectVersionsPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .enterHomePage(\"http://www.example.com\")\n                .enterRepository(\"http://www.test.com\")\n                .updateProject()\n                .goToProjects()\n                .goToProject(\"about fedora\");\n\n        assertThat(\"The homepage is correct\",\n                projectVersionsPage.getHomepage(),\n                Matchers.equalTo(\"http://www.example.com\"));\n\n        assertThat(\"The git url is correct\",\n                projectVersionsPage.getGitUrl(),\n                Matchers.equalTo(\"http://www.test.com\"));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changeProjectType() {\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"changeType\");\n        projectSettings.put(\"Name\", \"Project Type Test\");\n\n        assertThat(\"Admin can log in\",\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").loggedInAs(),\n                Matchers.equalTo(\"admin\"));\n\n        ProjectGeneralTab projectGeneralTab =\n                new ProjectWorkFlow()\n                .createNewProject(projectSettings)\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .selectProjectType(\"Properties\")\n                .updateProject()\n                .goToProjects()\n                .goToProject(projectSettings.get(\"Name\"))\n                .gotoSettingsTab()\n                .gotoSettingsGeneral();\n\n        assertThat(\"The type is correct\",\n                projectGeneralTab.getSelectedProjectType(),\n                Matchers.equalTo(\"Properties\"));\n    }","id":47238,"modified_method":"@Test\n    public void changeProjectType() {\n        ProjectGeneralTab projectGeneralTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .selectProjectType(\"Properties\")\n                .updateProject()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral();\n\n        assertThat(\"The type is correct\",\n                projectGeneralTab.getSelectedProjectType(),\n                Matchers.equalTo(\"Properties\"));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void setAProjectToWritable() {\n\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"rewritableproject\");\n        projectSettings.put(\"Name\", \"Rewrite Project Test\");\n\n        assertThat(\"Admin can log in\",\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").loggedInAs(),\n                equalTo(\"admin\"));\n\n        assertThat(\"The project is locked\",\n                new ProjectWorkFlow()\n                        .createNewProject(projectSettings)\n                        .gotoSettingsTab()\n                        .gotoSettingsGeneral()\n                        .lockProject()\n                        .goToProjects()\n                        .setActiveFilterEnabled(false)\n                        .setReadOnlyFilterEnabled(true)\n                        .setObsoleteFilterEnabled(false)\n                        .waitForProjectVisibility(\n                                projectSettings.get(\"Name\"), true)\n                        .getProjectNamesOnCurrentPage(),\n                hasItem(projectSettings.get(\"Name\")));\n\n        ProjectsPage projectsPage = new BasicWorkFlow()\n                .goToHome()\n                .goToProjects()\n                .goToProject(projectSettings.get(\"Name\"))\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .unlockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(projectSettings.get(\"Name\"), true);\n\n        assertThat(\"The project is now displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                hasItem(projectSettings.get(\"Name\")));\n    }","id":47239,"modified_method":"@Test\n    public void setAProjectToWritable() {\n        assertThat(\"The project is locked\", new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(\"about fedora\", true)\n                .getProjectNamesOnCurrentPage(),\n                hasItem(\"about fedora\"));\n\n        ProjectsPage projectsPage = new BasicWorkFlow()\n                .goToHome()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .unlockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .setObsoleteFilterEnabled(false)\n                .waitForProjectVisibility(\"about fedora\", true);\n\n        assertThat(\"The project is now displayed\",\n                projectsPage.getProjectNamesOnCurrentPage(),\n                hasItem(\"about fedora\"));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changeProjectName() {\n\n        String replacementText = \"a new name\";\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"changeName\");\n        projectSettings.put(\"Name\", \"Project Name Change Test\");\n\n        assertThat(\"Admin can log in\",\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").loggedInAs(),\n                Matchers.equalTo(\"admin\"));\n\n        ProjectVersionsPage projectVersionsPage =\n                new ProjectWorkFlow()\n                .createNewProject(projectSettings)\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .enterProjectName(replacementText)\n                .updateProject()\n                .goToProjects()\n                .goToProject(replacementText);\n\n        assertThat(\"The name has changed\",\n                projectVersionsPage.getProjectName(),\n                Matchers.equalTo(replacementText));\n    }","id":47240,"modified_method":"@Test\n    public void changeProjectName() {\n        String replacementText = \"a new name\";\n        ProjectVersionsPage projectVersionsPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .enterProjectName(replacementText)\n                .updateProject()\n                .goToProjects()\n                .goToProject(replacementText);\n\n        assertThat(\"The name has changed\",\n                projectVersionsPage.getProjectName(),\n                Matchers.equalTo(replacementText));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void setAnObsoleteProjectAsActive() {\n\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"setobsoleteprojectactive\");\n        projectSettings.put(\"Name\", \"Unobsolete Project Test\");\n        projectSettings.put(\"Project Type\", \"File\");\n\n        assertThat(\"Translator can log in\",\n                new LoginWorkFlow()\n                        .signIn(\"translator\", \"translator\")\n                        .loggedInAs(),\n                equalTo(\"translator\"));\n\n        new ProjectWorkFlow()\n                .createNewProject(projectSettings)\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .logout();\n\n        ProjectGeneralTab projectGeneralTab =\n                new LoginWorkFlow()\n                    .signIn(\"admin\", \"admin\")\n                    .goToProjects()\n                    .goToProject(projectSettings.get(\"Name\"))\n                    .gotoSettingsTab()\n                    .gotoSettingsGeneral()\n                    .archiveProject()\n                    .goToProjects()\n                    .setObsoleteFilterEnabled(true)\n                    .goToProject(projectSettings.get(\"Name\"))\n                    .gotoSettingsTab()\n                    .gotoSettingsGeneral()\n                    .unarchiveProject();\n\n        assertThat(\"The archive button is now available\",\n                projectGeneralTab.isArchiveButtonAvailable());\n\n        assertThat(\"Translator can view the project\",\n                new LoginWorkFlow()\n                    .signIn(\"translator\", \"translator\")\n                    .goToProjects()\n                    .goToProject(projectSettings.get(\"Name\"))\n                    .getProjectName(),\n                equalTo(projectSettings.get(\"Name\")));\n\n    }","id":47241,"modified_method":"@Test\n    public void setAnObsoleteProjectAsActive() {\n        ProjectGeneralTab projectGeneralTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .archiveProject()\n                .goToProjects()\n                .setObsoleteFilterEnabled(true)\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .unarchiveProject();\n\n        assertThat(\"The archive button is now available\",\n                projectGeneralTab.isArchiveButtonAvailable());\n\n        projectGeneralTab.logout();\n\n        assertThat(\"Translator can view the project\", new LoginWorkFlow()\n                .signIn(\"translator\", \"translator\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .getProjectName(),\n                equalTo(\"about fedora\"));\n\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void changeProjectDescription() {\n\n        String replacementText = \"a new description\";\n        HashMap<String, String> projectSettings = projectDefaults();\n        projectSettings.put(\"Project ID\", \"changeDescription\");\n        projectSettings.put(\"Name\", \"Project Description Test\");\n        projectSettings.put(\"Description\", \"An old description\");\n\n        assertThat(\"Admin can log in\",\n                new LoginWorkFlow().signIn(\"admin\", \"admin\").loggedInAs(),\n                Matchers.equalTo(\"admin\"));\n\n        ProjectVersionsPage projectVersionsPage =\n                new ProjectWorkFlow()\n                .createNewProject(projectSettings)\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .enterDescription(replacementText)\n                .updateProject()\n                .goToProjects()\n                .goToProject(projectSettings.get(\"Name\"));\n\n        assertThat(\"The text has changed\",\n                projectVersionsPage.getContentAreaParagraphs(),\n                Matchers.hasItem(replacementText));\n    }","id":47242,"modified_method":"@Test\n    public void changeProjectDescription() {\n        String replacementText = \"a new description\";\n        ProjectVersionsPage projectVersionsPage = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\");\n\n        assertThat(\"The description is default\",\n                projectVersionsPage.getContentAreaParagraphs(),\n                not(hasItem(replacementText)));\n\n        ProjectGeneralTab projectGeneralTab = projectVersionsPage\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .enterDescription(replacementText)\n                .updateProject();\n\n        assertThat(\"The text has changed\",\n                projectGeneralTab.getContentAreaParagraphs(),\n                Matchers.hasItem(replacementText));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void editProjectLanguages() {\n        ProjectLanguagesTab projectLanguagesTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab();\n\n        List<String> enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(\"The enabled list contains three languages\",\n                enabledLocaleList,\n                contains(\"French[fr]\", \"Hindi[hi]\", \"Polish[pl]\"));\n\n        assertThat(\"The enabled list does not contain \" +\n                \"'English (United States)[en-US]'\",\n                enabledLocaleList,\n                not(hasItem(\"English (United States)[en-US]\")));\n\n        projectLanguagesTab = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .removeLocale(\"pl\");\n\n        enabledLocaleList = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .getEnabledLocaleList();\n\n        assertThat(\"The enabled list does not contain 'US English'\",\n                enabledLocaleList,\n                not(hasItem(\"English (United States)[en-US]\")));\n\n        assertThat(\"The enabled list does not contain 'Polish'\",\n                enabledLocaleList,\n                not(hasItem(\"Polish[pl]\")));\n\n        enabledLocaleList = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .enterSearchLanguage(\"en-US\")\n                .addLanguage(\"English (United States)[en-US]\")\n                .getEnabledLocaleList();\n\n        assertThat(\"Three languages are available to translate\",\n                enabledLocaleList,\n                contains(\"English (United States)[en-US]\",\n                        \"French[fr]\",\n                        \"Hindi[hi]\"));\n    }","id":47243,"modified_method":"@Test\n    public void editProjectLanguages() {\n        ProjectLanguagesTab projectLanguagesTab = new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab();\n\n        projectLanguagesTab.slightPause();\n\n        List<String> enabledLocaleList = projectLanguagesTab\n                .getEnabledLocaleList();\n\n        assertThat(\"The enabled list contains three languages\",\n                enabledLocaleList,\n                contains(\"French[fr]\", \"Hindi[hi]\", \"Polish[pl]\"));\n\n        assertThat(\"The enabled list does not contain \" +\n                \"'English (United States)[en-US]'\",\n                enabledLocaleList,\n                not(hasItem(\"English (United States)[en-US]\")));\n\n        projectLanguagesTab = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .removeLocale(\"pl\");\n\n        enabledLocaleList = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .getEnabledLocaleList();\n\n        assertThat(\"The enabled list does not contain 'US English'\",\n                enabledLocaleList,\n                not(hasItem(\"English (United States)[en-US]\")));\n\n        assertThat(\"The enabled list does not contain 'Polish'\",\n                enabledLocaleList,\n                not(hasItem(\"Polish[pl]\")));\n\n        enabledLocaleList = projectLanguagesTab\n                .gotoSettingsTab()\n                .gotoSettingsLanguagesTab()\n                .enterSearchLanguage(\"en-US\")\n                .addLanguage(\"English (United States)[en-US]\")\n                .getEnabledLocaleList();\n\n        assertThat(\"Three languages are available to translate\",\n                enabledLocaleList,\n                contains(\"English (United States)[en-US]\",\n                        \"French[fr]\",\n                        \"Hindi[hi]\"));\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void uploadHTMLFile() {\n        File htmlfile =\n                testFileGenerator\n                        .generateTestFileWithContent(\"testhtmlfile\", \".html\",\n                                \"<html><title>Test content<\/title><br>This is <b>Bold<\/b> text<\/html>\");\n        String testFileName = htmlfile.getName();\n        String successfullyUploaded = \"Document \" + testFileName + \" uploaded.\";\n        VersionLanguagesPage projectVersionPage =\n                new LoginWorkFlow().signIn(\"admin\", \"admin\")\n                        .goToProjects()\n                        .goToProject(\"about fedora\")\n                        .gotoVersion(\"master\")\n                        .gotoSettingsTab()\n                        .gotoSettingsDocumentsTab()\n                        .pressUploadFileButton()\n                        .enterFilePath(htmlfile.getAbsolutePath())\n                        .submitUpload();\n        assertThat(\"Document uploaded notification shows\",\n                projectVersionPage.getNotificationMessage(),\n                Matchers.equalTo(successfullyUploaded));\n\n        VersionDocumentsPage versionDocumentsPage =\n                projectVersionPage.gotoDocumentTab();\n\n        assertThat(\"Document shows in table\", versionDocumentsPage\n                .sourceDocumentsContains(htmlfile.getName()));\n\n        EditorPage editorPage =\n                projectVersionPage.goToProjects().goToProject(\"about fedora\")\n                        .gotoVersion(\"master\").translate(\"pl\", testFileName);\n\n        assertThat(\"The first translation source is correct\",\n                editorPage.getMessageSourceAtRowIndex(0),\n                Matchers.equalTo(\"Test content\"));\n        assertThat(\"The second translation source is correct\",\n                editorPage.getMessageSourceAtRowIndex(1),\n                Matchers.equalTo(\"This is <g2>Bold<\/g2> text\"));\n\n    }","id":47244,"modified_method":"@Test\n    public void uploadHTMLFile() {\n        File htmlfile =\n                testFileGenerator\n                        .generateTestFileWithContent(\"testhtmlfile\", \".html\",\n                                \"<html><title>Test content<\/title><br>This is <b>Bold<\/b> text<\/html>\");\n        String testFileName = htmlfile.getName();\n        String successfullyUploaded = \"Document \" + testFileName + \" uploaded.\";\n        VersionLanguagesPage projectVersionPage =\n                new LoginWorkFlow().signIn(\"admin\", \"admin\")\n                        .goToProjects()\n                        .goToProject(\"about fedora\")\n                        .gotoVersion(\"master\")\n                        .gotoSettingsTab()\n                        .gotoSettingsDocumentsTab()\n                        .pressUploadFileButton()\n                        .enterFilePath(htmlfile.getAbsolutePath())\n                        .submitUpload();\n\n        assertThat(\"Document uploaded notification shows\",\n                projectVersionPage.expectNotification(successfullyUploaded));\n\n        VersionDocumentsPage versionDocumentsPage =\n                projectVersionPage.gotoDocumentTab();\n\n        assertThat(\"Document shows in table\", versionDocumentsPage\n                .sourceDocumentsContains(htmlfile.getName()));\n\n        EditorPage editorPage =\n                projectVersionPage.goToProjects().goToProject(\"about fedora\")\n                        .gotoVersion(\"master\").translate(\"pl\", testFileName);\n\n        assertThat(\"The first translation source is correct\",\n                editorPage.getMessageSourceAtRowIndex(0),\n                Matchers.equalTo(\"Test content\"));\n        assertThat(\"The second translation source is correct\",\n                editorPage.getMessageSourceAtRowIndex(1),\n                Matchers.equalTo(\"This is <g2>Bold<\/g2> text\"));\n\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        String documentStorageDirectory =\n                CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator);\n        assumeFalse(\"\", new File(documentStorageDirectory).exists());\n    }","id":47245,"modified_method":"@Before\n    public void before() {\n        new BasicWorkFlow().goToHome().deleteCookiesAndRefresh();\n        String documentStorageDirectory =\n                CleanDocumentStorageRule.getDocumentStoragePath()\n                        .concat(File.separator).concat(\"documents\")\n                        .concat(File.separator);\n        File docStorage = new File(documentStorageDirectory);\n        assumeTrue(\"The storage folder is empty\",\n                docStorage == null ||\n                !docStorage.exists() ||\n                docStorage.listFiles().length == 0);\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Press the \"Unarchive this project\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab unarchiveProject() {\n        getDriver().findElement(\n                By.id(\"settings-general-form:button-unarchive-project\"))\n                .click();\n        return new ProjectGeneralTab(getDriver());\n    }","id":47246,"modified_method":"/**\n     * Press the \"Unarchive this project\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab unarchiveProject() {\n        clickElement(By.id(\"settings-general-form:button-unarchive-project\"));\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Press the \"Archive this project\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab archiveProject() {\n        getDriver().findElement(\n                By.id(\"settings-general-form:button-archive-project\"))\n                .click();\n        return new ProjectGeneralTab(getDriver());\n    }","id":47247,"modified_method":"/**\n     * Press the \"Archive this project\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab archiveProject() {\n        clickElement(By.id(\"settings-general-form:button-archive-project\"));\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Press the \"Make this project writable\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab unlockProject() {\n        getDriver().findElement(\n                By.id(\"settings-general-form:button-unlock-project\"))\n                .click();\n        return new ProjectGeneralTab(getDriver());\n    }","id":47248,"modified_method":"/**\n     * Press the \"Make this project writable\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab unlockProject() {\n        clickElement(By.id(\"settings-general-form:button-unlock-project\"));\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Select a new type for the project.\n     * Searches by display name.\n     *\n     * @param projectType new project type\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab selectProjectType(String projectType) {\n        assert getProjectTypes().containsKey(projectType);\n        getProjectTypes().get(projectType).click();\n        return new ProjectGeneralTab(getDriver());\n    }","id":47249,"modified_method":"/**\n     * Select a new type for the project.\n     * Searches by display name.\n     *\n     * @param projectType new project type\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab selectProjectType(String projectType) {\n        assert getProjectTypes().containsKey(projectType);\n        WebElement projectTypeButton = getProjectTypes().get(projectType);\n        scrollIntoView(projectTypeButton);\n        projectTypeButton.click();\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Press the \"Make this project read only\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab lockProject() {\n        getDriver().findElement(\n                By.id(\"settings-general-form:button-lock-project\"))\n                .click();\n        return new ProjectGeneralTab(getDriver());\n    }","id":47250,"modified_method":"/**\n     * Press the \"Make this project read only\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab lockProject() {\n        clickElement(By.id(\"settings-general-form:button-lock-project\"));\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Press the \"Update general settings\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab updateProject() {\n        clickAndCheckErrors(updateButton);\n        return new ProjectGeneralTab(getDriver());\n    }","id":47251,"modified_method":"/**\n     * Press the \"Update general settings\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab updateProject() {\n        scrollIntoView(updateButton());\n        clickAndCheckErrors(updateButton());\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"1cb216ab3154bdf222dbd9fa3f1cb103aa1b1216","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Nullable\n  public static String getNewText(PsiElement elt) {\n    Project project = elt.getProject();\n    PsiFile psiFile = getContainingFile(elt);\n\n    final Document doc = PsiDocumentManager.getInstance(project).getDocument(psiFile);\n    if (doc == null) return null;\n\n    if (elt.getTextRange() == null) {\n      return null;\n    }\n\n    final ImplementationTextSelectioner implementationTextSelectioner =\n      LanguageImplementationTextSelectioner.INSTANCE.forLanguage(elt.getLanguage());\n    int start = implementationTextSelectioner.getTextStartOffset(elt);\n    \n    CharSequence rawDefinition = doc.getCharsSequence().subSequence(start, \n                                                                    implementationTextSelectioner.getTextEndOffset(elt));\n    int end = CharArrayUtil.shiftBackward(rawDefinition, rawDefinition.length(), \"\\r\\n\"); // deleting trailing EOLs\n\n    final int lineStart = doc.getLineStartOffset(doc.getLineNumber(start));\n    final int lineEnd = end < doc.getTextLength() ? doc.getLineEndOffset(doc.getLineNumber(end)) : doc.getTextLength();\n    return doc.getCharsSequence().subSequence(lineStart, lineEnd).toString();\n  }","id":47252,"modified_method":"@Nullable\n  public static String getNewText(PsiElement elt) {\n    Project project = elt.getProject();\n    PsiFile psiFile = getContainingFile(elt);\n\n    final Document doc = PsiDocumentManager.getInstance(project).getDocument(psiFile);\n    if (doc == null) return null;\n\n    if (elt.getTextRange() == null) {\n      return null;\n    }\n\n    final ImplementationTextSelectioner implementationTextSelectioner =\n      LanguageImplementationTextSelectioner.INSTANCE.forLanguage(elt.getLanguage());\n    int start = implementationTextSelectioner.getTextStartOffset(elt);\n    int end = implementationTextSelectioner.getTextEndOffset(elt);\n    CharSequence rawDefinition = doc.getCharsSequence().subSequence(start, end);\n    while (end > start && StringUtil.isLineBreak(rawDefinition.charAt(end - start - 1))) { // removing trailing EOLs from definition\n      end--;\n    }\n\n    final int lineStart = doc.getLineStartOffset(doc.getLineNumber(start));\n    final int lineEnd = end < doc.getTextLength() ? doc.getLineEndOffset(doc.getLineNumber(end)) : doc.getTextLength();\n    return doc.getCharsSequence().subSequence(lineStart, lineEnd).toString();\n  }","commit_id":"ca907554a6b2a6667ee7bd34ea7381470ac7b217","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void flushDeferredChanged() {\n    List<TextChangeImpl> changes = myDeferredChangesStorage.getChanges();\n    if (changes.isEmpty()) {\n      return;\n    }\n\n    BulkChangesMerger changesMerger = BulkChangesMerger.INSTANCE;\n    if (myArray.length < length()) {\n      myArray = changesMerger.mergeToCharArray(myArray, myCount, changes);\n    }\n    else {\n      changesMerger.mergeInPlace(myArray, myCount, changes);\n    }\n\n    myCount += myDeferredShift;\n    myDeferredShift = 0;\n    myDeferredChangesStorage.clear();\n  }","id":47253,"modified_method":"private void flushDeferredChanged() {\n    List<TextChangeImpl> changes = myDeferredChangesStorage.getChanges();\n    if (changes.isEmpty()) {\n      return;\n    }\n\n    char[] beforeMerge = null;\n    final boolean inPlace;\n    if (myDebugDeferredProcessing) {\n      beforeMerge = new char[myArray.length];\n      System.arraycopy(myArray, 0, beforeMerge, 0, myArray.length);\n    }\n    \n    BulkChangesMerger changesMerger = BulkChangesMerger.INSTANCE;\n    if (myArray.length < length()) {\n      myArray = changesMerger.mergeToCharArray(myArray, myCount, changes);\n      inPlace = false;\n    }\n    else {\n      changesMerger.mergeInPlace(myArray, myCount, changes);\n      inPlace = true;\n    }\n\n    if (myDebugDeferredProcessing) {\n      for (int i = 0, max = length(); i < max; i++) {\n        if (myArray[i] != myDebugArray.myArray[i]) {\n          dumpDebugInfo(String.format(\n            \"flushDeferredChanged(). Index %d, expected: '%c', actual '%c'. Text before merge: '%s', merge inplace: %b\",\n            i, myDebugArray.myArray[i], myArray[i], Arrays.toString(beforeMerge), inPlace));\n          break;\n        }\n      }\n    }\n    \n    myCount += myDeferredShift;\n    myDeferredShift = 0;\n    myDeferredChangesStorage.clear();\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final int length() {\n    return myCount + myDeferredShift;\n  }","id":47254,"modified_method":"public final int length() {\n    final int result = myCount + myDeferredShift;\n    if (myDebugDeferredProcessing && isDeferredChangeMode()) {\n      int expected = myDebugArray.length();\n      if (expected != result) {\n        dumpDebugInfo(String.format(\"Incorrect length() processing. Expected: '%s', actual: '%s'\", expected, result));\n      }\n    }\n    return result;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * There is a possible case that client of this class wants to perform great number of modifications in a short amount of time\n   * (e.g. end-user performs formatting of the document backed by the object of the current class). It may result in significant\n   * performance degradation is the changes are performed one by one (every time the change is applied tail content is shifted to\n   * the left or right). So, we may want to optimize that by avoiding actual array modification until information about\n   * all target changes is provided and perform array data moves only after that.\n   * <p/>\n   * This method allows to define that <code>'defer changes'<\/code> mode usages, i.e. expected usage pattern is as follows:\n   * <pre>\n   * <ol>\n   *   <li>\n   *     Client of this class enters <code>'defer changes'<\/code> mode (calls this method with <code>'true'<\/code> argument).\n   *     That means that all subsequent changes will not actually modify backed array data and will be stored separately;\n   *   <\/li>\n   *   <li>\n   *     Number of target changes are applied to the current object via standard API\n   *     ({@link #insert(DocumentImpl, CharSequence, int) insert},\n   *     {@link #remove(DocumentImpl, int, int, CharSequence) remove} and\n   *     {@link #replace(DocumentImpl, int, int, CharSequence, CharSequence, long, boolean) replace});\n   *   <\/li>\n   *   <li>\n   *     Client of this class indicates that <code>'massive change time'<\/code> is over by calling this method with <code>'false'<\/code>\n   *     argument. That flushes all deferred changes (if any) to the backed data array and makes every subsequent change to\n   *     be immediate flushed to the backed array;\n   *   <\/li>\n   * <\/ol>\n   * <\/pre>\n   * <p/>\n   * <b>Note:<\/b> we can't exclude possibility that <code>'defer changes'<\/code> mode is started but inadvertently not ended\n   * (due to programming error, unexpected exception etc). Hence, this class is free to automatically end\n   * <code>'defer changes'<\/code> mode when necessary in order to avoid memory leak with infinite deferred changes storing.\n   * \n   * @param deferredChangeMode    flag that defines if <code>'defer changes'<\/code> mode should be used by the current object\n   */\n  public void setDeferredChangeMode(boolean deferredChangeMode) {\n    myDeferredChangeMode = deferredChangeMode;\n    if (!deferredChangeMode) {\n      flushDeferredChanged();\n    }\n  }","id":47255,"modified_method":"/**\n   * There is a possible case that client of this class wants to perform great number of modifications in a short amount of time\n   * (e.g. end-user performs formatting of the document backed by the object of the current class). It may result in significant\n   * performance degradation is the changes are performed one by one (every time the change is applied tail content is shifted to\n   * the left or right). So, we may want to optimize that by avoiding actual array modification until information about\n   * all target changes is provided and perform array data moves only after that.\n   * <p/>\n   * This method allows to define that <code>'defer changes'<\/code> mode usages, i.e. expected usage pattern is as follows:\n   * <pre>\n   * <ol>\n   *   <li>\n   *     Client of this class enters <code>'defer changes'<\/code> mode (calls this method with <code>'true'<\/code> argument).\n   *     That means that all subsequent changes will not actually modify backed array data and will be stored separately;\n   *   <\/li>\n   *   <li>\n   *     Number of target changes are applied to the current object via standard API\n   *     ({@link #insert(DocumentImpl, CharSequence, int) insert},\n   *     {@link #remove(DocumentImpl, int, int, CharSequence) remove} and\n   *     {@link #replace(DocumentImpl, int, int, CharSequence, CharSequence, long, boolean) replace});\n   *   <\/li>\n   *   <li>\n   *     Client of this class indicates that <code>'massive change time'<\/code> is over by calling this method with <code>'false'<\/code>\n   *     argument. That flushes all deferred changes (if any) to the backed data array and makes every subsequent change to\n   *     be immediate flushed to the backed array;\n   *   <\/li>\n   * <\/ol>\n   * <\/pre>\n   * <p/>\n   * <b>Note:<\/b> we can't exclude possibility that <code>'defer changes'<\/code> mode is started but inadvertently not ended\n   * (due to programming error, unexpected exception etc). Hence, this class is free to automatically end\n   * <code>'defer changes'<\/code> mode when necessary in order to avoid memory leak with infinite deferred changes storing.\n   * \n   * @param deferredChangeMode    flag that defines if <code>'defer changes'<\/code> mode should be used by the current object\n   */\n  public void setDeferredChangeMode(boolean deferredChangeMode) {\n    if (deferredChangeMode && myDebugDeferredProcessing) {\n      myDebugArray.setText(null, myDebugTextOnBatchUpdateStart = toString());\n      myDebugDeferredChanges.clear();\n    }\n    myDeferredChangeMode = deferredChangeMode;\n    if (!deferredChangeMode) {\n      flushDeferredChanged();\n    }\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doInsert(final CharSequence s, final int startIndex) {\n    prepareForModification();\n\n    if (isDeferredChangeMode()) {\n      storeChange(new TextChangeImpl(s, startIndex));\n      return;\n    }\n    \n    int insertLength = s.length();\n    myArray = relocateArray(myArray, myCount + insertLength);\n    if (startIndex < myCount) {\n      System.arraycopy(myArray, startIndex, myArray, startIndex + insertLength, myCount - startIndex);\n    }\n    \n    CharArrayUtil.getChars(s, myArray, startIndex);\n    myCount += insertLength;\n  }","id":47256,"modified_method":"private void doInsert(final CharSequence s, final int startIndex) {\n    prepareForModification();\n\n    if (isDeferredChangeMode()) {\n      storeChange(new TextChangeImpl(s, startIndex));\n      if (myDebugDeferredProcessing) {\n        myDebugArray.doInsert(s, startIndex);\n      }\n      return;\n    }\n    \n    int insertLength = s.length();\n    myArray = relocateArray(myArray, myCount + insertLength);\n    if (startIndex < myCount) {\n      System.arraycopy(myArray, startIndex, myArray, startIndex + insertLength, myCount - startIndex);\n    }\n    \n    CharArrayUtil.getChars(s, myArray, startIndex);\n    myCount += insertLength;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private CharArray(int bufferSize, @NotNull TextChangesStorage deferredChangesStorage, @Nullable char[] data, int start, int end) {\n    myBufferSize = bufferSize;\n    myDeferredChangesStorage = deferredChangesStorage;\n    if (data == null) {\n      myOriginalSequence = \"\";\n    }\n    else {\n      myArray = data;\n      myCount = end - start;\n    }\n    if (start >= 0 && end >= 0) {\n      myStart = start;\n      myEnd = end;\n    }\n  }","id":47257,"modified_method":"private CharArray(final int bufferSize, @NotNull TextChangesStorage deferredChangesStorage, @Nullable char[] data, int start, int end) {\n    this(bufferSize, deferredChangesStorage, data, start, end, DEBUG_DEFERRED_PROCESSING);\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void getChars(final char[] dst, final int dstOffset) {\n    flushDeferredChanged();\n    if (myOriginalSequence != null) {\n      CharArrayUtil.getChars(myOriginalSequence,dst, dstOffset);\n    }\n    else {\n      System.arraycopy(myArray, myStart, dst, dstOffset, length());\n    }\n  }","id":47258,"modified_method":"public void getChars(final char[] dst, final int dstOffset) {\n    flushDeferredChanged();\n    if (myOriginalSequence != null) {\n      CharArrayUtil.getChars(myOriginalSequence,dst, dstOffset);\n    }\n    else {\n      System.arraycopy(myArray, myStart, dst, dstOffset, length());\n    }\n\n    if (myDebugDeferredProcessing && isDeferredChangeMode()) {\n      char[] expected = new char[dst.length];\n      myDebugArray.getChars(expected, dstOffset);\n      for (int i = dstOffset, j = myStart; i < dst.length && j < myArray.length; i++, j++) {\n        if (expected[i] != myArray[j]) {\n          dumpDebugInfo(String.format(\"getChars(char[], int). Given array of length %d, offset %d. Found char '%c' at index %d, \" +\n                                      \"expected to find '%c'\", dst.length, dstOffset, myArray[j], i, expected[i]));\n          break;\n        }\n      }\n    }\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doReplace(int startOffset, int endOffset, CharSequence newString) {\n    prepareForModification();\n\n    if (isDeferredChangeMode()) {\n      storeChange(new TextChangeImpl(newString, startOffset, endOffset));\n      return;\n    }\n    \n    int newLength = newString.length();\n    int oldLength = endOffset - startOffset;\n\n    CharArrayUtil.getChars(newString, myArray, startOffset, Math.min(newLength, oldLength));\n\n    if (newLength > oldLength) {\n      doInsert(newString.subSequence(oldLength, newLength), endOffset);\n    }\n    else if (newLength < oldLength) {\n      doRemove(startOffset + newLength, startOffset + oldLength);\n    }\n  }","id":47259,"modified_method":"private void doReplace(int startOffset, int endOffset, CharSequence newString) {\n    prepareForModification();\n\n    if (isDeferredChangeMode()) {\n      storeChange(new TextChangeImpl(newString, startOffset, endOffset));\n      if (myDebugDeferredProcessing) {\n        myDebugArray.doReplace(startOffset, endOffset, newString);\n      }\n      return;\n    }\n    \n    int newLength = newString.length();\n    int oldLength = endOffset - startOffset;\n\n    CharArrayUtil.getChars(newString, myArray, startOffset, Math.min(newLength, oldLength));\n\n    if (newLength > oldLength) {\n      doInsert(newString.subSequence(oldLength, newLength), endOffset);\n    }\n    else if (newLength < oldLength) {\n      doRemove(startOffset + newLength, startOffset + oldLength);\n    }\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Stores given change at collection of deferred changes (merging it with others if necessary) and updates current object\n   * state ({@link #length() length} etc).\n   * \n   * @param change      new change to store\n   */\n  private void storeChange(@NotNull TextChangeImpl change) {\n    if (myDeferredChangesStorage.size() >= MAX_DEFERRED_CHANGES_NUMBER) {\n      flushDeferredChanged();\n    }\n    myDeferredChangesStorage.store(change);\n    myDeferredShift += change.getDiff();\n  }","id":47260,"modified_method":"/**\n   * Stores given change at collection of deferred changes (merging it with others if necessary) and updates current object\n   * state ({@link #length() length} etc).\n   * \n   * @param change      new change to store\n   */\n  private void storeChange(@NotNull TextChangeImpl change) {\n    if (myDeferredChangesStorage.size() >= MAX_DEFERRED_CHANGES_NUMBER) {\n      flushDeferredChanged();\n    }\n    myDeferredChangesStorage.store(change);\n    myDeferredShift += change.getDiff();\n\n    if (myDebugDeferredProcessing) {\n      myDebugDeferredChanges.add(change);\n    }\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doRemove(final int startIndex, final int endIndex) {\n    if (startIndex == endIndex) {\n      return;\n    }\n    prepareForModification();\n\n    if (isDeferredChangeMode()) {\n      storeChange(new TextChangeImpl(\"\", startIndex, endIndex));\n      return;\n    }\n    \n    if (endIndex < myCount) {\n      System.arraycopy(myArray, endIndex, myArray, startIndex, myCount - endIndex);\n    }\n    myCount -= endIndex - startIndex;\n  }","id":47261,"modified_method":"private void doRemove(final int startIndex, final int endIndex) {\n    if (startIndex == endIndex) {\n      return;\n    }\n    prepareForModification();\n\n    if (isDeferredChangeMode()) {\n      storeChange(new TextChangeImpl(\"\", startIndex, endIndex));\n      if (myDebugDeferredProcessing) {\n        myDebugArray.doRemove(startIndex, endIndex);\n      }\n      return;\n    }\n    \n    if (endIndex < myCount) {\n      System.arraycopy(myArray, endIndex, myArray, startIndex, myCount - endIndex);\n    }\n    myCount -= endIndex - startIndex;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final char charAt(int i) {\n    if (i < 0 || i >= length()) {\n      throw new IndexOutOfBoundsException(\"Wrong offset: \" + i + \"; count:\" + length());\n    }\n    i += myStart;\n    if (myOriginalSequence != null) return myOriginalSequence.charAt(i);\n    if (hasDeferredChanges()) {\n      return myDeferredChangesStorage.charAt(myArray, i);\n    }\n    else {\n      return myArray[i];\n    }\n  }","id":47262,"modified_method":"public final char charAt(int i) {\n    if (i < 0 || i >= length()) {\n      throw new IndexOutOfBoundsException(\"Wrong offset: \" + i + \"; count:\" + length());\n    }\n    i += myStart;\n    if (myOriginalSequence != null) return myOriginalSequence.charAt(i);\n    final char result;\n    if (hasDeferredChanges()) {\n      result = myDeferredChangesStorage.charAt(myArray, i);\n    }\n    else {\n      result = myArray[i];\n    }\n\n    if (myDebugDeferredProcessing && isDeferredChangeMode()) {\n      char expected = myDebugArray.charAt(i);\n      if (expected != result) {\n        dumpDebugInfo(\n          String.format(\"Incorrect charAt() processing for index %d. Expected: '%c', actual: '%c'\", i, expected, result)\n        );\n      }\n    }\n    return result;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CharSequence substring(int start, int end) {\n    if (start == end) return \"\";\n    if (myOriginalSequence != null) {\n      return myOriginalSequence.subSequence(start, end);\n    }\n    return myDeferredChangesStorage.substring(myArray, start + myStart, end + myStart);\n  }","id":47263,"modified_method":"public CharSequence substring(final int start, final int end) {\n    if (start == end) return \"\";\n    final CharSequence result;\n    if (myOriginalSequence == null) {\n      result = myDeferredChangesStorage.substring(myArray, start + myStart, end + myStart);\n    }\n    else {\n      result = myOriginalSequence.subSequence(start, end);\n    }\n\n    if (myDebugDeferredProcessing && isDeferredChangeMode()) {\n      String expected = myDebugArray.substring(start, end).toString();\n      checkStrings(String.format(\"substring(%d, %d)\", start, end), expected, result.toString());\n    }\n    return result;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setText(DocumentImpl subj, CharSequence chars) {\n    myOriginalSequence = chars;\n    myArray = null;\n    myCount = chars.length();\n    myStringRef = null;\n    if (isSubSequence()) {\n      myDeferredChangesStorage = new TextChangesStorage();\n      myStart = 0;\n      myEnd = -1;\n    }\n    else {\n      myDeferredChangesStorage.clear();\n    }\n    trimToSize(subj);\n  }","id":47264,"modified_method":"public void setText(@Nullable final DocumentImpl subj, final CharSequence chars) {\n    myOriginalSequence = chars;\n    myArray = null;\n    myCount = chars.length();\n    myStringRef = null;\n    if (isSubSequence()) {\n      myDeferredChangesStorage = new TextChangesStorage();\n      myStart = 0;\n      myEnd = -1;\n    }\n    else {\n      myDeferredChangesStorage.clear();\n    }\n    if (subj != null) {\n      trimToSize(subj);\n    }\n\n    if (myDebugDeferredProcessing) {\n      myDebugArray.setText(subj, chars);\n      myDebugDeferredChanges.clear();\n    }\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n    String str = myStringRef != null ? myStringRef.get() : null;\n    if (str == null) {\n      if (myOriginalSequence != null) {\n        str = myOriginalSequence.toString();\n      }\n      else if (!hasDeferredChanges()) {\n        str = new String(myArray, myStart, myCount);\n      }\n      else {\n        str = substring(0, length()).toString();\n      }\n      myStringRef = new SoftReference<String>(str);\n    }\n    return str;\n  }","id":47265,"modified_method":"public String toString() {\n    String str = myStringRef != null ? myStringRef.get() : null;\n    if (str == null) {\n      if (myOriginalSequence != null) {\n        str = myOriginalSequence.toString();\n      }\n      else if (!hasDeferredChanges()) {\n        str = new String(myArray, myStart, myCount);\n      }\n      else {\n        str = substring(0, length()).toString();\n      }\n      myStringRef = new SoftReference<String>(str);\n    }\n    if (myDebugDeferredProcessing && isDeferredChangeMode()) {\n      String expected = myDebugArray.toString();\n      checkStrings(\"toString()\", expected, str);\n    }\n    return str;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public char[] getChars() {\n    if (myOriginalSequence != null) {\n      if (myArray == null) {\n        myArray = CharArrayUtil.fromSequence(myOriginalSequence);\n      }\n    }\n    flushDeferredChanged();\n    return myArray;\n  }","id":47266,"modified_method":"public char[] getChars() {\n    if (myOriginalSequence != null) {\n      if (myArray == null) {\n        myArray = CharArrayUtil.fromSequence(myOriginalSequence);\n      }\n    }\n    flushDeferredChanged();\n    if (myDebugDeferredProcessing && isDeferredChangeMode()) {\n      char[] expected = myDebugArray.getChars();\n      for (int i = 0, max = length(); i < max; i++) {\n        if (myArray[i] != expected[i]) {\n          dumpDebugInfo(String.format(\"getChars(). Index: %d, expected: %c, actual: %c\", i, expected[i], myArray[i]));\n          break;\n        }\n      }\n    }\n    return myArray;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Merges if necessary change stored at {@link #myChanges changes collection} at the given index with adjacent changes.\n   * \n   * @param insertionIndex      index of the change that can potentially be merged with adjacent changes\n   */\n  private void mergeIfNecessary(int insertionIndex) {\n    // Merge with previous if necessary.\n    ChangeEntry toMerge = myChanges.get(insertionIndex);\n    if (insertionIndex > 0) {\n      ChangeEntry left = myChanges.get(insertionIndex - 1);\n      if (left.change.getEnd() == toMerge.change.getStart()) {\n        String text = left.change.getText().toString() + toMerge.change.getText();\n        left.change = new TextChangeImpl(text, left.change.getStart(), toMerge.change.getEnd());\n        myChanges.remove(insertionIndex);\n        insertionIndex--;\n      }\n    }\n    \n    // Merge with next if necessary.\n    toMerge = myChanges.get(insertionIndex);\n    if (insertionIndex < myChanges.size() - 1) {\n      ChangeEntry right = myChanges.get(insertionIndex + 1);\n      if (toMerge.change.getEnd() == right.change.getStart()) {\n        String text = toMerge.change.getText().toString() + right.change.getText();\n        toMerge.change = new TextChangeImpl(text, toMerge.change.getStart(), right.change.getEnd());\n        myChanges.remove(insertionIndex + 1);\n      }\n    }\n  }","id":47267,"modified_method":"/**\n   * Merges if necessary change stored at {@link #myChanges changes collection} at the given index with adjacent changes.\n   * \n   * @param insertionIndex      index of the change that can potentially be merged with adjacent changes\n   */\n  private void mergeIfNecessary(int insertionIndex) {\n    // Merge with previous if necessary.\n    ChangeEntry toMerge = myChanges.get(insertionIndex);\n    if (insertionIndex > 0) {\n      ChangeEntry left = myChanges.get(insertionIndex - 1);\n      if (left.getClientEndOffset() == toMerge.clientStartOffset && left.change.getEnd() == toMerge.change.getStart()) {\n        String text = left.change.getText().toString() + toMerge.change.getText();\n        left.change = new TextChangeImpl(text, left.change.getStart(), toMerge.change.getEnd());\n        myChanges.remove(insertionIndex);\n        insertionIndex--;\n      }\n    }\n    \n    // Merge with next if necessary.\n    toMerge = myChanges.get(insertionIndex);\n    if (insertionIndex < myChanges.size() - 1) {\n      ChangeEntry right = myChanges.get(insertionIndex + 1);\n      if (toMerge.getClientEndOffset() == right.clientStartOffset && toMerge.change.getEnd() == right.change.getStart()) {\n        String text = toMerge.change.getText().toString() + right.change.getText();\n        toMerge.change = new TextChangeImpl(text, toMerge.change.getStart(), right.change.getEnd());\n        myChanges.remove(insertionIndex + 1);\n      }\n    }\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Stores given change at the current storage and returns its index at {@link #myChanges changes collection} (if any).\n   * \n   * @param change      change to store\n   * @return            non-negative value that indicates index under which given change is stored at the\n   *                    {@link #myChanges changes collection}; negative value if given change only modifies sub-range of\n   *                    already registered range\n   */\n  @SuppressWarnings({\"AssignmentToForLoopParameter\"})\n  private int doStore(@NotNull TextChange change) {\n    int newChangeStart = change.getStart();\n    int newChangeEnd = change.getEnd();\n    int insertionIndex = getChangeIndex(change.getStart());\n    int clientShift = 0; // 'Client text' shift before the given change to store. I.e. this value can be subtracted from the\n                         // given change's start/end offsets in order to get original document range affected by the given change.\n    int changeDiff = change.getText().length() - (change.getEnd() - change.getStart());\n    boolean updateClientOffsetOnly = false;\n    \n    if (insertionIndex < 0) {\n      insertionIndex = -insertionIndex - 1;\n      if (insertionIndex >= myChanges.size()) {\n        if (!myChanges.isEmpty()) {\n          ChangeEntry changeEntry = myChanges.get(myChanges.size() - 1);\n          clientShift = changeEntry.clientStartOffset - changeEntry.change.getStart() + changeEntry.change.getDiff();\n        }\n        myChanges.add(new ChangeEntry(\n          new TextChangeImpl(change.getText(), change.getStart() - clientShift, change.getEnd() - clientShift),\n          change.getStart()\n        ));\n        return insertionIndex;\n      }\n      else if (insertionIndex > 0 && !myChanges.isEmpty()) {\n        ChangeEntry changeEntry = myChanges.get(insertionIndex - 1);\n        clientShift = changeEntry.clientStartOffset - changeEntry.change.getStart() + changeEntry.change.getDiff();\n      }\n    }\n    else {\n      ChangeEntry changeEntry = myChanges.get(insertionIndex);\n      clientShift = changeEntry.clientStartOffset - changeEntry.change.getStart();\n    }\n    \n    for (int i = insertionIndex; i < myChanges.size(); i++) {\n      ChangeEntry changeEntry = myChanges.get(i);\n      int storedClientStart = changeEntry.change.getStart() + clientShift;\n      CharSequence storedText = changeEntry.change.getText();\n      int storedClientEnd = storedClientStart + storedText.length();\n\n      // Stored change lays after the new one.\n      if (!updateClientOffsetOnly && storedClientStart > newChangeEnd) {\n        if (changeDiff != 0) {\n          updateClientOffsetOnly = true;\n        }\n        else {\n          break;\n        }\n      }\n\n      if (updateClientOffsetOnly) {\n        changeEntry.clientStartOffset += changeDiff;\n        continue;\n      }\n      \n      // Stored change lays before the new one.\n      if (storedClientEnd <= newChangeStart) {\n        clientShift += changeEntry.change.getDiff();\n        insertionIndex = i + 1;\n        continue;\n      }\n      \n      // Check if given change targets sub-range of the stored one.\n      if (storedClientStart <= newChangeStart && storedClientEnd >= newChangeEnd) {\n        StringBuilder adjustedText = new StringBuilder();\n        if (storedClientStart < newChangeStart) {\n          adjustedText.append(storedText.subSequence(0, newChangeStart - storedClientStart));\n        }\n        adjustedText.append(change.getText());\n        if (storedClientEnd > newChangeEnd) {\n          adjustedText.append(storedText.subSequence(newChangeEnd - storedClientStart, storedText.length()));\n        }\n\n        if (adjustedText.length() == 0 && changeEntry.change.getStart() == changeEntry.change.getEnd()) {\n          myChanges.remove(i);\n          insertionIndex = -1;\n          updateClientOffsetOnly = true;\n          continue;\n        }\n\n        TextChangeImpl adjusted = new TextChangeImpl(adjustedText, changeEntry.change.getStart(), changeEntry.change.getEnd());\n        myChanges.set(i, new ChangeEntry(adjusted, adjusted.getStart()));\n        insertionIndex = -1;\n        updateClientOffsetOnly = true;\n        continue;\n      }\n\n      // Check if given change completely contains stored change range.\n      if (newChangeStart <= storedClientStart && newChangeEnd >= storedClientEnd) {\n        myChanges.remove(i);\n        insertionIndex = i;\n        newChangeEnd -= changeEntry.change.getDiff();\n        i--;\n        continue;\n      }\n\n      // Check if given change intersects stored change range from the left.\n      if (newChangeStart <= storedClientStart && newChangeEnd > storedClientStart) {\n        int numberOfStoredChangeSymbolsToRemove = newChangeEnd - storedClientStart;\n        CharSequence adjustedText = storedText.subSequence(numberOfStoredChangeSymbolsToRemove, storedText.length());\n        changeEntry.change = new TextChangeImpl(adjustedText, changeEntry.change.getStart(), changeEntry.change.getEnd());\n        newChangeEnd -= numberOfStoredChangeSymbolsToRemove;\n        insertionIndex = i;\n        continue;\n      }\n\n      // Check if given change intersects stored change range from the right.\n      if (newChangeStart < storedClientEnd && newChangeEnd >= storedClientEnd) {\n        CharSequence adjustedText = storedText.subSequence(0, newChangeStart - storedClientStart);\n        TextChangeImpl adjusted = new TextChangeImpl(adjustedText, changeEntry.change.getStart(), changeEntry.change.getEnd());\n        myChanges.set(i, new ChangeEntry(adjusted, adjusted.getStart()));\n        clientShift += adjusted.getDiff();\n        newChangeEnd -= storedClientEnd - newChangeStart;\n        insertionIndex = i + 1;\n      }\n    }\n\n    if (insertionIndex >= 0) {\n      myChanges.add(insertionIndex, new ChangeEntry(\n        new TextChangeImpl(change.getText(), newChangeStart - clientShift, newChangeEnd - clientShift),\n        change.getStart()\n      ));\n    }\n    \n    return insertionIndex;\n  }","id":47268,"modified_method":"/**\n   * Stores given change at the current storage and returns its index at {@link #myChanges changes collection} (if any).\n   * \n   * @param change      change to store\n   * @return            non-negative value that indicates index under which given change is stored at the\n   *                    {@link #myChanges changes collection}; negative value if given change only modifies sub-range of\n   *                    already registered range\n   */\n  @SuppressWarnings({\"AssignmentToForLoopParameter\"})\n  private int doStore(@NotNull TextChange change) {\n    int newChangeStart = change.getStart();\n    int newChangeEnd = change.getEnd();\n    int insertionIndex = getChangeIndex(change.getStart());\n    int clientShift = 0; // 'Client text' shift before the given change to store. I.e. this value can be subtracted from the\n                         // given change's start/end offsets in order to get original document range affected by the given change.\n    int changeDiff = change.getText().length() - (change.getEnd() - change.getStart());\n    boolean updateClientOffsetOnly = false;\n    \n    if (insertionIndex < 0) {\n      insertionIndex = -insertionIndex - 1;\n      if (insertionIndex >= myChanges.size()) {\n        if (!myChanges.isEmpty()) {\n          ChangeEntry changeEntry = myChanges.get(myChanges.size() - 1);\n          clientShift = changeEntry.clientStartOffset - changeEntry.change.getStart() + changeEntry.change.getDiff();\n        }\n        myChanges.add(new ChangeEntry(\n          new TextChangeImpl(change.getText(), change.getStart() - clientShift, change.getEnd() - clientShift),\n          change.getStart()\n        ));\n        return insertionIndex;\n      }\n      else if (insertionIndex > 0 && !myChanges.isEmpty()) {\n        ChangeEntry changeEntry = myChanges.get(insertionIndex - 1);\n        clientShift = changeEntry.clientStartOffset - changeEntry.change.getStart() + changeEntry.change.getDiff();\n      }\n    }\n    else {\n      ChangeEntry changeEntry = myChanges.get(insertionIndex);\n      clientShift = changeEntry.clientStartOffset - changeEntry.change.getStart();\n    }\n    \n    for (int i = insertionIndex; i < myChanges.size(); i++) {\n      ChangeEntry changeEntry = myChanges.get(i);\n      int storedClientStart = changeEntry.change.getStart() + clientShift;\n      CharSequence storedText = changeEntry.change.getText();\n      int storedClientEnd = storedClientStart + storedText.length();\n\n      // Stored change lays after the new one.\n      if (!updateClientOffsetOnly && storedClientStart > newChangeEnd) {\n        if (changeDiff != 0) {\n          updateClientOffsetOnly = true;\n        }\n        else {\n          break;\n        }\n      }\n\n      if (updateClientOffsetOnly) {\n        changeEntry.clientStartOffset += changeDiff;\n        continue;\n      }\n      \n      // Stored change lays before the new one.\n      if (storedClientEnd <= newChangeStart) {\n        clientShift += changeEntry.change.getDiff();\n        insertionIndex = i + 1;\n        continue;\n      }\n      \n      // Check if given change targets sub-range of the stored one.\n      if (storedClientStart <= newChangeStart && storedClientEnd >= newChangeEnd) {\n        StringBuilder adjustedText = new StringBuilder();\n        if (storedClientStart < newChangeStart) {\n          adjustedText.append(storedText.subSequence(0, newChangeStart - storedClientStart));\n        }\n        adjustedText.append(change.getText());\n        if (storedClientEnd > newChangeEnd) {\n          adjustedText.append(storedText.subSequence(newChangeEnd - storedClientStart, storedText.length()));\n        }\n\n        if (adjustedText.length() == 0 && changeEntry.change.getStart() == changeEntry.change.getEnd()) {\n          myChanges.remove(i);\n          insertionIndex = -1;\n          updateClientOffsetOnly = true;\n          continue;\n        }\n\n        changeEntry.change = new TextChangeImpl(adjustedText, changeEntry.change.getStart(), changeEntry.change.getEnd());\n        insertionIndex = -1;\n        updateClientOffsetOnly = true;\n        continue;\n      }\n\n      // Check if given change completely contains stored change range.\n      if (newChangeStart <= storedClientStart && newChangeEnd >= storedClientEnd) {\n        myChanges.remove(i);\n        insertionIndex = i;\n        newChangeEnd -= changeEntry.change.getDiff();\n        i--;\n        continue;\n      }\n\n      // Check if given change intersects stored change range from the left.\n      if (newChangeStart <= storedClientStart && newChangeEnd > storedClientStart) {\n        int numberOfStoredChangeSymbolsToRemove = newChangeEnd - storedClientStart;\n        CharSequence adjustedText = storedText.subSequence(numberOfStoredChangeSymbolsToRemove, storedText.length());\n        changeEntry.change = new TextChangeImpl(adjustedText, changeEntry.change.getStart(), changeEntry.change.getEnd());\n        changeEntry.clientStartOffset += changeDiff + numberOfStoredChangeSymbolsToRemove;\n        newChangeEnd -= numberOfStoredChangeSymbolsToRemove;\n        insertionIndex = i;\n        continue;\n      }\n\n      // Check if given change intersects stored change range from the right.\n      if (newChangeStart < storedClientEnd && newChangeEnd >= storedClientEnd) {\n        CharSequence adjustedText = storedText.subSequence(0, newChangeStart - storedClientStart);\n        TextChangeImpl adjusted = new TextChangeImpl(adjustedText, changeEntry.change.getStart(), changeEntry.change.getEnd());\n        changeEntry.change = adjusted;\n        clientShift += adjusted.getDiff();\n        newChangeEnd -= storedClientEnd - newChangeStart;\n        insertionIndex = i + 1;\n      }\n    }\n\n    if (insertionIndex >= 0) {\n      myChanges.add(insertionIndex, new ChangeEntry(\n        new TextChangeImpl(change.getText(), newChangeStart - clientShift, newChangeEnd - clientShift),\n        change.getStart()\n      ));\n    }\n    \n    return insertionIndex;\n  }","commit_id":"b434c54f80b6e8723e9e0ad51df386ba07b2d68d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean canBeI18ned(PsiLiteralExpression expression, String value, final Set<PsiModifierListOwner> nonNlsTargets) {\n    if (ignoreForNonAlpha && !StringUtil.containsAlphaCharacters(value)) {\n      return false;\n    }\n\n    PsiField parentField = PsiTreeUtil.getParentOfType(expression, PsiField.class);\n    if (parentField != null) {\n      nonNlsTargets.add(parentField);\n    }\n\n    if (I18nUtil.isPassedToAnnotatedParam(expression, AnnotationUtil.NON_NLS, new HashMap<String, Object>(), nonNlsTargets)) {\n      return false;\n    }\n\n    if (isInNonNlsCall(expression, nonNlsTargets)) {\n      return false;\n    }\n\n    if (isInNonNlsEquals(expression, nonNlsTargets)) {\n      return false;\n    }\n\n    if (isPassedToNonNlsVariable(expression, nonNlsTargets)) {\n      return false;\n    }\n\n    if (I18nUtil.mustBePropertyKey(expression, new HashMap<String, Object>())) {\n      return false;\n    }\n\n    if (isReturnedFromNonNlsMethod(expression, nonNlsTargets)) {\n      return false;\n    }\n    if (ignoreForAssertStatements && isArgOfAssertStatement(expression)) {\n      return false;\n    }\n    if (ignoreForExceptionConstructors && isArgOfExceptionConstructor(expression)) {\n      return false;\n    }\n    if (!ignoreForExceptionConstructors && isArgOfSpecifiedExceptionConstructor(expression, ignoreForSpecifiedExceptionConstructors.split(\",\"))) {\n      return false;\n    }\n    if (ignoreForJUnitAsserts && isArgOfJUnitAssertion(expression)) {\n      return false;\n    }\n    if (ignoreForClassReferences && isClassRef(expression, value)) {\n      return false;\n    }\n    if (ignoreForPropertyKeyReferences && I18nUtil.isPropertyRef(expression, value, null)) {\n      return false;\n    }\n    if (ignoreToString && isToString(expression)) {\n      return false;\n    }\n\n    Pattern pattern = myCachedNonNlsPattern;\n    if (pattern != null) {\n      Project project = expression.getProject();\n      Document document = PsiDocumentManager.getInstance(project).getDocument(expression.getContainingFile());\n      int line = document.getLineNumber(expression.getTextRange().getStartOffset());\n      CharSequence lineText = document.getCharsSequence().subSequence(document.getLineStartOffset(line), document.getLineEndOffset(line));\n      if (pattern.matcher(lineText).matches()) {\n        return false;\n      }\n    }\n\n    return true;\n  }","id":47269,"modified_method":"private boolean canBeI18ned(PsiLiteralExpression expression, String value, final Set<PsiModifierListOwner> nonNlsTargets) {\n    if (ignoreForNonAlpha && !StringUtil.containsAlphaCharacters(value)) {\n      return false;\n    }\n\n    PsiField parentField = PsiTreeUtil.getParentOfType(expression, PsiField.class);\n    if (parentField != null) {\n      nonNlsTargets.add(parentField);\n    }\n\n    if (I18nUtil.isPassedToAnnotatedParam(expression, AnnotationUtil.NON_NLS, new HashMap<String, Object>(), nonNlsTargets)) {\n      return false;\n    }\n\n    if (isInNonNlsCall(expression, nonNlsTargets)) {\n      return false;\n    }\n\n    if (isInNonNlsEquals(expression, nonNlsTargets)) {\n      return false;\n    }\n\n    if (isPassedToNonNlsVariable(expression, nonNlsTargets)) {\n      return false;\n    }\n\n    if (I18nUtil.mustBePropertyKey(expression, new HashMap<String, Object>())) {\n      return false;\n    }\n\n    if (isReturnedFromNonNlsMethod(expression, nonNlsTargets)) {\n      return false;\n    }\n    if (ignoreForAssertStatements && isArgOfAssertStatement(expression)) {\n      return false;\n    }\n    if (ignoreForExceptionConstructors && isArgOfExceptionConstructor(expression)) {\n      return false;\n    }\n    if (!ignoreForExceptionConstructors && isArgOfSpecifiedExceptionConstructor(expression, ignoreForSpecifiedExceptionConstructors.split(\",\"))) {\n      return false;\n    }\n    if (ignoreForJUnitAsserts && isArgOfJUnitAssertion(expression)) {\n      return false;\n    }\n    if (ignoreForClassReferences && isClassRef(expression, value)) {\n      return false;\n    }\n    if (ignoreForPropertyKeyReferences && I18nUtil.isPropertyRef(expression, value, null)) {\n      return false;\n    }\n    if (ignoreToString && isToString(expression)) {\n      return false;\n    }\n\n    Pattern pattern = myCachedNonNlsPattern;\n    if (pattern != null) {\n      Project project = expression.getProject();\n      PsiFile file = expression.getContainingFile();\n      Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n      int line = document.getLineNumber(expression.getTextRange().getStartOffset());\n      int lineStartOffset = document.getLineStartOffset(line);\n      CharSequence lineText = document.getCharsSequence().subSequence(lineStartOffset, document.getLineEndOffset(line));\n\n      Matcher matcher = pattern.matcher(lineText);\n      int start = 0;\n      while (matcher.find(start)) {\n        start = matcher.start();\n        PsiElement element = file.findElementAt(lineStartOffset + start);\n        if (PsiTreeUtil.getParentOfType(element, PsiComment.class, false, true) != null) return false;\n        if (start == lineText.length() - 1) break;\n        start++;\n      }\n    }\n\n    return true;\n  }","commit_id":"328fc65f061d02a75c4b5498af4563a87cd28b7a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void cacheNonNlsCommentPattern() {\n    if (nonNlsCommentPattern.trim().length() == 0) {\n      myCachedNonNlsPattern = null;\n    }\n    else {\n      @NonNls String regex = \".*//\\\\s*\" + nonNlsCommentPattern + \".*\";\n      myCachedNonNlsPattern = Pattern.compile(regex);\n    }\n  }","id":47270,"modified_method":"public void cacheNonNlsCommentPattern() {\n    if (nonNlsCommentPattern.trim().length() == 0) {\n      myCachedNonNlsPattern = null;\n    }\n    else {\n      myCachedNonNlsPattern = Pattern.compile(nonNlsCommentPattern);\n    }\n  }","commit_id":"328fc65f061d02a75c4b5498af4563a87cd28b7a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public YAMLScalar handleContentChange(@NotNull YAMLScalar element, @NotNull TextRange range, String newContent)\n    throws IncorrectOperationException {\n    return element;\n  }","id":47271,"modified_method":"@Override\n  public YAMLScalar handleContentChange(@NotNull YAMLScalar element, @NotNull TextRange range, String newContent)\n    throws IncorrectOperationException {\n    throw new IncorrectOperationException();\n  }","commit_id":"6c401ca974d36f12b1097b699524ef57afa5f255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getTextValue() {\n    final String text = getText();\n\n\n    final StringBuilder builder = new StringBuilder();\n    CharSequence prevString = null;\n    boolean isFirst = true;\n    for (TextRange range : getContentRanges()) {\n      final CharSequence curString = range.subSequence(text);\n\n      if (!isFirst) {\n        builder.append(getRangesJoiner(prevString, curString));\n      }\n      else {\n        isFirst = false;\n      }\n      builder.append(curString);\n      prevString = curString;\n    }\n    return builder.toString();\n  }","id":47272,"modified_method":"@NotNull\n  @Override\n  public String getTextValue() {\n    final String text = getText();\n    final List<TextRange> contentRanges = getContentRanges();\n\n    final StringBuilder builder = new StringBuilder();\n    CharSequence nextString = null;\n\n    for (int i = 0; i < contentRanges.size(); i++) {\n      final TextRange range = contentRanges.get(i);\n      \n      final CharSequence curString = i == 0 ? range.subSequence(text) : nextString;\n      assert curString != null;\n      builder.append(curString);\n\n      if (i + 1 != contentRanges.size()) {\n        nextString = contentRanges.get(i + 1).subSequence(text);\n        builder.append(getRangesJoiner(curString, nextString));\n      }\n    }\n    return processReplacements(builder, getDecodeReplacements(builder));\n  }","commit_id":"6c401ca974d36f12b1097b699524ef57afa5f255","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void convert(String[] args, StartParameter startParameter) {\n        OptionSet options;\n        try {\n            options = parser.parse(args);\n        } catch (OptionException e) {\n            throw new CommandLineArgumentException(e.getMessage());\n        }\n\n        if (options.has(HELP)) {\n            startParameter.setShowHelp(true);\n            return;\n        }\n\n        if (options.has(VERSION)) {\n            startParameter.setShowVersion(true);\n            return;\n        }\n\n        if (options.has(GUI)) {\n            startParameter.setLaunchGUI(true);\n        }\n\n        if (options.has(NO_DEFAULT_IMPORTS)) {\n            startParameter.setDefaultImportsFile(null);\n        } else if (options.has(DEFAULT_IMPORT_FILE)) {\n            startParameter.setDefaultImportsFile(new File(options.argumentOf(DEFAULT_IMPORT_FILE)));\n        }\n\n        if (options.has(SYSTEM_PROP)) {\n            List<String> props = options.argumentsOf(SYSTEM_PROP);\n            for (String keyValueExpression : props) {\n                String[] elements = keyValueExpression.split(\"=\");\n                startParameter.getSystemPropertiesArgs().put(elements[0], elements.length == 1 ? \"\" : elements[1]);\n            }\n        }\n\n        if (options.has(PROJECT_PROP)) {\n            List<String> props = options.argumentsOf(PROJECT_PROP);\n            for (String keyValueExpression : props) {\n                String[] elements = keyValueExpression.split(\"=\");\n                startParameter.getProjectProperties().put(elements[0], elements.length == 1 ? \"\" : elements[1]);\n            }\n        }\n\n        if (options.has(NO_SEARCH_UPWARDS)) {\n            startParameter.setSearchUpwards(false);\n        }\n\n        if (options.has(PROJECT_DIR)) {\n            startParameter.setProjectDir(new File(options.argumentOf(PROJECT_DIR)));\n        }\n        if (options.hasArgument(GRADLE_USER_HOME)) {\n            startParameter.setGradleUserHomeDir(new File(options.argumentOf(GRADLE_USER_HOME)));\n        }\n        if (options.hasArgument(BUILD_FILE)) {\n            startParameter.setBuildFile(new File(options.argumentOf(BUILD_FILE)));\n        }\n        if (options.hasArgument(SETTINGS_FILE)) {\n            startParameter.setSettingsFile(new File(options.argumentOf(SETTINGS_FILE)));\n        }\n\n        for (String script : (List<String>) options.argumentsOf(INIT_SCRIPT)) {\n            startParameter.addInitScript(new File(script));\n        }\n\n        if (options.has(CACHE)) {\n            try {\n                startParameter.setCacheUsage(CacheUsage.fromString(options.valueOf(CACHE).toString()));\n            } catch (InvalidUserDataException e) {\n                throw new CommandLineArgumentException(e.getMessage());\n            }\n        }\n\n        if (options.has(EMBEDDED_SCRIPT)) {\n            if (options.has(BUILD_FILE) || options.has(NO_SEARCH_UPWARDS) || options.has(SETTINGS_FILE)) {\n                System.err.println(String.format(\n                        \"Error: The -%s option can't be used together with the -%s, -%s or -%s options.\",\n                        EMBEDDED_SCRIPT, BUILD_FILE, SETTINGS_FILE, NO_SEARCH_UPWARDS));\n                throw new CommandLineArgumentException(String.format(\n                        \"Error: The -%s option can't be used together with the -%s, -%s or -%s options.\",\n                        EMBEDDED_SCRIPT, BUILD_FILE, SETTINGS_FILE, NO_SEARCH_UPWARDS));\n            }\n            startParameter.useEmbeddedBuildFile(options.argumentOf(EMBEDDED_SCRIPT));\n        }\n\n        if (options.has(FULL_STACKTRACE)) {\n            if (options.has(STACKTRACE)) {\n                throw new CommandLineArgumentException(String.format(\n                        \"Error: The -%s option can't be used together with the -%s option.\", FULL_STACKTRACE,\n                        STACKTRACE));\n            }\n            startParameter.setShowStacktrace(StartParameter.ShowStacktrace.ALWAYS_FULL);\n        } else if (options.has(STACKTRACE)) {\n            startParameter.setShowStacktrace(StartParameter.ShowStacktrace.ALWAYS);\n        }\n\n        if (options.has(TASKS) && options.has(PROPERTIES)) {\n            throw new CommandLineArgumentException(String.format(\n                    \"Error: The -%s and -%s options cannot be used together.\", TASKS, PROPERTIES));\n        }\n\n        if (options.has(PROJECT_DEPENDENCY_TASK_NAMES) && options.has(NO_PROJECT_DEPENDENCY_REBUILD)) {\n            throw new CommandLineArgumentException(String.format(\n                    \"Error: The -%s and -%s options cannot be used together.\", PROJECT_DEPENDENCY_TASK_NAMES,\n                    NO_PROJECT_DEPENDENCY_REBUILD));\n        } else if (options.has(NO_PROJECT_DEPENDENCY_REBUILD)) {\n            startParameter.setProjectDependenciesBuildInstruction(new ProjectDependenciesBuildInstruction(null));\n        } else if (options.has(PROJECT_DEPENDENCY_TASK_NAMES)) {\n            List<String> normalizedTaskNames = new ArrayList<String>();\n            for (Object o : options.valuesOf(PROJECT_DEPENDENCY_TASK_NAMES)) {\n                String taskName = (String) o;\n                normalizedTaskNames.add(taskName.trim());\n            }\n            startParameter.setProjectDependenciesBuildInstruction(new ProjectDependenciesBuildInstruction(\n                    normalizedTaskNames));\n        }\n\n        if (options.has(TASKS)) {\n            startParameter.setBuildExecuter(new BuiltInTasksBuildExecuter(\n                    BuiltInTasksBuildExecuter.Options.TASKS, options.argumentOf(TASKS)));\n        } else if (options.has(PROPERTIES)) {\n            startParameter.setBuildExecuter(new BuiltInTasksBuildExecuter(\n                    BuiltInTasksBuildExecuter.Options.PROPERTIES, options.argumentOf(PROPERTIES)));\n        } else if (options.has(DEPENDENCIES)) {\n            startParameter.setBuildExecuter(new BuiltInTasksBuildExecuter(\n                    BuiltInTasksBuildExecuter.Options.DEPENDENCIES, options.argumentOf(DEPENDENCIES)));\n        } else if (!options.nonOptionArguments().isEmpty()) {\n            startParameter.setTaskNames(options.nonOptionArguments());\n        }\n\n        if (options.has(DRY_RUN)) {\n            startParameter.setDryRun(true);\n        }\n\n        if (options.has(NO_OPT)) {\n            startParameter.setNoOpt(true);\n        }\n\n        if (options.has(EXCLUDE_TASK)) {\n            startParameter.setExcludedTaskNames(options.valuesOf(EXCLUDE_TASK));\n        }\n\n        startParameter.setLogLevel(getLogLevel(options));\n    }","id":47273,"modified_method":"public void convert(String[] args, StartParameter startParameter) {\n        OptionSet options;\n        try {\n            options = parser.parse(args);\n        } catch (OptionException e) {\n            throw new CommandLineArgumentException(e.getMessage());\n        }\n\n        if (options.has(HELP)) {\n            startParameter.setShowHelp(true);\n            return;\n        }\n\n        if (options.has(VERSION)) {\n            startParameter.setShowVersion(true);\n            return;\n        }\n\n        if (options.has(GUI)) {\n            startParameter.setLaunchGUI(true);\n        }\n\n        if (options.has(NO_DEFAULT_IMPORTS)) {\n            startParameter.setDefaultImportsFile(null);\n        } else if (options.has(DEFAULT_IMPORT_FILE)) {\n            startParameter.setDefaultImportsFile(new File((String) options.valueOf(DEFAULT_IMPORT_FILE)));\n        }\n\n        if (options.has(SYSTEM_PROP)) {\n            List<String> props = (List<String>) options.valuesOf(SYSTEM_PROP);\n            for (String keyValueExpression : props) {\n                String[] elements = keyValueExpression.split(\"=\");\n                startParameter.getSystemPropertiesArgs().put(elements[0], elements.length == 1 ? \"\" : elements[1]);\n            }\n        }\n\n        if (options.has(PROJECT_PROP)) {\n            List<String> props = (List<String>) options.valuesOf(PROJECT_PROP);\n            for (String keyValueExpression : props) {\n                String[] elements = keyValueExpression.split(\"=\");\n                startParameter.getProjectProperties().put(elements[0], elements.length == 1 ? \"\" : elements[1]);\n            }\n        }\n\n        if (options.has(NO_SEARCH_UPWARDS)) {\n            startParameter.setSearchUpwards(false);\n        }\n\n        if (options.has(PROJECT_DIR)) {\n            startParameter.setProjectDir(new File((String) options.valueOf(PROJECT_DIR)));\n        }\n        if (options.hasArgument(GRADLE_USER_HOME)) {\n            startParameter.setGradleUserHomeDir(new File((String) options.valueOf(GRADLE_USER_HOME)));\n        }\n        if (options.hasArgument(BUILD_FILE)) {\n            startParameter.setBuildFile(new File((String) options.valueOf(BUILD_FILE)));\n        }\n        if (options.hasArgument(SETTINGS_FILE)) {\n            startParameter.setSettingsFile(new File((String) options.valueOf(SETTINGS_FILE)));\n        }\n\n        for (String script : (List<String>) options.valuesOf(INIT_SCRIPT)) {\n            startParameter.addInitScript(new File(script));\n        }\n\n        if (options.has(CACHE)) {\n            try {\n                startParameter.setCacheUsage(CacheUsage.fromString(options.valueOf(CACHE).toString()));\n            } catch (InvalidUserDataException e) {\n                throw new CommandLineArgumentException(e.getMessage());\n            }\n        }\n\n        if (options.has(EMBEDDED_SCRIPT)) {\n            if (options.has(BUILD_FILE) || options.has(NO_SEARCH_UPWARDS) || options.has(SETTINGS_FILE)) {\n                System.err.println(String.format(\n                        \"Error: The -%s option can't be used together with the -%s, -%s or -%s options.\",\n                        EMBEDDED_SCRIPT, BUILD_FILE, SETTINGS_FILE, NO_SEARCH_UPWARDS));\n                throw new CommandLineArgumentException(String.format(\n                        \"Error: The -%s option can't be used together with the -%s, -%s or -%s options.\",\n                        EMBEDDED_SCRIPT, BUILD_FILE, SETTINGS_FILE, NO_SEARCH_UPWARDS));\n            }\n            startParameter.useEmbeddedBuildFile((String) options.valueOf(EMBEDDED_SCRIPT));\n        }\n\n        if (options.has(FULL_STACKTRACE)) {\n            if (options.has(STACKTRACE)) {\n                throw new CommandLineArgumentException(String.format(\n                        \"Error: The -%s option can't be used together with the -%s option.\", FULL_STACKTRACE,\n                        STACKTRACE));\n            }\n            startParameter.setShowStacktrace(StartParameter.ShowStacktrace.ALWAYS_FULL);\n        } else if (options.has(STACKTRACE)) {\n            startParameter.setShowStacktrace(StartParameter.ShowStacktrace.ALWAYS);\n        }\n\n        if (options.has(TASKS) && options.has(PROPERTIES)) {\n            throw new CommandLineArgumentException(String.format(\n                    \"Error: The -%s and -%s options cannot be used together.\", TASKS, PROPERTIES));\n        }\n\n        if (options.has(PROJECT_DEPENDENCY_TASK_NAMES) && options.has(NO_PROJECT_DEPENDENCY_REBUILD)) {\n            throw new CommandLineArgumentException(String.format(\n                    \"Error: The -%s and -%s options cannot be used together.\", PROJECT_DEPENDENCY_TASK_NAMES,\n                    NO_PROJECT_DEPENDENCY_REBUILD));\n        } else if (options.has(NO_PROJECT_DEPENDENCY_REBUILD)) {\n            startParameter.setProjectDependenciesBuildInstruction(new ProjectDependenciesBuildInstruction(null));\n        } else if (options.has(PROJECT_DEPENDENCY_TASK_NAMES)) {\n            List<String> normalizedTaskNames = new ArrayList<String>();\n            for (Object o : options.valuesOf(PROJECT_DEPENDENCY_TASK_NAMES)) {\n                String taskName = (String) o;\n                normalizedTaskNames.add(taskName.trim());\n            }\n            startParameter.setProjectDependenciesBuildInstruction(new ProjectDependenciesBuildInstruction(\n                    normalizedTaskNames));\n        }\n\n        if (options.has(TASKS)) {\n            startParameter.setBuildExecuter(new BuiltInTasksBuildExecuter(BuiltInTasksBuildExecuter.Options.TASKS,\n                    (String) options.valueOf(TASKS)));\n        } else if (options.has(PROPERTIES)) {\n            startParameter.setBuildExecuter(new BuiltInTasksBuildExecuter(BuiltInTasksBuildExecuter.Options.PROPERTIES,\n                    (String) options.valueOf(PROPERTIES)));\n        } else if (options.has(DEPENDENCIES)) {\n            startParameter.setBuildExecuter(new BuiltInTasksBuildExecuter(\n                    BuiltInTasksBuildExecuter.Options.DEPENDENCIES, (String) options.valueOf(DEPENDENCIES)));\n        } else if (!options.nonOptionArguments().isEmpty()) {\n            startParameter.setTaskNames(options.nonOptionArguments());\n        }\n\n        if (options.has(DRY_RUN)) {\n            startParameter.setDryRun(true);\n        }\n\n        if (options.has(NO_OPT)) {\n            startParameter.setNoOpt(true);\n        }\n\n        if (options.has(EXCLUDE_TASK)) {\n            startParameter.setExcludedTaskNames((List<String>) options.valuesOf(EXCLUDE_TASK));\n        }\n\n        startParameter.setLogLevel(getLogLevel(options));\n    }","commit_id":"e4393384633b6b09dcb1e6245994fe1b436b3a3b","url":"https://github.com/gradle/gradle"},{"original_method":"public static boolean isRelevant(Column column, ColumnFamily container, int gcBefore)\n    {\n        // the column itself must be not gc-able (it is live, or a still relevant tombstone, or has live subcolumns), (1)\n        // and if its container is deleted, the column must be changed more recently than the container tombstone (2)\n        // (since otherwise, the only thing repair cares about is the container tombstone)\n        long maxChange = column.timestamp();\n        return (column.getLocalDeletionTime() >= gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1)\n               && (!container.deletionInfo().isDeleted(column.name(), maxChange)); // (2)\n    }","id":47274,"modified_method":"public static boolean isRelevant(Column column, ColumnFamily container, int gcBefore)\n    {\n        // the column itself must be not gc-able (it is live, or a still relevant tombstone, or has live subcolumns), (1)\n        // and if its container is deleted, the column must be changed more recently than the container tombstone (2)\n        // (since otherwise, the only thing repair cares about is the container tombstone)\n        return (column.getLocalDeletionTime() >= gcBefore || column.timestamp() > column.getMarkedForDeleteAt()) // (1)\n               && (!container.deletionInfo().isDeleted(column.name(), column.timestamp())); // (2)\n    }","commit_id":"b6a0284fb909c976f4bcf61c7623dd75de2cdd32","url":"https://github.com/apache/cassandra"},{"original_method":"private void serializeRow(Row row)\n    {\n        try\n        {\n            json.writeStartObject();\n            String rowType = row.isStatic() ? \"static_block\" : \"row\";\n            json.writeFieldName(\"type\");\n            json.writeString(rowType);\n            json.writeNumberField(\"position\", this.currentPosition);\n\n            // Only print clustering information for non-static rows.\n            if (!row.isStatic())\n            {\n                serializeClustering(row.clustering());\n            }\n\n            LivenessInfo liveInfo = row.primaryKeyLivenessInfo();\n            if (!liveInfo.isEmpty())\n            {\n                objectIndenter.setCompact(false);\n                json.writeFieldName(\"liveness_info\");\n                objectIndenter.setCompact(true);\n                json.writeStartObject();\n                json.writeFieldName(\"tstamp\");\n                json.writeNumber(liveInfo.timestamp());\n                if (liveInfo.isExpiring())\n                {\n                    json.writeFieldName(\"ttl\");\n                    json.writeNumber(liveInfo.ttl());\n                    json.writeFieldName(\"expires_at\");\n                    json.writeNumber(liveInfo.localExpirationTime());\n                    json.writeFieldName(\"expired\");\n                    json.writeBoolean(liveInfo.localExpirationTime() < (System.currentTimeMillis() / 1000));\n                }\n                json.writeEndObject();\n                objectIndenter.setCompact(false);\n            }\n\n            // If this is a deletion, indicate that, otherwise write cells.\n            if (!row.deletion().isLive())\n            {\n                json.writeFieldName(\"deletion_info\");\n                objectIndenter.setCompact(true);\n                json.writeStartObject();\n                json.writeFieldName(\"deletion_time\");\n                json.writeNumber(row.deletion().time().markedForDeleteAt());\n                json.writeFieldName(\"tstamp\");\n                json.writeNumber(row.deletion().time().localDeletionTime());\n                json.writeEndObject();\n                objectIndenter.setCompact(false);\n            }\n            json.writeFieldName(\"cells\");\n            json.writeStartArray();\n            row.cells().forEach(c -> serializeCell(c, liveInfo));\n            json.writeEndArray();\n            json.writeEndObject();\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Fatal error parsing row.\", e);\n        }\n    }","id":47275,"modified_method":"private void serializeRow(Row row)\n    {\n        try\n        {\n            json.writeStartObject();\n            String rowType = row.isStatic() ? \"static_block\" : \"row\";\n            json.writeFieldName(\"type\");\n            json.writeString(rowType);\n            json.writeNumberField(\"position\", this.currentPosition);\n\n            // Only print clustering information for non-static rows.\n            if (!row.isStatic())\n            {\n                serializeClustering(row.clustering());\n            }\n\n            LivenessInfo liveInfo = row.primaryKeyLivenessInfo();\n            if (!liveInfo.isEmpty())\n            {\n                objectIndenter.setCompact(false);\n                json.writeFieldName(\"liveness_info\");\n                objectIndenter.setCompact(true);\n                json.writeStartObject();\n                json.writeFieldName(\"tstamp\");\n                json.writeString(dateString(TimeUnit.MICROSECONDS, liveInfo.timestamp()));\n                if (liveInfo.isExpiring())\n                {\n                    json.writeNumberField(\"ttl\", liveInfo.ttl());\n                    json.writeFieldName(\"expires_at\");\n                    json.writeString(dateString(TimeUnit.SECONDS, liveInfo.localExpirationTime()));\n                    json.writeFieldName(\"expired\");\n                    json.writeBoolean(liveInfo.localExpirationTime() < (System.currentTimeMillis() / 1000));\n                }\n                json.writeEndObject();\n                objectIndenter.setCompact(false);\n            }\n\n            // If this is a deletion, indicate that, otherwise write cells.\n            if (!row.deletion().isLive())\n            {\n                serializeDeletion(row.deletion().time());\n            }\n            json.writeFieldName(\"cells\");\n            json.writeStartArray();\n            for (ColumnData cd : row)\n            {\n                serializeColumnData(cd, liveInfo);\n            }\n            json.writeEndArray();\n            json.writeEndObject();\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Fatal error parsing row.\", e);\n        }\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"public static void keysToJson(ISSTableScanner currentScanner, Stream<DecoratedKey> keys, CFMetaData metadata, OutputStream out) throws IOException\n    {\n        try (JsonGenerator json = jsonFactory.createJsonGenerator(new OutputStreamWriter(out, \"UTF-8\")))\n        {\n            JsonTransformer transformer = new JsonTransformer(json, currentScanner, metadata);\n            json.writeStartArray();\n            keys.forEach(transformer::serializePartitionKey);\n            json.writeEndArray();\n        }\n    }","id":47276,"modified_method":"public static void keysToJson(ISSTableScanner currentScanner, Stream<DecoratedKey> keys, boolean rawTime, CFMetaData metadata, OutputStream out) throws IOException\n    {\n        try (JsonGenerator json = jsonFactory.createJsonGenerator(new OutputStreamWriter(out, \"UTF-8\")))\n        {\n            JsonTransformer transformer = new JsonTransformer(json, currentScanner, rawTime, metadata);\n            json.writeStartArray();\n            keys.forEach(transformer::serializePartitionKey);\n            json.writeEndArray();\n        }\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"private void serializeDeletion(DeletionTime deletion) throws IOException\n    {\n        json.writeFieldName(\"deletion_info\");\n        objectIndenter.setCompact(true);\n        json.writeStartObject();\n        json.writeFieldName(\"deletion_time\");\n        json.writeNumber(deletion.markedForDeleteAt());\n        json.writeFieldName(\"tstamp\");\n        json.writeNumber(deletion.localDeletionTime());\n        json.writeEndObject();\n        objectIndenter.setCompact(false);\n    }","id":47277,"modified_method":"private void serializeDeletion(DeletionTime deletion) throws IOException\n    {\n        json.writeFieldName(\"deletion_info\");\n        objectIndenter.setCompact(true);\n        json.writeStartObject();\n        json.writeFieldName(\"marked_deleted\");\n        json.writeString(dateString(TimeUnit.MICROSECONDS, deletion.markedForDeleteAt()));\n        json.writeFieldName(\"local_delete_time\");\n        json.writeString(dateString(TimeUnit.SECONDS, deletion.localDeletionTime()));\n        json.writeEndObject();\n        objectIndenter.setCompact(false);\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"public static void toJson(ISSTableScanner currentScanner, Stream<UnfilteredRowIterator> partitions, CFMetaData metadata, OutputStream out)\n            throws IOException\n    {\n        try (JsonGenerator json = jsonFactory.createJsonGenerator(new OutputStreamWriter(out, \"UTF-8\")))\n        {\n            JsonTransformer transformer = new JsonTransformer(json, currentScanner, metadata);\n            json.writeStartArray();\n            partitions.forEach(transformer::serializePartition);\n            json.writeEndArray();\n        }\n    }","id":47278,"modified_method":"public static void toJson(ISSTableScanner currentScanner, Stream<UnfilteredRowIterator> partitions, boolean rawTime, CFMetaData metadata, OutputStream out)\n            throws IOException\n    {\n        try (JsonGenerator json = jsonFactory.createJsonGenerator(new OutputStreamWriter(out, \"UTF-8\")))\n        {\n            JsonTransformer transformer = new JsonTransformer(json, currentScanner, rawTime, metadata);\n            json.writeStartArray();\n            partitions.forEach(transformer::serializePartition);\n            json.writeEndArray();\n        }\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"private void serializeCell(Cell cell, LivenessInfo liveInfo)\n    {\n        try\n        {\n            json.writeStartObject();\n            objectIndenter.setCompact(true);\n            json.writeFieldName(\"name\");\n            AbstractType<?> type = cell.column().type;\n            json.writeString(cell.column().name.toCQLString());\n\n            if (cell.path() != null && cell.path().size() > 0)\n            {\n                CollectionType ct = (CollectionType) type;\n                json.writeFieldName(\"path\");\n                arrayIndenter.setCompact(true);\n                json.writeStartArray();\n                for (int i = 0; i < cell.path().size(); i++)\n                {\n                    json.writeString(ct.nameComparator().getString(cell.path().get(i)));\n                }\n                json.writeEndArray();\n                arrayIndenter.setCompact(false);\n            }\n            if (cell.isTombstone())\n            {\n                json.writeFieldName(\"deletion_time\");\n                json.writeNumber(cell.localDeletionTime());\n            }\n            else\n            {\n                json.writeFieldName(\"value\");\n                json.writeString(cell.column().cellValueType().getString(cell.value()));\n            }\n            if (liveInfo.isEmpty() || cell.timestamp() != liveInfo.timestamp())\n            {\n                json.writeFieldName(\"tstamp\");\n                json.writeNumber(cell.timestamp());\n            }\n            if (cell.isExpiring() && (liveInfo.isEmpty() || cell.ttl() != liveInfo.ttl()))\n            {\n                json.writeFieldName(\"ttl\");\n                json.writeNumber(cell.ttl());\n                json.writeFieldName(\"expires_at\");\n                json.writeNumber(cell.localDeletionTime());\n                json.writeFieldName(\"expired\");\n                json.writeBoolean(!cell.isLive((int) (System.currentTimeMillis() / 1000)));\n            }\n            json.writeEndObject();\n            objectIndenter.setCompact(false);\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Failure parsing cell.\", e);\n        }\n    }","id":47279,"modified_method":"private void serializeCell(Cell cell, LivenessInfo liveInfo)\n    {\n        try\n        {\n            json.writeStartObject();\n            objectIndenter.setCompact(true);\n            json.writeFieldName(\"name\");\n            AbstractType<?> type = cell.column().type;\n            json.writeString(cell.column().name.toCQLString());\n\n            if (cell.path() != null && cell.path().size() > 0)\n            {\n                CollectionType ct = (CollectionType) type;\n                json.writeFieldName(\"path\");\n                arrayIndenter.setCompact(true);\n                json.writeStartArray();\n                for (int i = 0; i < cell.path().size(); i++)\n                {\n                    json.writeString(ct.nameComparator().getString(cell.path().get(i)));\n                }\n                json.writeEndArray();\n                arrayIndenter.setCompact(false);\n            }\n            if (cell.isTombstone())\n            {\n                json.writeFieldName(\"deletion_info\");\n                objectIndenter.setCompact(true);\n                json.writeStartObject();\n                json.writeFieldName(\"local_delete_time\");\n                json.writeString(dateString(TimeUnit.SECONDS, cell.localDeletionTime()));\n                json.writeEndObject();\n                objectIndenter.setCompact(false);\n            }\n            else\n            {\n                json.writeFieldName(\"value\");\n                json.writeString(cell.column().cellValueType().getString(cell.value()));\n            }\n            if (liveInfo.isEmpty() || cell.timestamp() != liveInfo.timestamp())\n            {\n                json.writeFieldName(\"tstamp\");\n                json.writeString(dateString(TimeUnit.MICROSECONDS, cell.timestamp()));\n            }\n            if (cell.isExpiring() && (liveInfo.isEmpty() || cell.ttl() != liveInfo.ttl()))\n            {\n                json.writeFieldName(\"ttl\");\n                json.writeNumber(cell.ttl());\n                json.writeFieldName(\"expires_at\");\n                json.writeString(dateString(TimeUnit.SECONDS, cell.localDeletionTime()));\n                json.writeFieldName(\"expired\");\n                json.writeBoolean(!cell.isLive((int) (System.currentTimeMillis() / 1000)));\n            }\n            json.writeEndObject();\n            objectIndenter.setCompact(false);\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Failure parsing cell.\", e);\n        }\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"private void serializePartition(UnfilteredRowIterator partition)\n    {\n        String key = metadata.getKeyValidator().getString(partition.partitionKey().getKey());\n        try\n        {\n            json.writeStartObject();\n\n            json.writeFieldName(\"partition\");\n            json.writeStartObject();\n            json.writeFieldName(\"key\");\n            serializePartitionKey(partition.partitionKey());\n            json.writeNumberField(\"position\", this.currentScanner.getCurrentPosition());\n\n            if (!partition.partitionLevelDeletion().isLive())\n            {\n                json.writeFieldName(\"deletion_info\");\n                objectIndenter.setCompact(true);\n                json.writeStartObject();\n                json.writeFieldName(\"deletion_time\");\n                json.writeNumber(partition.partitionLevelDeletion().markedForDeleteAt());\n                json.writeFieldName(\"tstamp\");\n                json.writeNumber(partition.partitionLevelDeletion().localDeletionTime());\n                json.writeEndObject();\n                objectIndenter.setCompact(false);\n                json.writeEndObject();\n            }\n            else\n            {\n                json.writeEndObject();\n                json.writeFieldName(\"rows\");\n                json.writeStartArray();\n                updatePosition();\n                if (!partition.staticRow().isEmpty())\n                {\n                    serializeRow(partition.staticRow());\n                }\n                Unfiltered unfiltered;\n                updatePosition();\n                while (partition.hasNext())\n                {\n                    unfiltered = partition.next();\n                    if (unfiltered instanceof Row)\n                    {\n                        serializeRow((Row) unfiltered);\n                    }\n                    else if (unfiltered instanceof RangeTombstoneMarker)\n                    {\n                        serializeTombstone((RangeTombstoneMarker) unfiltered);\n                    }\n                    updatePosition();\n                }\n                json.writeEndArray();\n            }\n\n            json.writeEndObject();\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Fatal error parsing partition: {}\", key, e);\n        }\n    }","id":47280,"modified_method":"private void serializePartition(UnfilteredRowIterator partition)\n    {\n        String key = metadata.getKeyValidator().getString(partition.partitionKey().getKey());\n        try\n        {\n            json.writeStartObject();\n\n            json.writeFieldName(\"partition\");\n            json.writeStartObject();\n            json.writeFieldName(\"key\");\n            serializePartitionKey(partition.partitionKey());\n            json.writeNumberField(\"position\", this.currentScanner.getCurrentPosition());\n\n            if (!partition.partitionLevelDeletion().isLive())\n            {\n                serializeDeletion(partition.partitionLevelDeletion());\n            }\n            else\n            {\n                json.writeEndObject();\n                json.writeFieldName(\"rows\");\n                json.writeStartArray();\n                updatePosition();\n                if (!partition.staticRow().isEmpty())\n                {\n                    serializeRow(partition.staticRow());\n                }\n                Unfiltered unfiltered;\n                updatePosition();\n                while (partition.hasNext())\n                {\n                    unfiltered = partition.next();\n                    if (unfiltered instanceof Row)\n                    {\n                        serializeRow((Row) unfiltered);\n                    }\n                    else if (unfiltered instanceof RangeTombstoneMarker)\n                    {\n                        serializeTombstone((RangeTombstoneMarker) unfiltered);\n                    }\n                    updatePosition();\n                }\n                json.writeEndArray();\n            }\n\n            json.writeEndObject();\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Fatal error parsing partition: {}\", key, e);\n        }\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"private JsonTransformer(JsonGenerator json, ISSTableScanner currentScanner, CFMetaData metadata)\n    {\n        this.json = json;\n        this.metadata = metadata;\n        this.currentScanner = currentScanner;\n\n        DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter();\n        prettyPrinter.indentObjectsWith(objectIndenter);\n        prettyPrinter.indentArraysWith(arrayIndenter);\n        json.setPrettyPrinter(prettyPrinter);\n    }","id":47281,"modified_method":"private JsonTransformer(JsonGenerator json, ISSTableScanner currentScanner, boolean rawTime, CFMetaData metadata)\n    {\n        this.json = json;\n        this.metadata = metadata;\n        this.currentScanner = currentScanner;\n        this.rawTime = rawTime;\n\n        DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter();\n        prettyPrinter.indentObjectsWith(objectIndenter);\n        prettyPrinter.indentArraysWith(arrayIndenter);\n        json.setPrettyPrinter(prettyPrinter);\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Given arguments specifying an SSTable, and optionally an output file, export the contents of the SSTable to JSON.\n     *\n     * @param args\n     *            command lines arguments\n     * @throws ConfigurationException\n     *             on configuration failure (wrong params given)\n     */\n    public static void main(String[] args) throws ConfigurationException\n    {\n        CommandLineParser parser = new PosixParser();\n        try\n        {\n            cmd = parser.parse(options, args);\n        }\n        catch (ParseException e1)\n        {\n            System.err.println(e1.getMessage());\n            printUsage();\n            System.exit(1);\n        }\n\n        if (cmd.getArgs().length != 1)\n        {\n            System.err.println(\"You must supply exactly one sstable\");\n            printUsage();\n            System.exit(1);\n        }\n\n        String[] keys = cmd.getOptionValues(KEY_OPTION);\n        HashSet<String> excludes = new HashSet<>(Arrays.asList(\n                cmd.getOptionValues(EXCLUDE_KEY_OPTION) == null\n                        ? new String[0]\n                        : cmd.getOptionValues(EXCLUDE_KEY_OPTION)));\n        String ssTableFileName = new File(cmd.getArgs()[0]).getAbsolutePath();\n\n        if (Descriptor.isLegacyFile(new File(ssTableFileName)))\n        {\n            System.err.println(\"Unsupported legacy sstable\");\n            System.exit(1);\n        }\n        if (!new File(ssTableFileName).exists())\n        {\n            System.err.println(\"Cannot find file \" + ssTableFileName);\n            System.exit(1);\n        }\n        Descriptor desc = Descriptor.fromFilename(ssTableFileName);\n        try\n        {\n            CFMetaData metadata = metadataFromSSTable(desc);\n            if (cmd.hasOption(ENUMERATE_KEYS_OPTION))\n            {\n                JsonTransformer.keysToJson(null, iterToStream(new KeyIterator(desc, metadata)), metadata, System.out);\n            }\n            else\n            {\n                SSTableReader sstable = SSTableReader.openNoValidation(desc, metadata);\n                IPartitioner partitioner = sstable.getPartitioner();\n                final ISSTableScanner currentScanner;\n                if ((keys != null) && (keys.length > 0))\n                {\n                    List<AbstractBounds<PartitionPosition>> bounds = Arrays.stream(keys)\n                            .filter(key -> !excludes.contains(key))\n                            .map(metadata.getKeyValidator()::fromString)\n                            .map(partitioner::decorateKey)\n                            .sorted()\n                            .map(DecoratedKey::getToken)\n                            .map(token -> new Bounds<>(token.minKeyBound(), token.maxKeyBound())).collect(Collectors.toList());\n                    currentScanner = sstable.getScanner(bounds.iterator());\n                }\n                else\n                {\n                    currentScanner = sstable.getScanner();\n                }\n                Stream<UnfilteredRowIterator> partitions = iterToStream(currentScanner).filter(i ->\n                    excludes.isEmpty() || !excludes.contains(metadata.getKeyValidator().getString(i.partitionKey().getKey()))\n                );\n                if (cmd.hasOption(DEBUG_OUTPUT_OPTION))\n                {\n                    AtomicLong position = new AtomicLong();\n                    partitions.forEach(partition ->\n                    {\n                        position.set(currentScanner.getCurrentPosition());\n\n                        if (!partition.partitionLevelDeletion().isLive())\n                        {\n                            System.out.println(\"[\" + metadata.getKeyValidator().getString(partition.partitionKey().getKey()) + \"]@\" +\n                                               position.get() + \" \" + partition.partitionLevelDeletion());\n                        }\n                        if (!partition.staticRow().isEmpty())\n                        {\n                            System.out.println(\"[\" + metadata.getKeyValidator().getString(partition.partitionKey().getKey()) + \"]@\" +\n                                               position.get() + \" \" + partition.staticRow().toString(metadata, true));\n                        }\n                        partition.forEachRemaining(row ->\n                        {\n                            System.out.println(\n                                    \"[\" + metadata.getKeyValidator().getString(partition.partitionKey().getKey()) + \"]@\"\n                                            + position.get() + \" \" + row.toString(metadata, false, true));\n                            position.set(currentScanner.getCurrentPosition());\n                        });\n                    });\n                }\n                else\n                {\n                    JsonTransformer.toJson(currentScanner, partitions, metadata, System.out);\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // throwing exception outside main with broken pipe causes windows cmd to hang\n            e.printStackTrace(System.err);\n        }\n\n        System.exit(0);\n    }","id":47282,"modified_method":"/**\n     * Given arguments specifying an SSTable, and optionally an output file, export the contents of the SSTable to JSON.\n     *\n     * @param args\n     *            command lines arguments\n     * @throws ConfigurationException\n     *             on configuration failure (wrong params given)\n     */\n    public static void main(String[] args) throws ConfigurationException\n    {\n        CommandLineParser parser = new PosixParser();\n        try\n        {\n            cmd = parser.parse(options, args);\n        }\n        catch (ParseException e1)\n        {\n            System.err.println(e1.getMessage());\n            printUsage();\n            System.exit(1);\n        }\n\n        if (cmd.getArgs().length != 1)\n        {\n            System.err.println(\"You must supply exactly one sstable\");\n            printUsage();\n            System.exit(1);\n        }\n\n        String[] keys = cmd.getOptionValues(KEY_OPTION);\n        HashSet<String> excludes = new HashSet<>(Arrays.asList(\n                cmd.getOptionValues(EXCLUDE_KEY_OPTION) == null\n                        ? new String[0]\n                        : cmd.getOptionValues(EXCLUDE_KEY_OPTION)));\n        String ssTableFileName = new File(cmd.getArgs()[0]).getAbsolutePath();\n\n        if (Descriptor.isLegacyFile(new File(ssTableFileName)))\n        {\n            System.err.println(\"Unsupported legacy sstable\");\n            System.exit(1);\n        }\n        if (!new File(ssTableFileName).exists())\n        {\n            System.err.println(\"Cannot find file \" + ssTableFileName);\n            System.exit(1);\n        }\n        Descriptor desc = Descriptor.fromFilename(ssTableFileName);\n        try\n        {\n            CFMetaData metadata = metadataFromSSTable(desc);\n            if (cmd.hasOption(ENUMERATE_KEYS_OPTION))\n            {\n                JsonTransformer.keysToJson(null, iterToStream(new KeyIterator(desc, metadata)),\n                                                              cmd.hasOption(RAW_TIMESTAMPS),\n                                                              metadata,\n                                                              System.out);\n            }\n            else\n            {\n                SSTableReader sstable = SSTableReader.openNoValidation(desc, metadata);\n                IPartitioner partitioner = sstable.getPartitioner();\n                final ISSTableScanner currentScanner;\n                if ((keys != null) && (keys.length > 0))\n                {\n                    List<AbstractBounds<PartitionPosition>> bounds = Arrays.stream(keys)\n                            .filter(key -> !excludes.contains(key))\n                            .map(metadata.getKeyValidator()::fromString)\n                            .map(partitioner::decorateKey)\n                            .sorted()\n                            .map(DecoratedKey::getToken)\n                            .map(token -> new Bounds<>(token.minKeyBound(), token.maxKeyBound())).collect(Collectors.toList());\n                    currentScanner = sstable.getScanner(bounds.iterator());\n                }\n                else\n                {\n                    currentScanner = sstable.getScanner();\n                }\n                Stream<UnfilteredRowIterator> partitions = iterToStream(currentScanner).filter(i ->\n                    excludes.isEmpty() || !excludes.contains(metadata.getKeyValidator().getString(i.partitionKey().getKey()))\n                );\n                if (cmd.hasOption(DEBUG_OUTPUT_OPTION))\n                {\n                    AtomicLong position = new AtomicLong();\n                    partitions.forEach(partition ->\n                    {\n                        position.set(currentScanner.getCurrentPosition());\n\n                        if (!partition.partitionLevelDeletion().isLive())\n                        {\n                            System.out.println(\"[\" + metadata.getKeyValidator().getString(partition.partitionKey().getKey()) + \"]@\" +\n                                               position.get() + \" \" + partition.partitionLevelDeletion());\n                        }\n                        if (!partition.staticRow().isEmpty())\n                        {\n                            System.out.println(\"[\" + metadata.getKeyValidator().getString(partition.partitionKey().getKey()) + \"]@\" +\n                                               position.get() + \" \" + partition.staticRow().toString(metadata, true));\n                        }\n                        partition.forEachRemaining(row ->\n                        {\n                            System.out.println(\n                                    \"[\" + metadata.getKeyValidator().getString(partition.partitionKey().getKey()) + \"]@\"\n                                            + position.get() + \" \" + row.toString(metadata, false, true));\n                            position.set(currentScanner.getCurrentPosition());\n                        });\n                    });\n                }\n                else\n                {\n                    JsonTransformer.toJson(currentScanner, partitions, cmd.hasOption(RAW_TIMESTAMPS), metadata, System.out);\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            // throwing exception outside main with broken pipe causes windows cmd to hang\n            e.printStackTrace(System.err);\n        }\n\n        System.exit(0);\n    }","commit_id":"620efdc8c4968e45994496b23cd7dcdfbccdad6d","url":"https://github.com/apache/cassandra"},{"original_method":"public Cell reconcile(Cell cell)\n    {\n        // tombstones take precedence.  (if both are tombstones, then it doesn't matter which one we use.)\n        if (!isLive())\n            return timestamp() < cell.timestamp() ? cell : this;\n        if (!cell.isLive())\n            return timestamp() > cell.timestamp() ? this : cell;\n        // break ties by comparing values.\n        if (timestamp() == cell.timestamp())\n            return value().compareTo(cell.value()) < 0 ? cell : this;\n        // neither is tombstoned and timestamps are different\n        return timestamp() < cell.timestamp() ? cell : this;\n    }","id":47283,"modified_method":"public Cell reconcile(Cell cell)\n    {\n        long ts1 = timestamp(), ts2 = cell.timestamp();\n        if (ts1 != ts2)\n            return ts1 < ts2 ? cell : this;\n        if (isLive() != cell.isLive())\n            return isLive() ? cell : this;\n        return value().compareTo(cell.value()) < 0 ? cell : this;\n    }","commit_id":"0bc4663aad3257f359058465dccbb36141fc75c6","url":"https://github.com/apache/cassandra"},{"original_method":"public List<superColumn_t> get_slice_super_by_names(String tablename, String key, String columnFamily, List<String> superColumnNames) throws CassandraException, TException\n    {\n\t\tArrayList<superColumn_t> retlist = new ArrayList<superColumn_t>();\n        long startTime = System.currentTimeMillis();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t\t\tColumnFamily cfamily = get_cf(tablename, key, columnFamily, superColumnNames);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily + \" is missing.....: \"+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the column family requested\" + columnFamily + \"is not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + columnFamily);\n\t\t\t}\n\t\t\t\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tsuperColumn_t thrift_superColumn = new superColumn_t();\n\t\t\t\tthrift_superColumn.name = column.name();\n\t\t\t\tCollection<IColumn> subColumns = column.getSubColumns();\n\t\t\t\tif(subColumns.size() != 0 )\n\t\t\t\t{\n\t\t\t\t\tthrift_superColumn.columns = new ArrayList<column_t>();\n\t\t\t\t\tfor( IColumn subColumn : subColumns )\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn_t thrift_column = new column_t();\n\t\t\t\t\t\tthrift_column.columnName = subColumn.name();\n\t\t\t\t\t\tthrift_column.value = new String(subColumn.value());\n\t\t\t\t\t\tthrift_column.timestamp = subColumn.timestamp();\n\t\t\t\t\t\tthrift_superColumn.columns.add(thrift_column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tretlist.add(thrift_superColumn);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n        logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime)\n                + \" ms.\");\n\t\treturn retlist;\n    }","id":47284,"modified_method":"public List<superColumn_t> get_slice_super_by_names(String tablename, String key, String columnFamily, List<String> superColumnNames) throws CassandraException, TException\n    {\n        long startTime = System.currentTimeMillis();\n\t\t\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t\t\tColumnFamily cfamily = get_cf(tablename, key, columnFamily, superColumnNames);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily + \" is missing.....: \"+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the column family requested\" + columnFamily + \"is not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + columnFamily);\n\t\t\t}\n\n            return thriftifySuperColumns(columns);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n        finally\n        {\n            logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n        }\n    }","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"public  ArrayList<column_t> get_columns_since(String tablename, String key, String columnFamily_column, long timeStamp) throws CassandraException,TException\n\t{\n\t\tArrayList<column_t> retlist = new ArrayList<column_t>();\n        long startTime = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 1 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, timeStamp, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily \" + columnFamily_column + \" map is missing.....: \" + \"   key:\" + key);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily_column + \" is missing.....: \"+\"   key:\" + key\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tif( values.length > 1 )\n\t\t\t{\n\t\t\t\t// this is the super column case \n\t\t\t\tIColumn column = cfamily.getColumn(values[1]);\n\t\t\t\tif(column != null)\n\t\t\t\t\tcolumns = column.getSubColumns();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\t}\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tcolumn_t thrift_column = new column_t();\n\t\t\t\tthrift_column.columnName = column.name();\n\t\t\t\tthrift_column.value = new String(column.value()); // This needs to be Utf8ed\n\t\t\t\tthrift_column.timestamp = column.timestamp();\n\t\t\t\tretlist.add(thrift_column);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n        logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn retlist;\n\t}","id":47285,"modified_method":"public List<column_t> get_columns_since(String tablename, String key, String columnFamily_column, long timeStamp) throws CassandraException,TException\n\t{\n        long startTime = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 1 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, timeStamp, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily \" + columnFamily_column + \" map is missing.....: \" + \"   key:\" + key);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily_column + \" is missing.....: \"+\"   key:\" + key\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tif( values.length > 1 )\n\t\t\t{\n\t\t\t\t// this is the super column case \n\t\t\t\tIColumn column = cfamily.getColumn(values[1]);\n\t\t\t\tif(column != null)\n\t\t\t\t\tcolumns = column.getSubColumns();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\t}\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\n            return thriftifyColumns(columns);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n        finally\n        {\n            logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n        }\n\t}","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"public ArrayList<column_t> get_slice(String tablename, String key, String columnFamily_column, int start, int count) throws CassandraException,TException\n\t{\n\t\tArrayList<column_t> retlist = new ArrayList<column_t>();\n        long startTime = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 1 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, start, count, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily \" + columnFamily_column + \" map is missing.....: \" + \"   key:\" + key);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily_column + \" is missing.....: \"\t+ \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tif( values.length > 1 )\n\t\t\t{\n\t\t\t\t// this is the super column case \n\t\t\t\tIColumn column = cfamily.getColumn(values[1]);\n\t\t\t\tif(column != null)\n\t\t\t\t\tcolumns = column.getSubColumns();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\t}\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tcolumn_t thrift_column = new column_t();\n\t\t\t\tthrift_column.columnName = column.name();\n\t\t\t\tthrift_column.value = new String(column.value()); // This needs to be Utf8ed\n\t\t\t\tthrift_column.timestamp = column.timestamp();\n\t\t\t\tretlist.add(thrift_column);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n        logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime)\n                + \" ms.\");\n\t\treturn retlist;\n\t}","id":47286,"modified_method":"public List<column_t> get_slice(String tablename, String key, String columnFamily_column, int start, int count) throws CassandraException,TException\n\t{\n        long startTime = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 1 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, start, count, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily \" + columnFamily_column + \" map is missing.....: \" + \"   key:\" + key);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily_column + \" is missing.....: \"\t+ \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tif( values.length > 1 )\n\t\t\t{\n\t\t\t\t// this is the super column case \n\t\t\t\tIColumn column = cfamily.getColumn(values[1]);\n\t\t\t\tif(column != null)\n\t\t\t\t\tcolumns = column.getSubColumns();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\t}\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\n            return thriftifyColumns(columns);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n        finally\n        {\n            logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n        }\n\t}","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"public superColumn_t get_superColumn(String tablename, String key, String columnFamily_column) throws CassandraException\n    {\n    \tsuperColumn_t ret = null;\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 2 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, -1, Integer.MAX_VALUE, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily map is missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily  is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tret = new superColumn_t();\n\t\t\t\tret.name = column.name();\n\t\t\t\tCollection<IColumn> subColumns = column.getSubColumns();\n\t\t\t\tif(subColumns.size() != 0 )\n\t\t\t\t{\n\t\t\t\t\tret.columns = new ArrayList<column_t>();\n\t\t\t\t\tfor(IColumn subColumn : subColumns)\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn_t thrift_column = new column_t();\n\t\t\t\t\t\tthrift_column.columnName = subColumn.name();\n\t\t\t\t\t\tthrift_column.value = new String(subColumn.value());\n\t\t\t\t\t\tthrift_column.timestamp = subColumn.timestamp();\n\t\t\t\t\t\tret.columns.add(thrift_column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n\t\treturn ret;\n    \t\n    }","id":47287,"modified_method":"public superColumn_t get_superColumn(String tablename, String key, String columnFamily_column) throws CassandraException\n    {\n    \tsuperColumn_t ret = null;\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 2 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, -1, Integer.MAX_VALUE, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily map is missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily  is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\n            assert columns.size() == 1;\n            IColumn column = columns.iterator().next();\n            if (column.getSubColumns().size() == 0)\n            {\n                logger_\t.info(\"ERROR Columns are missing.....: \"\n                               + \"   key:\" + key\n                                + \"  ColumnFamily:\" + values[0]);\n                throw new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n            }\n\n            return new superColumn_t(column.name(), thriftifyColumns(column.getSubColumns()));\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n    }","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"public ArrayList<superColumn_t> get_slice_super(String tablename, String key, String columnFamily_superColumnName, int start, int count) throws CassandraException\n    {\n\t\tArrayList<superColumn_t> retlist = new ArrayList<superColumn_t>();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_superColumnName);\n\t        // check for  values \n\t        if( values.length < 1 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_superColumnName + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_superColumnName, start, count, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily map is missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily  is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_superColumnName + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tsuperColumn_t thrift_superColumn = new superColumn_t();\n\t\t\t\tthrift_superColumn.name = column.name();\n\t\t\t\tCollection<IColumn> subColumns = column.getSubColumns();\n\t\t\t\tif(subColumns.size() != 0 )\n\t\t\t\t{\n\t\t\t\t\tthrift_superColumn.columns = new ArrayList<column_t>();\n\t\t\t\t\tfor( IColumn subColumn : subColumns )\n\t\t\t\t\t{\n\t\t\t\t\t\tcolumn_t thrift_column = new column_t();\n\t\t\t\t\t\tthrift_column.columnName = subColumn.name();\n\t\t\t\t\t\tthrift_column.value = new String(subColumn.value());\n\t\t\t\t\t\tthrift_column.timestamp = subColumn.timestamp();\n\t\t\t\t\t\tthrift_superColumn.columns.add(thrift_column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tretlist.add(thrift_superColumn);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n\t\treturn retlist;\n    \t\n    }","id":47288,"modified_method":"public List<superColumn_t> get_slice_super(String tablename, String key, String columnFamily_superColumnName, int start, int count) throws CassandraException\n    {\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_superColumnName);\n\t        // check for  values \n\t        if( values.length < 1 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_superColumnName + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_superColumnName, start, count, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily map is missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily  is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_superColumnName + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\n            return thriftifySuperColumns(columns);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n    }","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"public List<column_t> get_slice_by_names(String tablename, String key, String columnFamily, List<String> columnNames) throws CassandraException, TException\n    {\n\t\tArrayList<column_t> retlist = new ArrayList<column_t>();\n        long startTime = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t\t\tColumnFamily cfamily = get_cf(tablename, key, columnFamily, columnNames);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily + \" is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columnFamily requested\" + columnFamily + \"is not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + columnFamily);\n\t\t\t}\n\t\t\t\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tcolumn_t thrift_column = new column_t();\n\t\t\t\tthrift_column.columnName = column.name();\n\t\t\t\tthrift_column.value = new String(column.value()); // This needs to be Utf8ed\n\t\t\t\tthrift_column.timestamp = column.timestamp();\n\t\t\t\tretlist.add(thrift_column);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n\t\t\n        logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime)\n                + \" ms.\");\n\t\treturn retlist;\n    }","id":47289,"modified_method":"public List<column_t> get_slice_by_names(String tablename, String key, String columnFamily, List<String> columnNames) throws CassandraException, TException\n    {\n        long startTime = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t\t\tColumnFamily cfamily = get_cf(tablename, key, columnFamily, columnNames);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily \" + columnFamily + \" is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columnFamily requested\" + columnFamily + \"is not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + columnFamily);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + columnFamily);\n\t\t\t}\n\n            return thriftifyColumns(columns);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n\t\tfinally\n        {\n            logger_.debug(\"get_slice2: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n        }\n    }","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"public column_t get_column(String tablename, String key, String columnFamily_column) throws CassandraException,TException\n    {\n\t\tcolumn_t ret = null;\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 2 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, -1, Integer.MAX_VALUE, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\t\t\t\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily map is missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily  is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tif( values.length > 2 )\n\t\t\t{\n\t\t\t\t// this is the super column case \n\t\t\t\tIColumn column = cfamily.getColumn(values[1]);\n\t\t\t\tif(column != null)\n\t\t\t\t\tcolumns = column.getSubColumns();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\t}\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\t\t\tret = new column_t();\n\t\t\tfor(IColumn column : columns)\n\t\t\t{\n\t\t\t\tret.columnName = column.name();\n\t\t\t\tret.value = new String(column.value());\n\t\t\t\tret.timestamp = column.timestamp();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n\t\treturn ret;\n    }","id":47290,"modified_method":"public column_t get_column(String tablename, String key, String columnFamily_column) throws CassandraException,TException\n    {\n\t\ttry\n\t\t{\n\t\t\tvalidateTable(tablename);\n\t        String[] values = RowMutation.getColumnAndColumnFamily(columnFamily_column);\n\t        // check for  values \n\t        if( values.length < 2 )\n\t        {\n\t        \tthrow new CassandraException(\"Column Family \" + columnFamily_column + \" is invalid.\");\t        \t\n\t        }\n\t        Row row = StorageProxy.readProtocol(tablename, key, columnFamily_column, -1, Integer.MAX_VALUE, StorageService.ConsistencyLevel.WEAK);\n\t\t\tif (row == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR No row for this key .....: \" + key);\n\t        \tthrow new CassandraException(\"ERROR No row for this key .....: \" + key);\t        \t\n\t\t\t}\n\t\t\t\n\t\t\tMap<String, ColumnFamily> cfMap = row.getColumnFamilyMap();\n\t\t\tif (cfMap == null || cfMap.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR ColumnFamily map is missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested are not present.\");\n\t\t\t}\n\t\t\tColumnFamily cfamily = cfMap.get(values[0]);\n\t\t\tif (cfamily == null)\n\t\t\t{\n\t\t\t\tlogger_.info(\"ERROR ColumnFamily  is missing.....: \"\n\t\t\t\t\t\t\t+\"   key:\" + key\n\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"Either the key \" + key + \" is not present or the columns requested\" + columnFamily_column + \"are not present.\");\n\t\t\t}\n\t\t\tCollection<IColumn> columns = null;\n\t\t\tif( values.length > 2 )\n\t\t\t{\n\t\t\t\t// this is the super column case \n\t\t\t\tIColumn column = cfamily.getColumn(values[1]);\n\t\t\t\tif(column != null)\n\t\t\t\t\tcolumns = column.getSubColumns();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolumns = cfamily.getAllColumns();\n\t\t\t}\n\t\t\tif (columns == null || columns.size() == 0)\n\t\t\t{\n\t\t\t\tlogger_\t.info(\"ERROR Columns are missing.....: \"\n\t\t\t\t\t\t\t   + \"   key:\" + key\n\t\t\t\t\t\t\t\t+ \"  ColumnFamily:\" + values[0]);\n\t\t\t\tthrow new CassandraException(\"ERROR Columns are missing.....: \" + \"   key:\" + key + \"  ColumnFamily:\" + values[0]);\n\t\t\t}\n\n            assert columns.size() == 1;\n            IColumn column = columns.iterator().next();\n            if (column.isMarkedForDelete())\n            {\n                return null;\n            }\n            return new column_t(column.name(), new String(column.value()), column.timestamp());\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tString exception = LogUtil.throwableToString(ex);\n\t\t\tlogger_.info( exception );\n\t\t\tthrow new CassandraException(exception);\n\t\t}\n    }","commit_id":"560dc2a10f4ee8c621d3568051e6005f79e21ee4","url":"https://github.com/apache/cassandra"},{"original_method":"@BeforeClass\r\n    public static void setUp() throws Exception {\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n            pool = startDB();\r\n            broker = pool.get(SecurityManager.SYSTEM_USER);\r\n            transact = pool.getTransactionManager();\r\n            transaction = transact.beginTransaction();\r\n\r\n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\r\n            broker.saveCollection(transaction, root);\r\n\r\n            CollectionConfigurationManager mgr = pool.getConfigurationManager();\r\n            mgr.addConfiguration(transaction, broker, root, COLLECTION_CONFIG1);\r\n\r\n            File files[] = dir.listFiles(new XMLFilenameFilter());\r\n\r\n            File f;\r\n            IndexInfo info;\r\n\r\n            // store some documents.\r\n            for (int i = 0; i < files.length; i++) {\r\n                f = files[i];\r\n                info = root.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\r\n                root.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\r\n            }\r\n\r\n            info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"nested.xml\"), NESTED_XML);\r\n            root.store(transaction, broker, info, NESTED_XML, false);\r\n\r\n            transact.commit(transaction);\r\n            pool.release(broker);\r\n            \r\n\r\n            //for the tests\r\n            broker = pool.get(SecurityManager.SYSTEM_USER);\r\n            DocumentSet docs = root.allDocs(broker, new DefaultDocumentSet(), true, false);\r\n            seqSpeech = executeQuery(broker, \"//SPEECH\", 2628, null);\r\n            \r\n        } catch(Exception e) {\r\n            if (pool != null) {\r\n                pool.release(broker);\r\n                BrokerPool.stopAll(false);\r\n                pool = null;\r\n                root = null;\r\n            }\r\n            throw e;\r\n        }\r\n    }","id":47291,"modified_method":"@BeforeClass\n    public static void setUp() throws Exception {\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            pool = startDB();\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            transact = pool.getTransactionManager();\n            transaction = transact.beginTransaction();\n\n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\n            broker.saveCollection(transaction, root);\n\n            String existHome = System.getProperty(\"exist.home\");\n            File existDir = existHome==null ? new File(\".\") : new File(existHome);\n            String directory = \"samples/shakespeare\";\n            File dir = new File(existDir, directory);\n\n            // store some documents.\n            for(File f : dir.listFiles(new XMLFilenameFilter())) {\n                IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                root.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n            }\n\n            IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"nested.xml\"), NESTED_XML);\n            root.store(transaction, broker, info, NESTED_XML, false);\n            transact.commit(transaction);\n            \n            \n            //for the tests\n            docs = root.allDocs(broker, new DefaultDocumentSet(), true, false);\n            seqSpeech = executeQuery(broker, \"//SPEECH\", 2628, null);\n            \n        } catch(Exception e) {\n            if (pool != null) {\n                pool.release(broker);\n                BrokerPool.stopAll(false);\n                pool = null;\n                root = null;\n            }\n            throw e;\n        }\n    }","commit_id":"bf6bfc5a32dcf1405a271d7748b263a74f72be08","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\r\n    public void virtualNodeSet() throws SAXException {\r\n\r\n        Serializer serializer = broker.getSerializer();\r\n        serializer.reset();\r\n        \r\n        try {\r\n            executeQuery(broker, \"//*/LINE\", 9492, null);\r\n            executeQuery(broker, \"//*/LINE/*\", 61, null);\r\n            executeQuery(broker, \"//*/LINE/text()\", 9485, null);\r\n            executeQuery(broker, \"//SCENE/*/LINE\", 9464, null);\r\n            executeQuery(broker, \"//SCENE/*[LINE &= 'spirit']\", 21, null);\r\n            executeQuery(broker, \"//SCENE/*[LINE &= 'the']\", 1005, null);\r\n            executeQuery(broker, \"//SCENE/*/LINE[. &= 'the']\", 2167, null);\r\n            executeQuery(broker, \"//SPEECH[LINE &= 'spirit']/ancestor::*\", 30, null);\r\n            executeQuery(broker, \"for $s in //SCENE/*[LINE &= 'the'] return node-name($s)\", 1005, null);\r\n\r\n            executeQuery(broker, \"//SPEECH[LINE &= 'perturbed spirit']/preceding-sibling::*\", 65, null);\r\n            executeQuery(broker, \"//SPEECH[LINE &= 'perturbed spirit']/following-sibling::*\", 1, null);\r\n            \r\n        } catch (XPathException ex) {\r\n            Assert.fail(ex.getMessage());\r\n        }\r\n    }","id":47292,"modified_method":"@Test\n    public void virtualNodeSet_4() throws XPathException, SAXException {\n        executeQuery(broker, \"//SCENE/*/LINE\", 9464, null);\n    }","commit_id":"bf6bfc5a32dcf1405a271d7748b263a74f72be08","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testOptimizations() {\r\n        DBBroker broker = null;\r\n        try {\r\n            assertNotNull(pool);\r\n            broker = pool.get(pool.getSecurityManager().getSystemSubject());\r\n            assertNotNull(broker);\r\n            \r\n            Serializer serializer = broker.getSerializer();\r\n            serializer.reset();\r\n            DocumentSet docs = root.allDocs(broker, new DefaultDocumentSet(), true, false);\r\n\r\n            System.out.println(\"------------ Testing NativeElementIndex.findChildNodesByTagName ---------\");\r\n            // parent set: 1.1.1; child set: 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.2.1, 1.2.1\r\n            ExtNodeSet nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1.1']\", 1, null);\r\n            NodeSet children = \r\n            \tbroker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, \r\n            \t\t\tnew QName(\"para\", \"\"), Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n            assertEquals(3, children.getLength());\r\n            \r\n            // parent set: 1.1; child set: 1.1.1, 1.1.2\r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1']\", 1, null);\r\n            children = \r\n            \tbroker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, \r\n            \t\t\tnew QName(\"section\", \"\"), Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n            assertEquals(2, children.getLength());\r\n            \r\n            // parent set: 1, 1.1, 1.1.1, 1.1.2 ; child set: 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.2.1, 1.2.1\r\n            // problem: ancestor set contains nested nodes\r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = ('1.1', '1.1.1', '1.1.2')]\", 3, null);\r\n            children = \r\n            \tbroker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, \r\n        \t\t\tnew QName(\"para\", \"\"), Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n            assertEquals(4, children.getLength());\r\n            \r\n            // parent set: 1.1, 1.1.2, 1.2 ; child set: 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.2.1, 1.2.1\r\n            // problem: ancestor set contains nested nodes\r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = ('1.1', '1.1.2', '1.2')]\", 3, null);\r\n            children = \r\n                broker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"para\", \"\"), \r\n                \t\tConstants.CHILD_AXIS, docs, nestedSet, -1);\r\n            assertEquals(2, children.getLength());\r\n            \r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1']\", 1, null);\r\n            children = \r\n                broker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"para\", \"\"), \r\n                \t\tConstants.DESCENDANT_AXIS, docs, nestedSet, -1);\r\n            assertEquals(4, children.getLength());\r\n            \r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1']\", 1, null);\r\n            children = \r\n                broker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"para\", \"\"), \r\n                \t\tConstants.DESCENDANT_AXIS, docs, nestedSet, -1);\r\n            assertEquals(5, children.getLength());\r\n            \r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1.2']\", 1, null);\r\n            children = \r\n                broker.getStructuralIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"section\", \"\"), \r\n                \t\tConstants.DESCENDANT_SELF_AXIS, docs, nestedSet, -1);\r\n            assertEquals(1, children.getLength());\r\n            \r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1.2']\", 1, null);\r\n            children = \r\n                broker.getStructuralIndex().findDescendantsByTagName(ElementValue.ATTRIBUTE, new QName(\"n\", \"\"), \r\n                \t\tConstants.ATTRIBUTE_AXIS, docs, nestedSet, -1);\r\n            assertEquals(1, children.getLength());\r\n            \r\n            nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1']\", 1, null);\r\n            children = \r\n                broker.getStructuralIndex().findDescendantsByTagName(ElementValue.ATTRIBUTE, new QName(\"n\", \"\"), \r\n                \t\tConstants.DESCENDANT_ATTRIBUTE_AXIS, docs, nestedSet, -1);\r\n            assertEquals(7, children.getLength());\r\n            \r\n            System.out.println(\"------------ PASSED: NativeElementIndex.findChildNodesByTagName ---------\");\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) pool.release(broker);\r\n        }\r\n    }","id":47293,"modified_method":"@Test\r\n    public void testOptimizations() throws XPathException, SAXException, PermissionDeniedException {\r\n            \r\n        Serializer serializer = broker.getSerializer();\r\n        serializer.reset();\r\n        DocumentSet docs = root.allDocs(broker, new DefaultDocumentSet(), true, false);\r\n\r\n        System.out.println(\"------------ Testing NativeElementIndex.findChildNodesByTagName ---------\");\r\n        // parent set: 1.1.1; child set: 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.2.1, 1.2.1\r\n        ExtNodeSet nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1.1']\", 1, null);\r\n        NodeSet children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, \r\n                            new QName(\"para\", \"\"), Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n        assertEquals(3, children.getLength());\r\n\r\n        // parent set: 1.1; child set: 1.1.1, 1.1.2\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1']\", 1, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, \r\n                            new QName(\"section\", \"\"), Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n        assertEquals(2, children.getLength());\r\n\r\n        // parent set: 1, 1.1, 1.1.1, 1.1.2 ; child set: 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.2.1, 1.2.1\r\n        // problem: ancestor set contains nested nodes\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = ('1.1', '1.1.1', '1.1.2')]\", 3, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, \r\n                            new QName(\"para\", \"\"), Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n        assertEquals(4, children.getLength());\r\n\r\n        // parent set: 1.1, 1.1.2, 1.2 ; child set: 1.1.1.1, 1.1.1.2, 1.1.1.3, 1.1.2.1, 1.2.1\r\n        // problem: ancestor set contains nested nodes\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = ('1.1', '1.1.2', '1.2')]\", 3, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"para\", \"\"), \r\n                            Constants.CHILD_AXIS, docs, nestedSet, -1);\r\n        assertEquals(2, children.getLength());\r\n\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1']\", 1, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"para\", \"\"), \r\n                            Constants.DESCENDANT_AXIS, docs, nestedSet, -1);\r\n        assertEquals(4, children.getLength());\r\n\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1']\", 1, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"para\", \"\"), \r\n                            Constants.DESCENDANT_AXIS, docs, nestedSet, -1);\r\n        assertEquals(5, children.getLength());\r\n\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1.2']\", 1, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ELEMENT, new QName(\"section\", \"\"), \r\n                            Constants.DESCENDANT_SELF_AXIS, docs, nestedSet, -1);\r\n        assertEquals(1, children.getLength());\r\n\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1.2']\", 1, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ATTRIBUTE, new QName(\"n\", \"\"), \r\n                            Constants.ATTRIBUTE_AXIS, docs, nestedSet, -1);\r\n        assertEquals(1, children.getLength());\r\n\r\n        nestedSet = (ExtNodeSet) executeQuery(broker, \"//section[@n = '1.1']\", 1, null);\r\n        children = \r\n            broker.getElementIndex().findDescendantsByTagName(ElementValue.ATTRIBUTE, new QName(\"n\", \"\"), \r\n                            Constants.DESCENDANT_ATTRIBUTE_AXIS, docs, nestedSet, -1);\r\n        assertEquals(7, children.getLength());\r\n\r\n        System.out.println(\"------------ PASSED: NativeElementIndex.findChildNodesByTagName ---------\");\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void tearDown() {\r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n            broker = pool.get(pool.getSecurityManager().getSystemSubject());\r\n            assertNotNull(broker);            \r\n            transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);            \r\n            System.out.println(\"BasicNodeSetTest#tearDown >>>\");\r\n            \r\n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\r\n            assertNotNull(root);\r\n            broker.removeCollection(transaction, root);\r\n            \r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n            transact.abort(transaction);\r\n            e.printStackTrace();\r\n        } finally {\r\n            if (pool != null) pool.release(broker);\r\n        }\r\n        BrokerPool.stopAll(false);\r\n        pool = null;\r\n        root = null;\r\n    }","id":47294,"modified_method":"@AfterClass\r\n    public static void tearDown() {\r\n        \r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {    \r\n            transact = pool.getTransactionManager();\r\n            transaction = transact.beginTransaction();\r\n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\r\n//          broker.removeCollection(transaction, root);\r\n            \r\n            transact.commit(transaction);\r\n        } catch(Exception e) {\r\n            if(transaction != null) {\r\n                transact.abort(transaction);\r\n            }\r\n        } finally {\r\n            if (pool != null) pool.release(broker);\r\n        }\r\n        BrokerPool.stopAll(false);\r\n        pool = null;\r\n        root = null;\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testSelectors() {\r\n\t\tDBBroker broker = null;\r\n        try {\r\n        \tassertNotNull(pool);\r\n            broker = pool.get(pool.getSecurityManager().getSystemSubject());\r\n            assertNotNull(broker);\r\n            \r\n            @SuppressWarnings(\"unused\")\r\n\t\t\tDocumentSet docs = root.allDocs(broker, new DefaultDocumentSet(), true, false);\r\n            Sequence seq = executeQuery(broker, \"//SPEECH\", 2628, null);\r\n            \r\n            System.out.println(\"Testing ChildSelector ...\");\r\n            NameTest test = new NameTest(Type.ELEMENT, new QName(\"LINE\", \"\"));\r\n            NodeSelector selector = new ChildSelector(seq.toNodeSet(), -1);\r\n            NodeSet set = broker.getStructuralIndex().findElementsByTagName(ElementValue.ELEMENT, seq.getDocumentSet(),\r\n            \t\ttest.getName(), selector);\r\n            assertEquals(9492, set.getLength());\r\n            System.out.println(\"ChildSelector: PASS\");\r\n            \r\n            System.out.println(\"Testing DescendantOrSelfSelector ...\");\r\n            selector = new DescendantOrSelfSelector(seq.toNodeSet(), -1);\r\n            test = new NameTest(Type.ELEMENT, new QName(\"SPEECH\", \"\"));\r\n            set = broker.getStructuralIndex().findElementsByTagName(ElementValue.ELEMENT, seq.getDocumentSet(),\r\n            \t\ttest.getName(), selector);\r\n            assertEquals(2628, set.getLength());\r\n            System.out.println(\"DescendantOrSelfSelector: PASS\");\r\n            \r\n            System.out.println(\"Testing AncestorSelector ...\");\r\n            test = new NameTest(Type.ELEMENT, new QName(\"ACT\", \"\"));\r\n            selector = new AncestorSelector(seq.toNodeSet(), -1, false, true);\r\n            set = broker.getStructuralIndex().findElementsByTagName(ElementValue.ELEMENT, seq.getDocumentSet(),\r\n            \t\ttest.getName(), selector);\r\n            assertEquals(15, set.getLength());\r\n            System.out.println(\"AncestorSelector: PASS\");\r\n            \r\n            System.out.println(\"Testing AncestorSelector: self\");\r\n            test = new NameTest(Type.ELEMENT, new QName(\"SPEECH\", \"\"));\r\n            NodeSet ns = seq.toNodeSet();\r\n            System.out.println(\"ns = \" + ns.getLength());\r\n            selector = new AncestorSelector(ns, -1, true, true);\r\n            set = broker.getStructuralIndex().findElementsByTagName(ElementValue.ELEMENT, seq.getDocumentSet(),\r\n            \t\ttest.getName(), selector);\r\n            assertEquals(2628, set.getLength());\r\n            System.out.println(\"AncestorSelector: PASS\");\r\n            \r\n            System.out.println(\"Testing DescendantSelector ...\");\r\n            seq = executeQuery(broker, \"//SCENE\", 72, null);\r\n            test = new NameTest(Type.ELEMENT, new QName(\"SPEAKER\", \"\"));\r\n            selector = new DescendantSelector(seq.toNodeSet(), -1);\r\n            set = broker.getStructuralIndex().findElementsByTagName(ElementValue.ELEMENT, seq.getDocumentSet(),\r\n            \t\ttest.getName(), selector);\r\n            assertEquals(2639, set.getLength());\r\n            System.out.println(\"DescendantSelector: PASS\");\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n\t        fail(e.getMessage());\r\n        } finally {\r\n        \tif (pool != null) pool.release(broker);\r\n        }\r\n\t}","id":47295,"modified_method":"@Test\r\n    public void selectAncestors() throws XPathException, SAXException, PermissionDeniedException {\r\n        NameTest test = new NameTest(Type.ELEMENT, new QName(\"SCENE\", \"\"));\r\n        NodeSet scenes = broker.getElementIndex().findElementsByTagName(ElementValue.ELEMENT, docs, test.getName(), null);\r\n        Sequence largeSet = executeQuery(broker, \"//SPEECH/LINE[fn:contains(., 'love')]/ancestor::SPEECH\", 187, null);\r\n        \r\n        NodeSet result = ((AbstractNodeSet)scenes).selectAncestors(largeSet.toNodeSet(), false, -1);\r\n        assertEquals(49, result.getLength());\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() throws Exception {        \r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n        \tpool = startDB();\r\n        \tassertNotNull(pool);\r\n            broker = pool.get(pool.getSecurityManager().getSystemSubject());\r\n            assertNotNull(broker);            \r\n            transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);            \r\n            System.out.println(\"BasicNodeSetTest#setUp ...\");\r\n\r\n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\r\n            assertNotNull(root);\r\n            broker.saveCollection(transaction, root);\r\n\r\n            CollectionConfigurationManager mgr = pool.getConfigurationManager();\r\n            mgr.addConfiguration(transaction, broker, root, COLLECTION_CONFIG1);\r\n            \r\n            \r\n            File files[] = dir.listFiles(new XMLFilenameFilter());\r\n            assertNotNull(files);\r\n            \r\n            File f;\r\n            IndexInfo info;\r\n            // store some documents.\r\n            for (int i = 0; i < files.length; i++) {\r\n                f = files[i];\r\n                try {\r\n                    info = root.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\r\n                    assertNotNull(info);\r\n                    root.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\r\n                } catch (SAXException e) {\r\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\r\n                }\r\n            }\r\n            \r\n            info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"nested.xml\"), NESTED_XML);\r\n            //TODO : unlock the collection here ?\r\n            assertNotNull(info);\r\n            root.store(transaction, broker, info, NESTED_XML, false);\r\n            \r\n            transact.commit(transaction);\r\n            System.out.println(\"BasicNodeSetTest#setUp finished.\");\r\n        } catch (Exception e) {\r\n        \ttransact.abort(transaction);\r\n            e.printStackTrace();\r\n\t        fail(e.getMessage()); \t        \r\n        } finally {\r\n        \tif (pool != null) pool.release(broker);\r\n        }\r\n\t}","id":47296,"modified_method":"@BeforeClass\r\n    public static void setUp() throws Exception {\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n            pool = startDB();\r\n            broker = pool.get(pool.getSecurityManager().getSystemSubject());\r\n            transact = pool.getTransactionManager();\r\n            transaction = transact.beginTransaction();\r\n\r\n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\r\n            broker.saveCollection(transaction, root);\r\n\r\n            String existHome = System.getProperty(\"exist.home\");\r\n            File existDir = existHome==null ? new File(\".\") : new File(existHome);\r\n            String directory = \"samples/shakespeare\";\r\n            File dir = new File(existDir, directory);\r\n\r\n            // store some documents.\r\n            for(File f : dir.listFiles(new XMLFilenameFilter())) {\r\n                IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\r\n                root.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\r\n            }\r\n\r\n            IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"nested.xml\"), NESTED_XML);\r\n            root.store(transaction, broker, info, NESTED_XML, false);\r\n            transact.commit(transaction);\r\n            \r\n            \r\n            //for the tests\r\n            docs = root.allDocs(broker, new DefaultDocumentSet(), true, false);\r\n            seqSpeech = executeQuery(broker, \"//SPEECH\", 2628, null);\r\n            \r\n        } catch(Exception e) {\r\n            if (pool != null) {\r\n                pool.release(broker);\r\n                BrokerPool.stopAll(false);\r\n                pool = null;\r\n                root = null;\r\n            }\r\n            throw e;\r\n        }\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testVirtualNodeSet() {\r\n\t\tDBBroker broker = null;\r\n        try {\r\n        \tassertNotNull(pool);\r\n            broker = pool.get(pool.getSecurityManager().getSystemSubject());\r\n            assertNotNull(broker);\r\n            \r\n            Serializer serializer = broker.getSerializer();\r\n            serializer.reset();\r\n            \r\n            executeQuery(broker, \"//*/LINE\", 9492, null);\r\n            executeQuery(broker, \"//*/LINE/*\", 61, null);\r\n            executeQuery(broker, \"//*/LINE/text()\", 9485, null);\r\n            executeQuery(broker, \"//SCENE/*/LINE\", 9464, null);\r\n            executeQuery(broker, \"//SCENE/*[LINE &= 'spirit']\", 21, null);\r\n            executeQuery(broker, \"//SCENE/*[LINE &= 'the']\", 1005, null);\r\n            executeQuery(broker, \"//SCENE/*/LINE[. &= 'the']\", 2167, null);\r\n            executeQuery(broker, \"//SPEECH[LINE &= 'spirit']/ancestor::*\", 30, null);\r\n            executeQuery(broker, \"for $s in //SCENE/*[LINE &= 'the'] return node-name($s)\", 1005, null);\r\n            \r\n            executeQuery(broker, \"//SPEECH[LINE &= 'perturbed spirit']/preceding-sibling::*\", 65, null);\r\n            executeQuery(broker, \"//SPEECH[LINE &= 'perturbed spirit']/following-sibling::*\", 1, null);\r\n        } catch (Exception e) {\r\n        \te.printStackTrace();\r\n\t        fail(e.getMessage());\r\n        } finally {\r\n        \tif (pool != null) pool.release(broker);\r\n        }\r\n\t}","id":47297,"modified_method":"@Test\r\n    public void virtualNodeSet_5() throws XPathException, SAXException, PermissionDeniedException {\r\n        executeQuery(broker, \"//SCENE/*[fn:contains(LINE, 'spirit')]\", 30, null);\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"private Sequence executeQuery(DBBroker broker, String query, int expected,\r\n\t\t\tString expectedResult) throws XPathException, SAXException, PermissionDeniedException {\r\n\t\tXQuery xquery = broker.getXQueryService();\r\n\t\tassertNotNull(xquery);\r\n\t\tSequence seq = xquery.execute(query, null, AccessContext.TEST);\r\n\t\tassertNotNull(seq);\r\n\t\tassertEquals(expected, seq.getItemCount());\r\n\t\tSystem.out.println(\"Found: \" + seq.getItemCount() + \" for query:\\n\" + query);\r\n\t\tif (expectedResult != null) {\r\n\t        Item item = seq.itemAt(0);\r\n\t        String value = serialize(broker, item);\r\n\t        assertEquals(expectedResult, value);\r\n\t\t}\r\n\t\treturn seq;\r\n\t}","id":47298,"modified_method":"private static Sequence executeQuery(DBBroker broker, String query, int expected, String expectedResult) throws XPathException, SAXException, PermissionDeniedException {\r\n        XQuery xquery = broker.getXQueryService();\r\n        Sequence seq = xquery.execute(query, null, AccessContext.TEST);\r\n        assertEquals(expected, seq.getItemCount());\r\n        \r\n        if (expectedResult != null) {\r\n            Item item = seq.itemAt(0);\r\n            String value = serialize(broker, item);\r\n            assertEquals(expectedResult, value);\r\n        }\r\n        return seq;\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"protected BrokerPool startDB() {\r\n        String home, file = \"conf.xml\";\r\n        home = System.getProperty(\"exist.home\");\r\n        if (home == null)\r\n            home = System.getProperty(\"user.dir\");\r\n        try {\r\n            Configuration config = new Configuration(file, home);\r\n            BrokerPool.configure(1, 5, config);\r\n            return BrokerPool.getInstance();\r\n        } catch (Exception e) {            \r\n            fail(e.getMessage());\r\n        }\r\n        return null;\r\n    }","id":47299,"modified_method":"private static BrokerPool startDB() throws DatabaseConfigurationException, EXistException {\r\n        String home, file = \"conf.xml\";\r\n        home = System.getProperty(\"exist.home\");\r\n        if (home == null) {\r\n            home = System.getProperty(\"user.dir\");\r\n        }\r\n        \r\n        Configuration config = new Configuration(file, home);\r\n        BrokerPool.configure(1, 5, config);\r\n        return BrokerPool.getInstance();\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"private String serialize(DBBroker broker, Item item) throws SAXException, XPathException {\r\n\t\tSerializer serializer = broker.getSerializer();\r\n\t\tassertNotNull(serializer);\r\n        serializer.reset();\r\n\t\tString value;\r\n\t\tif (Type.subTypeOf(item.getType(), Type.NODE))\r\n\t\t\tvalue = serializer.serialize((NodeValue) item);\r\n\t\telse\r\n\t\t\tvalue = item.getStringValue();\r\n\t\treturn value;\r\n\t}","id":47300,"modified_method":"private static String serialize(DBBroker broker, Item item) throws SAXException, XPathException {\r\n        Serializer serializer = broker.getSerializer();\r\n\t\r\n        serializer.reset();\r\n        String value;\r\n        if(Type.subTypeOf(item.getType(), Type.NODE)) {\r\n            value = serializer.serialize((NodeValue) item);\r\n        } else {\t\r\n            value = item.getStringValue();\r\n        }\r\n        return value;\r\n    }","commit_id":"8659d4c63074a64dcee6273a97f242d31b37b4bb","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(DeleteMeta)smi;\n\t\tdata=(DeleteData)sdi;\n\t\t\n\t\tboolean sendToErrorRow=false;\n\t\tString errorMessage = null;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            // What's the output Row format?\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTableName());\n                                    \n            // lookup the values!\n            if (log.isDetailed()) logDetailed(Messages.getString(\"Delete.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs  = new int[meta.getKeyStream().length];\n            data.keynrs2 = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Delete.Exception.FieldRequired\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getKeyStream2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Delete.Exception.FieldRequired\",meta.getKeyStream2()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                \n                if (log.isDebug()) logDebug(Messages.getString(\"Delete.Log.FieldInfo\",meta.getKeyStream()[i])+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            prepareDelete(getInputRowMeta());\n        }\n\n\t\t    \n\t\ttry\n\t\t{\n\t\t\tdeleteValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n\t\t\tputRow(data.outputRowMeta, r);      // output the same rows of data, but with a copy of the metadata\n\t\t\t\n            if (checkFeedback(linesRead)) \r\n            {\r\n            \tif(log.isBasic()) logBasic(Messages.getString(\"Delete.Log.LineNumber\")+linesRead); //$NON-NLS-1$\r\n            }\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\t\n\t\t\tif (getStepMeta().isDoingErrorHandling())\n\t        {\n                sendToErrorRow = true;\n                errorMessage = e.toString();\n\t        }\n\t        else\n\t        {\n\t\t\t\n\t\t\t\tlogError(Messages.getString(\"Delete.Log.ErrorInStep\")+e.getMessage()); //$NON-NLS-1$\n\t\t\t\tsetErrors(1);\n\t\t\t\tstopAll();\n\t\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\t\treturn false;\n\t        }\n\t\t\t\n\t\t\t if (sendToErrorRow)\n\t         {\n\t\t\t\t // Simply add this row to the error row\n\t             putError(getInputRowMeta(), r, 1, errorMessage, null, \"DEL001\");\n\t         }\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","id":47301,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(DeleteMeta)smi;\n\t\tdata=(DeleteData)sdi;\n\t\t\n\t\tboolean sendToErrorRow=false;\n\t\tString errorMessage = null;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            // What's the output Row format?\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(environmentSubstitute(meta.getSchemaName()), environmentSubstitute(meta.getTableName()));\n                                    \n            // lookup the values!\n            if (log.isDetailed()) logDetailed(Messages.getString(\"Delete.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs  = new int[meta.getKeyStream().length];\n            data.keynrs2 = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Delete.Exception.FieldRequired\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getKeyStream2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Delete.Exception.FieldRequired\",meta.getKeyStream2()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                \n                if (log.isDebug()) logDebug(Messages.getString(\"Delete.Log.FieldInfo\",meta.getKeyStream()[i])+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            prepareDelete(getInputRowMeta());\n        }\n\n\t\t    \n\t\ttry\n\t\t{\n\t\t\tdeleteValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n\t\t\tputRow(data.outputRowMeta, r);      // output the same rows of data, but with a copy of the metadata\n\t\t\t\n            if (checkFeedback(linesRead)) \r\n            {\r\n            \tif(log.isBasic()) logBasic(Messages.getString(\"Delete.Log.LineNumber\")+linesRead); //$NON-NLS-1$\r\n            }\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\t\n\t\t\tif (getStepMeta().isDoingErrorHandling())\n\t        {\n                sendToErrorRow = true;\n                errorMessage = e.toString();\n\t        }\n\t        else\n\t        {\n\t\t\t\n\t\t\t\tlogError(Messages.getString(\"Delete.Log.ErrorInStep\")+e.getMessage()); //$NON-NLS-1$\n\t\t\t\tsetErrors(1);\n\t\t\t\tstopAll();\n\t\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\t\treturn false;\n\t        }\n\t\t\t\n\t\t\t if (sendToErrorRow)\n\t         {\n\t\t\t\t // Simply add this row to the error row\n\t             putError(getInputRowMeta(), r, 1, errorMessage, null, \"DEL001\");\n\t         }\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"e340cff282fd47cef2733e655a1c6f631f00ef7f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DeleteDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DeleteDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"DeleteDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"DeleteDialog.TargetTable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"DeleteDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Commit line\n\t\twlCommit = new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"DeleteDialog.Commit.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit = new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.top = new FormAttachment(wTable, margin);\n\t\tfdlCommit.right = new FormAttachment(middle, -margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit = new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top = new FormAttachment(wTable, margin);\n\t\tfdCommit.right = new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n        \n       \n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"DeleteDialog.Key.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCommit, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getKeyStream()!=null?input.getKeyStream().length:1);\n\t\t\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.TableField\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.Comparator\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.StreamField1\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.StreamField2\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\t\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t      props\n\t\t\t\t\t\t      );\n\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DeleteDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\tfdGet = new FormData();\n\t\tfdGet.right = new FormAttachment(100, 0);\n\t\tfdGet.top = new FormAttachment(wlKey, margin);\n\t\twGet.setLayoutData(fdGet);\n\n\t\tfdKey = new FormData();\n\t\tfdKey.left = new FormAttachment(0, 0);\n\t\tfdKey.top = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(wGet, -margin);\n\t\tfdKey.bottom = new FormAttachment(100, -30);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\t\t\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n        wSchema.addSelectionListener( lsDef );\n        wTable.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":47302,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DeleteDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DeleteDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"DeleteDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"DeleteDialog.TargetTable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"DeleteDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Commit line\n\t\twlCommit = new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"DeleteDialog.Commit.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit = new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.top = new FormAttachment(wTable, margin);\n\t\tfdlCommit.right = new FormAttachment(middle, -margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit = new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top = new FormAttachment(wTable, margin);\n\t\tfdCommit.right = new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n        \n       \n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"DeleteDialog.Key.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCommit, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getKeyStream()!=null?input.getKeyStream().length:1);\n\t\t\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.TableField\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.Comparator\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.StreamField1\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"DeleteDialog.ColumnInfo.StreamField2\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\t\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t      props\n\t\t\t\t\t\t      );\n\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DeleteDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\tfdGet = new FormData();\n\t\tfdGet.right = new FormAttachment(100, 0);\n\t\tfdGet.top = new FormAttachment(wlKey, margin);\n\t\twGet.setLayoutData(fdGet);\n\n\t\tfdKey = new FormData();\n\t\tfdKey.left = new FormAttachment(0, 0);\n\t\tfdKey.top = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(wGet, -margin);\n\t\tfdKey.bottom = new FormAttachment(100, -30);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\t\t\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n        wSchema.addSelectionListener( lsDef );\n        wTable.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"e340cff282fd47cef2733e655a1c6f631f00ef7f","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(DatabaseLookupMeta)smi;\n\t\tdata=(DatabaseLookupData)sdi;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            // create the output metadata\n            data.outputRowMeta = (RowMetaInterface)getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\n            if (meta.isCached())\n            {\n                if (meta.getCacheSize()>0)\n                {\n                    data.look=new Hashtable<RowMetaAndData, TimedRow>((int)(meta.getCacheSize()*1.5));\n                }\n                else\n                {\n                    data.look=new Hashtable<RowMetaAndData, TimedRow>();\n                }\n            }\n\n            data.db.setLookup(meta.getSchemaName(), meta.getTablename(), meta.getTableKeyField(), meta.getKeyCondition(), meta.getReturnValueField(), meta.getReturnValueNewName(), meta.getOrderByClause(), meta.isFailingOnMultipleResults());\n\n            // lookup the values!\n            if (log.isRowLevel()) logDetailed(Messages.getString(\"DatabaseLookup.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs = new int[meta.getStreamKeyField1().length];\n            data.keynrs2= new int[meta.getStreamKeyField1().length];\n\n            for (int i=0;i<meta.getStreamKeyField1().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getStreamKeyField1()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired1.Exception\")+meta.getStreamKeyField1()[i]+Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired2.Exception\")); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getStreamKeyField2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired3.Exception\")+meta.getStreamKeyField2()[i]+Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired4.Exception\")); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                if (log.isDebug()) logDebug(Messages.getString(\"DatabaseLookup.Log.FieldHasIndex1\")+meta.getStreamKeyField1()[i]+Messages.getString(\"DatabaseLookup.Log.FieldHasIndex2\")+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n\n            data.nullif = new Object[meta.getReturnValueField().length];\n\n            for (int i=0;i<meta.getReturnValueField().length;i++)\n            {\n                ValueMetaInterface stringMeta = new ValueMeta(\"string\", ValueMetaInterface.TYPE_STRING);\n                ValueMetaInterface returnMeta = data.outputRowMeta.getValueMeta(i+getInputRowMeta().size());\n                \n                if (!Const.isEmpty(meta.getReturnValueDefault()[i]))\n                {\n                    data.nullif[i] = returnMeta.convertData(stringMeta, meta.getReturnValueDefault()[i]);\n                }\n                else\n                {\n                    data.nullif[i] = null;;\n                }\n            }\n\n            // Determine the types...\n            data.keytypes = new int[meta.getTableKeyField().length];\n            String schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTablename());\n            RowMetaInterface fields = data.db.getTableFields(schemaTable);\n            if (fields!=null)\n            {\n                // Fill in the types...\n                for (int i=0;i<meta.getTableKeyField().length;i++)\n                {\n                    ValueMetaInterface key = fields.searchValueMeta(meta.getTableKeyField()[i]);\n                    if (key!=null)\n                    {\n                        data.keytypes[i] = key.getType();\n                    }\n                    else\n                    {\n                        throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired5.Exception\")+meta.getTableKeyField()[i]+Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired6.Exception\")); //$NON-NLS-1$ //$NON-NLS-2$\n                    }\n                }\n            }\n            else\n            {\n                throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0002.UnableToDetermineFieldsOfTable\")+schemaTable+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            // Count the number of values in the lookup as well as the metadata to send along with it.\n            //\n            data.lookupMeta = new RowMeta();\n            \n            for (int i=0;i<meta.getStreamKeyField1().length;i++)\n            {\n                if (data.keynrs[i]>=0)\n                {\n                    ValueMetaInterface value = (ValueMetaInterface) getInputRowMeta().getValueMeta(data.keynrs[i]).clone();\n                    \n                    // Try to convert type if needed in a clone, we don't want to\n                    // change the type in the original row\n\n                    if (value.getType()!=data.keytypes[i]) value.setType(data.keytypes[i]);\n                    data.lookupMeta.addValueMeta( value );\n                }\n                if (data.keynrs2[i]>=0)\n                {\n                    ValueMetaInterface value = getInputRowMeta().getValueMeta(data.keynrs2[i]);\n\n                    // Try to convert type if needed in a clone, we don't want to\n                    // change the type in the original row\n                    \n                    if (value.getType()!=data.keytypes[i]) value.setType(data.keytypes[i]);\n                    data.lookupMeta.addValueMeta( value );\n                }\n            }\n            \n            // We also want to know the metadata of the return values beforehand (null handling)\n            data.returnMeta = new RowMeta();\n            \n            for (int i=0;i<meta.getReturnValueField().length;i++)\n            {\n                ValueMetaInterface v = (ValueMetaInterface) data.outputRowMeta.getValueMeta(getInputRowMeta().size()+i).clone();\n                data.returnMeta.addValueMeta(v);\n            }\n        }\n\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.GotRowFromPreviousStep\")+r); //$NON-NLS-1$\n\n\t\ttry\n\t\t{\n            // add new lookup values to the row\n            Object[] outputRow = lookupValues(getInputRowMeta(), r); \n\n            // copy row to output rowset(s);\n\t\t\tputRow(data.outputRowMeta, outputRow);\n            \n\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.WroteRowToNextStep\")+r); //$NON-NLS-1$\n            if (checkFeedback(linesRead)) logBasic(\"linenr \"+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"DatabaseLookup.ERROR003.UnexpectedErrorDuringProcessing\")+e.getMessage()); //$NON-NLS-1$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":47303,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(DatabaseLookupMeta)smi;\n\t\tdata=(DatabaseLookupData)sdi;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            // create the output metadata\n            data.outputRowMeta = (RowMetaInterface)getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\n            if (meta.isCached())\n            {\n                if (meta.getCacheSize()>0)\n                {\n                    data.look=new Hashtable<RowMetaAndData, TimedRow>((int)(meta.getCacheSize()*1.5));\n                }\n                else\n                {\n                    data.look=new Hashtable<RowMetaAndData, TimedRow>();\n                }\n            }\n\n            data.db.setLookup(environmentSubstitute(meta.getSchemaName()), \n            \t\t          environmentSubstitute(meta.getTablename()), meta.getTableKeyField(), meta.getKeyCondition(), meta.getReturnValueField(), meta.getReturnValueNewName(), meta.getOrderByClause(), meta.isFailingOnMultipleResults());\n\n            // lookup the values!\n            if (log.isRowLevel()) logDetailed(Messages.getString(\"DatabaseLookup.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs = new int[meta.getStreamKeyField1().length];\n            data.keynrs2= new int[meta.getStreamKeyField1().length];\n\n            for (int i=0;i<meta.getStreamKeyField1().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getStreamKeyField1()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired1.Exception\")+meta.getStreamKeyField1()[i]+Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired2.Exception\")); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getStreamKeyField2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired3.Exception\")+meta.getStreamKeyField2()[i]+Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired4.Exception\")); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                if (log.isDebug()) logDebug(Messages.getString(\"DatabaseLookup.Log.FieldHasIndex1\")+meta.getStreamKeyField1()[i]+Messages.getString(\"DatabaseLookup.Log.FieldHasIndex2\")+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n\n            data.nullif = new Object[meta.getReturnValueField().length];\n\n            for (int i=0;i<meta.getReturnValueField().length;i++)\n            {\n                ValueMetaInterface stringMeta = new ValueMeta(\"string\", ValueMetaInterface.TYPE_STRING);\n                ValueMetaInterface returnMeta = data.outputRowMeta.getValueMeta(i+getInputRowMeta().size());\n                \n                if (!Const.isEmpty(meta.getReturnValueDefault()[i]))\n                {\n                    data.nullif[i] = returnMeta.convertData(stringMeta, meta.getReturnValueDefault()[i]);\n                }\n                else\n                {\n                    data.nullif[i] = null;;\n                }\n            }\n\n            // Determine the types...\n            data.keytypes = new int[meta.getTableKeyField().length];\n            String schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(environmentSubstitute(meta.getSchemaName()), \n            \t\t                                                                    environmentSubstitute(meta.getTablename()));\n            RowMetaInterface fields = data.db.getTableFields(schemaTable);\n            if (fields!=null)\n            {\n                // Fill in the types...\n                for (int i=0;i<meta.getTableKeyField().length;i++)\n                {\n                    ValueMetaInterface key = fields.searchValueMeta(meta.getTableKeyField()[i]);\n                    if (key!=null)\n                    {\n                        data.keytypes[i] = key.getType();\n                    }\n                    else\n                    {\n                        throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired5.Exception\")+meta.getTableKeyField()[i]+Messages.getString(\"DatabaseLookup.ERROR0001.FieldRequired6.Exception\")); //$NON-NLS-1$ //$NON-NLS-2$\n                    }\n                }\n            }\n            else\n            {\n                throw new KettleStepException(Messages.getString(\"DatabaseLookup.ERROR0002.UnableToDetermineFieldsOfTable\")+schemaTable+\"]\"); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            // Count the number of values in the lookup as well as the metadata to send along with it.\n            //\n            data.lookupMeta = new RowMeta();\n            \n            for (int i=0;i<meta.getStreamKeyField1().length;i++)\n            {\n                if (data.keynrs[i]>=0)\n                {\n                    ValueMetaInterface value = (ValueMetaInterface) getInputRowMeta().getValueMeta(data.keynrs[i]).clone();\n                    \n                    // Try to convert type if needed in a clone, we don't want to\n                    // change the type in the original row\n\n                    if (value.getType()!=data.keytypes[i]) value.setType(data.keytypes[i]);\n                    data.lookupMeta.addValueMeta( value );\n                }\n                if (data.keynrs2[i]>=0)\n                {\n                    ValueMetaInterface value = getInputRowMeta().getValueMeta(data.keynrs2[i]);\n\n                    // Try to convert type if needed in a clone, we don't want to\n                    // change the type in the original row\n                    \n                    if (value.getType()!=data.keytypes[i]) value.setType(data.keytypes[i]);\n                    data.lookupMeta.addValueMeta( value );\n                }\n            }\n            \n            // We also want to know the metadata of the return values beforehand (null handling)\n            data.returnMeta = new RowMeta();\n            \n            for (int i=0;i<meta.getReturnValueField().length;i++)\n            {\n                ValueMetaInterface v = (ValueMetaInterface) data.outputRowMeta.getValueMeta(getInputRowMeta().size()+i).clone();\n                data.returnMeta.addValueMeta(v);\n            }\n        }\n\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.GotRowFromPreviousStep\")+r); //$NON-NLS-1$\n\n\t\ttry\n\t\t{\n            // add new lookup values to the row\n            Object[] outputRow = lookupValues(getInputRowMeta(), r); \n\n            // copy row to output rowset(s);\n\t\t\tputRow(data.outputRowMeta, outputRow);\n            \n\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DatabaseLookup.Log.WroteRowToNextStep\")+r); //$NON-NLS-1$\n            if (checkFeedback(linesRead)) logBasic(\"linenr \"+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"DatabaseLookup.ERROR003.UnexpectedErrorDuringProcessing\")+e.getMessage()); //$NON-NLS-1$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"2fa648c0139f391707f6d710be70a52819787088","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\t\n\t\tFocusListener lsFocusLost = new FocusAdapter() {\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t\tsetTableFieldCombo();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DatabaseLookupDialog.shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DatabaseLookupDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"DatabaseLookupDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        wSchema.addFocusListener(lsFocusLost);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"DatabaseLookupDialog.Lookuptable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin*2);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"DatabaseLookupDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\twTable.addFocusListener(lsFocusLost);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin*2);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Cache?\n\t\twlCache=new Label(shell, SWT.RIGHT);\n\t\twlCache.setText(Messages.getString(\"DatabaseLookupDialog.Cache.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCache);\n\t\tfdlCache=new FormData();\n\t\tfdlCache.left = new FormAttachment(0, 0);\n\t\tfdlCache.right= new FormAttachment(middle, -margin);\n\t\tfdlCache.top  = new FormAttachment(wbTable, margin);\n\t\twlCache.setLayoutData(fdlCache);\n\t\twCache=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wCache);\n\t\tfdCache=new FormData();\n\t\tfdCache.left = new FormAttachment(middle, 0);\n\t\tfdCache.top  = new FormAttachment(wbTable, margin);\n\t\twCache.setLayoutData(fdCache);\n\t\twCache.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tinput.setChanged();\n\t\t\t\t\t\n\t\t\t\t\twCachesize.setEnabled(wCache.getSelection());\n\t\t\t\t\twlCachesize.setEnabled(wCache.getSelection());\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Cache size line\n\t\twlCachesize=new Label(shell, SWT.RIGHT);\n\t\twlCachesize.setText(Messages.getString(\"DatabaseLookupDialog.Cachesize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCachesize);\n\t\twlCachesize.setEnabled(input.isCached());\n\t\tfdlCachesize=new FormData();\n\t\tfdlCachesize.left   = new FormAttachment(0, 0);\n\t\tfdlCachesize.right  = new FormAttachment(middle, -margin);\n\t\tfdlCachesize.top    = new FormAttachment(wlCache, margin);\n\t\twlCachesize.setLayoutData(fdlCachesize);\n\t\twCachesize=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCachesize);\n\t\twCachesize.setEnabled(input.isCached());\n\t\twCachesize.addModifyListener(lsMod);\n\t\tfdCachesize=new FormData();\n\t\tfdCachesize.left   = new FormAttachment(middle, 0);\n\t\tfdCachesize.right  = new FormAttachment(100, 0);\n\t\tfdCachesize.top    = new FormAttachment(wlCache, margin);\n\t\twCachesize.setLayoutData(fdCachesize);\n\n\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"DatabaseLookupDialog.Keys.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCachesize, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getStreamKeyField1()!=null?input.getStreamKeyField1().length:1);\n\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Tablefield\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},  false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Comparator\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field1\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field2\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\ttableFieldColumns.add(ciKey[0]);\n\t\tfieldColumns.add(ciKey[2]);\n\t\tfieldColumns.add(ciKey[3]);\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdKey=new FormData();\n\t\tfdKey.left  = new FormAttachment(0, 0);\n\t\tfdKey.top   = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(100, 0);\n\t\tfdKey.bottom= new FormAttachment(wlKey, 150);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DatabaseLookupDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twGetLU=new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"DatabaseLookupDialog.GetLookupFields.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wGet, wGetLU, wCancel }, margin, null);\n\n\t\t// OderBy line\n\t\twlOrderBy=new Label(shell, SWT.RIGHT);\n\t\twlOrderBy.setText(Messages.getString(\"DatabaseLookupDialog.Orderby.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlOrderBy);\n\t\tfdlOrderBy=new FormData();\n\t\tfdlOrderBy.left   = new FormAttachment(0, 0);\n\t\tfdlOrderBy.right  = new FormAttachment(middle, -margin);\n\t\tfdlOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\twlOrderBy.setLayoutData(fdlOrderBy);\n\t\twOrderBy=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wOrderBy);\n\t\tfdOrderBy=new FormData();\n\t\tfdOrderBy.left   = new FormAttachment(middle, 0);\n\t\tfdOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\tfdOrderBy.right  = new FormAttachment(100, 0);\n\t\twOrderBy.setLayoutData(fdOrderBy);\n\n        // FailMultiple?\n        wlFailMultiple=new Label(shell, SWT.RIGHT);\n        wlFailMultiple.setText(Messages.getString(\"DatabaseLookupDialog.FailMultiple.Label\")); //$NON-NLS-1$\n        props.setLook(wlFailMultiple);\n        fdlFailMultiple=new FormData();\n        fdlFailMultiple.left   = new FormAttachment(0, 0);\n        fdlFailMultiple.right  = new FormAttachment(middle, -margin);\n        fdlFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wlFailMultiple.setLayoutData(fdlFailMultiple);\n        wFailMultiple=new Button(shell, SWT.CHECK);\n        props.setLook(wFailMultiple);\n        fdFailMultiple=new FormData();\n        fdFailMultiple.left   = new FormAttachment(middle, 0);\n        fdFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wFailMultiple.setLayoutData(fdFailMultiple);\n        wFailMultiple.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    setFlags();\n                }\n            }\n        );\n\n        // EatRows?\n        wlEatRows=new Label(shell, SWT.RIGHT);\n        wlEatRows.setText(Messages.getString(\"DatabaseLookupDialog.EatRows.Label\")); //$NON-NLS-1$\n        props.setLook(wlEatRows);\n        fdlEatRows=new FormData();\n        fdlEatRows.left   = new FormAttachment(0, 0);\n        fdlEatRows.right  = new FormAttachment(middle, -margin);\n        fdlEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wlEatRows.setLayoutData(fdlEatRows);\n        wEatRows=new Button(shell, SWT.CHECK);\n        props.setLook(wEatRows);\n        fdEatRows=new FormData();\n        fdEatRows.left   = new FormAttachment(middle, 0);\n        fdEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wEatRows.setLayoutData(fdEatRows);\n        wEatRows.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    setFlags();\n                }\n            }\n        );\n\n        \n        // THE UPDATE/INSERT TABLE\n        wlReturn=new Label(shell, SWT.NONE);\n        wlReturn.setText(Messages.getString(\"DatabaseLookupDialog.Return.Label\")); //$NON-NLS-1$\n        props.setLook(wlReturn);\n        fdlReturn=new FormData();\n        fdlReturn.left  = new FormAttachment(0, 0);\n        fdlReturn.top   = new FormAttachment(wKey, margin);\n        wlReturn.setLayoutData(fdlReturn);\n        \n        int UpInsCols=4;\n        int UpInsRows= (input.getReturnValueField()!=null?input.getReturnValueField().length:1);\n        \n        ColumnInfo[] ciReturn=new ColumnInfo[UpInsCols];\n        ciReturn[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field\"),    ColumnInfo.COLUMN_TYPE_CCOMBO,new String[]{},  false); //$NON-NLS-1$\n        ciReturn[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Newname\"), ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Default\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Type\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes()); //$NON-NLS-1$\n        tableFieldColumns.add(ciReturn[0]);\n        \n        wReturn=new TableView(transMeta, shell, \n                              SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n                              ciReturn, \n                              UpInsRows,  \n                              lsMod,\n                              props\n                              );\n\n        fdReturn=new FormData();\n        fdReturn.left  = new FormAttachment(0, 0);\n        fdReturn.top   = new FormAttachment(wlReturn, margin);\n        fdReturn.right = new FormAttachment(100, 0);\n        fdReturn.bottom= new FormAttachment(wEatRows, -margin);\n        wReturn.setLayoutData(fdReturn);\n\n\n        \n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsGetLU    = new Listener() { public void handleEvent(Event e) { getlookup(); } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twGetLU.addListener (SWT.Selection, lsGetLU );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twTable.addSelectionListener( lsDef );\n\t\twOrderBy.addSelectionListener( lsDef );\n\t\twCachesize.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\t\t\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\n\t\tsetComboValues();\n\t\tsetTableFieldCombo();\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":47304,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\t\n\t\tFocusListener lsFocusLost = new FocusAdapter() {\n\t\t\tpublic void focusLost(FocusEvent arg0) {\n\t\t\t\tsetTableFieldCombo();\n\t\t\t}\n\t\t};\n\t\tbackupChanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"DatabaseLookupDialog.shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"DatabaseLookupDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"DatabaseLookupDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        wSchema.addFocusListener(lsFocusLost);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"DatabaseLookupDialog.Lookuptable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin*2);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"DatabaseLookupDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\twTable.addFocusListener(lsFocusLost);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin*2);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Cache?\n\t\twlCache=new Label(shell, SWT.RIGHT);\n\t\twlCache.setText(Messages.getString(\"DatabaseLookupDialog.Cache.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCache);\n\t\tfdlCache=new FormData();\n\t\tfdlCache.left = new FormAttachment(0, 0);\n\t\tfdlCache.right= new FormAttachment(middle, -margin);\n\t\tfdlCache.top  = new FormAttachment(wbTable, margin);\n\t\twlCache.setLayoutData(fdlCache);\n\t\twCache=new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wCache);\n\t\tfdCache=new FormData();\n\t\tfdCache.left = new FormAttachment(middle, 0);\n\t\tfdCache.top  = new FormAttachment(wbTable, margin);\n\t\twCache.setLayoutData(fdCache);\n\t\twCache.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tinput.setChanged();\n\t\t\t\t\t\n\t\t\t\t\twCachesize.setEnabled(wCache.getSelection());\n\t\t\t\t\twlCachesize.setEnabled(wCache.getSelection());\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Cache size line\n\t\twlCachesize=new Label(shell, SWT.RIGHT);\n\t\twlCachesize.setText(Messages.getString(\"DatabaseLookupDialog.Cachesize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCachesize);\n\t\twlCachesize.setEnabled(input.isCached());\n\t\tfdlCachesize=new FormData();\n\t\tfdlCachesize.left   = new FormAttachment(0, 0);\n\t\tfdlCachesize.right  = new FormAttachment(middle, -margin);\n\t\tfdlCachesize.top    = new FormAttachment(wlCache, margin);\n\t\twlCachesize.setLayoutData(fdlCachesize);\n\t\twCachesize=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCachesize);\n\t\twCachesize.setEnabled(input.isCached());\n\t\twCachesize.addModifyListener(lsMod);\n\t\tfdCachesize=new FormData();\n\t\tfdCachesize.left   = new FormAttachment(middle, 0);\n\t\tfdCachesize.right  = new FormAttachment(100, 0);\n\t\tfdCachesize.top    = new FormAttachment(wlCache, margin);\n\t\twCachesize.setLayoutData(fdCachesize);\n\n\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"DatabaseLookupDialog.Keys.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wCachesize, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getStreamKeyField1()!=null?input.getStreamKeyField1().length:1);\n\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Tablefield\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},  false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Comparator\"),   ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field1\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field2\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, new String[]{\"\"},   false); //$NON-NLS-1$\n\t\ttableFieldColumns.add(ciKey[0]);\n\t\tfieldColumns.add(ciKey[2]);\n\t\tfieldColumns.add(ciKey[3]);\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t      );\n\n\t\tfdKey=new FormData();\n\t\tfdKey.left  = new FormAttachment(0, 0);\n\t\tfdKey.top   = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(100, 0);\n\t\tfdKey.bottom= new FormAttachment(wlKey, 150);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"DatabaseLookupDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\twGetLU=new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"DatabaseLookupDialog.GetLookupFields.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wGet, wGetLU, wCancel }, margin, null);\n\n\t\t// OderBy line\n\t\twlOrderBy=new Label(shell, SWT.RIGHT);\n\t\twlOrderBy.setText(Messages.getString(\"DatabaseLookupDialog.Orderby.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlOrderBy);\n\t\tfdlOrderBy=new FormData();\n\t\tfdlOrderBy.left   = new FormAttachment(0, 0);\n\t\tfdlOrderBy.right  = new FormAttachment(middle, -margin);\n\t\tfdlOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\twlOrderBy.setLayoutData(fdlOrderBy);\n\t\twOrderBy=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wOrderBy);\n\t\tfdOrderBy=new FormData();\n\t\tfdOrderBy.left   = new FormAttachment(middle, 0);\n\t\tfdOrderBy.bottom = new FormAttachment(wOK, -2*margin);\n\t\tfdOrderBy.right  = new FormAttachment(100, 0);\n\t\twOrderBy.setLayoutData(fdOrderBy);\n\n        // FailMultiple?\n        wlFailMultiple=new Label(shell, SWT.RIGHT);\n        wlFailMultiple.setText(Messages.getString(\"DatabaseLookupDialog.FailMultiple.Label\")); //$NON-NLS-1$\n        props.setLook(wlFailMultiple);\n        fdlFailMultiple=new FormData();\n        fdlFailMultiple.left   = new FormAttachment(0, 0);\n        fdlFailMultiple.right  = new FormAttachment(middle, -margin);\n        fdlFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wlFailMultiple.setLayoutData(fdlFailMultiple);\n        wFailMultiple=new Button(shell, SWT.CHECK);\n        props.setLook(wFailMultiple);\n        fdFailMultiple=new FormData();\n        fdFailMultiple.left   = new FormAttachment(middle, 0);\n        fdFailMultiple.bottom = new FormAttachment(wOrderBy, -margin);\n        wFailMultiple.setLayoutData(fdFailMultiple);\n        wFailMultiple.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    setFlags();\n                }\n            }\n        );\n\n        // EatRows?\n        wlEatRows=new Label(shell, SWT.RIGHT);\n        wlEatRows.setText(Messages.getString(\"DatabaseLookupDialog.EatRows.Label\")); //$NON-NLS-1$\n        props.setLook(wlEatRows);\n        fdlEatRows=new FormData();\n        fdlEatRows.left   = new FormAttachment(0, 0);\n        fdlEatRows.right  = new FormAttachment(middle, -margin);\n        fdlEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wlEatRows.setLayoutData(fdlEatRows);\n        wEatRows=new Button(shell, SWT.CHECK);\n        props.setLook(wEatRows);\n        fdEatRows=new FormData();\n        fdEatRows.left   = new FormAttachment(middle, 0);\n        fdEatRows.bottom = new FormAttachment(wFailMultiple, -margin);\n        wEatRows.setLayoutData(fdEatRows);\n        wEatRows.addSelectionListener(new SelectionAdapter()\n            {\n                public void widgetSelected(SelectionEvent e)\n                {\n                    setFlags();\n                }\n            }\n        );\n\n        \n        // THE UPDATE/INSERT TABLE\n        wlReturn=new Label(shell, SWT.NONE);\n        wlReturn.setText(Messages.getString(\"DatabaseLookupDialog.Return.Label\")); //$NON-NLS-1$\n        props.setLook(wlReturn);\n        fdlReturn=new FormData();\n        fdlReturn.left  = new FormAttachment(0, 0);\n        fdlReturn.top   = new FormAttachment(wKey, margin);\n        wlReturn.setLayoutData(fdlReturn);\n        \n        int UpInsCols=4;\n        int UpInsRows= (input.getReturnValueField()!=null?input.getReturnValueField().length:1);\n        \n        ColumnInfo[] ciReturn=new ColumnInfo[UpInsCols];\n        ciReturn[0]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Field\"),    ColumnInfo.COLUMN_TYPE_CCOMBO,new String[]{},  false); //$NON-NLS-1$\n        ciReturn[1]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Newname\"), ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[2]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Default\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n        ciReturn[3]=new ColumnInfo(Messages.getString(\"DatabaseLookupDialog.ColumnInfo.Type\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes()); //$NON-NLS-1$\n        tableFieldColumns.add(ciReturn[0]);\n        \n        wReturn=new TableView(transMeta, shell, \n                              SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n                              ciReturn, \n                              UpInsRows,  \n                              lsMod,\n                              props\n                              );\n\n        fdReturn=new FormData();\n        fdReturn.left  = new FormAttachment(0, 0);\n        fdReturn.top   = new FormAttachment(wlReturn, margin);\n        fdReturn.right = new FormAttachment(100, 0);\n        fdReturn.bottom= new FormAttachment(wEatRows, -margin);\n        wReturn.setLayoutData(fdReturn);\n\n\n        \n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsGetLU    = new Listener() { public void handleEvent(Event e) { getlookup(); } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twGetLU.addListener (SWT.Selection, lsGetLU );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twTable.addSelectionListener( lsDef );\n\t\twOrderBy.addSelectionListener( lsDef );\n\t\twCachesize.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\t\t\n\t\tgetData();\n\t\tinput.setChanged(backupChanged);\n\n\t\tsetComboValues();\n\t\tsetTableFieldCombo();\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"2fa648c0139f391707f6d710be70a52819787088","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(InsertUpdateMeta)smi;\n\t\tdata=(InsertUpdateData)sdi;\n\t\t\n\t\tboolean sendToErrorRow=false;\n\t\tString errorMessage = null;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)          // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            data.outputRowMeta = (RowMetaInterface)getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTableName());\n            \n            // lookup the values!\n            if (log.isDebug()) logDebug(Messages.getString(\"InsertUpdate.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs  = new int[meta.getKeyStream().length];\n            data.keynrs2 = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"InsertUpdate.Exception.FieldRequired\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getKeyStream2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"InsertUpdate.Exception.FieldRequired\",meta.getKeyStream2()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                \n                if (log.isDebug()) logDebug(Messages.getString(\"InsertUpdate.Log.FieldHasDataNumbers\",meta.getKeyStream()[i])+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            // Cache the position of the compare fields in Row row\n            //\n            data.valuenrs = new int[meta.getUpdateLookup().length];\n            for (int i=0;i<meta.getUpdateLookup().length;i++)\n            {\n                data.valuenrs[i]=getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\n                if (data.valuenrs[i]<0)  // couldn't find field!\n                {\n                    throw new KettleStepException(Messages.getString(\"InsertUpdate.Exception.FieldRequired\",meta.getUpdateStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                if (log.isDebug()) logDebug(Messages.getString(\"InsertUpdate.Log.FieldHasDataNumbers\",meta.getUpdateStream()[i])+data.valuenrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            setLookup(getInputRowMeta());\n            \n            data.insertRowMeta = new RowMeta();\n            \n            // Insert the update fields: just names.  Type doesn't matter!\n            for (int i=0;i<meta.getUpdateLookup().length;i++) \n            {\n                ValueMetaInterface insValue = data.insertRowMeta.searchValueMeta( meta.getUpdateLookup()[i]); \n                if (insValue==null) // Don't add twice!\n                {\n                    // we already checked that this value exists so it's probably safe to ignore lookup failure...\n                    ValueMetaInterface insertValue = (ValueMetaInterface) getInputRowMeta().searchValueMeta( meta.getUpdateStream()[i] ).clone();\n                    insertValue.setName(meta.getUpdateLookup()[i]);\n                    data.insertRowMeta.addValueMeta( insertValue );\n                }\n                else\n                {\n                    throw new KettleStepException(\"The same column can't be inserted into the target row twice: \"+insValue.getName()); // TODO i18n\n                }\n            }\n            data.db.prepareInsert(data.insertRowMeta, meta.getSchemaName(), meta.getTableName());\n            \n            if (!meta.isUpdateBypassed())\n            {\n                List<String> updateColumns = new ArrayList<String>();\n                for(int i=0;i<meta.getUpdate().length;i++) {\n                    if(meta.getUpdate()[i].booleanValue()) {\n                        updateColumns.add(meta.getUpdateLookup()[i]);\n                    }\n                }\n                prepareUpdate(getInputRowMeta());\n            }\n        }\n\n\t\t    \n\t\ttry\n\t\t{\n\t\t\tlookupValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n            putRow(data.outputRowMeta, r);      // Nothing changed to the input, return the same row, pass a \"cloned\" metadata row.\n\t\t\t\n\t\t\tif (checkFeedback(linesRead)) logBasic(Messages.getString(\"InsertUpdate.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tif (getStepMeta().isDoingErrorHandling())\n\t        {\n                sendToErrorRow = true;\n                errorMessage = e.toString();\n\t        }\n\t        else\n\t        {\n\t\t\t\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"InsertUpdate.Log.ErrorInStep\"), e); //$NON-NLS-1$\n\t        }\n\t\t\t \n\t\t\t if (sendToErrorRow)\n\t         {\n\t\t\t\t // Simply add this row to the error row\n\t             putError(getInputRowMeta(), r, 1, errorMessage, null, \"TOP001\");\n\t         }\n\t\t}\n\t\n\t\treturn true;\n\t}","id":47305,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(InsertUpdateMeta)smi;\n\t\tdata=(InsertUpdateData)sdi;\n\t\t\n\t\tboolean sendToErrorRow=false;\n\t\tString errorMessage = null;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)          // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            data.outputRowMeta = (RowMetaInterface)getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(environmentSubstitute(meta.getSchemaName()), \n            \t\t                                                                  environmentSubstitute(meta.getTableName()));\n            \n            // lookup the values!\n            if (log.isDebug()) logDebug(Messages.getString(\"InsertUpdate.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs  = new int[meta.getKeyStream().length];\n            data.keynrs2 = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"InsertUpdate.Exception.FieldRequired\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getKeyStream2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"InsertUpdate.Exception.FieldRequired\",meta.getKeyStream2()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                \n                if (log.isDebug()) logDebug(Messages.getString(\"InsertUpdate.Log.FieldHasDataNumbers\",meta.getKeyStream()[i])+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            // Cache the position of the compare fields in Row row\n            //\n            data.valuenrs = new int[meta.getUpdateLookup().length];\n            for (int i=0;i<meta.getUpdateLookup().length;i++)\n            {\n                data.valuenrs[i]=getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\n                if (data.valuenrs[i]<0)  // couldn't find field!\n                {\n                    throw new KettleStepException(Messages.getString(\"InsertUpdate.Exception.FieldRequired\",meta.getUpdateStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                if (log.isDebug()) logDebug(Messages.getString(\"InsertUpdate.Log.FieldHasDataNumbers\",meta.getUpdateStream()[i])+data.valuenrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            setLookup(getInputRowMeta());\n            \n            data.insertRowMeta = new RowMeta();\n            \n            // Insert the update fields: just names.  Type doesn't matter!\n            for (int i=0;i<meta.getUpdateLookup().length;i++) \n            {\n                ValueMetaInterface insValue = data.insertRowMeta.searchValueMeta( meta.getUpdateLookup()[i]); \n                if (insValue==null) // Don't add twice!\n                {\n                    // we already checked that this value exists so it's probably safe to ignore lookup failure...\n                    ValueMetaInterface insertValue = (ValueMetaInterface) getInputRowMeta().searchValueMeta( meta.getUpdateStream()[i] ).clone();\n                    insertValue.setName(meta.getUpdateLookup()[i]);\n                    data.insertRowMeta.addValueMeta( insertValue );\n                }\n                else\n                {\n                    throw new KettleStepException(\"The same column can't be inserted into the target row twice: \"+insValue.getName()); // TODO i18n\n                }\n            }\n            data.db.prepareInsert(data.insertRowMeta, environmentSubstitute(meta.getSchemaName()), \n            \t\t                                  environmentSubstitute(meta.getTableName()));\n            \n            if (!meta.isUpdateBypassed())\n            {\n                List<String> updateColumns = new ArrayList<String>();\n                for(int i=0;i<meta.getUpdate().length;i++) {\n                    if(meta.getUpdate()[i].booleanValue()) {\n                        updateColumns.add(meta.getUpdateLookup()[i]);\n                    }\n                }\n                prepareUpdate(getInputRowMeta());\n            }\n        }\n\n\t\t    \n\t\ttry\n\t\t{\n\t\t\tlookupValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n            putRow(data.outputRowMeta, r);      // Nothing changed to the input, return the same row, pass a \"cloned\" metadata row.\n\t\t\t\n\t\t\tif (checkFeedback(linesRead)) logBasic(Messages.getString(\"InsertUpdate.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tif (getStepMeta().isDoingErrorHandling())\n\t        {\n                sendToErrorRow = true;\n                errorMessage = e.toString();\n\t        }\n\t        else\n\t        {\n\t\t\t\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"InsertUpdate.Log.ErrorInStep\"), e); //$NON-NLS-1$\n\t        }\n\t\t\t \n\t\t\t if (sendToErrorRow)\n\t         {\n\t\t\t\t // Simply add this row to the error row\n\t             putError(getInputRowMeta(), r, 1, errorMessage, null, \"TOP001\");\n\t         }\n\t\t}\n\t\n\t\treturn true;\n\t}","commit_id":"2fa648c0139f391707f6d710be70a52819787088","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"InsertUpdateDialog.Shell.Title\")); //$NON-NLS-1$\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname = new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"InsertUpdateDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname = new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\n\t\tfdlStepname.top = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname = new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top = new FormAttachment(0, margin);\n\t\tfdStepname.right = new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"InsertUpdateDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable = new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"InsertUpdateDialog.TargetTable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable = new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right = new FormAttachment(middle, -margin);\n\t\tfdlTable.top = new FormAttachment(wSchema, margin);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable = new Button(shell, SWT.PUSH | SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"InsertUpdateDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable = new FormData();\n\t\tfdbTable.right = new FormAttachment(100, 0);\n\t\tfdbTable.top = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable = new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top = new FormAttachment(wSchema, margin);\n\t\tfdTable.right = new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Commit line\n\t\twlCommit = new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"InsertUpdateDialog.CommitSize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit = new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.top = new FormAttachment(wTable, margin);\n\t\tfdlCommit.right = new FormAttachment(middle, -margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit = new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top = new FormAttachment(wTable, margin);\n\t\tfdCommit.right = new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n\n\t\t// UpdateBypassed line\n\t\twlUpdateBypassed = new Label(shell, SWT.RIGHT);\n\t\twlUpdateBypassed.setText(Messages.getString(\"InsertUpdateDialog.UpdateBypassed.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlUpdateBypassed);\n\t\tfdlUpdateBypassed = new FormData();\n\t\tfdlUpdateBypassed.left = new FormAttachment(0, 0);\n\t\tfdlUpdateBypassed.top = new FormAttachment(wCommit, margin);\n\t\tfdlUpdateBypassed.right = new FormAttachment(middle, -margin);\n\t\twlUpdateBypassed.setLayoutData(fdlUpdateBypassed);\n\t\twUpdateBypassed = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wUpdateBypassed);\n\t\tfdUpdateBypassed = new FormData();\n\t\tfdUpdateBypassed.left = new FormAttachment(middle, 0);\n\t\tfdUpdateBypassed.top = new FormAttachment(wCommit, margin);\n\t\tfdUpdateBypassed.right = new FormAttachment(100, 0);\n\t\twUpdateBypassed.setLayoutData(fdUpdateBypassed);\n\n\t\twlKey = new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"InsertUpdateDialog.Keys.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey = new FormData();\n\t\tfdlKey.left = new FormAttachment(0, 0);\n\t\tfdlKey.top = new FormAttachment(wUpdateBypassed, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols = 4;\n\t\tint nrKeyRows = (input.getKeyStream() != null ? input.getKeyStream().length : 1);\n\n\t\tColumnInfo[] ciKey = new ColumnInfo[nrKeyCols];\n\t\tciKey[0] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.TableField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciKey[1] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.Comparator\"), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$\n\t\t\t\t\">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\tciKey[2] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.StreamField1\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciKey[3] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.StreamField2\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\n\t\twKey = new TableView(transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, ciKey,\n\t\t\t\tnrKeyRows, lsMod, props);\n\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"InsertUpdateDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\tfdGet = new FormData();\n\t\tfdGet.right = new FormAttachment(100, 0);\n\t\tfdGet.top = new FormAttachment(wlKey, margin);\n\t\twGet.setLayoutData(fdGet);\n\n\t\tfdKey = new FormData();\n\t\tfdKey.left = new FormAttachment(0, 0);\n\t\tfdKey.top = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(wGet, -margin);\n\t\tfdKey.bottom = new FormAttachment(wlKey, 190);\n\t\twKey.setLayoutData(fdKey);\n\n\n\t\t// THE BUTTONS\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twSQL = new Button(shell, SWT.PUSH);\n\t\twSQL.setText(Messages.getString(\"InsertUpdateDialog.SQL.Button\")); //$NON-NLS-1$\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wSQL, wCancel }, margin, null);\n\n\t\t\n\t\t// THE UPDATE/INSERT TABLE\n\t\twlReturn = new Label(shell, SWT.NONE);\n\t\twlReturn.setText(Messages.getString(\"InsertUpdateDialog.UpdateFields.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlReturn);\n\t\tfdlReturn = new FormData();\n\t\tfdlReturn.left = new FormAttachment(0, 0);\n\t\tfdlReturn.top = new FormAttachment(wKey, margin);\n\t\twlReturn.setLayoutData(fdlReturn);\n\n\t\tint UpInsCols = 3;\n\t\tint UpInsRows = (input.getUpdateLookup() != null ? input.getUpdateLookup().length : 1);\n\n\t\tColumnInfo[] ciReturn = new ColumnInfo[UpInsCols];\n\t\tciReturn[0] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.TableField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciReturn[1] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.StreamField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciReturn[2] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.Update\"), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] {\"Y\",\"N\"}); //$NON-NLS-1$\n\n\t\twReturn = new TableView(transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL,\n\t\t\t\tciReturn, UpInsRows, lsMod, props);\n\n\t\twGetLU = new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"InsertUpdateDialog.GetAndUpdateFields.Label\")); //$NON-NLS-1$\n\t\tfdGetLU = new FormData();\n\t\tfdGetLU.top   = new FormAttachment(wlReturn, margin);\n\t\tfdGetLU.right = new FormAttachment(100, 0);\n\t\twGetLU.setLayoutData(fdGetLU);\n\n\t\tfdReturn = new FormData();\n\t\tfdReturn.left = new FormAttachment(0, 0);\n\t\tfdReturn.top = new FormAttachment(wlReturn, margin);\n\t\tfdReturn.right = new FormAttachment(wGetLU, -margin);\n\t\tfdReturn.bottom = new FormAttachment(wOK, -2*margin);\n\t\twReturn.setLayoutData(fdReturn);\n\t\t\n\t\t// Add listeners\n\t\tlsOK = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\t\tlsGet = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tget();\n\t\t\t}\n\t\t};\n\t\tlsGetLU = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tgetUpdate();\n\t\t\t}\n\t\t};\n\t\tlsSQL = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcreate();\n\t\t\t}\n\t\t};\n\t\tlsCancel = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\n\t\twOK.addListener(SWT.Selection, lsOK);\n\t\twGet.addListener(SWT.Selection, lsGet);\n\t\twGetLU.addListener(SWT.Selection, lsGetLU);\n\t\twSQL.addListener(SWT.Selection, lsSQL);\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\n\t\tlsDef = new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twStepname.addSelectionListener(lsDef);\n        wSchema.addSelectionListener(lsDef);\n        wTable.addSelectionListener(lsDef);\n        wCommit.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter()\n\t\t{\n\t\t\tpublic void shellClosed(ShellEvent e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\n\t\twbTable.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tgetTableName();\n\t\t\t}\n\t\t});\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":47306,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout();\n\t\tformLayout.marginWidth = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"InsertUpdateDialog.Shell.Title\")); //$NON-NLS-1$\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname = new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"InsertUpdateDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname = new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\n\t\tfdlStepname.top = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname = new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top = new FormAttachment(0, margin);\n\t\tfdStepname.right = new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"InsertUpdateDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable = new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"InsertUpdateDialog.TargetTable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable = new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right = new FormAttachment(middle, -margin);\n\t\tfdlTable.top = new FormAttachment(wSchema, margin);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable = new Button(shell, SWT.PUSH | SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"InsertUpdateDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable = new FormData();\n\t\tfdbTable.right = new FormAttachment(100, 0);\n\t\tfdbTable.top = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable = new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top = new FormAttachment(wSchema, margin);\n\t\tfdTable.right = new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Commit line\n\t\twlCommit = new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"InsertUpdateDialog.CommitSize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit = new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.top = new FormAttachment(wTable, margin);\n\t\tfdlCommit.right = new FormAttachment(middle, -margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit = new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top = new FormAttachment(wTable, margin);\n\t\tfdCommit.right = new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n\n\t\t// UpdateBypassed line\n\t\twlUpdateBypassed = new Label(shell, SWT.RIGHT);\n\t\twlUpdateBypassed.setText(Messages.getString(\"InsertUpdateDialog.UpdateBypassed.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlUpdateBypassed);\n\t\tfdlUpdateBypassed = new FormData();\n\t\tfdlUpdateBypassed.left = new FormAttachment(0, 0);\n\t\tfdlUpdateBypassed.top = new FormAttachment(wCommit, margin);\n\t\tfdlUpdateBypassed.right = new FormAttachment(middle, -margin);\n\t\twlUpdateBypassed.setLayoutData(fdlUpdateBypassed);\n\t\twUpdateBypassed = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wUpdateBypassed);\n\t\tfdUpdateBypassed = new FormData();\n\t\tfdUpdateBypassed.left = new FormAttachment(middle, 0);\n\t\tfdUpdateBypassed.top = new FormAttachment(wCommit, margin);\n\t\tfdUpdateBypassed.right = new FormAttachment(100, 0);\n\t\twUpdateBypassed.setLayoutData(fdUpdateBypassed);\n\n\t\twlKey = new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"InsertUpdateDialog.Keys.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey = new FormData();\n\t\tfdlKey.left = new FormAttachment(0, 0);\n\t\tfdlKey.top = new FormAttachment(wUpdateBypassed, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols = 4;\n\t\tint nrKeyRows = (input.getKeyStream() != null ? input.getKeyStream().length : 1);\n\n\t\tColumnInfo[] ciKey = new ColumnInfo[nrKeyCols];\n\t\tciKey[0] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.TableField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciKey[1] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.Comparator\"), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$\n\t\t\t\t\">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\tciKey[2] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.StreamField1\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciKey[3] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.StreamField2\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\n\t\twKey = new TableView(transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, ciKey,\n\t\t\t\tnrKeyRows, lsMod, props);\n\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"InsertUpdateDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\tfdGet = new FormData();\n\t\tfdGet.right = new FormAttachment(100, 0);\n\t\tfdGet.top = new FormAttachment(wlKey, margin);\n\t\twGet.setLayoutData(fdGet);\n\n\t\tfdKey = new FormData();\n\t\tfdKey.left = new FormAttachment(0, 0);\n\t\tfdKey.top = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(wGet, -margin);\n\t\tfdKey.bottom = new FormAttachment(wlKey, 190);\n\t\twKey.setLayoutData(fdKey);\n\n\n\t\t// THE BUTTONS\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twSQL = new Button(shell, SWT.PUSH);\n\t\twSQL.setText(Messages.getString(\"InsertUpdateDialog.SQL.Button\")); //$NON-NLS-1$\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wSQL, wCancel }, margin, null);\n\n\t\t\n\t\t// THE UPDATE/INSERT TABLE\n\t\twlReturn = new Label(shell, SWT.NONE);\n\t\twlReturn.setText(Messages.getString(\"InsertUpdateDialog.UpdateFields.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlReturn);\n\t\tfdlReturn = new FormData();\n\t\tfdlReturn.left = new FormAttachment(0, 0);\n\t\tfdlReturn.top = new FormAttachment(wKey, margin);\n\t\twlReturn.setLayoutData(fdlReturn);\n\n\t\tint UpInsCols = 3;\n\t\tint UpInsRows = (input.getUpdateLookup() != null ? input.getUpdateLookup().length : 1);\n\n\t\tColumnInfo[] ciReturn = new ColumnInfo[UpInsCols];\n\t\tciReturn[0] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.TableField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciReturn[1] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.StreamField\"), ColumnInfo.COLUMN_TYPE_TEXT, false); //$NON-NLS-1$\n\t\tciReturn[2] = new ColumnInfo(Messages.getString(\"InsertUpdateDialog.ColumnInfo.Update\"), ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] {\"Y\",\"N\"}); //$NON-NLS-1$\n\n\t\twReturn = new TableView(transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL,\n\t\t\t\tciReturn, UpInsRows, lsMod, props);\n\n\t\twGetLU = new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"InsertUpdateDialog.GetAndUpdateFields.Label\")); //$NON-NLS-1$\n\t\tfdGetLU = new FormData();\n\t\tfdGetLU.top   = new FormAttachment(wlReturn, margin);\n\t\tfdGetLU.right = new FormAttachment(100, 0);\n\t\twGetLU.setLayoutData(fdGetLU);\n\n\t\tfdReturn = new FormData();\n\t\tfdReturn.left = new FormAttachment(0, 0);\n\t\tfdReturn.top = new FormAttachment(wlReturn, margin);\n\t\tfdReturn.right = new FormAttachment(wGetLU, -margin);\n\t\tfdReturn.bottom = new FormAttachment(wOK, -2*margin);\n\t\twReturn.setLayoutData(fdReturn);\n\t\t\n\t\t// Add listeners\n\t\tlsOK = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\t\tlsGet = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tget();\n\t\t\t}\n\t\t};\n\t\tlsGetLU = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tgetUpdate();\n\t\t\t}\n\t\t};\n\t\tlsSQL = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcreate();\n\t\t\t}\n\t\t};\n\t\tlsCancel = new Listener()\n\t\t{\n\t\t\tpublic void handleEvent(Event e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\n\t\twOK.addListener(SWT.Selection, lsOK);\n\t\twGet.addListener(SWT.Selection, lsGet);\n\t\twGetLU.addListener(SWT.Selection, lsGetLU);\n\t\twSQL.addListener(SWT.Selection, lsSQL);\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\n\t\tlsDef = new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twStepname.addSelectionListener(lsDef);\n        wSchema.addSelectionListener(lsDef);\n        wTable.addSelectionListener(lsDef);\n        wCommit.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter()\n\t\t{\n\t\t\tpublic void shellClosed(ShellEvent e)\n\t\t\t{\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\n\t\twbTable.addSelectionListener(new SelectionAdapter()\n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t{\n\t\t\t\tgetTableName();\n\t\t\t}\n\t\t});\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\tif (!display.readAndDispatch())\n\t\t\t\tdisplay.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"2fa648c0139f391707f6d710be70a52819787088","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(UpdateMeta)smi;\n\t\tdata=(UpdateData)sdi;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            // What's the output Row format?\n            data.outputRowMeta = (RowMetaInterface)getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTableName());\n                        \n            // lookup the values!\n            if (log.isDetailed()) logDetailed(Messages.getString(\"Update.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs  = new int[meta.getKeyStream().length];\n            data.keynrs2 = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Update.Exception.FieldRequired\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getKeyStream2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Update.Exception.FieldRequired\",meta.getKeyStream2()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                \n                if (log.isDebug()) logDebug(Messages.getString(\"Update.Log.FieldHasDataNumbers\",meta.getKeyStream()[i])+\"\"+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            // Cache the position of the compare fields in Row row\n            //\n            data.valuenrs = new int[meta.getUpdateLookup().length];\n            for (int i=0;i<meta.getUpdateLookup().length;i++)\n            {\n                data.valuenrs[i]=getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\n                if (data.valuenrs[i]<0)  // couldn't find field!\n                {\n                    throw new KettleStepException(Messages.getString(\"Update.Exception.FieldRequired\",meta.getUpdateStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                if (log.isDebug()) logDebug(Messages.getString(\"Update.Log.FieldHasDataNumbers\",meta.getUpdateStream()[i])+\"\"+data.valuenrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            setLookup(getInputRowMeta());\n            prepareUpdate(getInputRowMeta());\n        }\n            \n\t\tObject[] outputRow = lookupValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n        if (outputRow!=null) putRow(data.outputRowMeta, outputRow); // copy non-ignored rows to output rowset(s);\n        if (checkFeedback(linesRead)) logBasic(Messages.getString(\"Update.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t\t\n\t\treturn true;\n\t}","id":47307,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(UpdateMeta)smi;\n\t\tdata=(UpdateData)sdi;\n\n\t\tObject[] r=getRow();       // Get row from input rowset & set row busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n        \n        if (first)\n        {\n            first=false;\n            \n            // What's the output Row format?\n            data.outputRowMeta = (RowMetaInterface)getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n            \n            data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(environmentSubstitute(meta.getSchemaName()), \n            \t\t                                                                  environmentSubstitute(meta.getTableName()));\n                        \n            // lookup the values!\n            if (log.isDetailed()) logDetailed(Messages.getString(\"Update.Log.CheckingRow\")+getInputRowMeta().getString(r)); //$NON-NLS-1$\n            \n            data.keynrs  = new int[meta.getKeyStream().length];\n            data.keynrs2 = new int[meta.getKeyStream().length];\n            for (int i=0;i<meta.getKeyStream().length;i++)\n            {\n                data.keynrs[i]=getInputRowMeta().indexOfValue(meta.getKeyStream()[i]);\n                if (data.keynrs[i]<0 &&  // couldn't find field!\n                    !\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) &&   // No field needed! //$NON-NLS-1$\n                    !\"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i])  // No field needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Update.Exception.FieldRequired\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                data.keynrs2[i]=getInputRowMeta().indexOfValue(meta.getKeyStream2()[i]);\n                if (data.keynrs2[i]<0 &&  // couldn't find field!\n                    \"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i])   // 2 fields needed! //$NON-NLS-1$\n                   )\n                {\n                    throw new KettleStepException(Messages.getString(\"Update.Exception.FieldRequired\",meta.getKeyStream2()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                \n                if (log.isDebug()) logDebug(Messages.getString(\"Update.Log.FieldHasDataNumbers\",meta.getKeyStream()[i])+\"\"+data.keynrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            // Cache the position of the compare fields in Row row\n            //\n            data.valuenrs = new int[meta.getUpdateLookup().length];\n            for (int i=0;i<meta.getUpdateLookup().length;i++)\n            {\n                data.valuenrs[i]=getInputRowMeta().indexOfValue(meta.getUpdateStream()[i]);\n                if (data.valuenrs[i]<0)  // couldn't find field!\n                {\n                    throw new KettleStepException(Messages.getString(\"Update.Exception.FieldRequired\",meta.getUpdateStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n                }\n                if (log.isDebug()) logDebug(Messages.getString(\"Update.Log.FieldHasDataNumbers\",meta.getUpdateStream()[i])+\"\"+data.valuenrs[i]); //$NON-NLS-1$ //$NON-NLS-2$\n            }\n            \n            setLookup(getInputRowMeta());\n            prepareUpdate(getInputRowMeta());\n        }\n            \n\t\tObject[] outputRow = lookupValues(getInputRowMeta(), r); // add new values to the row in rowset[0].\n        if (outputRow!=null) putRow(data.outputRowMeta, outputRow); // copy non-ignored rows to output rowset(s);\n        if (checkFeedback(linesRead)) logBasic(Messages.getString(\"Update.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"2fa648c0139f391707f6d710be70a52819787088","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"UpdateDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"UpdateDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\t\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"UpdateDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"UpdateDialog.TargetTable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"UpdateDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Commit line\n\t\twlCommit = new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"UpdateDialog..Commit.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit = new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.top = new FormAttachment(wTable, margin);\n\t\tfdlCommit.right = new FormAttachment(middle, -margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit = new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top = new FormAttachment(wTable, margin);\n\t\tfdCommit.right = new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n        \n        \n        wlErrorIgnored=new Label(shell, SWT.RIGHT);\n        wlErrorIgnored.setText(Messages.getString(\"UpdateDialog.ErrorIgnored.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(        wlErrorIgnored);\n        fdlErrorIgnored=new FormData();\n        fdlErrorIgnored.left = new FormAttachment(0, 0);\n        fdlErrorIgnored.top  = new FormAttachment(wCommit, margin);\n        fdlErrorIgnored.right= new FormAttachment(middle, -margin);\n        wlErrorIgnored.setLayoutData(fdlErrorIgnored);\n        \n        wErrorIgnored=new Button(shell, SWT.CHECK );\n \t\tprops.setLook(        wErrorIgnored);\n        wErrorIgnored.setToolTipText(Messages.getString(\"UpdateDialog.ErrorIgnored.ToolTip\")); //$NON-NLS-1$\n        fdErrorIgnored=new FormData();\n        fdErrorIgnored.left = new FormAttachment(middle, 0);\n        fdErrorIgnored.top  = new FormAttachment(wCommit, margin);\n        wErrorIgnored.setLayoutData(fdErrorIgnored);\n        wErrorIgnored.addSelectionListener(new SelectionAdapter() \n            {\n                public void widgetSelected(SelectionEvent e) \n                {\n                    input.setChanged();\n                    setFlags();\n                }\n            }\n        );\n\n        wlIgnoreFlagField=new Label(shell, SWT.LEFT);\n        wlIgnoreFlagField.setText(Messages.getString(\"UpdateDialog.FlagField.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(        wlIgnoreFlagField);\n        fdlIgnoreFlagField=new FormData();\n        fdlIgnoreFlagField.left = new FormAttachment(wErrorIgnored, margin);\n        fdlIgnoreFlagField.top  = new FormAttachment(wCommit, margin);\n        wlIgnoreFlagField.setLayoutData(fdlIgnoreFlagField);\n        wIgnoreFlagField=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(        wIgnoreFlagField);\n        wIgnoreFlagField.addModifyListener(lsMod);\n        fdIgnoreFlagField=new FormData();\n        fdIgnoreFlagField.left = new FormAttachment(wlIgnoreFlagField, margin);\n        fdIgnoreFlagField.top  = new FormAttachment(wCommit, margin);\n        fdIgnoreFlagField.right= new FormAttachment(100, 0);\n        wIgnoreFlagField.setLayoutData(fdIgnoreFlagField);\n\n\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"UpdateDialog.Key.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wIgnoreFlagField, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getKeyStream()!=null?input.getKeyStream().length:1);\n\t\t\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.TableField\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.Comparator\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.StreamField1\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.StreamField2\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\t\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t      props\n\t\t\t\t\t\t      );\n\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"UpdateDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\tfdGet = new FormData();\n\t\tfdGet.right = new FormAttachment(100, 0);\n\t\tfdGet.top = new FormAttachment(wlKey, margin);\n\t\twGet.setLayoutData(fdGet);\n\n\t\tfdKey = new FormData();\n\t\tfdKey.left = new FormAttachment(0, 0);\n\t\tfdKey.top = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(wGet, -margin);\n\t\tfdKey.bottom = new FormAttachment(wlKey, 190);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twSQL=new Button(shell, SWT.PUSH);\n\t\twSQL.setText(Messages.getString(\"UpdateDialog.SQL.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wSQL, wCancel }, margin, null);\n\n\t\t\n\t\t// THE UPDATE/INSERT TABLE\n\t\twlReturn=new Label(shell, SWT.NONE);\n\t\twlReturn.setText(Messages.getString(\"UpdateDialog.Return.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlReturn);\n\t\tfdlReturn=new FormData();\n\t\tfdlReturn.left  = new FormAttachment(0, 0);\n\t\tfdlReturn.top   = new FormAttachment(wKey, margin);\n\t\twlReturn.setLayoutData(fdlReturn);\n\t\t\n\t\tint UpInsCols=2;\n\t\tint UpInsRows= (input.getUpdateLookup()!=null?input.getUpdateLookup().length:1);\n\t\t\n\t\tColumnInfo[] ciReturn=new ColumnInfo[UpInsCols];\n\t\tciReturn[0]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.TableField\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciReturn[1]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.StreamField\"), ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\t\n\t\twReturn=new TableView(transMeta, shell, \n\t\t\t\t\t\t\t  SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t\t  ciReturn, \n\t\t\t\t\t\t\t  UpInsRows,  \n\t\t\t\t\t\t\t  lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t\t  );\n\n\t\twGetLU = new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"UpdateDialog.GetAndUpdateFields\")); //$NON-NLS-1$\n\t\tfdGetLU = new FormData();\n\t\tfdGetLU.top   = new FormAttachment(wlReturn, margin);\n\t\tfdGetLU.right = new FormAttachment(100, 0);\n\t\twGetLU.setLayoutData(fdGetLU);\n\n\t\tfdReturn = new FormData();\n\t\tfdReturn.left = new FormAttachment(0, 0);\n\t\tfdReturn.top = new FormAttachment(wlReturn, margin);\n\t\tfdReturn.right = new FormAttachment(wGetLU, -margin);\n\t\tfdReturn.bottom = new FormAttachment(wOK, -2*margin);\n\t\twReturn.setLayoutData(fdReturn);\n\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsGetLU    = new Listener() { public void handleEvent(Event e) { getUpdate(); } };\n\t\tlsSQL      = new Listener() { public void handleEvent(Event e) { create();    } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twGetLU.addListener (SWT.Selection, lsGetLU );\n\t\twSQL.addListener   (SWT.Selection, lsSQL   );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n        wStepname.addSelectionListener( lsDef );\n        wSchema.addSelectionListener( lsDef );\n        wTable.addSelectionListener( lsDef );\n        wCommit.addSelectionListener( lsDef );\n\t\twIgnoreFlagField.addSelectionListener( lsDef );\n        \n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":47308,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"UpdateDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"UpdateDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Connection line\n\t\twConnection = addConnectionLine(shell, wStepname, middle, margin);\n\t\tif (input.getDatabaseMeta()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\t\t\n        // Schema line...\n        wlSchema=new Label(shell, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"UpdateDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        fdlSchema=new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin*2);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        fdSchema=new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin*2);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\t\t// Table line...\n\t\twlTable=new Label(shell, SWT.RIGHT);\n\t\twlTable.setText(Messages.getString(\"UpdateDialog.TargetTable.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTable);\n\t\tfdlTable=new FormData();\n\t\tfdlTable.left = new FormAttachment(0, 0);\n\t\tfdlTable.right= new FormAttachment(middle, -margin);\n\t\tfdlTable.top  = new FormAttachment(wSchema, margin);\n\t\twlTable.setLayoutData(fdlTable);\n\n\t\twbTable=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbTable);\n\t\twbTable.setText(Messages.getString(\"UpdateDialog.Browse.Button\")); //$NON-NLS-1$\n\t\tfdbTable=new FormData();\n\t\tfdbTable.right= new FormAttachment(100, 0);\n\t\tfdbTable.top  = new FormAttachment(wSchema, margin);\n\t\twbTable.setLayoutData(fdbTable);\n\n\t\twTable=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wTable);\n\t\twTable.addModifyListener(lsMod);\n\t\tfdTable=new FormData();\n\t\tfdTable.left = new FormAttachment(middle, 0);\n\t\tfdTable.top  = new FormAttachment(wSchema, margin);\n\t\tfdTable.right= new FormAttachment(wbTable, -margin);\n\t\twTable.setLayoutData(fdTable);\n\n\t\t// Commit line\n\t\twlCommit = new Label(shell, SWT.RIGHT);\n\t\twlCommit.setText(Messages.getString(\"UpdateDialog..Commit.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCommit);\n\t\tfdlCommit = new FormData();\n\t\tfdlCommit.left = new FormAttachment(0, 0);\n\t\tfdlCommit.top = new FormAttachment(wTable, margin);\n\t\tfdlCommit.right = new FormAttachment(middle, -margin);\n\t\twlCommit.setLayoutData(fdlCommit);\n\t\twCommit = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCommit);\n\t\twCommit.addModifyListener(lsMod);\n\t\tfdCommit = new FormData();\n\t\tfdCommit.left = new FormAttachment(middle, 0);\n\t\tfdCommit.top = new FormAttachment(wTable, margin);\n\t\tfdCommit.right = new FormAttachment(100, 0);\n\t\twCommit.setLayoutData(fdCommit);\n        \n        \n        wlErrorIgnored=new Label(shell, SWT.RIGHT);\n        wlErrorIgnored.setText(Messages.getString(\"UpdateDialog.ErrorIgnored.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(        wlErrorIgnored);\n        fdlErrorIgnored=new FormData();\n        fdlErrorIgnored.left = new FormAttachment(0, 0);\n        fdlErrorIgnored.top  = new FormAttachment(wCommit, margin);\n        fdlErrorIgnored.right= new FormAttachment(middle, -margin);\n        wlErrorIgnored.setLayoutData(fdlErrorIgnored);\n        \n        wErrorIgnored=new Button(shell, SWT.CHECK );\n \t\tprops.setLook(        wErrorIgnored);\n        wErrorIgnored.setToolTipText(Messages.getString(\"UpdateDialog.ErrorIgnored.ToolTip\")); //$NON-NLS-1$\n        fdErrorIgnored=new FormData();\n        fdErrorIgnored.left = new FormAttachment(middle, 0);\n        fdErrorIgnored.top  = new FormAttachment(wCommit, margin);\n        wErrorIgnored.setLayoutData(fdErrorIgnored);\n        wErrorIgnored.addSelectionListener(new SelectionAdapter() \n            {\n                public void widgetSelected(SelectionEvent e) \n                {\n                    input.setChanged();\n                    setFlags();\n                }\n            }\n        );\n\n        wlIgnoreFlagField=new Label(shell, SWT.LEFT);\n        wlIgnoreFlagField.setText(Messages.getString(\"UpdateDialog.FlagField.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(        wlIgnoreFlagField);\n        fdlIgnoreFlagField=new FormData();\n        fdlIgnoreFlagField.left = new FormAttachment(wErrorIgnored, margin);\n        fdlIgnoreFlagField.top  = new FormAttachment(wCommit, margin);\n        wlIgnoreFlagField.setLayoutData(fdlIgnoreFlagField);\n        wIgnoreFlagField=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(        wIgnoreFlagField);\n        wIgnoreFlagField.addModifyListener(lsMod);\n        fdIgnoreFlagField=new FormData();\n        fdIgnoreFlagField.left = new FormAttachment(wlIgnoreFlagField, margin);\n        fdIgnoreFlagField.top  = new FormAttachment(wCommit, margin);\n        fdIgnoreFlagField.right= new FormAttachment(100, 0);\n        wIgnoreFlagField.setLayoutData(fdIgnoreFlagField);\n\n\n\t\twlKey=new Label(shell, SWT.NONE);\n\t\twlKey.setText(Messages.getString(\"UpdateDialog.Key.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlKey);\n\t\tfdlKey=new FormData();\n\t\tfdlKey.left  = new FormAttachment(0, 0);\n\t\tfdlKey.top   = new FormAttachment(wIgnoreFlagField, margin);\n\t\twlKey.setLayoutData(fdlKey);\n\n\t\tint nrKeyCols=4;\n\t\tint nrKeyRows=(input.getKeyStream()!=null?input.getKeyStream().length:1);\n\t\t\n\t\tColumnInfo[] ciKey=new ColumnInfo[nrKeyCols];\n\t\tciKey[0]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.TableField\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[1]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.Comparator\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, new String[] { \"=\", \"<>\", \"<\", \"<=\", \">\", \">=\", \"LIKE\", \"BETWEEN\", \"IS NULL\", \"IS NOT NULL\" } ); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$ //$NON-NLS-7$ //$NON-NLS-8$ //$NON-NLS-9$ //$NON-NLS-10$ //$NON-NLS-11$\n\t\tciKey[2]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.StreamField1\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciKey[3]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.StreamField2\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\t\n\t\twKey=new TableView(transMeta, shell, \n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t      ciKey, \n\t\t\t\t\t\t      nrKeyRows,  \n\t\t\t\t\t\t      lsMod,\n\t\t\t\t\t\t      props\n\t\t\t\t\t\t      );\n\n\t\twGet = new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"UpdateDialog.GetFields.Button\")); //$NON-NLS-1$\n\t\tfdGet = new FormData();\n\t\tfdGet.right = new FormAttachment(100, 0);\n\t\tfdGet.top = new FormAttachment(wlKey, margin);\n\t\twGet.setLayoutData(fdGet);\n\n\t\tfdKey = new FormData();\n\t\tfdKey.left = new FormAttachment(0, 0);\n\t\tfdKey.top = new FormAttachment(wlKey, margin);\n\t\tfdKey.right = new FormAttachment(wGet, -margin);\n\t\tfdKey.bottom = new FormAttachment(wlKey, 190);\n\t\twKey.setLayoutData(fdKey);\n\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twSQL=new Button(shell, SWT.PUSH);\n\t\twSQL.setText(Messages.getString(\"UpdateDialog.SQL.Button\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wSQL, wCancel }, margin, null);\n\n\t\t\n\t\t// THE UPDATE/INSERT TABLE\n\t\twlReturn=new Label(shell, SWT.NONE);\n\t\twlReturn.setText(Messages.getString(\"UpdateDialog.Return.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlReturn);\n\t\tfdlReturn=new FormData();\n\t\tfdlReturn.left  = new FormAttachment(0, 0);\n\t\tfdlReturn.top   = new FormAttachment(wKey, margin);\n\t\twlReturn.setLayoutData(fdlReturn);\n\t\t\n\t\tint UpInsCols=2;\n\t\tint UpInsRows= (input.getUpdateLookup()!=null?input.getUpdateLookup().length:1);\n\t\t\n\t\tColumnInfo[] ciReturn=new ColumnInfo[UpInsCols];\n\t\tciReturn[0]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.TableField\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\tciReturn[1]=new ColumnInfo(Messages.getString(\"UpdateDialog.ColumnInfo.StreamField\"), ColumnInfo.COLUMN_TYPE_TEXT,   false); //$NON-NLS-1$\n\t\t\n\t\twReturn=new TableView(transMeta, shell, \n\t\t\t\t\t\t\t  SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI | SWT.V_SCROLL | SWT.H_SCROLL, \n\t\t\t\t\t\t\t  ciReturn, \n\t\t\t\t\t\t\t  UpInsRows,  \n\t\t\t\t\t\t\t  lsMod,\n\t\t\t\t\t\t\t  props\n\t\t\t\t\t\t\t  );\n\n\t\twGetLU = new Button(shell, SWT.PUSH);\n\t\twGetLU.setText(Messages.getString(\"UpdateDialog.GetAndUpdateFields\")); //$NON-NLS-1$\n\t\tfdGetLU = new FormData();\n\t\tfdGetLU.top   = new FormAttachment(wlReturn, margin);\n\t\tfdGetLU.right = new FormAttachment(100, 0);\n\t\twGetLU.setLayoutData(fdGetLU);\n\n\t\tfdReturn = new FormData();\n\t\tfdReturn.left = new FormAttachment(0, 0);\n\t\tfdReturn.top = new FormAttachment(wlReturn, margin);\n\t\tfdReturn.right = new FormAttachment(wGetLU, -margin);\n\t\tfdReturn.bottom = new FormAttachment(wOK, -2*margin);\n\t\twReturn.setLayoutData(fdReturn);\n\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();       } };\n\t\tlsGetLU    = new Listener() { public void handleEvent(Event e) { getUpdate(); } };\n\t\tlsSQL      = new Listener() { public void handleEvent(Event e) { create();    } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twGet.addListener   (SWT.Selection, lsGet   );\n\t\twGetLU.addListener (SWT.Selection, lsGetLU );\n\t\twSQL.addListener   (SWT.Selection, lsSQL   );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n        wStepname.addSelectionListener( lsDef );\n        wSchema.addSelectionListener( lsDef );\n        wTable.addSelectionListener( lsDef );\n        wCommit.addSelectionListener( lsDef );\n\t\twIgnoreFlagField.addSelectionListener( lsDef );\n        \n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\twbTable.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n\t\t\t\t\tgetTableName();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"2fa648c0139f391707f6d710be70a52819787088","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Object[] addSequence(RowMetaInterface inputRowMeta, Object[] inputRowData) throws KettleException\n\t{\n\t\tObject next = null;\n\t\t\n\t\tif (meta.isCounterUsed()) {\n\t\t\tsynchronized (data.counter) {\n\t\t\t\tlong prev = data.counter.getCounter();\n\t\t\t\t\n\t\t\t\tlong nval = prev + meta.getIncrementBy();\n\t\t\t\tif (meta.getIncrementBy() > 0 && meta.getMaxValue() > meta.getStartAt() && nval > meta.getMaxValue())\n\t\t\t\t\tnval = meta.getStartAt();\n\t\t\t\tif (meta.getIncrementBy() < 0 && meta.getMaxValue() < meta.getStartAt() && nval < meta.getMaxValue())\n\t\t\t\t\tnval = meta.getStartAt();\n\t\t\t\tdata.counter.setCounter(nval);\n\t\n\t\t\t\tnext = prev;\n\t\t\t}\n\t\t} else if (meta.isDatabaseUsed()) {\n\t\t\ttry {\n\t\t\t\tnext = data.getDb().getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getValuename());\n\t\t\t} catch (KettleDatabaseException dbe) {\n\t\t\t\tthrow new KettleStepException(Messages.getString(\n\t\t\t\t\t\t\"AddSequence.Exception.ErrorReadingSequence\", meta.getSequenceName()), dbe); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t} else {\n\t\t\t// This should never happen, but if it does, don't continue!!!\n\t\t\tthrow new KettleStepException(Messages.getString(\"AddSequence.Exception.NoSpecifiedMethod\")); //$NON-NLS-1$\n\t\t}\n\t\t\n\t\tif (next!=null)\n\t\t{\n\t\t\tObject[] outputRowData = inputRowData;\n\t\t\tif (inputRowData.length<inputRowMeta.size()+1) {\n\t\t\t\toutputRowData = RowDataUtil.resizeArray(inputRowData, inputRowMeta.size()+1);\n\t\t\t}\n\t\t\toutputRowData[inputRowMeta.size()]=next;\n\t\t\treturn outputRowData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new KettleStepException(Messages.getString(\"AddSequence.Exception.CouldNotFindNextValueForSequence\")+meta.getValuename()); //$NON-NLS-1$\n\t\t}\n\t}","id":47309,"modified_method":"public Object[] addSequence(RowMetaInterface inputRowMeta, Object[] inputRowData) throws KettleException\n\t{\n\t\tObject next = null;\n\t\t\n\t\tif (meta.isCounterUsed()) {\n\t\t\tsynchronized (data.counter) {\n\t\t\t\tlong prev = data.counter.getCounter();\n\t\t\t\t\n\t\t\t\tlong nval = prev + meta.getIncrementBy();\n\t\t\t\tif (meta.getIncrementBy() > 0 && meta.getMaxValue() > meta.getStartAt() && nval > meta.getMaxValue())\n\t\t\t\t\tnval = meta.getStartAt();\n\t\t\t\tif (meta.getIncrementBy() < 0 && meta.getMaxValue() < meta.getStartAt() && nval < meta.getMaxValue())\n\t\t\t\t\tnval = meta.getStartAt();\n\t\t\t\tdata.counter.setCounter(nval);\n\t\n\t\t\t\tnext = prev;\n\t\t\t}\n\t\t} else if (meta.isDatabaseUsed()) {\n\t\t\ttry {\n\t\t\t\tnext = data.getDb().getNextSequenceValue(environmentSubstitute(meta.getSchemaName()), \n\t\t\t\t\t\t                                 environmentSubstitute(meta.getSequenceName()), \n\t\t\t\t\t\t                                 meta.getValuename());\n\t\t\t} catch (KettleDatabaseException dbe) {\n\t\t\t\tthrow new KettleStepException(Messages.getString(\n\t\t\t\t\t\t\"AddSequence.Exception.ErrorReadingSequence\", meta.getSequenceName()), dbe); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t} else {\n\t\t\t// This should never happen, but if it does, don't continue!!!\n\t\t\tthrow new KettleStepException(Messages.getString(\"AddSequence.Exception.NoSpecifiedMethod\")); //$NON-NLS-1$\n\t\t}\n\t\t\n\t\tif (next!=null)\n\t\t{\n\t\t\tObject[] outputRowData = inputRowData;\n\t\t\tif (inputRowData.length<inputRowMeta.size()+1) {\n\t\t\t\toutputRowData = RowDataUtil.resizeArray(inputRowData, inputRowMeta.size()+1);\n\t\t\t}\n\t\t\toutputRowData[inputRowMeta.size()]=next;\n\t\t\treturn outputRowData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new KettleStepException(Messages.getString(\"AddSequence.Exception.CouldNotFindNextValueForSequence\")+meta.getValuename()); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"c07a3d9b2ad778cb30c4863523b626dc53bd9656","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"AddSequenceDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"AddSequenceDialog.StepName.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(\t\twlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Valuename line\n\t\twlValuename=new Label(shell, SWT.RIGHT);\n\t\twlValuename.setText(Messages.getString(\"AddSequenceDialog.Valuename.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlValuename);\n\t\tFormData fdlValuename = new FormData();\n\t\tfdlValuename.left = new FormAttachment(0, 0);\n\t\tfdlValuename.top  = new FormAttachment(wStepname, margin);\n\t\tfdlValuename.right= new FormAttachment(middle, -margin);\n\t\twlValuename.setLayoutData(fdlValuename);\n\t\twValuename=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twValuename.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wValuename);\n\t\twValuename.addModifyListener(lsMod);\n\t\tFormData fdValuename = new FormData();\n\t\tfdValuename.left = new FormAttachment(middle, 0);\n\t\tfdValuename.top  = new FormAttachment(wStepname, margin);\n\t\tfdValuename.right= new FormAttachment(100, 0);\n\t\twValuename.setLayoutData(fdValuename);\n        \n        gDatabase = new Group(shell, SWT.NONE);\n        gDatabase.setText(Messages.getString(\"AddSequenceDialog.UseDatabaseGroup.Label\"));\n        FormLayout databaseLayout = new FormLayout();\n        databaseLayout.marginHeight = margin;\n        databaseLayout.marginWidth = margin;\n        gDatabase.setLayout(databaseLayout);\n        props.setLook(gDatabase);\n        fdDatabase = new FormData();\n        fdDatabase.left  = new FormAttachment(0,0);\n        fdDatabase.right = new FormAttachment(100,0);\n        fdDatabase.top   = new FormAttachment(wValuename, 2*margin);\n        gDatabase.setLayoutData(fdDatabase);\n\n\t\twlUseDatabase=new Label(gDatabase, SWT.RIGHT);\n\t\twlUseDatabase.setText(Messages.getString(\"AddSequenceDialog.UseDatabase.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlUseDatabase);\n\t\tFormData fdlUseDatabase = new FormData();\n\t\tfdlUseDatabase.left = new FormAttachment(0, 0);\n\t\tfdlUseDatabase.top  = new FormAttachment(0, 0);\n\t\tfdlUseDatabase.right= new FormAttachment(middle, -margin);\n\t\twlUseDatabase.setLayoutData(fdlUseDatabase);\n\t\twUseDatabase=new Button(gDatabase, SWT.CHECK );\n \t\tprops.setLook(wUseDatabase);\n\t\twUseDatabase.setToolTipText(Messages.getString(\"AddSequenceDialog.UseDatabase.Tooltip\")); //$NON-NLS-1$\n\t\tFormData fdUseDatabase = new FormData();\n\t\tfdUseDatabase.left = new FormAttachment(middle, 0);\n\t\tfdUseDatabase.top  = new FormAttachment(0, 0);\n\t\twUseDatabase.setLayoutData(fdUseDatabase);\n\t\twUseDatabase.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n                    wUseCounter.setSelection(!wUseDatabase.getSelection());\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Connection line\n\t\twlConnection = new Label(gDatabase, SWT.RIGHT);\n        wbnConnection = new Button(gDatabase, SWT.PUSH);\n\t\twbeConnection = new Button(gDatabase, SWT.PUSH);\n        wConnection = addConnectionLine(gDatabase, wUseDatabase, middle, margin, wlConnection, wbnConnection, wbeConnection);\n\t\tif (input.getDatabase()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(gDatabase, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"AddSequenceDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        FormData fdlSchema = new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new Text(gDatabase, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        FormData fdSchema = new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\n\t\t// Seqname line\n\t\twlSeqname=new Label(gDatabase, SWT.RIGHT);\n\t\twlSeqname.setText(Messages.getString(\"AddSequenceDialog.Seqname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSeqname);\n\t\tFormData fdlSeqname = new FormData();\n\t\tfdlSeqname.left = new FormAttachment(0, 0);\n\t\tfdlSeqname.right= new FormAttachment(middle, -margin);\n\t\tfdlSeqname.top  = new FormAttachment(wSchema, margin);\n\t\twlSeqname.setLayoutData(fdlSeqname);\n\t\twSeqname=new Text(gDatabase, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSeqname.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wSeqname);\n\t\twSeqname.addModifyListener(lsMod);\n\t\tFormData fdSeqname = new FormData();\n\t\tfdSeqname.left = new FormAttachment(middle, 0);\n\t\tfdSeqname.top  = new FormAttachment(wSchema, margin);\n\t\tfdSeqname.right= new FormAttachment(100, 0);\n\t\twSeqname.setLayoutData(fdSeqname);\n\n        \n        gCounter = new Group(shell, SWT.NONE);\n        gCounter.setText(Messages.getString(\"AddSequenceDialog.UseCounterGroup.Label\"));\n        FormLayout counterLayout = new FormLayout();\n        counterLayout.marginHeight = margin;\n        counterLayout.marginWidth = margin;\n        gCounter.setLayout(counterLayout);\n        props.setLook(gCounter);\n        fdCounter = new FormData();\n        fdCounter.left  = new FormAttachment(0,0);\n        fdCounter.right = new FormAttachment(100,0);\n        fdCounter.top   = new FormAttachment(gDatabase, 2*margin);\n        gCounter.setLayoutData(fdCounter);\n\n\t\twlUseCounter=new Label(gCounter, SWT.RIGHT);\n\t\twlUseCounter.setText(Messages.getString(\"AddSequenceDialog.UseCounter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlUseCounter);\n\t\tFormData fdlUseCounter = new FormData();\n\t\tfdlUseCounter.left = new FormAttachment(0, 0);\n\t\tfdlUseCounter.top  = new FormAttachment(wSeqname, margin);\n\t\tfdlUseCounter.right= new FormAttachment(middle, -margin);\n\t\twlUseCounter.setLayoutData(fdlUseCounter);\n\t\twUseCounter=new Button(gCounter, SWT.CHECK );\n \t\tprops.setLook(wUseCounter);\n\t\twUseCounter.setToolTipText(Messages.getString(\"AddSequenceDialog.UseCounter.Tooltip\")); //$NON-NLS-1$\n\t\tFormData fdUseCounter = new FormData();\n\t\tfdUseCounter.left = new FormAttachment(middle, 0);\n\t\tfdUseCounter.top  = new FormAttachment(wSeqname, margin);\n\t\twUseCounter.setLayoutData(fdUseCounter);\n\t\twUseCounter.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n                    wUseDatabase.setSelection(!wUseCounter.getSelection());\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n        // CounterName line\n        wlCounterName=new Label(gCounter, SWT.RIGHT);\n        wlCounterName.setText(Messages.getString(\"AddSequenceDialog.CounterName.Label\")); //$NON-NLS-1$\n        props.setLook(wlCounterName);\n        FormData fdlCounterName = new FormData();\n        fdlCounterName.left = new FormAttachment(0, 0);\n        fdlCounterName.right= new FormAttachment(middle, -margin);\n        fdlCounterName.top  = new FormAttachment(wUseCounter, margin);\n        wlCounterName.setLayoutData(fdlCounterName);\n        wCounterName=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wCounterName.setText(\"\"); //$NON-NLS-1$\n        props.setLook(wCounterName);\n        wCounterName.addModifyListener(lsMod);\n        FormData fdCounterName = new FormData();\n        fdCounterName.left = new FormAttachment(middle, 0);\n        fdCounterName.top  = new FormAttachment(wUseCounter, margin);\n        fdCounterName.right= new FormAttachment(100, 0);\n        wCounterName.setLayoutData(fdCounterName);\n\n\t\t// StartAt line\n\t\twlStartAt=new Label(gCounter, SWT.RIGHT);\n\t\twlStartAt.setText(Messages.getString(\"AddSequenceDialog.StartAt.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStartAt);\n\t\tFormData fdlStartAt = new FormData();\n\t\tfdlStartAt.left = new FormAttachment(0, 0);\n\t\tfdlStartAt.right= new FormAttachment(middle, -margin);\n\t\tfdlStartAt.top  = new FormAttachment(wCounterName, margin);\n\t\twlStartAt.setLayoutData(fdlStartAt);\n\t\twStartAt=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStartAt.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wStartAt);\n\t\twStartAt.addModifyListener(lsMod);\n\t\tFormData fdStartAt = new FormData();\n\t\tfdStartAt.left = new FormAttachment(middle, 0);\n\t\tfdStartAt.top  = new FormAttachment(wCounterName, margin);\n\t\tfdStartAt.right= new FormAttachment(100, 0);\n\t\twStartAt.setLayoutData(fdStartAt);\n\n\t\t// IncrBy line\n\t\twlIncrBy=new Label(gCounter, SWT.RIGHT);\n\t\twlIncrBy.setText(Messages.getString(\"AddSequenceDialog.IncrBy.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlIncrBy);\n\t\tFormData fdlIncrBy = new FormData();\n\t\tfdlIncrBy.left = new FormAttachment(0, 0);\n\t\tfdlIncrBy.right= new FormAttachment(middle, -margin);\n\t\tfdlIncrBy.top  = new FormAttachment(wStartAt, margin);\n\t\twlIncrBy.setLayoutData(fdlIncrBy);\n\t\twIncrBy=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twIncrBy.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wIncrBy);\n\t\twIncrBy.addModifyListener(lsMod);\n\t\tFormData fdIncrBy = new FormData();\n\t\tfdIncrBy.left = new FormAttachment(middle, 0);\n\t\tfdIncrBy.top  = new FormAttachment(wStartAt, margin);\n\t\tfdIncrBy.right= new FormAttachment(100, 0);\n\t\twIncrBy.setLayoutData(fdIncrBy);\n\n\t\t// MaxVal line\n\t\twlMaxVal=new Label(gCounter, SWT.RIGHT);\n\t\twlMaxVal.setText(Messages.getString(\"AddSequenceDialog.MaxVal.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlMaxVal);\n\t\tFormData fdlMaxVal = new FormData();\n\t\tfdlMaxVal.left = new FormAttachment(0, 0);\n\t\tfdlMaxVal.right= new FormAttachment(middle, -margin);\n\t\tfdlMaxVal.top  = new FormAttachment(wIncrBy, margin);\n\t\twlMaxVal.setLayoutData(fdlMaxVal);\n\t\twMaxVal=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twMaxVal.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wMaxVal);\n\t\twMaxVal.addModifyListener(lsMod);\n\t\tFormData fdMaxVal = new FormData();\n\t\tfdMaxVal.left = new FormAttachment(middle, 0);\n\t\tfdMaxVal.top  = new FormAttachment(wIncrBy, margin);\n\t\tfdMaxVal.right= new FormAttachment(100, 0);\n\t\twMaxVal.setLayoutData(fdMaxVal);\n\n\t\t\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, gCounter);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twValuename.addSelectionListener( lsDef);\n        wSchema.addSelectionListener( lsDef );\n\t\twSeqname.addSelectionListener( lsDef );\n\t\twStartAt.addSelectionListener( lsDef );\n\t\twIncrBy.addSelectionListener( lsDef );\n\t\twMaxVal.addSelectionListener( lsDef );\n        wCounterName.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":47310,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"AddSequenceDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"AddSequenceDialog.StepName.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(\t\twlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Valuename line\n\t\twlValuename=new Label(shell, SWT.RIGHT);\n\t\twlValuename.setText(Messages.getString(\"AddSequenceDialog.Valuename.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlValuename);\n\t\tFormData fdlValuename = new FormData();\n\t\tfdlValuename.left = new FormAttachment(0, 0);\n\t\tfdlValuename.top  = new FormAttachment(wStepname, margin);\n\t\tfdlValuename.right= new FormAttachment(middle, -margin);\n\t\twlValuename.setLayoutData(fdlValuename);\n\t\twValuename=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twValuename.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wValuename);\n\t\twValuename.addModifyListener(lsMod);\n\t\tFormData fdValuename = new FormData();\n\t\tfdValuename.left = new FormAttachment(middle, 0);\n\t\tfdValuename.top  = new FormAttachment(wStepname, margin);\n\t\tfdValuename.right= new FormAttachment(100, 0);\n\t\twValuename.setLayoutData(fdValuename);\n        \n        gDatabase = new Group(shell, SWT.NONE);\n        gDatabase.setText(Messages.getString(\"AddSequenceDialog.UseDatabaseGroup.Label\"));\n        FormLayout databaseLayout = new FormLayout();\n        databaseLayout.marginHeight = margin;\n        databaseLayout.marginWidth = margin;\n        gDatabase.setLayout(databaseLayout);\n        props.setLook(gDatabase);\n        fdDatabase = new FormData();\n        fdDatabase.left  = new FormAttachment(0,0);\n        fdDatabase.right = new FormAttachment(100,0);\n        fdDatabase.top   = new FormAttachment(wValuename, 2*margin);\n        gDatabase.setLayoutData(fdDatabase);\n\n\t\twlUseDatabase=new Label(gDatabase, SWT.RIGHT);\n\t\twlUseDatabase.setText(Messages.getString(\"AddSequenceDialog.UseDatabase.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlUseDatabase);\n\t\tFormData fdlUseDatabase = new FormData();\n\t\tfdlUseDatabase.left = new FormAttachment(0, 0);\n\t\tfdlUseDatabase.top  = new FormAttachment(0, 0);\n\t\tfdlUseDatabase.right= new FormAttachment(middle, -margin);\n\t\twlUseDatabase.setLayoutData(fdlUseDatabase);\n\t\twUseDatabase=new Button(gDatabase, SWT.CHECK );\n \t\tprops.setLook(wUseDatabase);\n\t\twUseDatabase.setToolTipText(Messages.getString(\"AddSequenceDialog.UseDatabase.Tooltip\")); //$NON-NLS-1$\n\t\tFormData fdUseDatabase = new FormData();\n\t\tfdUseDatabase.left = new FormAttachment(middle, 0);\n\t\tfdUseDatabase.top  = new FormAttachment(0, 0);\n\t\twUseDatabase.setLayoutData(fdUseDatabase);\n\t\twUseDatabase.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n                    wUseCounter.setSelection(!wUseDatabase.getSelection());\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Connection line\n\t\twlConnection = new Label(gDatabase, SWT.RIGHT);\n        wbnConnection = new Button(gDatabase, SWT.PUSH);\n\t\twbeConnection = new Button(gDatabase, SWT.PUSH);\n        wConnection = addConnectionLine(gDatabase, wUseDatabase, middle, margin, wlConnection, wbnConnection, wbeConnection);\n\t\tif (input.getDatabase()==null && transMeta.nrDatabases()==1) wConnection.select(0);\n\t\twConnection.addModifyListener(lsMod);\n\n        // Schema line...\n        wlSchema=new Label(gDatabase, SWT.RIGHT);\n        wlSchema.setText(Messages.getString(\"AddSequenceDialog.TargetSchema.Label\")); //$NON-NLS-1$\n        props.setLook(wlSchema);\n        FormData fdlSchema = new FormData();\n        fdlSchema.left = new FormAttachment(0, 0);\n        fdlSchema.right= new FormAttachment(middle, -margin);\n        fdlSchema.top  = new FormAttachment(wConnection, margin);\n        wlSchema.setLayoutData(fdlSchema);\n\n        wSchema=new TextVar(transMeta, gDatabase, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wSchema);\n        wSchema.addModifyListener(lsMod);\n        FormData fdSchema = new FormData();\n        fdSchema.left = new FormAttachment(middle, 0);\n        fdSchema.top  = new FormAttachment(wConnection, margin);\n        fdSchema.right= new FormAttachment(100, 0);\n        wSchema.setLayoutData(fdSchema);\n\n\n\t\t// Seqname line\n\t\twlSeqname=new Label(gDatabase, SWT.RIGHT);\n\t\twlSeqname.setText(Messages.getString(\"AddSequenceDialog.Seqname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSeqname);\n\t\tFormData fdlSeqname = new FormData();\n\t\tfdlSeqname.left = new FormAttachment(0, 0);\n\t\tfdlSeqname.right= new FormAttachment(middle, -margin);\n\t\tfdlSeqname.top  = new FormAttachment(wSchema, margin);\n\t\twlSeqname.setLayoutData(fdlSeqname);\n\t\twSeqname=new TextVar(transMeta, gDatabase, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSeqname.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wSeqname);\n\t\twSeqname.addModifyListener(lsMod);\n\t\tFormData fdSeqname = new FormData();\n\t\tfdSeqname.left = new FormAttachment(middle, 0);\n\t\tfdSeqname.top  = new FormAttachment(wSchema, margin);\n\t\tfdSeqname.right= new FormAttachment(100, 0);\n\t\twSeqname.setLayoutData(fdSeqname);\n\n        \n        gCounter = new Group(shell, SWT.NONE);\n        gCounter.setText(Messages.getString(\"AddSequenceDialog.UseCounterGroup.Label\"));\n        FormLayout counterLayout = new FormLayout();\n        counterLayout.marginHeight = margin;\n        counterLayout.marginWidth = margin;\n        gCounter.setLayout(counterLayout);\n        props.setLook(gCounter);\n        fdCounter = new FormData();\n        fdCounter.left  = new FormAttachment(0,0);\n        fdCounter.right = new FormAttachment(100,0);\n        fdCounter.top   = new FormAttachment(gDatabase, 2*margin);\n        gCounter.setLayoutData(fdCounter);\n\n\t\twlUseCounter=new Label(gCounter, SWT.RIGHT);\n\t\twlUseCounter.setText(Messages.getString(\"AddSequenceDialog.UseCounter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlUseCounter);\n\t\tFormData fdlUseCounter = new FormData();\n\t\tfdlUseCounter.left = new FormAttachment(0, 0);\n\t\tfdlUseCounter.top  = new FormAttachment(wSeqname, margin);\n\t\tfdlUseCounter.right= new FormAttachment(middle, -margin);\n\t\twlUseCounter.setLayoutData(fdlUseCounter);\n\t\twUseCounter=new Button(gCounter, SWT.CHECK );\n \t\tprops.setLook(wUseCounter);\n\t\twUseCounter.setToolTipText(Messages.getString(\"AddSequenceDialog.UseCounter.Tooltip\")); //$NON-NLS-1$\n\t\tFormData fdUseCounter = new FormData();\n\t\tfdUseCounter.left = new FormAttachment(middle, 0);\n\t\tfdUseCounter.top  = new FormAttachment(wSeqname, margin);\n\t\twUseCounter.setLayoutData(fdUseCounter);\n\t\twUseCounter.addSelectionListener(new SelectionAdapter() \n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t{\n                    wUseDatabase.setSelection(!wUseCounter.getSelection());\n\t\t\t\t\tenableFields();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n        // CounterName line\n        wlCounterName=new Label(gCounter, SWT.RIGHT);\n        wlCounterName.setText(Messages.getString(\"AddSequenceDialog.CounterName.Label\")); //$NON-NLS-1$\n        props.setLook(wlCounterName);\n        FormData fdlCounterName = new FormData();\n        fdlCounterName.left = new FormAttachment(0, 0);\n        fdlCounterName.right= new FormAttachment(middle, -margin);\n        fdlCounterName.top  = new FormAttachment(wUseCounter, margin);\n        wlCounterName.setLayoutData(fdlCounterName);\n        wCounterName=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wCounterName.setText(\"\"); //$NON-NLS-1$\n        props.setLook(wCounterName);\n        wCounterName.addModifyListener(lsMod);\n        FormData fdCounterName = new FormData();\n        fdCounterName.left = new FormAttachment(middle, 0);\n        fdCounterName.top  = new FormAttachment(wUseCounter, margin);\n        fdCounterName.right= new FormAttachment(100, 0);\n        wCounterName.setLayoutData(fdCounterName);\n\n\t\t// StartAt line\n\t\twlStartAt=new Label(gCounter, SWT.RIGHT);\n\t\twlStartAt.setText(Messages.getString(\"AddSequenceDialog.StartAt.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStartAt);\n\t\tFormData fdlStartAt = new FormData();\n\t\tfdlStartAt.left = new FormAttachment(0, 0);\n\t\tfdlStartAt.right= new FormAttachment(middle, -margin);\n\t\tfdlStartAt.top  = new FormAttachment(wCounterName, margin);\n\t\twlStartAt.setLayoutData(fdlStartAt);\n\t\twStartAt=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStartAt.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wStartAt);\n\t\twStartAt.addModifyListener(lsMod);\n\t\tFormData fdStartAt = new FormData();\n\t\tfdStartAt.left = new FormAttachment(middle, 0);\n\t\tfdStartAt.top  = new FormAttachment(wCounterName, margin);\n\t\tfdStartAt.right= new FormAttachment(100, 0);\n\t\twStartAt.setLayoutData(fdStartAt);\n\n\t\t// IncrBy line\n\t\twlIncrBy=new Label(gCounter, SWT.RIGHT);\n\t\twlIncrBy.setText(Messages.getString(\"AddSequenceDialog.IncrBy.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlIncrBy);\n\t\tFormData fdlIncrBy = new FormData();\n\t\tfdlIncrBy.left = new FormAttachment(0, 0);\n\t\tfdlIncrBy.right= new FormAttachment(middle, -margin);\n\t\tfdlIncrBy.top  = new FormAttachment(wStartAt, margin);\n\t\twlIncrBy.setLayoutData(fdlIncrBy);\n\t\twIncrBy=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twIncrBy.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wIncrBy);\n\t\twIncrBy.addModifyListener(lsMod);\n\t\tFormData fdIncrBy = new FormData();\n\t\tfdIncrBy.left = new FormAttachment(middle, 0);\n\t\tfdIncrBy.top  = new FormAttachment(wStartAt, margin);\n\t\tfdIncrBy.right= new FormAttachment(100, 0);\n\t\twIncrBy.setLayoutData(fdIncrBy);\n\n\t\t// MaxVal line\n\t\twlMaxVal=new Label(gCounter, SWT.RIGHT);\n\t\twlMaxVal.setText(Messages.getString(\"AddSequenceDialog.MaxVal.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlMaxVal);\n\t\tFormData fdlMaxVal = new FormData();\n\t\tfdlMaxVal.left = new FormAttachment(0, 0);\n\t\tfdlMaxVal.right= new FormAttachment(middle, -margin);\n\t\tfdlMaxVal.top  = new FormAttachment(wIncrBy, margin);\n\t\twlMaxVal.setLayoutData(fdlMaxVal);\n\t\twMaxVal=new Text(gCounter, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twMaxVal.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wMaxVal);\n\t\twMaxVal.addModifyListener(lsMod);\n\t\tFormData fdMaxVal = new FormData();\n\t\tfdMaxVal.left = new FormAttachment(middle, 0);\n\t\tfdMaxVal.top  = new FormAttachment(wIncrBy, margin);\n\t\tfdMaxVal.right= new FormAttachment(100, 0);\n\t\twMaxVal.setLayoutData(fdMaxVal);\n\n\t\t\n\t\t// THE BUTTONS\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, gCounter);\n\n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();        } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();    } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twValuename.addSelectionListener( lsDef);\n        wSchema.addSelectionListener( lsDef );\n\t\twSeqname.addSelectionListener( lsDef );\n\t\twStartAt.addSelectionListener( lsDef );\n\t\twIncrBy.addSelectionListener( lsDef );\n\t\twMaxVal.addSelectionListener( lsDef );\n        wCounterName.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"c07a3d9b2ad778cb30c4863523b626dc53bd9656","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void loadAllTableDataIntoTheCache() throws KettleException {\r\n    \tDatabaseMeta dbMeta = meta.getDatabaseMeta();\r\n    \t\r\n    \ttry {\r\n\t    \t// We only want to get the used table fields...\r\n\t    \t//\r\n\t    \tString sql = \"SELECT \";\r\n\t    \t\r\n            for (int i=0;i<meta.getStreamKeyField1().length;i++)\r\n            {\r\n            \tif (i>0) sql+=\", \";\r\n            \tsql+=dbMeta.quoteField(meta.getTableKeyField()[i]);\r\n            }\r\n\r\n\t    \t// Also grab the return field...\r\n\t    \t//\r\n\t    \tfor (int i=0;i<meta.getReturnValueField().length;i++) {\r\n\t    \t\tsql+=\", \"+dbMeta.quoteField(meta.getReturnValueField()[i]);\r\n\t    \t}\r\n\t    \t// The schema/table\r\n\t    \t//\r\n\t    \tsql+=\" FROM \"+dbMeta.getQuotedSchemaTableCombination(meta.getSchemaName(), meta.getTablename());\r\n\t    \t\r\n\t    \t// order by?\r\n\t\t\tif (meta.getOrderByClause()!=null && meta.getOrderByClause().length()!=0)\r\n\t\t\t{\r\n\t\t\t\tsql += \" ORDER BY \"+meta.getOrderByClause();\r\n\t\t\t}\r\n\t    \t\r\n\t    \t// Now that we have the SQL constructed, let's store the rows...\r\n\t    \t//\r\n\t    \tList<Object[]> rows = data.db.getRows(sql, 0);\r\n\t    \tif (rows!=null && rows.size()>0) {\r\n\t    \t\tRowMetaInterface returnRowMeta = data.db.getReturnRowMeta();\r\n\t    \t\t// Copy the data into 2 parts: key and value...\r\n\t    \t\t// \r\n\t    \t\tfor (Object[] row : rows) {\r\n\t    \t\t\tint index=0;\r\n\t    \t\t\tRowMeta keyMeta = new RowMeta();\r\n\t    \t\t\tObject[] keyData = new Object[meta.getStreamKeyField1().length];\r\n\t    \t\t\tfor (int i=0;i<meta.getStreamKeyField1().length;i++) {\r\n\t    \t\t\t\tkeyData[i] = row[index];\r\n\t    \t\t\t\tkeyMeta.addValueMeta(returnRowMeta.getValueMeta(index++));\r\n\t    \t\t\t}\r\n\t    \t\t\t// RowMeta valueMeta = new RowMeta();\r\n\t    \t\t\tObject[] valueData = new Object[data.returnMeta.size()];\r\n\t    \t\t\tfor (int i=0;i<data.returnMeta.size();i++) {\r\n\t    \t\t\t\tvalueData[i] = row[index++];\r\n\t    \t\t\t\t// valueMeta.addValueMeta(returnRowMeta.getValueMeta(index++));\r\n\t    \t\t\t}\r\n\t    \t\t\t// Store the data...\r\n\t    \t\t\t//\r\n\t    \t\t\tstoreRowInCache(keyMeta, keyData, valueData);\r\n\t    \t\t\tincrementLinesInput();\r\n\t    \t\t}\r\n\t    \t}\r\n    \t}\r\n    \tcatch(Exception e) {\r\n    \t\tthrow new KettleException(e);\r\n    \t}\r\n\t}","id":47311,"modified_method":"private void loadAllTableDataIntoTheCache() throws KettleException {\r\n    \tDatabaseMeta dbMeta = meta.getDatabaseMeta();\r\n    \t\r\n    \ttry {\r\n\t    \t// We only want to get the used table fields...\r\n\t    \t//\r\n\t    \tString sql = \"SELECT \";\r\n\t    \t\r\n            for (int i=0;i<meta.getStreamKeyField1().length;i++)\r\n            {\r\n            \tif (i>0) sql+=\", \";\r\n            \tsql+=dbMeta.quoteField(meta.getTableKeyField()[i]);\r\n            }\r\n\r\n\t    \t// Also grab the return field...\r\n\t    \t//\r\n\t    \tfor (int i=0;i<meta.getReturnValueField().length;i++) {\r\n\t    \t\tsql+=\", \"+dbMeta.quoteField(meta.getReturnValueField()[i]);\r\n\t    \t}\r\n\t    \t// The schema/table\r\n\t    \t//\r\n\t    \tsql+=\" FROM \"+dbMeta.getQuotedSchemaTableCombination(environmentSubstitute(meta.getSchemaName()), environmentSubstitute(meta.getTablename()));\r\n\t    \t\r\n\t    \t// order by?\r\n\t\t\tif (meta.getOrderByClause()!=null && meta.getOrderByClause().length()!=0)\r\n\t\t\t{\r\n\t\t\t\tsql += \" ORDER BY \"+meta.getOrderByClause();\r\n\t\t\t}\r\n\t    \t\r\n\t    \t// Now that we have the SQL constructed, let's store the rows...\r\n\t    \t//\r\n\t    \tList<Object[]> rows = data.db.getRows(sql, 0);\r\n\t    \tif (rows!=null && rows.size()>0) {\r\n\t    \t\tRowMetaInterface returnRowMeta = data.db.getReturnRowMeta();\r\n\t    \t\t// Copy the data into 2 parts: key and value...\r\n\t    \t\t// \r\n\t    \t\tfor (Object[] row : rows) {\r\n\t    \t\t\tint index=0;\r\n\t    \t\t\tRowMeta keyMeta = new RowMeta();\r\n\t    \t\t\tObject[] keyData = new Object[meta.getStreamKeyField1().length];\r\n\t    \t\t\tfor (int i=0;i<meta.getStreamKeyField1().length;i++) {\r\n\t    \t\t\t\tkeyData[i] = row[index];\r\n\t    \t\t\t\tkeyMeta.addValueMeta(returnRowMeta.getValueMeta(index++));\r\n\t    \t\t\t}\r\n\t    \t\t\t// RowMeta valueMeta = new RowMeta();\r\n\t    \t\t\tObject[] valueData = new Object[data.returnMeta.size()];\r\n\t    \t\t\tfor (int i=0;i<data.returnMeta.size();i++) {\r\n\t    \t\t\t\tvalueData[i] = row[index++];\r\n\t    \t\t\t\t// valueMeta.addValueMeta(returnRowMeta.getValueMeta(index++));\r\n\t    \t\t\t}\r\n\t    \t\t\t// Store the data...\r\n\t    \t\t\t//\r\n\t    \t\t\tstoreRowInCache(keyMeta, keyData, valueData);\r\n\t    \t\t\tincrementLinesInput();\r\n\t    \t\t}\r\n\t    \t}\r\n    \t}\r\n    \tcatch(Exception e) {\r\n    \t\tthrow new KettleException(e);\r\n    \t}\r\n\t}","commit_id":"c8ffd2ec4013d28a3ecdd1809f4ff8a58750c4c8","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void processTemplate(\n\t\t\tPageContext pageContext, String portletId,\n\t\t\tTemplateResource templateResource)\n\t\tthrows Exception {\n\n\t\tdoDispatch(pageContext, portletId, templateResource, true);\n\t}","id":47312,"modified_method":"public void processTemplate(\n\t\t\tPageContext pageContext, String portletId,\n\t\t\tTemplateResource templateResource)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = null;\n\n\t\tsb = doDispatch(pageContext, portletId, templateResource, true);\n\n\t\tsb.writeTo(pageContext.getOut());\n\t}","commit_id":"7184bef863a4ecd207a224a6e926b66187b11e97","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doProcessTemplate(\n\t\t\tPageContext pageContext, String portletId,\n\t\t\tTemplateResource templateResource,\n\t\t\tTemplateContextType templateContextType)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tTemplateProcessor processor = new TemplateProcessor(\n\t\t\trequest, response, portletId);\n\n\t\tTemplate template = TemplateManagerUtil.getTemplate(\n\t\t\tTemplateManager.VELOCITY, templateResource, templateContextType);\n\n\t\ttemplate.put(\"processor\", processor);\n\n\t\t// Velocity variables\n\n\t\ttemplate.prepare(request);\n\n\t\t// liferay:include tag library\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tpageContext.getServletContext(), request,\n\t\t\tnew PipingServletResponse(response, unsyncStringWriter),\n\t\t\tpageContext, template);\n\n\t\ttemplate.put(\"taglibLiferay\", velocityTaglib);\n\t\ttemplate.put(\"theme\", velocityTaglib);\n\n\t\ttry {\n\t\t\ttemplate.processTemplate(unsyncStringWriter);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow e;\n\t\t}\n\n\t\tboolean portletParallelRender = GetterUtil.getBoolean(\n\t\t\trequest.getAttribute(WebKeys.PORTLET_PARALLEL_RENDER));\n\n\t\tLock lock = null;\n\n\t\tMap<String, StringBundler> contentsMap =\n\t\t\tnew HashMap<String, StringBundler>();\n\n\t\tMap<Integer, List<PortletRenderer>> portletRenderersMap =\n\t\t\tprocessor.getPortletRenderers();\n\n\t\tfor (Map.Entry<Integer, List<PortletRenderer>> entry :\n\t\t\t\tportletRenderersMap.entrySet()) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Processing portlets with render weight \" + entry.getKey());\n\t\t\t}\n\n\t\t\tList<PortletRenderer> portletRenderers = entry.getValue();\n\n\t\t\tif (portletParallelRender && (portletRenderers.size() > 1)) {\n\t\t\t\tStopWatch stopWatch = null;\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Start parallel rendering\");\n\n\t\t\t\t\tstopWatch = new StopWatch();\n\n\t\t\t\t\tstopWatch.start();\n\t\t\t\t}\n\n\t\t\t\tif (lock == null) {\n\t\t\t\t\tlock = new ReentrantLock();\n\t\t\t\t}\n\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.PARALLEL_RENDERING_MERGE_LOCK, lock);\n\n\t\t\t\tObjectValuePair<HttpServletRequest, Closeable> objectValuePair =\n\t\t\t\t\tThreadLocalFacadeServletRequestWrapperUtil.inject(request);\n\n\t\t\t\ttry {\n\t\t\t\t\tparallelyRenderPortlets(\n\t\t\t\t\t\tobjectValuePair.getKey(), response, processor,\n\t\t\t\t\t\tcontentsMap, portletRenderers);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tCloseable closeable = objectValuePair.getValue();\n\n\t\t\t\t\tcloseable.close();\n\t\t\t\t}\n\n\t\t\t\trequest.removeAttribute(WebKeys.PARALLEL_RENDERING_MERGE_LOCK);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Finished parallel rendering in \" +\n\t\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStopWatch stopWatch = null;\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Start serial rendering\");\n\n\t\t\t\t\tstopWatch = new StopWatch();\n\n\t\t\t\t\tstopWatch.start();\n\t\t\t\t}\n\n\t\t\t\tfor (PortletRenderer portletRenderer : portletRenderers) {\n\t\t\t\t\tPortlet portlet = portletRenderer.getPortlet();\n\n\t\t\t\t\tcontentsMap.put(\n\t\t\t\t\t\tportlet.getPortletId(),\n\t\t\t\t\t\tportletRenderer.render(request, response));\n\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Serially rendered portlet \" +\n\t\t\t\t\t\t\t\tportlet.getPortletId() + \" in \" +\n\t\t\t\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Finished serial rendering in \" + stopWatch.getTime() +\n\t\t\t\t\t\t\t\" ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (portletParallelRender && (_waitTime == Integer.MAX_VALUE)) {\n\t\t\t_waitTime = PropsValues.LAYOUT_PARALLEL_RENDER_TIMEOUT;\n\t\t}\n\n\t\tStringBundler sb = StringUtil.replaceWithStringBundler(\n\t\t\tunsyncStringWriter.toString(), \"[$TEMPLATE_PORTLET_\", \"$]\",\n\t\t\tcontentsMap);\n\n\t\tsb.writeTo(pageContext.getOut());\n\t}","id":47313,"modified_method":"protected StringBundler doProcessTemplate(\n\t\t\tPageContext pageContext, String portletId,\n\t\t\tTemplateResource templateResource,\n\t\t\tTemplateContextType templateContextType)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tTemplateProcessor processor = new TemplateProcessor(\n\t\t\trequest, response, portletId);\n\n\t\tTemplate template = TemplateManagerUtil.getTemplate(\n\t\t\tTemplateManager.VELOCITY, templateResource, templateContextType);\n\n\t\ttemplate.put(\"processor\", processor);\n\n\t\t// Velocity variables\n\n\t\ttemplate.prepare(request);\n\n\t\t// liferay:include tag library\n\n\t\tUnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tpageContext.getServletContext(), request,\n\t\t\tnew PipingServletResponse(response, unsyncStringWriter),\n\t\t\tpageContext, template);\n\n\t\ttemplate.put(\"taglibLiferay\", velocityTaglib);\n\t\ttemplate.put(\"theme\", velocityTaglib);\n\n\t\ttry {\n\t\t\ttemplate.processTemplate(unsyncStringWriter);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow e;\n\t\t}\n\n\t\tboolean portletParallelRender = GetterUtil.getBoolean(\n\t\t\trequest.getAttribute(WebKeys.PORTLET_PARALLEL_RENDER));\n\n\t\tLock lock = null;\n\n\t\tMap<String, StringBundler> contentsMap =\n\t\t\tnew HashMap<String, StringBundler>();\n\n\t\tMap<Integer, List<PortletRenderer>> portletRenderersMap =\n\t\t\tprocessor.getPortletRenderers();\n\n\t\tfor (Map.Entry<Integer, List<PortletRenderer>> entry :\n\t\t\t\tportletRenderersMap.entrySet()) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Processing portlets with render weight \" + entry.getKey());\n\t\t\t}\n\n\t\t\tList<PortletRenderer> portletRenderers = entry.getValue();\n\n\t\t\tif (portletParallelRender && (portletRenderers.size() > 1)) {\n\t\t\t\tStopWatch stopWatch = null;\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Start parallel rendering\");\n\n\t\t\t\t\tstopWatch = new StopWatch();\n\n\t\t\t\t\tstopWatch.start();\n\t\t\t\t}\n\n\t\t\t\tif (lock == null) {\n\t\t\t\t\tlock = new ReentrantLock();\n\t\t\t\t}\n\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.PARALLEL_RENDERING_MERGE_LOCK, lock);\n\n\t\t\t\tObjectValuePair<HttpServletRequest, Closeable> objectValuePair =\n\t\t\t\t\tThreadLocalFacadeServletRequestWrapperUtil.inject(request);\n\n\t\t\t\ttry {\n\t\t\t\t\tparallelyRenderPortlets(\n\t\t\t\t\t\tobjectValuePair.getKey(), response, processor,\n\t\t\t\t\t\tcontentsMap, portletRenderers);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tCloseable closeable = objectValuePair.getValue();\n\n\t\t\t\t\tcloseable.close();\n\t\t\t\t}\n\n\t\t\t\trequest.removeAttribute(WebKeys.PARALLEL_RENDERING_MERGE_LOCK);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Finished parallel rendering in \" +\n\t\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStopWatch stopWatch = null;\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Start serial rendering\");\n\n\t\t\t\t\tstopWatch = new StopWatch();\n\n\t\t\t\t\tstopWatch.start();\n\t\t\t\t}\n\n\t\t\t\tfor (PortletRenderer portletRenderer : portletRenderers) {\n\t\t\t\t\tPortlet portlet = portletRenderer.getPortlet();\n\n\t\t\t\t\tcontentsMap.put(\n\t\t\t\t\t\tportlet.getPortletId(),\n\t\t\t\t\t\tportletRenderer.render(request, response));\n\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Serially rendered portlet \" +\n\t\t\t\t\t\t\t\tportlet.getPortletId() + \" in \" +\n\t\t\t\t\t\t\t\t\tstopWatch.getTime() + \" ms\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Finished serial rendering in \" + stopWatch.getTime() +\n\t\t\t\t\t\t\t\" ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (portletParallelRender && (_waitTime == Integer.MAX_VALUE)) {\n\t\t\t_waitTime = PropsValues.LAYOUT_PARALLEL_RENDER_TIMEOUT;\n\t\t}\n\n\t\tStringBundler sb = StringUtil.replaceWithStringBundler(\n\t\t\tunsyncStringWriter.toString(), \"[$TEMPLATE_PORTLET_\", \"$]\",\n\t\t\tcontentsMap);\n\n\t\treturn sb;\n\t}","commit_id":"7184bef863a4ecd207a224a6e926b66187b11e97","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doDispatch(\n\t\t\tPageContext pageContext, String portletId,\n\t\t\tTemplateResource templateResource, boolean processTemplate)\n\t\tthrows Exception {\n\n\t\tLayoutTemplate layoutTemplate = getLayoutTemplate(\n\t\t\ttemplateResource.getTemplateId());\n\n\t\tString pluginServletContextName = GetterUtil.getString(\n\t\t\tlayoutTemplate.getServletContextName());\n\n\t\tServletContext pluginServletContext = ServletContextPool.get(\n\t\t\tpluginServletContextName);\n\n\t\tClassLoader pluginClassLoader = null;\n\n\t\tif (pluginServletContext != null) {\n\t\t\tpluginClassLoader =\n\t\t\t\t(ClassLoader)pluginServletContext.getAttribute(\n\t\t\t\t\tPluginContextListener.PLUGIN_CLASS_LOADER);\n\t\t}\n\n\t\tClassLoader contextClassLoader =\n\t\t\tPACLClassLoaderUtil.getContextClassLoader();\n\n\t\ttry {\n\t\t\tTemplateContextType templateContextType =\n\t\t\t\tTemplateContextType.STANDARD;\n\n\t\t\tif ((pluginClassLoader != null) &&\n\t\t\t\t(pluginClassLoader != contextClassLoader)) {\n\n\t\t\t\tPACLClassLoaderUtil.setContextClassLoader(pluginClassLoader);\n\n\t\t\t\ttemplateContextType = TemplateContextType.CLASS_LOADER;\n\t\t\t}\n\n\t\t\tif (processTemplate) {\n\t\t\t\tdoProcessTemplate(\n\t\t\t\t\tpageContext, portletId, templateResource,\n\t\t\t\t\ttemplateContextType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdoProcessCustomizationSettings(\n\t\t\t\t\tpageContext, templateResource, templateContextType);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif ((pluginClassLoader != null) &&\n\t\t\t\t(pluginClassLoader != contextClassLoader)) {\n\n\t\t\t\tPACLClassLoaderUtil.setContextClassLoader(contextClassLoader);\n\t\t\t}\n\t\t}\n\t}","id":47314,"modified_method":"protected StringBundler doDispatch(\n\t\t\tPageContext pageContext, String portletId,\n\t\t\tTemplateResource templateResource, boolean processTemplate)\n\t\tthrows Exception {\n\n\t\tLayoutTemplate layoutTemplate = getLayoutTemplate(\n\t\t\ttemplateResource.getTemplateId());\n\n\t\tString pluginServletContextName = GetterUtil.getString(\n\t\t\tlayoutTemplate.getServletContextName());\n\n\t\tServletContext pluginServletContext = ServletContextPool.get(\n\t\t\tpluginServletContextName);\n\n\t\tClassLoader pluginClassLoader = null;\n\n\t\tif (pluginServletContext != null) {\n\t\t\tpluginClassLoader =\n\t\t\t\t(ClassLoader)pluginServletContext.getAttribute(\n\t\t\t\t\tPluginContextListener.PLUGIN_CLASS_LOADER);\n\t\t}\n\n\t\tClassLoader contextClassLoader =\n\t\t\tPACLClassLoaderUtil.getContextClassLoader();\n\n\t\tStringBundler sb = null;\n\n\t\ttry {\n\t\t\tTemplateContextType templateContextType =\n\t\t\t\tTemplateContextType.STANDARD;\n\n\t\t\tif ((pluginClassLoader != null) &&\n\t\t\t\t(pluginClassLoader != contextClassLoader)) {\n\n\t\t\t\tPACLClassLoaderUtil.setContextClassLoader(pluginClassLoader);\n\n\t\t\t\ttemplateContextType = TemplateContextType.CLASS_LOADER;\n\t\t\t}\n\n\t\t\tif (processTemplate) {\n\t\t\t\tsb = doProcessTemplate(\n\t\t\t\t\tpageContext, portletId, templateResource,\n\t\t\t\t\ttemplateContextType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdoProcessCustomizationSettings(\n\t\t\t\t\tpageContext, templateResource, templateContextType);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif ((pluginClassLoader != null) &&\n\t\t\t\t(pluginClassLoader != contextClassLoader)) {\n\n\t\t\t\tPACLClassLoaderUtil.setContextClassLoader(contextClassLoader);\n\t\t\t}\n\t\t}\n\n\t\treturn sb;\n\t}","commit_id":"7184bef863a4ecd207a224a6e926b66187b11e97","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doDispatch(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\ttry {\n\t\t\tgetGroup(renderRequest);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchGroupException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(renderRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new PortletException(e);\n\t\t\t}\n\t\t}\n\n\t\tif (SessionErrors.contains(\n\t\t\t\trenderRequest, NoSuchGroupException.class.getName()) ||\n\t\t\tSessionErrors.contains(\n\t\t\t\trenderRequest, PrincipalException.getNestedClasses())) {\n\n\t\t\tinclude(\"/error.jsp\", renderRequest, renderResponse);\n\t\t}\n\t\telse {\n\t\t\tsuper.doDispatch(renderRequest, renderResponse);\n\t\t}\n\t}","id":47315,"modified_method":"@Override\n\tprotected void doDispatch(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\ttry {\n\t\t\tgetGroup(renderRequest);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchGroupException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(renderRequest, e.getClass());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new PortletException(e);\n\t\t\t}\n\t\t}\n\n\t\tif (SessionErrors.contains(\n\t\t\t\trenderRequest, NoSuchGroupException.class.getName()) ||\n\t\t\tSessionErrors.contains(\n\t\t\t\trenderRequest, PrincipalException.getNestedClasses())) {\n\n\t\t\tinclude(\"/error.jsp\", renderRequest, renderResponse);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tServiceContext serviceContext =\n\t\t\t\t\tServiceContextFactory.getInstance(renderRequest);\n\n\t\t\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tsuper.doDispatch(renderRequest, renderResponse);\n\t\t}\n\t}","commit_id":"25687738d1b88576c18f945e455143f32769dc59","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected int getNotificationsCount(RenderRequest renderRequest) {\n\t\tPanelCategoryHelper panelCategoryHelper = new PanelCategoryHelper(\n\t\t\t_panelAppRegistry, _panelCategoryRegistry);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\treturn panelCategoryHelper.getNotificationsCount(\n\t\t\tPanelCategoryKeys.USER, themeDisplay.getPermissionChecker(),\n\t\t\tthemeDisplay.getScopeGroup(), themeDisplay.getUser());\n\t}","id":47316,"modified_method":"protected int getNotificationsCount(\n\t\tThemeDisplay themeDisplay, RenderRequest renderRequest) {\n\n\t\tPanelCategoryHelper panelCategoryHelper = new PanelCategoryHelper(\n\t\t\t_panelAppRegistry, _panelCategoryRegistry);\n\n\t\treturn panelCategoryHelper.getNotificationsCount(\n\t\t\tPanelCategoryKeys.USER, themeDisplay.getPermissionChecker(),\n\t\t\tthemeDisplay.getScopeGroup(), themeDisplay.getUser());\n\t}","commit_id":"df581191fb4d3c94b000c2c18e64ef096562a899","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doDispatch(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\trenderRequest.setAttribute(\n\t\t\tProductNavigationUserPersonalBarWebKeys.NOTIFICATIONS_COUNT,\n\t\t\tgetNotificationsCount(renderRequest));\n\n\t\tsuper.doDispatch(renderRequest, renderResponse);\n\t}","id":47317,"modified_method":"@Override\n\tprotected void doDispatch(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows IOException, PortletException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tUser user = themeDisplay.getUser();\n\n\t\tif (!user.isDefaultUser()) {\n\t\t\trenderRequest.setAttribute(\n\t\t\t\tProductNavigationUserPersonalBarWebKeys.NOTIFICATIONS_COUNT,\n\t\t\t\tgetNotificationsCount(themeDisplay, renderRequest));\n\t\t}\n\n\t\tsuper.doDispatch(renderRequest, renderResponse);\n\t}","commit_id":"df581191fb4d3c94b000c2c18e64ef096562a899","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Change permissions for a resource.\n\t */\n\tpublic void setPermissions(Resource res, Permission perms) throws XMLDBException {\n        //TODO : use dedicated function in XmldbURI\n\t\tString path = ((RemoteCollection) res.getParentCollection()).getPath() + \"/\" + res.getId();\n\t\ttry {\n            List<Object> params = new ArrayList<Object>(1);\n\t\t\tparams.add(path);\n\t\t\tparams.add(perms.getOwner());\n\t\t\tparams.add(perms.getOwnerGroup());\n\t\t\tparams.add(new Integer(perms.getPermissions()));\n\t\t\tparent.getClient().execute(\"setPermissions\", params);\n\t\t} catch (XmlRpcException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t}\n    }","id":47318,"modified_method":"/**\n\t * Change permissions for a resource.\n\t */\n\tpublic void setPermissions(Resource res, Permission perms) throws XMLDBException {\n        //TODO : use dedicated function in XmldbURI\n\t\tString path = ((RemoteCollection) res.getParentCollection()).getPath() + \"/\" + res.getId();\n\t\ttry {\n            List<Object> params = new ArrayList<Object>(1);\n\t\t\tparams.add(path);\n\t\t\tparams.add(perms.getOwner().getName());\n\t\t\tparams.add(perms.getOwnerGroup().getName());\n\t\t\tparams.add(new Integer(perms.getPermissions()));\n\t\t\tparent.getClient().execute(\"setPermissions\", params);\n\t\t} catch (XmlRpcException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t}\n    }","commit_id":"f9f583becc6088cd135c401846d5542213f7d5a4","url":"https://github.com/eXist-db/exist"},{"original_method":"private void setupComponents() throws XMLDBException {\n\t\tGridBagLayout grid = new GridBagLayout();\n\t\tgetContentPane().setLayout(grid);\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\tc.insets = new Insets(5, 5, 5, 5);\n\n\t\tJLabel label = new JLabel(\"Resource:\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 0;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tc.weighty = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tlabel = new JLabel(URIUtils.urlDecodeUtf8(resource));\n\t\tc.gridx = 1;\n\t\tc.gridy = 0;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n        label = new JLabel(\"Mime:\");\n        c.gridx = 0;\n        c.gridy = 1;\n        c.anchor = GridBagConstraints.WEST;\n        c.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n        grid.setConstraints(label, c);\n        getContentPane().add(label);\n        \n        label = new JLabel(mimeType);\n        c.gridx = 1;\n        c.gridy = 1;\n        c.anchor = GridBagConstraints.WEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n        grid.setConstraints(label, c);\n        getContentPane().add(label);\n        \n\t\tlabel = new JLabel(\"Created:\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 2;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tString date = DateFormat.getDateTimeInstance().format(creationDate);\n\t\tlabel = new JLabel(date);\n\t\tc.gridx = 1;\n\t\tc.gridy = 2;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tlabel = new JLabel(\"Last modified:\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 3;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tdate = modificationDate != null ? DateFormat.getDateTimeInstance().format(modificationDate) :\n\t\t\t\"not available\";\n\t\tlabel = new JLabel(date);\n\t\tc.gridx = 1;\n\t\tc.gridy = 3;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tlabel = new JLabel(\"Owner\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 4;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tVector<String> ol = new Vector<String>();\n\t\tAccount users[] = service.getAccounts();\n\t\tfor (int i = 0; i < users.length; i++) {\n\t\t\tol.addElement(users[i].getName());\n\t\t}\n\t\towners = new JComboBox(ol);\n\t\towners.setSelectedItem(permissions.getOwner());\n\t\tc.gridx = 1;\n\t\tc.gridy = 4;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(owners, c);\n\t\tgetContentPane().add(owners);\n\n\t\tlabel = new JLabel(\"Group\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 5;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tVector<String> gl = new Vector<String>();\n\t\tString allGroups[] = service.getGroups();\n\t\tfor (int i = 0; i < allGroups.length; i++)\n\t\t\tgl.addElement(allGroups[i]);\n\t\tgroups = new JComboBox(gl);\n\t\tgroups.setSelectedItem(permissions.getOwnerGroup());\n\t\tc.gridx = 1;\n\t\tc.gridy = 5;\n\t\tc.anchor = GridBagConstraints.EAST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(groups, c);\n\t\tgetContentPane().add(groups);\n\n\t\tJComponent pc = setupPermissions();\n\t\tc.gridx = 0;\n\t\tc.gridy = 6;\n\t\tc.gridwidth = 2;\n\t\tc.anchor = GridBagConstraints.EAST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(pc, c);\n\t\tgetContentPane().add(pc);\n\n\t\tBox buttonBox = Box.createHorizontalBox();\n\n\t\tJButton button = new JButton(\"Apply\");\n\t\tbutton.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        applyAction();\n                    }\n\t\t});\n\t\tbuttonBox.add(button);\n\t\tbutton = new JButton(\"Cancel\");\n\t\tbutton.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        cancelAction();\n                    }\n\t\t});\n\t\tbuttonBox.add(button);\n\n\t\tc.gridx = 1;\n\t\tc.gridy = 7;\n\t\tc.gridwidth = 1;\n\t\tc.anchor = GridBagConstraints.EAST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(buttonBox, c);\n\t\tgetContentPane().add(buttonBox);\n\t}","id":47319,"modified_method":"private void setupComponents() throws XMLDBException {\n\t\tGridBagLayout grid = new GridBagLayout();\n\t\tgetContentPane().setLayout(grid);\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\tc.insets = new Insets(5, 5, 5, 5);\n\n\t\tJLabel label = new JLabel(\"Resource:\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 0;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tc.weighty = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tlabel = new JLabel(URIUtils.urlDecodeUtf8(resource));\n\t\tc.gridx = 1;\n\t\tc.gridy = 0;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n        label = new JLabel(\"Mime:\");\n        c.gridx = 0;\n        c.gridy = 1;\n        c.anchor = GridBagConstraints.WEST;\n        c.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n        grid.setConstraints(label, c);\n        getContentPane().add(label);\n        \n        label = new JLabel(mimeType);\n        c.gridx = 1;\n        c.gridy = 1;\n        c.anchor = GridBagConstraints.WEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n        grid.setConstraints(label, c);\n        getContentPane().add(label);\n        \n\t\tlabel = new JLabel(\"Created:\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 2;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tString date = DateFormat.getDateTimeInstance().format(creationDate);\n\t\tlabel = new JLabel(date);\n\t\tc.gridx = 1;\n\t\tc.gridy = 2;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tlabel = new JLabel(\"Last modified:\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 3;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tdate = modificationDate != null ? DateFormat.getDateTimeInstance().format(modificationDate) :\n\t\t\t\"not available\";\n\t\tlabel = new JLabel(date);\n\t\tc.gridx = 1;\n\t\tc.gridy = 3;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tlabel = new JLabel(\"Owner\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 4;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tVector<String> ol = new Vector<String>();\n\t\tAccount users[] = service.getAccounts();\n\t\tfor (int i = 0; i < users.length; i++) {\n\t\t\tol.addElement(users[i].getName());\n\t\t}\n\t\towners = new JComboBox(ol);\n\t\towners.setSelectedItem(permissions.getOwner().getName());\n\t\tc.gridx = 1;\n\t\tc.gridy = 4;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(owners, c);\n\t\tgetContentPane().add(owners);\n\n\t\tlabel = new JLabel(\"Group\");\n\t\tc.gridx = 0;\n\t\tc.gridy = 5;\n\t\tc.anchor = GridBagConstraints.WEST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(label, c);\n\t\tgetContentPane().add(label);\n\n\t\tVector<String> gl = new Vector<String>();\n\t\tString allGroups[] = service.getGroups();\n\t\tfor (int i = 0; i < allGroups.length; i++)\n\t\t\tgl.addElement(allGroups[i]);\n\t\tgroups = new JComboBox(gl);\n\t\tgroups.setSelectedItem(permissions.getOwnerGroup().getName());\n\t\tc.gridx = 1;\n\t\tc.gridy = 5;\n\t\tc.anchor = GridBagConstraints.EAST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(groups, c);\n\t\tgetContentPane().add(groups);\n\n\t\tJComponent pc = setupPermissions();\n\t\tc.gridx = 0;\n\t\tc.gridy = 6;\n\t\tc.gridwidth = 2;\n\t\tc.anchor = GridBagConstraints.EAST;\n\t\tc.fill = GridBagConstraints.HORIZONTAL;\n\t\tc.weightx = 1;\n\t\tgrid.setConstraints(pc, c);\n\t\tgetContentPane().add(pc);\n\n\t\tBox buttonBox = Box.createHorizontalBox();\n\n\t\tJButton button = new JButton(\"Apply\");\n\t\tbutton.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        applyAction();\n                    }\n\t\t});\n\t\tbuttonBox.add(button);\n\t\tbutton = new JButton(\"Cancel\");\n\t\tbutton.addActionListener(new ActionListener() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        cancelAction();\n                    }\n\t\t});\n\t\tbuttonBox.add(button);\n\n\t\tc.gridx = 1;\n\t\tc.gridy = 7;\n\t\tc.gridwidth = 1;\n\t\tc.anchor = GridBagConstraints.EAST;\n\t\tc.fill = GridBagConstraints.NONE;\n\t\tc.weightx = 0;\n\t\tgrid.setConstraints(buttonBox, c);\n\t\tgetContentPane().add(buttonBox);\n\t}","commit_id":"20a50aff947ad07549df1cfae5bc6484aa09969b","url":"https://github.com/eXist-db/exist"},{"original_method":"public void setPermissions(java.lang.String sessionId, XmldbURI resource, java.lang.String owner, java.lang.String ownerGroup, int permissions) throws java.rmi.RemoteException {\n        DBBroker broker = null;\n        Session session = getSession(sessionId);\n        Collection collection = null;\n        DocumentImpl doc = null;\n        TransactionManager transact = pool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        try {\n            broker = pool.get(session.getUser());\n            org.exist.security.SecurityManager manager = pool\n                    .getSecurityManager();\n            collection = broker.openCollection(resource, Lock.WRITE_LOCK);\n            if (collection == null) {\n// TODO check XML/Binary resource\n//                doc = (DocumentImpl) broker.openDocument(resource, Lock.WRITE_LOCK);\n                doc = (DocumentImpl) broker.getXMLResource(resource, Lock.WRITE_LOCK);\n                if (doc == null)\n                    throw new RemoteException(\"document or collection \"\n                            + resource + \" not found\");\n                LOG.debug(\"changing permissions on document \" + resource);\n                Permission perm = doc.getPermissions();\n                if (perm.getOwner().equals(session.getUser().getName())\n                || manager.hasAdminPrivileges(session.getUser())) {\n                    if (owner != null) {\n                        perm.setOwner(owner);\n                        perm.setGroup(ownerGroup);\n                    }\n                    perm.setPermissions(permissions);\n// TODO check XML/Binary resource\n//                    broker.storeDocument(transaction, doc);\n                    broker.storeXMLResource(transaction, doc);\n                    transact.commit(transaction);\n                    broker.flush();\n                    return;\n//                    return true;\n                }\n                transact.abort(transaction);\n                throw new PermissionDeniedException(\"not allowed to change permissions\");\n            }\n            LOG.debug(\"changing permissions on collection \" + resource);\n            Permission perm = collection.getPermissions();\n            if (perm.getOwner().equals(session.getUser().getName())\n            || manager.hasAdminPrivileges(session.getUser())) {\n                perm.setPermissions(permissions);\n                if (owner != null) {\n                    perm.setOwner(owner);\n                    perm.setGroup(ownerGroup);\n                }\n                transaction.registerLock(collection.getLock(), Lock.WRITE_LOCK);\n                broker.saveCollection(transaction, collection);\n                transact.commit(transaction);\n                broker.flush();\n                return;\n            }\n            transact.abort(transaction);\n            throw new PermissionDeniedException(\"not allowed to change permissions\");\n        } catch (IOException e) {\n            transact.abort(transaction);\n            throw new RemoteException(e.getMessage());\n        } catch (PermissionDeniedException e) {\n            transact.abort(transaction);\n            throw new RemoteException(e.getMessage());\n        } catch (TransactionException e) {\n            throw new RemoteException(e.getMessage());\n        } catch (EXistException e) {\n            throw new RemoteException(e.getMessage());\n        } finally {\n            if(doc != null)\n                doc.getUpdateLock().release(Lock.WRITE_LOCK);\n            pool.release(broker);\n        }\n    }","id":47320,"modified_method":"public void setPermissions(java.lang.String sessionId, XmldbURI resource, java.lang.String owner, java.lang.String ownerGroup, int permissions) throws java.rmi.RemoteException {\n        DBBroker broker = null;\n        Session session = getSession(sessionId);\n        Collection collection = null;\n        DocumentImpl doc = null;\n        TransactionManager transact = pool.getTransactionManager();\n        Txn transaction = transact.beginTransaction();\n        try {\n            broker = pool.get(session.getUser());\n            org.exist.security.SecurityManager manager = pool.getSecurityManager();\n            collection = broker.openCollection(resource, Lock.WRITE_LOCK);\n            if (collection == null) {\n// TODO check XML/Binary resource\n//                doc = (DocumentImpl) broker.openDocument(resource, Lock.WRITE_LOCK);\n                doc = (DocumentImpl) broker.getXMLResource(resource, Lock.WRITE_LOCK);\n                if (doc == null)\n                    throw new RemoteException(\"document or collection \"\n                            + resource + \" not found\");\n                LOG.debug(\"changing permissions on document \" + resource);\n                Permission perm = doc.getPermissions();\n                if (perm.getOwner().equals(session.getUser())\n                || manager.hasAdminPrivileges(session.getUser())) {\n                    if (owner != null) {\n                        perm.setOwner(owner);\n                        perm.setGroup(ownerGroup);\n                    }\n                    perm.setPermissions(permissions);\n// TODO check XML/Binary resource\n//                    broker.storeDocument(transaction, doc);\n                    broker.storeXMLResource(transaction, doc);\n                    transact.commit(transaction);\n                    broker.flush();\n                    return;\n//                    return true;\n                }\n                transact.abort(transaction);\n                throw new PermissionDeniedException(\"not allowed to change permissions\");\n            }\n            LOG.debug(\"changing permissions on collection \" + resource);\n            Permission perm = collection.getPermissions();\n            if (perm.getOwner().equals(session.getUser())\n            || manager.hasAdminPrivileges(session.getUser())) {\n                perm.setPermissions(permissions);\n                if (owner != null) {\n                    perm.setOwner(owner);\n                    perm.setGroup(ownerGroup);\n                }\n                transaction.registerLock(collection.getLock(), Lock.WRITE_LOCK);\n                broker.saveCollection(transaction, collection);\n                transact.commit(transaction);\n                broker.flush();\n                return;\n            }\n            transact.abort(transaction);\n            throw new PermissionDeniedException(\"not allowed to change permissions\");\n        } catch (IOException e) {\n            transact.abort(transaction);\n            throw new RemoteException(e.getMessage());\n        } catch (PermissionDeniedException e) {\n            transact.abort(transaction);\n            throw new RemoteException(e.getMessage());\n        } catch (TransactionException e) {\n            throw new RemoteException(e.getMessage());\n        } catch (EXistException e) {\n            throw new RemoteException(e.getMessage());\n        } finally {\n            if(doc != null)\n                doc.getUpdateLock().release(Lock.WRITE_LOCK);\n            pool.release(broker);\n        }\n    }","commit_id":"703a2014cdafb5666f026e563b6f500fb0f2020d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testGetCollection() {\n    \ttry {\n\t        Class<?> cl = Class.forName(DB_DRIVER);\n\t        Database database = (Database) cl.newInstance();\n\t        DatabaseManager.registerDatabase(database);\n\t\n\t        Collection rootCollection = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION, \"admin\", null);\n\t\n\t        CollectionManagementService cms = (CollectionManagementService) rootCollection.getService(\n\t                \"CollectionManagementService\", \"1.0\");\n\t        Collection adminCollection = cms.createCollection(ADMIN_COLLECTION_NAME);\n\t        UserManagementService ums = (UserManagementService) rootCollection.getService(\"UserManagementService\", \"1.0\");\n\t        if (ums != null) {\n\t\n\t            Permission p = PermissionFactory.getPermission();\n\t            p.setPermissions(Permission.USER_STRING + \"=+read,+write,\" + Permission.GROUP_STRING + \"=-read,-write,\" + Permission.OTHER_STRING + \"=-read,-write\");\n\t            ums.setPermissions(adminCollection, p);\n\t\n\t            Collection guestCollection = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION + \"/\" + ADMIN_COLLECTION_NAME, \"guest\",\n\t                    \"guest\");\n\t\n\t            Resource resource = guestCollection.createResource(\"testguest\", \"BinaryResource\");\n\t            resource.setContent(\"123\".getBytes());\n\t            try {\n\t                guestCollection.storeResource(resource);\n\t                fail();\n\t            } catch (XMLDBException e) {\n\t\n\t            }\n\t\n\t            cms.removeCollection(ADMIN_COLLECTION_NAME);\n\t        }\n        } catch (Exception e) {            \n            fail(e.getMessage()); \n        }\n    }","id":47321,"modified_method":"public void testGetCollection() {\n    \ttry {\n\t        Class<?> cl = Class.forName(DB_DRIVER);\n\t        Database database = (Database) cl.newInstance();\n\t        DatabaseManager.registerDatabase(database);\n\t\n\t        Collection rootCollection = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION, \"admin\", \"\");\n\t\n\t        CollectionManagementService cms = (CollectionManagementService) rootCollection.getService(\n\t                \"CollectionManagementService\", \"1.0\");\n\t        Collection adminCollection = cms.createCollection(ADMIN_COLLECTION_NAME);\n\t        UserManagementService ums = (UserManagementService) rootCollection.getService(\"UserManagementService\", \"1.0\");\n\t        if (ums != null) {\n\t\n\t            Permission p = PermissionFactory.getPermission();\n\t            p.setPermissions(Permission.USER_STRING + \"=+read,+write,\" + Permission.GROUP_STRING + \"=-read,-write,\" + Permission.OTHER_STRING + \"=-read,-write\");\n\t            ums.setPermissions(adminCollection, p);\n\t\n\t            Collection guestCollection = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION + \"/\" + ADMIN_COLLECTION_NAME, \"guest\",\n\t                    \"guest\");\n\t\n\t            Resource resource = guestCollection.createResource(\"testguest\", \"BinaryResource\");\n\t            resource.setContent(\"123\".getBytes());\n\t            try {\n\t                guestCollection.storeResource(resource);\n\t                fail();\n\t            } catch (XMLDBException e) {\n\t\n\t            }\n\t\n\t            cms.removeCollection(ADMIN_COLLECTION_NAME);\n\t        }\n        } catch (Exception e) {            \n            fail(e.getMessage()); \n        }\n    }","commit_id":"703a2014cdafb5666f026e563b6f500fb0f2020d","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Change permissions for a resource.\n\t */\n\tpublic void setPermissions(Collection child, Permission perms) throws XMLDBException {\n\t\tString path = ((RemoteCollection) child).getPath();\n\t\ttry {\n            List<Object> params = new ArrayList<Object>(4);\n\t\t\tparams.add(path);\n\t\t\tparams.add(perms.getOwner());\n\t\t\tparams.add(perms.getOwnerGroup());\n\t\t\tparams.add(new Integer(perms.getPermissions()));\n\t\t\tparent.getClient().execute(\"setPermissions\", params);\n\t\t} catch (XmlRpcException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t}\n    }","id":47322,"modified_method":"/**\n\t * Change permissions for a resource.\n\t */\n\tpublic void setPermissions(Collection child, Permission perms) throws XMLDBException {\n\t\tString path = ((RemoteCollection) child).getPath();\n\t\ttry {\n            List<Object> params = new ArrayList<Object>(4);\n\t\t\tparams.add(path);\n\t\t\tparams.add(perms.getOwner().getName());\n\t\t\tparams.add(perms.getOwnerGroup().getName());\n\t\t\tparams.add(new Integer(perms.getPermissions()));\n\t\t\tparent.getClient().execute(\"setPermissions\", params);\n\t\t} catch (XmlRpcException e) {\n\t\t\tthrow new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e);\n\t\t}\n    }","commit_id":"703a2014cdafb5666f026e563b6f500fb0f2020d","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>ejb<\/code>\n     */\n    public static boolean isEjbPackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"ejb\" );\n    }","id":47323,"modified_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>ejb<\/code>\n     */\n    public static boolean isEjbPackaging( MavenProject mavenProject )\n    {\n        return \"ejb\".equals( mavenProject.getPackaging() );\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param mavenProject not null\n     * @return true if project packaging equals <code>pom<\/code>\n     */\n    public static boolean isPomPackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"pom\" );\n    }","id":47324,"modified_method":"/**\n     * @param mavenProject not null\n     * @return true if project packaging equals <code>pom<\/code>\n     */\n    public static boolean isPomPackaging( MavenProject mavenProject )\n    {\n        return \"pom\".equals( mavenProject.getPackaging() );\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>maven-plugin<\/code>\n     */\n    public static boolean isMavenPluginPackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"maven-plugin\" );\n    }","id":47325,"modified_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>maven-plugin<\/code>\n     */\n    public static boolean isMavenPluginPackaging( MavenProject mavenProject )\n    {\n        return \"maven-plugin\".equals( mavenProject.getPackaging() );\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>bundle<\/code>\n     */\n    public static boolean isBundlePackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"bundle\" );\n    }","id":47326,"modified_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>bundle<\/code>\n     */\n    public static boolean isBundlePackaging( MavenProject mavenProject )\n    {\n        return \"bundle\".equals( mavenProject.getPackaging() );\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>ear<\/code>\n     */\n    public static boolean isEarPackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"ear\" );\n    }","id":47327,"modified_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals <code>ear<\/code>\n     */\n    public static boolean isEarPackaging( MavenProject mavenProject )\n    {\n        return \"ear\".equals( mavenProject.getPackaging() );\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals one of several packaging types \n     *         including  <code>jar<\/code>, <code>maven-plugin<\/code>, <code>ejb<\/code>, or\n     *         <code>bundle<\/code>\n     */\n    public static boolean isJarPackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"jar\" )\n            || isEjbPackaging( mavenProject )\n            || isMavenPluginPackaging( mavenProject )\n            || isBundlePackaging( mavenProject )\n            ;\n    }","id":47328,"modified_method":"/**\n     * @param mavenProject\n     * @return true if project packaging equals one of several packaging types \n     *         including  <code>jar<\/code>, <code>maven-plugin<\/code>, <code>ejb<\/code>, or\n     *         <code>bundle<\/code>\n     */\n    public static boolean isJarPackaging( MavenProject mavenProject )\n    {\n        return \"jar\".equals( mavenProject.getPackaging() )\n            || isEjbPackaging( mavenProject )\n            || isMavenPluginPackaging( mavenProject )\n            || isBundlePackaging( mavenProject )\n            ;\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @param mavenProject not null\n     * @return true if project packaging equals <code>war<\/code>\n     */\n    public static boolean isWarPackaging( MavenProject mavenProject )\n    {\n        return mavenProject.getPackaging().toLowerCase().equals( \"war\" );\n    }","id":47329,"modified_method":"/**\n     * @param mavenProject not null\n     * @return true if project packaging equals <code>war<\/code>\n     */\n    public static boolean isWarPackaging( MavenProject mavenProject )\n    {\n        return \"war\".equals( mavenProject.getPackaging() );\n    }","commit_id":"f6060dfed49d388170bbcc6d75c1fe1d06acc432","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n  Expr opt(final QueryContext ctx, final VarScope scp) throws QueryException {\n    if(oneOf(sig, Function.FOLD_LEFT, Function.FOLD_RIGHT, Function.FOR_EACH)\n        && allAreValues() && expr[0].size() < UNROLL_LIMIT) {\n      // unroll the loop\n      ctx.compInfo(QueryText.OPTUNROLL, this);\n      final Value seq = (Value) expr[0];\n      final int len = (int) seq.size();\n\n      // fn:for-each(...)\n      if (sig == Function.FOR_EACH) {\n        final Expr[] results = new Expr[len];\n        for(int i = 0; i < len; i++) {\n          results[i] = new DynFuncCall(info, expr[1], seq.itemAt(i)).optimize(ctx, scp);\n        }\n        return new List(info, results).optimize(ctx, scp);\n      }\n\n      // folds\n      Expr e = expr[1];\n      if (sig == Function.FOLD_LEFT) {\n        for (final Item it : seq)\n          e = new DynFuncCall(info, expr[2], e, it).optimize(ctx, scp);\n      } else {\n        for (int i = len; --i >= 0;)\n          e = new DynFuncCall(info, expr[2], seq.itemAt(i), e).optimize(ctx, scp);\n      }\n      return e;\n    }\n\n    if(sig == Function.FUNCTION_LOOKUP) {\n      for(final StaticFunc sf : ctx.funcs.funcs()) sf.compile(ctx);\n      if(allAreValues()) return lookup(ctx, info);\n    }\n    return this;\n  }","id":47330,"modified_method":"@Override\n  Expr opt(final QueryContext ctx, final VarScope scp) throws QueryException {\n    if(oneOf(sig, Function.FOLD_LEFT, Function.FOLD_RIGHT, Function.FOR_EACH)\n        && allAreValues() && expr[0].size() < UNROLL_LIMIT) {\n      // unroll the loop\n      ctx.compInfo(QueryText.OPTUNROLL, this);\n      final Value seq = (Value) expr[0];\n      final int len = (int) seq.size();\n\n      // fn:for-each(...)\n      if (sig == Function.FOR_EACH) {\n        final Expr[] results = new Expr[len];\n        for(int i = 0; i < len; i++) {\n          results[i] = new DynFuncCall(info, expr[1], seq.itemAt(i)).optimize(ctx, scp);\n        }\n        return new List(info, results).optimize(ctx, scp);\n      }\n\n      // folds\n      Expr e = expr[1];\n      if (sig == Function.FOLD_LEFT) {\n        for (final Item it : seq)\n          e = new DynFuncCall(info, expr[2], e, it).optimize(ctx, scp);\n      } else {\n        for (int i = len; --i >= 0;)\n          e = new DynFuncCall(info, expr[2], seq.itemAt(i), e).optimize(ctx, scp);\n      }\n      return e;\n    }\n\n    if(sig == Function.FUNCTION_LOOKUP) {\n      for(final StaticFunc sf : ctx.funcs.funcs()) sf.compile(ctx);\n    }\n    return this;\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Let optimize(final QueryContext ctx, final VarScope scp) throws QueryException {\n    if(!score && expr instanceof TypeCheck) {\n      final TypeCheck tc = (TypeCheck) expr;\n      if(tc.isRedundant(var) || var.adoptCheck(tc.type, tc.promote)) {\n        ctx.compInfo(OPTCAST, tc.type);\n        expr = tc.expr;\n      }\n    }\n\n    type = score ? SeqType.DBL : expr.type();\n    var.refineType(type, ctx, info);\n    if(var.checksType() && expr.isValue()) {\n      expr = var.checkType((Value) expr, ctx, info);\n      var.refineType(expr.type(), ctx, info);\n    }\n    size = score ? 1 : expr.size();\n    return this;\n  }","id":47331,"modified_method":"@Override\n  public Let optimize(final QueryContext ctx, final VarScope scp) throws QueryException {\n    if(!score && expr instanceof TypeCheck) {\n      final TypeCheck tc = (TypeCheck) expr;\n      if(tc.isRedundant(var) || var.adoptCheck(tc.type, tc.promote)) {\n        ctx.compInfo(OPTCAST, tc.type);\n        expr = tc.expr;\n      }\n    }\n\n    type = score ? SeqType.DBL : expr.type();\n    var.refineType(type, ctx, info);\n    if(var.checksType() && expr.isValue()) {\n      expr = var.checkType((Value) expr, ctx, info, true);\n      var.refineType(expr.type(), ctx, info);\n    }\n    size = score ? 1 : expr.size();\n    return this;\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Item item(final QueryContext ctx, final InputInfo ii) throws QueryException {\n    final Expr fn = expr[expr.length - 1];\n    final FItem f = (FItem) checkType(fn.item(ctx, ii), FuncType.ANY_FUN);\n    final FuncType ft = f.funcType();\n\n    final int arity = expr.length + holes.length - 1;\n    if(f.arity() != arity) throw INVARITY.get(ii, f, arity);\n    final Expr[] args = new Expr[arity];\n\n    final VarScope scp = new VarScope(sc);\n    final Var[] vars = new Var[holes.length];\n    int p = -1;\n    for(int i = 0; i < holes.length; i++) {\n      while(++p < holes[i]) args[p] = expr[p - i].value(ctx);\n      vars[i] = scp.newLocal(ctx, f.argName(holes[i]), ft.args[p], true);\n      args[p] = new VarRef(info, vars[i]);\n    }\n    while(++p < args.length) args[p] = expr[p - holes.length].value(ctx);\n\n    final Expr call = new DynFuncCall(info, f, args).optimize(ctx, scp);\n    final InlineFunc func = new InlineFunc(\n        info, ft.ret, vars, call, f.annotations(), sc, scp);\n    return func.optimize(ctx, null).item(ctx, ii);\n  }","id":47332,"modified_method":"@Override\n  public Item item(final QueryContext ctx, final InputInfo ii) throws QueryException {\n    final Expr fn = expr[expr.length - 1];\n    final FItem f = (FItem) checkType(fn.item(ctx, ii), FuncType.ANY_FUN);\n    final FuncType ft = f.funcType();\n\n    final int arity = expr.length + holes.length - 1;\n    if(f.arity() != arity) throw INVARITY.get(ii, f, arity);\n    final Expr[] args = new Expr[arity];\n\n    final VarScope scp = new VarScope(sc);\n    final Var[] vars = new Var[holes.length];\n    int p = -1;\n    for(int i = 0; i < holes.length; i++) {\n      while(++p < holes[i]) args[p] = expr[p - i].value(ctx);\n      vars[i] = scp.newLocal(ctx, f.argName(holes[i]), null, false);\n      args[p] = new VarRef(info, vars[i]);\n      vars[i].refineType(ft.args[p], ctx, ii);\n    }\n    while(++p < args.length) args[p] = expr[p - holes.length].value(ctx);\n\n    final Expr call = new DynFuncCall(info, f, args);\n    final FuncType tp = FuncType.get(f.annotations(), vars, ft.ret);\n    return new FuncItem(sc, f.annotations(), null, vars, tp, call, false,\n        ctx.value, ctx.pos, ctx.size, scp.stackSize());\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Adds some compilation info.\n   * @param string evaluation info\n   * @param ext text text extensions\n   */\n  void compInfo(final String string, final Object... ext) {\n    String info = Util.info(string,  ext);\n    if(runtime) {\n      info = \"RUNTIME: \" + info;\n      //Util.stack(info);\n    }\n    if(verbose) compile.add(info);\n  }","id":47333,"modified_method":"/**\n   * Adds some compilation info.\n   * @param string evaluation info\n   * @param ext text text extensions\n   */\n  void compInfo(final String string, final Object... ext) {\n    String info = Util.info(string,  ext);\n    if(runtime) {\n      info = \"RUNTIME: \" + info;\n      Util.stack(info);\n    }\n    if(verbose) compile.add(info);\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Sets the value of the given variable in the current stack frame.\n   * @param var variable to bind the value to\n   * @param val value to bind\n   * @param ctx query context\n   * @param ii input info\n   * @throws QueryException if the value does not have the right type\n   */\n  public void set(final Var var, final Value val, final QueryContext ctx,\n      final InputInfo ii) throws QueryException {\n    stack[pos(var)] = var.checkType(val, ctx, ii);\n  }","id":47334,"modified_method":"/**\n   * Sets the value of the given variable in the current stack frame.\n   * @param var variable to bind the value to\n   * @param val value to bind\n   * @param ctx query context\n   * @param ii input info\n   * @throws QueryException if the value does not have the right type\n   */\n  public void set(final Var var, final Value val, final QueryContext ctx,\n      final InputInfo ii) throws QueryException {\n    stack[pos(var)] = var.checkType(val, ctx, ii, false);\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Binds the specified value to a variable.\n   * @param name variable name\n   * @param args argument array\n   * @param value value to be bound\n   * @throws QueryException query exception\n   */\n  private void bind(final QNm name, final Expr[] args, final Value value) throws QueryException {\n    // skip nulled values\n    if(value == null) return;\n\n    for(int i = 0; i < function.args.length; i++) {\n      final Var var = function.args[i];\n      if(!var.name.eq(name)) continue;\n      // casts and binds the value\n      final SeqType decl = var.declaredType();\n      final Value val = value.type().instanceOf(decl) ? value :\n        decl.cast(value, context, function.sc, null, var);\n      args[i] = var.checkType(val, context, null);\n      break;\n    }\n  }","id":47335,"modified_method":"/**\n   * Binds the specified value to a variable.\n   * @param name variable name\n   * @param args argument array\n   * @param value value to be bound\n   * @throws QueryException query exception\n   */\n  private void bind(final QNm name, final Expr[] args, final Value value) throws QueryException {\n    // skip nulled values\n    if(value == null) return;\n\n    for(int i = 0; i < function.args.length; i++) {\n      final Var var = function.args[i];\n      if(!var.name.eq(name)) continue;\n      // casts and binds the value\n      final SeqType decl = var.declaredType();\n      final Value val = value.type().instanceOf(decl) ? value :\n        decl.cast(value, context, function.sc, null, var);\n      args[i] = var.checkType(val, context, null, false);\n      break;\n    }\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks the type of this value and casts/promotes it when necessary.\n   * @param val value to be checked\n   * @param ctx query context\n   * @param ii input info\n   * @return checked and possibly cast value\n   * @throws QueryException if the check failed\n   */\n  public Value checkType(final Value val, final QueryContext ctx, final InputInfo ii)\n      throws QueryException {\n    if(!checksType() || declType.instance(val)) return val;\n    if(promote) return declType.funcConvert(ctx, sc, ii, val, true);\n    throw INVCAST.get(ii, val.type(), declType);\n  }","id":47336,"modified_method":"/**\n   * Checks the type of this value and casts/promotes it when necessary.\n   * @param val value to be checked\n   * @param ctx query context\n   * @param ii input info\n   * @param opt if the result should be optimized\n   * @return checked and possibly cast value\n   * @throws QueryException if the check failed\n   */\n  public Value checkType(final Value val, final QueryContext ctx, final InputInfo ii,\n      final boolean opt) throws QueryException {\n    if(!checksType() || declType.instance(val)) return val;\n    if(promote) return declType.funcConvert(ctx, sc, ii, val, opt);\n    throw INVCAST.get(ii, val.type(), declType);\n  }","commit_id":"39d0586618cf1dcc23e404972cdee6d5842be19f","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * calculates the context of a base independent of the covariate mode (mismatch, insertion or deletion)\n     *\n     * @param bases       the bases in the read to build the context from\n     * @param contextSize context size to use building the context\n     * @param keys        list to store the keys\n     * @param mask        mask for pulling out just the context bits\n     */\n    private static void contextWith(final byte[] bases, final int contextSize, final ArrayList<Integer> keys, final int mask) {\n\n        // the first contextSize-1 bases will not have enough previous context\n        for (int i = 1; i < contextSize && i <= bases.length; i++)\n            keys.add(-1);\n\n        if (bases.length < contextSize)\n            return;\n\n        final int newBaseOffset = 2 * (contextSize - 1) + LENGTH_BITS;\n\n        // get (and add) the key for the context starting at the first base\n        int currentKey = keyFromContext(bases, 0, contextSize);\n        keys.add(currentKey);\n\n        // if the first key was -1 then there was an N in the context; figure out how many more consecutive contexts it affects\n        int currentNPenalty = 0;\n        if (currentKey == -1) {\n            currentKey = 0;\n            currentNPenalty = contextSize - 1;\n            int offset = newBaseOffset;\n            while (bases[currentNPenalty] != 'N') {\n                final int baseIndex = BaseUtils.simpleBaseToBaseIndex(bases[currentNPenalty]);\n                currentKey |= (baseIndex << offset);\n                offset -= 2;\n                currentNPenalty--;\n            }\n        }\n\n        final int readLength = bases.length;\n        for (int currentIndex = contextSize; currentIndex < readLength; currentIndex++) {\n            final int baseIndex = BaseUtils.simpleBaseToBaseIndex(bases[currentIndex]);\n            if (baseIndex == -1) {                    // ignore non-ACGT bases\n                currentNPenalty = contextSize;\n                currentKey = 0;                       // reset the key\n            } else {\n                // push this base's contribution onto the key: shift everything 2 bits, mask out the non-context bits, and add the new base and the length in\n                currentKey = (currentKey >> 2) & mask;\n                currentKey |= (baseIndex << newBaseOffset);\n                currentKey |= contextSize;\n            }\n\n            if (currentNPenalty == 0) {\n                keys.add(currentKey);\n            } else {\n                currentNPenalty--;\n                keys.add(-1);\n            }\n        }\n    }","id":47337,"modified_method":"/**\n     * calculates the context of a base independent of the covariate mode (mismatch, insertion or deletion)\n     *\n     * @param bases       the bases in the read to build the context from\n     * @param contextSize context size to use building the context\n     * @param mask        mask for pulling out just the context bits\n     */\n    private static ArrayList<Integer> contextWith(final byte[] bases, final int contextSize, final int mask) {\n\n        final int readLength = bases.length;\n        final ArrayList<Integer> keys = new ArrayList<Integer>(readLength);\n\n        // the first contextSize-1 bases will not have enough previous context\n        for (int i = 1; i < contextSize && i <= readLength; i++)\n            keys.add(-1);\n\n        if (readLength < contextSize)\n            return keys;\n\n        final int newBaseOffset = 2 * (contextSize - 1) + LENGTH_BITS;\n\n        // get (and add) the key for the context starting at the first base\n        int currentKey = keyFromContext(bases, 0, contextSize);\n        keys.add(currentKey);\n\n        // if the first key was -1 then there was an N in the context; figure out how many more consecutive contexts it affects\n        int currentNPenalty = 0;\n        if (currentKey == -1) {\n            currentKey = 0;\n            currentNPenalty = contextSize - 1;\n            int offset = newBaseOffset;\n            while (bases[currentNPenalty] != 'N') {\n                final int baseIndex = BaseUtils.simpleBaseToBaseIndex(bases[currentNPenalty]);\n                currentKey |= (baseIndex << offset);\n                offset -= 2;\n                currentNPenalty--;\n            }\n        }\n\n        for (int currentIndex = contextSize; currentIndex < readLength; currentIndex++) {\n            final int baseIndex = BaseUtils.simpleBaseToBaseIndex(bases[currentIndex]);\n            if (baseIndex == -1) {                    // ignore non-ACGT bases\n                currentNPenalty = contextSize;\n                currentKey = 0;                       // reset the key\n            } else {\n                // push this base's contribution onto the key: shift everything 2 bits, mask out the non-context bits, and add the new base and the length in\n                currentKey = (currentKey >> 2) & mask;\n                currentKey |= (baseIndex << newBaseOffset);\n                currentKey |= contextSize;\n            }\n\n            if (currentNPenalty == 0) {\n                keys.add(currentKey);\n            } else {\n                currentNPenalty--;\n                keys.add(-1);\n            }\n        }\n\n        return keys;\n    }","commit_id":"37ac54c9204436c7df768db4a08a7900aaed4d99","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void recordValues(final GATKSAMRecord read, final ReadCovariates values) {\n\n        // store the original bases and then write Ns over low quality ones\n        final byte[] originalBases = read.getReadBases().clone();\n        final GATKSAMRecord clippedRead = ReadClipper.clipLowQualEnds(read, LOW_QUAL_TAIL, ClippingRepresentation.WRITE_NS);   // Write N's over the low quality tail of the reads to avoid adding them into the context\n        \n        final boolean negativeStrand = clippedRead.getReadNegativeStrandFlag();\n        byte[] bases = clippedRead.getReadBases();\n        if (negativeStrand)\n            bases = BaseUtils.simpleReverseComplement(bases);\n\n        mismatchKeys.clear();\n        indelKeys.clear();\n        contextWith(bases, mismatchesContextSize, mismatchKeys, mismatchesKeyMask);\n        contextWith(bases, indelsContextSize, indelKeys, indelsKeyMask);\n\n        final int readLength = bases.length;\n        for (int i = 0; i < readLength; i++) {\n            final int indelKey = indelKeys.get(i);\n            values.addCovariate(mismatchKeys.get(i), indelKey, indelKey, (negativeStrand ? readLength - i - 1 : i));\n        }\n\n        // put the original bases back in\n        read.setReadBases(originalBases);\n    }","id":47338,"modified_method":"@Override\n    public void recordValues(final GATKSAMRecord read, final ReadCovariates values) {\n\n        // store the original bases and then write Ns over low quality ones\n        final byte[] originalBases = read.getReadBases().clone();\n        final GATKSAMRecord clippedRead = ReadClipper.clipLowQualEnds(read, LOW_QUAL_TAIL, ClippingRepresentation.WRITE_NS);   // Write N's over the low quality tail of the reads to avoid adding them into the context\n        \n        final boolean negativeStrand = clippedRead.getReadNegativeStrandFlag();\n        byte[] bases = clippedRead.getReadBases();\n        if (negativeStrand)\n            bases = BaseUtils.simpleReverseComplement(bases);\n\n        final ArrayList<Integer> mismatchKeys = contextWith(bases, mismatchesContextSize, mismatchesKeyMask);\n        final ArrayList<Integer> indelKeys = contextWith(bases, indelsContextSize, indelsKeyMask);\n\n        final int readLength = bases.length;\n        for (int i = 0; i < readLength; i++) {\n            final int indelKey = indelKeys.get(i);\n            values.addCovariate(mismatchKeys.get(i), indelKey, indelKey, (negativeStrand ? readLength - i - 1 : i));\n        }\n\n        // put the original bases back in\n        read.setReadBases(originalBases);\n    }","commit_id":"37ac54c9204436c7df768db4a08a7900aaed4d99","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void recordValues(final GATKSAMRecord read, final ReadCovariates values) {\n\n        final GATKSAMRecord clippedRead = ReadClipper.clipLowQualEnds(read, LOW_QUAL_TAIL, ClippingRepresentation.WRITE_NS);   // Write N's over the low quality tail of the reads to avoid adding them into the context\n        \n        final boolean negativeStrand = clippedRead.getReadNegativeStrandFlag();\n        byte[] bases = clippedRead.getReadBases();\n        if (negativeStrand)\n            bases = BaseUtils.simpleReverseComplement(bases);\n\n        final int readLength = clippedRead.getReadLength();\n        for (int i = 0; i < readLength; i++) {\n            values.addCovariate(contextWith(bases, i, mismatchesContextSize), contextWith(bases, i, insertionsContextSize), contextWith(bases, i, deletionsContextSize), (negativeStrand ? readLength - i - 1 : i));\n        }\n    }","id":47339,"modified_method":"@Override\n    public void recordValues(final GATKSAMRecord read, final ReadCovariates values) {\n\n        final GATKSAMRecord clippedRead = ReadClipper.clipLowQualEnds(read, LOW_QUAL_TAIL, ClippingRepresentation.WRITE_NS);   // Write N's over the low quality tail of the reads to avoid adding them into the context\n        \n        final boolean negativeStrand = clippedRead.getReadNegativeStrandFlag();\n        byte[] bases = clippedRead.getReadBases();\n        if (negativeStrand)\n            bases = BaseUtils.simpleReverseComplement(bases);\n\n        final int readLength = clippedRead.getReadLength();\n        for (int i = 0; i < readLength; i++) {\n            final long indelKey = contextWith(bases, i, indelsContextSize);\n            values.addCovariate(contextWith(bases, i, mismatchesContextSize), indelKey, indelKey, (negativeStrand ? readLength - i - 1 : i));\n        }\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void initialize(final RecalibrationArgumentCollection RAC) {\n        mismatchesContextSize = RAC.MISMATCHES_CONTEXT_SIZE;\n        insertionsContextSize = RAC.INSERTIONS_CONTEXT_SIZE;\n        deletionsContextSize = RAC.DELETIONS_CONTEXT_SIZE;\n        if (mismatchesContextSize > MAX_DNA_CONTEXT)\n            throw new UserException.BadArgumentValue(\"mismatches_context_size\", String.format(\"context size cannot be bigger than %d, but was %d\", MAX_DNA_CONTEXT, mismatchesContextSize));\n        if (insertionsContextSize > MAX_DNA_CONTEXT)\n            throw new UserException.BadArgumentValue(\"insertions_context_size\", String.format(\"context size cannot be bigger than %d, but was %d\", MAX_DNA_CONTEXT, insertionsContextSize));\n        if (deletionsContextSize > MAX_DNA_CONTEXT)\n            throw new UserException.BadArgumentValue(\"deletions_context_size\", String.format(\"context size cannot be bigger than %d, but was %d\", MAX_DNA_CONTEXT, deletionsContextSize));\n\n        LOW_QUAL_TAIL = RAC.LOW_QUAL_TAIL;\n        \n        if (mismatchesContextSize <= 0 || insertionsContextSize <= 0 || deletionsContextSize <= 0)\n            throw new UserException(String.format(\"Context Size must be positive, if you don't want to use the context covariate, just turn it off instead. Mismatches: %d Insertions: %d Deletions:%d\", mismatchesContextSize, insertionsContextSize, deletionsContextSize));\n    }","id":47340,"modified_method":"@Override\n    public void initialize(final RecalibrationArgumentCollection RAC) {\n        mismatchesContextSize = RAC.MISMATCHES_CONTEXT_SIZE;\n        indelsContextSize = RAC.INDELS_CONTEXT_SIZE;\n        if (mismatchesContextSize > MAX_DNA_CONTEXT)\n            throw new UserException.BadArgumentValue(\"mismatches_context_size\", String.format(\"context size cannot be bigger than %d, but was %d\", MAX_DNA_CONTEXT, mismatchesContextSize));\n        if (indelsContextSize > MAX_DNA_CONTEXT)\n            throw new UserException.BadArgumentValue(\"indels_context_size\", String.format(\"context size cannot be bigger than %d, but was %d\", MAX_DNA_CONTEXT, indelsContextSize));\n\n        LOW_QUAL_TAIL = RAC.LOW_QUAL_TAIL;\n        \n        if (mismatchesContextSize <= 0 || indelsContextSize <= 0)\n            throw new UserException(String.format(\"Context size must be positive, if you don't want to use the context covariate, just turn it off instead. Mismatches: %d Indels: %d\", mismatchesContextSize, indelsContextSize));\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = true)\n    public void testSimpleContexts() {\n        GATKSAMRecord read = ReadUtils.createRandomRead(1000);\n        GATKSAMRecord clippedRead = ReadClipper.clipLowQualEnds(read, RAC.LOW_QUAL_TAIL, ClippingRepresentation.WRITE_NS);\n        ReadCovariates readCovariates = new ReadCovariates(read.getReadLength(), 1);\n        covariate.recordValues(read, readCovariates);\n\n        verifyCovariateArray(readCovariates.getMismatchesKeySet(), RAC.MISMATCHES_CONTEXT_SIZE, clippedRead, covariate);\n        verifyCovariateArray(readCovariates.getInsertionsKeySet(), RAC.INSERTIONS_CONTEXT_SIZE, clippedRead, covariate);\n        verifyCovariateArray(readCovariates.getDeletionsKeySet(),  RAC.DELETIONS_CONTEXT_SIZE,  clippedRead, covariate);\n    }","id":47341,"modified_method":"@Test(enabled = true)\n    public void testSimpleContexts() {\n        GATKSAMRecord read = ReadUtils.createRandomRead(1000);\n        GATKSAMRecord clippedRead = ReadClipper.clipLowQualEnds(read, RAC.LOW_QUAL_TAIL, ClippingRepresentation.WRITE_NS);\n        ReadCovariates readCovariates = new ReadCovariates(read.getReadLength(), 1);\n        covariate.recordValues(read, readCovariates);\n\n        verifyCovariateArray(readCovariates.getMismatchesKeySet(), RAC.MISMATCHES_CONTEXT_SIZE, clippedRead, covariate);\n        verifyCovariateArray(readCovariates.getInsertionsKeySet(), RAC.INDELS_CONTEXT_SIZE, clippedRead, covariate);\n        verifyCovariateArray(readCovariates.getDeletionsKeySet(),  RAC.INDELS_CONTEXT_SIZE,  clippedRead, covariate);\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = false)\n    public void testCovariateGeneration() {\n        final String RGID = \"id\";\n        final int length = 10;\n        final RecalibrationArgumentCollection RAC = new RecalibrationArgumentCollection();\n        GATKSAMRecord read = ReadUtils.createRandomRead(length, false);\n        GATKSAMReadGroupRecord rg = new GATKSAMReadGroupRecord(RGID);\n        rg.setPlatform(\"illumina\");\n        read.setReadGroup(rg);\n        final byte[] mQuals = read.getBaseQualities(EventType.BASE_SUBSTITUTION);\n        final byte[] iQuals = read.getBaseQualities(EventType.BASE_INSERTION);\n        final byte[] dQuals = read.getBaseQualities(EventType.BASE_DELETION);\n\n        ReadGroupCovariate rgCov = new ReadGroupCovariate();\n        QualityScoreCovariate qsCov = new QualityScoreCovariate();\n        ContextCovariate coCov = new ContextCovariate();\n        CycleCovariate cyCov = new CycleCovariate();\n\n        rgCov.initialize(RAC);\n        qsCov.initialize(RAC);\n        coCov.initialize(RAC);\n        cyCov.initialize(RAC);\n\n        Covariate[] requestedCovariates = new Covariate[4];\n        requestedCovariates[0] = rgCov;\n        requestedCovariates[1] = qsCov;\n        requestedCovariates[2] = coCov;\n        requestedCovariates[3] = cyCov;\n\n        ReadCovariates rc = RecalDataManager.computeCovariates(read, requestedCovariates);\n\n        // check that the length is correct\n        Assert.assertEquals(rc.getMismatchesKeySet().length, length);\n        Assert.assertEquals(rc.getInsertionsKeySet().length, length);\n        Assert.assertEquals(rc.getDeletionsKeySet().length, length);\n\n        for (int i = 0; i < length; i++) {\n            // check that read group is always the same\n            Assert.assertEquals(rgCov.formatKey(rc.getMismatchesKeySet(i)[0]), RGID);\n            Assert.assertEquals(rgCov.formatKey(rc.getInsertionsKeySet(i)[0]), RGID);\n            Assert.assertEquals(rgCov.formatKey(rc.getDeletionsKeySet(i)[0]),  RGID);\n\n            // check quality score\n            Assert.assertEquals(qsCov.formatKey(rc.getMismatchesKeySet(i)[1]), \"\" + mQuals[i]);\n            Assert.assertEquals(qsCov.formatKey(rc.getInsertionsKeySet(i)[1]), \"\" + iQuals[i]);\n            Assert.assertEquals(qsCov.formatKey(rc.getDeletionsKeySet(i)[1]),  \"\" + dQuals[i]);\n\n            // check context\n            Assert.assertEquals(coCov.formatKey(rc.getMismatchesKeySet(i)[2]), ContextCovariateUnitTest.expectedContext(read, i, RAC.MISMATCHES_CONTEXT_SIZE));\n            Assert.assertEquals(coCov.formatKey(rc.getInsertionsKeySet(i)[2]), ContextCovariateUnitTest.expectedContext(read, i, RAC.INSERTIONS_CONTEXT_SIZE));\n            Assert.assertEquals(coCov.formatKey(rc.getDeletionsKeySet(i)[2]),  ContextCovariateUnitTest.expectedContext(read, i, RAC.DELETIONS_CONTEXT_SIZE));\n\n            // check cycle\n            Assert.assertEquals(cyCov.formatKey(rc.getMismatchesKeySet(i)[3]), \"\" + (i+1));\n            Assert.assertEquals(cyCov.formatKey(rc.getInsertionsKeySet(i)[3]), \"\" + (i+1));\n            Assert.assertEquals(cyCov.formatKey(rc.getDeletionsKeySet(i)[3]),  \"\" + (i+1));\n        }\n\n    }","id":47342,"modified_method":"@Test(enabled = false)\n    public void testCovariateGeneration() {\n        final String RGID = \"id\";\n        final int length = 10;\n        final RecalibrationArgumentCollection RAC = new RecalibrationArgumentCollection();\n        GATKSAMRecord read = ReadUtils.createRandomRead(length, false);\n        GATKSAMReadGroupRecord rg = new GATKSAMReadGroupRecord(RGID);\n        rg.setPlatform(\"illumina\");\n        read.setReadGroup(rg);\n        final byte[] mQuals = read.getBaseQualities(EventType.BASE_SUBSTITUTION);\n        final byte[] iQuals = read.getBaseQualities(EventType.BASE_INSERTION);\n        final byte[] dQuals = read.getBaseQualities(EventType.BASE_DELETION);\n\n        ReadGroupCovariate rgCov = new ReadGroupCovariate();\n        QualityScoreCovariate qsCov = new QualityScoreCovariate();\n        ContextCovariate coCov = new ContextCovariate();\n        CycleCovariate cyCov = new CycleCovariate();\n\n        rgCov.initialize(RAC);\n        qsCov.initialize(RAC);\n        coCov.initialize(RAC);\n        cyCov.initialize(RAC);\n\n        Covariate[] requestedCovariates = new Covariate[4];\n        requestedCovariates[0] = rgCov;\n        requestedCovariates[1] = qsCov;\n        requestedCovariates[2] = coCov;\n        requestedCovariates[3] = cyCov;\n\n        ReadCovariates rc = RecalDataManager.computeCovariates(read, requestedCovariates);\n\n        // check that the length is correct\n        Assert.assertEquals(rc.getMismatchesKeySet().length, length);\n        Assert.assertEquals(rc.getInsertionsKeySet().length, length);\n        Assert.assertEquals(rc.getDeletionsKeySet().length, length);\n\n        for (int i = 0; i < length; i++) {\n            // check that read group is always the same\n            Assert.assertEquals(rgCov.formatKey(rc.getMismatchesKeySet(i)[0]), RGID);\n            Assert.assertEquals(rgCov.formatKey(rc.getInsertionsKeySet(i)[0]), RGID);\n            Assert.assertEquals(rgCov.formatKey(rc.getDeletionsKeySet(i)[0]),  RGID);\n\n            // check quality score\n            Assert.assertEquals(qsCov.formatKey(rc.getMismatchesKeySet(i)[1]), \"\" + mQuals[i]);\n            Assert.assertEquals(qsCov.formatKey(rc.getInsertionsKeySet(i)[1]), \"\" + iQuals[i]);\n            Assert.assertEquals(qsCov.formatKey(rc.getDeletionsKeySet(i)[1]),  \"\" + dQuals[i]);\n\n            // check context\n            Assert.assertEquals(coCov.formatKey(rc.getMismatchesKeySet(i)[2]), ContextCovariateUnitTest.expectedContext(read, i, RAC.MISMATCHES_CONTEXT_SIZE));\n            Assert.assertEquals(coCov.formatKey(rc.getInsertionsKeySet(i)[2]), ContextCovariateUnitTest.expectedContext(read, i, RAC.INDELS_CONTEXT_SIZE));\n            Assert.assertEquals(coCov.formatKey(rc.getDeletionsKeySet(i)[2]),  ContextCovariateUnitTest.expectedContext(read, i, RAC.INDELS_CONTEXT_SIZE));\n\n            // check cycle\n            Assert.assertEquals(cyCov.formatKey(rc.getMismatchesKeySet(i)[3]), \"\" + (i+1));\n            Assert.assertEquals(cyCov.formatKey(rc.getInsertionsKeySet(i)[3]), \"\" + (i+1));\n            Assert.assertEquals(cyCov.formatKey(rc.getDeletionsKeySet(i)[3]),  \"\" + (i+1));\n        }\n\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public GATKReportTable generateReportTable() {\n        GATKReportTable argumentsTable = new GATKReportTable(\"Arguments\", \"Recalibration argument collection values used in this run\", 2);\n        argumentsTable.addColumn(\"Argument\");\n        argumentsTable.addColumn(RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME);\n        argumentsTable.addRowID(\"covariate\", true);\n        argumentsTable.set(\"covariate\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, (COVARIATES == null) ? \"null\" : Utils.join(\",\", COVARIATES));\n        argumentsTable.addRowID(\"standard_covs\", true);\n        argumentsTable.set(\"standard_covs\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, USE_STANDARD_COVARIATES);\n        argumentsTable.addRowID(\"run_without_dbsnp\", true);\n        argumentsTable.set(\"run_without_dbsnp\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, RUN_WITHOUT_DBSNP);\n        argumentsTable.addRowID(\"solid_recal_mode\", true);\n        argumentsTable.set(\"solid_recal_mode\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, SOLID_RECAL_MODE);\n        argumentsTable.addRowID(\"solid_nocall_strategy\", true);\n        argumentsTable.set(\"solid_nocall_strategy\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, SOLID_NOCALL_STRATEGY);\n        argumentsTable.addRowID(\"mismatches_context_size\", true);\n        argumentsTable.set(\"mismatches_context_size\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, MISMATCHES_CONTEXT_SIZE);\n        argumentsTable.addRowID(\"insertions_context_size\", true);\n        argumentsTable.set(\"insertions_context_size\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, INSERTIONS_CONTEXT_SIZE);\n        argumentsTable.addRowID(\"deletions_context_size\", true);\n        argumentsTable.set(\"deletions_context_size\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, DELETIONS_CONTEXT_SIZE);\n        argumentsTable.addRowID(\"mismatches_default_quality\", true);\n        argumentsTable.set(\"mismatches_default_quality\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, MISMATCHES_DEFAULT_QUALITY);\n        argumentsTable.addRowID(\"insertions_default_quality\", true);\n        argumentsTable.set(\"insertions_default_quality\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, INSERTIONS_DEFAULT_QUALITY);\n        argumentsTable.addRowID(\"low_quality_tail\", true);\n        argumentsTable.set(\"low_quality_tail\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, LOW_QUAL_TAIL);\n        argumentsTable.addRowID(\"default_platform\", true);\n        argumentsTable.set(\"default_platform\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, DEFAULT_PLATFORM);\n        argumentsTable.addRowID(\"force_platform\", true);\n        argumentsTable.set(\"force_platform\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, FORCE_PLATFORM);\n        argumentsTable.addRowID(\"quantizing_levels\", true);\n        argumentsTable.set(\"quantizing_levels\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, QUANTIZING_LEVELS);\n        argumentsTable.addRowID(\"keep_intermediate_files\", true);\n        argumentsTable.set(\"keep_intermediate_files\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, KEEP_INTERMEDIATE_FILES);\n        argumentsTable.addRowID(\"no_plots\", true);\n        argumentsTable.set(\"no_plots\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, NO_PLOTS);\n        argumentsTable.addRowID(\"recalibration_report\", true);\n        argumentsTable.set(\"recalibration_report\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, recalibrationReport == null ? \"null\" : recalibrationReport.getAbsolutePath());\n        return argumentsTable;\n    }","id":47343,"modified_method":"public GATKReportTable generateReportTable() {\n        GATKReportTable argumentsTable = new GATKReportTable(\"Arguments\", \"Recalibration argument collection values used in this run\", 2);\n        argumentsTable.addColumn(\"Argument\");\n        argumentsTable.addColumn(RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME);\n        argumentsTable.addRowID(\"covariate\", true);\n        argumentsTable.set(\"covariate\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, (COVARIATES == null) ? \"null\" : Utils.join(\",\", COVARIATES));\n        argumentsTable.addRowID(\"standard_covs\", true);\n        argumentsTable.set(\"standard_covs\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, USE_STANDARD_COVARIATES);\n        argumentsTable.addRowID(\"run_without_dbsnp\", true);\n        argumentsTable.set(\"run_without_dbsnp\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, RUN_WITHOUT_DBSNP);\n        argumentsTable.addRowID(\"solid_recal_mode\", true);\n        argumentsTable.set(\"solid_recal_mode\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, SOLID_RECAL_MODE);\n        argumentsTable.addRowID(\"solid_nocall_strategy\", true);\n        argumentsTable.set(\"solid_nocall_strategy\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, SOLID_NOCALL_STRATEGY);\n        argumentsTable.addRowID(\"mismatches_context_size\", true);\n        argumentsTable.set(\"mismatches_context_size\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, MISMATCHES_CONTEXT_SIZE);\n        argumentsTable.addRowID(\"indels_context_size\", true);\n        argumentsTable.set(\"indels_context_size\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, INDELS_CONTEXT_SIZE);\n        argumentsTable.addRowID(\"mismatches_default_quality\", true);\n        argumentsTable.set(\"mismatches_default_quality\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, MISMATCHES_DEFAULT_QUALITY);\n        argumentsTable.addRowID(\"insertions_default_quality\", true);\n        argumentsTable.set(\"insertions_default_quality\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, INSERTIONS_DEFAULT_QUALITY);\n        argumentsTable.addRowID(\"low_quality_tail\", true);\n        argumentsTable.set(\"low_quality_tail\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, LOW_QUAL_TAIL);\n        argumentsTable.addRowID(\"default_platform\", true);\n        argumentsTable.set(\"default_platform\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, DEFAULT_PLATFORM);\n        argumentsTable.addRowID(\"force_platform\", true);\n        argumentsTable.set(\"force_platform\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, FORCE_PLATFORM);\n        argumentsTable.addRowID(\"quantizing_levels\", true);\n        argumentsTable.set(\"quantizing_levels\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, QUANTIZING_LEVELS);\n        argumentsTable.addRowID(\"keep_intermediate_files\", true);\n        argumentsTable.set(\"keep_intermediate_files\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, KEEP_INTERMEDIATE_FILES);\n        argumentsTable.addRowID(\"no_plots\", true);\n        argumentsTable.set(\"no_plots\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, NO_PLOTS);\n        argumentsTable.addRowID(\"recalibration_report\", true);\n        argumentsTable.set(\"recalibration_report\", RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME, recalibrationReport == null ? \"null\" : recalibrationReport.getAbsolutePath());\n        return argumentsTable;\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Parses the arguments table from the GATK Report and creates a RAC object with the proper initialization values\n     *\n     * @param table the GATKReportTable containing the arguments and its corresponding values\n     * @return a RAC object properly initialized with all the objects in the table\n     */\n    private RecalibrationArgumentCollection initializeArgumentCollectionTable(GATKReportTable table) {\n        final RecalibrationArgumentCollection RAC = new RecalibrationArgumentCollection();\n\n        for ( int i = 0; i < table.getNumRows(); i++ ) {\n            final String argument = table.get(i, \"Argument\").toString();\n            Object value = table.get(i, RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME);\n            if (value.equals(\"null\"))\n                value = null;                                                                                           // generic translation of null values that were printed out as strings | todo -- add this capability to the GATKReport\n\n            if (argument.equals(\"covariate\") && value != null)\n                RAC.COVARIATES = value.toString().split(\",\");\n\n            else if (argument.equals(\"standard_covs\"))\n                RAC.USE_STANDARD_COVARIATES = Boolean.parseBoolean((String) value);\n\n            else if (argument.equals(\"solid_recal_mode\"))\n                RAC.SOLID_RECAL_MODE = RecalDataManager.SOLID_RECAL_MODE.recalModeFromString((String) value);\n\n            else if (argument.equals(\"solid_nocall_strategy\"))\n                RAC.SOLID_NOCALL_STRATEGY = RecalDataManager.SOLID_NOCALL_STRATEGY.nocallStrategyFromString((String) value);\n\n            else if (argument.equals(\"mismatches_context_size\"))\n                RAC.MISMATCHES_CONTEXT_SIZE = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"insertions_context_size\"))\n                RAC.INSERTIONS_CONTEXT_SIZE = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"deletions_context_size\"))\n                RAC.DELETIONS_CONTEXT_SIZE = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"mismatches_default_quality\"))\n                RAC.MISMATCHES_DEFAULT_QUALITY = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"insertions_default_quality\"))\n                RAC.INSERTIONS_DEFAULT_QUALITY = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"deletions_default_quality\"))\n                RAC.DELETIONS_DEFAULT_QUALITY = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"low_quality_tail\"))\n                RAC.LOW_QUAL_TAIL = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"default_platform\"))\n                RAC.DEFAULT_PLATFORM = (String) value;\n\n            else if (argument.equals(\"force_platform\"))\n                RAC.FORCE_PLATFORM = (String) value;\n\n            else if (argument.equals(\"quantizing_levels\"))\n                RAC.QUANTIZING_LEVELS = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"keep_intermediate_files\"))\n                RAC.KEEP_INTERMEDIATE_FILES = Boolean.parseBoolean((String) value);\n\n            else if (argument.equals(\"no_plots\"))\n                RAC.NO_PLOTS = Boolean.parseBoolean((String) value);\n\n            else if (argument.equals(\"recalibration_report\"))\n                RAC.recalibrationReport = (value == null) ? null : new File((String) value);\n        }\n\n        return RAC;\n    }","id":47344,"modified_method":"/**\n     * Parses the arguments table from the GATK Report and creates a RAC object with the proper initialization values\n     *\n     * @param table the GATKReportTable containing the arguments and its corresponding values\n     * @return a RAC object properly initialized with all the objects in the table\n     */\n    private RecalibrationArgumentCollection initializeArgumentCollectionTable(GATKReportTable table) {\n        final RecalibrationArgumentCollection RAC = new RecalibrationArgumentCollection();\n\n        for ( int i = 0; i < table.getNumRows(); i++ ) {\n            final String argument = table.get(i, \"Argument\").toString();\n            Object value = table.get(i, RecalDataManager.ARGUMENT_VALUE_COLUMN_NAME);\n            if (value.equals(\"null\"))\n                value = null;                                                                                           // generic translation of null values that were printed out as strings | todo -- add this capability to the GATKReport\n\n            if (argument.equals(\"covariate\") && value != null)\n                RAC.COVARIATES = value.toString().split(\",\");\n\n            else if (argument.equals(\"standard_covs\"))\n                RAC.USE_STANDARD_COVARIATES = Boolean.parseBoolean((String) value);\n\n            else if (argument.equals(\"solid_recal_mode\"))\n                RAC.SOLID_RECAL_MODE = RecalDataManager.SOLID_RECAL_MODE.recalModeFromString((String) value);\n\n            else if (argument.equals(\"solid_nocall_strategy\"))\n                RAC.SOLID_NOCALL_STRATEGY = RecalDataManager.SOLID_NOCALL_STRATEGY.nocallStrategyFromString((String) value);\n\n            else if (argument.equals(\"mismatches_context_size\"))\n                RAC.MISMATCHES_CONTEXT_SIZE = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"indels_context_size\"))\n                RAC.INDELS_CONTEXT_SIZE = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"mismatches_default_quality\"))\n                RAC.MISMATCHES_DEFAULT_QUALITY = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"insertions_default_quality\"))\n                RAC.INSERTIONS_DEFAULT_QUALITY = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"deletions_default_quality\"))\n                RAC.DELETIONS_DEFAULT_QUALITY = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"low_quality_tail\"))\n                RAC.LOW_QUAL_TAIL = Byte.parseByte((String) value);\n\n            else if (argument.equals(\"default_platform\"))\n                RAC.DEFAULT_PLATFORM = (String) value;\n\n            else if (argument.equals(\"force_platform\"))\n                RAC.FORCE_PLATFORM = (String) value;\n\n            else if (argument.equals(\"quantizing_levels\"))\n                RAC.QUANTIZING_LEVELS = Integer.parseInt((String) value);\n\n            else if (argument.equals(\"keep_intermediate_files\"))\n                RAC.KEEP_INTERMEDIATE_FILES = Boolean.parseBoolean((String) value);\n\n            else if (argument.equals(\"no_plots\"))\n                RAC.NO_PLOTS = Boolean.parseBoolean((String) value);\n\n            else if (argument.equals(\"recalibration_report\"))\n                RAC.recalibrationReport = (value == null) ? null : new File((String) value);\n        }\n\n        return RAC;\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = false)\n    public void testOutput() {\n        final int length = 100;\n\n        List<Byte> quals = new ArrayList<Byte>(QualityUtils.MAX_QUAL_SCORE + 1);\n        List<Long> counts = new ArrayList<Long>(QualityUtils.MAX_QUAL_SCORE + 1);\n\n        for (int i = 0;  i<= QualityUtils.MAX_QUAL_SCORE; i++) {\n            quals.add((byte) i);\n            counts.add(1L);\n        }\n\n        final QuantizationInfo quantizationInfo = new QuantizationInfo(quals, counts);\n        final RecalibrationArgumentCollection RAC = new RecalibrationArgumentCollection();\n        final LinkedHashMap<BQSRKeyManager, Map<Long, RecalDatum>> keysAndTablesMap = new LinkedHashMap<BQSRKeyManager, Map<Long, RecalDatum>>();\n\n        quantizationInfo.noQuantization();\n        final List<Covariate> requiredCovariates = new LinkedList<Covariate>();\n        final List<Covariate> optionalCovariates = new LinkedList<Covariate>();\n\n        final ReadGroupCovariate rgCovariate = new ReadGroupCovariate();\n        rgCovariate.initialize(RAC);\n        requiredCovariates.add(rgCovariate);\n        final BQSRKeyManager rgKeyManager = new BQSRKeyManager(requiredCovariates, optionalCovariates);\n        keysAndTablesMap.put(rgKeyManager, new HashMap<Long, RecalDatum>());\n\n        final QualityScoreCovariate qsCovariate = new QualityScoreCovariate();\n        qsCovariate.initialize(RAC);\n        requiredCovariates.add(qsCovariate);\n        final BQSRKeyManager qsKeyManager = new BQSRKeyManager(requiredCovariates, optionalCovariates);\n        keysAndTablesMap.put(qsKeyManager, new HashMap<Long, RecalDatum>());\n\n        final ContextCovariate cxCovariate = new ContextCovariate();\n        cxCovariate.initialize(RAC);\n        optionalCovariates.add(cxCovariate);\n        final CycleCovariate cyCovariate = new CycleCovariate();\n        cyCovariate.initialize(RAC);\n        optionalCovariates.add(cyCovariate);\n        BQSRKeyManager cvKeyManager = new BQSRKeyManager(requiredCovariates, optionalCovariates);\n        keysAndTablesMap.put(cvKeyManager, new HashMap<Long, RecalDatum>());\n\n        final Covariate[] requestedCovariates = new Covariate[requiredCovariates.size() + optionalCovariates.size()];\n        int covariateIndex = 0;\n        for (final Covariate cov : requiredCovariates)\n            requestedCovariates[covariateIndex++] = cov;\n        for (final Covariate cov : optionalCovariates)\n            requestedCovariates[covariateIndex++] = cov;\n\n        final GATKSAMReadGroupRecord rg = new GATKSAMReadGroupRecord(\"id\");\n        rg.setPlatform(\"illumina\");\n        final GATKSAMRecord read = ReadUtils.createRandomRead(length, false);\n        read.setReadGroup(rg);\n        final byte [] readQuals = new byte[length];\n        for (int i = 0; i < length; i++)\n            readQuals[i] = 20;\n        read.setBaseQualities(readQuals);\n\n\n        final int expectedKeys = expectedNumberOfKeys(4, length, RAC.INSERTIONS_CONTEXT_SIZE, RAC.MISMATCHES_CONTEXT_SIZE);\n        int nKeys = 0;                                                                                                  // keep track of how many keys were produced\n        final ReadCovariates rc = RecalDataManager.computeCovariates(read, requestedCovariates);\n        for (int offset = 0; offset < length; offset++) {\n            for (Map.Entry<BQSRKeyManager, Map<Long, RecalDatum>> entry : keysAndTablesMap.entrySet()) {\n                BQSRKeyManager keyManager = entry.getKey();\n                Map<Long, RecalDatum> table = entry.getValue();\n\n                final int numOptionalCovariates = keyManager.getNumOptionalCovariates();\n                if (numOptionalCovariates == 0) {\n                    table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_SUBSTITUTION, -1), RecalDatum.createRandomRecalDatum(10000, 10));\n                    table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_INSERTION, -1), RecalDatum.createRandomRecalDatum(100000, 10));\n                    table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_DELETION, -1), RecalDatum.createRandomRecalDatum(100000, 10));\n                    nKeys += 3;\n                } else {\n                    for (int j = 0; j < numOptionalCovariates; j++) {\n                        table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_SUBSTITUTION, j), RecalDatum.createRandomRecalDatum(10000, 10));\n                        table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_INSERTION, j), RecalDatum.createRandomRecalDatum(100000, 10));\n                        table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_DELETION, j), RecalDatum.createRandomRecalDatum(100000, 10));\n                        nKeys += 3;\n                    }\n                }\n            }\n        }\n        Assert.assertEquals(nKeys, expectedKeys);\n\n        RecalibrationReport report = new RecalibrationReport(quantizationInfo, keysAndTablesMap, RAC.generateReportTable(), RAC);\n\n        File output = new File(\"RecalibrationReportUnitTestOutuput.grp\");\n        PrintStream out;\n        try {\n            out = new PrintStream(output);\n        } catch (FileNotFoundException e) {\n            throw new ReviewedStingException(\"couldn't create the file \" + output, e);\n        }\n        report.output(out);\n\n        RecalibrationReport loadedReport = new RecalibrationReport(output);\n\n        Assert.assertTrue(report.equals(loadedReport));\n        if (!output.delete())\n            throw new ReviewedStingException(\"File could not be deleted \" + output);\n    }","id":47345,"modified_method":"@Test(enabled = false)\n    public void testOutput() {\n        final int length = 100;\n\n        List<Byte> quals = new ArrayList<Byte>(QualityUtils.MAX_QUAL_SCORE + 1);\n        List<Long> counts = new ArrayList<Long>(QualityUtils.MAX_QUAL_SCORE + 1);\n\n        for (int i = 0;  i<= QualityUtils.MAX_QUAL_SCORE; i++) {\n            quals.add((byte) i);\n            counts.add(1L);\n        }\n\n        final QuantizationInfo quantizationInfo = new QuantizationInfo(quals, counts);\n        final RecalibrationArgumentCollection RAC = new RecalibrationArgumentCollection();\n        final LinkedHashMap<BQSRKeyManager, Map<Long, RecalDatum>> keysAndTablesMap = new LinkedHashMap<BQSRKeyManager, Map<Long, RecalDatum>>();\n\n        quantizationInfo.noQuantization();\n        final List<Covariate> requiredCovariates = new LinkedList<Covariate>();\n        final List<Covariate> optionalCovariates = new LinkedList<Covariate>();\n\n        final ReadGroupCovariate rgCovariate = new ReadGroupCovariate();\n        rgCovariate.initialize(RAC);\n        requiredCovariates.add(rgCovariate);\n        final BQSRKeyManager rgKeyManager = new BQSRKeyManager(requiredCovariates, optionalCovariates);\n        keysAndTablesMap.put(rgKeyManager, new HashMap<Long, RecalDatum>());\n\n        final QualityScoreCovariate qsCovariate = new QualityScoreCovariate();\n        qsCovariate.initialize(RAC);\n        requiredCovariates.add(qsCovariate);\n        final BQSRKeyManager qsKeyManager = new BQSRKeyManager(requiredCovariates, optionalCovariates);\n        keysAndTablesMap.put(qsKeyManager, new HashMap<Long, RecalDatum>());\n\n        final ContextCovariate cxCovariate = new ContextCovariate();\n        cxCovariate.initialize(RAC);\n        optionalCovariates.add(cxCovariate);\n        final CycleCovariate cyCovariate = new CycleCovariate();\n        cyCovariate.initialize(RAC);\n        optionalCovariates.add(cyCovariate);\n        BQSRKeyManager cvKeyManager = new BQSRKeyManager(requiredCovariates, optionalCovariates);\n        keysAndTablesMap.put(cvKeyManager, new HashMap<Long, RecalDatum>());\n\n        final Covariate[] requestedCovariates = new Covariate[requiredCovariates.size() + optionalCovariates.size()];\n        int covariateIndex = 0;\n        for (final Covariate cov : requiredCovariates)\n            requestedCovariates[covariateIndex++] = cov;\n        for (final Covariate cov : optionalCovariates)\n            requestedCovariates[covariateIndex++] = cov;\n\n        final GATKSAMReadGroupRecord rg = new GATKSAMReadGroupRecord(\"id\");\n        rg.setPlatform(\"illumina\");\n        final GATKSAMRecord read = ReadUtils.createRandomRead(length, false);\n        read.setReadGroup(rg);\n        final byte [] readQuals = new byte[length];\n        for (int i = 0; i < length; i++)\n            readQuals[i] = 20;\n        read.setBaseQualities(readQuals);\n\n\n        final int expectedKeys = expectedNumberOfKeys(4, length, RAC.INDELS_CONTEXT_SIZE, RAC.MISMATCHES_CONTEXT_SIZE);\n        int nKeys = 0;                                                                                                  // keep track of how many keys were produced\n        final ReadCovariates rc = RecalDataManager.computeCovariates(read, requestedCovariates);\n        for (int offset = 0; offset < length; offset++) {\n            for (Map.Entry<BQSRKeyManager, Map<Long, RecalDatum>> entry : keysAndTablesMap.entrySet()) {\n                BQSRKeyManager keyManager = entry.getKey();\n                Map<Long, RecalDatum> table = entry.getValue();\n\n                final int numOptionalCovariates = keyManager.getNumOptionalCovariates();\n                if (numOptionalCovariates == 0) {\n                    table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_SUBSTITUTION, -1), RecalDatum.createRandomRecalDatum(10000, 10));\n                    table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_INSERTION, -1), RecalDatum.createRandomRecalDatum(100000, 10));\n                    table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_DELETION, -1), RecalDatum.createRandomRecalDatum(100000, 10));\n                    nKeys += 3;\n                } else {\n                    for (int j = 0; j < numOptionalCovariates; j++) {\n                        table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_SUBSTITUTION, j), RecalDatum.createRandomRecalDatum(10000, 10));\n                        table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_INSERTION, j), RecalDatum.createRandomRecalDatum(100000, 10));\n                        table.put(keyManager.createMasterKey(rc.getMismatchesKeySet(offset), EventType.BASE_DELETION, j), RecalDatum.createRandomRecalDatum(100000, 10));\n                        nKeys += 3;\n                    }\n                }\n            }\n        }\n        Assert.assertEquals(nKeys, expectedKeys);\n\n        RecalibrationReport report = new RecalibrationReport(quantizationInfo, keysAndTablesMap, RAC.generateReportTable(), RAC);\n\n        File output = new File(\"RecalibrationReportUnitTestOutuput.grp\");\n        PrintStream out;\n        try {\n            out = new PrintStream(output);\n        } catch (FileNotFoundException e) {\n            throw new ReviewedStingException(\"couldn't create the file \" + output, e);\n        }\n        report.output(out);\n\n        RecalibrationReport loadedReport = new RecalibrationReport(output);\n\n        Assert.assertTrue(report.equals(loadedReport));\n        if (!output.delete())\n            throw new ReviewedStingException(\"File could not be deleted \" + output);\n    }","commit_id":"f4643a54760ba12d889e9fc39944d6387e3c072b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void store() throws PermissionDeniedException, IOException, TriggerException, EXistException, SAXException, LockException, AuthenticationException {\n    \tBrokerPool pool = null;\n    \tDBBroker broker = null;    \n    \ttry {\n            pool = BrokerPool.getInstance();\n            Subject admin = pool.getSecurityManager().authenticate(\"admin\", \"\");\n            broker = pool.get(admin);\n            Collection collection = broker.getOrCreateCollection(null, TestConstants.TEST_COLLECTION_URI);\n            IndexInfo info = collection.validateXMLResource(null, broker, TestConstants.TEST_XML_URI, XML);\n            //TODO : unlock the collection here ?\n            collection.store(null, broker, info, XML, false);\n            @SuppressWarnings(\"unused\")\n\t\t\torg.exist.dom.persistent.DocumentImpl doc = info.getDocument();\n            broker.flush();\n            broker.saveCollection(null, collection);\n        } finally {\n            if (pool != null) {\n                pool.release(broker);\n            }\n        }\n    }","id":47346,"modified_method":"@Test\n    public void store() throws PermissionDeniedException, IOException, EXistException, SAXException, LockException, AuthenticationException {\n    \tBrokerPool pool = null;\n    \tDBBroker broker = null;\n        TransactionManager txnMgr = null;\n        Txn txn = null;\n    \ttry {\n            pool = BrokerPool.getInstance();\n            txnMgr = pool.getTransactionManager();\n            txn = txnMgr.beginTransaction();\n            Subject admin = pool.getSecurityManager().authenticate(\"admin\", \"\");\n            broker = pool.get(admin);\n            Collection collection = broker.getOrCreateCollection(txn, TestConstants.TEST_COLLECTION_URI);\n            IndexInfo info = collection.validateXMLResource(txn, broker, TestConstants.TEST_XML_URI, XML);\n            //TODO : unlock the collection here ?\n            collection.store(txn, broker, info, XML, false);\n            @SuppressWarnings(\"unused\")\n            org.exist.dom.persistent.DocumentImpl doc = info.getDocument();\n            broker.flush();\n            broker.saveCollection(txn, collection);\n            txnMgr.commit(txn);\n        } finally {\n            if(txn != null) {\n                txn.close();\n            }\n            if (pool != null) {\n                pool.release(broker);\n            }\n        }\n    }","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"private void loadDirectory(File folder, Collection col) throws Exception {\n    \t//System.out.println(\"******* loadDirectory \"+folder.getName());\n    \tif (!(folder.exists() && folder.canRead()))\n    \t\treturn;\n    \t\n    \tCollection current = broker.getOrCreateCollection(null, col.getURI().append(folder.getName()));\n\t\tbroker.saveCollection(null, current);\n    \t\t\n        File[] files = folder.listFiles();\n        for (File file : files) {\n        \tif (file.isDirectory()) {\n        \t\tif (file.getName().equals(\"CVS\"))\n            \t\tcontinue; //ignore\n        \t\t\n        \t\tloadDirectory(file, current);\n        \t} else {\n        \t\tloadFile(file, current);\n        \t}\n        }\n    }","id":47347,"modified_method":"private void loadDirectory(Txn txn, File folder, Collection col) throws Exception {\n    \t//System.out.println(\"******* loadDirectory \"+folder.getName());\n    \tif (!(folder.exists() && folder.canRead()))\n    \t\treturn;\n    \t\n    \tCollection current = broker.getOrCreateCollection(null, col.getURI().append(folder.getName()));\n\t\tbroker.saveCollection(null, current);\n    \t\t\n        File[] files = folder.listFiles();\n        for (File file : files) {\n        \tif (file.isDirectory()) {\n        \t\tif (file.getName().equals(\"CVS\"))\n            \t\tcontinue; //ignore\n        \t\t\n        \t\tloadDirectory(txn, file, current);\n        \t} else {\n        \t\tloadFile(txn, file, current);\n        \t}\n        }\n    }","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"private void loadFile(File file, Collection col) throws Exception {\n    \t//System.out.println(\"******* loadFile \"+file.getName());\n    \t\n    \tif (file.getName().endsWith(\".html\") \n    \t\t\t|| file.getName().endsWith(\".xsd\")\n    \t\t\t|| file.getName().equals(\"badxml.xml\")\n    \t\t\t|| file.getName().equals(\"BCisInvalid.xml\")\n    \t\t\t|| file.getName().equals(\"InvalidUmlaut.xml\")\n    \t\t\t|| file.getName().equals(\"InvalidXMLId.xml\")\n    \t\t\t|| file.getName().equals(\"invalid-xml.xml\")\n\t\t\t)\n    \t\treturn;\n    \t\n    \tif (!(file.exists() && file.canRead()))\n    \t\treturn;\n    \t\n        MimeType mime = getMimeTable().getContentTypeFor( file.getName() );\n        if (mime != null && mime.isXMLType()) {\n        \tIndexInfo info = col.validateXMLResource(null, broker, \n            \t\tXmldbURI.create(file.getName()), \n            \t\tnew InputSource(new FileInputStream(file))\n            \t);\n            //info.getDocument().getMetadata().setMimeType();\n        \t\n        \tFileInputStream is = new FileInputStream(file);\n        \ttry {\n        \t    col.store(null, broker, info, new InputSource(is), false);\n        \t} finally {\n        \t    is.close();\n        \t}\n        } else {\n        \tTransactionManager txManager = db.getTransactionManager();\n        \tTxn txn = txManager.beginTransaction();\n\n            try {\n                FileInputStream is = new FileInputStream(file);\n                try {\n                    col.addBinaryResource(txn, broker,\n                            XmldbURI.create(file.getName()),\n                            is,\n                            MimeType.BINARY_TYPE.getName(), file.length());\n                } finally {\n                    is.close();\n                }\n                txManager.commit(txn);\n            } finally {\n                txManager.close(txn);\n            }\n        }\n    \t//System.out.println(file);\n    }","id":47348,"modified_method":"private void loadFile(Txn txn, File file, Collection col) throws Exception {\n    \t//System.out.println(\"******* loadFile \"+file.getName());\n    \t\n    \tif (file.getName().endsWith(\".html\") \n    \t\t\t|| file.getName().endsWith(\".xsd\")\n    \t\t\t|| file.getName().equals(\"badxml.xml\")\n    \t\t\t|| file.getName().equals(\"BCisInvalid.xml\")\n    \t\t\t|| file.getName().equals(\"InvalidUmlaut.xml\")\n    \t\t\t|| file.getName().equals(\"InvalidXMLId.xml\")\n    \t\t\t|| file.getName().equals(\"invalid-xml.xml\")\n\t\t\t)\n    \t\treturn;\n    \t\n    \tif (!(file.exists() && file.canRead()))\n    \t\treturn;\n    \t\n        MimeType mime = getMimeTable().getContentTypeFor( file.getName() );\n\n        if (mime != null && mime.isXMLType()) {\n            IndexInfo info = col.validateXMLResource(txn, broker,\n                    XmldbURI.create(file.getName()),\n                    new InputSource(new FileInputStream(file))\n                );\n            //info.getDocument().getMetadata().setMimeType();\n\n            FileInputStream is = new FileInputStream(file);\n            try {\n                col.store(txn, broker, info, new InputSource(is), false);\n            } finally {\n                is.close();\n            }\n        } else {\n            FileInputStream is = new FileInputStream(file);\n            try {\n                col.addBinaryResource(txn, broker,\n                        XmldbURI.create(file.getName()),\n                        is,\n                        MimeType.BINARY_TYPE.getName(), file.length());\n            } finally {\n                is.close();\n            }\n        }\n    \t//System.out.println(file);\n    }","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"public void init() throws Exception {\n\t\tdb = BrokerPool.getInstance();\n\t\t\n\t\tbroker = db.get(db.getSecurityManager().getSystemSubject());\n\t\tAssert.assertNotNull(broker);\n\t\t\n\t\tcollection = broker.getOrCreateCollection(null, QT3TS_case.QT3_URI);\n\t\tAssert.assertNotNull(collection);\n\t\tbroker.saveCollection(null, collection);\n    }","id":47349,"modified_method":"public void init() throws EXistException, PermissionDeniedException, IOException, TriggerException {\n\t\tdb = BrokerPool.getInstance();\n\t\t\n\t\tbroker = db.get(db.getSecurityManager().getSystemSubject());\n\t\tAssert.assertNotNull(broker);\n\n        TransactionManager txnMgr = db.getTransactionManager();\n        Txn txn = null;\n        try {\n            txn = txnMgr.beginTransaction();\n            collection = broker.getOrCreateCollection(txn, QT3TS_case.QT3_URI);\n            Assert.assertNotNull(collection);\n            broker.saveCollection(txn, collection);\n            txnMgr.commit(txn);\n        } finally {\n            txn.close();\n        }\n    }","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"public void load() throws Exception {\n        File folder = new File(QT3TS_case.FOLDER);\n        \n        File[] files = folder.listFiles();\n        for (File file : files) {\n        \tif (file.isDirectory()) {\n        \t\tif (file.getName().equals(\"CVS\") \n        \t\t\t\t|| file.getName().equals(\"drivers\")\n    \t\t\t\t)\n            \t\tcontinue; //ignore\n        \t\t\n        \t\tloadDirectory(file, collection);\n        \t} else {\n\t\t\t\tif (file.getName().equals(\".project\"))\n\t\t\t\t\tcontinue; //ignore\n        \t\t\n\t\t\t\tloadFile(file, collection);\n        \t}\n        }\n    }","id":47350,"modified_method":"public void load() throws Exception {\n        File folder = new File(QT3TS_case.FOLDER);\n        File[] files = folder.listFiles();\n\n\n        final TransactionManager txnMgr = broker.getBrokerPool().getTransactionManager();\n        Txn txn = null;\n        try {\n            txn = txnMgr.beginTransaction();\n\n            for(File file : files) {\n                if(file.isDirectory()) {\n                    if(file.getName().equals(\"CVS\")\n                        || file.getName().equals(\"drivers\")\n                        )\n                        continue; //ignore\n\n                    loadDirectory(txn, file, collection);\n                } else {\n                    if(file.getName().equals(\".project\"))\n                        continue; //ignore\n\n                    loadFile(txn, file, collection);\n                }\n            }\n\n            txnMgr.commit(txn);\n        } finally {\n            if(txn != null) {\n                txn.close();\n            }\n        }\n    }","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"private void addRecord(DBBroker broker, String xupdate) throws TriggerException {\n        MutableDocumentSet docs = new DefaultDocumentSet();\n        docs.add(doc);\n        try {\n            // IMPORTANT: temporarily disable triggers on the collection.\n            // We would end up in infinite recursion if we don't do that\n            getCollection().setTriggersEnabled(false);\n            // create the XUpdate processor\n            XUpdateProcessor processor = new XUpdateProcessor(broker, docs, AccessContext.TRIGGER);\n            // process the XUpdate\n            Modification modifications[] = processor.parse(new InputSource(new StringReader(xupdate)));\n            for (int i = 0; i < modifications.length; i++)\n                modifications[i].process(null);\n            broker.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new TriggerException(e.getMessage(), e);\n        } finally {\n            // IMPORTANT: reenable trigger processing for the collection.\n            getCollection().setTriggersEnabled(true);\n        }\n\n\t}","id":47351,"modified_method":"private void addRecord(DBBroker broker, String xupdate) throws TriggerException {\n        MutableDocumentSet docs = new DefaultDocumentSet();\n        docs.add(doc);\n        TransactionManager transactMgr = broker.getBrokerPool().getTransactionManager();\n        Txn transaction = transactMgr.beginTransaction();\n        try {\n            // IMPORTANT: temporarily disable triggers on the collection.\n            // We would end up in infinite recursion if we don't do that\n            getCollection().setTriggersEnabled(false);\n            // create the XUpdate processor\n            XUpdateProcessor processor = new XUpdateProcessor(broker, docs, AccessContext.TRIGGER);\n            // process the XUpdate\n            Modification modifications[] = processor.parse(new InputSource(new StringReader(xupdate)));\n            for (int i = 0; i < modifications.length; i++) {\n                modifications[i].process(transaction);\n            }\n            transactMgr.commit(transaction);\n\n            broker.flush();\n        } catch (Exception e) {\n            transactMgr.abort(transaction);\n            e.printStackTrace();\n            throw new TriggerException(e.getMessage(), e);\n        } finally {\n            transaction.close();\n            // IMPORTANT: reenable trigger processing for the collection.\n            getCollection().setTriggersEnabled(true);\n        }\n\n\t}","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"public void configure(DBBroker broker, org.exist.collections.Collection parent, Map<String, List<?>> parameters) throws TriggerException {\n        super.configure(broker, parent, parameters);\n        XmldbURI docPath = XmldbURI.create(\"messages.xml\");\n        System.out.println(\"TestTrigger prepares\");\n        TransactionManager transactMgr = broker.getBrokerPool().getTransactionManager();\n        Txn transaction = transactMgr.beginTransaction();\n        try {\n            this.doc = parent.getDocument(broker, docPath);\n            if (this.doc == null) {\n                \n                \n        \n                LOG.debug(\"creating new file for collection contents\");\n\n                // IMPORTANT: temporarily disable triggers on the collection.\n                // We would end up in infinite recursion if we don't do that\n                parent.setTriggersEnabled(false);\n                IndexInfo info = parent.validateXMLResource(transaction, broker, docPath, TEMPLATE);\n                //TODO : unlock the collection here ?\n                parent.store(transaction, broker, info, TEMPLATE, false);\n                this.doc = info.getDocument();\n\n                transactMgr.commit(transaction);\n            }\n        } catch (Exception e) {\n            transactMgr.abort(transaction);\n            throw new TriggerException(e.getMessage(), e);\n        } finally {\n            parent.setTriggersEnabled(true);\n        }\n    }","id":47352,"modified_method":"public void configure(DBBroker broker, org.exist.collections.Collection parent, Map<String, List<?>> parameters) throws TriggerException {\n        super.configure(broker, parent, parameters);\n        XmldbURI docPath = XmldbURI.create(\"messages.xml\");\n        System.out.println(\"TestTrigger prepares\");\n        TransactionManager transactMgr = broker.getBrokerPool().getTransactionManager();\n        Txn transaction = transactMgr.beginTransaction();\n        try {\n            this.doc = parent.getDocument(broker, docPath);\n            if (this.doc == null) {\n                LOG.debug(\"creating new file for collection contents\");\n\n                // IMPORTANT: temporarily disable triggers on the collection.\n                // We would end up in infinite recursion if we don't do that\n                parent.setTriggersEnabled(false);\n                IndexInfo info = parent.validateXMLResource(transaction, broker, docPath, TEMPLATE);\n                //TODO : unlock the collection here ?\n                parent.store(transaction, broker, info, TEMPLATE, false);\n                this.doc = info.getDocument();\n            }\n            transactMgr.commit(transaction);\n\n        } catch (Exception e) {\n            transactMgr.abort(transaction);\n            throw new TriggerException(e.getMessage(), e);\n        } finally {\n            transaction.close();\n            parent.setTriggersEnabled(true);\n        }\n    }","commit_id":"47b1b236ede4443b832b2c2bcf43502db3fb2067","url":"https://github.com/eXist-db/exist"},{"original_method":"protected IndexInfo init(DBBroker broker, TransactionManager mgr) {\n    \tIndexInfo info = null;\n    \ttry {\n    \t\t\n        \tTxn transaction = mgr.beginTransaction();        \n        \tSystem.out.println(\"Transaction started ...\");\n\t        \n\t        Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI);\n\t        broker.saveCollection(transaction, root);\n\t        \n\t        Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI.append(\"test2\"));\n\t        broker.saveCollection(transaction, test);\n\t        \n\t        info = test.validateXMLResource(transaction, broker, XmldbURI.create(\"test.xml\"), TEST_XML);\n\t        //TODO : unlock the collection here ?\n\t        test.store(transaction, broker, info, TEST_XML, false);\n\t\n\t        mgr.commit(transaction);\t\n\t        System.out.println(\"Transaction commited ...\");\n\t        \n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());\n\t    }  \n\t    return info;\n    }","id":47353,"modified_method":"protected IndexInfo init(DBBroker broker, TransactionManager mgr) {\n    \tIndexInfo info = null;\n    \tTxn transaction = null;\n    \ttry {\n    \t\t\n    \t\ttransaction = mgr.beginTransaction();        \n        \tSystem.out.println(\"Transaction started ...\");\n\t        \n\t        Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI);\n\t        broker.saveCollection(transaction, root);\n\t        \n\t        Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI.append(\"test2\"));\n\t        broker.saveCollection(transaction, test);\n\t        \n\t        info = test.validateXMLResource(transaction, broker, XmldbURI.create(\"test.xml\"), TEST_XML);\n\t        //TODO : unlock the collection here ?\n\t        test.store(transaction, broker, info, TEST_XML, false);\n\t\n\t        mgr.commit(transaction);\t\n\t        System.out.println(\"Transaction commited ...\");\n\t        \n\t    } catch (Exception e) {\n\t    \tmgr.abort(transaction);\n\t        fail(e.getMessage());\n\t    }  \n\t    return info;\n    }","commit_id":"861dbc032cfae3ca9c16129cbf94b74a88950fad","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);            \n            TransactionManager transact = pool.getTransactionManager();\n            \n            Txn transaction = transact.beginTransaction();            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI);\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI.append(\"test2\"));\n            broker.saveCollection(transaction, test);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n        } catch (Exception e) {            \n            fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","id":47354,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = startDB();\n        DBBroker broker = null;\n        Txn transaction = null;\n        TransactionManager transact = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);            \n            transact = pool.getTransactionManager();\n            \n            transaction = transact.beginTransaction();            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI);\n            broker.saveCollection(transaction, root);\n            \n            Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION_URI.append(\"test2\"));\n            broker.saveCollection(transaction, test);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n        } catch (Exception e) {\n        \ttransact.abort(transaction);\n            fail(e.getMessage());              \n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"861dbc032cfae3ca9c16129cbf94b74a88950fad","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean insertResource(String documentPath, byte[] grammar){\n        boolean insertIsSuccesfull = false;\n        \n        XmldbURI documentURI;\n        try{\n        \tdocumentURI = XmldbURI.xmldbUriFor(documentPath);\n        } catch(URISyntaxException e) {\n        \tthrow new IllegalArgumentException(\"Invalid URI: \"+e.getMessage());\n        }\n\n        DBBroker broker = null;\n        try {\n            MimeType mime = MimeTable.getInstance().getContentTypeFor(documentURI.lastSegment());\n            if (mime == null){\n                mime = MimeType.BINARY_TYPE;\n            }\n            \n            broker = brokerPool.get(SecurityManager.SYSTEM_USER);\n            \n            TransactionManager transact = brokerPool.getTransactionManager();\n            Txn transaction = transact.beginTransaction();\n            \n            Collection collection = broker\n                    .getOrCreateCollection(transaction, documentURI.removeLastSegment());\n            \n            broker.saveCollection(transaction, collection);\n            \n            if(mime.isXMLType()){\n                \n                IndexInfo info = collection.validateXMLResource( transaction, broker, documentURI.lastSegment() , new InputSource( new ByteArrayInputStream(grammar) ) );\n                collection.store(transaction, broker, info, new InputSource( new ByteArrayInputStream(grammar) ), false);\n                \n            } else {\n                // TODO : call mime-type stuff for good mimetypes\n                collection.addBinaryResource(transaction, broker,\n                        \t\tdocumentURI.lastSegment(), grammar, mime.getName() );\n            }\n            transact.commit(transaction);\n            \n            insertIsSuccesfull=true;\n            \n        } catch (Exception ex){\n            ex.printStackTrace();\n            logger.error(ex);\n            \n        } finally {\n            if(brokerPool!=null){\n                brokerPool.release(broker);\n            }\n        }\n        return insertIsSuccesfull;\n        \n    }","id":47355,"modified_method":"public boolean insertResource(String documentPath, byte[] grammar){\n        boolean insertIsSuccesfull = false;\n        \n        XmldbURI documentURI;\n        try{\n        \tdocumentURI = XmldbURI.xmldbUriFor(documentPath);\n        } catch(URISyntaxException e) {\n        \tthrow new IllegalArgumentException(\"Invalid URI: \"+e.getMessage());\n        }\n\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            MimeType mime = MimeTable.getInstance().getContentTypeFor(documentURI.lastSegment());\n            if (mime == null){\n                mime = MimeType.BINARY_TYPE;\n            }\n            \n            broker = brokerPool.get(SecurityManager.SYSTEM_USER);\n            \n            transact = brokerPool.getTransactionManager();\n            transaction = transact.beginTransaction();\n            \n            Collection collection = broker\n            \t//TODO : resolve URI against \"..\"\n                    .getOrCreateCollection(transaction, documentURI.removeLastSegment());\n            \n            broker.saveCollection(transaction, collection);\n            \n            if(mime.isXMLType()){\n                \n                IndexInfo info = collection.validateXMLResource( transaction, broker, documentURI.lastSegment() , new InputSource( new ByteArrayInputStream(grammar) ) );\n                collection.store(transaction, broker, info, new InputSource( new ByteArrayInputStream(grammar) ), false);\n                \n            } else {\n                // TODO : call mime-type stuff for good mimetypes\n                collection.addBinaryResource(transaction, broker,\n                        \t\tdocumentURI.lastSegment(), grammar, mime.getName() );\n            }\n            transact.commit(transaction);\n            \n            insertIsSuccesfull=true;\n            \n        } catch (Exception ex){\n        \ttransact.abort(transaction);\n            ex.printStackTrace();\n            logger.error(ex);\n            \n        } finally {\n            if(brokerPool!=null){\n                brokerPool.release(broker);\n            }\n        }\n        return insertIsSuccesfull;\n        \n    }","commit_id":"861dbc032cfae3ca9c16129cbf94b74a88950fad","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testQuery() {\n\t\t//String query = \"document()//p[. &= '\\uB2E8\\uACC4']\";\n\t\tString query =\n\t\t\t\"document()//p[. = '\\u4ED6\\u4E3A\\u8FD9\\u9879\\u5DE5\\u7A0B\\u6295\"\n\t\t\t\t+ \"\\u5165\\u4E86\\u5341\\u4E09\\u5E74\\u65F6\\u95F4\\u3002']\";\n\n\t\t// get a BrokerPool for access to the database engine\n\t\tBrokerPool pool = null;\n\t\ttry {\n\t\t\tpool = BrokerPool.getInstance();\n\t\t} catch (EXistException e1) {\n\t\t\te1.printStackTrace();\n\t\t\tfail(e1.getMessage());\n\t\t}\n\t\tUser user = pool.getSecurityManager().getUser(\"admin\");\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\t// parse the xml source\n\t\t\tbroker = pool.get(user);\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            Collection collection = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            broker.saveCollection(transaction, collection);\n\n            IndexInfo info = collection.validateXMLResource(transaction, broker, XmldbURI.create(\"test.xml\"), xml);\n            //TODO : unlock the collection here ?\n            collection.store(transaction, broker, info, xml, false);\n            transact.commit(transaction);\n            \n            // parse the query into the internal syntax tree\n\t\t\tXQueryContext context = new XQueryContext(broker, AccessContext.TEST);\n\t\t\tXQueryLexer lexer = new XQueryLexer(context, new StringReader(query));\n\t\t\tXQueryParser xparser = new XQueryParser(lexer);\n\t\t\tXQueryTreeParser treeParser = new XQueryTreeParser(context);\n\t\t\txparser.xpath();\n\t\t\tif (xparser.foundErrors()) {\n\t\t\t\tSystem.err.println(xparser.getErrorMessage());\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAST ast = xparser.getAST();\n\t\t\tSystem.out.println(\"generated AST: \" + ast.toStringTree());\n\n\t\t\tPathExpr expr = new PathExpr(context);\n\t\t\ttreeParser.xpath(ast, expr);\n\t\t\tif (treeParser.foundErrors()) {\n\t\t\t\tSystem.err.println(treeParser.getErrorMessage());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\texpr.analyze(new AnalyzeContextInfo());\n\t\t\t// execute the query\n\t\t\tSequence result = expr.eval(null, null);\n\n\t\t\t// check results\n\t\t\tSystem.out.println(\"----------------------------------\");\n\t\t\tSystem.out.println(\"found: \" + result.getItemCount());\n\t\t} catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t\tif (localDb)\n\t\t\ttry {\n\t\t\t\tBrokerPool.stop();\n\t\t\t} catch (EXistException e2) {\n\t\t\t\te2.printStackTrace();\n\t\t\t}\n\t}","id":47356,"modified_method":"public void testQuery() {\n\t\t//String query = \"document()//p[. &= '\\uB2E8\\uACC4']\";\n\t\tString query =\n\t\t\t\"document()//p[. = '\\u4ED6\\u4E3A\\u8FD9\\u9879\\u5DE5\\u7A0B\\u6295\"\n\t\t\t\t+ \"\\u5165\\u4E86\\u5341\\u4E09\\u5E74\\u65F6\\u95F4\\u3002']\";\n\n\t\t// get a BrokerPool for access to the database engine\n\t\tBrokerPool pool = null;\n\t\ttry {\n\t\t\tpool = BrokerPool.getInstance();\n\t\t} catch (EXistException e1) {\n\t\t\te1.printStackTrace();\n\t\t\tfail(e1.getMessage());\n\t\t}\n\t\tUser user = pool.getSecurityManager().getUser(\"admin\");\n\t\tDBBroker broker = null;\n\t\tTransactionManager transact = null;\n\t\tTxn transaction = null;\n\t\ttry {\n\t\t\t// parse the xml source\n\t\t\tbroker = pool.get(user);\n\t\t\ttransact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            Collection collection = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            broker.saveCollection(transaction, collection);\n\n            IndexInfo info = collection.validateXMLResource(transaction, broker, XmldbURI.create(\"test.xml\"), xml);\n            //TODO : unlock the collection here ?\n            collection.store(transaction, broker, info, xml, false);\n            transact.commit(transaction);\n\t\t} catch (Exception e) {\n\t\t\ttransact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n\t\t}\n\n\t\ttry {\n            // parse the query into the internal syntax tree\n\t\t\tXQueryContext context = new XQueryContext(broker, AccessContext.TEST);\n\t\t\tXQueryLexer lexer = new XQueryLexer(context, new StringReader(query));\n\t\t\tXQueryParser xparser = new XQueryParser(lexer);\n\t\t\tXQueryTreeParser treeParser = new XQueryTreeParser(context);\n\t\t\txparser.xpath();\n\t\t\tif (xparser.foundErrors()) {\n\t\t\t\tSystem.err.println(xparser.getErrorMessage());\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAST ast = xparser.getAST();\n\t\t\tSystem.out.println(\"generated AST: \" + ast.toStringTree());\n\n\t\t\tPathExpr expr = new PathExpr(context);\n\t\t\ttreeParser.xpath(ast, expr);\n\t\t\tif (treeParser.foundErrors()) {\n\t\t\t\tSystem.err.println(treeParser.getErrorMessage());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\texpr.analyze(new AnalyzeContextInfo());\n\t\t\t// execute the query\n\t\t\tSequence result = expr.eval(null, null);\n\n\t\t\t// check results\n\t\t\tSystem.out.println(\"----------------------------------\");\n\t\t\tSystem.out.println(\"found: \" + result.getItemCount());\n\t\t} catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t\tif (localDb)\n\t\t\ttry {\n\t\t\t\tBrokerPool.stop();\n\t\t\t} catch (EXistException e2) {\n\t\t\t\te2.printStackTrace();\n\t\t\t}\n\t}","commit_id":"861dbc032cfae3ca9c16129cbf94b74a88950fad","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * get collection object If the collection does not yet exists, it is\n     * created automatically.\n     *\n     * Wraps for cluster the resultant collection in a ClusterCollection\n     *\n     * @param name the collection's name\n     * @return The orCreateCollection value\n     * @throws org.exist.security.PermissionDeniedException\n     *          Description of the Exception\n     */\n    public Collection getOrCreateCollection(Txn transaction, XmldbURI name) throws PermissionDeniedException,\n    \tIOException {\n        Collection c=   super.getOrCreateCollection(transaction, name);\n        return c==null?null:new ClusterCollection(c);\n\n    }","id":47357,"modified_method":"/**\n\t * Returns the database collection identified by the specified path. If the\n\t * collection does not yet exist, it is created - including all ancestors.\n\t * The path should be absolute, e.g. /db/shakespeare.\n     * Wraps for cluster the resultant collection in a ClusterCollection\n     * @param transaction The transaction, which registers the acquired write locks. The locks should be released on commit/abort.\n\t * @param uri The collection's URI\n\t * @return The collection or <code>null<\/code> if no collection matches the path\n\t * @throws PermissionDeniedException\n\t * @throws IOException\n\t */    \n    public Collection getOrCreateCollection(Txn transaction, XmldbURI uri) throws PermissionDeniedException,\n    \tIOException {\n        Collection c=   super.getOrCreateCollection(transaction, uri);\n        return c==null?null:new ClusterCollection(c);\n\n    }","commit_id":"861dbc032cfae3ca9c16129cbf94b74a88950fad","url":"https://github.com/eXist-db/exist"},{"original_method":"private void store(DBBroker broker, String docName, String data) throws PermissionDeniedException, EXistException, TriggerException, SAXException, LockException, TransactionException {\n\t\tTransactionManager mgr = pool.getTransactionManager();\n\t\tTxn transaction = mgr.beginTransaction();        \n\t\tSystem.out.println(\"Transaction started ...\");\n\t\t\n\t\ttry {\n\t\t\tCollection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n\t\t\tbroker.saveCollection(transaction, root);\n\t\t\t\n\t\t\tIndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(docName), data);\n\t\t\t//TODO : unlock the collection here ?\n\t\t\troot.store(transaction, broker, info, data, false);\n\t   \n\t\t\tmgr.commit(transaction);\n\t\t\t\n\t\t\tDocumentImpl doc = root.getDocument(broker, XmldbURI.create(docName));\n\t\t    broker.getSerializer().serialize(doc);\n\t\t} catch (IOException e) {\n\t\t\tfail();\n\t\t}\n\t}","id":47358,"modified_method":"private void store(DBBroker broker, String docName, String data) throws PermissionDeniedException, EXistException, TriggerException, SAXException, LockException, TransactionException {\n\t\tTransactionManager mgr = pool.getTransactionManager();\n\t\tTxn transaction = mgr.beginTransaction();        \n\t\tSystem.out.println(\"Transaction started ...\");\n\t\t\n\t\ttry {\n\t\t\tCollection root = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n\t\t\tbroker.saveCollection(transaction, root);\n\t\t\t\n\t\t\tIndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(docName), data);\n\t\t\t//TODO : unlock the collection here ?\n\t\t\troot.store(transaction, broker, info, data, false);\n\t   \n\t\t\tmgr.commit(transaction);\n\t\t\t\n\t\t\tDocumentImpl doc = root.getDocument(broker, XmldbURI.create(docName));\n\t\t    broker.getSerializer().serialize(doc);\n\t\t} catch (IOException e) {\n\t\t\tmgr.abort(transaction);\n\t\t\tfail();\n\t\t}\n\t}","commit_id":"861dbc032cfae3ca9c16129cbf94b74a88950fad","url":"https://github.com/eXist-db/exist"},{"original_method":"public void moveCollection(Collection collection, Collection destination, String newName) \n\tthrows PermissionDeniedException, LockException {\n\t    if (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    if(collection.getName().equals(ROOT_COLLECTION))\n\t        throw new PermissionDeniedException(\"Cannot move the db root collection\");\n\t    if(!collection.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move collection \" +\n\t                collection.getName());\n\t    if(!destination.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t                destination.getName());\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        String name = collection.getName();\n\t        Collection parent = collection.getParent(this);\n\t        parent.removeCollection(name.substring(name.lastIndexOf(\"/\") + 1));\n\t\t    \n\t        collectionsDb.getCollectionCache().remove(collection);\n\t\t    Value key;\n\t\t\ttry {\n\t\t\t\tkey = new Value(name.getBytes(\"UTF-8\"));\n\t\t\t} catch (UnsupportedEncodingException uee) {\n\t\t\t\tkey = new Value(name.getBytes());\n\t\t\t}\t\n\t\t\tcollectionsDb.remove(key);\n\t\t\t\n\t\t\tname = destination.getName() + '/' + newName;\n\t\t    collection.setName(name);\n\t\t    collection.setCreationTime(System.currentTimeMillis());\n\t\t    collection.correctResourcePaths();\n\t\t    \n\t\t    destination.addCollection(collection);\n\t\t    saveCollection(parent);\n\t\t    if(parent != destination)\n\t\t        saveCollection(destination);\n\t\t    saveCollection(collection);\n\t    } catch (ReadOnlyException e) {\n            throw new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n        } finally {\n\t        lock.release();\n\t    }\n\t}","id":47359,"modified_method":"public void moveCollection(Collection collection, Collection destination, String newName) \n\tthrows PermissionDeniedException, LockException {\n\t    if (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    if(collection.getName().equals(ROOT_COLLECTION))\n\t        throw new PermissionDeniedException(\"Cannot move the db root collection\");\n\t    if(!collection.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to move collection \" +\n\t                collection.getName());\n\t    if(!destination.getPermissions().validate(user, Permission.WRITE))\n\t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t                destination.getName());\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        String name = collection.getName();\n\t        Collection parent = collection.getParent(this);\n\t        if(parent != null)\n\t            parent.removeCollection(name.substring(name.lastIndexOf(\"/\") + 1));\n\t\t    \n\t        collectionsDb.getCollectionCache().remove(collection);\n\t\t    Value key;\n\t\t\ttry {\n\t\t\t\tkey = new Value(name.getBytes(\"UTF-8\"));\n\t\t\t} catch (UnsupportedEncodingException uee) {\n\t\t\t\tkey = new Value(name.getBytes());\n\t\t\t}\t\n\t\t\tcollectionsDb.remove(key);\n\t\t\t\n\t\t    collection.setName(destination.getName() + '/' + newName);\n\t\t    collection.setCreationTime(System.currentTimeMillis());\n\t\t    collection.correctResourcePaths();\n\t\t    \n\t\t    destination.addCollection(collection);\n\t\t    if(parent != null)\n\t\t        saveCollection(parent);\n\t\t    if(parent != destination)\n\t\t        saveCollection(destination);\n\t\t    saveCollection(collection);\n\t\t    \n\t\t    String childName;\n\t\t    Collection child;\n\t\t    for(Iterator i = collection.collectionIterator(); i.hasNext(); ) {\n\t\t        childName = (String)i.next();\n\t\t        child = getCollection(name + '/' + childName);\n\t\t        if(child == null)\n\t\t            LOG.warn(\"Child collection \" + childName + \" not found\");\n\t\t        else\n\t\t            moveCollection(child, collection, childName);\n\t\t    }\n\t    } catch (ReadOnlyException e) {\n            throw new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n        } finally {\n\t        lock.release();\n\t    }\n\t}","commit_id":"01ebf288d9a4032496783a54d4ecebc2d484bb93","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public String authenticate(String command, Map<String, Object[]> params, HttpSession session, String remoteAddress, String responseType, StringBuilder auditTrailSb, final HttpServletResponse resp) throws ServerApiException {\n\n        // FIXME: ported from ApiServlet, refactor and cleanup\n        final String[] username = (String[])params.get(ApiConstants.USERNAME);\n        final String[] password = (String[])params.get(ApiConstants.PASSWORD);\n        String[] domainIdArr = (String[])params.get(ApiConstants.DOMAIN_ID);\n\n        if (domainIdArr == null) {\n            domainIdArr = (String[])params.get(ApiConstants.DOMAIN__ID);\n        }\n        final String[] domainName = (String[])params.get(ApiConstants.DOMAIN);\n        Long domainId = null;\n        if ((domainIdArr != null) && (domainIdArr.length > 0)) {\n            try {\n                //check if UUID is passed in for domain\n                domainId = _apiServer.fetchDomainId(domainIdArr[0]);\n                if (domainId == null) {\n                    domainId = Long.parseLong(domainIdArr[0]);\n                }\n                auditTrailSb.append(\" domainid=\" + domainId);// building the params for POST call\n            } catch (final NumberFormatException e) {\n                s_logger.warn(\"Invalid domain id entered by user\");\n                auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"Invalid domain id entered, please enter a valid one\");\n                throw new ServerApiException(ApiErrorCode.UNAUTHORIZED,\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid domain id entered, please enter a valid one\", params,\n                                responseType));\n            }\n        }\n\n        String domain = null;\n        if (domainName != null) {\n            domain = domainName[0];\n            auditTrailSb.append(\" domain=\" + domain);\n            if (domain != null) {\n                // ensure domain starts with '/' and ends with '/'\n                if (!domain.endsWith(\"/\")) {\n                    domain += '/';\n                }\n                if (!domain.startsWith(\"/\")) {\n                    domain = \"/\" + domain;\n                }\n            }\n        }\n\n        String serializedResponse = null;\n        if (username != null) {\n            final String pwd = ((password == null) ? null : password[0]);\n            try {\n                _apiServer.loginUser(session, username[0], pwd, domainId, domain, remoteAddress, params);\n                auditTrailSb.insert(0, \"(userId=\" + session.getAttribute(\"userid\") + \" accountId=\" + ((Account) session.getAttribute(\"accountobj\")).getId() +\n                        \" sessionId=\" + session.getId() + \")\");\n                return createLoginResponse(session, responseType);\n            } catch (final CloudAuthenticationException ex) {\n                // TODO: fall through to API key, or just fail here w/ auth error? (HTTP 401)\n                try {\n                    session.invalidate();\n                } catch (final IllegalStateException ise) {\n                }\n                auditTrailSb.append(\" \" + ApiErrorCode.ACCOUNT_ERROR + \" \" + ex.getMessage() != null ? ex.getMessage()\n                        : \"failed to authenticate user, check if username/password are correct\");\n                serializedResponse =\n                        _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), ex.getMessage() != null ? ex.getMessage()\n                                : \"failed to authenticate user, check if username/password are correct\", params, responseType);\n            }\n        }\n        // We should not reach here and if we do we throw an exception\n        throw new ServerApiException(ApiErrorCode.ACCOUNT_ERROR, serializedResponse);\n    }","id":47360,"modified_method":"@Override\n    public String authenticate(String command, Map<String, Object[]> params, HttpSession session, String remoteAddress, String responseType, StringBuilder auditTrailSb, final HttpServletResponse resp) throws ServerApiException {\n\n        // FIXME: ported from ApiServlet, refactor and cleanup\n        final String[] username = (String[])params.get(ApiConstants.USERNAME);\n        final String[] password = (String[])params.get(ApiConstants.PASSWORD);\n        String[] domainIdArr = (String[])params.get(ApiConstants.DOMAIN_ID);\n\n        if (domainIdArr == null) {\n            domainIdArr = (String[])params.get(ApiConstants.DOMAIN__ID);\n        }\n        final String[] domainName = (String[])params.get(ApiConstants.DOMAIN);\n        Long domainId = null;\n        if ((domainIdArr != null) && (domainIdArr.length > 0)) {\n            try {\n                //check if UUID is passed in for domain\n                domainId = _apiServer.fetchDomainId(domainIdArr[0]);\n                if (domainId == null) {\n                    domainId = Long.parseLong(domainIdArr[0]);\n                }\n                auditTrailSb.append(\" domainid=\" + domainId);// building the params for POST call\n            } catch (final NumberFormatException e) {\n                s_logger.warn(\"Invalid domain id entered by user\");\n                auditTrailSb.append(\" \" + HttpServletResponse.SC_UNAUTHORIZED + \" \" + \"Invalid domain id entered, please enter a valid one\");\n                throw new ServerApiException(ApiErrorCode.UNAUTHORIZED,\n                        _apiServer.getSerializedApiError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid domain id entered, please enter a valid one\", params,\n                                responseType));\n            }\n        }\n\n        String domain = null;\n        if (domainName != null) {\n            domain = domainName[0];\n            auditTrailSb.append(\" domain=\" + domain);\n            if (domain != null) {\n                // ensure domain starts with '/' and ends with '/'\n                if (!domain.endsWith(\"/\")) {\n                    domain += '/';\n                }\n                if (!domain.startsWith(\"/\")) {\n                    domain = \"/\" + domain;\n                }\n            }\n        }\n\n        String serializedResponse = null;\n        if (username != null) {\n            final String pwd = ((password == null) ? null : password[0]);\n            try {\n                return ApiResponseSerializer.toSerializedString(_apiServer.loginUser(session, username[0], pwd, domainId, domain, remoteAddress, params),\n                        responseType);\n            } catch (final CloudAuthenticationException ex) {\n                // TODO: fall through to API key, or just fail here w/ auth error? (HTTP 401)\n                try {\n                    session.invalidate();\n                } catch (final IllegalStateException ise) {\n                }\n                auditTrailSb.append(\" \" + ApiErrorCode.ACCOUNT_ERROR + \" \" + ex.getMessage() != null ? ex.getMessage()\n                        : \"failed to authenticate user, check if username/password are correct\");\n                serializedResponse =\n                        _apiServer.getSerializedApiError(ApiErrorCode.ACCOUNT_ERROR.getHttpCode(), ex.getMessage() != null ? ex.getMessage()\n                                : \"failed to authenticate user, check if username/password are correct\", params, responseType);\n            }\n        }\n        // We should not reach here and if we do we throw an exception\n        throw new ServerApiException(ApiErrorCode.ACCOUNT_ERROR, serializedResponse);\n    }","commit_id":"9c7204d38637f046768541a3dc3aa707fe5eb927","url":"https://github.com/apache/cloudstack"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm form, HttpServletRequest request,\n            HttpServletResponse response) {\n\n        CertificateManager cm = CertificateManager.getInstance();\n        if (cm.isSatelliteCertInRestrictedPeriod()) {\n            createErrorMessageWithMultipleArgs(request, \"satellite.expired.restricted\",\n                   cm.getDayProgressInRestrictedPeriod());\n        }\n        else if (cm.isSatelliteCertExpired()) {\n            addMessage(request, \"satellite.expired\");\n            request.setAttribute(LoginSetupAction.HAS_EXPIRED, Boolean.TRUE);\n            return mapping.findForward(\"failure\");\n        }\n\n        ActionForward ret = null;\n        DynaActionForm f = (DynaActionForm)form;\n\n        // Validate the form\n        ActionErrors errors = RhnValidationHelper.validateDynaActionForm(this, f);\n        if (!errors.isEmpty()) {\n            performGracePeriodCheck(request);\n            addErrors(request, errors);\n            return mapping.findForward(\"failure\");\n        }\n\n        ActionErrors e = new ActionErrors();\n        User user = loginUser((String) f.get(\"username\"), (String) f.get(\"password\"),\n                request, response, e);\n\n        if (e.isEmpty()) {\n            LoginHelper.successfulLogin(request, response, user);\n        }\n        else {\n            performGracePeriodCheck(request);\n            addErrors(request, e);\n            ret = mapping.findForward(\"failure\");\n        }\n\n        return ret;\n    }","id":47361,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm form, HttpServletRequest request,\n            HttpServletResponse response) {\n\n        CertificateManager cm = CertificateManager.getInstance();\n        if (cm.isSatelliteCertInRestrictedPeriod()) {\n            createErrorMessageWithMultipleArgs(request, \"satellite.expired.restricted\",\n                   cm.getDayProgressInRestrictedPeriod());\n        }\n        else if (cm.isSatelliteCertExpired()) {\n            addMessage(request, \"satellite.expired\");\n            request.setAttribute(LoginSetupAction.HAS_EXPIRED, Boolean.TRUE);\n            return mapping.findForward(\"failure\");\n        }\n\n        ActionForward ret = null;\n        DynaActionForm f = (DynaActionForm)form;\n\n        // Validate the form\n        ActionErrors errors = RhnValidationHelper.validateDynaActionForm(this, f);\n        if (!errors.isEmpty()) {\n            performGracePeriodCheck(request);\n            addErrors(request, errors);\n            return mapping.findForward(\"failure\");\n        }\n\n        ActionMessages messages = new ActionMessages();\n        User user = LoginHelper.checkExternalAuthentication(request, messages, errors);\n        // save stores msgs into the session (works for redirect)\n        saveMessages(request, messages);\n        addErrors(request, errors);\n        errors.clear();\n\n        if (user == null) {\n            user = loginUser((String) f.get(\"username\"), (String) f.get(\"password\"),\n                    request, response, errors);\n        }\n\n        if (errors.isEmpty()) {\n            LoginHelper.successfulLogin(request, response, user);\n        }\n        else {\n            performGracePeriodCheck(request);\n            addErrors(request, errors);\n            ret = mapping.findForward(\"failure\");\n        }\n\n        return ret;\n    }","commit_id":"72be4ea24fedac8b6be33666844e8800ae24c8c2","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n        ActionForm form, HttpServletRequest request,\n        HttpServletResponse response) {\n\n        String rpmSchemaVersion = getRpmSchemaVersion(\"satellite-schema\");\n        if (rpmSchemaVersion == null) {\n            rpmSchemaVersion = getRpmSchemaVersion(\"spacewalk-schema\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"General_queries\", \"installed_schema_version\");\n        DataResult<HashMap> dr = m.execute();\n        String installedSchemaVersion = null;\n        if (dr.size() > 0) {\n            installedSchemaVersion = (String) dr.get(0).get(\"version\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"RPM version of schema: \" +\n                (rpmSchemaVersion == null ? \"null\" : rpmSchemaVersion));\n            log.debug(\"Version of installed database schema: \" +\n                (installedSchemaVersion == null ? \"null\" : installedSchemaVersion));\n        }\n\n        if (rpmSchemaVersion != null && installedSchemaVersion != null &&\n            !rpmSchemaVersion.equals(installedSchemaVersion)) {\n            request.setAttribute(\"schemaUpgradeRequired\", \"true\");\n        }\n        else {\n            request.setAttribute(\"schemaUpgradeRequired\", \"false\");\n        }\n\n        CertificateManager man = CertificateManager.getInstance();\n        if (man.isSatelliteCertInRestrictedPeriod()) {\n            createErrorMessageWithMultipleArgs(request, \"satellite.expired.restricted\",\n                    man.getDayProgressInRestrictedPeriod());\n        }\n        else if (man.isSatelliteCertExpired()) {\n            addMessage(request, \"satellite.expired\");\n            request.setAttribute(HAS_EXPIRED, Boolean.TRUE);\n            return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n        }\n        else if (man.isSatelliteCertInGracePeriod()) {\n            long daysUntilExpiration = man.getDaysLeftBeforeCertExpiration();\n            createSuccessMessage(request,\n                \"satellite.graceperiod\",\n                String.valueOf(daysUntilExpiration));\n        }\n        else if (!UserManager.satelliteHasUsers()) {\n            return mapping.findForward(\"needuser\");\n        }\n\n        if (AclManager.hasAcl(\"user_authenticated()\", request, null)) {\n            return mapping.findForward(\"loggedin\");\n        }\n\n        String remoteUserString = request.getRemoteUser();\n        if (remoteUserString != null) {\n\n            String firstname = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_FIRSTNAME\"), \"\");\n            String lastname = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_LASTNAME\"), \"\");\n            String email = decodeFromIso88591(\n                    (String) request.getAttribute(\"REMOTE_USER_EMAIL\"), null);\n\n            Long defaultOrgId = SatConfigFactory.getSatConfigLongValue(\n                    SatConfigFactory.ORG_ID_FOR_EXT_AUTH);\n\n            User remoteUser = null;\n            Set<Role> roles = getRolesFromExtGroups(request);\n\n            log.info(\"REMOTE_USER_CUSTOM_N: \" +\n                    request.getAttribute(\"REMOTE_USER_CUSTOM_N\"));\n            log.info(\"REMOTE_USER_GECOS: \" +\n                    request.getAttribute(\"REMOTE_USER_GECOS\"));\n            log.warn(\"REMOTE_USER_GROUPS: \" +\n                    request.getAttribute(\"REMOTE_USER_GROUPS\"));\n            log.info(\"REMOTE_USER_GROUP_1: \" +\n                    request.getAttribute(\"REMOTE_USER_GROUP_1\"));\n            log.info(\"REMOTE_USER_GROUP_2: \" +\n                    request.getAttribute(\"REMOTE_USER_GROUP_2\"));\n            log.info(\"REMOTE_USER_GROUP_3: \" +\n                    request.getAttribute(\"REMOTE_USER_GROUP_3\"));\n            log.info(\"REMOTE_USER_GROUP_N: \" +\n                    request.getAttribute(\"REMOTE_USER_GROUP_N\"));\n\n                try {\n                    remoteUser = UserFactory.lookupByLogin(remoteUserString);\n\n                if (remoteUser.isDisabled()) {\n                    createErrorMessage(request, \"account.user.disabled\", remoteUserString);\n                    remoteUser = null;\n                }\n                if (remoteUser != null) {\n                    UpdateUserCommand updateCmd = new UpdateUserCommand(remoteUser);\n                    updateCmd.setFirstNames(firstname);\n                    updateCmd.setLastName(lastname);\n                    updateCmd.setEmail(email);\n                    updateCmd.setRoles(roles);\n                    updateCmd.updateUser();\n                    log.warn(\"Externally authenticated login \" + remoteUserString +\n                                 \" (\" + firstname + \" \" + lastname + \")\");\n                }\n            }\n            catch (LookupException le) {\n                Org defaultOrg = null;\n                if (defaultOrgId != null) {\n                    defaultOrg = OrgFactory.lookupById(defaultOrgId);\n                }\n                if (defaultOrg == null) {\n                    log.error(\"Cannot find organization with id: \" + defaultOrgId);\n                }\n                else {\n                    CreateUserCommand createCmd = new CreateUserCommand();\n                    createCmd.setLogin(remoteUserString);\n                    // set a password, that cannot really be used\n                    createCmd.setRawPassword(DEFAULT_KERB_USER_PASSWORD);\n                    createCmd.setFirstNames(firstname);\n                    createCmd.setLastName(lastname);\n                    createCmd.setEmail(email);\n                    createCmd.setOrg(defaultOrg);\n                    createCmd.setRoles(roles);\n                    createCmd.validate();\n                    createCmd.storeNewUser();\n                    remoteUser = createCmd.getUser();\n                    log.warn(\"Externally authenticated login \" + remoteUserString +\n                                 \" (\" + firstname + \" \" + lastname + \") created.\");\n                }\n            }\n            if (remoteUser != null) {\n                if (remoteUser.getPassword().equals(DEFAULT_KERB_USER_PASSWORD)) {\n                    createMessage(request, \"message.kerbuserlogged\",\n                            new String [] {remoteUserString});\n                }\n                if (LoginHelper.successfulLogin(request, response, remoteUser)) {\n                    return null;\n                }\n                return mapping.findForward(\"loggedin\");\n            }\n        }\n\n        // store url_bounce set by pxt pages\n        String urlBounce = request.getParameter(\"url_bounce\");\n        if (!StringUtils.isBlank(urlBounce)) {\n            HttpSession hs = request.getSession();\n            if (hs != null) {\n                hs.setAttribute(\"url_bounce\", urlBounce);\n            }\n        }\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","id":47362,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n        ActionForm form, HttpServletRequest request,\n        HttpServletResponse response) {\n\n        String rpmSchemaVersion = getRpmSchemaVersion(\"satellite-schema\");\n        if (rpmSchemaVersion == null) {\n            rpmSchemaVersion = getRpmSchemaVersion(\"spacewalk-schema\");\n        }\n\n        SelectMode m = ModeFactory.getMode(\"General_queries\", \"installed_schema_version\");\n        DataResult<HashMap> dr = m.execute();\n        String installedSchemaVersion = null;\n        if (dr.size() > 0) {\n            installedSchemaVersion = (String) dr.get(0).get(\"version\");\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"RPM version of schema: \" +\n                (rpmSchemaVersion == null ? \"null\" : rpmSchemaVersion));\n            log.debug(\"Version of installed database schema: \" +\n                (installedSchemaVersion == null ? \"null\" : installedSchemaVersion));\n        }\n\n        if (rpmSchemaVersion != null && installedSchemaVersion != null &&\n            !rpmSchemaVersion.equals(installedSchemaVersion)) {\n            request.setAttribute(\"schemaUpgradeRequired\", \"true\");\n        }\n        else {\n            request.setAttribute(\"schemaUpgradeRequired\", \"false\");\n        }\n\n        CertificateManager man = CertificateManager.getInstance();\n        if (man.isSatelliteCertInRestrictedPeriod()) {\n            createErrorMessageWithMultipleArgs(request, \"satellite.expired.restricted\",\n                    man.getDayProgressInRestrictedPeriod());\n        }\n        else if (man.isSatelliteCertExpired()) {\n            addMessage(request, \"satellite.expired\");\n            request.setAttribute(HAS_EXPIRED, Boolean.TRUE);\n            return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n        }\n        else if (man.isSatelliteCertInGracePeriod()) {\n            long daysUntilExpiration = man.getDaysLeftBeforeCertExpiration();\n            createSuccessMessage(request,\n                \"satellite.graceperiod\",\n                String.valueOf(daysUntilExpiration));\n        }\n        else if (!UserManager.satelliteHasUsers()) {\n            return mapping.findForward(\"needuser\");\n        }\n\n        if (AclManager.hasAcl(\"user_authenticated()\", request, null)) {\n            return mapping.findForward(\"loggedin\");\n        }\n\n        ActionErrors errors = new ActionErrors();\n        ActionMessages messages = new ActionMessages();\n        User remoteUser =\n                LoginHelper.checkExternalAuthentication(request, messages, errors);\n        // save stores msgs into the session (works for redirect)\n        saveMessages(request, messages);\n        addErrors(request, errors);\n        if (errors.isEmpty() && remoteUser != null) {\n            if (LoginHelper.successfulLogin(request, response, remoteUser)) {\n                return null;\n            }\n            return mapping.findForward(\"loggedin\");\n        }\n\n        // store url_bounce set by pxt pages\n        String urlBounce = request.getParameter(\"url_bounce\");\n        if (!StringUtils.isBlank(urlBounce)) {\n            HttpSession hs = request.getSession();\n            if (hs != null) {\n                hs.setAttribute(\"url_bounce\", urlBounce);\n            }\n        }\n        return mapping.findForward(RhnHelper.DEFAULT_FORWARD);\n    }","commit_id":"72be4ea24fedac8b6be33666844e8800ae24c8c2","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public List<Pair<String, Object>> loginUser(HttpSession session, String username, String password, Long domainId, String domainPath, Map<String, Object[]> requestParameters) {\r\n    \t// We will always use domainId first.  If that does not exist, we will use domain name.  If THAT doesn't exist\r\n    \t// we will default to ROOT\r\n        if (domainId == null) {\r\n        \tif (domainPath == null || domainPath.trim().length() == 0) {\r\n        \t\tdomainId = DomainVO.ROOT_DOMAIN;\r\n        \t} else {\r\n                DomainVO domainObj = _ms.findDomainByPath(domainPath);\r\n        \t\tif (domainObj != null) {\r\n        \t\t\tdomainId = domainObj.getId();\r\n        \t\t} else { // if an unknown path is passed in, fail the login call\r\n        \t\t\treturn null;\r\n        \t\t}\r\n        \t}\r\n        }\r\n\r\n        UserAccount userAcct = _ms.authenticateUser(username, password, domainId, requestParameters);\r\n        if (userAcct != null) \r\n        {\r\n        \tString timezone = userAcct.getTimezone();\r\n        \tfloat offsetInHrs = 0f;\r\n        \tif (timezone!=null) {\r\n\t    \t\tTimeZone t = TimeZone.getTimeZone(timezone);\r\n\t    \t\ts_logger.info(\"Current user logged in under \"+timezone+\" timezone\");\r\n\t    \t\t\r\n\t            java.util.Date date = new java.util.Date();\r\n\t            long longDate = date.getTime();\r\n\t            float offsetInMs = (t.getOffset(longDate));\r\n\t            offsetInHrs = offsetInMs/ (1000*60*60);\r\n\t            s_logger.info(\"Timezone offset from UTC is: \"+offsetInHrs);\r\n        \t}\r\n        \t\r\n        \tAccount account = _ms.findAccountById(userAcct.getAccountId());\r\n            List<Pair<String, Object>> loginParams = new ArrayList<Pair<String, Object>>();\r\n\r\n            String networkType = _ms.getConfigurationValue(\"network.type\");\r\n            if (networkType == null) \r\n            \tnetworkType = \"vnet\";\r\n            \r\n            String hypervisorType = _ms.getConfigurationValue(\"hypervisor.type\");\r\n            if (hypervisorType == null) \r\n            \thypervisorType = \"kvm\";\r\n            \r\n            String directAttachNetworkGroupsEnabled = _ms.getConfigurationValue(\"direct.attach.network.groups.enabled\");\r\n            if(directAttachNetworkGroupsEnabled == null) \r\n            \tdirectAttachNetworkGroupsEnabled = \"false\";     \r\n            \r\n            String directAttachedUntaggedEnabled = _ms.getConfigurationValue(\"direct.attach.untagged.vlan.enabled\");\r\n            if (directAttachedUntaggedEnabled == null) \r\n            \tdirectAttachedUntaggedEnabled = \"false\";\r\n            \r\n            String systemVmUseLocalStorage = _ms.getConfigurationValue(\"system.vm.use.local.storage\");\r\n            if (systemVmUseLocalStorage == null) \r\n            \tsystemVmUseLocalStorage = \"false\";            \r\n\r\n            // set the userId and account object for everyone\r\n            session.setAttribute(\"userid\", userAcct.getId().toString());\r\n            session.setAttribute(\"username\", userAcct.getUsername());\r\n            session.setAttribute(\"firstname\", userAcct.getFirstname());\r\n            session.setAttribute(\"lastname\", userAcct.getLastname());\r\n            session.setAttribute(\"accountobj\", account);\r\n            session.setAttribute(\"account\", account.getAccountName());\r\n            session.setAttribute(\"domainid\", account.getDomainId().toString());\r\n            session.setAttribute(\"type\", Short.valueOf(account.getType()).toString());\r\n            session.setAttribute(\"networktype\", networkType);\r\n            session.setAttribute(\"hypervisortype\", hypervisorType);\r\n            session.setAttribute(\"directattachnetworkgroupsenabled\", directAttachNetworkGroupsEnabled);\r\n            session.setAttribute(\"directattacheduntaggedenabled\", directAttachedUntaggedEnabled);\r\n            session.setAttribute(\"systemvmuselocalstorage\", systemVmUseLocalStorage);\r\n            if (timezone != null) {\r\n                session.setAttribute(\"timezone\", timezone);\r\n                session.setAttribute(\"timezoneoffset\", Float.valueOf(offsetInHrs).toString());\r\n            }\r\n\r\n            // (bug 5483) generate a session key that the user must submit on every request to prevent CSRF, add that\r\n            //  to the login response so that session-based authenticators know to send the key back\r\n            SecureRandom sesssionKeyRandom = new SecureRandom();\r\n            byte sessionKeyBytes[] = new byte[20];\r\n            sesssionKeyRandom.nextBytes(sessionKeyBytes);\r\n            String sessionKey = Base64.encodeBytes(sessionKeyBytes);\r\n            session.setAttribute(\"sessionkey\", sessionKey);\r\n\r\n            return loginParams;\r\n        }\r\n        return null;\r\n    }","id":47363,"modified_method":"public void loginUser(HttpSession session, String username, String password, Long domainId, String domainPath, Map<String, Object[]> requestParameters) throws CloudAuthenticationException {\r\n    \t// We will always use domainId first.  If that does not exist, we will use domain name.  If THAT doesn't exist\r\n    \t// we will default to ROOT\r\n        if (domainId == null) {\r\n        \tif (domainPath == null || domainPath.trim().length() == 0) {\r\n        \t\tdomainId = DomainVO.ROOT_DOMAIN;\r\n        \t} else {\r\n                DomainVO domainObj = _ms.findDomainByPath(domainPath);\r\n        \t\tif (domainObj != null) {\r\n        \t\t\tdomainId = domainObj.getId();\r\n        \t\t} else { // if an unknown path is passed in, fail the login call\r\n        \t\t\tthrow new CloudAuthenticationException(\"Unable to find the domain from the path \" + domainPath);\r\n        \t\t}\r\n        \t}\r\n        }\r\n\r\n        UserAccount userAcct = _ms.authenticateUser(username, password, domainId, requestParameters);\r\n        if (userAcct != null) {\r\n        \tString timezone = userAcct.getTimezone();\r\n        \tfloat offsetInHrs = 0f;\r\n        \tif (timezone!=null) {\r\n\t    \t\tTimeZone t = TimeZone.getTimeZone(timezone);\r\n\t    \t\ts_logger.info(\"Current user logged in under \"+timezone+\" timezone\");\r\n\t    \t\t\r\n\t            java.util.Date date = new java.util.Date();\r\n\t            long longDate = date.getTime();\r\n\t            float offsetInMs = (t.getOffset(longDate));\r\n\t            offsetInHrs = offsetInMs/ (1000*60*60);\r\n\t            s_logger.info(\"Timezone offset from UTC is: \"+offsetInHrs);\r\n        \t}\r\n        \t\r\n        \tAccount account = _ms.findAccountById(userAcct.getAccountId());\r\n\r\n            String networkType = _ms.getConfigurationValue(\"network.type\");\r\n            if (networkType == null) \r\n            \tnetworkType = \"vnet\";\r\n            \r\n            String hypervisorType = _ms.getConfigurationValue(\"hypervisor.type\");\r\n            if (hypervisorType == null) \r\n            \thypervisorType = \"kvm\";\r\n            \r\n            String directAttachNetworkGroupsEnabled = _ms.getConfigurationValue(\"direct.attach.network.groups.enabled\");\r\n            if(directAttachNetworkGroupsEnabled == null) \r\n            \tdirectAttachNetworkGroupsEnabled = \"false\";     \r\n            \r\n            String directAttachedUntaggedEnabled = _ms.getConfigurationValue(\"direct.attach.untagged.vlan.enabled\");\r\n            if (directAttachedUntaggedEnabled == null) \r\n            \tdirectAttachedUntaggedEnabled = \"false\";\r\n            \r\n            String systemVmUseLocalStorage = _ms.getConfigurationValue(\"system.vm.use.local.storage\");\r\n            if (systemVmUseLocalStorage == null) \r\n            \tsystemVmUseLocalStorage = \"false\";            \r\n\r\n            // set the userId and account object for everyone\r\n            session.setAttribute(\"userid\", userAcct.getId().toString());\r\n            session.setAttribute(\"username\", userAcct.getUsername());\r\n            session.setAttribute(\"firstname\", userAcct.getFirstname());\r\n            session.setAttribute(\"lastname\", userAcct.getLastname());\r\n            session.setAttribute(\"accountobj\", account);\r\n            session.setAttribute(\"account\", account.getAccountName());\r\n            session.setAttribute(\"domainid\", account.getDomainId().toString());\r\n            session.setAttribute(\"type\", Short.valueOf(account.getType()).toString());\r\n            session.setAttribute(\"networktype\", networkType);\r\n            session.setAttribute(\"hypervisortype\", hypervisorType);\r\n            session.setAttribute(\"directattachnetworkgroupsenabled\", directAttachNetworkGroupsEnabled);\r\n            session.setAttribute(\"directattacheduntaggedenabled\", directAttachedUntaggedEnabled);\r\n            session.setAttribute(\"systemvmuselocalstorage\", systemVmUseLocalStorage);\r\n            if (timezone != null) {\r\n                session.setAttribute(\"timezone\", timezone);\r\n                session.setAttribute(\"timezoneoffset\", Float.valueOf(offsetInHrs).toString());\r\n            }\r\n\r\n            // (bug 5483) generate a session key that the user must submit on every request to prevent CSRF, add that\r\n            //  to the login response so that session-based authenticators know to send the key back\r\n            SecureRandom sesssionKeyRandom = new SecureRandom();\r\n            byte sessionKeyBytes[] = new byte[20];\r\n            sesssionKeyRandom.nextBytes(sessionKeyBytes);\r\n            String sessionKey = Base64.encodeBytes(sessionKeyBytes);\r\n            session.setAttribute(\"sessionkey\", sessionKey);\r\n\r\n            return;\r\n        }\r\n        throw new CloudAuthenticationException(\"Unable to find user \" + username + \" in domain \" + domainId);\r\n    }","commit_id":"a8112f65de8aa9f671d37e0a0ace4a200d003270","url":"https://github.com/apache/cloudstack"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n    private void processRequest(HttpServletRequest req, HttpServletResponse resp) {\r\n        try {\r\n            Map<String, Object[]> params = new HashMap<String, Object[]>();\r\n            params.putAll(req.getParameterMap());\r\n            HttpSession session = req.getSession(false);\r\n\r\n            // get the response format since we'll need it in a couple of places\r\n            String responseType = BaseCmd.RESPONSE_TYPE_XML;\r\n            Object[] responseTypeParam = params.get(\"response\");\r\n            if (responseTypeParam != null) {\r\n                responseType = (String)responseTypeParam[0];\r\n            }\r\n\r\n            Object[] commandObj = params.get(\"command\");\r\n            if (commandObj != null) {\r\n                String command = (String)commandObj[0];\r\n                if (\"logout\".equalsIgnoreCase(command)) {\r\n                    // if this is just a logout, invalidate the session and return\r\n                    if (session != null) {\r\n                        String userIdStr = (String)session.getAttribute(\"userId\");\r\n                        if (userIdStr != null) {\r\n                            _apiServer.logoutUser(Long.parseLong(userIdStr));\r\n                        }\r\n                        session.invalidate();\r\n                    }\r\n                    writeResponse(resp, getLogoutSuccessResponse(responseType), false, responseType);\r\n                    return;\r\n                } else if (\"login\".equalsIgnoreCase(command)) {\r\n                    // if this is a login, authenticate the user and return\r\n                    if (session != null) session.invalidate();\r\n                \tsession = req.getSession(true);\r\n                    String[] username = (String[])params.get(\"username\");\r\n                    String[] password = (String[])params.get(\"password\");\n                    String[] domainIdArr = (String[])params.get(\"domainid\");\r\n                    if (domainIdArr == null) {\r\n                    \tdomainIdArr = (String[])params.get(\"domainId\");\r\n                    }\r\n                    String[] domainName = (String[])params.get(\"domain\");\r\n                    Long domainId = null;\r\n                    if ((domainIdArr != null) && (domainIdArr.length > 0)) {\r\n                    \ttry{\n                    \t\tdomainId = new Long(Long.parseLong(domainIdArr[0]));\n                    \t}\n                    \tcatch(NumberFormatException e)\n                    \t{\n                    \t\ts_logger.warn(\"Invalid domain id entered by user\");\n                    \t\tresp.sendError(HttpServletResponse.SC_UNAUTHORIZED,\"Invalid domain id entered, please enter a valid one\");\n                    \t}\n                    }\r\n                    String domain = null;\r\n                    if (domainName != null) {\r\n                    \tdomain = domainName[0];\n                    \tif (domain != null) {\n                    \t    // ensure domain starts with '/' and ends with '/'\n                    \t    if (!domain.endsWith(\"/\")) {\n                                domain += '/';\n                    \t    }\n                    \t    if (!domain.startsWith(\"/\")) {\n                    \t        domain = \"/\" + domain;\n                    \t    }\n                    \t}\r\n                    }\n\r\n                    if (username != null) {\n                        String pwd = ((password == null) ? null : password[0]);\r\n                        List<Pair<String, Object>> sessionParams = _apiServer.loginUser(session, username[0], pwd, domainId, domain, params);\r\n                        if (sessionParams != null) {\r\n                            for (Pair<String, Object> sessionParam : sessionParams) {\r\n                                session.setAttribute(sessionParam.first(), sessionParam.second());\r\n                            }\r\n                            String loginResponse = getLoginSuccessResponse(session, responseType);\r\n                            writeResponse(resp, loginResponse, false, responseType);\r\n                            return;\r\n                        } else {\r\n                            // TODO:  fall through to API key, or just fail here w/ auth error? (HTTP 401)\r\n                            session.invalidate();\r\n                            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"failed to authenticated user, check username/password are correct\");\r\n                            return;\r\n                        }\r\n                    }\r\n                } \r\n            }\r\n\r\n            boolean isNew = ((session == null) ? true : session.isNew());\r\n\r\n            // Initialize an empty context and we will update it after we have verified the request below,\n            // we no longer rely on web-session here, verifyRequest will populate user/account information\n            // if a API key exists\n            UserContext.registerContext(null, null, null, null, null, null, false);\n            String userId = null;\n\n            if (!isNew) {\r\n                userId = (String)session.getAttribute(\"userid\");\r\n                String account = (String)session.getAttribute(\"account\");\r\n                String domainId = (String)session.getAttribute(\"domainid\");\r\n                Object accountObj = session.getAttribute(\"accountobj\");\n                String sessionKey = (String)session.getAttribute(\"sessionkey\");\n                String[] sessionKeyParam = (String[])params.get(\"sessionkey\");\n                if ((sessionKeyParam == null) || (sessionKey == null) || !sessionKey.equals(sessionKeyParam[0])) {\n                    session.invalidate();\n                    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\");\n                }\r\n\r\n                // Do a sanity check here to make sure the user hasn't already been deleted\r\n                if ((userId != null) && (account != null) && (accountObj != null) && _apiServer.verifyUser(Long.valueOf(userId))) {\r\n                    String[] command = (String[])params.get(\"command\");\r\n                    if (command == null) {\r\n                        s_logger.info(\"missing command, ignoring request...\");\r\n                        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, \"no command specified\");\r\n                        return;\r\n                    }\n                    UserContext.updateContext(Long.valueOf(userId), accountObj, account, ((Account)accountObj).getId(), Long.valueOf(domainId), session.getId());\r\n                } else {\r\n                    // Invalidate the session to ensure we won't allow a request across management server restarts if the userId was serialized to the\r\n                    // stored session\r\n                    session.invalidate();\n                    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\");\n                    return;\r\n                }\r\n            }\r\n\n            if (_apiServer.verifyRequest(params, userId)) {\n                /*\n            \tif (accountObj != null) {\r\n            \t\tAccount userAccount = (Account)accountObj;\r\n            \t\tif (userAccount.getType() == Account.ACCOUNT_TYPE_NORMAL) {\r\n            \t\t\tparams.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\r\n                        params.put(BaseCmd.Properties.ACCOUNT.getName(), new String[] { account });\r\n                        params.put(BaseCmd.Properties.DOMAIN_ID.getName(), new String[] { domainId });\r\n                \t\tparams.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj });\r\n            \t\t} else {\r\n            \t\t\tparams.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\r\n            \t\t\tparams.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj });\r\n            \t\t}\r\n            \t}\n            \t\n            \t// update user context info here so that we can take information if the request is authenticated\n            \t// via api key mechenism\n            \tupdateUserContext(params, session != null ? session.getId() : null);\n                */\n            \ttry {\r\n            \t\tString response = _apiServer.handleRequest(params, false, responseType);\r\n            \t\twriteResponse(resp, response != null ? response : \"\", false, responseType);\r\n            \t} catch (ServerApiException se) {\r\n            \t\tresp.sendError(se.getErrorCode(), se.getDescription());\r\n            \t}\r\n            } else {\n                if (session != null) {\n                    session.invalidate();\n                }\n                resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials and/or request signature\");\r\n            }\r\n        } catch (IOException ioex) {\r\n            if (s_logger.isTraceEnabled()) {\r\n                s_logger.trace(\"exception processing request: \" + ioex);\r\n            }\r\n        } catch (Exception ex) {\r\n            s_logger.error(\"unknown exception writing api response\", ex);\r\n        } finally {\n            // cleanup user context to prevent from being peeked in other request context\n            UserContext.unregisterContext();\n        }\r\n    }","id":47364,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n    private void processRequest(HttpServletRequest req, HttpServletResponse resp) {\r\n        try {\r\n            Map<String, Object[]> params = new HashMap<String, Object[]>();\r\n            params.putAll(req.getParameterMap());\r\n            HttpSession session = req.getSession(false);\r\n\r\n            // get the response format since we'll need it in a couple of places\r\n            String responseType = BaseCmd.RESPONSE_TYPE_XML;\r\n            Object[] responseTypeParam = params.get(\"response\");\r\n            if (responseTypeParam != null) {\r\n                responseType = (String)responseTypeParam[0];\r\n            }\r\n\r\n            Object[] commandObj = params.get(\"command\");\r\n            if (commandObj != null) {\r\n                String command = (String)commandObj[0];\r\n                if (\"logout\".equalsIgnoreCase(command)) {\r\n                    // if this is just a logout, invalidate the session and return\r\n                    if (session != null) {\r\n                        String userIdStr = (String)session.getAttribute(\"userId\");\r\n                        if (userIdStr != null) {\r\n                            _apiServer.logoutUser(Long.parseLong(userIdStr));\r\n                        }\r\n                        session.invalidate();\r\n                    }\r\n                    writeResponse(resp, getLogoutSuccessResponse(responseType), false, responseType);\r\n                    return;\r\n                } else if (\"login\".equalsIgnoreCase(command)) {\r\n                    // if this is a login, authenticate the user and return\r\n                    if (session != null) session.invalidate();\r\n                \tsession = req.getSession(true);\r\n                    String[] username = (String[])params.get(\"username\");\r\n                    String[] password = (String[])params.get(\"password\");\n                    String[] domainIdArr = (String[])params.get(\"domainid\");\r\n                    if (domainIdArr == null) {\r\n                    \tdomainIdArr = (String[])params.get(\"domainId\");\r\n                    }\r\n                    String[] domainName = (String[])params.get(\"domain\");\r\n                    Long domainId = null;\r\n                    if ((domainIdArr != null) && (domainIdArr.length > 0)) {\r\n                    \ttry{\n                    \t\tdomainId = new Long(Long.parseLong(domainIdArr[0]));\n                    \t}\n                    \tcatch(NumberFormatException e)\n                    \t{\n                    \t\ts_logger.warn(\"Invalid domain id entered by user\");\n                    \t\tresp.sendError(HttpServletResponse.SC_UNAUTHORIZED,\"Invalid domain id entered, please enter a valid one\");\n                    \t}\n                    }\r\n                    String domain = null;\r\n                    if (domainName != null) {\r\n                    \tdomain = domainName[0];\n                    \tif (domain != null) {\n                    \t    // ensure domain starts with '/' and ends with '/'\n                    \t    if (!domain.endsWith(\"/\")) {\n                                domain += '/';\n                    \t    }\n                    \t    if (!domain.startsWith(\"/\")) {\n                    \t        domain = \"/\" + domain;\n                    \t    }\n                    \t}\r\n                    }\n\r\n                    if (username != null) {\n                        String pwd = ((password == null) ? null : password[0]);\n                        try {\n                            _apiServer.loginUser(session, username[0], pwd, domainId, domain, params);\n                            String loginResponse = getLoginSuccessResponse(session, responseType);\n                            writeResponse(resp, loginResponse, false, responseType);\n                            return;\n                        } catch (CloudAuthenticationException ex) {\n                            // TODO:  fall through to API key, or just fail here w/ auth error? (HTTP 401)\n                            session.invalidate();\n                            resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"failed to authenticated user, check username/password are correct\");\n                            return;\n                        }\r\n                    }\r\n                } \r\n            }\r\n\r\n            boolean isNew = ((session == null) ? true : session.isNew());\r\n\r\n            // Initialize an empty context and we will update it after we have verified the request below,\n            // we no longer rely on web-session here, verifyRequest will populate user/account information\n            // if a API key exists\n            UserContext.registerContext(null, null, null, null, null, null, false);\n            String userId = null;\n\n            if (!isNew) {\r\n                userId = (String)session.getAttribute(\"userid\");\r\n                String account = (String)session.getAttribute(\"account\");\r\n                String domainId = (String)session.getAttribute(\"domainid\");\r\n                Object accountObj = session.getAttribute(\"accountobj\");\n                String sessionKey = (String)session.getAttribute(\"sessionkey\");\n                String[] sessionKeyParam = (String[])params.get(\"sessionkey\");\n                if ((sessionKeyParam == null) || (sessionKey == null) || !sessionKey.equals(sessionKeyParam[0])) {\n                    session.invalidate();\n                    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\");\n                }\r\n\r\n                // Do a sanity check here to make sure the user hasn't already been deleted\r\n                if ((userId != null) && (account != null) && (accountObj != null) && _apiServer.verifyUser(Long.valueOf(userId))) {\r\n                    String[] command = (String[])params.get(\"command\");\r\n                    if (command == null) {\r\n                        s_logger.info(\"missing command, ignoring request...\");\r\n                        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, \"no command specified\");\r\n                        return;\r\n                    }\n                    UserContext.updateContext(Long.valueOf(userId), accountObj, account, ((Account)accountObj).getId(), Long.valueOf(domainId), session.getId());\r\n                } else {\r\n                    // Invalidate the session to ensure we won't allow a request across management server restarts if the userId was serialized to the\r\n                    // stored session\r\n                    session.invalidate();\n                    resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials\");\n                    return;\r\n                }\r\n            }\r\n\n            if (_apiServer.verifyRequest(params, userId)) {\n                /*\n            \tif (accountObj != null) {\r\n            \t\tAccount userAccount = (Account)accountObj;\r\n            \t\tif (userAccount.getType() == Account.ACCOUNT_TYPE_NORMAL) {\r\n            \t\t\tparams.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\r\n                        params.put(BaseCmd.Properties.ACCOUNT.getName(), new String[] { account });\r\n                        params.put(BaseCmd.Properties.DOMAIN_ID.getName(), new String[] { domainId });\r\n                \t\tparams.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj });\r\n            \t\t} else {\r\n            \t\t\tparams.put(BaseCmd.Properties.USER_ID.getName(), new String[] { userId });\r\n            \t\t\tparams.put(BaseCmd.Properties.ACCOUNT_OBJ.getName(), new Object[] { accountObj });\r\n            \t\t}\r\n            \t}\n            \t\n            \t// update user context info here so that we can take information if the request is authenticated\n            \t// via api key mechenism\n            \tupdateUserContext(params, session != null ? session.getId() : null);\n                */\n            \ttry {\r\n            \t\tString response = _apiServer.handleRequest(params, false, responseType);\r\n            \t\twriteResponse(resp, response != null ? response : \"\", false, responseType);\r\n            \t} catch (ServerApiException se) {\r\n            \t\tresp.sendError(se.getErrorCode(), se.getDescription());\r\n            \t}\r\n            } else {\n                if (session != null) {\n                    session.invalidate();\n                }\n                resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"unable to verify user credentials and/or request signature\");\r\n            }\r\n        } catch (IOException ioex) {\r\n            if (s_logger.isTraceEnabled()) {\r\n                s_logger.trace(\"exception processing request: \" + ioex);\r\n            }\r\n        } catch (Exception ex) {\r\n            s_logger.error(\"unknown exception writing api response\", ex);\r\n        } finally {\n            // cleanup user context to prevent from being peeked in other request context\n            UserContext.unregisterContext();\n        }\r\n    }","commit_id":"a8112f65de8aa9f671d37e0a0ace4a200d003270","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n        public void run() {\n            if (!running) {\n                // return and don't spawn...\n                return;\n            }\n            final DiscoveryNode masterToPing = masterNode;\n            if (masterToPing == null) {\n                // master is null, should not happen, but we are still running, so reschedule\n                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, MasterPinger.this);\n                return;\n            }\n            final MasterPingRequest request = new MasterPingRequest(clusterService.localNode().id(), masterToPing.id(), clusterName);\n            final TransportRequestOptions options = options().withType(TransportRequestOptions.Type.PING).withTimeout(pingRetryTimeout);\n            transportService.sendRequest(masterToPing, MASTER_PING_ACTION_NAME, request, options, new BaseTransportResponseHandler<MasterPingResponseResponse>() {\n\n                        @Override\n                        public MasterPingResponseResponse newInstance() {\n                            return new MasterPingResponseResponse();\n                        }\n\n                        @Override\n                        public void handleResponse(MasterPingResponseResponse response) {\n                            if (!running) {\n                                return;\n                            }\n                            // reset the counter, we got a good result\n                            MasterFaultDetection.this.retryCount = 0;\n                            // check if the master node did not get switched on us..., if it did, we simply return with no reschedule\n                            if (masterToPing.equals(MasterFaultDetection.this.masterNode())) {\n                                if (!response.listedOnMaster) {\n                                    logger.trace(\"[master] [{}] does not have us registered with it...\", masterToPing);\n                                    notifyNotListedOnMaster();\n                                }\n                                // we don't stop on disconnection from master, we keep pinging it\n                                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, MasterPinger.this);\n                            }\n                        }\n\n                        @Override\n                        public void handleException(TransportException exp) {\n                            if (!running) {\n                                return;\n                            }\n                            synchronized (masterNodeMutex) {\n                                // check if the master node did not get switched on us...\n                                if (masterToPing.equals(MasterFaultDetection.this.masterNode())) {\n                                    if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {\n                                        handleTransportDisconnect(masterToPing);\n                                        return;\n                                    } else if (exp.getCause() instanceof NoLongerMasterException) {\n                                        logger.debug(\"[master] pinging a master {} that is no longer a master\", masterNode);\n                                        notifyMasterFailure(masterToPing, \"no longer master\");\n                                        return;\n                                    } else if (exp.getCause() instanceof NotMasterException) {\n                                        logger.debug(\"[master] pinging a master {} that is not the master\", masterNode);\n                                        notifyMasterFailure(masterToPing, \"not master\");\n                                        return;\n                                    } else if (exp.getCause() instanceof NodeDoesNotExistOnMasterException) {\n                                        logger.debug(\"[master] pinging a master {} but we do not exists on it, act as if its master failure\", masterNode);\n                                        notifyMasterFailure(masterToPing, \"do not exists on master, act as master failure\");\n                                        return;\n                                    }\n\n                                    int retryCount = ++MasterFaultDetection.this.retryCount;\n                                    logger.trace(\"[master] failed to ping [{}], retry [{}] out of [{}]\", exp, masterNode, retryCount, pingRetryCount);\n                                    if (retryCount >= pingRetryCount) {\n                                        logger.debug(\"[master] failed to ping [{}], tried [{}] times, each with maximum [{}] timeout\", masterNode, pingRetryCount, pingRetryTimeout);\n                                        // not good, failure\n                                        notifyMasterFailure(masterToPing, \"failed to ping, tried [\" + pingRetryCount + \"] times, each with  maximum [\" + pingRetryTimeout + \"] timeout\");\n                                    } else {\n                                        // resend the request, not reschedule, rely on send timeout\n                                        transportService.sendRequest(masterToPing, MASTER_PING_ACTION_NAME, request, options, this);\n                                    }\n                                }\n                            }\n                        }\n\n                        @Override\n                        public String executor() {\n                            return ThreadPool.Names.SAME;\n                        }\n                    }\n            );\n        }","id":47365,"modified_method":"@Override\n        public void run() {\n            if (!running) {\n                // return and don't spawn...\n                return;\n            }\n            final DiscoveryNode masterToPing = masterNode;\n            if (masterToPing == null) {\n                // master is null, should not happen, but we are still running, so reschedule\n                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, MasterPinger.this);\n                return;\n            }\n            final MasterPingRequest request = new MasterPingRequest(clusterService.localNode().id(), masterToPing.id(), clusterName);\n            final TransportRequestOptions options = options().withType(TransportRequestOptions.Type.PING).withTimeout(pingRetryTimeout);\n            transportService.sendRequest(masterToPing, MASTER_PING_ACTION_NAME, request, options, new BaseTransportResponseHandler<MasterPingResponseResponse>() {\n\n                        @Override\n                        public MasterPingResponseResponse newInstance() {\n                            return new MasterPingResponseResponse();\n                        }\n\n                        @Override\n                        public void handleResponse(MasterPingResponseResponse response) {\n                            if (!running) {\n                                return;\n                            }\n                            // reset the counter, we got a good result\n                            MasterFaultDetection.this.retryCount = 0;\n                            // check if the master node did not get switched on us..., if it did, we simply return with no reschedule\n                            if (masterToPing.equals(MasterFaultDetection.this.masterNode())) {\n                                // we don't stop on disconnection from master, we keep pinging it\n                                threadPool.schedule(pingInterval, ThreadPool.Names.SAME, MasterPinger.this);\n                            }\n                        }\n\n                        @Override\n                        public void handleException(TransportException exp) {\n                            if (!running) {\n                                return;\n                            }\n                            synchronized (masterNodeMutex) {\n                                // check if the master node did not get switched on us...\n                                if (masterToPing.equals(MasterFaultDetection.this.masterNode())) {\n                                    if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {\n                                        handleTransportDisconnect(masterToPing);\n                                        return;\n                                    } else if (exp.getCause() instanceof NoLongerMasterException) {\n                                        logger.debug(\"[master] pinging a master {} that is no longer a master\", masterNode);\n                                        notifyMasterFailure(masterToPing, \"no longer master\");\n                                        return;\n                                    } else if (exp.getCause() instanceof NotMasterException) {\n                                        logger.debug(\"[master] pinging a master {} that is not the master\", masterNode);\n                                        notifyMasterFailure(masterToPing, \"not master\");\n                                        return;\n                                    } else if (exp.getCause() instanceof NodeDoesNotExistOnMasterException) {\n                                        logger.debug(\"[master] pinging a master {} but we do not exists on it, act as if its master failure\", masterNode);\n                                        notifyMasterFailure(masterToPing, \"do not exists on master, act as master failure\");\n                                        return;\n                                    }\n\n                                    int retryCount = ++MasterFaultDetection.this.retryCount;\n                                    logger.trace(\"[master] failed to ping [{}], retry [{}] out of [{}]\", exp, masterNode, retryCount, pingRetryCount);\n                                    if (retryCount >= pingRetryCount) {\n                                        logger.debug(\"[master] failed to ping [{}], tried [{}] times, each with maximum [{}] timeout\", masterNode, pingRetryCount, pingRetryTimeout);\n                                        // not good, failure\n                                        notifyMasterFailure(masterToPing, \"failed to ping, tried [\" + pingRetryCount + \"] times, each with  maximum [\" + pingRetryTimeout + \"] timeout\");\n                                    } else {\n                                        // resend the request, not reschedule, rely on send timeout\n                                        transportService.sendRequest(masterToPing, MASTER_PING_ACTION_NAME, request, options, this);\n                                    }\n                                }\n                            }\n                        }\n\n                        @Override\n                        public String executor() {\n                            return ThreadPool.Names.SAME;\n                        }\n                    }\n            );\n        }","commit_id":"99187e52592a807b0524556b50690cd54c0edaa0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void messageReceived(final MasterPingRequest request, final TransportChannel channel) throws Exception {\n            final DiscoveryNodes nodes = clusterService.state().nodes();\n            // check if we are really the same master as the one we seemed to be think we are\n            // this can happen if the master got \"kill -9\" and then another node started using the same port\n            if (!request.masterNodeId.equals(nodes.localNodeId())) {\n                throw new NotMasterException();\n            }\n\n            // ping from nodes of version < 1.4.0 will have the clustername set to null\n            if (request.clusterName != null && !request.clusterName.equals(clusterName)) {\n                logger.trace(\"master fault detection ping request is targeted for a different [{}] cluster then us [{}]\", request.clusterName, clusterName);\n                throw new NotMasterException(\"master fault detection ping request is targeted for a different [\" + request.clusterName + \"] cluster then us [\" + clusterName + \"]\");\n            }\n\n            // when we are elected as master or when a node joins, we use a cluster state update thread\n            // to incorporate that information in the cluster state. That cluster state is published\n            // before we make it available locally. This means that a master ping can come from a node\n            // that has already processed the new CS but it is not known locally.\n            // Therefore, if we fail we have to check again under a cluster state thread to make sure\n            // all processing is finished.\n            //\n\n\n            if (!nodes.localNodeMaster() || !nodes.nodeExists(request.nodeId)) {\n                logger.trace(\"checking ping from [{}] under a cluster state thread\", request.nodeId);\n                clusterService.submitStateUpdateTask(\"master ping (from: [\" + request.nodeId + \"])\", new ProcessedClusterStateNonMasterUpdateTask() {\n\n                    @Override\n                    public ClusterState execute(ClusterState currentState) throws Exception {\n                        // if we are no longer master, fail...\n                        DiscoveryNodes nodes = currentState.nodes();\n                        if (!nodes.localNodeMaster()) {\n                            throw new NoLongerMasterException();\n                        }\n                        if (!nodes.nodeExists(request.nodeId)) {\n                            throw new NodeDoesNotExistOnMasterException();\n                        }\n                        return currentState;\n                    }\n\n                    @Override\n                    public void onFailure(String source, @Nullable Throwable t) {\n                        if (t == null) {\n                            t = new ElasticsearchException(\"unknown error while processing ping\");\n                        }\n                        try {\n                            channel.sendResponse(t);\n                        } catch (IOException e) {\n                            logger.warn(\"error while sending ping response\", e);\n                        }\n                    }\n\n                    @Override\n                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                        try {\n                            channel.sendResponse(new MasterPingResponseResponse(true));\n                        } catch (IOException e) {\n                            logger.warn(\"error while sending ping response\", e);\n                        }\n                    }\n                });\n            } else {\n                // send a response, and note if we are connected to the master or not\n                channel.sendResponse(new MasterPingResponseResponse(true));\n            }\n        }","id":47366,"modified_method":"@Override\n        public void messageReceived(final MasterPingRequest request, final TransportChannel channel) throws Exception {\n            final DiscoveryNodes nodes = clusterService.state().nodes();\n            // check if we are really the same master as the one we seemed to be think we are\n            // this can happen if the master got \"kill -9\" and then another node started using the same port\n            if (!request.masterNodeId.equals(nodes.localNodeId())) {\n                throw new NotMasterException();\n            }\n\n            // ping from nodes of version < 1.4.0 will have the clustername set to null\n            if (request.clusterName != null && !request.clusterName.equals(clusterName)) {\n                logger.trace(\"master fault detection ping request is targeted for a different [{}] cluster then us [{}]\", request.clusterName, clusterName);\n                throw new NotMasterException(\"master fault detection ping request is targeted for a different [\" + request.clusterName + \"] cluster then us [\" + clusterName + \"]\");\n            }\n\n            // when we are elected as master or when a node joins, we use a cluster state update thread\n            // to incorporate that information in the cluster state. That cluster state is published\n            // before we make it available locally. This means that a master ping can come from a node\n            // that has already processed the new CS but it is not known locally.\n            // Therefore, if we fail we have to check again under a cluster state thread to make sure\n            // all processing is finished.\n            //\n\n            if (!nodes.localNodeMaster() || !nodes.nodeExists(request.nodeId)) {\n                logger.trace(\"checking ping from [{}] under a cluster state thread\", request.nodeId);\n                clusterService.submitStateUpdateTask(\"master ping (from: [\" + request.nodeId + \"])\", new ProcessedClusterStateNonMasterUpdateTask() {\n\n                    @Override\n                    public ClusterState execute(ClusterState currentState) throws Exception {\n                        // if we are no longer master, fail...\n                        DiscoveryNodes nodes = currentState.nodes();\n                        if (!nodes.localNodeMaster()) {\n                            throw new NoLongerMasterException();\n                        }\n                        if (!nodes.nodeExists(request.nodeId)) {\n                            throw new NodeDoesNotExistOnMasterException();\n                        }\n                        return currentState;\n                    }\n\n                    @Override\n                    public void onFailure(String source, @Nullable Throwable t) {\n                        if (t == null) {\n                            t = new ElasticsearchException(\"unknown error while processing ping\");\n                        }\n                        try {\n                            channel.sendResponse(t);\n                        } catch (IOException e) {\n                            logger.warn(\"error while sending ping response\", e);\n                        }\n                    }\n\n                    @Override\n                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {\n                        try {\n                            channel.sendResponse(new MasterPingResponseResponse());\n                        } catch (IOException e) {\n                            logger.warn(\"error while sending ping response\", e);\n                        }\n                    }\n                });\n            } else {\n                // send a response, and note if we are connected to the master or not\n                channel.sendResponse(new MasterPingResponseResponse());\n            }\n        }","commit_id":"99187e52592a807b0524556b50690cd54c0edaa0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            listedOnMaster = in.readBoolean();\n        }","id":47367,"modified_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            if (in.getVersion().onOrBefore(Version.V_1_4_0_Beta1)) {\n                // old listedOnMaster\n                in.readBoolean();\n            }\n        }","commit_id":"99187e52592a807b0524556b50690cd54c0edaa0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            out.writeBoolean(listedOnMaster);\n        }","id":47368,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            if (out.getVersion().onOrBefore(Version.V_1_4_0_Beta1)) {\n                // old listedOnMaster\n                out.writeBoolean(true);\n            }\n        }","commit_id":"99187e52592a807b0524556b50690cd54c0edaa0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMasterFaultDetectionConnectOnDisconnect() throws InterruptedException {\n\n        ImmutableSettings.Builder settings = ImmutableSettings.builder();\n        boolean shouldRetry = randomBoolean();\n        // make sure we don't ping\n        settings.put(FaultDetection.SETTING_CONNECT_ON_NETWORK_DISCONNECT, shouldRetry)\n                .put(FaultDetection.SETTING_PING_INTERVAL, \"5m\");\n        ClusterName clusterName = new ClusterName(randomAsciiOfLengthBetween(3, 20));\n        final ClusterState state = ClusterState.builder(clusterName).nodes(buildNodesForA(false)).build();\n        MasterFaultDetection masterFD = new MasterFaultDetection(settings.build(), threadPool, serviceA, clusterName,\n                new NoopClusterService(state));\n        masterFD.start(nodeB, \"test\");\n\n        final String[] failureReason = new String[1];\n        final DiscoveryNode[] failureNode = new DiscoveryNode[1];\n        final CountDownLatch notified = new CountDownLatch(1);\n        masterFD.addListener(new MasterFaultDetection.Listener() {\n\n            @Override\n            public void onMasterFailure(DiscoveryNode masterNode, String reason) {\n                failureNode[0] = masterNode;\n                failureReason[0] = reason;\n                notified.countDown();\n            }\n\n            @Override\n            public void notListedOnMaster() {\n\n            }\n        });\n        // will raise a disconnect on A\n        serviceB.stop();\n        notified.await(30, TimeUnit.SECONDS);\n\n        assertEquals(nodeB, failureNode[0]);\n        Matcher<String> matcher = Matchers.containsString(\"verified\");\n        if (!shouldRetry) {\n            matcher = Matchers.not(matcher);\n        }\n\n        assertThat(failureReason[0], matcher);\n    }","id":47369,"modified_method":"@Test\n    public void testMasterFaultDetectionConnectOnDisconnect() throws InterruptedException {\n\n        ImmutableSettings.Builder settings = ImmutableSettings.builder();\n        boolean shouldRetry = randomBoolean();\n        // make sure we don't ping\n        settings.put(FaultDetection.SETTING_CONNECT_ON_NETWORK_DISCONNECT, shouldRetry)\n                .put(FaultDetection.SETTING_PING_INTERVAL, \"5m\");\n        ClusterName clusterName = new ClusterName(randomAsciiOfLengthBetween(3, 20));\n        final ClusterState state = ClusterState.builder(clusterName).nodes(buildNodesForA(false)).build();\n        MasterFaultDetection masterFD = new MasterFaultDetection(settings.build(), threadPool, serviceA, clusterName,\n                new NoopClusterService(state));\n        masterFD.start(nodeB, \"test\");\n\n        final String[] failureReason = new String[1];\n        final DiscoveryNode[] failureNode = new DiscoveryNode[1];\n        final CountDownLatch notified = new CountDownLatch(1);\n        masterFD.addListener(new MasterFaultDetection.Listener() {\n\n            @Override\n            public void onMasterFailure(DiscoveryNode masterNode, String reason) {\n                failureNode[0] = masterNode;\n                failureReason[0] = reason;\n                notified.countDown();\n            }\n        });\n        // will raise a disconnect on A\n        serviceB.stop();\n        notified.await(30, TimeUnit.SECONDS);\n\n        assertEquals(nodeB, failureNode[0]);\n        Matcher<String> matcher = Matchers.containsString(\"verified\");\n        if (!shouldRetry) {\n            matcher = Matchers.not(matcher);\n        }\n\n        assertThat(failureReason[0], matcher);\n    }","commit_id":"99187e52592a807b0524556b50690cd54c0edaa0","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendResponse(OutputStream output) throws IOException {\n            List<ResultHandler<?, Void>> results = new ArrayList<ResultHandler<?, Void>>(updates.size());\n\n            final CountDownLatch latch = new CountDownLatch(1);\n            final ServerUpdateController controller = new ServerUpdateController(serverController.getServerModel(),\n                    serviceContainer, executor,\n                    new ServerUpdateCommitHandler() {\n                        public void handleUpdateCommit(ServerUpdateController controller, Status priorStatus) {\n                            configurationPersister.configurationModified();\n                            latch.countDown();\n                        }\n                    }, true, ! preventShutdown);\n\n            boolean requiresRestart = false;\n            for(final AbstractServerModelUpdate<?> update : updates) {\n                requiresRestart |= update.requiresRestart();\n                results.add(addUpdate(update, controller));\n            }\n\n            controller.executeUpdates();\n            try {\n                latch.await();\n            } catch(Exception e) {\n                throw new ManagementException(\"failed to execute updates\", e);\n            }\n\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n            marshaller.writeInt(results.size());\n            for(ResultHandler<?, Void> result : results) {\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT);\n                if(result.failure != null) {\n                    marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT_EXCEPTION);\n                    marshaller.writeObject(result.failure);\n                } else {\n                    marshaller.writeByte(StandaloneClientProtocol.APPLY_UPDATE_RESULT_SERVER_MODEL_SUCCESS);\n                    marshaller.writeObject(result.result);\n                }\n            }\n            marshaller.finish();\n            if(! preventShutdown && requiresRestart) {\n                executor.execute(new Runnable() {\n                     public void run() {\n                         // TODO proper restart handling\n                         serverController.shutdown();\n                         SystemExiter.exit(10);\n                         // shutdownHandler.shutdownRequested();\n                     }\n                 });\n            }\n        }","id":47370,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendResponse(OutputStream output) throws IOException {\n            List<ResultHandler<?, Void>> results = new ArrayList<ResultHandler<?, Void>>(updates.size());\n\n            final CountDownLatch latch = new CountDownLatch(1);\n            final ServerUpdateController controller = new ServerUpdateController(serverController.getServerModel(),\n                    serviceContainer, executor,\n                    new ServerUpdateCommitHandler() {\n                        public void handleUpdateCommit(ServerUpdateController controller, Status priorStatus) {\n                            configurationPersister.configurationModified();\n                            latch.countDown();\n                        }\n                    }, true, ! preventShutdown);\n\n            boolean requiresRestart = false;\n            for(final AbstractServerModelUpdate<?> update : updates) {\n                requiresRestart |= update.requiresRestart();\n                results.add(addUpdate(update, controller));\n            }\n\n            controller.executeUpdates();\n            try {\n                latch.await();\n            } catch(Exception e) {\n                throw new ManagementException(\"failed to execute updates\", e);\n            }\n\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            try {\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n                marshaller.writeInt(results.size());\n                for(ResultHandler<?, Void> result : results) {\n                    marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT);\n                    if(result.failure != null) {\n                        marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT_EXCEPTION);\n                        marshaller.writeObject(result.failure);\n                    } else {\n                        marshaller.writeByte(StandaloneClientProtocol.APPLY_UPDATE_RESULT_SERVER_MODEL_SUCCESS);\n                        marshaller.writeObject(result.result);\n                    }\n                }\n                marshaller.finish();\n            } finally {\n                safeFinish(marshaller);\n            }\n\n            if(! preventShutdown && requiresRestart) {\n                executor.execute(new Runnable() {\n                     public void run() {\n                         // TODO proper restart handling\n                         serverController.shutdown();\n                         SystemExiter.exit(10);\n                         // shutdownHandler.shutdownRequested();\n                     }\n                 });\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void sendResponse(final OutputStream outputStream) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(outputStream));\n            marshaller.writeByte(StandaloneClientProtocol.PARAM_SERVER_MODEL);\n            marshaller.writeObject(serverController.getServerModel());\n            marshaller.finish();\n        }","id":47371,"modified_method":"@Override\n        protected void sendResponse(final OutputStream outputStream) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(outputStream));\n            try {\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_SERVER_MODEL);\n                marshaller.writeObject(serverController.getServerModel());\n                marshaller.finish();\n            } finally {\n                safeFinish(marshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected final void readRequest(final InputStream inputStream) throws IOException {\n\n            ByteDataInput input = null;\n            try {\n                input = new SimpleByteDataInput(inputStream);\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_NAME);\n                deploymentName = input.readUTF();\n            } finally {\n                safeClose(input);\n            }\n\n        }","id":47372,"modified_method":"@Override\n        protected final void readRequest(final InputStream inputStream) throws IOException {\n\n            ByteDataInput input = null;\n            try {\n                input = new SimpleByteDataInput(inputStream);\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_NAME);\n                deploymentName = input.readUTF();\n                input.close();\n            } finally {\n                safeClose(input);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void readRequest(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n            int count = unmarshaller.readInt();\n            updates = new ArrayList<AbstractServerModelUpdate<?>>();\n            for (int i = 0; i < count; i++) {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_SERVER_MODEL_UPDATE);\n                final AbstractServerModelUpdate<?> update = unmarshal(unmarshaller, AbstractServerModelUpdate.class);\n                updates.add(update);\n            }\n            unmarshaller.finish();\n        }","id":47373,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void readRequest(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n                int count = unmarshaller.readInt();\n                updates = new ArrayList<AbstractServerModelUpdate<?>>();\n                for (int i = 0; i < count; i++) {\n                    expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_SERVER_MODEL_UPDATE);\n                    final AbstractServerModelUpdate<?> update = unmarshal(unmarshaller, AbstractServerModelUpdate.class);\n                    updates.add(update);\n                }\n                unmarshaller.finish();\n            } finally {\n                safeFinish(unmarshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected final void readRequest(final InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN);\n            deploymentPlan = unmarshal(unmarshaller, DeploymentPlan.class);\n            unmarshaller.finish();\n        }","id":47374,"modified_method":"@Override\n        protected final void readRequest(final InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN);\n                deploymentPlan = unmarshal(unmarshaller, DeploymentPlan.class);\n                unmarshaller.finish();\n            }\n            finally {\n                safeFinish(unmarshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void sendResponse(final OutputStream output) throws IOException {\n            final Future<ServerDeploymentPlanResult> result = deploymentManager.execute(deploymentPlan);\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            marshaller.writeByte(StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN_RESULT);\n            try {\n                marshaller.writeObject(result.get());\n            } catch (Exception e) {\n                throw new ManagementException(\"Failed get deployment plan result.\", e);\n            }\n            marshaller.finish();\n        }","id":47375,"modified_method":"@Override\n        protected void sendResponse(final OutputStream output) throws IOException {\n            ServerDeploymentPlanResult result = null;\n            try {\n                result = deploymentManager.execute(deploymentPlan).get();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new ManagementException(\"Failed get deployment plan result.\", e);\n            } catch (ExecutionException e) {\n                throw new ManagementException(\"Failed get deployment plan result.\", e);\n            }\n\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            try {\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN_RESULT);\n                marshaller.writeObject(result);\n                marshaller.finish();\n            } finally {\n                safeFinish(marshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected final ServerDeploymentPlanResult receiveResponse(final InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN_RESULT);\n            final ServerDeploymentPlanResult result = unmarshal(unmarshaller, ServerDeploymentPlanResult.class);\n            unmarshaller.finish();\n            return result;\n        }","id":47376,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected final ServerDeploymentPlanResult receiveResponse(final InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN_RESULT);\n                final ServerDeploymentPlanResult result = unmarshal(unmarshaller, ServerDeploymentPlanResult.class);\n                unmarshaller.finish();\n                return result;\n            } finally {\n                safeFinish(unmarshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected final Boolean receiveResponse(final InputStream inputStream) throws IOException {\n            ByteDataInput input = null;\n            try {\n                input = new SimpleByteDataInput(inputStream);\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_NAME_UNIQUE);\n                return input.readBoolean();\n            } finally {\n                safeClose(input);\n            }\n        }","id":47377,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected final Boolean receiveResponse(final InputStream inputStream) throws IOException {\n            ByteDataInput input = null;\n            try {\n                input = new SimpleByteDataInput(inputStream);\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_NAME_UNIQUE);\n                Boolean b = Boolean.valueOf(input.readBoolean());\n                input.close();\n                return b;\n            } finally {\n                safeClose(input);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected final byte[] receiveResponse(final InputStream inputStream) throws IOException {\n            ByteDataInput input = null;\n            try {\n                input = new SimpleByteDataInput(inputStream);\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_HASH_LENGTH);\n                int length = input.readInt();\n                byte[] hash = new byte[length];\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_HASH);\n                input.readFully(hash);\n                return hash;\n            } finally {\n                 safeClose(input);\n            }\n        }","id":47378,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected final byte[] receiveResponse(final InputStream inputStream) throws IOException {\n            ByteDataInput input = null;\n            try {\n                input = new SimpleByteDataInput(inputStream);\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_HASH_LENGTH);\n                int length = input.readInt();\n                byte[] hash = new byte[length];\n                expectHeader(input, StandaloneClientProtocol.PARAM_DEPLOYMENT_HASH);\n                input.readFully(hash);\n                input.close();\n                return hash;\n            } finally {\n                 safeClose(input);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream outputStream) throws IOException {\n            outputStream.write(StandaloneClientProtocol.PARAM_DEPLOYMENT_NAME);\n            StreamUtils.writeUTFZBytes(outputStream, name);\n            outputStream.write(StandaloneClientProtocol.PARAM_DEPLOYMENT_RUNTIME_NAME);\n            StreamUtils.writeUTFZBytes(outputStream, runtimeName);\n            outputStream.write(StandaloneClientProtocol.PARAM_DEPLOYMENT_CONTENT);\n            try {\n                byte[] buffer = new byte[8192];\n                int read;\n                while ((read = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, read);\n                }\n            } finally {\n                safeClose(inputStream);\n            }\n        }","id":47379,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream outputStream) throws IOException {\n            outputStream.write(StandaloneClientProtocol.PARAM_DEPLOYMENT_NAME);\n            StreamUtils.writeUTFZBytes(outputStream, name);\n            outputStream.write(StandaloneClientProtocol.PARAM_DEPLOYMENT_RUNTIME_NAME);\n            StreamUtils.writeUTFZBytes(outputStream, runtimeName);\n            outputStream.write(StandaloneClientProtocol.PARAM_DEPLOYMENT_CONTENT);\n            try {\n                byte[] buffer = new byte[8192];\n                int read;\n                while ((read = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, read);\n                }\n                inputStream.close();\n            } finally {\n                safeClose(inputStream);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n            marshaller.writeInt(updates.size());\n            for (AbstractServerModelUpdate<?> update : updates) {\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_SERVER_MODEL_UPDATE);\n                marshaller.writeObject(update);\n            }\n            marshaller.finish();\n        }","id":47380,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(int protocolVersion, OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            try {\n                marshaller.start(createByteOutput(output));\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n                marshaller.writeInt(updates.size());\n                for (AbstractServerModelUpdate<?> update : updates) {\n                    marshaller.writeByte(StandaloneClientProtocol.PARAM_SERVER_MODEL_UPDATE);\n                    marshaller.writeObject(update);\n                }\n                marshaller.finish();\n            }\n            finally {\n                safeFinish(marshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected List<StandaloneUpdateResult<?>> receiveResponse(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n            final int updateCount = unmarshaller.readInt();\n            List<StandaloneUpdateResult<?>> results = new ArrayList<StandaloneUpdateResult<?>>();\n            for (int i = 0; i < updateCount; i++) {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT);\n                byte resultCode = unmarshaller.readByte();\n                if (resultCode == (byte) StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT_EXCEPTION) {\n                    final UpdateFailedException failure = unmarshal(unmarshaller, UpdateFailedException.class);\n                    results.add(new StandaloneUpdateResult<Object>(null, failure));\n                } else {\n                    final Object result = unmarshal(unmarshaller, Object.class);\n                    results.add(new StandaloneUpdateResult<Object>(result, null));\n                }\n            }\n            return results;\n        }","id":47381,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected List<StandaloneUpdateResult<?>> receiveResponse(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_APPLY_UPDATES_RESULT_COUNT);\n                final int updateCount = unmarshaller.readInt();\n                List<StandaloneUpdateResult<?>> results = new ArrayList<StandaloneUpdateResult<?>>();\n                for (int i = 0; i < updateCount; i++) {\n                    expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT);\n                    byte resultCode = unmarshaller.readByte();\n                    if (resultCode == (byte) StandaloneClientProtocol.PARAM_APPLY_UPDATE_RESULT_EXCEPTION) {\n                        final UpdateFailedException failure = unmarshal(unmarshaller, UpdateFailedException.class);\n                        results.add(new StandaloneUpdateResult<Object>(null, failure));\n                    } else {\n                        final Object result = unmarshal(unmarshaller, Object.class);\n                        results.add(new StandaloneUpdateResult<Object>(result, null));\n                    }\n                }\n                unmarshaller.finish();\n                return results;\n            } finally {\n                safeFinish(unmarshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(final int protocolVersion, final OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            marshaller.writeByte(StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN);\n            marshaller.writeObject(deploymentPlan);\n            marshaller.finish();\n        }","id":47382,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected void sendRequest(final int protocolVersion, final OutputStream output) throws IOException {\n            final Marshaller marshaller = getMarshaller();\n            marshaller.start(createByteOutput(output));\n            try {\n                marshaller.writeByte(StandaloneClientProtocol.PARAM_DEPLOYMENT_PLAN);\n                marshaller.writeObject(deploymentPlan);\n                marshaller.finish();\n            } finally {\n                safeFinish(marshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"boolean isDeploymentNameUnique(String name) {\n        try {\n            return new CheckUnitDeploymentNameOperation(name).executeForResult(getConnectionStrategy());\n        } catch (Exception e) {\n            throw new ManagementException(\"Failed to check deployment name uniqueness.\", e);\n        }\n    }","id":47383,"modified_method":"boolean isDeploymentNameUnique(String name) {\n        try {\n            Boolean b = new CheckUnitDeploymentNameOperation(name).executeForResult(getConnectionStrategy());\n            return b.booleanValue();\n        } catch (Exception e) {\n            throw new ManagementException(\"Failed to check deployment name uniqueness.\", e);\n        }\n    }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n        @Override\n        protected ServerModel receiveResponse(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_SERVER_MODEL);\n            final ServerModel serverModel = unmarshal(unmarshaller, ServerModel.class);\n            unmarshaller.finish();\n            return serverModel;\n        }","id":47384,"modified_method":"/** {@inheritDoc} */\n        @Override\n        protected ServerModel receiveResponse(InputStream input) throws IOException {\n            final Unmarshaller unmarshaller = getUnmarshaller();\n            unmarshaller.start(createByteInput(input));\n            try {\n                expectHeader(unmarshaller, StandaloneClientProtocol.PARAM_SERVER_MODEL);\n                final ServerModel serverModel = unmarshal(unmarshaller, ServerModel.class);\n                unmarshaller.finish();\n                return serverModel;\n            } finally {\n                safeFinish(unmarshaller);\n            }\n        }","commit_id":"2cb8f0baedee62b99d1d5eedeca7da0a53f2383e","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void main(String[] args){\n    final long processStart = System.currentTimeMillis();\n    System.out.println(\"Build process started. Classpath: \" + System.getProperty(\"java.class.path\"));\n    final String host = args[HOST_ARG];\n    final int port = Integer.parseInt(args[PORT_ARG]);\n    final UUID sessionId = UUID.fromString(args[SESSION_ID_ARG]);\n    @SuppressWarnings(\"ConstantConditions\")\n    final File systemDir = new File(FileUtil.toCanonicalPath(args[SYSTEM_DIR_ARG]));\n    Utils.setSystemRoot(systemDir);\n\n    // IDEA-123132, let's try again\n    for (int attempt = 0; attempt < 3; attempt++) {\n      try {\n        ourEventLoopGroup = new NioEventLoopGroup(1, SharedThreadPool.getInstance());\n        break;\n      }\n      catch (IllegalStateException e) {\n        if (attempt == 2) {\n          printErrorAndExit(host, port, e);\n          return;\n        }\n        else {\n          LOG.warn(\"Cannot create event loop, attempt #\" + attempt, e);\n          try {\n            //noinspection BusyWait\n            Thread.sleep(10 * (attempt + 1));\n          }\n          catch (InterruptedException ignored) {\n          }\n        }\n      }\n    }\n\n    final Bootstrap bootstrap = new Bootstrap().group(ourEventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer() {\n      @Override\n      protected void initChannel(Channel channel) throws Exception {\n        channel.pipeline().addLast(new ProtobufVarint32FrameDecoder(),\n                                   new ProtobufDecoder(CmdlineRemoteProto.Message.getDefaultInstance()),\n                                   new ProtobufVarint32LengthFieldPrepender(),\n                                   new ProtobufEncoder(),\n                                   new MyMessageHandler(sessionId));\n      }\n    }).option(ChannelOption.TCP_NODELAY, true).option(ChannelOption.SO_KEEPALIVE, true);\n\n    final ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).awaitUninterruptibly();\n    final boolean success = future.isSuccess();\n    if (success) {\n      final String projectPathToPreload = System.getProperty(PRELOAD_PROJECT_PATH, null);\n      final String globalsPathToPreload = System.getProperty(PRELOAD_CONFIG_PATH, null); \n      if (projectPathToPreload != null && globalsPathToPreload != null) {\n        final PreloadedData data = new PreloadedData();\n        ourPreloadedData = data;\n        try {\n          FileSystemUtil.getAttributes(projectPathToPreload); // this will pre-load all FS optimizations\n\n          final BuildRunner runner = new BuildRunner(new JpsModelLoaderImpl(projectPathToPreload, globalsPathToPreload, null));\n          data.setRunner(runner);\n\n          final File dataStorageRoot = Utils.getDataStorageRoot(projectPathToPreload);\n          final BuildFSState fsState = new BuildFSState(false);\n          final ProjectDescriptor pd = runner.load(new MessageHandler() {\n            @Override\n            public void processMessage(BuildMessage msg) {\n              data.addMessage(msg);\n            }\n          }, dataStorageRoot, fsState);\n          data.setProjectDescriptor(pd);\n          \n          try {\n            final File fsStateFile = new File(dataStorageRoot, BuildSession.FS_STATE_FILE);\n            final DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(fsStateFile)));\n            try {\n              final int version = in.readInt();\n              if (version == FSState.VERSION) {\n                final long savedOrdinal = in.readLong();\n                in.readBoolean(); // must skip \"has-work-to-do\" flag\n                fsState.load(in, pd.getModel(), pd.getBuildRootIndex());\n                data.setFsEventOrdinal(savedOrdinal);\n              }\n            }\n            finally {\n              in.close();\n            }\n          }\n          catch (FileNotFoundException ignored) {\n          }\n          catch (IOException e) {\n            LOG.info(\"Error pre-loading FS state\", e);\n            fsState.clearAll();\n          }\n\n          // preloading target configurations\n          final BuildTargetsState targetsState = pd.getTargetsState();\n          for (BuildTarget<?> target : pd.getBuildTargetIndex().getAllTargets()) {\n            targetsState.getTargetConfiguration(target);\n          }\n\n          BuilderRegistry.getInstance();\n\n          LOG.info(\"Pre-loaded process ready in \" + (System.currentTimeMillis() - processStart) + \" ms\");\n        }\n        catch (Throwable e) {\n          LOG.info(\"Failed to pre-load project \" + projectPathToPreload, e);\n          // just failed to preload the project, the situation will be handled later, when real build starts\n        }\n      }\n      else if (projectPathToPreload != null || globalsPathToPreload != null){\n        LOG.info(\"Skipping project pre-loading step: both paths to project configuration files and path to global settings must be specified\");\n      }\n      future.channel().writeAndFlush(CmdlineProtoUtil.toMessage(sessionId, CmdlineProtoUtil.createParamRequest()));\n    }\n    else {\n      printErrorAndExit(host, port, future.cause());\n    }\n  }","id":47385,"modified_method":"public static void main(String[] args){\n    final long processStart = System.currentTimeMillis();\n    System.out.println(\"Build process started. Classpath: \" + System.getProperty(\"java.class.path\"));\n    final String host = args[HOST_ARG];\n    final int port = Integer.parseInt(args[PORT_ARG]);\n    final UUID sessionId = UUID.fromString(args[SESSION_ID_ARG]);\n    @SuppressWarnings(\"ConstantConditions\")\n    final File systemDir = new File(FileUtil.toCanonicalPath(args[SYSTEM_DIR_ARG]));\n    Utils.setSystemRoot(systemDir);\n\n    // IDEA-123132, let's try again\n    for (int attempt = 0; attempt < 3; attempt++) {\n      try {\n        ourEventLoopGroup = new NioEventLoopGroup(1, SharedThreadPool.getInstance());\n        break;\n      }\n      catch (IllegalStateException e) {\n        if (attempt == 2) {\n          printErrorAndExit(host, port, e);\n          return;\n        }\n        else {\n          LOG.warn(\"Cannot create event loop, attempt #\" + attempt, e);\n          try {\n            //noinspection BusyWait\n            Thread.sleep(10 * (attempt + 1));\n          }\n          catch (InterruptedException ignored) {\n          }\n        }\n      }\n    }\n\n    final Bootstrap bootstrap = new Bootstrap().group(ourEventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer() {\n      @Override\n      protected void initChannel(Channel channel) throws Exception {\n        channel.pipeline().addLast(new ProtobufVarint32FrameDecoder(),\n                                   new ProtobufDecoder(CmdlineRemoteProto.Message.getDefaultInstance()),\n                                   new ProtobufVarint32LengthFieldPrepender(),\n                                   new ProtobufEncoder(),\n                                   new MyMessageHandler(sessionId));\n      }\n    }).option(ChannelOption.TCP_NODELAY, true).option(ChannelOption.SO_KEEPALIVE, true);\n\n    final ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).awaitUninterruptibly();\n    final boolean success = future.isSuccess();\n    if (success) {\n      final String projectPathToPreload = System.getProperty(PRELOAD_PROJECT_PATH, null);\n      final String globalsPathToPreload = System.getProperty(PRELOAD_CONFIG_PATH, null); \n      if (projectPathToPreload != null && globalsPathToPreload != null) {\n        final PreloadedData data = new PreloadedData();\n        ourPreloadedData = data;\n        try {\n          FileSystemUtil.getAttributes(projectPathToPreload); // this will pre-load all FS optimizations\n\n          final BuildRunner runner = new BuildRunner(new JpsModelLoaderImpl(projectPathToPreload, globalsPathToPreload, null));\n          data.setRunner(runner);\n\n          final File dataStorageRoot = Utils.getDataStorageRoot(projectPathToPreload);\n          final BuildFSState fsState = new BuildFSState(false);\n          final ProjectDescriptor pd = runner.load(new MessageHandler() {\n            @Override\n            public void processMessage(BuildMessage msg) {\n              data.addMessage(msg);\n            }\n          }, dataStorageRoot, fsState);\n          data.setProjectDescriptor(pd);\n          \n          try {\n            final File fsStateFile = new File(dataStorageRoot, BuildSession.FS_STATE_FILE);\n            final DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(fsStateFile)));\n            try {\n              final int version = in.readInt();\n              if (version == FSState.VERSION) {\n                final long savedOrdinal = in.readLong();\n                final boolean hasWorkToDo = in.readBoolean();// must skip \"has-work-to-do\" flag\n                fsState.load(in, pd.getModel(), pd.getBuildRootIndex());\n                data.setFsEventOrdinal(savedOrdinal);\n                data.setHasHasWorkToDo(hasWorkToDo);\n              }\n            }\n            finally {\n              in.close();\n            }\n          }\n          catch (FileNotFoundException ignored) {\n          }\n          catch (IOException e) {\n            LOG.info(\"Error pre-loading FS state\", e);\n            fsState.clearAll();\n          }\n\n          // preloading target configurations\n          final BuildTargetsState targetsState = pd.getTargetsState();\n          for (BuildTarget<?> target : pd.getBuildTargetIndex().getAllTargets()) {\n            targetsState.getTargetConfiguration(target);\n          }\n\n          BuilderRegistry.getInstance();\n\n          LOG.info(\"Pre-loaded process ready in \" + (System.currentTimeMillis() - processStart) + \" ms\");\n        }\n        catch (Throwable e) {\n          LOG.info(\"Failed to pre-load project \" + projectPathToPreload, e);\n          // just failed to preload the project, the situation will be handled later, when real build starts\n        }\n      }\n      else if (projectPathToPreload != null || globalsPathToPreload != null){\n        LOG.info(\"Skipping project pre-loading step: both paths to project configuration files and path to global settings must be specified\");\n      }\n      future.channel().writeAndFlush(CmdlineProtoUtil.toMessage(sessionId, CmdlineProtoUtil.createParamRequest()));\n    }\n    else {\n      printErrorAndExit(host, port, future.cause());\n    }\n  }","commit_id":"1b719d1f2fbb27c4507da9101b5e6b29d3bcfc38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void runBuild(final MessageHandler msgHandler, CanceledStatus cs) throws Throwable{\n    final File dataStorageRoot = Utils.getDataStorageRoot(myProjectPath);\n    if (dataStorageRoot == null) {\n      msgHandler.processMessage(new CompilerMessage(\"build\", BuildMessage.Kind.ERROR, \"Cannot determine build data storage root for project \" + myProjectPath));\n      return;\n    }\n    if (!dataStorageRoot.exists()) {\n      // invoked the very first time for this project\n      myBuildRunner.setForceCleanCaches(true);\n    }\n    final ProjectDescriptor preloadedProject = myPreloadedData != null? myPreloadedData.getProjectDescriptor() : null;\n    final DataInputStream fsStateStream = \n      preloadedProject != null || myInitialFSDelta == null /*this will force FS rescan*/? null : createFSDataStream(dataStorageRoot, myInitialFSDelta.getOrdinal());\n\n    if (fsStateStream != null) {\n      // optimization: check whether we can skip the build\n      final boolean hasWorkToDoWithModules = fsStateStream.readBoolean() || myInitialFSDelta == null;\n      if (!myForceModelLoading && (myBuildType == BuildType.BUILD || myBuildType == BuildType.UP_TO_DATE_CHECK) && !hasWorkToDoWithModules\n          && scopeContainsModulesOnlyForIncrementalMake(myScopes) && !containsChanges(myInitialFSDelta)) {\n        updateFsStateOnDisk(dataStorageRoot, fsStateStream, myInitialFSDelta.getOrdinal());\n        return;\n      }\n    }\n\n    final BuildFSState fsState = preloadedProject != null? preloadedProject.fsState : new BuildFSState(false);\n    try {\n      final ProjectDescriptor pd;\n      if (preloadedProject != null) {\n        pd = preloadedProject;\n        final List<BuildMessage> preloadMessages = myPreloadedData.getLoadMessages();\n        if (!preloadMessages.isEmpty()) {\n          // replay preload-time messages, so that they are delivered to the IDE\n          for (BuildMessage message : preloadMessages) {\n            msgHandler.processMessage(message);\n          }\n        }\n        if (myInitialFSDelta == null || myPreloadedData.getFsEventOrdinal() + 1L != myInitialFSDelta.getOrdinal()) {\n          // FS rescan was forced\n          fsState.clearAll(); \n        }\n        else {\n          // apply events to already loaded state\n          try {\n            applyFSEvent(pd, myInitialFSDelta, false);\n          }\n          catch (Throwable e) {\n            LOG.error(e);\n            fsState.clearAll();\n          }\n        }\n      }\n      else {\n        // standard case\n        pd = myBuildRunner.load(msgHandler, dataStorageRoot, fsState);\n        TimingLog.LOG.debug(\"Project descriptor loaded\");\n        if (fsStateStream != null) {\n          try {\n            try {\n              fsState.load(fsStateStream, pd.getModel(), pd.getBuildRootIndex());\n              applyFSEvent(pd, myInitialFSDelta, false);\n              TimingLog.LOG.debug(\"FS Delta loaded\");\n            }\n            finally {\n              fsStateStream.close();\n            }\n          }\n          catch (Throwable e) {\n            LOG.error(e);\n            fsState.clearAll();\n          }\n        }\n      }\n      myProjectDescriptor = pd;\n      \n      myLastEventOrdinal = myInitialFSDelta != null? myInitialFSDelta.getOrdinal() : 0L;\n\n      // free memory\n      myInitialFSDelta = null;\n      // ensure events from controller are processed after FSState initialization\n      myEventsProcessor.startProcessing();\n\n      myBuildRunner.runBuild(pd, cs, myConstantSearch, msgHandler, myBuildType, myScopes, false);\n      TimingLog.LOG.debug(\"Build finished\");\n    }\n    finally {\n      saveData(fsState, dataStorageRoot);\n    }\n  }","id":47386,"modified_method":"private void runBuild(final MessageHandler msgHandler, CanceledStatus cs) throws Throwable{\n    final File dataStorageRoot = Utils.getDataStorageRoot(myProjectPath);\n    if (dataStorageRoot == null) {\n      msgHandler.processMessage(new CompilerMessage(\"build\", BuildMessage.Kind.ERROR, \"Cannot determine build data storage root for project \" + myProjectPath));\n      return;\n    }\n    if (!dataStorageRoot.exists()) {\n      // invoked the very first time for this project\n      myBuildRunner.setForceCleanCaches(true);\n    }\n    final ProjectDescriptor preloadedProject = myPreloadedData != null? myPreloadedData.getProjectDescriptor() : null;\n    final DataInputStream fsStateStream = \n      preloadedProject != null || myInitialFSDelta == null /*this will force FS rescan*/? null : createFSDataStream(dataStorageRoot, myInitialFSDelta.getOrdinal());\n\n    if (fsStateStream != null || myPreloadedData != null) {\n      // optimization: check whether we can skip the build\n      final boolean hasWorkFlag = fsStateStream != null? fsStateStream.readBoolean() : myPreloadedData.hasWorkToDo();\n      final boolean hasWorkToDoWithModules = hasWorkFlag || myInitialFSDelta == null;\n      if (!myForceModelLoading && (myBuildType == BuildType.BUILD || myBuildType == BuildType.UP_TO_DATE_CHECK) && !hasWorkToDoWithModules\n          && scopeContainsModulesOnlyForIncrementalMake(myScopes) && !containsChanges(myInitialFSDelta)) {\n\n        final DataInputStream storedFsData;\n        if (myPreloadedData != null) {\n          storedFsData = createFSDataStream(dataStorageRoot, myInitialFSDelta.getOrdinal());\n          if (storedFsData != null) {\n            storedFsData.readBoolean(); // skip hasWorkToDo flag\n          }\n        }\n        else {\n          storedFsData = fsStateStream;\n        }\n\n        if (storedFsData != null) {\n          updateFsStateOnDisk(dataStorageRoot, storedFsData, myInitialFSDelta.getOrdinal());\n          return;\n        }\n      }\n    }\n\n    final BuildFSState fsState = preloadedProject != null? preloadedProject.fsState : new BuildFSState(false);\n    try {\n      final ProjectDescriptor pd;\n      if (preloadedProject != null) {\n        pd = preloadedProject;\n        final List<BuildMessage> preloadMessages = myPreloadedData.getLoadMessages();\n        if (!preloadMessages.isEmpty()) {\n          // replay preload-time messages, so that they are delivered to the IDE\n          for (BuildMessage message : preloadMessages) {\n            msgHandler.processMessage(message);\n          }\n        }\n        if (myInitialFSDelta == null || myPreloadedData.getFsEventOrdinal() + 1L != myInitialFSDelta.getOrdinal()) {\n          // FS rescan was forced\n          fsState.clearAll(); \n        }\n        else {\n          // apply events to already loaded state\n          try {\n            applyFSEvent(pd, myInitialFSDelta, false);\n          }\n          catch (Throwable e) {\n            LOG.error(e);\n            fsState.clearAll();\n          }\n        }\n      }\n      else {\n        // standard case\n        pd = myBuildRunner.load(msgHandler, dataStorageRoot, fsState);\n        TimingLog.LOG.debug(\"Project descriptor loaded\");\n        if (fsStateStream != null) {\n          try {\n            try {\n              fsState.load(fsStateStream, pd.getModel(), pd.getBuildRootIndex());\n              applyFSEvent(pd, myInitialFSDelta, false);\n              TimingLog.LOG.debug(\"FS Delta loaded\");\n            }\n            finally {\n              fsStateStream.close();\n            }\n          }\n          catch (Throwable e) {\n            LOG.error(e);\n            fsState.clearAll();\n          }\n        }\n      }\n      myProjectDescriptor = pd;\n      \n      myLastEventOrdinal = myInitialFSDelta != null? myInitialFSDelta.getOrdinal() : 0L;\n\n      // free memory\n      myInitialFSDelta = null;\n      // ensure events from controller are processed after FSState initialization\n      myEventsProcessor.startProcessing();\n\n      myBuildRunner.runBuild(pd, cs, myConstantSearch, msgHandler, myBuildType, myScopes, false);\n      TimingLog.LOG.debug(\"Build finished\");\n    }\n    finally {\n      saveData(fsState, dataStorageRoot);\n    }\n  }","commit_id":"1b719d1f2fbb27c4507da9101b5e6b29d3bcfc38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"BuildSession(UUID sessionId,\n               Channel channel,\n               CmdlineRemoteProto.Message.ControllerMessage.ParametersMessage params,\n               @Nullable CmdlineRemoteProto.Message.ControllerMessage.FSEvent delta, @Nullable PreloadedData preloaded) {\n    mySessionId = sessionId;\n    myChannel = channel;\n    myPreloadedData = preloaded;\n    \n    final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals = params.getGlobalSettings();\n    myProjectPath = FileUtil.toCanonicalPath(params.getProjectId());\n    String globalOptionsPath = FileUtil.toCanonicalPath(globals.getGlobalOptionsPath());\n    myBuildType = convertCompileType(params.getBuildType());\n    myScopes = params.getScopeList();\n    List<String> filePaths = params.getFilePathList();\n    final Map<String, String> builderParams = new HashMap<String, String>();\n    for (CmdlineRemoteProto.Message.KeyValuePair pair : params.getBuilderParameterList()) {\n      builderParams.put(pair.getKey(), pair.getValue());\n    }\n    myInitialFSDelta = delta;\n    if (preloaded == null || preloaded.getRunner() == null) {\n      myBuildRunner = new BuildRunner(new JpsModelLoaderImpl(myProjectPath, globalOptionsPath, null));\n    }\n    else {\n      myBuildRunner = preloaded.getRunner();\n    }\n    myBuildRunner.setFilePaths(filePaths);\n    myBuildRunner.setBuilderParams(builderParams);\n    myForceModelLoading = (preloaded != null && preloaded.getProjectDescriptor() != null) || Boolean.parseBoolean(builderParams.get(BuildParametersKeys.FORCE_MODEL_LOADING));\n  }","id":47387,"modified_method":"BuildSession(UUID sessionId,\n               Channel channel,\n               CmdlineRemoteProto.Message.ControllerMessage.ParametersMessage params,\n               @Nullable CmdlineRemoteProto.Message.ControllerMessage.FSEvent delta, @Nullable PreloadedData preloaded) {\n    mySessionId = sessionId;\n    myChannel = channel;\n    myPreloadedData = preloaded;\n    \n    final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals = params.getGlobalSettings();\n    myProjectPath = FileUtil.toCanonicalPath(params.getProjectId());\n    String globalOptionsPath = FileUtil.toCanonicalPath(globals.getGlobalOptionsPath());\n    myBuildType = convertCompileType(params.getBuildType());\n    myScopes = params.getScopeList();\n    List<String> filePaths = params.getFilePathList();\n    final Map<String, String> builderParams = new HashMap<String, String>();\n    for (CmdlineRemoteProto.Message.KeyValuePair pair : params.getBuilderParameterList()) {\n      builderParams.put(pair.getKey(), pair.getValue());\n    }\n    myInitialFSDelta = delta;\n    if (preloaded == null || preloaded.getRunner() == null) {\n      myBuildRunner = new BuildRunner(new JpsModelLoaderImpl(myProjectPath, globalOptionsPath, null));\n    }\n    else {\n      myBuildRunner = preloaded.getRunner();\n    }\n    myBuildRunner.setFilePaths(filePaths);\n    myBuildRunner.setBuilderParams(builderParams);\n    myForceModelLoading =  Boolean.parseBoolean(builderParams.get(BuildParametersKeys.FORCE_MODEL_LOADING));\n  }","commit_id":"1b719d1f2fbb27c4507da9101b5e6b29d3bcfc38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Map<K, V> getAll(Set<K> keys) {\n        Set keyset = new HashSet(keys.size());\n        for (Object key : keys) {\n            keyset.add(toData(key));\n        }\n        MapGetAllRequest request = new MapGetAllRequest(name, keyset);\n        MapEntrySet mapEntrySet = invoke(request);\n        Map<K,V> result = new HashMap<K, V>();\n        Set<Entry<Data, Data>> entrySet = mapEntrySet.getEntrySet();\n        for (Entry<Data, Data> dataEntry : entrySet) {\n            result.put((K)toObject(dataEntry.getKey()), (V)toObject(dataEntry.getValue()));\n        }\n        return result;\n    }","id":47388,"modified_method":"public Map<K, V> getAll(Set<K> keys) {\n        Set keySet = new HashSet(keys.size());\n        for (Object key : keys) {\n            keySet.add(toData(key));\n        }\n        MapGetAllRequest request = new MapGetAllRequest(name, keySet);\n        MapEntrySet mapEntrySet = invoke(request);\n        Map<K,V> result = new HashMap<K, V>();\n        Set<Entry<Data, Data>> entrySet = mapEntrySet.getEntrySet();\n        for (Entry<Data, Data> dataEntry : entrySet) {\n            result.put((K) toObject(dataEntry.getKey()), (V) toObject(dataEntry.getValue()));\n        }\n        return result;\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public String addEntryListener(EntryListener<K, V> listener, K key, boolean includeValue) {\n        return null;\n    }","id":47389,"modified_method":"public String addEntryListener(EntryListener<K, V> listener, K key, boolean includeValue) {\n        final Data keyData = toData(key);\n        MapAddEntryListenerRequest request = new MapAddEntryListenerRequest(name, keyData, includeValue);\n        EventHandler<PortableEntryEvent> handler = createHandler(listener, includeValue);\n        return listen(request, keyData, handler);\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public String addEntryListener(EntryListener<K, V> listener, Predicate<K, V> predicate, K key, boolean includeValue) {\n        return null;\n    }","id":47390,"modified_method":"public String addEntryListener(EntryListener<K, V> listener, Predicate<K, V> predicate, K key, boolean includeValue) {\n        final Data keyData = toData(key);\n        MapAddEntryListenerRequest request = new MapAddEntryListenerRequest(name, keyData, includeValue, predicate);\n        EventHandler<PortableEntryEvent> handler = createHandler(listener, includeValue);\n        return listen(request, keyData, handler);\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected void onDestroy() {\n        //TODO ?\n    }","id":47391,"modified_method":"protected void onDestroy() {\n        MapDestroyRequest request = new MapDestroyRequest(name);\n        invoke(request);\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public String addEntryListener(EntryListener<K, V> listener, boolean includeValue) {\n        return null;\n    }","id":47392,"modified_method":"public String addEntryListener(EntryListener<K, V> listener, boolean includeValue) {\n        MapAddEntryListenerRequest request = new MapAddEntryListenerRequest(name, includeValue);\n        EventHandler<PortableEntryEvent> handler = createHandler(listener, includeValue);\n        return listen(request, handler);\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean removeEntryListener(String id) {\n        return false;\n    }","id":47393,"modified_method":"public boolean removeEntryListener(String id) {\n        return stopListening(id);\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Object call() {\n        final ClientEndpoint endpoint = getEndpoint();\n        final ClientEngine clientEngine = getClientEngine();\n        final MapService mapService = getService();\n        final MutableString id = new MutableString();\n        EntryListener<Object, Object> listener = new EntryListener<Object, Object>() {\n\n            private void handleEvent(EntryEvent<Object, Object> event){\n                if (endpoint.live()) {\n                    clientEngine.sendResponse(endpoint, new PortableEntryEvent(event));\n                } else {\n                    mapService.removeEventListener(name, id.getString());\n                }\n            }\n\n            @Override\n            public void entryAdded(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n\n            @Override\n            public void entryRemoved(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n\n            @Override\n            public void entryUpdated(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n\n            @Override\n            public void entryEvicted(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n        };\n\n        EventFilter eventFilter = new EntryEventFilter(includeValue, key);\n        if(local) {\n            id.setString(mapService.addLocalEventListener(listener, name));\n        }\n        else {\n            id.setString(mapService.addEventListener(listener, eventFilter, name));\n        }\n\n        return true;\n    }","id":47394,"modified_method":"@Override\n    public Object call() {\n        final ClientEndpoint endpoint = getEndpoint();\n        final ClientEngine clientEngine = getClientEngine();\n        final MapService mapService = getService();\n        EntryListener<Object, Object> listener = new EntryListener<Object, Object>() {\n\n            private void handleEvent(EntryEvent<Object, Object> event) {\n                if (endpoint.live()) {\n                    Data key = clientEngine.toData(event.getKey());\n                    Data value = clientEngine.toData(event.getValue());\n                    Data oldValue = clientEngine.toData(event.getOldValue());\n                    PortableEntryEvent portableEntryEvent = new PortableEntryEvent(key, value, oldValue, event.getEventType(), event.getMember().getUuid());\n                    clientEngine.sendResponse(endpoint, portableEntryEvent);\n                } else {\n                    mapService.removeEventListener(name, registrationId);\n                }\n            }\n\n            public void entryAdded(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n\n            public void entryRemoved(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n\n            public void entryUpdated(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n\n            public void entryEvicted(EntryEvent<Object, Object> event) {\n                handleEvent(event);\n            }\n        };\n\n        EventFilter eventFilter = null;\n        if (predicate == null){\n            eventFilter = new EntryEventFilter(includeValue, key);\n        } else {\n            eventFilter = new QueryEventFilter(includeValue, key, predicate);\n        }\n        registrationId = mapService.addEventListener(listener, eventFilter, name);\n        return true;\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MapAddEntryListenerRequest(String name) {\n        this.name = name;\n    }","id":47395,"modified_method":"public MapAddEntryListenerRequest(String name, boolean includeValue) {\n        this.name = name;\n        this.includeValue = includeValue;\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void readPortable(PortableReader reader) throws IOException {\n        name = reader.readUTF(\"name\");\n        includeValue = reader.readBoolean(\"i\");\n        local = reader.readBoolean(\"local\");\n        boolean hasKey = reader.readBoolean(\"key\");\n\n        if (hasKey) {\n            final ObjectDataInput in = reader.getRawDataInput();\n            key = new Data();\n            key.readData(in);\n        }\n    }","id":47396,"modified_method":"public void readPortable(PortableReader reader) throws IOException {\n        name = reader.readUTF(\"name\");\n        includeValue = reader.readBoolean(\"i\");\n        boolean hasKey = reader.readBoolean(\"key\");\n        if (reader.readBoolean(\"pre\")){\n            predicate = (Predicate)reader.readPortable(\"p\");\n        }\n        if (hasKey) {\n            final ObjectDataInput in = reader.getRawDataInput();\n            key = new Data();\n            key.readData(in);\n        }\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void writePortable(PortableWriter writer) throws IOException {\n        writer.writeUTF(\"name\", name);\n        writer.writeBoolean(\"i\", includeValue);\n        writer.writeBoolean(\"local\", local);\n        final boolean hasKey = key != null;\n        writer.writeBoolean(\"key\", hasKey);\n\n        if (hasKey) {\n            final ObjectDataOutput out = writer.getRawDataOutput();\n            key.writeData(out);\n        }\n    }","id":47397,"modified_method":"public void writePortable(PortableWriter writer) throws IOException {\n        writer.writeUTF(\"name\", name);\n        writer.writeBoolean(\"i\", includeValue);\n        final boolean hasKey = key != null;\n        writer.writeBoolean(\"key\", hasKey);\n        if (predicate == null){\n            writer.writeBoolean(\"pre\", false);\n        } else {\n            writer.writeBoolean(\"pre\", true);\n            writer.writePortable(\"p\",(Portable)predicate);\n        }\n        if (hasKey) {\n            final ObjectDataOutput out = writer.getRawDataOutput();\n            key.writeData(out);\n        }\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MapAddEntryListenerRequest(String name, Data key, boolean includeValue, boolean local) {\n        this.name = name;\n        this.includeValue = includeValue;\n        this.key = key;\n        this.local = local;\n    }","id":47398,"modified_method":"public MapAddEntryListenerRequest(String name, Data key, boolean includeValue) {\n        this(name, includeValue);\n        this.key = key;\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public PortableFactory createFactory() {\n        return new PortableFactory() {\n            final ConstructorFunction<Integer, Portable> constructors[] = new ConstructorFunction[PORTABLE_ENTRY_EVENT+1];\n\n            {\n                constructors[GET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapGetRequest();\n                    }\n                };\n\n                constructors[PUT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutRequest();\n                    }\n                };\n\n                constructors[PUT_IF_ABSENT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutIfAbsentRequest();\n                    }\n                };\n\n                constructors[TRY_PUT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapTryPutRequest();\n                    }\n                };\n\n                constructors[PUT_TRANSIENT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutTransientRequest();\n                    }\n                };\n\n                constructors[SET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapSetRequest();\n                    }\n                };\n\n                constructors[CONTAINS_KEY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapContainsKeyRequest();\n                    }\n                };\n\n                constructors[CONTAINS_VALUE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapContainsValueRequest();\n                    }\n                };\n\n                constructors[REMOVE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapRemoveRequest();\n                    }\n                };\n\n                constructors[REMOVE_IF_SAME] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapRemoveIfSameRequest();\n                    }\n                };\n\n                constructors[DELETE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapDeleteRequest();\n                    }\n                };\n\n                constructors[FLUSH] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapFlushRequest();\n                    }\n                };\n\n                constructors[GET_ALL] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapGetAllRequest();\n                    }\n                };\n\n                constructors[TRY_REMOVE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapTryRemoveRequest();\n                    }\n                };\n\n                constructors[REPLACE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapReplaceRequest();\n                    }\n                };\n\n                constructors[REPLACE_IF_SAME] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapReplaceIfSameRequest();\n                    }\n                };\n\n                constructors[LOCK] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapLockRequest();\n                    }\n                };\n\n                constructors[IS_LOCKED] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapIsLockedRequest();\n                    }\n                };\n\n                constructors[UNLOCK] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapUnlockRequest();\n                    }\n                };\n\n                constructors[EVICT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapEvictRequest();\n                    }\n                };\n\n                constructors[ADD_INTERCEPTOR] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapAddInterceptorRequest();\n                    }\n                };\n\n                constructors[REMOVE_INTERCEPTOR] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapRemoveRequest();\n                    }\n                };\n\n                constructors[ADD_ENTRY_LISTENER] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapAddEntryListenerRequest();\n                    }\n                };\n\n                constructors[GET_ENTRY_VIEW] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapGetEntryViewRequest();\n                    }\n                };\n\n                constructors[ADD_INDEX] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapAddIndexRequest();\n                    }\n                };\n\n                constructors[KEYSET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapKeySetRequest();\n                    }\n                };\n\n                constructors[VALUES] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapValuesRequest();\n                    }\n                };\n\n                constructors[ENTRY_SET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapEntrySetRequest();\n                    }\n                };\n\n                constructors[SIZE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapSizeRequest();\n                    }\n                };\n\n                constructors[QUERY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapQueryRequest();\n                    }\n                };\n\n                constructors[EXECUTE_ON_KEY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapExecuteOnKeyRequest();\n                    }\n                };\n\n                constructors[EXECUTE_ON_ALL_KEYS] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapExecuteOnAllKeysRequest();\n                    }\n                };\n\n                constructors[PUT_ALL] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutAllRequest();\n                    }\n                };\n\n                constructors[DESTROY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapDestroyRequest();\n                    }\n                };\n\n                constructors[PORTABLE_ENTRY_EVENT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new PortableEntryEvent();\n                    }\n                };\n\n\n            }\n\n            public Portable create(int classId) {\n                return (classId > 0 && classId <= constructors.length) ? constructors[classId].createNew(classId) : null;\n            }\n        };\n    }","id":47399,"modified_method":"public PortableFactory createFactory() {\n        return new PortableFactory() {\n            final ConstructorFunction<Integer, Portable> constructors[] = new ConstructorFunction[DESTROY+1];\n\n            {\n                constructors[GET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapGetRequest();\n                    }\n                };\n\n                constructors[PUT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutRequest();\n                    }\n                };\n\n                constructors[PUT_IF_ABSENT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutIfAbsentRequest();\n                    }\n                };\n\n                constructors[TRY_PUT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapTryPutRequest();\n                    }\n                };\n\n                constructors[PUT_TRANSIENT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutTransientRequest();\n                    }\n                };\n\n                constructors[SET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapSetRequest();\n                    }\n                };\n\n                constructors[CONTAINS_KEY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapContainsKeyRequest();\n                    }\n                };\n\n                constructors[CONTAINS_VALUE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapContainsValueRequest();\n                    }\n                };\n\n                constructors[REMOVE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapRemoveRequest();\n                    }\n                };\n\n                constructors[REMOVE_IF_SAME] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapRemoveIfSameRequest();\n                    }\n                };\n\n                constructors[DELETE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapDeleteRequest();\n                    }\n                };\n\n                constructors[FLUSH] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapFlushRequest();\n                    }\n                };\n\n                constructors[GET_ALL] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapGetAllRequest();\n                    }\n                };\n\n                constructors[TRY_REMOVE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapTryRemoveRequest();\n                    }\n                };\n\n                constructors[REPLACE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapReplaceRequest();\n                    }\n                };\n\n                constructors[REPLACE_IF_SAME] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapReplaceIfSameRequest();\n                    }\n                };\n\n                constructors[LOCK] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapLockRequest();\n                    }\n                };\n\n                constructors[IS_LOCKED] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapIsLockedRequest();\n                    }\n                };\n\n                constructors[UNLOCK] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapUnlockRequest();\n                    }\n                };\n\n                constructors[EVICT] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapEvictRequest();\n                    }\n                };\n\n                constructors[ADD_INTERCEPTOR] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapAddInterceptorRequest();\n                    }\n                };\n\n                constructors[REMOVE_INTERCEPTOR] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapRemoveRequest();\n                    }\n                };\n\n                constructors[ADD_ENTRY_LISTENER] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapAddEntryListenerRequest();\n                    }\n                };\n\n                constructors[GET_ENTRY_VIEW] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapGetEntryViewRequest();\n                    }\n                };\n\n                constructors[ADD_INDEX] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapAddIndexRequest();\n                    }\n                };\n\n                constructors[KEYSET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapKeySetRequest();\n                    }\n                };\n\n                constructors[VALUES] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapValuesRequest();\n                    }\n                };\n\n                constructors[ENTRY_SET] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapEntrySetRequest();\n                    }\n                };\n\n                constructors[SIZE] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapSizeRequest();\n                    }\n                };\n\n                constructors[QUERY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapQueryRequest();\n                    }\n                };\n\n                constructors[EXECUTE_ON_KEY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapExecuteOnKeyRequest();\n                    }\n                };\n\n                constructors[EXECUTE_ON_ALL_KEYS] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapExecuteOnAllKeysRequest();\n                    }\n                };\n\n                constructors[PUT_ALL] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapPutAllRequest();\n                    }\n                };\n\n                constructors[DESTROY] = new ConstructorFunction<Integer, Portable>() {\n                    public Portable createNew(Integer arg) {\n                        return new MapDestroyRequest();\n                    }\n                };\n\n\n            }\n\n            public Portable create(int classId) {\n                return (classId > 0 && classId <= constructors.length) ? constructors[classId].createNew(classId) : null;\n            }\n        };\n    }","commit_id":"747ff8073a611a8e0af1b5065695cbc89b3d00cb","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Writes Ignite configuration.\n     *\n     * @param w Writer.\n     * @param cfg Configuration.\n     */\n    public static void writeIgniteConfiguration(BinaryRawWriter w, IgniteConfiguration cfg) {\n        assert w != null;\n        assert cfg != null;\n\n        w.writeBoolean(cfg.isClientMode());\n        w.writeIntArray(cfg.getIncludeEventTypes());\n        w.writeLong(cfg.getMetricsExpireTime());\n        w.writeInt(cfg.getMetricsHistorySize());\n        w.writeLong(cfg.getMetricsLogFrequency());\n        w.writeLong(cfg.getMetricsUpdateFrequency());\n        w.writeInt(cfg.getNetworkSendRetryCount());\n        w.writeLong(cfg.getNetworkSendRetryDelay());\n        w.writeLong(cfg.getNetworkTimeout());\n        w.writeString(cfg.getWorkDirectory());\n        w.writeString(cfg.getLocalHost());\n        w.writeBoolean(cfg.isDaemon());\n        w.writeBoolean(cfg.isLateAffinityAssignment());\n\n        CacheConfiguration[] cacheCfg = cfg.getCacheConfiguration();\n\n        if (cacheCfg != null) {\n            w.writeInt(cacheCfg.length);\n\n            for (CacheConfiguration ccfg : cacheCfg)\n                writeCacheConfiguration(w, ccfg);\n        }\n        else\n            w.writeInt(0);\n\n        writeDiscoveryConfiguration(w, cfg.getDiscoverySpi());\n\n        CommunicationSpi comm = cfg.getCommunicationSpi();\n\n        if (comm instanceof TcpCommunicationSpi) {\n            w.writeBoolean(true);\n            TcpCommunicationSpiMBean tcp = (TcpCommunicationSpiMBean) comm;\n\n            w.writeInt(tcp.getAckSendThreshold());\n            w.writeLong(tcp.getConnectTimeout());\n            w.writeBoolean(tcp.isDirectBuffer());\n            w.writeBoolean(tcp.isDirectSendBuffer());\n            w.writeLong(tcp.getIdleConnectionTimeout());\n            w.writeString(tcp.getLocalAddress());\n            w.writeInt(tcp.getLocalPort());\n            w.writeInt(tcp.getLocalPortRange());\n            w.writeLong(tcp.getMaxConnectTimeout());\n            w.writeInt(tcp.getMessageQueueLimit());\n            w.writeInt(tcp.getReconnectCount());\n            w.writeInt(tcp.getSelectorsCount());\n            w.writeInt(tcp.getSlowClientQueueLimit());\n            w.writeInt(tcp.getSocketReceiveBuffer());\n            w.writeInt(tcp.getSocketSendBuffer());\n            w.writeBoolean(tcp.isTcpNoDelay());\n            w.writeInt(tcp.getUnacknowledgedMessagesBufferSize());\n        }\n        else\n            w.writeBoolean(false);\n\n        BinaryConfiguration bc = cfg.getBinaryConfiguration();\n        w.writeBoolean(bc != null);\n\n        if (bc != null)\n            w.writeBoolean(bc.isCompactFooter());\n\n        Map<String, ?> attrs = cfg.getUserAttributes();\n\n        if (attrs != null) {\n            w.writeInt(attrs.size());\n\n            for (Map.Entry<String, ?> e : attrs.entrySet()) {\n                w.writeString(e.getKey());\n                w.writeObject(e.getValue());\n            }\n        }\n        else\n            w.writeInt(0);\n\n        AtomicConfiguration atomic = cfg.getAtomicConfiguration();\n\n        if (atomic != null) {\n            w.writeBoolean(true);\n\n            w.writeInt(atomic.getAtomicSequenceReserveSize());\n            w.writeInt(atomic.getBackups());\n            w.writeInt(atomic.getCacheMode().ordinal());\n        }\n        else\n            w.writeBoolean(false);\n\n        TransactionConfiguration tx = cfg.getTransactionConfiguration();\n\n        if (tx != null) {\n            w.writeBoolean(true);\n\n            w.writeInt(tx.getPessimisticTxLogSize());\n            w.writeInt(tx.getDefaultTxConcurrency().ordinal());\n            w.writeInt(tx.getDefaultTxIsolation().ordinal());\n            w.writeLong(tx.getDefaultTxTimeout());\n            w.writeInt(tx.getPessimisticTxLogLinger());\n        }\n        else\n            w.writeBoolean(false);\n\n        w.writeString(cfg.getIgniteHome());\n\n        w.writeLong(ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getInit());\n        w.writeLong(ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax());\n    }","id":47400,"modified_method":"/**\n     * Writes Ignite configuration.\n     *\n     * @param w Writer.\n     * @param cfg Configuration.\n     */\n    public static void writeIgniteConfiguration(BinaryRawWriter w, IgniteConfiguration cfg) {\n        assert w != null;\n        assert cfg != null;\n\n        w.writeBoolean(true); w.writeBoolean(cfg.isClientMode());\n        w.writeIntArray(cfg.getIncludeEventTypes());\n        w.writeBoolean(true); w.writeLong(cfg.getMetricsExpireTime());\n        w.writeBoolean(true); w.writeInt(cfg.getMetricsHistorySize());\n        w.writeBoolean(true); w.writeLong(cfg.getMetricsLogFrequency());\n        w.writeBoolean(true); w.writeLong(cfg.getMetricsUpdateFrequency());\n        w.writeBoolean(true); w.writeInt(cfg.getNetworkSendRetryCount());\n        w.writeBoolean(true); w.writeLong(cfg.getNetworkSendRetryDelay());\n        w.writeBoolean(true); w.writeLong(cfg.getNetworkTimeout());\n        w.writeString(cfg.getWorkDirectory());\n        w.writeString(cfg.getLocalHost());\n        w.writeBoolean(true); w.writeBoolean(cfg.isDaemon());\n        w.writeBoolean(true); w.writeBoolean(cfg.isLateAffinityAssignment());\n\n        CacheConfiguration[] cacheCfg = cfg.getCacheConfiguration();\n\n        if (cacheCfg != null) {\n            w.writeInt(cacheCfg.length);\n\n            for (CacheConfiguration ccfg : cacheCfg)\n                writeCacheConfiguration(w, ccfg);\n        }\n        else\n            w.writeInt(0);\n\n        writeDiscoveryConfiguration(w, cfg.getDiscoverySpi());\n\n        CommunicationSpi comm = cfg.getCommunicationSpi();\n\n        if (comm instanceof TcpCommunicationSpi) {\n            w.writeBoolean(true);\n            TcpCommunicationSpiMBean tcp = (TcpCommunicationSpiMBean) comm;\n\n            w.writeInt(tcp.getAckSendThreshold());\n            w.writeLong(tcp.getConnectTimeout());\n            w.writeBoolean(tcp.isDirectBuffer());\n            w.writeBoolean(tcp.isDirectSendBuffer());\n            w.writeLong(tcp.getIdleConnectionTimeout());\n            w.writeString(tcp.getLocalAddress());\n            w.writeInt(tcp.getLocalPort());\n            w.writeInt(tcp.getLocalPortRange());\n            w.writeLong(tcp.getMaxConnectTimeout());\n            w.writeInt(tcp.getMessageQueueLimit());\n            w.writeInt(tcp.getReconnectCount());\n            w.writeInt(tcp.getSelectorsCount());\n            w.writeInt(tcp.getSlowClientQueueLimit());\n            w.writeInt(tcp.getSocketReceiveBuffer());\n            w.writeInt(tcp.getSocketSendBuffer());\n            w.writeBoolean(tcp.isTcpNoDelay());\n            w.writeInt(tcp.getUnacknowledgedMessagesBufferSize());\n        }\n        else\n            w.writeBoolean(false);\n\n        BinaryConfiguration bc = cfg.getBinaryConfiguration();\n        w.writeBoolean(bc != null);\n\n        if (bc != null)\n            w.writeBoolean(bc.isCompactFooter());\n\n        Map<String, ?> attrs = cfg.getUserAttributes();\n\n        if (attrs != null) {\n            w.writeInt(attrs.size());\n\n            for (Map.Entry<String, ?> e : attrs.entrySet()) {\n                w.writeString(e.getKey());\n                w.writeObject(e.getValue());\n            }\n        }\n        else\n            w.writeInt(0);\n\n        AtomicConfiguration atomic = cfg.getAtomicConfiguration();\n\n        if (atomic != null) {\n            w.writeBoolean(true);\n\n            w.writeInt(atomic.getAtomicSequenceReserveSize());\n            w.writeInt(atomic.getBackups());\n            w.writeInt(atomic.getCacheMode().ordinal());\n        }\n        else\n            w.writeBoolean(false);\n\n        TransactionConfiguration tx = cfg.getTransactionConfiguration();\n\n        if (tx != null) {\n            w.writeBoolean(true);\n\n            w.writeInt(tx.getPessimisticTxLogSize());\n            w.writeInt(tx.getDefaultTxConcurrency().ordinal());\n            w.writeInt(tx.getDefaultTxIsolation().ordinal());\n            w.writeLong(tx.getDefaultTxTimeout());\n            w.writeInt(tx.getPessimisticTxLogLinger());\n        }\n        else\n            w.writeBoolean(false);\n\n        w.writeString(cfg.getIgniteHome());\n\n        w.writeLong(ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getInit());\n        w.writeLong(ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax());\n    }","commit_id":"341f12fb25b16206a82de32a96b900163cf4f043","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Reads Ignite configuration.\n     * @param in Reader.\n     * @param cfg Configuration.\n     */\n    public static void readIgniteConfiguration(BinaryRawReaderEx in, IgniteConfiguration cfg) {\n        if (!in.readBoolean())\n            return;  // there is no config\n\n        cfg.setClientMode(in.readBoolean());\n        cfg.setIncludeEventTypes(in.readIntArray());\n        cfg.setMetricsExpireTime(in.readLong());\n        cfg.setMetricsHistorySize(in.readInt());\n        cfg.setMetricsLogFrequency(in.readLong());\n        cfg.setMetricsUpdateFrequency(in.readLong());\n        cfg.setNetworkSendRetryCount(in.readInt());\n        cfg.setNetworkSendRetryDelay(in.readLong());\n        cfg.setNetworkTimeout(in.readLong());\n        cfg.setWorkDirectory(in.readString());\n        cfg.setLocalHost(in.readString());\n        cfg.setDaemon(in.readBoolean());\n        cfg.setLateAffinityAssignment(in.readBoolean());\n\n        readCacheConfigurations(in, cfg);\n        readDiscoveryConfiguration(in, cfg);\n\n        if (in.readBoolean()) {\n            TcpCommunicationSpi comm = new TcpCommunicationSpi();\n\n            comm.setAckSendThreshold(in.readInt());\n            comm.setConnectTimeout(in.readLong());\n            comm.setDirectBuffer(in.readBoolean());\n            comm.setDirectSendBuffer(in.readBoolean());\n            comm.setIdleConnectionTimeout(in.readLong());\n            comm.setLocalAddress(in.readString());\n            comm.setLocalPort(in.readInt());\n            comm.setLocalPortRange(in.readInt());\n            comm.setMaxConnectTimeout(in.readLong());\n            comm.setMessageQueueLimit(in.readInt());\n            comm.setReconnectCount(in.readInt());\n            comm.setSelectorsCount(in.readInt());\n            comm.setSlowClientQueueLimit(in.readInt());\n            comm.setSocketReceiveBuffer(in.readInt());\n            comm.setSocketSendBuffer(in.readInt());\n            comm.setTcpNoDelay(in.readBoolean());\n            comm.setUnacknowledgedMessagesBufferSize(in.readInt());\n\n            cfg.setCommunicationSpi(comm);\n        }\n\n        if (in.readBoolean()) {\n            if (cfg.getBinaryConfiguration() == null)\n                cfg.setBinaryConfiguration(new BinaryConfiguration());\n\n            cfg.getBinaryConfiguration().setCompactFooter(in.readBoolean());\n        }\n\n        int attrCnt = in.readInt();\n\n        if (attrCnt > 0) {\n            Map<String, Object> attrs = new HashMap<>(attrCnt);\n\n            for (int i = 0; i < attrCnt; i++)\n                attrs.put(in.readString(), in.readObject());\n\n            cfg.setUserAttributes(attrs);\n        }\n\n        if (in.readBoolean()) {\n            AtomicConfiguration atomic = new AtomicConfiguration();\n\n            atomic.setAtomicSequenceReserveSize(in.readInt());\n            atomic.setBackups(in.readInt());\n            atomic.setCacheMode(CacheMode.fromOrdinal(in.readInt()));\n\n            cfg.setAtomicConfiguration(atomic);\n        }\n\n        if (in.readBoolean()) {\n            TransactionConfiguration tx = new TransactionConfiguration();\n\n            tx.setPessimisticTxLogSize(in.readInt());\n            tx.setDefaultTxConcurrency(TransactionConcurrency.fromOrdinal(in.readInt()));\n            tx.setDefaultTxIsolation(TransactionIsolation.fromOrdinal(in.readInt()));\n            tx.setDefaultTxTimeout(in.readLong());\n            tx.setPessimisticTxLogLinger(in.readInt());\n\n            cfg.setTransactionConfiguration(tx);\n        }\n    }","id":47401,"modified_method":"/**\n     * Reads Ignite configuration.\n     * @param in Reader.\n     * @param cfg Configuration.\n     */\n    public static void readIgniteConfiguration(BinaryRawReaderEx in, IgniteConfiguration cfg) {\n        if (in.readBoolean()) cfg.setClientMode(in.readBoolean());\n        int[] eventTypes = in.readIntArray(); if (eventTypes != null) cfg.setIncludeEventTypes(eventTypes);\n        if (in.readBoolean()) cfg.setMetricsExpireTime(in.readLong());\n        if (in.readBoolean()) cfg.setMetricsHistorySize(in.readInt());\n        if (in.readBoolean()) cfg.setMetricsLogFrequency(in.readLong());\n        if (in.readBoolean()) cfg.setMetricsUpdateFrequency(in.readLong());\n        if (in.readBoolean()) cfg.setNetworkSendRetryCount(in.readInt());\n        if (in.readBoolean()) cfg.setNetworkSendRetryDelay(in.readLong());\n        if (in.readBoolean()) cfg.setNetworkTimeout(in.readLong());\n        String workDir = in.readString(); if (workDir != null) cfg.setWorkDirectory(workDir);\n        String localHost = in.readString(); if (localHost != null) cfg.setLocalHost(localHost);\n        if (in.readBoolean()) cfg.setDaemon(in.readBoolean());\n        if (in.readBoolean()) cfg.setLateAffinityAssignment(in.readBoolean());\n\n        readCacheConfigurations(in, cfg);\n        readDiscoveryConfiguration(in, cfg);\n\n        if (in.readBoolean()) {\n            TcpCommunicationSpi comm = new TcpCommunicationSpi();\n\n            comm.setAckSendThreshold(in.readInt());\n            comm.setConnectTimeout(in.readLong());\n            comm.setDirectBuffer(in.readBoolean());\n            comm.setDirectSendBuffer(in.readBoolean());\n            comm.setIdleConnectionTimeout(in.readLong());\n            comm.setLocalAddress(in.readString());\n            comm.setLocalPort(in.readInt());\n            comm.setLocalPortRange(in.readInt());\n            comm.setMaxConnectTimeout(in.readLong());\n            comm.setMessageQueueLimit(in.readInt());\n            comm.setReconnectCount(in.readInt());\n            comm.setSelectorsCount(in.readInt());\n            comm.setSlowClientQueueLimit(in.readInt());\n            comm.setSocketReceiveBuffer(in.readInt());\n            comm.setSocketSendBuffer(in.readInt());\n            comm.setTcpNoDelay(in.readBoolean());\n            comm.setUnacknowledgedMessagesBufferSize(in.readInt());\n\n            cfg.setCommunicationSpi(comm);\n        }\n\n        if (in.readBoolean()) {\n            if (cfg.getBinaryConfiguration() == null)\n                cfg.setBinaryConfiguration(new BinaryConfiguration());\n\n            cfg.getBinaryConfiguration().setCompactFooter(in.readBoolean());\n        }\n\n        int attrCnt = in.readInt();\n\n        if (attrCnt > 0) {\n            Map<String, Object> attrs = new HashMap<>(attrCnt);\n\n            for (int i = 0; i < attrCnt; i++)\n                attrs.put(in.readString(), in.readObject());\n\n            cfg.setUserAttributes(attrs);\n        }\n\n        if (in.readBoolean()) {\n            AtomicConfiguration atomic = new AtomicConfiguration();\n\n            atomic.setAtomicSequenceReserveSize(in.readInt());\n            atomic.setBackups(in.readInt());\n            atomic.setCacheMode(CacheMode.fromOrdinal(in.readInt()));\n\n            cfg.setAtomicConfiguration(atomic);\n        }\n\n        if (in.readBoolean()) {\n            TransactionConfiguration tx = new TransactionConfiguration();\n\n            tx.setPessimisticTxLogSize(in.readInt());\n            tx.setDefaultTxConcurrency(TransactionConcurrency.fromOrdinal(in.readInt()));\n            tx.setDefaultTxIsolation(TransactionIsolation.fromOrdinal(in.readInt()));\n            tx.setDefaultTxTimeout(in.readLong());\n            tx.setPessimisticTxLogLinger(in.readInt());\n\n            cfg.setTransactionConfiguration(tx);\n        }\n    }","commit_id":"341f12fb25b16206a82de32a96b900163cf4f043","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Exports an object for remoting to the other {@link Channel}.\n     *\n     * @param type\n     *      Interface to be remoted.\n     * @return\n     *      the proxy object that implements <tt>T<\/tt>. This object can be transfered\n     *      to the other {@link Channel}, and calling methods on it will invoke the\n     *      same method on the given <tt>instance<\/tt> object.\n     */\n    /*package*/ synchronized <T> T export(Class<T> type, T instance) {\n        if(instance==null)\n            return null;\n        // TODO: unexport\n\n        final int id = exportedObjects.intern(instance);\n        return type.cast(Proxy.newProxyInstance( type.getClassLoader(), new Class[]{type},\n            new RemoteInvocationHandler(id)));\n    }","id":47402,"modified_method":"/**\n     * Exports an object for remoting to the other {@link Channel}.\n     *\n     * @param type\n     *      Interface to be remoted.\n     * @return\n     *      the proxy object that implements <tt>T<\/tt>. This object can be transfered\n     *      to the other {@link Channel}, and calling methods on it will invoke the\n     *      same method on the given <tt>instance<\/tt> object.\n     */\n    /*package*/ synchronized <T> T export(Class<T> type, T instance) {\n        if(instance==null)\n            return null;\n        // TODO: unexport\n\n        final int id = export(instance);\n        return type.cast(Proxy.newProxyInstance( type.getClassLoader(), new Class[]{type},\n            new RemoteInvocationHandler(id)));\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Makes a remote procedure call.\n     */\n    public <V extends Serializable,T extends Throwable>\n    V call(Callable<V,T> callable) throws IOException, T, InterruptedException {\n        UserResponse<V> r = new UserRequest<V,T>(this, callable).call(this);\n        try {\n            return r.retrieve(this, callable.getClass().getClassLoader());\n        } catch (ClassNotFoundException e) {\n            // this is unlikely to happen, so this is a lame implementation\n            IOException x = new IOException();\n            x.initCause(e);\n            throw x;\n        }\n    }","id":47403,"modified_method":"/**\n     * Makes a remote procedure call.\n     *\n     * <p>\n     * Sends {@link Callable} to the remote system, executes it, and returns its result.\n     *\n     * @throws InterruptedException\n     *      If the current thread is interrupted while waiting for the completion.\n     * @throws IOException\n     *      If there's any error in the communication between {@link Channel}s.\n     */\n    public <V extends Serializable,T extends Throwable>\n    V call(Callable<V,T> callable) throws IOException, T, InterruptedException {\n        UserResponse<V> r = new UserRequest<V,T>(this, callable).call(this);\n        try {\n            return r.retrieve(this, callable.getClass().getClassLoader());\n        } catch (ClassNotFoundException e) {\n            // this is unlikely to happen, so this is a lame implementation\n            IOException x = new IOException();\n            x.initCause(e);\n            throw x;\n        }\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Waits for the close down of this {@link Channel}.\n     */\n    public synchronized void join() throws InterruptedException {\n        while(!closed)\n            wait();\n    }","id":47404,"modified_method":"/**\n     * Waits for this {@link Channel} to be closed down.\n     *\n     * The close-down of a {@link Channel} might be initiated locally or remotely.\n     */\n    public synchronized void join() throws InterruptedException {\n        while(!closed)\n            wait();\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Makes an asynchronous remote procedure call.\n     */\n    public <V extends Serializable,T extends Throwable>\n    Future<V> callAsync(final Callable<V,T> callable) throws IOException, T, InterruptedException {\n        final Future<UserResponse<V>> f = new UserRequest<V, T>(this, callable).callAsync(this);\n        return new FutureAdapter<V,UserResponse<V>>(f) {\n            protected V adapt(UserResponse<V> r) throws ExecutionException {\n                try {\n                    return r.retrieve(Channel.this,callable.getClass().getClassLoader());\n                } catch (IOException e) {\n                    throw new ExecutionException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new ExecutionException(e);\n                }\n            }\n        };\n    }","id":47405,"modified_method":"/**\n     * Makes an asynchronous remote procedure call.\n     *\n     * <p>\n     * Similar to {@link #call(Callable)} but returns immediately.\n     * The result of the {@link Callable} can be obtained through the {@link Future} object.\n     */\n    public <V extends Serializable,T extends Throwable>\n    Future<V> callAsync(final Callable<V,T> callable) throws IOException, T, InterruptedException {\n        final Future<UserResponse<V>> f = new UserRequest<V, T>(this, callable).callAsync(this);\n        return new FutureAdapter<V,UserResponse<V>>(f) {\n            protected V adapt(UserResponse<V> r) throws ExecutionException {\n                try {\n                    return r.retrieve(Channel.this,callable.getClass().getClassLoader());\n                } catch (IOException e) {\n                    throw new ExecutionException(e);\n                } catch (ClassNotFoundException e) {\n                    throw new ExecutionException(e);\n                }\n            }\n        };\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"public OutputStream getOut() {\n        return out;\n    }","id":47406,"modified_method":"/**\n     * Gets the writing end of the pipe.\n     */\n    public OutputStream getOut() {\n        return out;\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        final Channel channel = Channel.current();\n        assert channel !=null;\n\n        if(ois.readBoolean()) {\n            // local will write to remote\n            final int oid = ois.readInt();\n\n            in = null;\n            out = new BufferedOutputStream(new OutputStream() {\n                public void write(int b) throws IOException {\n                    write(new byte[]{(byte)b},0,1);\n                }\n\n                public void write(byte b[], int off, int len) throws IOException {\n                    if(off==0 && len==b.length)\n                        write(b);\n                    else {\n                        byte[] buf = new byte[len];\n                        System.arraycopy(b,off,buf,0,len);\n                        write(buf);\n                    }\n                }\n\n                public void write(byte b[]) throws IOException {\n                    channel.send(new Chunk(oid,b));\n                }\n\n                public void close() throws IOException {\n                    channel.send(new EOF(oid));\n                }\n            });\n        } else {\n            // TODO\n            throw new UnsupportedOperationException();\n        }\n    }","id":47407,"modified_method":"private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        final Channel channel = Channel.current();\n        assert channel !=null;\n\n        if(ois.readBoolean()) {\n            // local will write to remote\n            in = null;\n            out = new BufferedOutputStream(new RemoteOutputStream(channel, ois.readInt()));\n        } else {\n            // local will read from remote.\n            // tell the remote system about this local read pipe\n\n            // this is the OutputStream that wants to send data to us\n            final int oidRos = ois.readInt();\n\n            // we want 'oidRos' to send data to this PipedOutputStream\n            PipedOutputStream pos = new PipedOutputStream();\n            final int oidPos = channel.export(pos);\n\n            // tell 'ros' to connect to our 'pos'.\n            channel.send(new ConnectCommand(oidRos, oidPos));\n\n            out = null;\n            in = new PipedInputStream(pos);\n        }\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void writeObject(ObjectOutputStream oos) throws IOException {\n        if(in!=null && out==null) {\n            // remote will write to local\n            PipedOutputStream pos = new PipedOutputStream((PipedInputStream)in);\n            int oid = Channel.current().exportedObjects.intern(pos);\n\n            oos.writeBoolean(true); // marker\n            oos.writeInt(oid);\n        } else {\n            // TODO: remote will read from local\n            throw new UnsupportedOperationException();\n        }\n    }","id":47408,"modified_method":"private void writeObject(ObjectOutputStream oos) throws IOException {\n        if(in!=null && out==null) {\n            // remote will write to local\n            PipedOutputStream pos = new PipedOutputStream((PipedInputStream)in);\n            int oid = Channel.current().export(pos);\n\n            oos.writeBoolean(true); // marker\n            oos.writeInt(oid);\n        } else {\n            // remote will read from local\n            int oid = Channel.current().export(out);\n\n            oos.writeBoolean(false);\n            oos.writeInt(oid);\n        }\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"public InputStream getIn() {\n        return in;\n    }","id":47409,"modified_method":"/**\n     * Gets the reading end of the pipe.\n     */\n    public InputStream getIn() {\n        return in;\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Test the \"remote-write local-read\" pipe.\n     */\n    public void testRemoteWrite() throws Exception {\n        Pipe p = Pipe.create();\n        Future<Integer> f = channel.callAsync(new WritingCallable(p));\n\n        InputStream in = p.getIn();\n        for( int cnt=0; cnt<256*256; cnt++ )\n            assertEquals(cnt/256,in.read());\n        assertEquals(-1,in.read());\n        in.close();\n\n        int r = f.get();\n        System.out.println(\"result=\" + r);\n        assertEquals(5,r);\n    }","id":47410,"modified_method":"/**\n     * Test the \"remote-write local-read\" pipe.\n     */\n    public void testRemoteWrite() throws Exception {\n        Pipe p = Pipe.createRemoteToLocal();\n        Future<Integer> f = channel.callAsync(new WritingCallable(p));\n\n        read(p);\n\n        int r = f.get();\n        System.out.println(\"result=\" + r);\n        assertEquals(5,r);\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"public Integer call() throws IOException {\n            OutputStream os = pipe.getOut();\n            byte[] buf = new byte[384];\n            for( int i=0; i<256; i++ ) {\n                Arrays.fill(buf,(byte)i);\n                os.write(buf,0,256);\n            }\n            os.close();\n            return 5;\n        }","id":47411,"modified_method":"public Integer call() throws IOException {\n            write(pipe);\n            return 5;\n        }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Two proxies are the same iff they represent the same remote object. \n     */\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        RemoteInvocationHandler that = (RemoteInvocationHandler) o;\n\n        if (oid != that.oid) return false;\n        if (channel!=that.channel) return false;\n\n        return true;\n    }","id":47412,"modified_method":"/**\n     * Two proxies are the same iff they represent the same remote object. \n     */\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        RemoteInvocationHandler that = (RemoteInvocationHandler) o;\n\n        return this.oid==that.oid && this.channel==that.channel;\n\n    }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected Serializable perform(Channel channel) throws Throwable {\n            Object o = channel.exportedObjects.get(oid);\n            if(o==null)\n                throw new IllegalStateException(\"Unable to call \"+methodName+\". Invalid object ID \"+oid);\n            try {\n                return (Serializable)choose(o).invoke(o,arguments);\n            } catch (InvocationTargetException e) {\n                throw e.getTargetException();\n            }\n        }","id":47413,"modified_method":"protected Serializable perform(Channel channel) throws Throwable {\n            Object o = channel.getExportedObject(oid);\n            if(o==null)\n                throw new IllegalStateException(\"Unable to call \"+methodName+\". Invalid object ID \"+oid);\n            try {\n                return (Serializable)choose(o).invoke(o,arguments);\n            } catch (InvocationTargetException e) {\n                throw e.getTargetException();\n            }\n        }","commit_id":"9222fdbcc13806916d0686db04d0c8260e519e05","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        if (in.getVersion().before(Version.V_1_4_0_Beta1)) {\n            //the index was previously serialized although not needed\n            in.readString();\n        }\n        scriptLang = in.readString();\n        id = in.readString();\n        preference = in.readOptionalString();\n        refresh = in.readBoolean();\n        byte realtime = in.readByte();\n        if (realtime == 0) {\n            this.realtime = false;\n        } else if (realtime == 1) {\n            this.realtime = true;\n        }\n\n        this.versionType = VersionType.fromValue(in.readByte());\n        this.version = Versions.readVersionWithVLongForBW(in);\n\n        fetchSourceContext = FetchSourceContext.optionalReadFromStream(in);\n    }","id":47414,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        if (in.getVersion().before(Version.V_1_4_0_Beta1)) {\n            //the index was previously serialized although not needed\n            in.readString();\n        }\n        scriptLang = in.readString();\n        id = in.readString();\n        if (in.getVersion().before(Version.V_1_5_0)) {\n            in.readOptionalString(); //Preference\n            in.readBoolean(); //Refresh\n            in.readByte(); //Realtime\n        }\n        this.versionType = VersionType.fromValue(in.readByte());\n        this.version = Versions.readVersionWithVLongForBW(in);\n\n        if (in.getVersion().before(Version.V_1_5_0)) {\n            FetchSourceContext.optionalReadFromStream(in);\n        }\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public String toString() {\n        return \"[\" + ScriptService.SCRIPT_INDEX + \"][\" + scriptLang + \"][\" + id + \"]: routing [\" + routing + \"]\";\n    }","id":47415,"modified_method":"@Override\n    public String toString() {\n        return \"[\" + ScriptService.SCRIPT_INDEX + \"][\" + scriptLang + \"][\" + id + \"]\";\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        if (out.getVersion().before(Version.V_1_4_0_Beta1)) {\n            //the index was previously serialized although not needed\n            out.writeString(ScriptService.SCRIPT_INDEX);\n        }\n        out.writeString(scriptLang);\n        out.writeString(id);\n        out.writeOptionalString(preference);\n        out.writeBoolean(refresh);\n        if (realtime == null) {\n            out.writeByte((byte) -1);\n        } else if (!realtime) {\n            out.writeByte((byte) 0);\n        } else {\n            out.writeByte((byte) 1);\n        }\n\n        out.writeByte(versionType.getValue());\n        Versions.writeVersionWithVLongForBW(version, out);\n\n        FetchSourceContext.optionalWriteToStream(fetchSourceContext, out);\n    }","id":47416,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        if (out.getVersion().before(Version.V_1_4_0_Beta1)) {\n            //the index was previously serialized although not needed\n            out.writeString(ScriptService.SCRIPT_INDEX);\n        }\n        out.writeString(scriptLang);\n        out.writeString(id);\n        if (out.getVersion().before(Version.V_1_5_0)) {\n            out.writeOptionalString(\"_local\"); //Preference\n            out.writeBoolean(true); //Refresh\n            out.writeByte((byte) -1); //Realtime\n        }\n\n        out.writeByte(versionType.getValue());\n        Versions.writeVersionWithVLongForBW(version, out);\n\n        if (out.getVersion().before(Version.V_1_5_0)) {\n            FetchSourceContext.optionalWriteToStream(null, out);\n        }\n\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testGetIndexedScriptRequestSerialization() throws IOException {\n        GetIndexedScriptRequest request = new GetIndexedScriptRequest(\"lang\", \"id\");\n        if (randomBoolean()) {\n            request.realtime(false);\n        }\n        if (randomBoolean()) {\n            request.refresh(true);\n        }\n        if (randomBoolean()) {\n            request.version(randomIntBetween(1, Integer.MAX_VALUE));\n            request.versionType(randomFrom(VersionType.values()));\n        }\n        if (randomBoolean()) {\n            request.routing(randomAsciiOfLength(randomIntBetween(1, 10)));\n        }\n\n        BytesStreamOutput out = new BytesStreamOutput();\n        out.setVersion(randomVersion());\n        request.writeTo(out);\n\n        BytesStreamInput in = new BytesStreamInput(out.bytes());\n        in.setVersion(out.getVersion());\n        GetIndexedScriptRequest request2 = new GetIndexedScriptRequest();\n        request2.readFrom(in);\n\n        assertThat(request2.id(), equalTo(request.id()));\n        assertThat(request2.scriptLang(), equalTo(request.scriptLang()));\n        assertThat(request2.realtime(), equalTo(request.realtime()));\n        assertThat(request2.refresh(), equalTo(request.refresh()));\n        assertThat(request2.version(), equalTo(request.version()));\n        assertThat(request2.versionType(), equalTo(request.versionType()));\n    }","id":47417,"modified_method":"@Test\n    public void testGetIndexedScriptRequestSerialization() throws IOException {\n        GetIndexedScriptRequest request = new GetIndexedScriptRequest(\"lang\", \"id\");\n        if (randomBoolean()) {\n            request.version(randomIntBetween(1, Integer.MAX_VALUE));\n            request.versionType(randomFrom(VersionType.values()));\n        }\n\n        BytesStreamOutput out = new BytesStreamOutput();\n        out.setVersion(randomVersion());\n        request.writeTo(out);\n\n        BytesStreamInput in = new BytesStreamInput(out.bytes());\n        in.setVersion(out.getVersion());\n        GetIndexedScriptRequest request2 = new GetIndexedScriptRequest();\n        request2.readFrom(in);\n\n        assertThat(request2.id(), equalTo(request.id()));\n        assertThat(request2.scriptLang(), equalTo(request.scriptLang()));\n        assertThat(request2.version(), equalTo(request.version()));\n        assertThat(request2.versionType(), equalTo(request.versionType()));\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected String getScriptFieldName() {\n        return \"script\";\n    }","id":47418,"modified_method":"protected String getScriptFieldName() {\n        return SCRIPT_FIELD;\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel, Client client) {\n        final GetIndexedScriptRequest getRequest = new GetIndexedScriptRequest(getScriptLang(request), request.param(\"id\"));\n        getRequest.version(request.paramAsLong(\"version\", getRequest.version()));\n        getRequest.versionType(VersionType.fromString(request.param(\"version_type\"), getRequest.versionType()));\n        client.getIndexedScript(getRequest, new RestResponseListener<GetIndexedScriptResponse>(channel) {\n            @Override\n            public RestResponse buildResponse(GetIndexedScriptResponse response) throws Exception {\n                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n                if (!response.isExists()) {\n                    return new BytesRestResponse(NOT_FOUND, builder);\n                } else {\n                    try{\n                        String script = response.getScript();\n                        builder.startObject();\n                        builder.field(getScriptFieldName(), script);\n                        builder.endObject();\n                        return new BytesRestResponse(OK, builder);\n                    } catch( IOException|ClassCastException e ){\n                        throw new ElasticsearchIllegalStateException(\"Unable to parse \"  + response.getScript() + \" as json\",e);\n                    }\n                }\n            }\n        });\n    }","id":47419,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel, Client client) {\n        final GetIndexedScriptRequest getRequest = new GetIndexedScriptRequest(getScriptLang(request), request.param(\"id\"));\n        getRequest.version(request.paramAsLong(\"version\", getRequest.version()));\n        getRequest.versionType(VersionType.fromString(request.param(\"version_type\"), getRequest.versionType()));\n        client.getIndexedScript(getRequest, new RestResponseListener<GetIndexedScriptResponse>(channel) {\n            @Override\n            public RestResponse buildResponse(GetIndexedScriptResponse response) throws Exception {\n                XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n                if (!response.isExists()) {\n                    return new BytesRestResponse(NOT_FOUND, builder);\n                } else {\n                    try{\n                        String script = response.getScript();\n                        builder.startObject();\n                        builder.field(getScriptFieldName(), script);\n                        builder.field(VERSION_FIELD, response.getVersion());\n                        builder.field(LANG_FIELD, response.getScriptLang());\n                        builder.field(ID_FIELD, response.getId());\n                        builder.endObject();\n                        return new BytesRestResponse(OK, builder);\n                    } catch( IOException|ClassCastException e ){\n                        throw new ElasticsearchIllegalStateException(\"Unable to parse \"  + response.getScript() + \" as json\",e);\n                    }\n                }\n            }\n        });\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected String getScriptLang(RestRequest request) {\n        return request.param(\"lang\");\n    }","id":47420,"modified_method":"protected String getScriptLang(RestRequest request) {\n        return request.param(LANG_FIELD);\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void parseTemplate(ShardSearchRequest request) {\n\n        final ExecutableScript executable;\n        if (hasLength(request.templateName())) {\n            executable = this.scriptService.executable(\"mustache\", request.templateName(), request.templateType(), request.templateParams());\n        } else {\n            if (!hasLength(request.templateSource())) {\n                return;\n            }\n            XContentParser parser = null;\n            TemplateQueryParser.TemplateContext templateContext = null;\n\n            try {\n                parser = XContentFactory.xContent(request.templateSource()).createParser(request.templateSource());\n                templateContext = TemplateQueryParser.parse(parser, \"params\", \"template\");\n\n                if (templateContext.scriptType().equals(ScriptService.ScriptType.INLINE)) {\n                    //Try to double parse for nested template id/file\n                    parser = XContentFactory.xContent(templateContext.template().getBytes(Charset.defaultCharset())).createParser(templateContext.template().getBytes(Charset.defaultCharset()));\n                    TemplateQueryParser.TemplateContext innerContext = TemplateQueryParser.parse(parser, \"params\");\n                    if (hasLength(innerContext.template()) && !innerContext.scriptType().equals(ScriptService.ScriptType.INLINE)) {\n                        //An inner template referring to a filename or id\n                        templateContext = new TemplateQueryParser.TemplateContext(innerContext.scriptType(), innerContext.template(), templateContext.params());\n                    }\n                }\n            } catch (IOException e) {\n                throw new ElasticsearchParseException(\"Failed to parse template\", e);\n            } finally {\n                Releasables.closeWhileHandlingException(parser);\n            }\n\n            if (templateContext == null || !hasLength(templateContext.template())) {\n                throw new ElasticsearchParseException(\"Template must have [template] field configured\");\n            }\n            executable = this.scriptService.executable(\"mustache\", templateContext.template(), templateContext.scriptType(), templateContext.params());\n        }\n\n        BytesReference processedQuery = (BytesReference) executable.run();\n        request.source(processedQuery);\n    }","id":47421,"modified_method":"private void parseTemplate(ShardSearchRequest request) {\n\n        final ExecutableScript executable;\n        if (hasLength(request.templateName())) {\n            executable = this.scriptService.executable(\"mustache\", request.templateName(), request.templateType(), request.templateParams());\n        } else {\n            if (!hasLength(request.templateSource())) {\n                return;\n            }\n            XContentParser parser = null;\n            TemplateQueryParser.TemplateContext templateContext = null;\n\n            try {\n                parser = XContentFactory.xContent(request.templateSource()).createParser(request.templateSource());\n                templateContext = TemplateQueryParser.parse(parser, \"params\", \"template\");\n\n                if (templateContext.scriptType().equals(ScriptService.ScriptType.INLINE)) {\n                    //Try to double parse for nested template id/file\n                    parser = null;\n                    try {\n                        byte[] templateBytes = templateContext.template().getBytes(Charsets.UTF_8);\n                        parser = XContentFactory.xContent(templateBytes).createParser(templateBytes);\n                    } catch (ElasticsearchParseException epe) {\n                        //This was an non-nested template, the parse failure was due to this, it is safe to assume this refers to a file\n                        //for backwards compatibility and keep going\n                        templateContext = new TemplateQueryParser.TemplateContext(ScriptService.ScriptType.FILE, templateContext.template(), templateContext.params());\n                    }\n                    if (parser != null) {\n                        TemplateQueryParser.TemplateContext innerContext = TemplateQueryParser.parse(parser, \"params\");\n                        if (hasLength(innerContext.template()) && !innerContext.scriptType().equals(ScriptService.ScriptType.INLINE)) {\n                            //An inner template referring to a filename or id\n                            templateContext = new TemplateQueryParser.TemplateContext(innerContext.scriptType(), innerContext.template(), templateContext.params());\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new ElasticsearchParseException(\"Failed to parse template\", e);\n            } finally {\n                Releasables.closeWhileHandlingException(parser);\n            }\n\n            if (templateContext == null || !hasLength(templateContext.template())) {\n                throw new ElasticsearchParseException(\"Template must have [template] field configured\");\n            }\n            executable = this.scriptService.executable(\"mustache\", templateContext.template(), templateContext.scriptType(), templateContext.params());\n        }\n\n        BytesReference processedQuery = (BytesReference) executable.run();\n        request.source(processedQuery);\n    }","commit_id":"8e742c2096dad1e87e88719902b961e2b7100fa6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void doJoin(AtomicBoolean joined) {\n        int tryCount = 0;\n        long joinStartTime = Clock.currentTimeMillis();\n        long maxJoinMillis = node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;\n        \n        while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n            String msg = \"Joining to master node: \" + node.getMasterAddress();\n            logger.log(Level.FINEST, msg);\n            systemLogService.logJoin(msg);\n            \n            Address masterAddressNow = getTargetAddress();\n            if (masterAddressNow == null) {\n                masterAddressNow = findMasterWithMulticast();\n            }\n            node.setMasterAddress(masterAddressNow);\n            if (masterAddressNow != null) {\n                systemLogService.logJoin(\"Setting master address to \" + masterAddressNow);\n            }\n            if (node.getMasterAddress() == null || node.getThisAddress().equals(node.getMasterAddress())) {\n                TcpIpConfig tcpIpConfig = config.getNetworkConfig().getJoin().getTcpIpConfig();\n                if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {\n                    doTCP(joined);\n                } else {\n                    node.setAsMaster();\n                }\n                return;\n            }\n            if (++tryCount > 49) {\n                failedJoiningToMaster(true, tryCount);\n            }\n            if (!node.getMasterAddress().equals(node.getThisAddress())) {\n                connectAndSendJoinRequest(node.getMasterAddress());\n            } else {\n                node.setMasterAddress(null);\n                tryCount = 0;\n            }\n            try {\n                //noinspection BusyWait\n                Thread.sleep(500L);\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }","id":47422,"modified_method":"public void doJoin(AtomicBoolean joined) {\n        int tryCount = 0;\n        long joinStartTime = Clock.currentTimeMillis();\n        long maxJoinMillis = node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;\n\n        while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n            Address masterAddressNow = getTargetAddress();\n            if (masterAddressNow == null) {\n                masterAddressNow = findMasterWithMulticast();\n            }\n            node.setMasterAddress(masterAddressNow);\n\n            String msg = \"Joining to master node: \" + node.getMasterAddress();\n            logger.log(Level.FINEST, msg);\n            systemLogService.logJoin(msg);\n\n            if (node.getMasterAddress() == null || node.getThisAddress().equals(node.getMasterAddress())) {\n                TcpIpConfig tcpIpConfig = config.getNetworkConfig().getJoin().getTcpIpConfig();\n                if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {\n                    doTCP(joined);\n                } else {\n                    node.setAsMaster();\n                }\n                return;\n            }\n            if (++tryCount > 49) {\n                failedJoiningToMaster(true, tryCount);\n            }\n            if (!node.getMasterAddress().equals(node.getThisAddress())) {\n                connectAndSendJoinRequest(node.getMasterAddress());\n            } else {\n                node.setMasterAddress(null);\n                tryCount = 0;\n            }\n            try {\n                //noinspection BusyWait\n                Thread.sleep(500L);\n            } catch (InterruptedException ignored) {\n            }\n        }\n    }","commit_id":"f6d0263a9b3018822ab1764a664249c6a74de357","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Address findMasterWithMulticast() {\n        try {\n            final String ip = System.getProperty(\"join.ip\");\n            if (ip == null) {\n                JoinRequest joinRequest = node.createJoinRequest();\n                for (; node.isActive() && currentTryCount.incrementAndGet() <= maxTryCount.get(); ) {\n                    joinRequest.setTryCount(currentTryCount.get());\n                    node.multicastService.send(joinRequest);\n                    if (node.getMasterAddress() == null) {\n                        //noinspection BusyWait\n                        Thread.sleep(publishInterval);\n                    } else {\n                        return node.getMasterAddress();\n                    }\n                }\n            } else {\n                logger.log(Level.FINEST, \"RETURNING join.ip\");\n                return new Address(ip, config.getNetworkConfig().getPort());\n            }\n        } catch (final Exception e) {\n            if (logger != null) {\n                logger.log(Level.WARNING, e.getMessage(), e);\n            }\n        } finally {\n            currentTryCount.set(0);\n        }\n        return null;\n    }","id":47423,"modified_method":"private Address findMasterWithMulticast() {\n        try {\n            JoinRequest joinRequest = node.createJoinRequest();\n            while (node.isActive() && currentTryCount.incrementAndGet() <= maxTryCount.get()) {\n                joinRequest.setTryCount(currentTryCount.get());\n                node.multicastService.send(joinRequest);\n                if (node.getMasterAddress() == null) {\n                    //noinspection BusyWait\n                    Thread.sleep(publishInterval);\n                } else {\n                    return node.getMasterAddress();\n                }\n            }\n        } catch (final Exception e) {\n            if (logger != null) {\n                logger.log(Level.WARNING, e.getMessage(), e);\n            }\n        } finally {\n            currentTryCount.set(0);\n        }\n        return null;\n    }","commit_id":"f6d0263a9b3018822ab1764a664249c6a74de357","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MulticastService(Node node, MulticastSocket multicastSocket) throws Exception {\n        this.node = node;\n        logger = node.getLogger(MulticastService.class.getName());\n        Config config = node.getConfig();\n        this.multicastSocket = multicastSocket;\n\n        sendOutput = (BufferObjectDataOutput) node.serializationService.createObjectDataOutput(DATAGRAM_BUFFER_SIZE);\n        receiveOutput = (BufferObjectDataOutput) node.serializationService.createObjectDataOutput(DATAGRAM_BUFFER_SIZE);\n\n        this.datagramPacketReceive = new DatagramPacket(new byte[DATAGRAM_BUFFER_SIZE], DATAGRAM_BUFFER_SIZE);\n        final MulticastConfig multicastConfig = config.getNetworkConfig().getJoin().getMulticastConfig();\n        this.datagramPacketSend = new DatagramPacket(new byte[0], 0, InetAddress\n                .getByName(multicastConfig.getMulticastGroup()), multicastConfig.getMulticastPort());\n        running = true;\n    }","id":47424,"modified_method":"public MulticastService(Node node, MulticastSocket multicastSocket) throws Exception {\n        this.node = node;\n        logger = node.getLogger(MulticastService.class.getName());\n        Config config = node.getConfig();\n        this.multicastSocket = multicastSocket;\n\n        sendOutput = node.serializationService.createObjectDataOutput(DATAGRAM_BUFFER_SIZE);\n        receiveOutput = node.serializationService.createObjectDataOutput(DATAGRAM_BUFFER_SIZE);\n\n        this.datagramPacketReceive = new DatagramPacket(new byte[DATAGRAM_BUFFER_SIZE], DATAGRAM_BUFFER_SIZE);\n        final MulticastConfig multicastConfig = config.getNetworkConfig().getJoin().getMulticastConfig();\n        this.datagramPacketSend = new DatagramPacket(new byte[0], 0, InetAddress\n                .getByName(multicastConfig.getMulticastGroup()), multicastConfig.getMulticastPort());\n        running = true;\n    }","commit_id":"f6d0263a9b3018822ab1764a664249c6a74de357","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void removeMulticastListener(MulticastListener multicastListener) {\n        lsListeners.remove(multicastListener);\n    }","id":47425,"modified_method":"public void removeMulticastListener(MulticastListener multicastListener) {\n        listeners.remove(multicastListener);\n    }","commit_id":"f6d0263a9b3018822ab1764a664249c6a74de357","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@SuppressWarnings(\"WhileLoopSpinsOnField\")\n    public void run() {\n        try {\n            while (running) {\n                try {\n                    final JoinMessage joinMessage = receive();\n                    if (joinMessage != null) {\n                        for (MulticastListener multicastListener : lsListeners) {\n                            try {\n                                multicastListener.onMessage(joinMessage);\n                            } catch (Exception e) {\n                                logger.log(Level.WARNING, e.getMessage(), e);\n                            }\n                        }\n                    }\n                } catch (OutOfMemoryError e) {\n                    OutOfMemoryErrorDispatcher.onOutOfMemory(e);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, e.getMessage(), e);\n                }\n            }\n        } finally {\n            cleanup();\n        }\n    }","id":47426,"modified_method":"@SuppressWarnings(\"WhileLoopSpinsOnField\")\n    public void run() {\n        try {\n            while (running) {\n                try {\n                    final JoinMessage joinMessage = receive();\n                    if (joinMessage != null) {\n                        for (MulticastListener multicastListener : listeners) {\n                            try {\n                                multicastListener.onMessage(joinMessage);\n                            } catch (Exception e) {\n                                logger.log(Level.WARNING, e.getMessage(), e);\n                            }\n                        }\n                    }\n                } catch (OutOfMemoryError e) {\n                    OutOfMemoryErrorDispatcher.onOutOfMemory(e);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, e.getMessage(), e);\n                }\n            }\n        } finally {\n            cleanup();\n        }\n    }","commit_id":"f6d0263a9b3018822ab1764a664249c6a74de357","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void addMulticastListener(MulticastListener multicastListener) {\n        lsListeners.add(multicastListener);\n    }","id":47427,"modified_method":"public void addMulticastListener(MulticastListener multicastListener) {\n        listeners.add(multicastListener);\n    }","commit_id":"f6d0263a9b3018822ab1764a664249c6a74de357","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void doJoin() {\n        synchronized (joinerLock) {\n            Address master;\n\n            final ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            for (int i = 0; !node.joined() && node.isRunning() && i < 2000; i++) {\n                try {\n                    master = node.getMasterAddress();\n                    if (master == null) {\n                        master = findCurrentMasterAddress();\n                        node.setMasterAddress(master);\n                    }\n\n                    Assert.assertNotNull(master);\n                    if (master.equals(node.getThisAddress())) {\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    clusterJoinManager.sendJoinRequest(master, true);\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            if (!node.joined()) {\n                logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                node.shutdown(true);\n            }\n        }\n    }","id":47428,"modified_method":"public void doJoin() {\n        synchronized (joinerLock) {\n\n            ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            long joinStartTime = Clock.currentTimeMillis();\n            long maxJoinMillis = getMaxJoinMillis();\n\n            while (node.isRunning() && !node.joined()\n                    && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n                try {\n                    lookupMasterAddress();\n\n                    if (node.getThisAddress().equals(masterAddress)) {\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    if (masterAddress != null) {\n                        node.setMasterAddress(masterAddress);\n                        clusterJoinManager.sendJoinRequest(masterAddress, true);\n                    }\n\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            if (!node.joined()) {\n                logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                node.shutdown(true);\n            }\n        }\n    }","commit_id":"e33f32b07b5340d309af218a576ef28efa61cf63","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Address findCurrentMasterAddress() {\n        NodeEngineImpl nodeEngine = null;\n        for (Address address : joinAddresses) {\n            NodeEngineImpl ne = nodes.get(address);\n            if (ne != null && ne.isRunning() && ne.getNode().joined()) {\n                nodeEngine = ne;\n                break;\n            }\n        }\n        Address master = null;\n        if (nodeEngine != null) {\n            if (nodeEngine.getNode().isMaster()) {\n                master = nodeEngine.getThisAddress();\n            } else {\n                master = nodeEngine.getMasterAddress();\n            }\n        }\n        if (master == null) {\n            master = node.getThisAddress();\n        }\n        return master;\n    }","id":47429,"modified_method":"private void lookupMasterAddress() {\n        NodeEngineImpl nodeEngine = findAliveNodeEngine();\n        if (nodeEngine == null) {\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        Address master;\n        if (nodeEngine.getNode().isMaster()) {\n            master = nodeEngine.getThisAddress();\n        } else {\n            master = nodeEngine.getMasterAddress();\n        }\n\n        if (master == null) {\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        NodeEngineImpl masterNodeEngine = nodes.get(master);\n        if (masterNodeEngine != null && masterNodeEngine.isRunning() && masterNodeEngine.getNode().joined()) {\n            masterAddress = master;\n        }\n    }","commit_id":"e33f32b07b5340d309af218a576ef28efa61cf63","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void doJoin() {\n        NodeEngineImpl nodeEngine = null;\n        synchronized (joinerLock) {\n            for (Address address : joinAddresses) {\n                NodeEngineImpl ne = nodes.get(address);\n                if (ne != null && ne.isRunning() && ne.getNode().joined()) {\n                    nodeEngine = ne;\n                    break;\n                }\n            }\n            Address master = null;\n            if (nodeEngine != null) {\n                if (nodeEngine.getNode().isMaster()) {\n                    master = nodeEngine.getThisAddress();\n                } else {\n                    master = nodeEngine.getMasterAddress();\n                }\n            }\n            if (master == null) {\n                master = node.getThisAddress();\n            }\n            node.setMasterAddress(master);\n            if (node.getMasterAddress().equals(node.getThisAddress())) {\n                node.setJoined();\n                node.setAsMaster();\n            } else {\n                final ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n\n                for (int i = 0; !node.joined() && node.isRunning() && i < 2000; i++) {\n                    try {\n                        clusterJoinManager.sendJoinRequest(node.getMasterAddress(), true);\n                        Thread.sleep(50);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                        break;\n                    }\n                }\n                if (!node.joined()) {\n                    logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                    node.shutdown(true);\n                }\n            }\n        }\n    }","id":47430,"modified_method":"public void doJoin() {\n        synchronized (joinerLock) {\n            Address master;\n\n            final ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            for (int i = 0; !node.joined() && node.isRunning() && i < 2000; i++) {\n                try {\n                    master = node.getMasterAddress();\n                    if (master == null) {\n                        master = findCurrentMasterAddress();\n                        node.setMasterAddress(master);\n                    }\n\n                    Assert.assertNotNull(master);\n                    if (master.equals(node.getThisAddress())) {\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    clusterJoinManager.sendJoinRequest(master, true);\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            if (!node.joined()) {\n                logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                node.shutdown(true);\n            }\n        }\n    }","commit_id":"5fedbbc66678ae81c24bbfae5aa9c04f965f5d29","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public FirewallingMockConnectionManager(IOService ioService, ConcurrentMap<Address, NodeEngineImpl> nodes, Node node, Object joinerLock) {\n        super(ioService, nodes, node, joinerLock);\n    }","id":47431,"modified_method":"public FirewallingMockConnectionManager(IOService ioService, Node node, TestNodeRegistry registry) {\n        super(ioService, node, registry);\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public MockConnectionManager(IOService ioService, ConcurrentMap<Address, NodeEngineImpl> nodes, Node node, Object joinerLock) {\n        this.ioService = ioService;\n        this.nodes = nodes;\n        this.node = node;\n        this.joinerLock = joinerLock;\n        this.logger = ioService.getLogger(MockConnectionManager.class.getName());\n        synchronized (this.joinerLock) {\n            this.nodes.put(node.getThisAddress(), node.nodeEngine);\n        }\n    }","id":47432,"modified_method":"public MockConnectionManager(IOService ioService, Node node, TestNodeRegistry registry) {\n        this.ioService = ioService;\n        this.registry = registry;\n        this.node = node;\n        this.logger = ioService.getLogger(MockConnectionManager.class.getName());\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void stop() {\n        logger.fine(\"Stopping connection manager\");\n        live = false;\n\n        for (Address address : nodes.keySet()) {\n            if (address.equals(node.getThisAddress())) {\n                continue;\n            }\n\n            final NodeEngineImpl otherNodeEngine = nodes.get(address);\n            if (otherNodeEngine != null && otherNodeEngine.getNode().getState() != NodeState.SHUT_DOWN) {\n                if (otherNodeEngine.getClusterService().getMember(node.getThisAddress()) == null) {\n                    continue;\n                }\n\n                logger.fine(otherNodeEngine.getThisAddress() + \" is instructed to remove this node.\");\n                otherNodeEngine.getExecutionService().execute(ExecutionService.SYSTEM_EXECUTOR, new Runnable() {\n                    public void run() {\n                        ClusterServiceImpl clusterService = (ClusterServiceImpl) otherNodeEngine.getClusterService();\n                        clusterService.removeAddress(node.getThisAddress());\n                    }\n                });\n            }\n        }\n        for (MockConnection connection : mapConnections.values()) {\n            connection.close();\n        }\n    }","id":47433,"modified_method":"@Override\n    public void stop() {\n        logger.fine(\"Stopping connection manager\");\n        live = false;\n\n        for (Address address : registry.getAddresses()) {\n            if (address.equals(node.getThisAddress())) {\n                continue;\n            }\n\n            final Node otherNode = registry.getNode(address);\n            if (otherNode != null && otherNode.getState() != NodeState.SHUT_DOWN) {\n                if (otherNode.getClusterService().getMember(node.getThisAddress()) == null) {\n                    continue;\n                }\n\n                logger.fine(otherNode.getThisAddress() + \" is instructed to remove this node.\");\n                otherNode.getNodeEngine().getExecutionService().execute(ExecutionService.SYSTEM_EXECUTOR, new Runnable() {\n                    public void run() {\n                        ClusterServiceImpl clusterService = (ClusterServiceImpl) otherNode.getClusterService();\n                        clusterService.removeAddress(node.getThisAddress());\n                    }\n                });\n            }\n        }\n        for (MockConnection connection : mapConnections.values()) {\n            connection.close();\n        }\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Connection getOrConnect(Address address) {\n        MockConnection conn = mapConnections.get(address);\n        if (live && (conn == null || !conn.isAlive())) {\n            NodeEngineImpl nodeEngine = nodes.get(address);\n            if (nodeEngine != null && nodeEngine.getNode().getState() != NodeState.SHUT_DOWN) {\n                MockConnection thisConnection = new MockConnection(address, node.getThisAddress(), node.nodeEngine);\n                conn = new MockConnection(node.getThisAddress(), address, nodeEngine);\n                conn.localConnection = thisConnection;\n                thisConnection.localConnection = conn;\n                mapConnections.put(address, conn);\n                logger.info(\"Created connection to endpoint: \" + address + \", connection: \" + conn);\n            }\n        }\n        return conn;\n    }","id":47434,"modified_method":"@Override\n    public Connection getOrConnect(Address address) {\n        MockConnection conn = mapConnections.get(address);\n        if (live && (conn == null || !conn.isAlive())) {\n            Node otherNode = registry.getNode(address);\n            if (otherNode != null && otherNode.getState() != NodeState.SHUT_DOWN) {\n                MockConnection thisConnection = new MockConnection(address, node.getThisAddress(), node.getNodeEngine());\n                conn = new MockConnection(node.getThisAddress(), address, otherNode.getNodeEngine());\n                conn.localConnection = thisConnection;\n                thisConnection.localConnection = conn;\n                mapConnections.put(address, conn);\n                logger.info(\"Created connection to endpoint: \" + address + \", connection: \" + conn);\n            }\n        }\n        return conn;\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void doJoin() {\n        synchronized (joinerLock) {\n\n            ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            long joinStartTime = Clock.currentTimeMillis();\n            long maxJoinMillis = getMaxJoinMillis();\n\n            while (node.isRunning() && !node.joined()\n                    && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n                try {\n                    if (masterAddress == null) {\n                        lookupMasterAddress();\n                    }\n\n                    if (node.getThisAddress().equals(masterAddress)) {\n                        logger.fine(\"This node is found as master, no need to join.\");\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    if (masterAddress != null) {\n                        logger.fine(\"Sending join request to master \" + masterAddress);\n                        node.setMasterAddress(masterAddress);\n                        if (!clusterJoinManager.sendJoinRequest(masterAddress, true)) {\n                            logger.fine(\"Could not send join request to \" + masterAddress);\n                            masterAddress = null;\n                        }\n                    }\n\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            if (!node.joined()) {\n                logger.severe(\"Node[\" + node.getThisAddress() + \"] should have been joined to \" + node.getMasterAddress());\n                node.shutdown(true);\n            }\n        }\n    }","id":47435,"modified_method":"public void doJoin() {\n        synchronized (registry) {\n            registry.registerNode(node);\n\n            ClusterJoinManager clusterJoinManager = node.clusterService.getClusterJoinManager();\n            final long joinStartTime = Clock.currentTimeMillis();\n            final long maxJoinMillis = getMaxJoinMillis();\n\n            while (node.isRunning() && !node.joined() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {\n                try {\n                    Address joinAddress = getJoinAddress();\n                    assertNotNull(joinAddress);\n\n                    if (node.getThisAddress().equals(joinAddress)) {\n                        logger.fine(\"This node is found as master, no need to join.\");\n                        node.setJoined();\n                        node.setAsMaster();\n                        break;\n                    }\n\n                    logger.fine(\"Sending join request to \" + joinAddress);\n                    if (!clusterJoinManager.sendJoinRequest(joinAddress, true)) {\n                        logger.fine(\"Could not send join request to \" + joinAddress);\n                        node.setMasterAddress(null);\n                    }\n\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n        }\n\n        final boolean joined = node.joined();\n        if (!joined) {\n            node.shutdown(true);\n        }\n        assertTrue(node.getThisAddress() + \" should have been joined to \" + node.getMasterAddress(), joined);\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private NodeEngineImpl findAliveNodeEngine() {\n        logger.fine(\"Searching possible addresses for master \" + joinAddresses);\n        for (Address address : joinAddresses) {\n            NodeEngineImpl nodeEngine = nodes.get(address);\n            if (nodeEngine == null) {\n                logger.fine(\"NodeEngine for \" + address + \" is null.\");\n                continue;\n            }\n\n            if (!nodeEngine.isRunning()) {\n                logger.fine(\"NodeEngine for \" + address + \" is not running. -> \" + nodeEngine.getNode().getState());\n                continue;\n            }\n\n            if (!nodeEngine.getNode().joined()) {\n                logger.fine(\"NodeEngine for \" + address + \" is not joined.\");\n                continue;\n            }\n\n            logger.fine(\"Found an alive node. Will ask master of \" + address);\n            return nodeEngine;\n        }\n        return null;\n    }","id":47436,"modified_method":"private Node findAliveNode() {\n        Collection<Address> joinAddresses = registry.getJoinAddresses();\n        logger.fine(\"Searching possible addresses for master \" + joinAddresses);\n        for (Address address : joinAddresses) {\n            Node foundNode = registry.getNode(address);\n            if (foundNode == null) {\n                logger.fine(\"Node for \" + address + \" is null.\");\n                continue;\n            }\n\n            Assert.assertEquals(address, foundNode.getThisAddress());\n\n            if (!foundNode.isRunning()) {\n                logger.fine(\"Node for \" + address + \" is not running. -> \" + foundNode.getState());\n                continue;\n            }\n\n            if (!foundNode.joined()) {\n                logger.fine(\"Node for \" + address + \" is not joined yet.\");\n                continue;\n            }\n\n            logger.fine(\"Found an alive node. Will ask master of \" + address);\n            return foundNode;\n        }\n        return null;\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void lookupMasterAddress() {\n        NodeEngineImpl nodeEngine = findAliveNodeEngine();\n        if (nodeEngine == null) {\n            logger.fine(\"Picking this node as master, no other running NodeEngine has been detected.\");\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        Address master;\n        if (nodeEngine.getNode().isMaster()) {\n            master = nodeEngine.getThisAddress();\n            logger.fine(\"Found node itself is master: \" + master);\n        } else {\n            master = nodeEngine.getMasterAddress();\n            logger.fine(\"Found node \" + nodeEngine.getThisAddress() + \" knows master as: \" + master);\n        }\n\n        if (master == null) {\n            logger.fine(\"Picking this node as master, found NodeEngine has no master information.\");\n            masterAddress = node.getThisAddress();\n            return;\n        }\n\n        NodeEngineImpl masterNodeEngine = nodes.get(master);\n        if (masterNodeEngine == null) {\n            logger.fine(\"NodeEngine for discovered master \" + master + \" is null.\");\n            return;\n        }\n\n        if (!masterNodeEngine.isRunning()) {\n            logger.fine(\"NodeEngine for discovered master \" + master + \" is not running. -> \"\n                    + masterNodeEngine.getNode().getState());\n            return;\n        }\n\n        if (!masterNodeEngine.getNode().joined()) {\n            logger.fine(\"NodeEngine for discovered master \" + master + \" is not joined.\");\n            return;\n        }\n\n        logger.fine(\"Found possible master. Will try to connect to \" + master);\n        masterAddress = master;\n    }","id":47437,"modified_method":"private Address lookupJoinAddress() {\n        Node foundNode = findAliveNode();\n        if (foundNode == null) {\n            logger.fine(\"Picking this node as master, no other running node has been detected.\");\n            return node.getThisAddress();\n        }\n\n        logger.fine(\"Found alive node. Will try to connect to \" + foundNode.getThisAddress());\n        return foundNode.getThisAddress();\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public ConnectionManager createConnectionManager(Node node, ServerSocketChannel serverSocketChannel) {\n        NodeIOService ioService = new NodeIOService(node, node.nodeEngine);\n        return new FirewallingMockConnectionManager(ioService, nodes, node, joinerLock);\n    }","id":47438,"modified_method":"public ConnectionManager createConnectionManager(Node node, ServerSocketChannel serverSocketChannel) {\n        NodeIOService ioService = new NodeIOService(node, node.nodeEngine);\n        return new FirewallingMockConnectionManager(ioService, node, registry);\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Joiner createJoiner(Node node) {\n        return new MockJoiner(node, joinAddresses, nodes, joinerLock);\n    }","id":47439,"modified_method":"public Joiner createJoiner(Node node) {\n        return new MockJoiner(node, registry);\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"ConcurrentMap<Address, NodeEngineImpl> getNodes() {\n        return nodes;\n    }","id":47440,"modified_method":"Map<Address, Node> getNodes() {\n        return Collections.unmodifiableMap(nodes);\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void shutdown(boolean terminate) {\n        Iterator<NodeEngineImpl> iterator = nodes.values().iterator();\n        while (iterator.hasNext()) {\n            NodeEngineImpl nodeEngine = iterator.next();\n            HazelcastInstance hz = nodeEngine.getHazelcastInstance();\n            LifecycleService lifecycleService = hz.getLifecycleService();\n            if (terminate) {\n                lifecycleService.terminate();\n            } else {\n                lifecycleService.shutdown();\n            }\n            iterator.remove();\n        }\n    }","id":47441,"modified_method":"private void shutdown(boolean terminate) {\n        Iterator<Node> iterator = nodes.values().iterator();\n        while (iterator.hasNext()) {\n            Node node = iterator.next();\n            HazelcastInstance hz = node.hazelcastInstance;\n            LifecycleService lifecycleService = hz.getLifecycleService();\n            if (terminate) {\n                lifecycleService.terminate();\n            } else {\n                lifecycleService.shutdown();\n            }\n            iterator.remove();\n        }\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public HazelcastInstance getInstance(Address address) {\n        NodeEngineImpl nodeEngine = nodes.get(address);\n        return nodeEngine != null && nodeEngine.isRunning() ? nodeEngine.getHazelcastInstance() : null;\n    }","id":47442,"modified_method":"public HazelcastInstance getInstance(Address address) {\n        Node node = nodes.get(address);\n        return node != null && node.isRunning() ? node.hazelcastInstance : null;\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public NodeContext createNodeContext(Address address) {\n        NodeEngineImpl nodeEngine;\n        if ((nodeEngine = nodes.get(address)) != null) {\n            if (nodeEngine.isRunning()) {\n                throw new IllegalArgumentException(\"This address already in registry! \" + address);\n            }\n            nodes.remove(address);\n        }\n        return new MockNodeContext(joinAddresses, nodes, address, joinerLock);\n    }","id":47443,"modified_method":"public NodeContext createNodeContext(Address address) {\n        Node node;\n        if ((node = nodes.get(address)) != null) {\n            assertEquals(\"This address is already in registry! \" + address, NodeState.SHUT_DOWN, node.getState());\n            nodes.remove(address, node);\n        }\n        return new MockNodeContext(this, address);\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Collection<HazelcastInstance> getAllHazelcastInstances() {\n        Collection<HazelcastInstance> all = new LinkedList<HazelcastInstance>();\n        for (NodeEngineImpl nodeEngine : nodes.values()) {\n            if (nodeEngine.isRunning()) {\n                all.add(nodeEngine.getHazelcastInstance());\n            }\n        }\n        return all;\n    }","id":47444,"modified_method":"public Collection<HazelcastInstance> getAllHazelcastInstances() {\n        Collection<HazelcastInstance> all = new LinkedList<HazelcastInstance>();\n        for (Node node : nodes.values()) {\n            if (node.isRunning()) {\n                all.add(node.hazelcastInstance);\n            }\n        }\n        return all;\n    }","commit_id":"9de94166419ad1fb7c83474709c32d1a6e6c6a10","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\r\n\t * Thread method: this thread will handle reading datagrams and \r\n\t * the periodic re-expressing of standing interests\r\n\t */\r\n\tpublic void run() {\r\n\t\tif (! _run) {\r\n\t\t\tLog.warning(\"CCNNetworkManager run() called after shutdown\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Allocate datagram buffer: want to wrap array to ensure backed by\r\n\t\t// array to permit decoding\r\n\t\tbyte[] buffer = new byte[MAX_PAYLOAD];\r\n\t\tByteBuffer datagram = ByteBuffer.wrap(buffer);\r\n\t\tWirePacket packet = new WirePacket();\r\n\t\tif( Log.isLoggable(Level.INFO) )\r\n\t\t\tLog.info(\"CCNNetworkManager processing thread started for port: \" + _localPort);\r\n\t\twhile (_run) {\r\n\t\t\tif (_channel.isConnected()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t//--------------------------------- Read and decode\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tif (_channel.select(SOCKET_TIMEOUT) != 0) {\r\n\t\t\t\t\t\t\t// Note: we're selecting on only one channel to get\r\n\t\t\t\t\t\t\t// the ability to use wakeup, so there is no need to \r\n\t\t\t\t\t\t\t// inspect the selected-key set\r\n\t\t\t\t\t\t\tdatagram.clear(); // make ready for new read\r\n\t\t\t\t\t\t\tsynchronized (_channel) {\r\n\t\t\t\t\t\t\t\t_channel.read(datagram); // queue readers and writers\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif( Log.isLoggable(Level.FINEST) )\r\n\t\t\t\t\t\t\t\tLog.finest(\"Read datagram (\" + datagram.position() + \" bytes) for port: \" + _localPort);\r\n\t\t\t\t\t\t\t_channel.clearSelectedKeys();\r\n\t\t\t\t\t\t\tdatagram.flip(); // make ready to decode\r\n\t\t\t\t\t\t\tif (null != _tapStreamIn) {\r\n\t\t\t\t\t\t\t\tbyte [] b = new byte[datagram.limit()];\r\n\t\t\t\t\t\t\t\tdatagram.get(b);\r\n\t\t\t\t\t\t\t\t_tapStreamIn.write(b);\r\n\t\t\t\t\t\t\t\tdatagram.rewind();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\t\tpacket.decode(datagram);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// This was a timeout or wakeup, no data\r\n\t\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\t\tif (!_run) {\r\n\t\t\t\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (IOException io) {\r\n\t\t\t\t\t\t_channel.close();\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.INFO) )\r\n\t\t\t\t\t\t\tLog.info(\"Unable to receive from agent: is it still running? Port: \" + _localPort);\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t}\r\n\t                if (!_run) {\r\n\t                    // exit immediately if wakeup for shutdown\r\n\t                    break;\r\n\t                }\r\n\t                \r\n\t                // If we got a data packet, hand it back to all the interested\r\n\t\t\t\t\t// parties (registered interests and getters).\r\n\t\t\t\t\t//--------------------------------- Process data from net (if any) \r\n\t\t\t\t\tfor (ContentObject co : packet.data()) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.FINER) )\r\n\t\t\t\t\t\t\tLog.finer(\"Data from net for port: \" + _localPort + \" {0}\", co.name());\r\n\t\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdeliverData(co);\r\n\t\t\t\t\t\t// External data never goes back to network, never held onto here\r\n\t\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//--------------------------------- Process interests from net (if any)\r\n\t\t\t\t\tfor (Interest interest : packet.interests()) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.FINEST) )\r\n\t\t\t\t\t\t\tLog.finest(\"Interest from net for port: \" + _localPort + \" {0}\", interest);\r\n\t\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(this, interest, null, null);\r\n\t\t\t\t\t\tdeliverInterest(oInterest);\r\n\t\t\t\t\t\t// External interests never go back to network\r\n\t\t\t\t\t} // for interests\r\n\t\t\t\t\t\r\n\t\t\t\t} catch (Exception ex) {\r\n\t\t\t\t\tLog.severe(\"Processing thread failure (UNKNOWN): \" + ex.getMessage() + \" for port: \" + _localPort);\r\n\t                Log.warningStackTrace(ex);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tThread.sleep(DOWN_DELAY);\r\n\t\t\t\t} catch (InterruptedException e) {}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_threadpool.shutdown();\r\n\t\tLog.info(\"Shutdown complete for port: \" + _localPort);\r\n\t}","id":47445,"modified_method":"/**\r\n\t * Thread method: this thread will handle reading datagrams and \r\n\t * the periodic re-expressing of standing interests\r\n\t */\r\n\tpublic void run() {\r\n\t\tif (! _run) {\r\n\t\t\tLog.warning(\"CCNNetworkManager run() called after shutdown\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tWirePacket packet = new WirePacket();\r\n\t\tif( Log.isLoggable(Level.INFO) )\r\n\t\t\tLog.info(\"CCNNetworkManager processing thread started for port: \" + _localPort);\r\n\t\twhile (_run) {\r\n\t\t\tif (_channel.isConnected()) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t//--------------------------------- Read and decode\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tif (_channel.select(SOCKET_TIMEOUT) != 0) {\r\n\t\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\t\tpacket.decode(_channel.getInputStream());\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// This was a timeout or wakeup, no data\r\n\t\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\t\tif (!_run) {\r\n\t\t\t\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (ContentDecodingException cde) {\r\n\t\t\t\t\t\t_channel.close();\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.INFO) )\r\n\t\t\t\t\t\t\tLog.info(\"Shutting down channel to ccnd\");\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} catch (IOException ioe) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.INFO) )\r\n\t\t\t\t\t\t\tLog.info(\"Error on ccnd channel: \" + ioe.getMessage());\r\n\t\t\t\t\t\tpacket.clear();\t\t\r\n\t\t\t\t\t}\r\n\t                if (!_run) {\r\n\t                    // exit immediately if wakeup for shutdown\r\n\t                    break;\r\n\t                }\r\n\t                \r\n\t                // If we got a data packet, hand it back to all the interested\r\n\t\t\t\t\t// parties (registered interests and getters).\r\n\t\t\t\t\t//--------------------------------- Process data from net (if any) \r\n\t\t\t\t\tfor (ContentObject co : packet.data()) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.FINER) )\r\n\t\t\t\t\t\t\tLog.finer(\"Data from net for port: \" + _localPort + \" {0}\", co.name());\r\n\t\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdeliverData(co);\r\n\t\t\t\t\t\t// External data never goes back to network, never held onto here\r\n\t\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//--------------------------------- Process interests from net (if any)\r\n\t\t\t\t\tfor (Interest interest : packet.interests()) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Level.FINEST) )\r\n\t\t\t\t\t\t\tLog.finest(\"Interest from net for port: \" + _localPort + \" {0}\", interest);\r\n\t\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(this, interest, null, null);\r\n\t\t\t\t\t\tdeliverInterest(oInterest);\r\n\t\t\t\t\t\t// External interests never go back to network\r\n\t\t\t\t\t} // for interests\r\n\t\t\t\t\t\r\n\t\t\t\t} catch (Exception ex) {\r\n\t\t\t\t\tLog.severe(\"Processing thread failure (UNKNOWN): \" + ex.getMessage() + \" for port: \" + _localPort);\r\n\t                Log.warningStackTrace(ex);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tThread.sleep(DOWN_DELAY);\r\n\t\t\t\t} catch (InterruptedException e) {}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_threadpool.shutdown();\r\n\t\tLog.info(\"Shutdown complete for port: \" + _localPort);\r\n\t}","commit_id":"cc9bfb78c78d175bfb816f7a801e20bc45f1a9f1","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static OperationResourceInfo findTargetMethod(ClassResourceInfo resource,\n                                                         Message message,\n                                                         String httpMethod, \n                                                         MultivaluedMap<String, String> values, \n                                                         String requestContentType, \n                                                         List<MediaType> acceptContentTypes,\n                                                         boolean logNow) {\n        if (LOG.isLoggable(Level.FINE)) {\n            org.apache.cxf.common.i18n.Message msg = \n                new org.apache.cxf.common.i18n.Message(\"START_OPER_MATCH\", \n                                                       BUNDLE,\n                                                       resource.getServiceClass().getName());\n            LOG.fine(msg.toString());\n            \n        }\n        String path = values.getFirst(URITemplate.FINAL_MATCH_GROUP);\n        if (path == null) {\n            path = \"/\";\n        }\n        \n        SortedMap<OperationResourceInfo, MultivaluedMap<String, String>> candidateList = \n            new TreeMap<OperationResourceInfo, MultivaluedMap<String, String>>(\n                new OperationResourceInfoComparator(message, httpMethod));\n\n        MediaType requestType = requestContentType == null \n                                ? ALL_TYPES : MediaType.valueOf(requestContentType);\n        \n        int pathMatched = 0;\n        int methodMatched = 0;\n        int consumeMatched = 0;\n        int produceMatched = 0;\n        \n        boolean subresourcesOnly = true;\n        for (MediaType acceptType : acceptContentTypes) {\n            for (OperationResourceInfo ori : resource.getMethodDispatcher().getOperationResourceInfos()) {\n                URITemplate uriTemplate = ori.getURITemplate();\n                MultivaluedMap<String, String> map = new MetadataMap<String, String>(values);\n                if (uriTemplate != null && uriTemplate.match(path, map)) {\n                    boolean added = false;\n                    if (ori.isSubResourceLocator()) {\n                        candidateList.put(ori, map);\n                        added = true;\n                    } else {\n                        String finalGroup = map.getFirst(URITemplate.FINAL_MATCH_GROUP);\n                        if (finalGroup == null || StringUtils.isEmpty(finalGroup)\n                            || finalGroup.equals(\"/\")) {\n                            pathMatched++;\n                            boolean mMatched = matchHttpMethod(ori.getHttpMethod(), httpMethod);\n                            boolean cMatched = matchConsumeTypes(requestType, ori);\n                            boolean pMatched = matchProduceTypes(acceptType, ori);\n                            if (mMatched && cMatched && pMatched) {\n                                subresourcesOnly = false;\n                                candidateList.put(ori, map);\n                                added = true;\n                            } else {\n                                methodMatched = mMatched ? methodMatched + 1 : methodMatched;\n                                produceMatched = pMatched ? produceMatched + 1 : produceMatched;\n                                consumeMatched = cMatched ? consumeMatched + 1 : consumeMatched;\n                                logNoMatchMessage(ori, path, httpMethod, requestType, acceptContentTypes);\n                            }\n                        } else {\n                            logNoMatchMessage(ori, path, httpMethod, requestType, acceptContentTypes);\n                        }\n                    }\n                    if (added && LOG.isLoggable(Level.FINE)) {\n                        LOG.fine(new org.apache.cxf.common.i18n.Message(\"OPER_SELECTED_POSSIBLY\", \n                                  BUNDLE, \n                                  ori.getMethodToInvoke().getName()).toString());\n                    }\n                } else {\n                    logNoMatchMessage(ori, path, httpMethod, requestType, acceptContentTypes);\n                }\n            }\n            if (!candidateList.isEmpty() && !subresourcesOnly) {\n                break;\n            }\n        }\n        if (!candidateList.isEmpty()) {\n            Map.Entry<OperationResourceInfo, MultivaluedMap<String, String>> firstEntry = \n                candidateList.entrySet().iterator().next();\n            values.clear();\n            values.putAll(firstEntry.getValue());\n            OperationResourceInfo ori = firstEntry.getKey();\n            if (headMethodPossible(ori.getHttpMethod(), httpMethod)) {\n                LOG.info(new org.apache.cxf.common.i18n.Message(\"GET_INSTEAD_OF_HEAD\", \n                         BUNDLE, resource.getServiceClass().getName(), \n                         ori.getMethodToInvoke().getName()).toString());\n            }\n            LOG.fine(new org.apache.cxf.common.i18n.Message(\"OPER_SELECTED\", \n                           BUNDLE, ori.getMethodToInvoke().getName(), \n                           resource.getServiceClass().getName()).toString());\n            return ori;\n        }\n        \n        int status;\n        \n        // criteria matched the least number of times will determine the error code;\n        // priority : path, method, consumes, produces;\n        if (pathMatched == 0) {\n            status = 404;\n        } else if (methodMatched == 0) {\n            status = 405;\n        } else if (consumeMatched <= produceMatched) {\n            status = 415;\n        } else {\n            status = 406;\n        }\n        \n        String name = resource.isRoot() ? \"NO_OP_EXC\" : \"NO_SUBRESOURCE_METHOD_FOUND\";\n        org.apache.cxf.common.i18n.Message errorMsg = \n            new org.apache.cxf.common.i18n.Message(name, \n                                                   BUNDLE,\n                                                   path,\n                                                   httpMethod,\n                                                   requestType.toString(),\n                                                   convertTypesToString(acceptContentTypes));\n        if (!\"OPTIONS\".equalsIgnoreCase(httpMethod) && logNow) {\n            LOG.warning(errorMsg.toString());\n        }\n        ResponseBuilder rb = createResponseBuilder(resource, status, methodMatched == 0);\n        throw new WebApplicationException(rb.build());\n        \n    }","id":47446,"modified_method":"public static OperationResourceInfo findTargetMethod(ClassResourceInfo resource,\n                                                         Message message,\n                                                         String httpMethod, \n                                                         MultivaluedMap<String, String> values, \n                                                         String requestContentType, \n                                                         List<MediaType> acceptContentTypes,\n                                                         boolean logNow) {\n        boolean isFineLevelLoggable = LOG.isLoggable(Level.FINE); \n        if (isFineLevelLoggable) {\n            org.apache.cxf.common.i18n.Message msg = \n                new org.apache.cxf.common.i18n.Message(\"START_OPER_MATCH\", \n                                                       BUNDLE,\n                                                       resource.getServiceClass().getName());\n            LOG.fine(msg.toString());\n            \n        }\n        String path = values.getFirst(URITemplate.FINAL_MATCH_GROUP);\n        if (path == null) {\n            path = \"/\";\n        }\n        \n        SortedMap<OperationResourceInfo, MultivaluedMap<String, String>> candidateList = \n            new TreeMap<OperationResourceInfo, MultivaluedMap<String, String>>(\n                new OperationResourceInfoComparator(message, httpMethod));\n\n        MediaType requestType = requestContentType == null \n                                ? ALL_TYPES : MediaType.valueOf(requestContentType);\n        \n        int pathMatched = 0;\n        int methodMatched = 0;\n        int consumeMatched = 0;\n        int produceMatched = 0;\n        \n        boolean subresourcesOnly = true;\n        for (MediaType acceptType : acceptContentTypes) {\n            for (OperationResourceInfo ori : resource.getMethodDispatcher().getOperationResourceInfos()) {\n                URITemplate uriTemplate = ori.getURITemplate();\n                MultivaluedMap<String, String> map = new MetadataMap<String, String>(values);\n                if (uriTemplate != null && uriTemplate.match(path, map)) {\n                    boolean added = false;\n                    if (ori.isSubResourceLocator()) {\n                        candidateList.put(ori, map);\n                        added = true;\n                    } else {\n                        String finalGroup = map.getFirst(URITemplate.FINAL_MATCH_GROUP);\n                        if (finalGroup == null || StringUtils.isEmpty(finalGroup)\n                            || finalGroup.equals(\"/\")) {\n                            pathMatched++;\n                            boolean mMatched = matchHttpMethod(ori.getHttpMethod(), httpMethod);\n                            boolean cMatched = matchConsumeTypes(requestType, ori);\n                            boolean pMatched = matchProduceTypes(acceptType, ori);\n                            if (mMatched && cMatched && pMatched) {\n                                subresourcesOnly = false;\n                                candidateList.put(ori, map);\n                                added = true;\n                            } else {\n                                methodMatched = mMatched ? methodMatched + 1 : methodMatched;\n                                produceMatched = pMatched ? produceMatched + 1 : produceMatched;\n                                consumeMatched = cMatched ? consumeMatched + 1 : consumeMatched;\n                                logNoMatchMessage(ori, path, httpMethod, requestType, acceptContentTypes);\n                            }\n                        } else {\n                            logNoMatchMessage(ori, path, httpMethod, requestType, acceptContentTypes);\n                        }\n                    }\n                    if (added && isFineLevelLoggable) {\n                        LOG.fine(new org.apache.cxf.common.i18n.Message(\"OPER_SELECTED_POSSIBLY\", \n                                  BUNDLE, \n                                  ori.getMethodToInvoke().getName()).toString());\n                    }\n                } else {\n                    logNoMatchMessage(ori, path, httpMethod, requestType, acceptContentTypes);\n                }\n            }\n            if (!candidateList.isEmpty() && !subresourcesOnly) {\n                break;\n            }\n        }\n        if (!candidateList.isEmpty()) {\n            Map.Entry<OperationResourceInfo, MultivaluedMap<String, String>> firstEntry = \n                candidateList.entrySet().iterator().next();\n            values.clear();\n            values.putAll(firstEntry.getValue());\n            OperationResourceInfo ori = firstEntry.getKey();\n            if (headMethodPossible(ori.getHttpMethod(), httpMethod)) {\n                LOG.info(new org.apache.cxf.common.i18n.Message(\"GET_INSTEAD_OF_HEAD\", \n                         BUNDLE, resource.getServiceClass().getName(), \n                         ori.getMethodToInvoke().getName()).toString());\n            }\n            if (isFineLevelLoggable) {\n                LOG.fine(new org.apache.cxf.common.i18n.Message(\"OPER_SELECTED\", \n                               BUNDLE, ori.getMethodToInvoke().getName(), \n                               resource.getServiceClass().getName()).toString());\n            }\n            return ori;\n        }\n        \n        int status;\n        \n        // criteria matched the least number of times will determine the error code;\n        // priority : path, method, consumes, produces;\n        if (pathMatched == 0) {\n            status = 404;\n        } else if (methodMatched == 0) {\n            status = 405;\n        } else if (consumeMatched <= produceMatched) {\n            status = 415;\n        } else {\n            status = 406;\n        }\n        \n        String name = resource.isRoot() ? \"NO_OP_EXC\" : \"NO_SUBRESOURCE_METHOD_FOUND\";\n        org.apache.cxf.common.i18n.Message errorMsg = \n            new org.apache.cxf.common.i18n.Message(name, \n                                                   BUNDLE,\n                                                   path,\n                                                   httpMethod,\n                                                   requestType.toString(),\n                                                   convertTypesToString(acceptContentTypes));\n        if (!\"OPTIONS\".equalsIgnoreCase(httpMethod) && logNow) {\n            LOG.warning(errorMsg.toString());\n        }\n        ResponseBuilder rb = createResponseBuilder(resource, status, methodMatched == 0);\n        throw new WebApplicationException(rb.build());\n        \n    }","commit_id":"2d8876e968a5a83b78ee64054773681cb65f77d3","url":"https://github.com/apache/cxf"},{"original_method":"public static ClassResourceInfo selectResourceClass(List<ClassResourceInfo> resources,\n                                                 String path, \n                                                 MultivaluedMap<String, String> values,\n                                                 Message message) {\n        \n        LOG.fine(new org.apache.cxf.common.i18n.Message(\"START_CRI_MATCH\", \n                                                        BUNDLE, \n                                                        path).toString());\n        if (resources.size() == 1) { \n            return resources.get(0).getURITemplate().match(path, values)\n                   ? resources.get(0) : null;\n        }\n        \n        SortedMap<ClassResourceInfo, MultivaluedMap<String, String>> candidateList = \n            new TreeMap<ClassResourceInfo, MultivaluedMap<String, String>>(\n                new ClassResourceInfoComparator(message));\n        \n        for (ClassResourceInfo cri : resources) {\n            MultivaluedMap<String, String> map = new MetadataMap<String, String>();\n            if (cri.getURITemplate().match(path, map)) {\n                candidateList.put(cri, map);\n                LOG.fine(new org.apache.cxf.common.i18n.Message(\"CRI_SELECTED_POSSIBLY\", \n                                                                BUNDLE, \n                                                                cri.getServiceClass().getName(),\n                                                                path, \n                                                                cri.getURITemplate().getValue()).toString());\n            } else {\n                LOG.fine(new org.apache.cxf.common.i18n.Message(\"CRI_NO_MATCH\", \n                                                                BUNDLE, \n                                                                path,\n                                                                cri.getServiceClass().getName()).toString());\n            }\n        }\n        \n        if (!candidateList.isEmpty()) {\n            Map.Entry<ClassResourceInfo, MultivaluedMap<String, String>> firstEntry = \n                candidateList.entrySet().iterator().next();\n            values.putAll(firstEntry.getValue());\n            ClassResourceInfo cri = firstEntry.getKey();\n            LOG.fine(new org.apache.cxf.common.i18n.Message(\"CRI_SELECTED\", \n                                                         BUNDLE, \n                                                         cri.getServiceClass().getName(),\n                                                         path, cri.getURITemplate().getValue()).toString());\n            return cri;\n        }\n        \n        return null;\n    }","id":47447,"modified_method":"public static ClassResourceInfo selectResourceClass(List<ClassResourceInfo> resources,\n                                                 String path, \n                                                 MultivaluedMap<String, String> values,\n                                                 Message message) {\n        boolean isFineLevelLoggable = LOG.isLoggable(Level.FINE); \n        if (isFineLevelLoggable) {\n            LOG.fine(new org.apache.cxf.common.i18n.Message(\"START_CRI_MATCH\", \n                                                        BUNDLE, \n                                                        path).toString());\n        }\n        if (resources.size() == 1) { \n            return resources.get(0).getURITemplate().match(path, values)\n                   ? resources.get(0) : null;\n        }\n        \n        SortedMap<ClassResourceInfo, MultivaluedMap<String, String>> candidateList = \n            new TreeMap<ClassResourceInfo, MultivaluedMap<String, String>>(\n                new ClassResourceInfoComparator(message));\n        \n        for (ClassResourceInfo cri : resources) {\n            MultivaluedMap<String, String> map = new MetadataMap<String, String>();\n            if (cri.getURITemplate().match(path, map)) {\n                candidateList.put(cri, map);\n                if (isFineLevelLoggable) {\n                    LOG.fine(new org.apache.cxf.common.i18n.Message(\"CRI_SELECTED_POSSIBLY\", \n                                                                BUNDLE, \n                                                                cri.getServiceClass().getName(),\n                                                                path, \n                                                                cri.getURITemplate().getValue()).toString());\n                }\n            } else if (isFineLevelLoggable) {\n                LOG.fine(new org.apache.cxf.common.i18n.Message(\"CRI_NO_MATCH\", \n                                                                BUNDLE, \n                                                                path,\n                                                                cri.getServiceClass().getName()).toString());\n            }\n        }\n        \n        if (!candidateList.isEmpty()) {\n            Map.Entry<ClassResourceInfo, MultivaluedMap<String, String>> firstEntry = \n                candidateList.entrySet().iterator().next();\n            values.putAll(firstEntry.getValue());\n            ClassResourceInfo cri = firstEntry.getKey();\n            if (isFineLevelLoggable) {\n                LOG.fine(new org.apache.cxf.common.i18n.Message(\"CRI_SELECTED\", \n                                                         BUNDLE, \n                                                         cri.getServiceClass().getName(),\n                                                         path, cri.getURITemplate().getValue()).toString());\n            }\n            return cri;\n        }\n        \n        return null;\n    }","commit_id":"2d8876e968a5a83b78ee64054773681cb65f77d3","url":"https://github.com/apache/cxf"},{"original_method":"/**\n\t * \n\t * @param handle\n\t * @param topo\n\t * @param prefix\n\t * @param filters\n\t * @param startHash\n\t * @param startName Start enumerating names after this one. NOTE - this is currently implemented in a\n\t * \t\t\t\t    simplistic way which may not work in cases of disjoint hashes.\n\t * @param syncCallback\n\t * @return\n\t * @throws IOException\n\t * @throws ConfigurationException\n\t */\n\tpublic ConfigSlice startSync(CCNHandle handle, ContentName topo, ContentName prefix, Collection<ContentName> filters, byte[] startHash, ContentName startName, CCNSyncHandler syncCallback) throws IOException, ConfigurationException{\n\t\tif (handle == null)\n\t\t\thandle = CCNHandle.getHandle();\n\t\tCollection<Filter> f = new ArrayList<Filter>();\n\t\tif (filters!=null) {\n\t\t\tfor (ContentName cn: filters)\n\t\t\t\tf.add(new Filter(cn));\n\t\t}\n\t\ttry {\n\t\t\tConfigSlice slice = ConfigSlice.checkAndCreate(topo, prefix, f, handle);\n\t\t\tif (syncMon == null)\n\t\t\t\tsyncMon = new ProtocolBasedSyncMonitor(handle);\n\t\t\tsyncMon.registerCallback(syncCallback, slice, startHash, startName);\n\t\t\treturn slice;\n\t\t} catch (Exception e) {\n\t\t\tLog.warning(Log.FAC_REPO, \"Error when starting sync for slice with prefix: {0}\", prefix);\n\t\t\tthrow new IOException(\"Unable to create sync slice: \"+e.getMessage());\n\t\t}\n\t}","id":47448,"modified_method":"/**\n\t * \n\t * @param handle\n\t * @param topo\n\t * @param prefix\n\t * @param filters\n\t * @param startHash\n\t * @param startName Start enumerating names after this one. NOTE - this is currently implemented in a\n\t * \t\t\t\t    simplistic way which may not work in cases of disjoint hashes.\n\t * @param syncCallback\n\t * @return\n\t * @throws IOException\n\t * @throws ConfigurationException\n\t */\n\tpublic ConfigSlice startSync(CCNHandle handle, ContentName topo, ContentName prefix, Collection<ContentName> filters, byte[] startHash, ContentName startName, CCNSyncHandler syncCallback) throws IOException, ConfigurationException{\n\t\tif (handle == null)\n\t\t\thandle = CCNHandle.getHandle();\n\t\tCollection<Filter> f = new ArrayList<Filter>();\n\t\tif (filters!=null) {\n\t\t\tfor (ContentName cn: filters)\n\t\t\t\tf.add(new Filter(cn));\n\t\t}\n\t\ttry {\n\t\t\tConfigSlice slice = ConfigSlice.checkAndCreate(topo, prefix, f, handle);\n\t\t\tif (syncMon == null)\n\t\t\t\tsyncMon = new ProtocolBasedSyncMonitor(handle);\n\t\t\tsyncMon.registerCallback(syncCallback, slice, startHash, startName);\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(\"Started sync with topo: {0} and prefix: {1}\", topo, prefix);\n\t\t\treturn slice;\n\t\t} catch (Exception e) {\n\t\t\tLog.warning(Log.FAC_REPO, \"Error when starting sync for slice with prefix: {0}\", prefix);\n\t\t\tthrow new IOException(\"Unable to create sync slice: \"+e.getMessage());\n\t\t}\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Test\n\tpublic void testSyncStartName() throws Exception {\n\t\tLog.info(Log.FAC_TEST,\"Starting testSyncStartName\");\n\t\tContentName prefix1;\n\t\tprefix1 = prefix.append(\"slice7\");\n\t\tCCNSync sync1 = new CCNSync();\n\t\t\n\t\t//the slice should be written..  now save content and get a callback.\n\t\tLog.fine(Log.FAC_TEST, \"writing out file: {0}\", prefix1);\n\t\t\n\t\t// Write a 100 block file to test a true sync tree\n\t\tint segments = writeFile(prefix1, false, SystemConfiguration.BLOCK_SIZE * 100);\n\t\tContentObject checkObj = getHandle.get(prefix1, SystemConfiguration.MEDIUM_TIMEOUT);\n\t\tAssert.assertNotNull(\"Didn't get back what we wrote to the repo\", checkObj);\n\t\tContentName name = checkObj.name();\n\t\tname = name.cut(name.count() - 1);\n\t\tContentName startName = SegmentationProfile.segmentName(name, 20);\n\t\tConfigSlice slice7 = sync1.startSync(getHandle, topo, prefix1, null, null, startName, this);\n\t\tint segmentCheck = checkCallbacks(prefix1, segments - 20, 20);\n\t\tif (segmentCheck!=0)\n\t\t\tAssert.fail(\"Did not receive all of the callbacks\");\n\t\telse\n\t\t\tLog.fine(Log.FAC_TEST, \"I got all the callbacks for part 1 of testSyncRestart!\");\n\t\tsync1.stopSync(this, slice7);\n\t\tLog.info(Log.FAC_TEST,\"Finished running testSyncStartName\");\n\t}","id":47449,"modified_method":"@Test\n\tpublic void testSyncStartName() throws Exception {\n\t\tLog.info(Log.FAC_TEST,\"Starting testSyncStartName\");\n\t\tContentName prefix1;\n\t\tprefix1 = prefix.append(\"slice8\");\n\t\tCCNSync sync1 = new CCNSync();\n\t\t\n\t\tLog.fine(Log.FAC_TEST, \"writing out file: {0}\", prefix1);\n\t\t\n\t\t// Write a 100 block file to test a true sync tree\n\t\tint segments = writeFile(prefix1, false, SystemConfiguration.BLOCK_SIZE * 100);\n\t\tContentObject checkObj = getHandle.get(prefix1, SystemConfiguration.MEDIUM_TIMEOUT);\n\t\tAssert.assertNotNull(\"Didn't get back what we wrote to the repo\", checkObj);\n\t\tContentName name = checkObj.name();\n\t\tname = name.cut(name.count() - 1);\n\t\tContentName startName = SegmentationProfile.segmentName(name, 20);\n\t\t\n\t\t// We should start looking starting with segment 20\n\t\tConfigSlice slice8 = sync1.startSync(getHandle, topo, prefix1, null, null, startName, this);\n\t\tint segmentCheck = checkCallbacks(prefix1, segments - 20, 20);\n\t\tif (segmentCheck!=0)\n\t\t\tAssert.fail(\"Did not receive all of the callbacks\");\n\t\telse\n\t\t\tLog.fine(Log.FAC_TEST, \"I got all the callbacks for part 1 of testSyncRestart!\");\n\t\tsync1.stopSync(this, slice8);\n\t\tLog.info(Log.FAC_TEST,\"Finished running testSyncStartName\");\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private int writeFile(ContentName name, boolean random, int size) throws Exception {\n\t\tint segmentsToWrite = 0;\n\t\tRepositoryFileOutputStream rfos = new RepositoryFileOutputStream(name.append(\"randomFile\"), putHandle);\n\t\tDigestOutputStream dos = new DigestOutputStream(rfos, MessageDigest.getInstance(CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM));\n\n\t\tbyte [] buf = new byte[BUF_SIZE];\n\t\tint count = 0;\n\t\tint towrite = 0;\n\t\tRandom rand = new Random();\n\t\tint bytes = 0;\n\t\tif (random) {\n\t\t\tbytes = rand.nextInt(maxBytes) + 1;\n\t\t} else\n\t\t\tbytes = size;\n\t\tdouble block = (double)bytes/(double)SystemConfiguration.BLOCK_SIZE;\n\t\tsegmentsToWrite = (int) (Math.ceil(block) + 1);\n\t\tLog.fine(Log.FAC_TEST, \"bytes: {0} block size: {1} div: {2} ceil: {3}\", bytes, SystemConfiguration.BLOCK_SIZE, block, (int)Math.ceil(block));\n\t\tLog.fine(Log.FAC_TEST, \"will write out a {0} byte file, will have {1} segments (1 is a header)\", bytes, segmentsToWrite);\n\t\twhile (count < bytes) {\n\t\t\trand.nextBytes(buf);\n\t\t\ttowrite = ((bytes - count) > buf.length) ? buf.length : (bytes - count);\n\t\t\tdos.write(buf, 0, towrite);\n\t\t\tcount += towrite;\n\t\t}\n\t\tdos.flush();\n\t\tdos.close();\n\t\trfos.close();\n\t\tLog.info(Log.FAC_TEST, \"Wrote file to repository: {0} with {1} segments\", rfos.getBaseName(), segmentsToWrite);\n\t\treturn segmentsToWrite;\n\t}","id":47450,"modified_method":"private int writeFile(ContentName name, boolean random, int size) throws Exception {\n\t\tint segmentsToWrite = 0;\n\t\tRepositoryFileOutputStream rfos = new RepositoryFileOutputStream(name.append(\"randomFile\"), putHandle);\n\t\tDigestOutputStream dos = new DigestOutputStream(rfos, MessageDigest.getInstance(CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM));\n\n\t\tbyte [] buf = new byte[BUF_SIZE];\n\t\tint count = 0;\n\t\tint towrite = 0;\n\t\tRandom rand = new Random();\n\t\tint bytes = 0;\n\t\tif (random) {\n\t\t\tbytes = rand.nextInt(maxBytes) + 1;\n\t\t} else\n\t\t\tbytes = size;\n\t\tdouble block = (double)bytes/(double)SystemConfiguration.BLOCK_SIZE;\n\t\tsegmentsToWrite = (int) (Math.ceil(block) + 1);\n\t\tLog.fine(Log.FAC_TEST, \"bytes: {0} block size: {1} div: {2} ceil: {3}\", bytes, SystemConfiguration.BLOCK_SIZE, block, (int)Math.ceil(block));\n\t\tLog.fine(Log.FAC_TEST, \"will write out a {0} byte file, will have {1} segments (1 is a header)\", bytes, segmentsToWrite);\n\t\twhile (count < bytes) {\n\t\t\trand.nextBytes(buf);\n\t\t\ttowrite = ((bytes - count) > buf.length) ? buf.length : (bytes - count);\n\t\t\tdos.write(buf, 0, towrite);\n\t\t\tcount += towrite;\n\t\t}\n\t\tdos.flush();\n\t\tdos.close();\n\t\tLog.info(Log.FAC_TEST, \"Wrote file to repository: {0} with {1} segments\", rfos.getBaseName(), segmentsToWrite);\n\t\treturn segmentsToWrite;\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Separate thread for running comparisons. We run until we can't do anything\n\t * anymore, then rely on \"kickCompare\" to restart the thread. It uses a state\n\t * machine to figure out where it left off and where to start back in again.\n\t */\n\tpublic void run() {\n\t\t_compareSemaphore.acquireUninterruptibly();\n\t\tboolean keepComparing = true;\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tswitch (getState()) {\n\t\t\t\tcase INIT:\t\t// Starting a new compare\n\t\t\t\t\tnextRound();\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tbyte[] data = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tdata = getPendingContent();\n\t\t\t\t\t\t\tif (null != data) {\n\t\t\t\t\t\t\t\tSyncNodeComposite snc = new SyncNodeComposite();\n\t\t\t\t\t\t\t\tsnc.decode(data);\n\t\t\t\t\t\t\t\tSyncTreeEntry ste = _pbsm.addHash(snc.getHash());\n\t\t\t\t\t\t\t\tste.setNode(snc);\n\t\t\t\t\t\t\t\taddPending(ste);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (null != data);\n\t\t\t\t\t\tSyncTreeEntry ste = getPending();\n\t\t\t\t\t\tif (null != ste) {\n\t\t\t\t\t\t\tpush(ste, _next);\n\t\t\t\t\t\t\t_currentRoot = ste;\n\t\t\t\t\t\t\tchangeState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_state == SyncCompareState.INIT) {\n\t\t\t\t\t\t\t_state = SyncCompareState.DONE;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Starting new round with X = {0} and Y = {1}\",\n\t\t\t\t\t\t\t\t\t\t(null == getHead(_current) ? \"null\" : Component.printURI(getHead(_current).getHash())),\n\t\t\t\t\t\t\t\t\t\tComponent.printURI(getHead(_next).getHash()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Fall through\n\t\t\t\tcase PRELOAD:\t// Need to load data for the compare\n\t\t\t\t\tif (null == getHead(_next)) {\n\t\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (doPreload(getHead(_next))) {\n\t\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchangeState(SyncCompareState.COMPARE);\n\t\t\t\t\t// Fall through\n\t\t\t\tcase COMPARE:\t// We are currently in the process of comparing\n\t\t\t\t\tdoComparison();\n\t\t\t\t\tif (getState() == SyncCompareState.COMPARE) {\n\t\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DONE:\t// Compare is done. Start over again if we have pending data\n\t\t\t\t\t\t\t// for another compare\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (_pendingEntries.size() > 0) {\n\t\t\t\t\t\t\tchangeState(SyncCompareState.INIT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\tif (!keepComparing) {\n\t\t\t\t\t\tif (_needToCompare) {\n\t\t\t\t\t\t\tkeepComparing = true;\n\t\t\t\t\t\t\t_needToCompare = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t_comparing = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (keepComparing);\n\t\t\t_compareSemaphore.release();\n\t\t} catch (Exception ex) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, ex);} \t\n\t\t  catch (Error er) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, er);} \n\t}","id":47451,"modified_method":"/**\n\t * Separate thread for running comparisons. We run until we can't do anything\n\t * anymore, then rely on \"kickCompare\" to restart the thread. It uses a state\n\t * machine to figure out where it left off and where to start back in again.\n\t */\n\tpublic void run() {\n\t\t_compareSemaphore.acquireUninterruptibly();\n\t\tboolean keepComparing = true;\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tswitch (getState()) {\n\t\t\t\tcase INIT:\t\t// Starting a new compare\n\t\t\t\t\tnextRound();\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tbyte[] data = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tdata = getPendingContent();\n\t\t\t\t\t\t\tif (null != data) {\n\t\t\t\t\t\t\t\tSyncNodeComposite snc = new SyncNodeComposite();\n\t\t\t\t\t\t\t\tsnc.decode(data);\n\t\t\t\t\t\t\t\tSyncTreeEntry ste = _pbsm.addHash(snc.getHash());\n\t\t\t\t\t\t\t\tste.setNode(snc);\n\t\t\t\t\t\t\t\tif (null != _currentRoot && _currentRoot.getHash().length == 0) {\n\t\t\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\t\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Starting for items after {0}\", Component.printURI(ste.getHash()));\n\t\t\t\t\t\t\t\t\t_currentRoot = ste;\n\t\t\t\t\t\t\t\t\tnextRound();\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\taddPending(ste);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (null != data);\n\t\t\t\t\t\tSyncTreeEntry ste = getPending();\n\t\t\t\t\t\tif (null != ste) {\n\t\t\t\t\t\t\tste.setPos(0);\n\t\t\t\t\t\t\tpush(ste, _next);\n\t\t\t\t\t\t\t_currentRoot = ste;\n\t\t\t\t\t\t\tchangeState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (getState() == SyncCompareState.INIT) {\n\t\t\t\t\t\t\tchangeState(SyncCompareState.DONE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Starting new round with X = {0} and Y = {1}\",\n\t\t\t\t\t\t\t\t\t\t(null == getHead(_current) ? \"null\" : Component.printURI(getHead(_current).getHash())),\n\t\t\t\t\t\t\t\t\t\tComponent.printURI(getHead(_next).getHash()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Fall through\n\t\t\t\tcase PRELOAD:\t// Need to load data for the compare\n\t\t\t\t\tif (null == getHead(_next)) {\n\t\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (doPreload(getHead(_next))) {\n\t\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchangeState(SyncCompareState.COMPARE);\n\t\t\t\t\t// Fall through\n\t\t\t\tcase COMPARE:\t// We are currently in the process of comparing\n\t\t\t\t\tdoComparison();\n\t\t\t\t\tif (getState() == SyncCompareState.COMPARE) {\n\t\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DONE:\t// Compare is done. Start over again if we have pending data\n\t\t\t\t\t\t\t// for another compare\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (_pendingEntries.size() > 0) {\n\t\t\t\t\t\t\tchangeState(SyncCompareState.INIT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tkeepComparing = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\tif (!keepComparing) {\n\t\t\t\t\t\tif (_needToCompare) {\n\t\t\t\t\t\t\tkeepComparing = true;\n\t\t\t\t\t\t\t_needToCompare = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t_comparing = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (keepComparing);\n\t\t\t_compareSemaphore.release();\n\t\t} catch (Exception ex) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, ex);} \t\n\t\t  catch (Error er) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, er);} \n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Add new data into the system - either a hash which must be looked up or node\n\t * data which can be directly decoded. These will be used to start a new hash tree\n\t * for the next compare when the current one has completed.\n\t * \n\t * These will normally be called by handlers in ProtocolBasedSyncMonitor so\n\t * it is therefore handler code (so we should not decode anything here). \n\t * They must be called locked\n\t *\n\t * @param ste entry for new hash\n\t * @return\n\t */\n\tpublic boolean addPending(SyncTreeEntry ste) {\n\t\tfor (SyncTreeEntry tste : _pendingEntries) {\n\t\t\tif (ste.equals(tste)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (SyncTreeEntry tste: _next) {\n\t\t\tif (ste.equals(tste)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t_pendingEntries.add(ste);\n\t\treturn true;\n\t}","id":47452,"modified_method":"/**\n\t * Add new data into the system - either a hash which must be looked up or node\n\t * data which can be directly decoded. These will be used to start a new hash tree\n\t * for the next compare when the current one has completed.\n\t * \n\t * These will normally be called by handlers in ProtocolBasedSyncMonitor so\n\t * it is therefore handler code (so we should not decode anything here). \n\t * They must be called locked\n\t *\n\t * @param ste entry for new hash\n\t * @return\n\t */\n\tpublic boolean addPending(SyncTreeEntry ste) {\n\t\tsynchronized (this) {\n\t\t\tfor (SyncTreeEntry tste : _pendingEntries) {\n\t\t\t\tif (ste.equals(tste)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (SyncTreeEntry tste: _next) {\n\t\t\t\tif (ste.equals(tste)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_pendingEntries.add(ste);\n\t\t\treturn true;\n\t\t}\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * This is the critical routine which actually does the comparison. It continues\n\t * the compare as long as it can - either until completion or until it can't continue\n\t * due to missing information. A callback is generated for any node which hasn't been\n\t * seen before. Completed hashes on the Y side are marked \"covered\".\n\t * \n\t * @throws SyncException\n\t */\n\tprivate void doComparison() throws SyncException {\n\t\tSyncTreeEntry srtY = null;\n\t\tSyncTreeEntry srtX = null;\n\t\t\n\t\tsynchronized (this) {\n\t\t\tsrtY = getHead(_next);\n\t\t\tsrtX = getHead(_current);\n\t\t}\n\t\twhile (null != srtY) {\n\t\t\tSyncNodeComposite sncX = null;\n\t\t\tSyncNodeComposite sncY = null;\n\t\t\tSyncNodeComposite.SyncNodeElement sneX = null;\n\t\t\tSyncNodeComposite.SyncNodeElement sneY = null;\n\t\t\tsynchronized (this) {\n\t\t\t\t// Get the current X and Y entries for comparison\n\t\t\t\t// If we have no Y entry we are done. If we have just completed\n\t\t\t\t// an entire Y hash, mark it covered.\n\t\t\t\twhile (null != srtY && (srtY.lastPos() || srtY.isCovered())) {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\tif (srtY.isCovered())\n\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Skipping covered entry {0}\", Component.printURI(srtY.getHash()));\n\t\t\t\t\t}\n\t\t\t\t\tsrtY.setCovered(true);\n\t\t\t\t\tpop(_next);\n\t\t\t\t\tsrtY = getHead(_next);\n\t\t\t\t}\n\t\t\t\tif (null == srtY) {\n\t\t\t\t\tbreak;  // we're done\n\t\t\t\t}\t\t\n\t\t\t\tsncY = srtY.getNodeX(_decoder);\n\t\t\t\tif (null != sncY) {\n\t\t\t\t\tsneY = srtY.getCurrentElement();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (null != srtX && srtX.lastPos()) {\n\t\t\t\t\tpop(_current);\n\t\t\t\t\tsrtX = getHead(_current);\n\t\t\t\t}\n\t\t\t\tif (null != srtX) {\n\t\t\t\t\tsncX = srtX.getNodeX(_decoder);\n\t\t\t\t\tif (null != sncX) {\n\t\t\t\t\t\tsneX = srtX.getCurrentElement();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (null == sneX && null != sneY) {\n\t\t\t\t// We only have a Y tree so we will output all LEAF names that we see\t\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST))\n\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Y hash only for {0}, type is {1}\", Component.printURI(srtY.getHash()), sneY.getType());\n\t\t\t\tswitch (sneY.getType()) {\n\t\t\t\tcase LEAF:\n\t\t\t\t\tdoCallback(sneY);\n\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\tbreak;\n\t\t\t\tcase HASH:\n\t\t\t\t\t// The entry is a hash \n\t\t\t\t\tSyncTreeEntry entry = handleHashNode(sneY);\n\t\t\t\t\tif (null != entry) {\n\t\t\t\t\t\tentry.setPos(0);\n\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\tpush(entry, _next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\tsrtY = entry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (null == sneY) {\n\t\t\t\t// This shouldn't happen often because we should have already preloaded the node\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINE))\n\t\t\t\t\tLog.fine(Log.FAC_SYNC, \"No data for {0}, pos is {1}\", Component.printURI(srtY.getHash()), srtY.getPos());\n\t\t\t\trequestNode(srtY.getHash());\n\t\t\t\treturn;\n\t\t\t} else if (null != sneX) {\n\t\t\t\t// We have both X and Y entries. Compare is different depending on what type the entries are\n\t\t\t\tSyncNodeType typeX = sneX.getType();\n\t\t\t\tSyncNodeType typeY = sneY.getType();\n\t\t\t\tif (typeY == SyncNodeType.HASH) {\n\t\t\t\t\tSyncTreeEntry entryY = _pbsm.getHash(sneY.getData());\n\t\t\t\t\tif (null != entryY && entryY.isCovered()) {\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST))\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Skipping covered subentry {0}\", Component.printURI(entryY.getHash()));\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t    if (typeX == SyncNodeType.HASH) {\n\t\t\t\t\t\t// Both nodes\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare NODE {0} to NODE {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"pos X is {0}, pos Y is {1}\", srtX.getPos(), srtY.getPos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentryY = handleHashNode(sneY);\n\t\t\t\t\t\tif (null != entryY) {\n\t\t\t\t\t\t\tentryY.setPos(0);\n\t\t\t\t\t\t\tSyncTreeEntry entryX = handleHashNode(sneX);\n\t\t\t\t\t\t\tif (null != entryX) {\n\t\t\t\t\t\t\t\tentryX.setPos(0);\n\t\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpush(entryY, _next);\n\t\t\t\t\t\t\t\t\tpush(entryX, _current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsrtX = entryX;\n\t\t\t\t\t\t\t\tsrtY = entryY;\n\t\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Pushing X entry {0} and Y entry {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn;\n\t\t\t\t    } else {\n\t\t\t\t\t\t// X is leaf Y is Node\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare LEAF {0} to NODE {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"minname is {0}, maxname is {1}, X name is {2}, pos X is {3}, pos Y is {4}\", SegmentationProfile.getSegmentNumber(sncY.getMinName().getName().parent()), \n\t\t\t\t\t\t\t\t\tSegmentationProfile.getSegmentNumber(sncY.getMaxName().getName().parent()), SegmentationProfile.getSegmentNumber(sneX.getName().parent()), srtX.getPos(), srtY.getPos());\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"minname (expanded) is {0}, maxname (expanded) is {1}\", sncY.getMinName().getName(), sncY.getMaxName().getName());\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"sneX (expanded) is {0}, comp is {1}\", sneX.getName(), sneX.getName().compareTo(sncY.getMinName().getName()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sneX.getName().compareTo(sncY.getMinName().getName()) < 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSyncTreeEntry entry = handleHashNode(sneY);\n\t\t\t\t\t\t\tif (null != entry) {\n\t\t\t\t\t\t\t\tentry.setPos(0);\n\t\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpush(entry, _next);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsrtY = entry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t\tif (typeX == SyncNodeType.HASH) {\n\t\t\t\t\t\t// X is node Y is leaf\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare NODE {0} to LEAF {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"minname is {0}, maxname is {1}, pos X is {2}, pos Y is {3}\", SegmentationProfile.getSegmentNumber(sncX.getMinName().getName().parent()), \n\t\t\t\t\t\t\t\t\tSegmentationProfile.getSegmentNumber(sncX.getMaxName().getName().parent()), srtX.getPos(), srtY.getPos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint resMin = sneY.getName().compareTo(sncX.getMinName().getName());\n\t\t\t\t\t\tint resMax = sneY.getName().compareTo(sncX.getMaxName().getName());\n\t\t\t\t\t\tif (resMin < 0) {\n\t\t\t\t\t\t\tdoCallback(sneY);\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else if (resMin == 0) {\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else if (resMax > 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t} else if (resMax < 0) {\n\t\t\t\t\t\t\tSyncTreeEntry entry = handleHashNode(sneX);\n\t\t\t\t\t\t\tif (null != entry) {\n\t\t\t\t\t\t\t\tentry.setPos(0);\n\t\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpush(entry, _current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsrtX = entry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (resMax == 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new SyncException(\"Bogus comparison\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\t// Both leaves\n\t\t\t\t\t\tint comp = sneX.getName().compareTo(sneY.getName());\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare LEAF {0} to LEAF {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"name X is {0}, pos X is {1}, name Y is {2}, pos Y is {3} comp is {4}\", SegmentationProfile.getSegmentNumber(sneX.getName().parent()), \n\t\t\t\t\t\t\t\t\tsrtX.getPos(), SegmentationProfile.getSegmentNumber(sneY.getName().parent()), srtY.getPos(), comp);\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"name X (expanded) is {0}, name Y (expanded) is {1}\", sneX.getName(), sneY.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (srtX.getPos() == 0) {\n\t\t\t\t\t\t\t// If the highest node in X is before the lowest node in Y no need to go through\n\t\t\t\t\t\t\t// everything in X\n\t\t\t\t\t\t\tint comp2 = sncX.getMaxName().getName().compareTo(sncY.getMinName().getName());\n\t\t\t\t\t\t\tif (comp2 < 0) {\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpop(_current);\n\t\t\t\t\t\t\t\t\tsrtX = getHead(_current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (null != srtX) {\n\t\t\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Shortcut - popping X back to {0}, pos {1}\", Component.printURI(srtX.getHash()), srtX.getPos());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\t// Don't inc X - should have been pre-incremented\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (comp == 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else if (comp < 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdoCallback(sneY);\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsynchronized (this) {\n\t\t\tif (_state == SyncCompareState.COMPARE)\n\t\t\t\t_state = SyncCompareState.DONE;\n\t\t}\n\t}","id":47453,"modified_method":"/**\n\t * This is the critical routine which actually does the comparison. It continues\n\t * the compare as long as it can - either until completion or until it can't continue\n\t * due to missing information. A callback is generated for any node which hasn't been\n\t * seen before. Completed hashes on the Y side are marked \"covered\".\n\t * \n\t * @throws SyncException\n\t */\n\tprivate void doComparison() throws SyncException {\n\t\tSyncTreeEntry srtY = null;\n\t\tSyncTreeEntry srtX = null;\n\t\t\n\t\tsynchronized (this) {\n\t\t\tsrtY = getHead(_next);\n\t\t\tsrtX = getHead(_current);\n\t\t}\n\n\t\twhile (null != srtY) {\n\t\t\tSyncNodeComposite sncX = null;\n\t\t\tSyncNodeComposite sncY = null;\n\t\t\tSyncNodeComposite.SyncNodeElement sneX = null;\n\t\t\tSyncNodeComposite.SyncNodeElement sneY = null;\n\t\t\tsynchronized (this) {\n\t\t\t\t// Get the current X and Y entries for comparison\n\t\t\t\t// If we have no Y entry we are done. If we have just completed\n\t\t\t\t// an entire Y hash, mark it covered.\n\t\t\t\twhile (null != srtY && (srtY.lastPos() || srtY.isCovered())) {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\tif (srtY.isCovered())\n\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Skipping covered entry {0}\", Component.printURI(srtY.getHash()));\n\t\t\t\t\t}\n\t\t\t\t\tsrtY.setCovered(true);\n\t\t\t\t\tpop(_next);\n\t\t\t\t\tsrtY = getHead(_next);\n\t\t\t\t}\n\t\t\t\tif (null == srtY) {\n\t\t\t\t\tbreak;  // we're done\n\t\t\t\t}\t\t\n\t\t\t\tsncY = srtY.getNodeX(_decoder);\n\t\t\t\tif (null != sncY) {\n\t\t\t\t\tsneY = srtY.getCurrentElement();\n\t\t\t\t}\n\t\t\t\tif (null == sneY) {\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINE))\n\t\t\t\t\t\tLog.fine(Log.FAC_SYNC, \"No data for Y: {0}, pos is {1}\", Component.printURI(srtY.getHash()), srtY.getPos());\n\t\t\t\t\trequestNode(srtY.getHash());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (null != srtX && srtX.lastPos()) {\n\t\t\t\t\tpop(_current);\n\t\t\t\t\tsrtX = getHead(_current);\n\t\t\t\t}\n\t\t\t\tif (null != srtX) {\n\t\t\t\t\tsncX = srtX.getNodeX(_decoder);\n\t\t\t\t\tif (null != sncX) {\n\t\t\t\t\t\tsneX = srtX.getCurrentElement();\n\t\t\t\t\t}\n\t\t\t\t\tif (null == sneX) {\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINE))\n\t\t\t\t\t\t\tLog.fine(Log.FAC_SYNC, \"No data for X: {0}, pos is {1}\", Component.printURI(srtY.getHash()), srtY.getPos());\n\t\t\t\t\t\trequestNode(srtX.getHash());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (null == sneX) {\n\t\t\t\t// We only have a Y tree so we will output all LEAF names that we see\t\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST))\n\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Y hash only for {0}, type is {1}\", Component.printURI(srtY.getHash()), sneY.getType());\n\t\t\t\tswitch (sneY.getType()) {\n\t\t\t\tcase LEAF:\n\t\t\t\t\tdoCallback(sneY);\n\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\tbreak;\n\t\t\t\tcase HASH:\n\t\t\t\t\t// The entry is a hash \n\t\t\t\t\tSyncTreeEntry entry = handleHashNode(sneY);\n\t\t\t\t\tif (null != entry) {\n\t\t\t\t\t\tentry.setPos(0);\n\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\tpush(entry, _next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\tsrtY = entry;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We have both X and Y entries. Compare is different depending on what type the entries are\n\t\t\t\tSyncNodeType typeX = sneX.getType();\n\t\t\t\tSyncNodeType typeY = sneY.getType();\n\t\t\t\tif (typeY == SyncNodeType.HASH) {\n\t\t\t\t\tSyncTreeEntry entryY = _pbsm.getHash(sneY.getData());\n\t\t\t\t\tif (null != entryY && entryY.isCovered()) {\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST))\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Skipping covered subentry {0}\", Component.printURI(entryY.getHash()));\n\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t    if (typeX == SyncNodeType.HASH) {\n\t\t\t\t\t\t// Both nodes\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare NODE {0} to NODE {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"pos X is {0}, pos Y is {1}\", srtX.getPos(), srtY.getPos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentryY = handleHashNode(sneY);\n\t\t\t\t\t\tif (null != entryY) {\n\t\t\t\t\t\t\tentryY.setPos(0);\n\t\t\t\t\t\t\tSyncTreeEntry entryX = handleHashNode(sneX);\n\t\t\t\t\t\t\tif (null != entryX) {\n\t\t\t\t\t\t\t\tentryX.setPos(0);\n\t\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpush(entryY, _next);\n\t\t\t\t\t\t\t\t\tpush(entryX, _current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsrtX = entryX;\n\t\t\t\t\t\t\t\tsrtY = entryY;\n\t\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Pushing X entry {0} and Y entry {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn;\n\t\t\t\t    } else {\n\t\t\t\t\t\t// X is leaf Y is Node\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare LEAF {0} to NODE {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"minname is {0}, maxname is {1}, X name is {2}, pos X is {3}, pos Y is {4}\", SegmentationProfile.getSegmentNumber(sncY.getMinName().getName().parent()), \n\t\t\t\t\t\t\t\t\tSegmentationProfile.getSegmentNumber(sncY.getMaxName().getName().parent()), SegmentationProfile.getSegmentNumber(sneX.getName().parent()), srtX.getPos(), srtY.getPos());\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"minname (expanded) is {0}, maxname (expanded) is {1}\", sncY.getMinName().getName(), sncY.getMaxName().getName());\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"sneX (expanded) is {0}, comp is {1}\", sneX.getName(), sneX.getName().compareTo(sncY.getMinName().getName()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sneX.getName().compareTo(sncY.getMinName().getName()) < 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSyncTreeEntry entry = handleHashNode(sneY);\n\t\t\t\t\t\t\tif (null != entry) {\n\t\t\t\t\t\t\t\tentry.setPos(0);\n\t\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpush(entry, _next);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsrtY = entry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t\tif (typeX == SyncNodeType.HASH) {\n\t\t\t\t\t\t// X is node Y is leaf\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare NODE {0} to LEAF {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"minname is {0}, maxname is {1}, pos X is {2}, pos Y is {3}\", SegmentationProfile.getSegmentNumber(sncX.getMinName().getName().parent()), \n\t\t\t\t\t\t\t\t\tSegmentationProfile.getSegmentNumber(sncX.getMaxName().getName().parent()), srtX.getPos(), srtY.getPos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint resMin = sneY.getName().compareTo(sncX.getMinName().getName());\n\t\t\t\t\t\tint resMax = sneY.getName().compareTo(sncX.getMaxName().getName());\n\t\t\t\t\t\tif (resMin < 0) {\n\t\t\t\t\t\t\tdoCallback(sneY);\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else if (resMin == 0) {\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else if (resMax > 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t} else if (resMax < 0) {\n\t\t\t\t\t\t\tSyncTreeEntry entry = handleHashNode(sneX);\n\t\t\t\t\t\t\tif (null != entry) {\n\t\t\t\t\t\t\t\tentry.setPos(0);\n\t\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpush(entry, _current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsrtX = entry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (resMax == 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new SyncException(\"Bogus comparison\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\t// Both leaves\n\t\t\t\t\t\tint comp = sneX.getName().compareTo(sneY.getName());\n\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Compare LEAF {0} to LEAF {1}\", Component.printURI(srtX.getHash()), Component.printURI(srtY.getHash()));\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"name X is {0}, pos X is {1}, name Y is {2}, pos Y is {3} comp is {4}\", SegmentationProfile.getSegmentNumber(sneX.getName().parent()), \n\t\t\t\t\t\t\t\t\tsrtX.getPos(), SegmentationProfile.getSegmentNumber(sneY.getName().parent()), srtY.getPos(), comp);\n\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"name X (expanded) is {0}, name Y (expanded) is {1}\", sneX.getName(), sneY.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (srtX.getPos() == 0) {\n\t\t\t\t\t\t\t// If the highest node in X is before the lowest node in Y no need to go through\n\t\t\t\t\t\t\t// everything in X\n\t\t\t\t\t\t\tint comp2 = sncX.getMaxName().getName().compareTo(sncY.getMinName().getName());\n\t\t\t\t\t\t\tif (comp2 < 0) {\n\t\t\t\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\t\t\t\tpop(_current);\n\t\t\t\t\t\t\t\t\tsrtX = getHead(_current);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (null != srtX) {\n\t\t\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\t\t\t\t\t\t\tLog.finest(Log.FAC_SYNC, \"Shortcut - popping X back to {0}, pos {1}\", Component.printURI(srtX.getHash()), srtX.getPos());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\t// Don't inc X - should have been pre-incremented\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (comp == 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t} else if (comp < 0) {\n\t\t\t\t\t\t\tsrtX.incPos();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdoCallback(sneY);\n\t\t\t\t\t\t\tsrtY.incPos();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsynchronized (this) {\n\t\t\tif (_state == SyncCompareState.COMPARE)\n\t\t\t\t_state = SyncCompareState.DONE;\n\t\t}\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SyncTreeEntry getPending() {\n\t\tSyncTreeEntry best = null;\n\t\tfor (SyncTreeEntry ste : _pendingEntries) {\n\t\t\tif (!ste.isCovered()) {\n\t\t\t\tif (best == null)\n\t\t\t\t\tbest = ste;\n\t\t\t\telse {\n\t\t\t\t\tif (DataUtils.compare(ste.getHash(), best.getHash()) > 0) {\n\t\t\t\t\t\tbest = ste;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}","id":47454,"modified_method":"protected SyncTreeEntry getPending() {\n\t\tSyncTreeEntry best = null;\n\t\tArrayList<SyncTreeEntry> removes = new ArrayList<SyncTreeEntry>();\n\t\tsynchronized (this) {\n\t\t  outerLoop:\n\t\t\tfor (SyncTreeEntry ste : _pendingEntries) {\n\t\t\t\tfor (SyncTreeEntry tste : _current) {\n\t\t\t\t\tif (ste.equals(tste)) {\n\t\t\t\t\t\tremoves.add(tste);\n\t\t\t\t\t\tcontinue outerLoop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ste.isCovered()) {\n\t\t\t\t\tif (best == null)\n\t\t\t\t\t\tbest = ste;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (DataUtils.compare(ste.getHash(), best.getHash()) > 0) {\n\t\t\t\t\t\t\tbest = ste;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tremoves.add(ste);\n\t\t\t}\n\t\t\tfor (SyncTreeEntry ste : removes) {\n\t\t\t\t_pendingEntries.remove(ste);\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void setNode(SyncNodeComposite snc) {\n\t\t_nodeX = snc;\n\t}","id":47455,"modified_method":"public void setNode(SyncNodeComposite snc) {\n\t\t_nodeX = snc;\n\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\tdecodeLogging();\n\t\t}\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public SyncNodeComposite getNodeX(XMLDecoder decoder) {\n\t\tif (null == _nodeX && null != _rawContent) {\n\t\t\t_nodeX = new SyncNodeComposite();\n\t\t\ttry {\n\t\t\t\t_nodeX.decode(_rawContent, decoder);\n\t\t\t} catch (ContentDecodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\t_nodeX = null;\n\t\t\t\t_rawContent = null;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t_rawContent = null;\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\tLog.finest(Log.FAC_SYNC, \"decode node for {0} depth = {1} refs = {2}, position = {3}\", Component.printURI(_nodeX._longhash), \n\t\t\t\t\t\t_nodeX._treeDepth, _nodeX.getRefs().size(), _position);\n\t\t\t\tLog.finest(Log.FAC_SYNC, \"min is {0}, max is {1}, expanded min is {2}, expanded max is {3}\", \n\t\t\t\t\t\tSegmentationProfile.getSegmentNumber(_nodeX._minName.getName().parent()), \n\t\t\t\t\t\tSegmentationProfile.getSegmentNumber(_nodeX._maxName.getName().parent()),\n\t\t\t\t\t\t_nodeX._minName.getName(), _nodeX._maxName.getName());\n\t\t\t}\n\t\t}\n\t\treturn _nodeX;\n\t}","id":47456,"modified_method":"public SyncNodeComposite getNodeX(XMLDecoder decoder) {\n\t\tif (null == _nodeX && null != _rawContent) {\n\t\t\t_nodeX = new SyncNodeComposite();\n\t\t\ttry {\n\t\t\t\t_nodeX.decode(_rawContent, decoder);\n\t\t\t} catch (ContentDecodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\t_nodeX = null;\n\t\t\t\t_rawContent = null;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t_rawContent = null;\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINEST)) {\n\t\t\t\tdecodeLogging();\n\t\t\t}\n\t\t}\n\t\treturn _nodeX;\n\t}","commit_id":"df4dd1bcbfb2b05cbe23d5aaf75333bf18d8bc6f","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@NotNull\n  public static SProperty getProperty(SPropertyId id, String propName) {\n    SConceptId cid = id.getConceptId();\n    UUID langId = cid.getLanguageId().getIdValue();\n    return getProperty(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), cid.getIdValue(), id.getIdValue(), propName);\n  }","id":47457,"modified_method":"@NotNull\n  public static SProperty getProperty(SPropertyId id, String propName) {\n    SConceptId cid = id.getConceptId();\n    SLanguageId langId = cid.getLanguageId();\n    return getProperty(langId.getHighBits(), langId.getLowBits(), cid.getIdValue(), id.getIdValue(), propName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SConcept getConcept(SConceptId id, String conceptName) {\n    UUID langId = id.getLanguageId().getIdValue();\n    return getConcept(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), id.getIdValue(), conceptName);\n  }","id":47458,"modified_method":"@NotNull\n  public static SConcept getConcept(SConceptId id, String conceptName) {\n    SLanguageId langId = id.getLanguageId();\n    return getConcept(langId.getHighBits(), langId.getLowBits(), id.getIdValue(), conceptName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SProperty getProperty(@NotNull SAbstractConcept concept, long prop, String propName) {\n    final SConceptId cid = MetaIdHelper.getConcept(concept);\n    UUID langId = cid.getLanguageId().getIdValue();\n    return getProperty(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), cid.getIdValue(), prop, propName);\n  }","id":47459,"modified_method":"public static SProperty getProperty(@NotNull SAbstractConcept concept, long prop, String propName) {\n    final SConceptId cid = MetaIdHelper.getConcept(concept);\n    SLanguageId langId = cid.getLanguageId();\n    return getProperty(langId.getHighBits(), langId.getLowBits(), cid.getIdValue(), prop, propName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SInterfaceConcept getInterfaceConcept(@NotNull SLanguage language, long concept, @NotNull String shortConceptName) {\n    final UUID langId = MetaIdHelper.getLanguage(language).getIdValue();\n    return getInterfaceConcept(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), concept, NameUtil.conceptFQNameFromNamespaceAndShortName(language.getQualifiedName(), shortConceptName));\n  }","id":47460,"modified_method":"public static SInterfaceConcept getInterfaceConcept(@NotNull SLanguage language, long concept, @NotNull String shortConceptName) {\n    final SLanguageId langId = MetaIdHelper.getLanguage(language);\n    return getInterfaceConcept(langId.getHighBits(), langId.getLowBits(), concept, NameUtil.conceptFQNameFromNamespaceAndShortName(language.getQualifiedName(), shortConceptName));\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SLanguage getLanguage(long uuidHigh, long uuidLow, String langName) {\n    return getLanguage(MetaIdFactory.langId(uuidHigh, uuidLow), langName);\n  }","id":47461,"modified_method":"@NotNull\n  public static SLanguage getLanguage(long uuidHigh, long uuidLow, String langName) {\n    List<SLanguageAdapterById> list = getBucketList(ourLanguages, uuidHigh * 17 + uuidLow);\n    //noinspection SynchronizationOnLocalVariableOrMethodParameter\n    synchronized (list) {\n      for (int i = 0, x = list.size(); i < x; i++) {\n        SLanguageAdapterById rv = list.get(i);\n        SLanguageId id = rv.getId();\n        if (uuidHigh == id.getHighBits() && uuidLow == id.getLowBits()) {\n          return rv;\n        }\n      }\n      SLanguageAdapterById rv = new SLanguageAdapterById(MetaIdFactory.langId(uuidHigh, uuidLow), langName);\n      list.add(rv);\n      return rv;\n    }\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SReferenceLink getReferenceLink(SReferenceLinkId id, String refName) {\n    SConceptId cid = id.getConceptId();\n    UUID langId = cid.getLanguageId().getIdValue();\n    return getReferenceLink(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), cid.getIdValue(), id.getIdValue(), refName);\n  }","id":47462,"modified_method":"@NotNull\n  public static SReferenceLink getReferenceLink(SReferenceLinkId id, String refName) {\n    SConceptId cid = id.getConceptId();\n    SLanguageId langId = cid.getLanguageId();\n    return getReferenceLink(langId.getHighBits(), langId.getLowBits(), cid.getIdValue(), id.getIdValue(), refName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SConcept getConcept(@NotNull SLanguage language, long concept, @NotNull String shortConceptName) {\n    final UUID langId = MetaIdHelper.getLanguage(language).getIdValue();\n    return getConcept(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), concept, NameUtil.conceptFQNameFromNamespaceAndShortName(language.getQualifiedName(), shortConceptName));\n  }","id":47463,"modified_method":"public static SConcept getConcept(@NotNull SLanguage language, long concept, @NotNull String shortConceptName) {\n    final SLanguageId langId = MetaIdHelper.getLanguage(language);\n    return getConcept(langId.getHighBits(), langId.getLowBits(), concept, NameUtil.conceptFQNameFromNamespaceAndShortName(language.getQualifiedName(), shortConceptName));\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName) {\n    SLanguageAdapterById l = new SLanguageAdapterById(id, langName);\n    LangKey p = new LangKey(id, langName);\n    SLanguage result = ourLanguageIds.putIfAbsent(p, l);\n    return result != null ? result : l;\n  }","id":47464,"modified_method":"@NotNull\n  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName) {\n    // FIXME change templates to invoke getLanguage(long,long,string) instead\n    return getLanguage(id.getHighBits(), id.getLowBits(), langName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SContainmentLink getContainmentLink(SContainmentLinkId id, String linkName) {\n    SConceptId cid = id.getConceptId();\n    UUID langId = cid.getLanguageId().getIdValue();\n    return getContainmentLink(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), cid.getIdValue(), id.getIdValue(), linkName);\n  }","id":47465,"modified_method":"@NotNull\n  public static SContainmentLink getContainmentLink(SContainmentLinkId id, String linkName) {\n    SConceptId cid = id.getConceptId();\n    SLanguageId langId = cid.getLanguageId();\n    return getContainmentLink(langId.getHighBits(), langId.getLowBits(), cid.getIdValue(), id.getIdValue(), linkName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SContainmentLink getContainmentLink(@NotNull SAbstractConcept concept, long link, String linkName) {\n    final SConceptId cid = MetaIdHelper.getConcept(concept);\n    UUID langId = cid.getLanguageId().getIdValue();\n    return getContainmentLink(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), cid.getIdValue(), link, linkName);\n  }","id":47466,"modified_method":"public static SContainmentLink getContainmentLink(@NotNull SAbstractConcept concept, long link, String linkName) {\n    final SConceptId cid = MetaIdHelper.getConcept(concept);\n      SLanguageId langId = cid.getLanguageId();\n    return getContainmentLink(langId.getHighBits(), langId.getLowBits(), cid.getIdValue(), link, linkName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static SInterfaceConcept getInterfaceConcept(SConceptId id, String conceptName) {\n    UUID langId = id.getLanguageId().getIdValue(); // FIXME SLanguageId shall get accessors to avoid excessive wrap into UUID\n    return getInterfaceConcept(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), id.getIdValue(), conceptName);\n  }","id":47467,"modified_method":"@NotNull\n  public static SInterfaceConcept getInterfaceConcept(SConceptId id, String conceptName) {\n    SLanguageId langId = id.getLanguageId();\n    return getInterfaceConcept(langId.getHighBits(), langId.getLowBits(), id.getIdValue(), conceptName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SReferenceLink getReferenceLink(@NotNull SAbstractConcept concept, long link, String linkName) {\n    final SConceptId cid = MetaIdHelper.getConcept(concept);\n    UUID langId = cid.getLanguageId().getIdValue();\n    return getReferenceLink(langId.getMostSignificantBits(), langId.getLeastSignificantBits(), cid.getIdValue(), link, linkName);\n  }","id":47468,"modified_method":"public static SReferenceLink getReferenceLink(@NotNull SAbstractConcept concept, long link, String linkName) {\n    final SConceptId cid = MetaIdHelper.getConcept(concept);\n    SLanguageId langId = cid.getLanguageId();\n    return getReferenceLink(langId.getHighBits(), langId.getLowBits(), cid.getIdValue(), link, linkName);\n  }","commit_id":"88054d4b0c8a795be650a626d0d70e14aba7effb","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected void addTag(TagName tagName, String comment) {\n        /*\n         * The documentation for Lookup.lookupAll() explicitly says that the\n         * collection it returns may contain duplicates. Within this invocation\n         * of addTag(), we don't want to tag the same AbstractFile more than\n         * once, so we dedupe the AbstractFiles by stuffing them into a HashSet.\n         *\n         * We don't want VirtualFile and DerivedFile objects to be tagged.\n         */\n        final Collection<AbstractFile> selectedFiles = new HashSet<>();\n        selectedFiles.addAll(new HashSet<>(Utilities.actionsGlobalContext().lookupAll(FsContent.class)));\n        selectedFiles.addAll(new HashSet<>(Utilities.actionsGlobalContext().lookupAll(LayoutFile.class)));\n        selectedFiles.addAll(new HashSet<>(Utilities.actionsGlobalContext().lookupAll(LocalFile.class)));\n\n        new Thread(() -> {\n            for (AbstractFile file : selectedFiles) {\n                try {\n                    // Handle the special cases of current (\".\") and parent (\"..\") directory entries.\n                    if (file.getName().equals(\".\")) {\n                        Content parentFile = file.getParent();\n                        if (parentFile instanceof AbstractFile) {\n                            file = (AbstractFile) parentFile;\n                        } else {\n                            SwingUtilities.invokeLater(() -> {\n                                JOptionPane.showMessageDialog(null,\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.unableToTag.msg\",\n                                                parentFile.getName()),\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.cannotApplyTagErr\"),\n                                        JOptionPane.WARNING_MESSAGE);\n                            });\n                            continue;\n                        }\n                    } else if (file.getName().equals(\"..\")) {\n                        Content parentFile = file.getParent();\n                        if (parentFile instanceof AbstractFile) {\n                            parentFile = (AbstractFile) ((AbstractFile) parentFile).getParent();\n                            if (parentFile instanceof AbstractFile) {\n                                file = (AbstractFile) parentFile;\n                            } else {\n                                final Content parentFileCopy = parentFile;\n                                SwingUtilities.invokeLater(() -> {\n                                    JOptionPane.showMessageDialog(null,\n                                            NbBundle.getMessage(this.getClass(),\n                                                    \"AddContentTagAction.unableToTag.msg\",\n                                                    parentFileCopy.getName()),\n                                            NbBundle.getMessage(this.getClass(),\n                                                    \"AddContentTagAction.cannotApplyTagErr\"),\n                                            JOptionPane.WARNING_MESSAGE);\n                                });\n                                continue;\n                            }\n                        } else {\n                            final Content parentFileCopy = parentFile;\n                            SwingUtilities.invokeLater(() -> {\n                                JOptionPane.showMessageDialog(null,\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.unableToTag.msg\",\n                                                parentFileCopy.getName()),\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.cannotApplyTagErr\"),\n                                        JOptionPane.WARNING_MESSAGE);\n                            });\n                            continue;\n                        }\n                    }\n\n                    Case.getCurrentCase().getServices().getTagsManager().addContentTag(file, tagName, comment);\n                } catch (TskCoreException ex) {\n                    Logger.getLogger(AddContentTagAction.class.getName()).log(Level.SEVERE, \"Error tagging result\", ex); //NON-NLS\n                    AbstractFile fileCopy = file;\n                    SwingUtilities.invokeLater(() -> {\n                        JOptionPane.showMessageDialog(null,\n                                NbBundle.getMessage(this.getClass(),\n                                        \"AddContentTagAction.unableToTag.msg2\",\n                                        fileCopy.getName()),\n                                NbBundle.getMessage(this.getClass(), \"AddContentTagAction.taggingErr\"),\n                                JOptionPane.ERROR_MESSAGE);\n                    });\n                }\n            }\n        }).start();\n    }","id":47469,"modified_method":"@Override\n    protected void addTag(TagName tagName, String comment) {\n        /*\n         * The documentation for Lookup.lookupAll() explicitly says that the\n         * collection it returns may contain duplicates. Within this invocation\n         * of addTag(), we don't want to tag the same AbstractFile more than\n         * once, so we dedupe the AbstractFiles by stuffing them into a HashSet.\n         *\n         * We don't want VirtualFile and DerivedFile objects to be tagged.\n         */\n        final Collection<AbstractFile> selectedFiles = new HashSet<>();\n        selectedFiles.addAll(Utilities.actionsGlobalContext().lookupAll(FsContent.class));\n        selectedFiles.addAll(Utilities.actionsGlobalContext().lookupAll(LayoutFile.class));\n        selectedFiles.addAll(Utilities.actionsGlobalContext().lookupAll(LocalFile.class));\n\n        new Thread(() -> {\n            for (AbstractFile file : selectedFiles) {\n                try {\n                    // Handle the special cases of current (\".\") and parent (\"..\") directory entries.\n                    if (file.getName().equals(\".\")) {\n                        Content parentFile = file.getParent();\n                        if (parentFile instanceof AbstractFile) {\n                            file = (AbstractFile) parentFile;\n                        } else {\n                            SwingUtilities.invokeLater(() -> {\n                                JOptionPane.showMessageDialog(null,\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.unableToTag.msg\",\n                                                parentFile.getName()),\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.cannotApplyTagErr\"),\n                                        JOptionPane.WARNING_MESSAGE);\n                            });\n                            continue;\n                        }\n                    } else if (file.getName().equals(\"..\")) {\n                        Content parentFile = file.getParent();\n                        if (parentFile instanceof AbstractFile) {\n                            parentFile = (AbstractFile) ((AbstractFile) parentFile).getParent();\n                            if (parentFile instanceof AbstractFile) {\n                                file = (AbstractFile) parentFile;\n                            } else {\n                                final Content parentFileCopy = parentFile;\n                                SwingUtilities.invokeLater(() -> {\n                                    JOptionPane.showMessageDialog(null,\n                                            NbBundle.getMessage(this.getClass(),\n                                                    \"AddContentTagAction.unableToTag.msg\",\n                                                    parentFileCopy.getName()),\n                                            NbBundle.getMessage(this.getClass(),\n                                                    \"AddContentTagAction.cannotApplyTagErr\"),\n                                            JOptionPane.WARNING_MESSAGE);\n                                });\n                                continue;\n                            }\n                        } else {\n                            final Content parentFileCopy = parentFile;\n                            SwingUtilities.invokeLater(() -> {\n                                JOptionPane.showMessageDialog(null,\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.unableToTag.msg\",\n                                                parentFileCopy.getName()),\n                                        NbBundle.getMessage(this.getClass(),\n                                                \"AddContentTagAction.cannotApplyTagErr\"),\n                                        JOptionPane.WARNING_MESSAGE);\n                            });\n                            continue;\n                        }\n                    }\n\n                    Case.getCurrentCase().getServices().getTagsManager().addContentTag(file, tagName, comment);\n                } catch (TskCoreException ex) {\n                    Logger.getLogger(AddContentTagAction.class.getName()).log(Level.SEVERE, \"Error tagging result\", ex); //NON-NLS\n                    AbstractFile fileCopy = file;\n                    SwingUtilities.invokeLater(() -> {\n                        JOptionPane.showMessageDialog(null,\n                                NbBundle.getMessage(this.getClass(),\n                                        \"AddContentTagAction.unableToTag.msg2\",\n                                        fileCopy.getName()),\n                                NbBundle.getMessage(this.getClass(), \"AddContentTagAction.taggingErr\"),\n                                JOptionPane.ERROR_MESSAGE);\n                    });\n                }\n            }\n        }).start();\n    }","commit_id":"dfdc033a522f7f539bd38a7329f8c69a9bac871c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tagame exists but wasn't found\", ex);\n                }\n            } catch (NullPointerException | IllegalStateException ex) {\n                LOGGER.log(Level.SEVERE, \"Case was closed out from underneath\", ex); //NON-NLS\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","id":47470,"modified_method":"public TagName getTagName(String displayName) throws TskCoreException {\n        synchronized (autopsyTagsManagerLock) {\n            try {\n                for (TagName tn : autopsyTagsManager.getAllTagNames()) {\n                    if (displayName.equals(tn.getDisplayName())) {\n                        return tn;\n                    }\n                }\n                try {\n                    return autopsyTagsManager.addTagName(displayName);\n                } catch (TagsManager.TagNameAlreadyExistsException ex) {\n                    throw new TskCoreException(\"tag name exists but wasn't found\", ex);\n                }\n            } catch (NullPointerException | IllegalStateException ex) {\n                LOGGER.log(Level.SEVERE, \"Case was closed out from underneath\", ex); //NON-NLS\n                throw new TskCoreException(\"Case was closed out from underneath\", ex);\n            }\n        }\n    }","commit_id":"dfdc033a522f7f539bd38a7329f8c69a9bac871c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Constructor\n     *\n     * @param controller The TimeLineController for this topcomponent.\n     */\n    public TimeLineTopComponent(TimeLineController controller) {\n        initComponents();\n        associateLookup(ExplorerUtils.createLookup(em, getActionMap()));\n        setName(NbBundle.getMessage(TimeLineTopComponent.class, \"CTL_TimeLineTopComponent\"));\n        setToolTipText(NbBundle.getMessage(TimeLineTopComponent.class, \"HINT_TimeLineTopComponent\"));\n        setIcon(WindowManager.getDefault().getMainWindow().getIconImage()); //use the same icon as main application\n\n        this.controller = controller;\n\n        //create linked result and content views\n        contentViewerPanel = DataContentPanel.createInstance();\n        dataResultPanel = DataResultPanel.createInstanceUninitialized(\"\", \"\", Node.EMPTY, 0, contentViewerPanel);\n\n        //add them to bottom splitpane\n        horizontalSplitPane.setLeftComponent(dataResultPanel);\n        horizontalSplitPane.setRightComponent(contentViewerPanel);\n\n        dataResultPanel.open(); //get the explorermanager\n\n        Platform.runLater(this::initFXComponents);\n\n        //set up listeners \n        TimeLineController.getTimeZone().addListener(timeZone -> dataResultPanel.setPath(getResultViewerSummaryString()));\n        controller.getSelectedEventIDs().addListener(selectedEventsListener);\n\n        //Listen to ViewMode and adjust GUI componenets as needed.\n        controller.viewModeProperty().addListener(viewMode -> syncViewMode());\n        syncViewMode();\n    }","id":47471,"modified_method":"/**\n     * Constructor\n     *\n     * @param controller The TimeLineController for this topcomponent.\n     */\n    public TimeLineTopComponent(TimeLineController controller) {\n        initComponents();\n        associateLookup(ExplorerUtils.createLookup(em, getActionMap()));\n        setName(NbBundle.getMessage(TimeLineTopComponent.class, \"CTL_TimeLineTopComponent\"));\n        setToolTipText(NbBundle.getMessage(TimeLineTopComponent.class, \"HINT_TimeLineTopComponent\"));\n        setIcon(WindowManager.getDefault().getMainWindow().getIconImage()); //use the same icon as main application\n\n        getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, InputEvent.CTRL_MASK), \"addBookmarkTag\"); //NON-NLS\n        getActionMap().put(\"addBookmarkTag\", new BookmarkFileAction()); //NON-NLS\n\n        this.controller = controller;\n\n        //create linked result and content views\n        contentViewerPanel = DataContentPanel.createInstance();\n        dataResultPanel = DataResultPanel.createInstanceUninitialized(\"\", \"\", Node.EMPTY, 0, contentViewerPanel);\n\n        //add them to bottom splitpane\n        horizontalSplitPane.setLeftComponent(dataResultPanel);\n        horizontalSplitPane.setRightComponent(contentViewerPanel);\n\n        dataResultPanel.open(); //get the explorermanager\n\n        Platform.runLater(this::initFXComponents);\n\n        //set up listeners \n        TimeLineController.getTimeZone().addListener(timeZone -> dataResultPanel.setPath(getResultViewerSummaryString()));\n        controller.getSelectedEventIDs().addListener(selectedEventsListener);\n\n        //Listen to ViewMode and adjust GUI componenets as needed.\n        controller.viewModeProperty().addListener(viewMode -> syncViewMode());\n        syncViewMode();\n    }","commit_id":"dfdc033a522f7f539bd38a7329f8c69a9bac871c","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void setAll( long value )\n    {\n        for ( LongArray chunk : chunks )\n        {\n            chunk.setAll( value );\n        }\n        setAllValue = value;\n    }","id":47472,"modified_method":"@Override\n    public LongArray setAll( long value )\n    {\n        for ( LongArray chunk : chunks )\n        {\n            chunk.setAll( value );\n        }\n        setAllValue = value;\n        return this;\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void setAll( long value )\n    {\n        for ( long[] shard : shards )\n        {\n            Arrays.fill( shard, value );\n        }\n    }","id":47473,"modified_method":"@Override\n    public LongArray setAll( long value )\n    {\n        for ( long[] shard : shards )\n        {\n            Arrays.fill( shard, value );\n        }\n        return this;\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void setAll( int value )\n    {\n        long longValue = 0;\n        longValue = LONG_BITS.set( longValue, 0, value );\n        longValue = LONG_BITS.set( longValue, 1, value );\n        longs.setAll( longValue );\n    }","id":47474,"modified_method":"public IntArray setAll( int value )\n    {\n        long longValue = 0;\n        longValue = LONG_BITS.set( longValue, 0, value );\n        longValue = LONG_BITS.set( longValue, 1, value );\n        longs.setAll( longValue );\n        return this;\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public NodeLabelsCache( LongArrayFactory cacheFactory, int highLabelId, int chunkSize )\n    {\n        this.cache = cacheFactory.newDynamicLongArray( chunkSize );\n        this.spillOver = cacheFactory.newDynamicLongArray( chunkSize / 5 ); // expect way less of these\n        this.highLabelId = highLabelId;\n        this.bitsPerLabel = Integer.SIZE-numberOfLeadingZeros( highLabelId );\n\n        int worstCaseLongsNeeded = ((bitsPerLabel * (highLabelId+1 /*length slot*/)) - 1) / Long.SIZE + 1;\n        this.labelScratch = new long[worstCaseLongsNeeded];\n        this.labelBits = bitsFromLongs( labelScratch );\n    }","id":47475,"modified_method":"public NodeLabelsCache( LongArrayFactory cacheFactory, int highLabelId, int chunkSize )\n    {\n        this.cache = cacheFactory.newDynamicLongArray( chunkSize ).setAll( 0 );\n        this.spillOver = cacheFactory.newDynamicLongArray( chunkSize / 5 ).setAll( 0 ); // expect way less of these\n        this.bitsPerLabel = Integer.SIZE-numberOfLeadingZeros( highLabelId );\n\n        int worstCaseLongsNeeded = ((bitsPerLabel * (highLabelId+1 /*length slot*/)) - 1) / Long.SIZE + 1;\n        this.labelScratch = new long[worstCaseLongsNeeded];\n        this.labelBits = bitsFromLongs( labelScratch );\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Write labels for a node into {@code target}. If target isn't big enough it will grow.\n     * The target, intact or grown, will be returned.\n     */\n    public int[] get( long nodeId, int[] target )\n    {\n        // make this field available to our Bits instance, hackish? meh\n        fieldBits.clear( false );\n        fieldScratch[0] = cache.get( nodeId );\n        int length = fieldBits.getInt( bitsPerLabel );\n        int longsInUse = ((bitsPerLabel * (length+1))-1) / Long.SIZE + 1;\n        target = ensureCapacity( target, length );\n        if ( longsInUse == 1 )\n        {\n            decode( fieldBits, length, target );\n        }\n        else\n        {\n            // Read data from spill over cache into the label bits array for decoding\n            long spillOverIndex = fieldBits.getLong( Long.SIZE - bitsPerLabel );\n            labelBits.clear( false );\n            for ( int i = 0; i < longsInUse; i++ )\n            {\n                labelScratch[i] = spillOver.get( spillOverIndex + i );\n            }\n            labelBits.getInt( bitsPerLabel ); // first one ignored, since it's just the length\n            decode( labelBits, length, target );\n        }\n\n        return target;\n    }","id":47476,"modified_method":"/**\n     * Write labels for a node into {@code target}. If target isn't big enough it will grow.\n     * The target, intact or grown, will be returned.\n     */\n    public int[] get( long nodeId, int[] target )\n    {\n        // make this field available to our Bits instance, hackish? meh\n        fieldBits.clear( false );\n        fieldScratch[0] = cache.get( nodeId );\n        if ( fieldScratch[0] == 0 )\n        {   // Nothing here\n            target[0] = -1; // mark the end\n            return target;\n        }\n\n        int length = fieldBits.getInt( bitsPerLabel );\n        int longsInUse = ((bitsPerLabel * (length+1))-1) / Long.SIZE + 1;\n        target = ensureCapacity( target, length );\n        if ( longsInUse == 1 )\n        {\n            decode( fieldBits, length, target );\n        }\n        else\n        {\n            // Read data from spill over cache into the label bits array for decoding\n            long spillOverIndex = fieldBits.getLong( Long.SIZE - bitsPerLabel );\n            labelBits.clear( false );\n            for ( int i = 0; i < longsInUse; i++ )\n            {\n                labelScratch[i] = spillOver.get( spillOverIndex + i );\n            }\n            labelBits.getInt( bitsPerLabel ); // first one ignored, since it's just the length\n            decode( labelBits, length, target );\n        }\n\n        return target;\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldEndTargetArrayWithMinusOne() throws Exception\n    {\n        // GIVEN\n        NodeLabelsCache cache = new NodeLabelsCache( LongArrayFactory.AUTO, CHUNK_SIZE );\n        cache.put( 10, new long[] { 5, 6, 7, 8 } );\n\n        // WHEN\n        int[] target = new int[20];\n        assertTrue( target == cache.get( 10, target ) );\n        assertEquals( 5, target[0] );\n        assertEquals( 6, target[1] );\n        assertEquals( 7, target[2] );\n        assertEquals( 8, target[3] );\n\n        // THEN\n        assertEquals( -1, target[4] );\n    }","id":47477,"modified_method":"@Test\n    public void shouldEndTargetArrayWithMinusOne() throws Exception\n    {\n        // GIVEN\n        NodeLabelsCache cache = new NodeLabelsCache( LongArrayFactory.AUTO, 10 );\n        cache.put( 10, new long[] { 5, 6, 7, 8 } );\n\n        // WHEN\n        int[] target = new int[20];\n        assertTrue( target == cache.get( 10, target ) );\n        assertEquals( 5, target[0] );\n        assertEquals( 6, target[1] );\n        assertEquals( 7, target[2] );\n        assertEquals( 8, target[3] );\n\n        // THEN\n        assertEquals( -1, target[4] );\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public NodeRelationshipLinkImpl( LongArrayFactory arrayFactory, int denseNodeThreshold )\n    {\n        int chunkSize = 1_000_000;\n        this.array = arrayFactory.newDynamicLongArray( chunkSize );\n        this.array.setAll( IdFieldManipulator.emptyField() );\n        this.denseNodeThreshold = denseNodeThreshold;\n        this.relGroupCache = new RelGroupCache( arrayFactory, chunkSize );\n    }","id":47478,"modified_method":"public NodeRelationshipLinkImpl( LongArrayFactory arrayFactory, int denseNodeThreshold )\n    {\n        int chunkSize = 1_000_000;\n        this.array = arrayFactory.newDynamicLongArray( chunkSize ).setAll( IdFieldManipulator.emptyField() );\n        this.denseNodeThreshold = denseNodeThreshold;\n        this.relGroupCache = new RelGroupCache( arrayFactory, chunkSize );\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"RelGroupCache( LongArrayFactory arrayFactory, long chunkSize )\n        {\n            assert chunkSize > 0;\n            this.array = arrayFactory.newDynamicLongArray( chunkSize );\n            this.array.setAll( -1 );\n        }","id":47479,"modified_method":"RelGroupCache( LongArrayFactory arrayFactory, long chunkSize )\n        {\n            assert chunkSize > 0;\n            this.array = arrayFactory.newDynamicLongArray( chunkSize ).setAll( -1 );\n        }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void setAll( long value )\n    {\n        if ( isByteUniform( value ) )\n        {\n            unsafe.setMemory( address, length << 3, (byte)value );\n        }\n        else\n        {\n            for ( long i = 0, adr = address; i < length; i++, adr += 8 )\n            {\n                unsafe.putLong( adr, value );\n            }\n        }\n    }","id":47480,"modified_method":"@Override\n    public LongArray setAll( long value )\n    {\n        if ( isByteUniform( value ) )\n        {\n            unsafe.setMemory( address, length << 3, (byte)value );\n        }\n        else\n        {\n            for ( long i = 0, adr = address; i < length; i++, adr += 8 )\n            {\n                unsafe.putLong( adr, value );\n            }\n        }\n        return this;\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static IntArray newIntArray( LongArrayFactory cacheFactory )\n    {\n        IntArray cache = intArray( cacheFactory.newDynamicLongArray( CACHE_CHUNK_SIZE ) );\n        cache.setAll( -1 );\n        return cache;\n    }","id":47481,"modified_method":"private static IntArray newIntArray( LongArrayFactory cacheFactory )\n    {\n        return intArray( cacheFactory.newDynamicLongArray( CACHE_CHUNK_SIZE ) ).setAll( -1 );\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static LongArray newLongArray( LongArrayFactory cacheFactory )\n    {\n        LongArray cache = cacheFactory.newDynamicLongArray( CACHE_CHUNK_SIZE );\n        cache.setAll( -1 );\n        return cache;\n    }","id":47482,"modified_method":"private static LongArray newLongArray( LongArrayFactory cacheFactory )\n    {\n        return cacheFactory.newDynamicLongArray( CACHE_CHUNK_SIZE ).setAll( -1 );\n    }","commit_id":"d8b7e3ea182d9f87060deca810d1d27fbd5e244a","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected boolean setDocument(String StringXML,FileObject file,boolean IsInXMLField,boolean readurl) throws KettleException {\r\n\t   \r\n\t   try{\r\n\t\t\tSAXReader reader = new SAXReader();\r\n\t\r\n\t\t\t// Validate XML against specified schema?\r\n\t\t\tif(meta.isValidating())\r\n\t\t\t{\r\n\t\t\t\treader.setValidation(true);\r\n\t\t\t\treader.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Ignore comments?\r\n\t\t\tif(meta.isIgnoreComments())\treader.setIgnoreComments(true);\r\n\t\t\t\r\n\t\t\tif (IsInXMLField)\r\n\t\t\t{\r\n\t\t\t\t//read string to parse\r\n\t\t\t\tdata.document= reader.read(new StringReader(StringXML));\t\r\n\t\t\t}\r\n\t\t\telse if (readurl)\r\n\t\t\t{\r\n\t\t\t\t// read url as source\r\n\t\t\t\tdata.document= reader.read(new URL(StringXML));\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t\r\n\t\t\t\t// get encoding. By default UTF-8\r\n\t\t\t\tString encoding=\"UTF-8\";\r\n\t\t\t\tif (!Const.isEmpty(meta.getEncoding())) encoding=meta.getEncoding();\r\n\t\t\t\tdata.document = reader.read(new FileInputStream(KettleVFS.getFilename(file)),encoding);\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif(meta.isNamespaceAware())\tprepareNSMap(data.document.getRootElement());\t    \t    \r\n\t   }catch (Exception e)\r\n\t   {\r\n\t\t   throw new KettleException(e);\r\n\t   }\r\n\t   return true;        \r\n   }","id":47483,"modified_method":"protected boolean setDocument(String StringXML,FileObject file,boolean IsInXMLField,boolean readurl) throws KettleException {\r\n\t   \r\n\t   try{\r\n\t\t\tSAXReader reader = new SAXReader();\r\n\t\r\n\t\t\t// Validate XML against specified schema?\r\n\t\t\tif(meta.isValidating())\r\n\t\t\t{\r\n\t\t\t\treader.setValidation(true);\r\n\t\t\t\treader.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Ignore comments?\r\n\t\t\tif(meta.isIgnoreComments())\treader.setIgnoreComments(true);\r\n\t\t\t\r\n\t\t\tif (IsInXMLField)\r\n\t\t\t{\r\n\t\t\t\t//read string to parse\r\n\t\t\t\tdata.document= reader.read(new StringReader(StringXML));\t\r\n\t\t\t}\r\n\t\t\telse if (readurl)\r\n\t\t\t{\r\n\t\t\t\t// read url as source\r\n\t\t\t\tdata.document= reader.read(new URL(StringXML));\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t\r\n\t\t\t\t// get encoding. By default UTF-8\r\n\t\t\t\tString encoding=\"UTF-8\";\r\n\t\t\t\tif (!Const.isEmpty(meta.getEncoding())) encoding=meta.getEncoding();\r\n\t\t\t\tdata.document = reader.read( KettleVFS.getInputStream(file),encoding);\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif(meta.isNamespaceAware())\tprepareNSMap(data.document.getRootElement());\t    \t    \r\n\t   }catch (Exception e)\r\n\t   {\r\n\t\t   throw new KettleException(e);\r\n\t   }\r\n\t   return true;        \r\n   }","commit_id":"91d8cd53ea362da6f17950a993efe7672e0ce783","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getLoopPathList()\r\n\t{\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\tGetXMLDataMeta meta = new GetXMLDataMeta ();\r\n\t\t\tgetInfo(meta);\r\n\t\t\tFileInputList fileinputList = meta.getFiles(transMeta);\r\n    \t\r\n\t    \t if (fileinputList.nrOfFiles()>0)\r\n            { \r\n\t\t\t\t// Check the first file\r\n\t    \t\t \r\n\t\t\t\tif (fileinputList.getFile(0).exists()) \r\n\t\t\t\t{\r\n\t\t\t\t\tlistpath.clear();\r\n           \t\t\t// get encoding. By default UTF-8\r\n   \t\t\t\t\tString encoding=\"UTF-8\";\r\n   \t\t\t\t\tif (!Const.isEmpty(meta.getEncoding())) encoding=meta.getEncoding();\r\n   \t\t\t\t\tSAXReader reader = new SAXReader();\r\n   \t    \t\t\tDocument document  = reader.read(new FileInputStream(KettleVFS.getFilename(fileinputList.getFile(0))),encoding);\t\r\n   \t    \t\t\tList<Node> nodes = document.selectNodes(document.getRootElement().getName());\r\n\r\n   \t    \t\t\t for (Node node : nodes) \r\n   \t    \t\t\t {\r\n   \t    \t\t\t\t if(!listpath.contains(node.getPath()))\r\n   \t    \t\t\t\t {\r\n   \t    \t\t\t\t\t listpath.add(node.getPath());\r\n   \t    \t\t\t\t\t addLoopXPath(node);\r\n   \t    \t\t\t\t }\r\n   \t    \t\t\t }\r\n\t\t\t\t\tString[] list_xpath = (String[]) listpath.toArray(new String[listpath.size()]);\r\n\r\n\t\t\t\t\tEnterSelectionDialog dialog = new EnterSelectionDialog(shell, list_xpath, Messages.getString(\"GetXMLDataDialog.Dialog.SelectALoopPath.Title\"), Messages.getString(\"GetXMLDataDialog.Dialog.SelectALoopPath.Message\"));\r\n\t\t\t\t\tString listxpaths = dialog.open();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (listxpaths != null) wLoopXPath.setText(listxpaths);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// The file not exists !\r\n\t\t\t\t\tthrow new KettleException(Messages.getString(\"GetXMLDataDialog.Exception.FileDoesNotExist\", KettleVFS\r\n\t\t\t\t\t\t\t.getFilename(fileinputList.getFile(0))));\r\n\t\t\t\t\t}\r\n           \t\t}\r\n           \r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// No file specified\r\n\t\t\t\t MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t            mb.setMessage(Messages.getString(\"GetXMLDataDialog.FilesMissing.DialogMessage\"));\r\n\t\t            mb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\r\n\t\t            mb.open(); \r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t    {\r\n\t        new ErrorDialog(shell, Messages.getString(\"GetXMLDataDialog.UnableToGetListOfPaths.Title\"), Messages.getString(\"GetXMLDataDialog.UnableToGetListOfPaths.Message\"), e);\r\n\t    }\r\n\t}","id":47484,"modified_method":"private void getLoopPathList()\r\n\t{\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\tGetXMLDataMeta meta = new GetXMLDataMeta ();\r\n\t\t\tgetInfo(meta);\r\n\t\t\tFileInputList fileinputList = meta.getFiles(transMeta);\r\n    \t\r\n\t    \t if (fileinputList.nrOfFiles()>0)\r\n            { \r\n\t\t\t\t// Check the first file\r\n\t    \t\t \r\n\t\t\t\tif (fileinputList.getFile(0).exists()) \r\n\t\t\t\t{\r\n\t\t\t\t\tlistpath.clear();\r\n           \t\t\t// get encoding. By default UTF-8\r\n   \t\t\t\t\tString encoding=\"UTF-8\";\r\n   \t\t\t\t\tif (!Const.isEmpty(meta.getEncoding())) encoding=meta.getEncoding();\r\n   \t\t\t\t\tSAXReader reader = new SAXReader();\r\n   \t    \t\t\tDocument document  = reader.read( KettleVFS.getInputStream(fileinputList.getFile(0)), encoding);\t\r\n   \t    \t\t\tList<Node> nodes = document.selectNodes(document.getRootElement().getName());\r\n\r\n   \t    \t\t\t for (Node node : nodes) \r\n   \t    \t\t\t {\r\n   \t    \t\t\t\t if(!listpath.contains(node.getPath()))\r\n   \t    \t\t\t\t {\r\n   \t    \t\t\t\t\t listpath.add(node.getPath());\r\n   \t    \t\t\t\t\t addLoopXPath(node);\r\n   \t    \t\t\t\t }\r\n   \t    \t\t\t }\r\n\t\t\t\t\tString[] list_xpath = (String[]) listpath.toArray(new String[listpath.size()]);\r\n\r\n\t\t\t\t\tEnterSelectionDialog dialog = new EnterSelectionDialog(shell, list_xpath, Messages.getString(\"GetXMLDataDialog.Dialog.SelectALoopPath.Title\"), Messages.getString(\"GetXMLDataDialog.Dialog.SelectALoopPath.Message\"));\r\n\t\t\t\t\tString listxpaths = dialog.open();\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (listxpaths != null) wLoopXPath.setText(listxpaths);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// The file not exists !\r\n\t\t\t\t\tthrow new KettleException(Messages.getString(\"GetXMLDataDialog.Exception.FileDoesNotExist\", KettleVFS\r\n\t\t\t\t\t\t\t.getFilename(fileinputList.getFile(0))));\r\n\t\t\t\t\t}\r\n           \t\t}\r\n           \r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// No file specified\r\n\t\t\t\t MessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t            mb.setMessage(Messages.getString(\"GetXMLDataDialog.FilesMissing.DialogMessage\"));\r\n\t\t            mb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\r\n\t\t            mb.open(); \r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t    {\r\n\t        new ErrorDialog(shell, Messages.getString(\"GetXMLDataDialog.UnableToGetListOfPaths.Title\"), Messages.getString(\"GetXMLDataDialog.UnableToGetListOfPaths.Message\"), e);\r\n\t    }\r\n\t}","commit_id":"91d8cd53ea362da6f17950a993efe7672e0ce783","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void get()\r\n\t{\r\n        try\r\n        {\r\n        \tlist.clear();\r\n        \tGetXMLDataMeta meta = new GetXMLDataMeta();\r\n        \tgetInfo(meta);\r\n        \t\r\n        \t//\t check if the path is given \r\n    \t\tif (!checkLoopXPath(meta)) return;    \t       \r\n            \r\n    \t\tFileInputList inputList = meta.getFiles(transMeta);\r\n    \t\t\r\n    \t\tif (inputList.getFiles().size()>0)\r\n            {    \r\n            \twFields.removeAll();\r\n            \t// get encoding. By default UTF-8\r\n    \t\t\tString encoding=\"UTF-8\";\r\n    \t\t\tif (!Const.isEmpty(meta.getEncoding()))\r\n    \t\t\t{\r\n    \t\t\t\tencoding=meta.getEncoding();\r\n    \t\t\t}\r\n    \t\t\t\r\n    \t\t\tSAXReader reader = new SAXReader();\r\n    \t\t\tDocument document  = reader.read(new FileInputStream(KettleVFS.getFilename(inputList.getFile(0))),encoding);\t\r\n    \t\t\tList<Node> nodes = document.selectNodes(meta.getLoopXPath());\r\n    \t\t\t for (Node node : nodes) \r\n    \t\t\t {\r\n    \t\t\t\t setNodeField(node); \r\n\t\t\t\t     ChildNode(node);\r\n    \t\t\t }\r\n    \t\t\t \r\n                wFields.removeEmptyRows();\r\n                wFields.setRowNums();\r\n                wFields.optWidth(true);\r\n            }\r\n        }     \r\n        catch(Exception e)\r\n        {\r\n            new ErrorDialog(shell, Messages.getString(\"GetXMLDataDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"GetXMLDataDialog.ErrorParsingData.DialogMessage\"), e);\r\n        }\r\n\t}","id":47485,"modified_method":"private void get()\r\n\t{\r\n        try\r\n        {\r\n        \tlist.clear();\r\n        \tGetXMLDataMeta meta = new GetXMLDataMeta();\r\n        \tgetInfo(meta);\r\n        \t\r\n        \t//\t check if the path is given \r\n    \t\tif (!checkLoopXPath(meta)) return;    \t       \r\n            \r\n    \t\tFileInputList inputList = meta.getFiles(transMeta);\r\n    \t\t\r\n    \t\tif (inputList.getFiles().size()>0)\r\n            {    \r\n            \twFields.removeAll();\r\n            \t// get encoding. By default UTF-8\r\n    \t\t\tString encoding=\"UTF-8\";\r\n    \t\t\tif (!Const.isEmpty(meta.getEncoding()))\r\n    \t\t\t{\r\n    \t\t\t\tencoding=meta.getEncoding();\r\n    \t\t\t}\r\n    \t\t\t\r\n    \t\t\tSAXReader reader = new SAXReader();\r\n    \t\t\tDocument document  = reader.read( KettleVFS.getInputStream(inputList.getFile(0)),encoding );\t\r\n    \t\t\tList<Node> nodes = document.selectNodes(meta.getLoopXPath());\r\n    \t\t\t for (Node node : nodes) \r\n    \t\t\t {\r\n    \t\t\t\t setNodeField(node); \r\n\t\t\t\t     ChildNode(node);\r\n    \t\t\t }\r\n    \t\t\t \r\n                wFields.removeEmptyRows();\r\n                wFields.setRowNums();\r\n                wFields.optWidth(true);\r\n            }\r\n        }     \r\n        catch(Exception e)\r\n        {\r\n            new ErrorDialog(shell, Messages.getString(\"GetXMLDataDialog.ErrorParsingData.DialogTitle\"), Messages.getString(\"GetXMLDataDialog.ErrorParsingData.DialogMessage\"), e);\r\n        }\r\n\t}","commit_id":"91d8cd53ea362da6f17950a993efe7672e0ce783","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void emitMetrics(TimelineMetrics metrics) {\n    String connectUrl = getCollectorUri();\n    String jsonData = null;\n    try {\n      jsonData = mapper.writeValueAsString(metrics);\n    } catch (IOException e) {\n      LOG.error(\"Unable to parse metrics\", e);\n    }\n    if (jsonData != null) {\n      emitMetricsJson(connectUrl, jsonData);\n    }\n  }","id":47486,"modified_method":"protected boolean emitMetrics(TimelineMetrics metrics) {\n    String connectUrl = getCollectorUri();\n    String jsonData = null;\n    try {\n      jsonData = mapper.writeValueAsString(metrics);\n    } catch (IOException e) {\n      LOG.error(\"Unable to parse metrics\", e);\n    }\n    if (jsonData != null) {\n      return emitMetricsJson(connectUrl, jsonData);\n    }\n    return false;\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"protected void emitMetricsJson(String connectUrl, String jsonData) {\n    int timeout = getTimeoutSeconds() * 1000;\n    HttpURLConnection connection = null;\n    try {\n      if (connectUrl == null) {\n        throw new IOException(\"Unknown URL. Unable to connect to metrics collector.\");\n      }\n      connection = connectUrl.startsWith(\"https\") ?\n          getSSLConnection(connectUrl) : getConnection(connectUrl);\n\n      connection.setRequestMethod(\"POST\");\n      connection.setRequestProperty(\"Content-Type\", \"application/json\");\n      connection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n      connection.setConnectTimeout(timeout);\n      connection.setReadTimeout(timeout);\n      connection.setDoOutput(true);\n\n      if (jsonData != null) {\n        try (OutputStream os = connection.getOutputStream()) {\n          os.write(jsonData.getBytes(\"UTF-8\"));\n        }\n      }\n\n      int statusCode = connection.getResponseCode();\n\n      if (statusCode != 200) {\n        LOG.info(\"Unable to POST metrics to collector, \" + connectUrl + \", \" +\n            \"statusCode = \" + statusCode);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Metrics posted to Collector \" + connectUrl);\n        }\n      }\n      cleanupInputStream(connection.getInputStream());\n      //reset failedCollectorConnectionsCounter to \"0\"\n      failedCollectorConnectionsCounter.set(0);\n    } catch (IOException ioe) {\n      StringBuilder errorMessage =\n          new StringBuilder(\"Unable to connect to collector, \" + connectUrl + \"\\n\"\n                  + \"This exceptions will be ignored for next \" + NUMBER_OF_SKIPPED_COLLECTOR_EXCEPTIONS + \" times\\n\");\n      try {\n        if ((connection != null)) {\n          errorMessage.append(cleanupInputStream(connection.getErrorStream()));\n        }\n      } catch (IOException e) {\n        //NOP\n      }\n\n      if (failedCollectorConnectionsCounter.getAndIncrement() == 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(errorMessage, ioe);\n        } else {\n          LOG.info(errorMessage);\n        }\n        throw new UnableToConnectException(ioe).setConnectUrl(connectUrl);\n      } else {\n        failedCollectorConnectionsCounter.compareAndSet(NUMBER_OF_SKIPPED_COLLECTOR_EXCEPTIONS, 0);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\"Ignoring %s AMS connection exceptions\", NUMBER_OF_SKIPPED_COLLECTOR_EXCEPTIONS));\n        }\n      }\n    }\n  }","id":47487,"modified_method":"protected boolean emitMetricsJson(String connectUrl, String jsonData) {\n    int timeout = getTimeoutSeconds() * 1000;\n    HttpURLConnection connection = null;\n    try {\n      if (connectUrl == null) {\n        throw new IOException(\"Unknown URL. Unable to connect to metrics collector.\");\n      }\n      connection = connectUrl.startsWith(\"https\") ?\n          getSSLConnection(connectUrl) : getConnection(connectUrl);\n\n      connection.setRequestMethod(\"POST\");\n      connection.setRequestProperty(\"Content-Type\", \"application/json\");\n      connection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n      connection.setConnectTimeout(timeout);\n      connection.setReadTimeout(timeout);\n      connection.setDoOutput(true);\n\n      if (jsonData != null) {\n        try (OutputStream os = connection.getOutputStream()) {\n          os.write(jsonData.getBytes(\"UTF-8\"));\n        }\n      }\n\n      int statusCode = connection.getResponseCode();\n\n      if (statusCode != 200) {\n        LOG.info(\"Unable to POST metrics to collector, \" + connectUrl + \", \" +\n            \"statusCode = \" + statusCode);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Metrics posted to Collector \" + connectUrl);\n        }\n      }\n      cleanupInputStream(connection.getInputStream());\n      //reset failedCollectorConnectionsCounter to \"0\"\n      failedCollectorConnectionsCounter.set(0);\n      return true;\n    } catch (IOException ioe) {\n      StringBuilder errorMessage =\n          new StringBuilder(\"Unable to connect to collector, \" + connectUrl + \"\\n\"\n                  + \"This exceptions will be ignored for next \" + NUMBER_OF_SKIPPED_COLLECTOR_EXCEPTIONS + \" times\\n\");\n      try {\n        if ((connection != null)) {\n          errorMessage.append(cleanupInputStream(connection.getErrorStream()));\n        }\n      } catch (IOException e) {\n        //NOP\n      }\n\n      if (failedCollectorConnectionsCounter.getAndIncrement() == 0) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(errorMessage, ioe);\n        } else {\n          LOG.info(errorMessage);\n        }\n        throw new UnableToConnectException(ioe).setConnectUrl(connectUrl);\n      } else {\n        failedCollectorConnectionsCounter.compareAndSet(NUMBER_OF_SKIPPED_COLLECTOR_EXCEPTIONS, 0);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(String.format(\"Ignoring %s AMS connection exceptions\", NUMBER_OF_SKIPPED_COLLECTOR_EXCEPTIONS));\n        }\n        return false;\n      }\n    }\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public void emitMetrics(TimelineMetrics metrics) {\n      super.emitMetrics(metrics);\n    }","id":47488,"modified_method":"@Override\n    public boolean emitMetrics(TimelineMetrics metrics) {\n      return super.emitMetrics(metrics);\n    }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void emitMetrics(TimelineMetrics metrics) {\n    super.emitMetrics(metrics);\n  }","id":47489,"modified_method":"@Override\n  protected boolean emitMetrics(TimelineMetrics metrics) {\n    return super.emitMetrics(metrics);\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void emitMetrics(TimelineMetrics metrics) {\n    super.emitMetrics(metrics);\n  }","id":47490,"modified_method":"@Override\n  protected boolean emitMetrics(TimelineMetrics metrics) {\n    return super.emitMetrics(metrics);\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"private void addHeapMemoryUsageMetric(TimelineMetrics metrics) {\n    Exception lastException = null;\n    for (int retries = 0; retries < 3; retries++) {\n      try {\n        Map<String, Long> memoryData = solrJmxAdapter.getMemoryData();\n        addMetric(\"jvm.JvmMetrics.MemHeapUsedM\", \"Long\", memoryData.get(\"heapMemoryUsed\").doubleValue() / 1024 / 1024, metrics);\n        addMetric(\"jvm.JvmMetrics.MemHeapCommittedM\", \"Long\", memoryData.get(\"heapMemoryCommitted\").doubleValue() / 1024 / 1024, metrics);\n        addMetric(\"jvm.JvmMetrics.MemHeapMaxM\", \"Long\", memoryData.get(\"heapMemoryMax\").doubleValue() / 1024 / 1024, metrics);\n        addMetric(\"jvm.JvmMetrics.MemNonHeapUsedM\", \"Long\", memoryData.get(\"nonHeapMemoryUsed\").doubleValue() / 1024 / 1024, metrics);\n        addMetric(\"jvm.JvmMetrics.MemNonHeapCommittedM\", \"Long\", memoryData.get(\"nonHeapMemoryCommitted\").doubleValue() / 1024 / 1024, metrics);\n        addMetric(\"jvm.JvmMetrics.MemNonHeapMaxM\", \"Long\", memoryData.get(\"nonHeapMemoryMax\").doubleValue() / 1024 / 1024, metrics);\n        return;\n      } catch (MalformedObjectNameException e) {\n        lastException = e;\n        try {\n          solrJmxAdapter.reConnect();\n        } catch (IOException e1) {\n        }\n      }\n    }\n\n    LOG.info(\"Could not load solr heap memory usage metric, last exception:\", lastException);\n  }","id":47491,"modified_method":"private void addHeapMemoryUsageMetric() {\n    Exception lastException = null;\n    for (int retries = 0; retries < RETRY; retries++) {\n      try {\n        Map<String, Long> memoryData = solrJmxAdapter.getMemoryData();\n        addMetric(\"jvm.JvmMetrics.MemHeapUsedM\", \"Long\", memoryData.get(\"heapMemoryUsed\").doubleValue() / 1024 / 1024);\n        addMetric(\"jvm.JvmMetrics.MemHeapCommittedM\", \"Long\", memoryData.get(\"heapMemoryCommitted\").doubleValue() / 1024 / 1024);\n        addMetric(\"jvm.JvmMetrics.MemHeapMaxM\", \"Long\", memoryData.get(\"heapMemoryMax\").doubleValue() / 1024 / 1024);\n        addMetric(\"jvm.JvmMetrics.MemNonHeapUsedM\", \"Long\", memoryData.get(\"nonHeapMemoryUsed\").doubleValue() / 1024 / 1024);\n        addMetric(\"jvm.JvmMetrics.MemNonHeapCommittedM\", \"Long\", memoryData.get(\"nonHeapMemoryCommitted\").doubleValue() / 1024 / 1024);\n        addMetric(\"jvm.JvmMetrics.MemNonHeapMaxM\", \"Long\", memoryData.get(\"nonHeapMemoryMax\").doubleValue() / 1024 / 1024);\n        return;\n      } catch (MalformedObjectNameException e) {\n        lastException = e;\n        try {\n          solrJmxAdapter.reConnect();\n        } catch (IOException e1) {\n        }\n      }\n    }\n\n    LOG.info(\"Could not load solr heap memory usage metric, last exception:\", lastException);\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public void run() {\n    LOG.info(\"Loading Solr Metrics for the host \" + solrHost);\n\n    TimelineMetrics metrics = new TimelineMetrics();\n\n    addCpuUsageMetric(metrics);\n    addHeapMemoryUsageMetric(metrics);\n    addIndexSizeMetric(metrics);\n\n    solrAmsClient.emitMetrics(metrics);\n  }","id":47492,"modified_method":"@Override\n  public void run() {\n    LOG.info(\"Loading Solr Metrics for the host \" + solrHost);\n\n    addCpuUsageMetric();\n    addHeapMemoryUsageMetric();\n    addIndexSizeMetric();\n\n    emitMetrics();\n    removeOverTheLimitMetrics();\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"private void addMetric(String metricName, String type, Double value, TimelineMetrics metrics) {\n    Long currMS = System.currentTimeMillis();\n\n    TimelineMetric metric = new TimelineMetric();\n    metric.setMetricName(metricName);\n    metric.setHostName(solrHost);\n    metric.setAppId(\"logsearch-solr\");\n    metric.setStartTime(currMS);\n    metric.setType(type);\n    metric.setTimestamp(currMS);\n    metric.getMetricValues().put(currMS, value);\n\n    metrics.addOrMergeTimelineMetric(metric);\n  }","id":47493,"modified_method":"private void addMetric(String metricName, String type, Double value) {\n    Long currMS = System.currentTimeMillis();\n\n    TimelineMetric metric = new TimelineMetric();\n    metric.setMetricName(metricName);\n    metric.setHostName(solrHost);\n    metric.setAppId(\"logsearch-solr\");\n    metric.setStartTime(currMS);\n    metric.setType(type);\n    metric.setTimestamp(currMS);\n    metric.getMetricValues().put(currMS, value);\n\n    metrics.addOrMergeTimelineMetric(metric);\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"public static void startSolrMetricsLoaderTasks() {\n    try {\n      String collectorHosts = PropertiesUtil.getProperty(\"metrics.collector.hosts\");\n      if (StringUtils.isEmpty(collectorHosts)) {\n        LOG.warn(\"No Ambari Metrics service is available, no Solr metrics will be loaded!\");\n        return;\n      }\n\n      int solrJmxPort = PropertiesUtil.getIntProperty(\"solr.jmx.port\");\n\n      String zkHosts = PropertiesUtil.getProperty(\"solr.zkhosts\");\n      AmbariSolrCloudClient ambariSolrCloudClient = new AmbariSolrCloudClientBuilder()\n          .withZookeeperHosts(zkHosts)\n          .build();\n\n      Collection<String> solrHosts = ambariSolrCloudClient.getSolrHosts();\n      for (String solrHost : solrHosts) {\n        SolrMetricsLoader sml = new SolrMetricsLoader(solrHost, solrJmxPort, collectorHosts);\n        Timer timer = new Timer(\"Solr Metrics Loader - \" + solrHost, false);\n        timer.scheduleAtFixedRate(sml, 0, 10000);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Could not start solr metric loader tasks\", e);\n    }\n  }","id":47494,"modified_method":"public static void startSolrMetricsLoaderTasks() {\n    try {\n      String collectorHosts = PropertiesUtil.getProperty(\"metrics.collector.hosts\");\n      if (StringUtils.isEmpty(collectorHosts)) {\n        LOG.warn(\"No Ambari Metrics service is available, no Solr metrics will be loaded!\");\n        return;\n      }\n\n      int solrJmxPort = PropertiesUtil.getIntProperty(\"solr.jmx.port\");\n\n      String zkHosts = PropertiesUtil.getProperty(\"solr.zkhosts\");\n      AmbariSolrCloudClient ambariSolrCloudClient = new AmbariSolrCloudClientBuilder()\n          .withZookeeperHosts(zkHosts)\n          .build();\n\n      Collection<String> solrHosts = ambariSolrCloudClient.getSolrHosts();\n      for (String solrHost : solrHosts) {\n        SolrMetricsLoader sml = new SolrMetricsLoader(solrHost, solrJmxPort, collectorHosts);\n        Timer timer = new Timer(\"Solr Metrics Loader - \" + solrHost, true);\n        timer.scheduleAtFixedRate(sml, 0, 10000);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Could not start solr metric loader tasks\", e);\n    }\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"private void addCpuUsageMetric(TimelineMetrics metrics) {\n    Exception lastException = null;\n    for (int retries = 0; retries < 3; retries++) {\n      try {\n        double processCpuLoad = solrJmxAdapter.getProcessCpuLoad();\n        addMetric(\"logsearch.solr.cpu.usage\", \"Float\", processCpuLoad, metrics);\n        return;\n      } catch (MalformedObjectNameException e) {\n        lastException = e;\n        try {\n          solrJmxAdapter.reConnect();\n        } catch (IOException e1) {\n        }\n      }\n    }\n\n    LOG.info(\"Could not load solr cpu usage metric, last exception:\", lastException);\n  }","id":47495,"modified_method":"private void addCpuUsageMetric() {\n    Exception lastException = null;\n    for (int retries = 0; retries < RETRY; retries++) {\n      try {\n        double processCpuLoad = solrJmxAdapter.getProcessCpuLoad();\n        addMetric(\"logsearch.solr.cpu.usage\", \"Float\", processCpuLoad);\n        return;\n      } catch (MalformedObjectNameException e) {\n        lastException = e;\n        try {\n          solrJmxAdapter.reConnect();\n        } catch (IOException e1) {\n        }\n      }\n    }\n\n    LOG.info(\"Could not load solr cpu usage metric, last exception:\", lastException);\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"private void addIndexSizeMetric(TimelineMetrics metrics) {\n    Exception lastException = null;\n    for (int retries = 0; retries < 3; retries++) {\n      try {\n        double indexSize = solrJmxAdapter.getIndexSize();\n        addMetric(\"logsearch.solr.index.size\", \"Long\", indexSize / 1024 / 1024 / 1024, metrics);\n        return;\n      } catch (Exception e) {\n        lastException = e;\n        try {\n          solrJmxAdapter.reConnect();\n        } catch (IOException e1) {\n        }\n      }\n    }\n\n    LOG.info(\"Could not load solr index size metric, last exception:\", lastException);\n  }","id":47496,"modified_method":"private void addIndexSizeMetric() {\n    Exception lastException = null;\n    for (int retries = 0; retries < RETRY; retries++) {\n      try {\n        double indexSize = solrJmxAdapter.getIndexSize();\n        addMetric(\"logsearch.solr.index.size\", \"Long\", indexSize / 1024 / 1024 / 1024);\n        return;\n      } catch (Exception e) {\n        lastException = e;\n        try {\n          solrJmxAdapter.reConnect();\n        } catch (IOException e1) {\n        }\n      }\n    }\n\n    LOG.info(\"Could not load solr index size metric, last exception:\", lastException);\n  }","commit_id":"bd377e67b476d93596be72697f4a6b2a7808504e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n\tpublic Cookie toCookie() {\n\t\tCookie cookie = new Cookie(this.name, this.value);\n\t\tcookie.setComment(this.comment);\n\t\tif(this.domain != null) {\n\t\t\t// FYI: setDomain requires non-null argument (requirement not documented)\n\t\t\tcookie.setDomain(this.domain);\n\t\t}\n\t\t\n\t\tfinal int maxAge;\n\t\tif (this.expires == null) {\n\t\t    maxAge = -1;\n\t\t}\n\t\telse {\n\t\t    maxAge = (int)TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - this.expires.getTime());\n\t\t}\n\t\tcookie.setMaxAge(maxAge);\n\t\tcookie.setPath(this.path);\n\t\tcookie.setSecure(this.secure);\n\t\tcookie.setVersion(this.version);\n\t\treturn cookie;\n\t}","id":47497,"modified_method":"@Override\n\tpublic Cookie toCookie() {\n\t\tCookie cookie = new Cookie(this.name, this.value);\n\t\tcookie.setComment(this.comment);\n\t\tif(this.domain != null) {\n\t\t\t// FYI: setDomain requires non-null argument (requirement not documented)\n\t\t\tcookie.setDomain(this.domain);\n\t\t}\n\t\t\n\t\tfinal int maxAge;\n\t\tif (this.expires == null) {\n\t\t    maxAge = -1;\n\t\t}\n\t\telse {\n\t\t    maxAge = (int)TimeUnit.MILLISECONDS.toSeconds(this.expires.getTime() - System.currentTimeMillis());\n\t\t}\n\t\tcookie.setMaxAge(maxAge);\n\t\tcookie.setPath(this.path);\n\t\tcookie.setSecure(this.secure);\n\t\tcookie.setVersion(this.version);\n\t\treturn cookie;\n\t}","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected IPortalCookie getPortalCookie(HttpServletRequest request) {\n        final Cookie cookie = this.getCookie(this.cookieName, request);\n        if (cookie == null) {\n            return null;\n        }\n        \n        final String value = cookie.getValue();\n        return this.portletCookieDao.getPortalCookie(value);\n    }","id":47498,"modified_method":"/**\n     * Get THE {@link IPortalCookie} from the {@link HttpServletRequest}, if it exists.\n     * Gracefully returns null if not in the request.\n     * \n     * @param request\n     * @return\n     */\n    protected IPortalCookie getPortalCookie(HttpServletRequest request) {\n        final Cookie cookie = this.getCookieFromRequest(this.cookieName, request);\n        if (cookie == null) {\n        \t// check the session\n        \tIPortalCookie portalCookieInSession = locatePortalCookieInSession(request.getSession());\n        \tif(null != portalCookieInSession) {\n        \t\treturn  portalCookieInSession;\n        \t} else {\n        \t\treturn null;\n        \t}\n        }\n        \n        final String value = cookie.getValue();\n        return this.portletCookieDao.getPortalCookie(value);\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected Cookie getCookie(String name, HttpServletRequest request) {\n        final Cookie[] cookies = request.getCookies();\n        if (cookies == null) { // getCookies() returns null if there aren't any\n            return null;\n        }\n        \n        for (final Cookie cookie : cookies) {\n            if (name.equals(cookie.getName())) {\n                return cookie;\n            }\n        }\n        \n        return null;\n    }","id":47499,"modified_method":"/**\n     * Attempts to retrieve the {@link Cookie} with the specified name from the \n     * {@link HttpServletRequest}.\n     * \n     * Returns the {@link Cookie} if a match is found in the request, otherwise\n     * gracefully returns null.\n     * \n     * @param name\n     * @param request\n     * @return\n     */\n    protected Cookie getCookieFromRequest(String name, HttpServletRequest request) {\n        final Cookie[] cookies = request.getCookies();\n        if (cookies == null) { // getCookies() returns null if there aren't any\n            return null;\n        }\n        \n        for (final Cookie cookie : cookies) {\n            if (name.equals(cookie.getName())) {\n                return cookie;\n            }\n        }\n        \n        return null;\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void updatePortalCookie(HttpServletRequest request, HttpServletResponse response) {\n        //Get the portal cookie object\n        final IPortalCookie portalCookie = this.getOrCreatePortalCookie(request);\n        \n        //Create the browser cookie\n        final Cookie cookie = this.createCookie(portalCookie, request.isSecure());\n        \n        //Update the expiration date of the portal cookie stored in the DB\n        this.portletCookieDao.updatePortalCookieExpiration(portalCookie, cookie.getMaxAge());\n        \n        //Update the cookie in the users browser\n        response.addCookie(cookie);\n    }","id":47500,"modified_method":"/**\n     * \n     * (non-Javadoc)\n     * @see org.jasig.portal.portlet.container.services.IPortletCookieService#updatePortalCookie(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    public void updatePortalCookie(HttpServletRequest request, HttpServletResponse response) {\n        //Get the portal cookie object\n        final IPortalCookie portalCookie = this.getOrCreatePortalCookie(request);\n        \n        //Create the browser cookie\n        final Cookie cookie = this.convertToCookie(portalCookie, this.portalCookieAlwaysSecure || request.isSecure());\n        \n        //Update the expiration date of the portal cookie stored in the DB\n        this.portletCookieDao.updatePortalCookieExpiration(portalCookie, cookie.getMaxAge());\n        \n        // Update expiration dates of portlet cookies stored in session\n        removeExpiredPortletCookies(request);\n        \n        //Update the cookie in the users browser\n        response.addCookie(cookie);\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public Cookie[] getAllPortletCookies(HttpServletRequest request, IPortletWindowId portletWindowId) {\n        //Get the cookies from the servlet request\n        Cookie[] servletCookies = request.getCookies();\n        if (servletCookies == null) {\n            servletCookies = new Cookie[0];\n        }\n        \n        //Get cookies that have been set by portlets\n        final IPortalCookie portalCookie = this.getPortalCookie(request);\n        Set<IPortletCookie> portletCookies = Collections.emptySet();\n        if(portalCookie != null) {\n        \tportletCookies = portalCookie.getPortletCookies();\n        }\n        \n        // finally get portlet cookies from session (all maxAge -1)\n        Map<String, Cookie> sessionOnlyPortletCookieMap = getSessionOnlyPortletCookieMap(request);\n        Collection<Cookie> sessionOnlyCookies = sessionOnlyPortletCookieMap.values();\n        \n        //Merge into a single array\n        final Cookie[] cookies = new Cookie[servletCookies.length + portletCookies.size() + sessionOnlyCookies.size()];\n        System.arraycopy(servletCookies, 0, cookies, 0, servletCookies.length);\n\n        int cookieIdx = servletCookies.length;\n        for (final IPortletCookie portletCookie : portletCookies) {\n            final Cookie cookie = portletCookie.toCookie(); \n            cookies[cookieIdx++] = cookie;\n        }\n        for(Cookie sessionOnlyCookie: sessionOnlyCookies) {\n        \tcookies[cookieIdx++] = sessionOnlyCookie;\n        }\n       \n        \n        return cookies;\n    }","id":47501,"modified_method":"@Override\n    public Cookie[] getAllPortletCookies(HttpServletRequest request, IPortletWindowId portletWindowId) {\n        //Get the cookies from the servlet request\n        Cookie[] servletCookies = request.getCookies();\n        if (servletCookies == null) {\n            servletCookies = new Cookie[0];\n        }\n        \n        //Get cookies that have been set by portlets, suppressing expired\n        final IPortalCookie portalCookie = this.getPortalCookie(request);\n        Set<IPortletCookie> portletCookies = new HashSet<IPortletCookie>();\n        if(portalCookie != null) {\n        \tDate now = new Date();\n        \tfor(IPortletCookie portletCookie: portalCookie.getPortletCookies()) {\n        \t\tif(portletCookie.getExpires().after(now)) {\n        \t\t\tportletCookies.add(portletCookie);\n        \t\t}\n        \t}\n        }\n        \n        // finally get portlet cookies from session (all maxAge -1)\n        Map<String, SessionOnlyPortletCookieImpl> sessionOnlyPortletCookieMap = getSessionOnlyPortletCookieMap(request);\n        Collection<SessionOnlyPortletCookieImpl> sessionOnlyCookies = sessionOnlyPortletCookieMap.values();\n        \n        //Merge into a single array\n        final Cookie[] cookies = new Cookie[servletCookies.length + portletCookies.size() + sessionOnlyCookies.size()];\n        System.arraycopy(servletCookies, 0, cookies, 0, servletCookies.length);\n\n        int cookieIdx = servletCookies.length;\n        for (final IPortletCookie portletCookie : portletCookies) {\n            final Cookie cookie = portletCookie.toCookie(); \n            cookies[cookieIdx++] = cookie;\n        }\n        for(SessionOnlyPortletCookieImpl sessionOnlyCookie: sessionOnlyCookies) {\n        \tcookies[cookieIdx++] = sessionOnlyCookie.toCookie();\n        }\n       \n        \n        return cookies;\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Convert the {@link IPortalCookie} into a servlet {@link Cookie}.\n     * \n     * @param portalCookie\n     * @return\n     */\n    protected Cookie createCookie(IPortalCookie portalCookie, boolean secure) {\n        final Cookie cookie = new Cookie(this.cookieName, portalCookie.getValue());\n        \n        //Set the cookie's feilds\n        cookie.setComment(this.comment);\n        cookie.setMaxAge(this.maxAge);\n        cookie.setSecure(secure);\n        if (this.domain != null) {\n            cookie.setDomain(this.domain);\n        }\n        if (this.path != null) {\n            cookie.setPath(this.path);\n        }\n        \n        return cookie;\n    }","id":47502,"modified_method":"/**\n     * Convert the {@link IPortalCookie} into a servlet {@link Cookie}.\n     * \n     * @param portalCookie\n     * @return\n     */\n    protected Cookie convertToCookie(IPortalCookie portalCookie, boolean secure) {\n    \tfinal Cookie cookie = new Cookie(this.cookieName, portalCookie.getValue());\n\n    \t//Set the cookie's fields\n    \tcookie.setComment(this.comment);\n    \tcookie.setMaxAge(this.maxAge);\n    \tcookie.setSecure(secure);\n    \tif (this.domain != null) {\n    \t\tcookie.setDomain(this.domain);\n    \t}\n\n    \tcookie.setPath(this.path);\n\n    \treturn cookie;\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Get the {@link Map} of {@link Cookie}s stored in the {@link HttpSession} specifically\n     * used for storing {@link Cookie}s with a maxAge equal to -1.\n     * Will create the map if it doesn't yet exist.\n     * \n     * @param request\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n\tprotected Map<String, Cookie> getSessionOnlyPortletCookieMap(final HttpServletRequest request) {\n    \tfinal HttpSession session = request.getSession();\n        synchronized(WebUtils.getSessionMutex(session)) {\n        \tMap<String, Cookie> sessionOnlyPortletCookies = (Map<String, Cookie>) session.getAttribute(SESSION_ATTRIBUTE__SESSION_ONLY_COOKIE_MAP);\n        \tif(sessionOnlyPortletCookies == null) {\n        \t\tsessionOnlyPortletCookies = new ConcurrentHashMap<String, Cookie>();\n        \t\tsession.setAttribute(SESSION_ATTRIBUTE__SESSION_ONLY_COOKIE_MAP, sessionOnlyPortletCookies);\t\n        \t}\n        \treturn sessionOnlyPortletCookies;\n        }\n    }","id":47503,"modified_method":"/**\n     * Get the {@link Map} of {@link SessionOnlyPortletCookieImpl}s stored in the {@link HttpSession} specifically\n     * used for storing {@link SessionOnlyPortletCookieImpl}s with a maxAge equal to -1.\n     * Will create the map if it doesn't yet exist.\n     * \n     * @param request\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n\tprotected Map<String, SessionOnlyPortletCookieImpl> getSessionOnlyPortletCookieMap(final HttpServletRequest request) {\n    \tfinal HttpSession session = request.getSession();\n        synchronized(WebUtils.getSessionMutex(session)) {\n        \tMap<String, SessionOnlyPortletCookieImpl> sessionOnlyPortletCookies = (Map<String, SessionOnlyPortletCookieImpl>) session.getAttribute(SESSION_ATTRIBUTE__SESSION_ONLY_COOKIE_MAP);\n        \tif(sessionOnlyPortletCookies == null) {\n        \t\tsessionOnlyPortletCookies = new ConcurrentHashMap<String, SessionOnlyPortletCookieImpl>();\n        \t\tsession.setAttribute(SESSION_ATTRIBUTE__SESSION_ONLY_COOKIE_MAP, sessionOnlyPortletCookies);\t\n        \t}\n        \treturn sessionOnlyPortletCookies;\n        }\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public void addCookie(HttpServletRequest request, IPortletWindowId portletWindowId, Cookie cookie) {\n        final IPortalCookie portalCookie = this.getOrCreatePortalCookie(request);\n        if(cookie.getMaxAge() == -1) {\n        \t// persist only in the session\n            Map<String, Cookie> sessionOnlyPortletCookies = getSessionOnlyPortletCookieMap(request);\n            sessionOnlyPortletCookies.put(cookie.getName(), cookie);\n            \n        } else {\n        \tthis.portletCookieDao.addOrUpdatePortletCookie(portalCookie, cookie);\n        }\n        \n    }","id":47504,"modified_method":"@Override\n    public void addCookie(HttpServletRequest request, IPortletWindowId portletWindowId, Cookie cookie) {\n        final IPortalCookie portalCookie = this.getOrCreatePortalCookie(request);\n        if(cookie.getMaxAge() < 0) {\n        \t// persist only in the session\n            Map<String, SessionOnlyPortletCookieImpl> sessionOnlyPortletCookies = getSessionOnlyPortletCookieMap(request);\n            SessionOnlyPortletCookieImpl sessionOnlyCookie = new SessionOnlyPortletCookieImpl(cookie);\n            sessionOnlyPortletCookies.put(cookie.getName(), sessionOnlyCookie);\n        } else if (cookie.getMaxAge() == 0) {\n        \t// delete the cookie from the session, if present\n        \tMap<String, SessionOnlyPortletCookieImpl> sessionOnlyPortletCookies = getSessionOnlyPortletCookieMap(request);\n        \tSessionOnlyPortletCookieImpl existing = sessionOnlyPortletCookies.remove(cookie.getName());\n        \tif(null == existing) {\n        \t\t// returning null from map#remove means cookie wasn't in the session, trigger portletCookieDao update\n        \t\tthis.portletCookieDao.addOrUpdatePortletCookie(portalCookie, cookie);\n        \t}\n        } else {\n        \tMap<String, SessionOnlyPortletCookieImpl> sessionOnlyPortletCookies = getSessionOnlyPortletCookieMap(request);\n        \tsessionOnlyPortletCookies.remove(cookie.getName());\n        \t// update the portletCookieDao regardless\n        \tthis.portletCookieDao.addOrUpdatePortletCookie(portalCookie, cookie);\n        }\n        \n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected IPortalCookie getOrCreatePortalCookie(HttpServletRequest request) {\n        final Cookie cookie = this.getCookie(this.cookieName, request);\n        if (cookie == null) {\n            return this.portletCookieDao.createPortalCookie(this.maxAge);\n        }\n        \n        final String value = cookie.getValue();\n        final IPortalCookie portalCookie = this.portletCookieDao.getPortalCookie(value);\n        if (portalCookie == null) {\n            return this.portletCookieDao.createPortalCookie(this.maxAge);\n        }\n        \n        return portalCookie;\n    }","id":47505,"modified_method":"/**\n     * Locate the existing {@link IPortalCookie} with the request, or create a new one.\n     * \n     * @param request\n     * @return the {@link IPortalCookie} - never null\n     */\n    protected IPortalCookie getOrCreatePortalCookie(HttpServletRequest request) {\n    \tIPortalCookie result = null;\n    \t\n    \t// first check in request\n        final Cookie cookie = this.getCookieFromRequest(this.cookieName, request);\n        if (cookie != null) {\n        \t// found a potential cookie, call off to the dao\n        \tfinal String value = cookie.getValue();\n        \tresult = this.portletCookieDao.getPortalCookie(value);\n        } \n        \n        // still null? check in the session\n        if(result == null) {\n        \tresult = locatePortalCookieInSession(request.getSession());\n        }\n        // if by this point we still haven't found the portal cookie, create one\n        if(result == null) {\n        \tresult = this.portletCookieDao.createPortalCookie(this.maxAge);\n        \t// store the portal cookie value value in the session \n        \tHttpSession session = request.getSession();\n        \tsynchronized(WebUtils.getSessionMutex(session)) {\n        \t\tsession.setAttribute(SESSION_ATTRIBUTE__PORTAL_COOKIE_ID, result.getValue());\n        \t}\n        }\n        \n        return result;\n    }","commit_id":"4a45f011ffe5805e3f9099afa7a4582e19aba2ad","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n\tpublic void destroy() {\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"called SOFilter destroy()\");\n\t\t}\n\t}","id":47506,"modified_method":"@Override\n\tpublic void destroy() {\n\t}","commit_id":"ab56be194c3a00d051955f6f2be464f2ec68aeb2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void doFilter(\n\t\t\tServletRequest servletRequest, ServletResponse servletResponse,\n\t\t\tFilterChain filterChain)\n\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\tHttpServletRequest request = (HttpServletRequest)servletRequest;\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tif ((user == null) || !user.hasPrivateLayouts()) {\n\t\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBoolean secure = PortalUtil.isSecure(request);\n\n\t\t\tString portalURL = PortalUtil.getPortalURL(request, secure);\n\n\t\t\tString redirect = user.getDisplayURL(\n\t\t\t\tportalURL, PortalUtil.getPathMain(), Boolean.TRUE);\n\n\t\t\tHttpServletResponse response = (HttpServletResponse)servletResponse;\n\n\t\t\tresponse.sendRedirect(redirect.toString());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\n\t\t\tif (_log.isDebugEnabled())\n\t\t\t_log.debug(e, e);\n\t\t}\n\t}","id":47507,"modified_method":"@Override\n\tpublic void doFilter(\n\t\t\tServletRequest servletRequest, ServletResponse servletResponse,\n\t\t\tFilterChain filterChain)\n\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\tHttpServletRequest request = (HttpServletRequest)servletRequest;\n\n\t\t\tUser user = PortalUtil.getUser(request);\n\n\t\t\tif ((user == null) || !user.hasPrivateLayouts()) {\n\t\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString portalURL = PortalUtil.getPortalURL(\n\t\t\t\trequest, PortalUtil.isSecure(request));\n\n\t\t\tString redirect = user.getDisplayURL(\n\t\t\t\tportalURL, PortalUtil.getPathMain(), true);\n\n\t\t\tHttpServletResponse response = (HttpServletResponse)servletResponse;\n\n\t\t\tresponse.sendRedirect(redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\t\t}\n\t}","commit_id":"ab56be194c3a00d051955f6f2be464f2ec68aeb2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"called SOFilter init()\");\n\t\t}\n\t}","id":47508,"modified_method":"@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t}","commit_id":"ab56be194c3a00d051955f6f2be464f2ec68aeb2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)req.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong userId = themeDisplay.getUserId();\n\t\tLayout layout = themeDisplay.getLayout();\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\tthemeDisplay.getLayoutTypePortlet();\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tString portletId = ParamUtil.getString(req, \"p_p_id\");\n\n\t\tboolean updateLayout = true;\n\t\tboolean deletePortlet = false;\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tportletId = layoutTypePortlet.addPortletId(userId, portletId);\n\t\t}\n\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\tif (layoutTypePortlet.hasPortletId(portletId)) {\n\t\t\t\tdeletePortlet = true;\n\n\t\t\t\tlayoutTypePortlet.removePortletId(portletId);\n\t\t\t}\n\t\t}\n\t\telse if (cmd.equals(\"drag\")) {\n\t\t\tif (LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout.getGroupId(),\n\t\t\t\t\tlayout.isPrivateLayout(), layout.getLayoutId(),\n\t\t\t\t\tActionKeys.UPDATE)) {\n\n\t\t\t\tString height = ParamUtil.getString(req, \"height\");\n\t\t\t\tString width = ParamUtil.getString(req, \"width\");\n\t\t\t\tString top = ParamUtil.getString(req, \"top\");\n\t\t\t\tString left = ParamUtil.getString(req, \"left\");\n\n\t\t\t\tPortletPreferences prefs =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\treq, portletId, true, true);\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tsm.append(\"height=\" + height + \"\\n\");\n\t\t\t\tsm.append(\"width=\" + width + \"\\n\");\n\t\t\t\tsm.append(\"top=\" + top + \"\\n\");\n\t\t\t\tsm.append(\"left=\" + left + \"\\n\");\n\n\t\t\t\tprefs.setValue(\"portlet-freeform-styles\", sm.toString());\n\n\t\t\t\tprefs.store();\n\t\t\t}\n\t\t}\n\t\telse if (cmd.equals(\"minimize\")) {\n\t\t\tboolean restore = ParamUtil.getBoolean(req, \"p_p_restore\");\n\n\t\t\tif (restore) {\n\t\t\t\tlayoutTypePortlet.removeStateMinPortletId(portletId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayoutTypePortlet.addStateMinPortletId(portletId);\n\n\t\t\t\tif (layout.isShared()) {\n\t\t\t\t\tupdateLayout = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (cmd.equals(\"move\")) {\n\t\t\tString columnId = ParamUtil.getString(req, \"p_p_col_id\");\n\t\t\tint columnPos = ParamUtil.getInteger(req, \"p_p_col_pos\");\n\n\t\t\tlayoutTypePortlet.movePortletId(\n\t\t\t\tuserId, portletId, columnId, columnPos);\n\t\t}\n\t\telse if (cmd.equals(\"template\")) {\n\t\t\tString layoutTemplateId = ParamUtil.getString(\n\t\t\t\treq, \"layoutTemplateId\");\n\n\t\t\tlayoutTypePortlet.setLayoutTemplateId(userId, layoutTemplateId);\n\t\t}\n\n\t\tif (updateLayout) {\n\t\t\tLayoutServiceUtil.updateLayout(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), layout.getTypeSettings());\n\n\t\t\t// See LEP-1411. Delay the delete of extraneous portlet resources\n\t\t\t// only after the user has proven that he has the valid permissions.\n\n\t\t\tif (deletePortlet) {\n\t\t\t\tString rootPortletId = PortletImpl.getRootPortletId(portletId);\n\n\t\t\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\t\t\tlayout.getCompanyId(), rootPortletId,\n\t\t\t\t\tResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\t\t\tPortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portletId));\n\t\t\t}\n\t\t}\n\n\t\tif (ParamUtil.getBoolean(req, \"refresh\")) {\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_REFERER);\n\t\t}\n\t\telse {\n\t\t\tif (cmd.equals(Constants.ADD) && (portletId != null)) {\n\n\t\t\t\t// Run the render portlet action to add a portlet without\n\t\t\t\t// refreshing.\n\n\t\t\t\tAction renderPortletAction = (Action)InstancePool.get(\n\t\t\t\t\tRenderPortletAction.class.getName());\n\n\t\t\t\t// Pass in the portlet id because the portlet id may be the\n\t\t\t\t// instance id. Namespace the request if necessary.\n\n\t\t\t\tlong companyId = PortalUtil.getCompanyId(req);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, portletId);\n\n\t\t\t\tDynamicServletRequest dynamicReq = null;\n\n\t\t\t\tif (portlet.isPrivateRequestAttributes()) {\n\t\t\t\t\tString portletNamespace =\n\t\t\t\t\t\tPortalUtil.getPortletNamespace(portlet.getPortletId());\n\n\t\t\t\t\tdynamicReq = new NamespaceServletRequest(\n\t\t\t\t\t\treq, portletNamespace, portletNamespace);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdynamicReq = new DynamicServletRequest(req);\n\t\t\t\t}\n\n\t\t\t\tdynamicReq.setParameter(\"p_p_id\", portletId);\n\n\t\t\t\trenderPortletAction.execute(mapping, form, dynamicReq, res);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}","id":47509,"modified_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)req.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong userId = themeDisplay.getUserId();\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t// Get the original layout (not the clone) to ensure that you don't add\n\t\t// a portlet\n\n\t\tlayout = LayoutLocalServiceUtil.getLayout(layout.getPlid());\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tString portletId = ParamUtil.getString(req, \"p_p_id\");\n\n\t\tboolean updateLayout = true;\n\t\tboolean deletePortlet = false;\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tportletId = layoutTypePortlet.addPortletId(userId, portletId);\n\t\t}\n\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\tif (layoutTypePortlet.hasPortletId(portletId)) {\n\t\t\t\tdeletePortlet = true;\n\n\t\t\t\tlayoutTypePortlet.removePortletId(portletId);\n\t\t\t}\n\t\t}\n\t\telse if (cmd.equals(\"drag\")) {\n\t\t\tif (LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout.getGroupId(),\n\t\t\t\t\tlayout.isPrivateLayout(), layout.getLayoutId(),\n\t\t\t\t\tActionKeys.UPDATE)) {\n\n\t\t\t\tString height = ParamUtil.getString(req, \"height\");\n\t\t\t\tString width = ParamUtil.getString(req, \"width\");\n\t\t\t\tString top = ParamUtil.getString(req, \"top\");\n\t\t\t\tString left = ParamUtil.getString(req, \"left\");\n\n\t\t\t\tPortletPreferences prefs =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(\n\t\t\t\t\t\treq, portletId, true, true);\n\n\t\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\t\tsm.append(\"height=\" + height + \"\\n\");\n\t\t\t\tsm.append(\"width=\" + width + \"\\n\");\n\t\t\t\tsm.append(\"top=\" + top + \"\\n\");\n\t\t\t\tsm.append(\"left=\" + left + \"\\n\");\n\n\t\t\t\tprefs.setValue(\"portlet-freeform-styles\", sm.toString());\n\n\t\t\t\tprefs.store();\n\t\t\t}\n\t\t}\n\t\telse if (cmd.equals(\"minimize\")) {\n\t\t\tboolean restore = ParamUtil.getBoolean(req, \"p_p_restore\");\n\n\t\t\tif (restore) {\n\t\t\t\tlayoutTypePortlet.removeStateMinPortletId(portletId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayoutTypePortlet.addStateMinPortletId(portletId);\n\n\t\t\t\tif (layout.isShared()) {\n\t\t\t\t\tupdateLayout = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (cmd.equals(\"move\")) {\n\t\t\tString columnId = ParamUtil.getString(req, \"p_p_col_id\");\n\t\t\tint columnPos = ParamUtil.getInteger(req, \"p_p_col_pos\");\n\n\t\t\tlayoutTypePortlet.movePortletId(\n\t\t\t\tuserId, portletId, columnId, columnPos);\n\t\t}\n\t\telse if (cmd.equals(\"template\")) {\n\t\t\tString layoutTemplateId = ParamUtil.getString(\n\t\t\t\treq, \"layoutTemplateId\");\n\n\t\t\tlayoutTypePortlet.setLayoutTemplateId(userId, layoutTemplateId);\n\t\t}\n\n\t\tif (updateLayout) {\n\t\t\tLayoutServiceUtil.updateLayout(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), layout.getTypeSettings());\n\n\t\t\t// See LEP-1411. Delay the delete of extraneous portlet resources\n\t\t\t// only after the user has proven that he has the valid permissions.\n\n\t\t\tif (deletePortlet) {\n\t\t\t\tString rootPortletId = PortletImpl.getRootPortletId(portletId);\n\n\t\t\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\t\t\tlayout.getCompanyId(), rootPortletId,\n\t\t\t\t\tResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\t\t\tPortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portletId));\n\t\t\t}\n\t\t}\n\n\t\tif (ParamUtil.getBoolean(req, \"refresh\")) {\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_REFERER);\n\t\t}\n\t\telse {\n\t\t\tif (cmd.equals(Constants.ADD) && (portletId != null)) {\n\n\t\t\t\t// Run the render portlet action to add a portlet without\n\t\t\t\t// refreshing.\n\n\t\t\t\tAction renderPortletAction = (Action)InstancePool.get(\n\t\t\t\t\tRenderPortletAction.class.getName());\n\n\t\t\t\t// Pass in the portlet id because the portlet id may be the\n\t\t\t\t// instance id. Namespace the request if necessary.\n\n\t\t\t\tlong companyId = PortalUtil.getCompanyId(req);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, portletId);\n\n\t\t\t\tDynamicServletRequest dynamicReq = null;\n\n\t\t\t\tif (portlet.isPrivateRequestAttributes()) {\n\t\t\t\t\tString portletNamespace =\n\t\t\t\t\t\tPortalUtil.getPortletNamespace(portlet.getPortletId());\n\n\t\t\t\t\tdynamicReq = new NamespaceServletRequest(\n\t\t\t\t\t\treq, portletNamespace, portletNamespace);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdynamicReq = new DynamicServletRequest(req);\n\t\t\t\t}\n\n\t\t\t\tdynamicReq.setParameter(\"p_p_id\", portletId);\n\n\t\t\t\trenderPortletAction.execute(mapping, form, dynamicReq, res);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"b1c7da9befcff4a35729ec256fa7c62121bbead3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doFilter(\n\t\t\tServletRequest req, ServletResponse res, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (USE_VIRTUAL_HOST_FILTER) {\n\t\t\t\t_log.debug(\"Virtual host is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Virtual host is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tHttpServletRequest httpReq = (HttpServletRequest)req;\n\n\t\thttpReq.setCharacterEncoding(ENCODING);\n\n\t\t// Company id needs to always be called here so that it's properly set\n\t\t// in subsequent calls\n\n\t\tlong companyId = PortalInstances.getCompanyId(httpReq);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Company id \" + companyId);\n\t\t}\n\n\t\tPortalUtil.getCurrentURL(httpReq);\n\n\t\tHttpSession ses = httpReq.getSession();\n\n\t\tBoolean httpsInitial = (Boolean)ses.getAttribute(WebKeys.HTTPS_INITIAL);\n\n\t\tif (httpsInitial == null) {\n\t\t\tses.setAttribute(\n\t\t\t\tWebKeys.HTTPS_INITIAL, new Boolean(httpReq.isSecure()));\n\t\t}\n\n\t\tif (!USE_VIRTUAL_HOST_FILTER) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuffer requestURL = httpReq.getRequestURL();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received \" + requestURL);\n\t\t}\n\n\t\tif (!isValidRequestURL(requestURL)) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString friendlyURL = httpReq.getRequestURI().toLowerCase();\n\n\t\tif ((!contextPath.equals(StringPool.SLASH)) &&\n\t\t\t(friendlyURL.indexOf(contextPath) != -1)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(\n\t\t\t\tcontextPath.length(), friendlyURL.length());\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!isValidFriendlyURL(friendlyURL)) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)req.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (layoutSet != null) {\n\t\t\ttry {\n\t\t\t\tStringMaker prefix = new StringMaker();\n\n\t\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPrivateGroup());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPublic());\n\t\t\t\t}\n\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tlayoutSet.getGroupId());\n\n\t\t\t\tif (Validator.isNotNull(group.getFriendlyURL())) {\n\t\t\t\t\tprefix.append(group.getFriendlyURL());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprefix.append(\n\t\t\t\t\t\tgroup.getDefaultFriendlyURL(\n\t\t\t\t\t\t\tlayoutSet.isPrivateLayout()));\n\t\t\t\t}\n\n\t\t\t\tStringMaker redirect = new StringMaker();\n\n\t\t\t\tredirect.append(prefix);\n\t\t\t\tredirect.append(friendlyURL);\n\n\t\t\t\tString query = httpReq.getQueryString();\n\n\t\t\t\tif (query != null) {\n\t\t\t\t\tredirect.append(StringPool.QUESTION);\n\t\t\t\t\tredirect.append(query);\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Redirect to \" + redirect);\n\t\t\t\t}\n\n\t\t\t\tRequestDispatcher rd =\n\t\t\t\t\t_ctx.getRequestDispatcher(redirect.toString());\n\n\t\t\t\trd.forward(req, res);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tchain.doFilter(req, res);\n\t}","id":47510,"modified_method":"public void doFilter(\n\t\t\tServletRequest req, ServletResponse res, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (USE_VIRTUAL_HOST_FILTER) {\n\t\t\t\t_log.debug(\"Virtual host is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(\"Virtual host is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tHttpServletRequest httpReq = (HttpServletRequest)req;\n\n\t\thttpReq.setCharacterEncoding(ENCODING);\n\n\t\t// Company id needs to always be called here so that it's properly set\n\t\t// in subsequent calls\n\n\t\tlong companyId = PortalInstances.getCompanyId(httpReq);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Company id \" + companyId);\n\t\t}\n\n\t\tPortalUtil.getCurrentURL(httpReq);\n\n\t\tHttpSession ses = httpReq.getSession();\n\n\t\tBoolean httpsInitial = (Boolean)ses.getAttribute(WebKeys.HTTPS_INITIAL);\n\n\t\tif (httpsInitial == null) {\n\t\t\thttpsInitial = new Boolean(ParamUtil.getBoolean(\n\t\t\t\thttpReq, \"httpsInitial\", httpReq.isSecure()));\n\n\t\t\tses.setAttribute(WebKeys.HTTPS_INITIAL, httpsInitial);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Setting httpsInitial to \" + httpsInitial);\n\t\t\t}\n\t\t}\n\n\t\tif (!USE_VIRTUAL_HOST_FILTER) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuffer requestURL = httpReq.getRequestURL();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received \" + requestURL);\n\t\t}\n\n\t\tif (!isValidRequestURL(requestURL)) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString friendlyURL = httpReq.getRequestURI().toLowerCase();\n\n\t\tif ((!contextPath.equals(StringPool.SLASH)) &&\n\t\t\t(friendlyURL.indexOf(contextPath) != -1)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(\n\t\t\t\tcontextPath.length(), friendlyURL.length());\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!isValidFriendlyURL(friendlyURL)) {\n\t\t\tchain.doFilter(req, res);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)req.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (layoutSet != null) {\n\t\t\ttry {\n\t\t\t\tStringMaker prefix = new StringMaker();\n\n\t\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPrivateGroup());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPublic());\n\t\t\t\t}\n\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tlayoutSet.getGroupId());\n\n\t\t\t\tif (Validator.isNotNull(group.getFriendlyURL())) {\n\t\t\t\t\tprefix.append(group.getFriendlyURL());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprefix.append(\n\t\t\t\t\t\tgroup.getDefaultFriendlyURL(\n\t\t\t\t\t\t\tlayoutSet.isPrivateLayout()));\n\t\t\t\t}\n\n\t\t\t\tStringMaker redirect = new StringMaker();\n\n\t\t\t\tredirect.append(prefix);\n\t\t\t\tredirect.append(friendlyURL);\n\n\t\t\t\tString query = httpReq.getQueryString();\n\n\t\t\t\tif (query != null) {\n\t\t\t\t\tredirect.append(StringPool.QUESTION);\n\t\t\t\t\tredirect.append(query);\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Redirect to \" + redirect);\n\t\t\t\t}\n\n\t\t\t\tRequestDispatcher rd =\n\t\t\t\t\t_ctx.getRequestDispatcher(redirect.toString());\n\n\t\t\t\trd.forward(req, res);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tchain.doFilter(req, res);\n\t}","commit_id":"b1c7da9befcff4a35729ec256fa7c62121bbead3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void delete(MPSProject project, SModule module, boolean deleteFiles) {\n    //HACK: generator module is not project module, so need to check it separately\n    if (!project.isProjectModule(module instanceof Generator ? ((Generator) module).getSourceLanguage() : module) && !deleteFiles) {\n      throw new IllegalArgumentException(\"Non-project modules can only be deleted with files deletion enabled\");\n    }\n\n    //see MPS-18743\n    MPSModuleRepository.getInstance().saveAll();\n\n    if (deleteFiles) {\n      for (SModel model : module.getModels()) {\n        DeleteModelHelper.delete(module, model, true);\n      }\n\n      if (module.getFacet(JavaModuleFacet.class) != null) {\n        IFile classesGen = module.getFacet(JavaModuleFacet.class).getClassesGen();\n        if (classesGen != null) {\n          deleteFile(classesGen.getPath());\n        }\n      }\n      if (module.getFacet(TestsFacet.class) != null) {\n        deleteFile(module.getFacet(TestsFacet.class).getTestsOutputPath().getPath());\n      }\n\n      if (module instanceof AbstractModule) {\n        AbstractModule curModule = (AbstractModule) module;\n        String outputPath = curModule.getOutputPath().getPath();\n        deleteFile(outputPath);\n        deleteFile(FileGenerationUtil.getCachesPath(outputPath));\n\n        if(curModule.getDescriptorFile() != null)\n          curModule.getDescriptorFile().delete();\n\n        if (curModule.getModuleSourceDir() != null && curModule.getModuleSourceDir().getChildren().isEmpty()) {\n          deleteFile(curModule.getModuleSourceDir().getPath());\n        }\n\n        if(curModule.getDescriptorFile() != null) {\n          IFile moduleFolder = curModule.getDescriptorFile().getParent();\n          if (deleteDirIfEmpty(moduleFolder))\n            moduleFolder.delete();\n        }\n      }\n    }\n\n    //remove from project\n    if (project.isProjectModule(module)) {\n      project.removeModule(module);\n      ((StandaloneMPSProject) project).update();\n      MPSModuleRepository.getInstance().unregisterModule(module, project);\n      project.save();\n    }\n\n    if (deleteFiles) ModuleRepositoryFacade.getInstance().removeModuleForced(module);\n  }","id":47511,"modified_method":"private static void delete(MPSProject project, SModule module, boolean deleteFiles) {\n    //HACK: generator module is not project module, so need to check it separately\n    if (!project.isProjectModule(module instanceof Generator ? ((Generator) module).getSourceLanguage() : module) && !deleteFiles) {\n      throw new IllegalArgumentException(\"Non-project modules can only be deleted with files deletion enabled\");\n    }\n\n    //see MPS-18743\n    project.getRepository().saveAll();\n\n    if (deleteFiles) {\n      for (SModel model : module.getModels()) {\n        DeleteModelHelper.delete(module, model, true);\n      }\n\n      if (module.getFacet(JavaModuleFacet.class) != null) {\n        IFile classesGen = module.getFacet(JavaModuleFacet.class).getClassesGen();\n        if (classesGen != null) {\n          deleteFile(classesGen.toPath().toString());\n        }\n      }\n      if (module.getFacet(TestsFacet.class) != null) {\n        final IFile testsOutputPath = module.getFacet(TestsFacet.class).getTestsOutputPath();\n        if (testsOutputPath != null) {\n          deleteFile(testsOutputPath.toPath().toString());\n        }\n      }\n\n      if (module instanceof AbstractModule) {\n        AbstractModule curModule = (AbstractModule) module;\n        String outputPath = curModule.getOutputPath().toPath().toString();\n        deleteFile(outputPath);\n        deleteFile(FileGenerationUtil.getCachesPath(outputPath));\n\n        if (curModule.getDescriptorFile() != null) {\n          curModule.getDescriptorFile().delete();\n        }\n\n        if (curModule.getModuleSourceDir() != null && curModule.getModuleSourceDir().getChildren().isEmpty()) {\n          deleteFile(curModule.getModuleSourceDir().toPath().toString());\n        }\n\n        if (curModule.getDescriptorFile() != null) {\n          IFile moduleFolder = curModule.getDescriptorFile().getParent();\n          if (moduleFolder !=null && deleteDirIfEmpty(moduleFolder)) {\n            moduleFolder.delete();\n          }\n        }\n      }\n    }\n\n    //remove from project\n    if (project.isProjectModule(module)) {\n      final SRepository repository = project.getRepository();\n      if (repository instanceof SRepositoryExt) {\n        ((SRepositoryExt) repository).unregisterModule(module, project);\n      }\n      project.removeModule(module);\n      project.save();\n\n      ((StandaloneMPSProject) project).update();\n    }\n\n    if (deleteFiles) {\n      new ModuleRepositoryFacade(project.getRepository()).removeModuleForced(module);\n    }\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void deleteFile(String path) {\n    IFile file = FileSystem.getInstance().getFileByPath(path);\n    if (!file.exists()) return;\n    file.delete();\n  }","id":47512,"modified_method":"private static void deleteFile(String path) {\n    IFile file = FileSystem.getInstance().getFile(path);\n    if (!file.exists()) {\n      return;\n    }\n    file.delete();\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    ModulePath modulePath = (ModulePath) o;\n\n    if (myVirtualFolder != null ? !myVirtualFolder.equals(modulePath.myVirtualFolder) : modulePath.myVirtualFolder != null) return false;\n    return myPath.equals(modulePath.myPath);\n  }","id":47513,"modified_method":"@Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n\n    if (obj == null || getClass() != obj.getClass()) {\n      return false;\n    }\n\n    ModulePath modulePath = (ModulePath) obj;\n\n    return myPath.equals(modulePath.myPath)\n        && (myVirtualFolder == null\n        ? modulePath.myVirtualFolder == null\n        : myVirtualFolder.equals(modulePath.myVirtualFolder));\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public final List<SModule> getProjectModules() {\n    return new ArrayList<SModule>(myModuleToPathMap.keySet());\n  }","id":47514,"modified_method":"@NotNull\n  public final List<SModule> getProjectModules() {\n    return new ArrayList<>(myModuleToPathMap.keySet());\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public final void addModule(@NotNull SModule module) {\n    IFile descriptorFile = getDescriptorFileChecked(module);\n    if (descriptorFile != null) {\n      ModulePath path = new ModulePath(descriptorFile.getPath());\n      myModuleToPathMap.put(module, path);\n      myProjectDescriptor.addModulePath(path);\n    }\n  }","id":47515,"modified_method":"@Override\n  public final void addModule(@NotNull SModule module) {\n    IFile descriptorFile = getDescriptorFileChecked(module);\n    if (descriptorFile != null) {\n      ModulePath path = new ModulePath(descriptorFile.toPath().toString());\n      myModuleToPathMap.put(module, path);\n      myProjectDescriptor.addModulePath(path);\n    }\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public final void removeModule(@NotNull SModule module) {\n    if (!myModuleToPathMap.containsKey(module)) {\n      LOG.warn(\"Module has not been registered in the project: \" + module);\n    }\n    IFile descriptorFile = getDescriptorFileChecked(module);\n    if (descriptorFile != null) {\n      myModuleToPathMap.remove(module);\n      myProjectDescriptor.removeModulePath(new ModulePath(descriptorFile.getPath()));\n    }\n  }","id":47516,"modified_method":"@Override\n  public final void removeModule(@NotNull SModule module) {\n    if (!myModuleToPathMap.containsKey(module)) {\n      LOG.warn(\"Module has not been registered in the project: \" + module);\n    }\n    IFile descriptorFile = getDescriptorFileChecked(module);\n    if (descriptorFile != null) {\n      final ModulePath modulePath = myModuleToPathMap.remove(module);\n      myProjectDescriptor.removeModulePath(modulePath);\n    }\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<ModulePath> getModulePaths() {\n    return new ArrayList<ModulePath>(myPath2VFolderMap.keySet());\n  }","id":47517,"modified_method":"public List<ModulePath> getModulePaths() {\n    return new ArrayList<>(myPath2VFolderMap.keySet());\n  }","commit_id":"16a6287972582af037ec35a2dfc47cffd19552c7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testHadoopFileSystemExample() throws Exception {\n        startGrid(CLIENT_LIGHT_GRID_NAME);\n\n        try {\n            // Execute light version of this benchmark in order to ensure that it work.\n            GgfsFileSystemExample.main(new String[]{\"os/examples/config\"});\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","id":47518,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testHadoopFileSystemExample() throws Exception {\n        Path path = U.resolveGridGainPath(\"examples/config\").toPath();\n\n        startGrid(CLIENT_LIGHT_GRID_NAME);\n\n        try {\n            // Execute light version of this benchmark in order to ensure that it work.\n            GgfsFileSystemExample.main(new String[]{Paths.get(U.getGridGainHome()).relativize(path).toString()});\n        }\n        finally {\n            stopAllGrids();\n        }\n    }","commit_id":"f96692ec0235a0af728e920f8dd329057c09c354","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testCustomScript() throws Exception {\n        joinedLatch = new CountDownLatch(1);\n\n        String script = U.isWindows() ? CUSTOM_SCRIPT_WIN : CUSTOM_SCRIPT_LINUX;\n\n        script = U.resolveGridGainPath(script).getPath();\n\n        Collection<GridTuple3<String, Boolean, String>> res =\n            grid.startNodes(\n                maps(Collections.singleton(HOST), SSH_UNAME, pwd, key, 1, U.getGridGainHome(), null, script),\n                null, false, 0, 16).get(WAIT_TIMEOUT);\n\n        assert res.size() == 1;\n\n        F.forEach(res, new CI1<GridTuple3<String, Boolean, String>>() {\n            @Override public void apply(GridTuple3<String, Boolean, String> t) {\n                assert t.get1().equals(HOST);\n\n                if (!t.get2())\n                    throw new GridRuntimeException(t.get3());\n            }\n        });\n\n        assert joinedLatch.await(WAIT_TIMEOUT, MILLISECONDS);\n\n        assert joinedCnt.get() == 1;\n        assert leftCnt.get() == 0;\n\n        assert grid.nodes().size() == 1;\n\n        assert CUSTOM_CFG_ATTR_VAL.equals(F.first(grid.nodes()).<String>attribute(CUSTOM_CFG_ATTR_KEY));\n    }","id":47519,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testCustomScript() throws Exception {\n        joinedLatch = new CountDownLatch(1);\n\n        String script = U.isWindows() ? CUSTOM_SCRIPT_WIN : CUSTOM_SCRIPT_LINUX;\n\n        script = Paths.get(U.getGridGainHome()).relativize(U.resolveGridGainPath(script).toPath()).toString();\n\n        Collection<GridTuple3<String, Boolean, String>> res =\n            grid.startNodes(\n                maps(Collections.singleton(HOST), SSH_UNAME, pwd, key, 1, U.getGridGainHome(), null, script),\n                null, false, 0, 16).get(WAIT_TIMEOUT);\n\n        assert res.size() == 1;\n\n        F.forEach(res, new CI1<GridTuple3<String, Boolean, String>>() {\n            @Override public void apply(GridTuple3<String, Boolean, String> t) {\n                assert t.get1().equals(HOST);\n\n                if (!t.get2())\n                    throw new GridRuntimeException(t.get3());\n            }\n        });\n\n        assert joinedLatch.await(WAIT_TIMEOUT, MILLISECONDS);\n\n        assert joinedCnt.get() == 1;\n        assert leftCnt.get() == 0;\n\n        assert grid.nodes().size() == 1;\n\n        assert CUSTOM_CFG_ATTR_VAL.equals(F.first(grid.nodes()).<String>attribute(CUSTOM_CFG_ATTR_KEY));\n    }","commit_id":"f96692ec0235a0af728e920f8dd329057c09c354","url":"https://github.com/apache/ignite"},{"original_method":"private static boolean isNoRemoteWithoutDotGitError(Throwable e, String url) {\n    Throwable cause = e.getCause();\n    if (!(cause instanceof NoRemoteRepositoryException) && !(cause.getCause() instanceof NoRemoteRepositoryException)) {\n      return false;\n    }\n    return !url.toLowerCase().endsWith(GitUtil.DOT_GIT);\n  }","id":47520,"modified_method":"private static boolean isNoRemoteWithoutDotGitError(Throwable e, String url) {\n    Throwable cause = e.getCause();\n    if (cause == null || (!(cause instanceof NoRemoteRepositoryException) && !(cause.getCause() instanceof NoRemoteRepositoryException))) {\n      return false;\n    }\n    return !url.toLowerCase().endsWith(GitUtil.DOT_GIT);\n  }","commit_id":"700867d76bd123f61167f8a341cfbc1642de0b31","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Calls the given runnable.\n   * If user cancels the authentication dialog, returns.\n   * If user enters incorrect data, he has 2 more attempts to go before failure.\n   * Cleanups are executed after each incorrect attempt to enter password, and after other retriable actions.\n   */\n  private static GeneralResult callWithAuthRetry(@NotNull GitHttpRemoteCommand command, @NotNull Project project) throws InvalidRemoteException, IOException, URISyntaxException {\n    ProxySelector defaultProxySelector = ProxySelector.getDefault();\n    if (GitHttpProxySupport.shouldUseProxy()) {\n      ProxySelector.setDefault(GitHttpProxySupport.newProxySelector(defaultProxySelector, command.getUrl()));\n      GitHttpProxySupport.init();\n    }\n\n    boolean httpTransportErrorFixTried = false;\n    boolean noRemoteWithoutGitErrorFixTried = false;\n    String url = command.getUrl();\n    GitHttpCredentialsProvider provider = command.getCredentialsProvider();\n    try {\n      for (int i = 0; i < 3; i++) {\n        try {\n          AuthData authData = getUsernameAndPassword(provider.getProject(), provider.getUrl());\n          if (authData != null) {\n            provider.fillAuthDataIfNotFilled(authData.getLogin(), authData.getPassword());\n          }\n          if (i == 0) {\n            provider.setAlwaysShowDialog(false);   // if username and password are supplied, no need to show the dialog\n          } else {\n            provider.setAlwaysShowDialog(true);    // unless these values fail authentication\n          }\n          command.run();\n          rememberPassword(provider);\n          return GeneralResult.SUCCESS;\n        }\n        catch (GitAPIException e) {\n          if (!noRemoteWithoutGitErrorFixTried && isNoRemoteWithoutDotGitError(e, url)) {\n            url = addDotGitToUrl(url);\n            command.setUrl(url);\n            provider.setUrl(url);\n            noRemoteWithoutGitErrorFixTried = true;\n            // don't \"eat\" one password entering attempt\n            //noinspection AssignmentToForLoopParameter\n            i--;\n            command.cleanup();\n          }\n        }\n        catch (JGitInternalException e) {\n          if (authError(e)) {\n            if (provider.wasCancelled()) {  // if user cancels the dialog, just return\n              return GeneralResult.CANCELLED;\n            }\n            // otherwise give more tries to enter password\n            command.cleanup();\n          }\n          else if (!httpTransportErrorFixTried && isTransportExceptionForHttp(e, url)) {\n            url = url.replaceFirst(\"http\", \"https\");\n            command.setUrl(url);\n            provider.setUrl(url);\n            httpTransportErrorFixTried = true;\n            // don't \"eat\" one password entering attempt\n            //noinspection AssignmentToForLoopParameter\n            i--;\n            command.cleanup();\n          }\n          else if (!noRemoteWithoutGitErrorFixTried && isNoRemoteWithoutDotGitError(e, url)) {\n            url = addDotGitToUrl(url);\n            command.setUrl(url);\n            provider.setUrl(url);\n            noRemoteWithoutGitErrorFixTried = true;\n            // don't \"eat\" one password entering attempt\n            //noinspection AssignmentToForLoopParameter\n            i--;\n            command.cleanup();\n          }\n          else if (smartHttpPushNotSupported(e)) {\n            throw new SmartPushNotSupportedException(e.getCause().getMessage());\n          }\n          else {\n            throw e;\n          }\n        }\n      }\n      return GeneralResult.NOT_AUTHORIZED;\n    }\n    finally {\n      log(command, project);\n      ProxySelector.setDefault(defaultProxySelector);\n    }\n  }","id":47521,"modified_method":"/**\n   * Calls the given runnable.\n   * If user cancels the authentication dialog, returns.\n   * If user enters incorrect data, he has 2 more attempts to go before failure.\n   * Cleanups are executed after each incorrect attempt to enter password, and after other retriable actions.\n   */\n  private static GeneralResult callWithAuthRetry(@NotNull GitHttpRemoteCommand command, @NotNull Project project) throws InvalidRemoteException, IOException, URISyntaxException {\n    ProxySelector defaultProxySelector = ProxySelector.getDefault();\n    if (GitHttpProxySupport.shouldUseProxy()) {\n      ProxySelector.setDefault(GitHttpProxySupport.newProxySelector(defaultProxySelector, command.getUrl()));\n      GitHttpProxySupport.init();\n    }\n\n    boolean httpTransportErrorFixTried = false;\n    boolean noRemoteWithoutGitErrorFixTried = false;\n    String url = command.getUrl();\n    GitHttpCredentialsProvider provider = command.getCredentialsProvider();\n    try {\n      for (int i = 0; i < 3; i++) {\n        try {\n          AuthData authData = getUsernameAndPassword(provider.getProject(), provider.getUrl());\n          if (authData != null) {\n            provider.fillAuthDataIfNotFilled(authData.getLogin(), authData.getPassword());\n          }\n          if (i == 0) {\n            provider.setAlwaysShowDialog(false);   // if username and password are supplied, no need to show the dialog\n          } else {\n            provider.setAlwaysShowDialog(true);    // unless these values fail authentication\n          }\n          command.run();\n          rememberPassword(provider);\n          return GeneralResult.SUCCESS;\n        }\n        catch (GitAPIException e) {\n          if (!noRemoteWithoutGitErrorFixTried && isNoRemoteWithoutDotGitError(e, url)) {\n            url = addDotGitToUrl(url);\n            command.setUrl(url);\n            provider.setUrl(url);\n            noRemoteWithoutGitErrorFixTried = true;\n            // don't \"eat\" one password entering attempt\n            //noinspection AssignmentToForLoopParameter\n            i--;\n          }\n          command.cleanup();\n        }\n        catch (JGitInternalException e) {\n          try {\n            if (authError(e)) {\n              if (provider.wasCancelled()) {  // if user cancels the dialog, just return\n                return GeneralResult.CANCELLED;\n              }\n              // otherwise give more tries to enter password\n            }\n            else if (!httpTransportErrorFixTried && isTransportExceptionForHttp(e, url)) {\n              url = url.replaceFirst(\"http\", \"https\");\n              command.setUrl(url);\n              provider.setUrl(url);\n              httpTransportErrorFixTried = true;\n              // don't \"eat\" one password entering attempt\n              //noinspection AssignmentToForLoopParameter\n              i--;\n            }\n            else if (!noRemoteWithoutGitErrorFixTried && isNoRemoteWithoutDotGitError(e, url)) {\n              url = addDotGitToUrl(url);\n              command.setUrl(url);\n              provider.setUrl(url);\n              noRemoteWithoutGitErrorFixTried = true;\n              // don't \"eat\" one password entering attempt\n              //noinspection AssignmentToForLoopParameter\n              i--;\n            }\n            else if (smartHttpPushNotSupported(e)) {\n              throw new SmartPushNotSupportedException(e.getCause().getMessage());\n            }\n            else {\n              throw e;\n            }\n          }\n          finally {\n            command.cleanup();\n          }\n        }\n      }\n      return GeneralResult.NOT_AUTHORIZED;\n    }\n    finally {\n      log(command, project);\n      ProxySelector.setDefault(defaultProxySelector);\n    }\n  }","commit_id":"700867d76bd123f61167f8a341cfbc1642de0b31","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void compactionNoBinaryClone() throws Exception {\n        // 2MB data, 5MB blob\n        final int blobSize = 5 * 1024 * 1024;\n        final int dataNodes = 10000;\n\n        // really long time span, no binary cloning\n\n        FileStore fileStore = new FileStore(directory, 1);\n        final SegmentNodeStore nodeStore = new SegmentNodeStore(fileStore);\n                CompactionStrategy custom = new CompactionStrategy(false,\n                false, CLEAN_OLD, TimeUnit.HOURS.toMillis(1), (byte) 0) {\n                    @Override\n                    public boolean compacted(@Nonnull Callable<Boolean> setHead) throws Exception {\n                        return nodeStore.locked(setHead);\n                    }\n                };\n        fileStore.setCompactionStrategy(custom);\n\n        // 1a. Create a bunch of data\n        NodeBuilder extra = nodeStore.getRoot().builder();\n        NodeBuilder content = extra.child(\"content\");\n        for (int i = 0; i < dataNodes; i++) {\n            NodeBuilder c = content.child(\"c\" + i);\n            for (int j = 0; j < 1000; j++) {\n                c.setProperty(\"p\" + i, \"v\" + i);\n            }\n        }\n        nodeStore.merge(extra, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n        // ----\n\n        final long dataSize = fileStore.size();\n        // System.out.printf(\"File store dataSize %s%n\",\n        // byteCountToDisplaySize(dataSize));\n\n        // 1. Create a property with 5 MB blob\n        NodeBuilder builder = nodeStore.getRoot().builder();\n        builder.setProperty(\"a1\", createBlob(nodeStore, blobSize));\n        builder.setProperty(\"b\", \"foo\");\n\n        nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        // System.out.printf(\"File store pre removal %s expecting %s %n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize));\n        assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n        // 2. Now remove the property\n        builder = nodeStore.getRoot().builder();\n        builder.removeProperty(\"a1\");\n        nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        // Size remains same, no cleanup happened yet\n        // System.out.printf(\"File store pre compaction %s expecting %s%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize));\n        assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n        // 3. Compact\n        assertTrue(fileStore.maybeCompact(false));\n\n        // Size still remains same: ran compaction with a '1 Hour' cleanup\n        // strategy\n        // System.out.printf(\"File store post compaction %s expecting %s%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize));\n        assertEquals(\"File store post compaction size\",\n                mb(blobSize + dataSize), mb(fileStore.size()));\n\n        // 4. Add some more property to flush the current TarWriter\n        builder = nodeStore.getRoot().builder();\n        builder.setProperty(\"a2\", createBlob(nodeStore, blobSize));\n        nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        // Size is double\n        // System.out.printf(\"File store pre cleanup %s expecting %s%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(2 * blobSize + dataSize));\n        assertEquals(mb(2 * blobSize + dataSize), mb(fileStore.size()));\n\n        // 5. Cleanup, expecting store size:\n        // no data content =>\n        // fileStore.size() == blobSize\n        // some data content =>\n        // fileStore.size() in [blobSize + dataSize, blobSize + 2xdataSize]\n        assertTrue(fileStore.maybeCompact(true));\n        fileStore.flush();\n        // System.out.printf(\n        // \"File store post cleanup %s expecting between [%s,%s]%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize),\n        // byteCountToDisplaySize(blobSize + 2 * dataSize));\n        assertTrue(mb(fileStore.size()) >= mb(blobSize + dataSize)\n                && mb(fileStore.size()) <= mb(blobSize + 2 * dataSize));\n\n        // refresh the ts ref, to simulate a long wait time\n        custom.setOlderThan(0);\n        TimeUnit.MILLISECONDS.sleep(5);\n\n        // gain is 33%\n        assertTrue(fileStore.maybeCompact(false));\n        fileStore.cleanup();\n\n        // gain is 19%\n        assertTrue(fileStore.maybeCompact(false));\n        fileStore.cleanup();\n\n        // gain is 0%\n        assertFalse(fileStore.maybeCompact(false));\n\n        // no data loss happened\n        byte[] blob = ByteStreams.toByteArray(nodeStore.getRoot()\n                .getProperty(\"a2\").getValue(Type.BINARY).getNewStream());\n        assertEquals(blobSize, blob.length);\n    }","id":47522,"modified_method":"@Test\n    public void compactionNoBinaryClone() throws Exception {\n        // 2MB data, 5MB blob\n        final int blobSize = 5 * 1024 * 1024;\n        final int dataNodes = 10000;\n\n        // really long time span, no binary cloning\n\n        FileStore fileStore = new FileStore(directory, 1);\n        final SegmentNodeStore nodeStore = new SegmentNodeStore(fileStore);\n                CompactionStrategy custom = new CompactionStrategy(false,\n                false, CLEAN_OLD, TimeUnit.HOURS.toMillis(1), (byte) 0) {\n                    @Override\n                    public boolean compacted(@Nonnull Callable<Boolean> setHead) throws Exception {\n                        return nodeStore.locked(setHead);\n                    }\n                };\n        fileStore.setCompactionStrategy(custom);\n\n        // 1a. Create a bunch of data\n        NodeBuilder extra = nodeStore.getRoot().builder();\n        NodeBuilder content = extra.child(\"content\");\n        for (int i = 0; i < dataNodes; i++) {\n            NodeBuilder c = content.child(\"c\" + i);\n            for (int j = 0; j < 1000; j++) {\n                c.setProperty(\"p\" + i, \"v\" + i);\n            }\n        }\n        nodeStore.merge(extra, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n        // ----\n\n        final long dataSize = fileStore.size();\n        // System.out.printf(\"File store dataSize %s%n\",\n        // byteCountToDisplaySize(dataSize));\n\n        // 1. Create a property with 5 MB blob\n        NodeBuilder builder = nodeStore.getRoot().builder();\n        builder.setProperty(\"a1\", createBlob(nodeStore, blobSize));\n        builder.setProperty(\"b\", \"foo\");\n        nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        // System.out.printf(\"File store pre removal %s expecting %s %n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize));\n        assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n        // 2. Now remove the property\n        builder = nodeStore.getRoot().builder();\n        builder.removeProperty(\"a1\");\n        nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        // Size remains same, no cleanup happened yet\n        // System.out.printf(\"File store pre compaction %s expecting %s%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize));\n        assertEquals(mb(blobSize + dataSize), mb(fileStore.size()));\n\n        // 3. Compact\n        assertTrue(fileStore.maybeCompact(false));\n\n        // Size doesn't shrink: ran compaction with a '1 Hour' cleanup\n        // strategy\n        // System.out.printf(\"File store post compaction %s expecting %s%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize));\n        assertSize(\"post compaction\", fileStore.size(), blobSize + dataSize,\n                blobSize + 2 * dataSize);\n\n        // 4. Add some more property to flush the current TarWriter\n        builder = nodeStore.getRoot().builder();\n        builder.setProperty(\"a2\", createBlob(nodeStore, blobSize));\n        nodeStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        // Size is double\n        // System.out.printf(\"File store pre cleanup %s expecting %s%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(2 * blobSize + dataSize));\n        assertSize(\"post compaction\", fileStore.size(),\n                2 * blobSize + dataSize, 2 * blobSize + 2 * dataSize);\n\n        // 5. Cleanup, expecting store size:\n        // no data content =>\n        // fileStore.size() == blobSize\n        // some data content =>\n        // fileStore.size() in [blobSize + dataSize, blobSize + 2xdataSize]\n        assertTrue(fileStore.maybeCompact(false));\n        fileStore.cleanup();\n        // System.out.printf(\n        // \"File store post cleanup %s expecting between [%s,%s]%n\",\n        // byteCountToDisplaySize(fileStore.size()),\n        // byteCountToDisplaySize(blobSize + dataSize),\n        // byteCountToDisplaySize(blobSize + 2 * dataSize));\n        assertSize(\"post cleanup\", fileStore.size(),\n                blobSize + dataSize, blobSize + 2 * dataSize);\n\n        // refresh the ts ref, to simulate a long wait time\n        custom.setOlderThan(0);\n        TimeUnit.MILLISECONDS.sleep(5);\n\n        boolean needsCompaction = true;\n        for (int i = 0; i < 3 && needsCompaction; i++) {\n            needsCompaction = fileStore.maybeCompact(false);\n            fileStore.cleanup();\n        }\n\n        // gain is finally 0%\n        assertFalse(fileStore.maybeCompact(false));\n\n        // no data loss happened\n        byte[] blob = ByteStreams.toByteArray(nodeStore.getRoot()\n                .getProperty(\"a2\").getValue(Type.BINARY).getNewStream());\n        assertEquals(blobSize, blob.length);\n    }","commit_id":"b5d95212853add5eb155e5ef58efe8626836036b","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public IngestModule.ProcessResult process(AbstractFile file) {\n        // Skip everything except unallocated space files.\n        if (file.getType() != TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) {\n            return IngestModule.ProcessResult.OK;\n        }\n        \n        // Safely get a reference to the totalsForIngestJobs object\n        IngestJobTotals totals = getTotalsForIngestJobs(jobId);\n\n        Path tempFilePath = null;\n        try {\n            long id = getRootId(file);\n            // make sure we have a valid systemID\n            if (id == -1) {\n                return ProcessResult.ERROR;\n            }\n\n            // Verify initialization succeeded.\n            if (null == this.executableFile) {\n                logger.log(Level.SEVERE, \"PhotoRec carver called after failed start up\");  // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Check that we have roughly enough disk space left to complete the operation\n            long freeDiskSpace = IngestServices.getInstance().getFreeDiskSpace();\n            // Some network drives always return -1 for free disk space.\n            // In this case, expect enough space and move on.\n\n            if ((freeDiskSpace != -1) && ((file.getSize() * 1.2) > freeDiskSpace)) {\n                logger.log(Level.SEVERE, \"PhotoRec error processing {0} with {1} Not enough space on primary disk to save unallocated space.\", // NON-NLS\n                        new Object[]{file.getName(), PhotoRecCarverIngestModuleFactory.getModuleName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.UnableToCarve\", file.getName()),\n                        NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.NotEnoughDiskSpace\"));\n\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Write the file to disk.\n            long writestart = System.currentTimeMillis();\n            WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.get(this.jobId);\n            tempFilePath = Paths.get(paths.getTempDirPath().toString(), file.getName());\n            ContentUtils.writeToFile(file, tempFilePath.toFile());\n\n            // Create a subdirectory for this file.\n            Path outputDirPath = Paths.get(paths.getOutputDirPath().toString(), file.getName());\n            Files.createDirectory(outputDirPath);\n            File log = new File(Paths.get(outputDirPath.toString(), LOG_FILE).toString()); //NON-NLS\n\n            // Scan the file with Unallocated Carver.\n            ProcessBuilder processAndSettings = new ProcessBuilder(\n                    \"\\\"\" + executableFile + \"\\\"\",\n                    \"/d\", // NON-NLS\n                    \"\\\"\" + outputDirPath.toAbsolutePath() + File.separator + PHOTOREC_RESULTS_BASE + \"\\\"\",\n                    \"/cmd\", // NON-NLS\n                    \"\\\"\" + tempFilePath.toFile() + \"\\\"\",\n                    \"search\");  // NON_NLS\n\n            // Add environment variable to force PhotoRec to run with the same permissions Autopsy uses\n            processAndSettings.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\"); //NON-NLS\n            processAndSettings.redirectErrorStream(true);\n            processAndSettings.redirectOutput(Redirect.appendTo(log));\n\n            int exitValue = ExecUtil.execute(processAndSettings, new FileIngestModuleProcessTerminator(this.context));\n\n            if (this.context.fileIngestIsCancelled() == true) {\n                // if it was cancelled by the user, result is OK\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.INFO, \"PhotoRec cancelled by user\"); // NON-NLS\n                return IngestModule.ProcessResult.OK;\n            } else if (0 != exitValue) {\n                // if it failed or was cancelled by timeout, result is ERROR\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.SEVERE, \"PhotoRec carver returned error exit value = {0} when scanning {1}\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}); // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Move carver log file to avoid placement into Autopsy results. PhotoRec appends \".1\" to the folder name.\n            java.io.File oldAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_RESULTS_EXTENDED, PHOTOREC_REPORT).toString()); //NON-NLS\n            java.io.File newAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_REPORT).toString()); //NON-NLS\n            oldAuditFile.renameTo(newAuditFile);\n\n            Path pathToRemove = Paths.get(outputDirPath.toAbsolutePath().toString());\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(pathToRemove)) {\n                for (Path entry : stream) {\n                    if (Files.isDirectory(entry)) {\n                        FileUtil.deleteDir(new File(entry.toString()));\n                    }\n                }\n            }\n            long writedelta = (System.currentTimeMillis() - writestart);\n            totals.totalWritetime.addAndGet(writedelta);\n            \n            // Now that we've cleaned up the folders and data files, parse the xml output file to add carved items into the database\n            long calcstart = System.currentTimeMillis();\n            PhotoRecCarverOutputParser parser = new PhotoRecCarverOutputParser(outputDirPath);\n            List<LayoutFile> carvedItems = parser.parse(newAuditFile, id, file);            \n            long calcdelta = (System.currentTimeMillis() - calcstart);\n            totals.totalParsetime.addAndGet(calcdelta);\n            if (carvedItems != null) { // if there were any results from carving, add the unallocated carving event to the reports list.\n                totals.totalItemsRecovered.addAndGet(carvedItems.size());\n                context.addFilesToJob(new ArrayList<>(carvedItems));\n                services.fireModuleContentEvent(new ModuleContentEvent(carvedItems.get(0))); // fire an event to update the tree\n            }\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error processing \" + file.getName() + \" with PhotoRec carver\", ex); // NON-NLS\n            return IngestModule.ProcessResult.ERROR;\n        } finally {\n            if (null != tempFilePath && Files.exists(tempFilePath)) {\n                // Get rid of the unallocated space file.\n                tempFilePath.toFile().delete();\n            }\n        }\n        return IngestModule.ProcessResult.OK;\n\n    }","id":47523,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public IngestModule.ProcessResult process(AbstractFile file) {\n        // Skip everything except unallocated space files.\n        if (file.getType() != TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) {\n            return IngestModule.ProcessResult.OK;\n        }\n\n        // Safely get a reference to the totalsForIngestJobs object\n        IngestJobTotals totals = getTotalsForIngestJobs(jobId);\n\n        Path tempFilePath = null;\n        try {\n            long id = getRootId(file);\n            // make sure we have a valid systemID\n            if (id == -1) {\n                return ProcessResult.ERROR;\n            }\n\n            // Verify initialization succeeded.\n            if (null == this.executableFile) {\n                logger.log(Level.SEVERE, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.failedStartup\"));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Check that we have roughly enough disk space left to complete the operation\n            long freeDiskSpace = IngestServices.getInstance().getFreeDiskSpace();\n            // Some network drives always return -1 for free disk space.\n            // In this case, expect enough space and move on.\n\n            if ((freeDiskSpace != -1) && ((file.getSize() * 1.2) > freeDiskSpace)) {\n                totals.totalItemsWithErrors.incrementAndGet();\n                logger.log(Level.SEVERE, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.NotEnoughDiskSpace.detail.msg\", new Object[]{file.getName(), PhotoRecCarverIngestModuleFactory.getModuleName()}));\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.UnableToCarve\", file.getName()),\n                        NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.NotEnoughDiskSpace\"));\n\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Write the file to disk.\n            long writestart = System.currentTimeMillis();\n            WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.get(this.jobId);\n            tempFilePath = Paths.get(paths.getTempDirPath().toString(), file.getName());\n            ContentUtils.writeToFile(file, tempFilePath.toFile());\n\n            // Create a subdirectory for this file.\n            Path outputDirPath = Paths.get(paths.getOutputDirPath().toString(), file.getName());\n            Files.createDirectory(outputDirPath);\n            File log = new File(Paths.get(outputDirPath.toString(), LOG_FILE).toString()); //NON-NLS\n\n            // Scan the file with Unallocated Carver.\n            ProcessBuilder processAndSettings = new ProcessBuilder(\n                    \"\\\"\" + executableFile + \"\\\"\",\n                    \"/d\", // NON-NLS\n                    \"\\\"\" + outputDirPath.toAbsolutePath() + File.separator + PHOTOREC_RESULTS_BASE + \"\\\"\",\n                    \"/cmd\", // NON-NLS\n                    \"\\\"\" + tempFilePath.toFile() + \"\\\"\",\n                    \"search\");  // NON_NLS\n\n            // Add environment variable to force PhotoRec to run with the same permissions Autopsy uses\n            processAndSettings.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\"); //NON-NLS\n            processAndSettings.redirectErrorStream(true);\n            processAndSettings.redirectOutput(Redirect.appendTo(log));\n\n            int exitValue = ExecUtil.execute(processAndSettings, new FileIngestModuleProcessTerminator(this.context));\n\n            if (this.context.fileIngestIsCancelled() == true) {\n                // if it was cancelled by the user, result is OK\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.INFO, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.cancelledByUser\"));\n                MessageNotifyUtil.Notify.info(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.cancelledByUser\"));\n                return IngestModule.ProcessResult.OK;\n            } else if (0 != exitValue) {\n                // if it failed or was cancelled by timeout, result is ERROR\n                cleanup(outputDirPath, tempFilePath);\n                totals.totalItemsWithErrors.incrementAndGet();\n                logger.log(Level.SEVERE, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.exitValue\",\n                        new Object[]{exitValue, file.getName()}));\n                MessageNotifyUtil.Notify.error(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.exitValue\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Move carver log file to avoid placement into Autopsy results. PhotoRec appends \".1\" to the folder name.\n            java.io.File oldAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_RESULTS_EXTENDED, PHOTOREC_REPORT).toString()); //NON-NLS\n            java.io.File newAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_REPORT).toString()); //NON-NLS\n            oldAuditFile.renameTo(newAuditFile);\n\n            Path pathToRemove = Paths.get(outputDirPath.toAbsolutePath().toString());\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(pathToRemove)) {\n                for (Path entry : stream) {\n                    if (Files.isDirectory(entry)) {\n                        FileUtil.deleteDir(new File(entry.toString()));\n                    }\n                }\n            }\n            long writedelta = (System.currentTimeMillis() - writestart);\n            totals.totalWritetime.addAndGet(writedelta);\n\n            // Now that we've cleaned up the folders and data files, parse the xml output file to add carved items into the database\n            long calcstart = System.currentTimeMillis();\n            PhotoRecCarverOutputParser parser = new PhotoRecCarverOutputParser(outputDirPath);\n            List<LayoutFile> carvedItems = parser.parse(newAuditFile, id, file);\n            long calcdelta = (System.currentTimeMillis() - calcstart);\n            totals.totalParsetime.addAndGet(calcdelta);\n            if (carvedItems != null) { // if there were any results from carving, add the unallocated carving event to the reports list.\n                totals.totalItemsRecovered.addAndGet(carvedItems.size());\n                context.addFilesToJob(new ArrayList<>(carvedItems));\n                services.fireModuleContentEvent(new ModuleContentEvent(carvedItems.get(0))); // fire an event to update the tree\n            }\n        } catch (IOException ex) {\n            totals.totalItemsWithErrors.incrementAndGet();\n            logger.log(Level.SEVERE, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.msg\", file.getName()), ex);\n            MessageNotifyUtil.Notify.error(PhotoRecCarverIngestModuleFactory.getModuleName(), NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.error.msg\", file.getName()));\n            return IngestModule.ProcessResult.ERROR;\n        } finally {\n            if (null != tempFilePath && Files.exists(tempFilePath)) {\n                // Get rid of the unallocated space file.\n                tempFilePath.toFile().delete();\n            }\n        }\n        return IngestModule.ProcessResult.OK;\n\n    }","commit_id":"4c0a230fd67b4474ab25226ca6f2816831333a9b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void startUp(IngestJobContext context) throws IngestModule.IngestModuleException {\n        this.context = context;\n        this.services = IngestServices.getInstance();\n        this.jobId = this.context.getJobId();\n\n        // If the global unallocated space processing setting and the module\n        // process unallocated space only setting are not in sych, throw an \n        // exception. Although the result would not be incorrect, it would be\n        // unfortunate for the user to get an accidental no-op for this module. \n        if (!this.context.processingUnallocatedSpace()) {\n            throw new IngestModule.IngestModuleException(NbBundle.getMessage(this.getClass(), \"unallocatedSpaceProcessingSettingsError.message\"));\n        }\n\n        this.rootOutputDirPath = PhotoRecCarverFileIngestModule.createModuleOutputDirectoryForCase();\n\n        Path execName = Paths.get(PHOTOREC_DIRECTORY, PHOTOREC_EXECUTABLE);\n        executableFile = locateExecutable(execName.toString());\n\n        if (PhotoRecCarverFileIngestModule.refCounter.incrementAndGet(this.jobId) == 1) {\n            try {\n                // The first instance creates an output subdirectory with a date and time stamp\n                DateFormat dateFormat = new SimpleDateFormat(\"MM-dd-yyyy-HH-mm-ss-SSSS\");  // NON-NLS\n                Date date = new Date();\n                String folder = this.context.getDataSource().getId() + \"_\" + dateFormat.format(date);\n                Path outputDirPath = Paths.get(this.rootOutputDirPath.toAbsolutePath().toString(), folder);\n                Files.createDirectories(outputDirPath);\n\n                // A temp subdirectory is also created as a location for writing unallocated space files to disk.\n                Path tempDirPath = Paths.get(outputDirPath.toString(), PhotoRecCarverFileIngestModule.TEMP_DIR_NAME);\n                Files.createDirectory(tempDirPath);\n\n                // Save the directories for the current job.\n                PhotoRecCarverFileIngestModule.pathsByJob.put(this.jobId, new WorkingPaths(outputDirPath, tempDirPath));\n                \n                // Initialize job totals\n                initTotalsForIngestJob(jobId);\n            } catch (SecurityException | IOException | UnsupportedOperationException ex) {\n                throw new IngestModule.IngestModuleException(NbBundle.getMessage(this.getClass(), \"cannotCreateOutputDir.message\", ex.getLocalizedMessage()));\n            }\n        }\n    }","id":47524,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void startUp(IngestJobContext context) throws IngestModule.IngestModuleException {\n        this.context = context;\n        this.services = IngestServices.getInstance();\n        this.jobId = this.context.getJobId();\n\n        // If the global unallocated space processing setting and the module\n        // process unallocated space only setting are not in sych, throw an \n        // exception. Although the result would not be incorrect, it would be\n        // unfortunate for the user to get an accidental no-op for this module. \n        if (!this.context.processingUnallocatedSpace()) {\n            throw new IngestModule.IngestModuleException(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"unallocatedSpaceProcessingSettingsError.message\"));\n        }\n\n        this.rootOutputDirPath = PhotoRecCarverFileIngestModule.createModuleOutputDirectoryForCase();\n\n        Path execName = Paths.get(PHOTOREC_DIRECTORY, PHOTOREC_EXECUTABLE);\n        executableFile = locateExecutable(execName.toString());\n\n        if (PhotoRecCarverFileIngestModule.refCounter.incrementAndGet(this.jobId) == 1) {\n            try {\n                // The first instance creates an output subdirectory with a date and time stamp\n                DateFormat dateFormat = new SimpleDateFormat(\"MM-dd-yyyy-HH-mm-ss-SSSS\");  // NON-NLS\n                Date date = new Date();\n                String folder = this.context.getDataSource().getId() + \"_\" + dateFormat.format(date);\n                Path outputDirPath = Paths.get(this.rootOutputDirPath.toAbsolutePath().toString(), folder);\n                Files.createDirectories(outputDirPath);\n\n                // A temp subdirectory is also created as a location for writing unallocated space files to disk.\n                Path tempDirPath = Paths.get(outputDirPath.toString(), PhotoRecCarverFileIngestModule.TEMP_DIR_NAME);\n                Files.createDirectory(tempDirPath);\n\n                // Save the directories for the current job.\n                PhotoRecCarverFileIngestModule.pathsByJob.put(this.jobId, new WorkingPaths(outputDirPath, tempDirPath));\n\n                // Initialize job totals\n                initTotalsForIngestJob(jobId);\n            } catch (SecurityException | IOException | UnsupportedOperationException ex) {\n                throw new IngestModule.IngestModuleException(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"cannotCreateOutputDir.message\", ex.getLocalizedMessage()));\n            }\n        }\n    }","commit_id":"4c0a230fd67b4474ab25226ca6f2816831333a9b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Finds the root Volume or Image of the AbstractFile passed in.\n     *\n     * @param file The file we want to find the root parent for\n     * @return The ID of the root parent Volume or Image\n     */\n    private static long getRootId(AbstractFile file) {\n        long id = -1;\n        Content parent = null;\n        try {\n            parent = file.getParent();\n            while (parent != null) {\n                if (parent instanceof Volume || parent instanceof Image) {\n                    id = parent.getId();\n                    break;\n                }\n                parent = parent.getParent();\n            }\n        }\n        catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"PhotoRec carver exception while trying to get parent of AbstractFile.\", ex); //NON-NLS\n        }\n        return id;\n    }","id":47525,"modified_method":"/**\n     * Finds the root Volume or Image of the AbstractFile passed in.\n     *\n     * @param file The file we want to find the root parent for\n     * @return The ID of the root parent Volume or Image\n     */\n    private static long getRootId(AbstractFile file) {\n        long id = -1;\n        Content parent = null;\n        try {\n            parent = file.getParent();\n            while (parent != null) {\n                if (parent instanceof Volume || parent instanceof Image) {\n                    id = parent.getId();\n                    break;\n                }\n                parent = parent.getParent();\n            }\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.parentAbstractFile.error\"), ex);\n        }\n        return id;\n    }","commit_id":"4c0a230fd67b4474ab25226ca6f2816831333a9b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void shutDown() {\n        if (this.context != null && refCounter.decrementAndGet(this.jobId) == 0) {\n            try {\n                // The last instance of this module for an ingest job cleans out \n                // the working paths map entry for the job and deletes the temp dir.\n                WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.remove(this.jobId);\n                FileUtil.deleteDir(new File(paths.getTempDirPath().toString()));\n                postSummary(jobId);\n            } \n            catch (SecurityException ex) {\n                logger.log(Level.SEVERE, \"Error shutting down PhotoRec carver module\", ex); // NON-NLS\n            }\n        }\n    }","id":47526,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void shutDown() {\n        if (this.context != null && refCounter.decrementAndGet(this.jobId) == 0) {\n            try {\n                // The last instance of this module for an ingest job cleans out \n                // the working paths map entry for the job and deletes the temp dir.\n                WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.remove(this.jobId);\n                FileUtil.deleteDir(new File(paths.getTempDirPath().toString()));\n                postSummary(jobId);\n            } catch (SecurityException ex) {\n                logger.log(Level.SEVERE, NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.shutdown.error\"), ex);\n            }\n        }\n    }","commit_id":"4c0a230fd67b4474ab25226ca6f2816831333a9b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static synchronized void postSummary(long jobId) {\n        IngestJobTotals jobTotals = totalsForIngestJobs.remove(jobId);\n\n        StringBuilder detailsSb = new StringBuilder();\n        //details\n        detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\"); //NON-NLS\n\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                 .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.numberOfCarved\"))\n                 .append(\"<\/td>\"); //NON-NLS\n        detailsSb.append(\"<td>\").append(jobTotals.totalItemsRecovered.get()).append(\"<\/td><\/tr>\"); //NON-NLS\n\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                 .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.totalWritetime\"))\n                 .append(\"<\/td><td>\").append(jobTotals.totalWritetime.get()).append(\"<\/td><\/tr>\\n\"); //NON-NLS\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                 .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.totalParsetime\"))\n                 .append(\"<\/td><td>\").append(jobTotals.totalParsetime.get()).append(\"<\/td><\/tr>\\n\"); //NON-NLS\n        detailsSb.append(\"<\/table>\"); //NON-NLS\n\n        IngestServices.getInstance().postMessage(IngestMessage.createMessage(\n                IngestMessage.MessageType.INFO,\n                PhotoRecCarverIngestModuleFactory.getModuleName(),\n                NbBundle.getMessage(PhotoRecCarverFileIngestModule.class,\n                        \"PhotoRecIngestModule.complete.photoRecResults\"),\n                detailsSb.toString()));\n\n    }","id":47527,"modified_method":"private static synchronized void postSummary(long jobId) {\n        IngestJobTotals jobTotals = totalsForIngestJobs.remove(jobId);\n\n        StringBuilder detailsSb = new StringBuilder();\n        //details\n        detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\"); //NON-NLS\n\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.numberOfCarved\"))\n                .append(\"<\/td>\"); //NON-NLS\n        detailsSb.append(\"<td>\").append(jobTotals.totalItemsRecovered.get()).append(\"<\/td><\/tr>\"); //NON-NLS\n\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.numberOfErrors\"))\n                .append(\"<\/td>\"); //NON-NLS\n        detailsSb.append(\"<td>\").append(jobTotals.totalItemsWithErrors.get()).append(\"<\/td><\/tr>\"); //NON-NLS\n\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.totalWritetime\"))\n                .append(\"<\/td><td>\").append(jobTotals.totalWritetime.get()).append(\"<\/td><\/tr>\\n\"); //NON-NLS\n        detailsSb.append(\"<tr><td>\") //NON-NLS\n                .append(NbBundle.getMessage(PhotoRecCarverFileIngestModule.class, \"PhotoRecIngestModule.complete.totalParsetime\"))\n                .append(\"<\/td><td>\").append(jobTotals.totalParsetime.get()).append(\"<\/td><\/tr>\\n\"); //NON-NLS\n        detailsSb.append(\"<\/table>\"); //NON-NLS\n\n        IngestServices.getInstance().postMessage(IngestMessage.createMessage(\n                IngestMessage.MessageType.INFO,\n                PhotoRecCarverIngestModuleFactory.getModuleName(),\n                NbBundle.getMessage(PhotoRecCarverFileIngestModule.class,\n                        \"PhotoRecIngestModule.complete.photoRecResults\"),\n                detailsSb.toString()));\n\n    }","commit_id":"4c0a230fd67b4474ab25226ca6f2816831333a9b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void performInspectionsWithProgress(final AnalysisScope scope, final InspectionManager manager) {\n    try {\n      myProgressIndicator = ProgressManager.getInstance().getProgressIndicator();\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          final PsiManager psiManager = PsiManager.getInstance(myProject);\n          try {\n            psiManager.startBatchFilesProcessingMode();\n            ((RefManagerImpl)getRefManager()).inspectionReadActionStarted();\n            EntryPointsManager.getInstance(getProject()).resolveEntryPoints(getRefManager());\n            List<InspectionTool> needRepeatSearchRequest = new ArrayList<InspectionTool>();\n            runTools(needRepeatSearchRequest, scope, manager);\n          }\n          catch (ProcessCanceledException e) {\n            ((InspectionManagerEx)manager).closeRunningContext(GlobalInspectionContextImpl.this);\n            for (Set<Pair<InspectionTool, InspectionProfile>> tools : myTools.values()) {\n              for (Pair<InspectionTool, InspectionProfile> tool : tools) {\n                tool.first.finalCleanup();\n              }\n            }\n            myTools.clear();\n            cleanup();\n            throw e;\n          } catch (Exception e){\n            LOG.error(e);\n          }\n          finally {\n            psiManager.finishBatchFilesProcessingMode();\n          }\n        }\n      });\n    }\n    finally {\n      if (myRefManager != null) {\n        ((RefManagerImpl)getRefManager()).inspectionReadActionFinished();\n      }\n    }\n  }","id":47528,"modified_method":"private void performInspectionsWithProgress(final AnalysisScope scope, final InspectionManager manager) {\n    try {\n      myProgressIndicator = ProgressManager.getInstance().getProgressIndicator();\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          final PsiManager psiManager = PsiManager.getInstance(myProject);\n          try {\n            psiManager.startBatchFilesProcessingMode();\n            ((RefManagerImpl)getRefManager()).inspectionReadActionStarted();\n            EntryPointsManager.getInstance(getProject()).resolveEntryPoints(getRefManager());\n            List<InspectionTool> needRepeatSearchRequest = new ArrayList<InspectionTool>();\n            runTools(needRepeatSearchRequest, scope, manager);\n          }\n          catch (ProcessCanceledException e) {\n            cleanup((InspectionManagerEx)manager);\n            throw e;\n          } catch (Exception e){\n            LOG.error(e);\n          }\n          finally {\n            psiManager.finishBatchFilesProcessingMode();\n          }\n        }\n      });\n    }\n    finally {\n      if (myRefManager != null) {\n        ((RefManagerImpl)getRefManager()).inspectionReadActionFinished();\n      }\n    }\n  }","commit_id":"4b715e4bc0476b34e33efbd8651eb20bd4b90d1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void close(boolean noSuspisiousCodeFound) {\n    if (!noSuspisiousCodeFound && (myView == null || myView.isRerun())) return;\n    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManager.getInstance(myProject);\n    managerEx.closeRunningContext(this);\n    managerEx.getUIOptions().save(myUIOptions);\n    getContentManager().removeContent(myContent);\n    for (Set<Pair<InspectionTool, InspectionProfile>> tools : myTools.values()) {\n      for (Pair<InspectionTool, InspectionProfile> tool : tools) {\n        tool.first.finalCleanup();\n      }\n    }\n    cleanup();\n    myView = null;\n  }","id":47529,"modified_method":"public void close(boolean noSuspisiousCodeFound) {\n    if (!noSuspisiousCodeFound && (myView == null || myView.isRerun())) return;\n    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManager.getInstance(myProject);\n    cleanup(managerEx);\n    managerEx.getUIOptions().save(myUIOptions);\n    getContentManager().removeContent(myContent);\n    myView = null;\n  }","commit_id":"4b715e4bc0476b34e33efbd8651eb20bd4b90d1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processProfileTools(final InspectionProfileWrapper inspectionProfile,\n                                   final Map<String, Set<InspectionTool>> tools,\n                                   final Map<String, Set<InspectionTool>> localTools) {\n    final InspectionTool[] usedTools = inspectionProfile.getInspectionTools();\n    final Set<InspectionTool> profileTools = new HashSet<InspectionTool>();\n    tools.put(inspectionProfile.getName(), profileTools);\n    final HashSet<InspectionTool> localProfileTools = new HashSet<InspectionTool>();\n    localTools.put(inspectionProfile.getName(), localProfileTools);\n    for (InspectionTool tool : usedTools) {\n      final String shortName = tool.getShortName();\n      final HighlightDisplayKey key = HighlightDisplayKey.find(shortName);\n      if (inspectionProfile.isToolEnabled(key)) {\n        tool.initialize(this);\n        Set<Pair<InspectionTool, InspectionProfile>> sertainTools = myTools.get(shortName);\n        if (sertainTools == null){\n          sertainTools = new HashSet<Pair<InspectionTool, InspectionProfile>>();\n          myTools.put(shortName, sertainTools);\n        }\n        sertainTools.add(Pair.create(tool, inspectionProfile.getInspectionProfile()));\n        if (tool instanceof LocalInspectionToolWrapper) {\n          localProfileTools.add(tool);\n          appendJobDescriptor(LOCAL_ANALYSIS);\n        }\n        else {\n          profileTools.add(tool);\n          JobDescriptor[] jobDescriptors = tool.getJobDescriptors();\n          for (JobDescriptor jobDescriptor : jobDescriptors) {\n            appendJobDescriptor(jobDescriptor);\n          }\n        }\n      }\n    }\n  }","id":47530,"modified_method":"private void processProfileTools(final InspectionProfileWrapper inspectionProfile,\n                                   final Map<String, Set<InspectionTool>> tools,\n                                   final Map<String, Set<InspectionTool>> localTools) {\n    final InspectionTool[] usedTools = inspectionProfile.getInspectionTools();\n    final Set<InspectionTool> profileTools = new TreeSet<InspectionTool>(new Comparator<InspectionTool>() {\n      public int compare(final InspectionTool tool1, final InspectionTool tool2) {\n        if (tool1.getShortName().equals(DeadCodeInspection.SHORT_NAME)) return -1;\n        if (tool2.getShortName().equals(DeadCodeInspection.SHORT_NAME)) return 1;\n        return tool1.getShortName().compareTo(tool2.getShortName());\n      }\n    });\n    tools.put(inspectionProfile.getName(), profileTools);\n    final HashSet<InspectionTool> localProfileTools = new HashSet<InspectionTool>();\n    localTools.put(inspectionProfile.getName(), localProfileTools);\n    for (InspectionTool tool : usedTools) {\n      final String shortName = tool.getShortName();\n      final HighlightDisplayKey key = HighlightDisplayKey.find(shortName);\n      if (inspectionProfile.isToolEnabled(key)) {\n        tool.initialize(this);\n        Set<Pair<InspectionTool, InspectionProfile>> sertainTools = myTools.get(shortName);\n        if (sertainTools == null){\n          sertainTools = new HashSet<Pair<InspectionTool, InspectionProfile>>();\n          myTools.put(shortName, sertainTools);\n        }\n        sertainTools.add(Pair.create(tool, inspectionProfile.getInspectionProfile()));\n        if (tool instanceof LocalInspectionToolWrapper) {\n          localProfileTools.add(tool);\n          appendJobDescriptor(LOCAL_ANALYSIS);\n        }\n        else {\n          profileTools.add(tool);\n          JobDescriptor[] jobDescriptors = tool.getJobDescriptors();\n          for (JobDescriptor jobDescriptor : jobDescriptors) {\n            appendJobDescriptor(jobDescriptor);\n          }\n        }\n      }\n    }\n  }","commit_id":"4b715e4bc0476b34e33efbd8651eb20bd4b90d1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void runTools(final List<InspectionTool> needRepeatSearchRequest, final AnalysisScope scope, final InspectionManager manager) {\n    final HashMap<String, Set<InspectionTool>> usedTools = new HashMap<String, Set<InspectionTool>>();\n    final Map<String, Set<InspectionTool>> localTools = new HashMap<String, Set<InspectionTool>>();\n    initializeTools(scope, usedTools, localTools);\n    final Set<Pair<InspectionTool, InspectionProfile>> deadCodeTools = myTools.get(DeadCodeInspection.SHORT_NAME);\n    if (deadCodeTools != null) {\n      for (Pair<InspectionTool, InspectionProfile> deadCodeTool : deadCodeTools) {\n        processGlobalTool(deadCodeTool.first, scope, manager, needRepeatSearchRequest); //need to initialize entry points first\n      }\n    }\n    for (Set<InspectionTool> tools : usedTools.values()) {\n      for (InspectionTool tool : tools) {\n        if (!Comparing.strEqual(tool.getShortName(), DeadCodeInspection.SHORT_NAME)) {\n          processGlobalTool(tool, scope, manager, needRepeatSearchRequest);\n        }\n      }\n    }\n    performPostRunFindUsages(needRepeatSearchRequest, manager);\n    if (RUN_GLOBAL_TOOLS_ONLY) return;\n    final Set<InspectionTool> currentProfileLocalTools = localTools.get(getCurrentProfile().getName());\n    if (RUN_WITH_EDITOR_PROFILE || currentProfileLocalTools != null && !currentProfileLocalTools.isEmpty()) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final InspectionProjectProfileManager profileManager = InspectionProjectProfileManager.getInstance(myProject);\n      scope.accept(new PsiRecursiveElementVisitor() {\n        public void visitReferenceExpression(PsiReferenceExpression expression) {\n        }\n\n        @Override               \n        public void visitFile(PsiFile file) {\n          InspectionProfile profile;\n          if (RUN_WITH_EDITOR_PROFILE) {\n            profile = profileManager.getInspectionProfile(file);\n          }\n          else {\n            profile = getCurrentProfile();\n          }\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile != null) {\n            incrementJobDoneAmount(LOCAL_ANALYSIS, VfsUtil.calcRelativeToProjectPath(virtualFile, myProject));\n          }\n          final Set<InspectionTool> tools = localTools.get(profile.getName());\n          for (InspectionTool tool : tools) {\n            try {\n              ((LocalInspectionToolWrapper)tool).processFile(file, true, manager);\n            }\n            catch (ProcessCanceledException e) {\n              throw e;\n            }\n            catch (Exception e) {\n              //LOG.error(\"Problem file: \" + file.getVirtualFile().getPresentableUrl());\n              LOG.error(e);\n            }\n          }\n          psiManager.dropResolveCaches();\n        }\n      });\n    }\n  }","id":47531,"modified_method":"private void runTools(final List<InspectionTool> needRepeatSearchRequest, final AnalysisScope scope, final InspectionManager manager) {\n    final HashMap<String, Set<InspectionTool>> usedTools = new HashMap<String, Set<InspectionTool>>();\n    final Map<String, Set<InspectionTool>> localTools = new HashMap<String, Set<InspectionTool>>();\n    initializeTools(scope, usedTools, localTools);\n    for (Set<InspectionTool> tools : usedTools.values()) {\n      for (InspectionTool tool : tools) {\n        try {\n          if (tool.isGraphNeeded()) {\n            ((RefManagerImpl)tool.getRefManager()).findAllDeclarations();\n          }\n          tool.runInspection(scope, manager);\n          if (tool.queryExternalUsagesRequests(manager)) {\n            needRepeatSearchRequest.add(tool);\n          }\n        }\n        catch (ProcessCanceledException e) {\n          throw e;\n        }\n        catch (Exception e) {\n          LOG.error(e);\n        }\n      }\n    }\n    performPostRunFindUsages(needRepeatSearchRequest, manager);\n    if (RUN_GLOBAL_TOOLS_ONLY) return;\n    final Set<InspectionTool> currentProfileLocalTools = localTools.get(getCurrentProfile().getName());\n    if (RUN_WITH_EDITOR_PROFILE || currentProfileLocalTools != null && !currentProfileLocalTools.isEmpty()) {\n      final PsiManager psiManager = PsiManager.getInstance(myProject);\n      final InspectionProjectProfileManager profileManager = InspectionProjectProfileManager.getInstance(myProject);\n      scope.accept(new PsiRecursiveElementVisitor() {\n        public void visitReferenceExpression(PsiReferenceExpression expression) {\n        }\n\n        @Override               \n        public void visitFile(PsiFile file) {\n          InspectionProfile profile;\n          if (RUN_WITH_EDITOR_PROFILE) {\n            profile = profileManager.getInspectionProfile(file);\n          }\n          else {\n            profile = getCurrentProfile();\n          }\n          final VirtualFile virtualFile = file.getVirtualFile();\n          if (virtualFile != null) {\n            incrementJobDoneAmount(LOCAL_ANALYSIS, VfsUtil.calcRelativeToProjectPath(virtualFile, myProject));\n          }\n          final Set<InspectionTool> tools = localTools.get(profile.getName());\n          for (InspectionTool tool : tools) {\n            try {\n              ((LocalInspectionToolWrapper)tool).processFile(file, true, manager);\n            }\n            catch (ProcessCanceledException e) {\n              throw e;\n            }\n            catch (Exception e) {\n              //LOG.error(\"Problem file: \" + file.getVirtualFile().getPresentableUrl());\n              LOG.error(e);\n            }\n          }\n          psiManager.dropResolveCaches();\n        }\n      });\n    }\n  }","commit_id":"4b715e4bc0476b34e33efbd8651eb20bd4b90d1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void flush() throws IOException {\n        synchronized (persistedHead) {\n            RecordId before = persistedHead.get();\n            RecordId after = head.get();\n            boolean cleanup = cleanupNeeded.getAndSet(false);\n            if (cleanup || !after.equals(before)) {\n                // needs to happen outside the synchronization block below to\n                // avoid a deadlock with another thread flushing the writer\n                tracker.getWriter().flush();\n\n                // needs to happen outside the synchronization block below to\n                // prevent the flush from stopping concurrent reads and writes\n                writer.flush();\n\n                synchronized (this) {\n                    log.debug(\"TarMK journal update {} -> {}\", before, after);\n                    journalFile.writeBytes(after.toString10() + \" root\\n\");\n                    journalFile.getChannel().force(false);\n                    persistedHead.set(after);\n                }\n\n                // Needs to happen outside the synchronization block above to\n                // prevent the flush from stopping concurrent reads and writes\n                // by the persisted compaction map. See OAK-3264\n                if (cleanup) {\n                    // Explicitly give up reference to the previous root state\n                    // otherwise they would block cleanup. See OAK-3347\n                    before = null;\n                    after = null;\n                    cleanup();\n                }\n            }\n            synchronized (this) {\n                // remove all obsolete tar generations\n                Iterator<File> iterator = toBeRemoved.iterator();\n                while (iterator.hasNext()) {\n                    File file = iterator.next();\n                    log.debug(\"TarMK GC: Attempting to remove old file {}\",\n                            file);\n                    if (!file.exists() || file.delete()) {\n                        log.debug(\"TarMK GC: Removed old file {}\", file);\n                        iterator.remove();\n                    }\n                }\n            }\n        }\n    }","id":47532,"modified_method":"public void flush() throws IOException {\n        synchronized (persistedHead) {\n            RecordId before = persistedHead.get();\n            RecordId after = head.get();\n            boolean cleanup = cleanupNeeded.getAndSet(false);\n\n            if (cleanup || !after.equals(before)) {\n                // needs to happen outside the synchronization block below to\n                // avoid a deadlock with another thread flushing the writer\n                tracker.getWriter().flush();\n\n                // needs to happen outside the synchronization block below to\n                // prevent the flush from stopping concurrent reads and writes\n                writer.flush();\n\n                synchronized (this) {\n                    log.debug(\"TarMK journal update {} -> {}\", before, after);\n                    journalFile.writeBytes(after.toString10() + \" root\\n\");\n                    journalFile.getChannel().force(false);\n                    persistedHead.set(after);\n                }\n\n                // Needs to happen outside the synchronization block above to\n                // prevent the flush from stopping concurrent reads and writes\n                // by the persisted compaction map. See OAK-3264\n                if (cleanup) {\n                    // Explicitly give up reference to the previous root state\n                    // otherwise they would block cleanup. See OAK-3347\n                    before = null;\n                    after = null;\n                    pendingRemove.addAll(cleanup());\n                }\n            }\n\n            // remove all obsolete tar generations\n            Iterator<File> iterator = pendingRemove.iterator();\n            while (iterator.hasNext()) {\n                File file = iterator.next();\n                log.debug(\"TarMK GC: Attempting to remove old file {}\",\n                        file);\n                if (!file.exists() || file.delete()) {\n                    log.debug(\"TarMK GC: Removed old file {}\", file);\n                    iterator.remove();\n                } else {\n                    log.warn(\"TarMK GC: Failed to remove old file {}. Will retry later.\", file);\n                }\n            }\n        }\n    }","commit_id":"2ce702d814b9c86e1b4d7c5d6e9d94f80c147f5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Map<UUID, List<UUID>> getTarGraph(String fileName) throws IOException {\n        for (TarReader reader : readers) {\n            if (fileName.equals(reader.getFile().getName())) {\n                Map<UUID, List<UUID>> graph = Maps.newHashMap();\n                for (UUID uuid : reader.getUUIDs()) {\n                    graph.put(uuid, null);\n                }\n                Map<UUID, List<UUID>> g = reader.getGraph();\n                if (g != null) {\n                    graph.putAll(g);\n                }\n                return graph;\n            }\n        }\n        return emptyMap();\n    }","id":47533,"modified_method":"public Map<UUID, List<UUID>> getTarGraph(String fileName) throws IOException {\n        for (TarReader reader : readers) {\n            if (fileName.equals(reader.getFile().getName())) {\n                Map<UUID, List<UUID>> graph = newHashMap();\n                for (UUID uuid : reader.getUUIDs()) {\n                    graph.put(uuid, null);\n                }\n                Map<UUID, List<UUID>> g = reader.getGraph();\n                if (g != null) {\n                    graph.putAll(g);\n                }\n                return graph;\n            }\n        }\n        return emptyMap();\n    }","commit_id":"2ce702d814b9c86e1b4d7c5d6e9d94f80c147f5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Runs garbage collection on the segment level, which could write new\n     * generations of tar files. It checks which segments are still reachable,\n     * and throws away those that are not.\n     * <p>\n     * A new generation of a tar file is created (and segments are only\n     * discarded) if doing so releases more than 25% of the space in a tar file.\n     */\n    public void cleanup() throws IOException {\n        Stopwatch watch = Stopwatch.createStarted();\n        long initialSize = size();\n        CompactionMap cm = tracker.getCompactionMap();\n        Set<UUID> cleanedIds = newHashSet();\n\n        synchronized (this) {\n            gcMonitor.info(\"TarMK revision cleanup started. Current repository size {}\",\n                    humanReadableByteCount(initialSize));\n\n            newWriter();\n            tracker.clearCache();\n\n            // Suggest to the JVM that now would be a good time\n            // to clear stale weak references in the SegmentTracker\n            System.gc();\n\n            Set<UUID> ids = newHashSet();\n            for (SegmentId id : tracker.getReferencedSegmentIds()) {\n                ids.add(new UUID(\n                        id.getMostSignificantBits(),\n                        id.getLeastSignificantBits()));\n            }\n            writer.collectReferences(ids);\n\n            List<TarReader> list = newArrayListWithCapacity(readers.size());\n            for (TarReader reader : readers) {\n                TarReader cleaned = reader.cleanup(ids, cm, cleanedIds);\n                if (cleaned == reader) {\n                    list.add(reader);\n                } else {\n                    if (cleaned != null) {\n                        list.add(cleaned);\n                    }\n                    closeAndLogOnFail(reader);\n                    File file = reader.getFile();\n                    gcMonitor.info(\"TarMK revision cleanup reclaiming {}\", file.getName());\n                    toBeRemoved.addLast(file);\n                }\n            }\n            readers = list;\n        }\n\n        // Do this outside sync to avoid deadlock with SegmentId.getSegment(). See OAK-3179\n        cm.remove(cleanedIds);\n        long finalSize = size();\n        gcMonitor.cleaned(initialSize - finalSize, finalSize);\n        gcMonitor.info(\"TarMK revision cleanup completed in {}. Post cleanup size is {} \" +\n                \"and space reclaimed {}. Compaction map weight/depth is {}/{}.\", watch,\n                humanReadableByteCount(finalSize),\n                humanReadableByteCount(initialSize - finalSize),\n                humanReadableByteCount(sum(cm.getEstimatedWeights())),\n                cm.getDepth());\n    }","id":47534,"modified_method":"/**\n     * Runs garbage collection on the segment level, which could write new\n     * generations of tar files. It checks which segments are still reachable,\n     * and throws away those that are not.\n     * <p>\n     * A new generation of a tar file is created (and segments are only\n     * discarded) if doing so releases more than 25% of the space in a tar file.\n     */\n    public List<File> cleanup() throws IOException {\n        Stopwatch watch = Stopwatch.createStarted();\n        long initialSize = size();\n        Set<UUID> referencedIds = newHashSet();\n        Map<TarReader, TarReader> cleaned = newLinkedHashMap();\n\n        synchronized (this) {\n            gcMonitor.info(\"TarMK revision cleanup started. Current repository size {}\",\n                    humanReadableByteCount(initialSize));\n\n            newWriter();\n            tracker.clearCache();\n\n            // Suggest to the JVM that now would be a good time\n            // to clear stale weak references in the SegmentTracker\n            System.gc();\n\n            for (SegmentId id : tracker.getReferencedSegmentIds()) {\n                referencedIds.add(id.asUUID());\n            }\n            writer.collectReferences(referencedIds);\n            for (TarReader reader : readers) {\n                cleaned.put(reader, null);\n            }\n        }\n\n        // Do actual cleanup outside of the lock to prevent blocking\n        // concurrent writers for a long time\n        CompactionMap cm = tracker.getCompactionMap();\n        LinkedList<File> toRemove = newLinkedList();\n        Set<UUID> cleanedIds = newHashSet();\n        for (TarReader reader : cleaned.keySet()) {\n            TarReader newReader = reader.cleanup(referencedIds, cm, cleanedIds);\n            cleaned.put(reader, newReader);\n        }\n\n        List<TarReader> oldReaders = newArrayList();\n        synchronized (this) {\n            // Replace current list of reader with the cleaned readers taking care not to lose\n            // any new reader that might have come in through concurrent calls to newWriter()\n            List<TarReader> newReaders = newArrayList();\n            for (TarReader reader : readers) {\n                if (cleaned.containsKey(reader)) {\n                    TarReader newReader = cleaned.get(reader);\n                    if (newReader != null) {\n                        newReaders.add(newReader);\n                    }\n                    if (newReader != reader) {\n                        oldReaders.add(reader);\n                    }\n                } else {\n                    newReaders.add(reader);\n                }\n            }\n            readers = newReaders;\n        }\n\n        // Close old readers *after* setting readers to the new readers to avoid accessing\n        // a closed reader from readSegment()\n        for (TarReader oldReader : oldReaders) {\n            closeAndLogOnFail(oldReader);\n            File file = oldReader.getFile();\n            gcMonitor.info(\"TarMK revision cleanup marking file for deletion: {}\", file.getName());\n            toRemove.addLast(file);\n        }\n\n        cm.remove(cleanedIds);\n        long finalSize = size();\n        gcMonitor.cleaned(initialSize - finalSize, finalSize);\n        gcMonitor.info(\"TarMK revision cleanup completed in {}. Post cleanup size is {} \" +\n                \"and space reclaimed {}. Compaction map weight/depth is {}/{}.\", watch,\n                humanReadableByteCount(finalSize),\n                humanReadableByteCount(initialSize - finalSize),\n                humanReadableByteCount(sum(cm.getEstimatedWeights())),\n                cm.getDepth());\n        return toRemove;\n    }","commit_id":"2ce702d814b9c86e1b4d7c5d6e9d94f80c147f5f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n   * Creates a new instance of {@link CreateDirectoryOptions} from {@link CreateDirectoryTOptions}.\n   * The option of permission status is constructed with the username obtained from thrift\n   * transport.\n   *\n   * @param tOptions the {@link CreateDirectoryTOptions} to use\n   * @return the {@link CreateDirectoryOptions} from {@link CreateDirectoryTOptions}\n   * @throws IOException if an I/O error occurs\n   */\n  public static CreateDirectoryOptions fromTOptions(CreateDirectoryTOptions tOptions)\n      throws IOException {\n    CreateDirectoryOptions options = new CreateDirectoryOptions();\n    options.setAllowExists(tOptions.isAllowExists());\n    options.setPersisted(tOptions.isPersisted());\n    options.setRecursive(tOptions.isRecursive());\n    options.setPermissionStatus(\n        PermissionStatus.defaults().setUserFromThriftClient(MasterContext.getConf()));\n    return options;\n  }","id":47535,"modified_method":"/**\n   * Creates a new instance of {@link CreateDirectoryOptions} from {@link CreateDirectoryTOptions}.\n   * The option of permission status is constructed with the username obtained from thrift\n   * transport.\n   *\n   * @param tOptions the {@link CreateDirectoryTOptions} to use\n   * @return the {@link CreateDirectoryOptions} from {@link CreateDirectoryTOptions}\n   * @throws IOException if an I/O error occurs\n   */\n  public static CreateDirectoryOptions fromTOptions(CreateDirectoryTOptions tOptions)\n      throws IOException {\n    CreateDirectoryOptions options = new CreateDirectoryOptions()\n        .setAllowExists(tOptions.isAllowExists())\n        .setPersisted(tOptions.isPersisted())\n        .setRecursive(tOptions.isRecursive())\n        .setPermissionStatus(\n            PermissionStatus.defaults().setUserFromThriftClient(MasterContext.getConf()));\n    return options;\n  }","commit_id":"ab82cf802596960c2a296a34124189e009971af9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link CreateFileOptions} from {@link CreateFileTOptions}. The\n   * option of permission status is constructed with the username obtained from thrift transport.\n   *\n   * @param tOptions the {@link CreateFileTOptions} to use\n   * @return the {@link CreateFileOptions} from {@link CreateFileTOptions}\n   * @throws IOException if an I/O error occurs\n   */\n  public static CreateFileOptions fromTOptions(CreateFileTOptions tOptions) throws IOException {\n    CreateFileOptions options = new CreateFileOptions();\n    options.setBlockSizeBytes(tOptions.getBlockSizeBytes());\n    options.setPersisted(tOptions.isPersisted());\n    options.setRecursive(tOptions.isRecursive());\n    options.setTtl(tOptions.getTtl());\n    options.setPermissionStatus(\n        PermissionStatus.defaults().setUserFromThriftClient(MasterContext.getConf()));\n    return options;\n  }","id":47536,"modified_method":"/**\n   * Creates a new instance of {@link CreateFileOptions} from {@link CreateFileTOptions}. The\n   * option of permission status is constructed with the username obtained from thrift transport.\n   *\n   * @param tOptions the {@link CreateFileTOptions} to use\n   * @return the {@link CreateFileOptions} from {@link CreateFileTOptions}\n   * @throws IOException if an I/O error occurs\n   */\n  public static CreateFileOptions fromTOptions(CreateFileTOptions tOptions) throws IOException {\n    CreateFileOptions options = new CreateFileOptions()\n        .setBlockSizeBytes(tOptions.getBlockSizeBytes())\n        .setPersisted(tOptions.isPersisted())\n        .setRecursive(tOptions.isRecursive())\n        .setTtl(tOptions.getTtl())\n        .setPermissionStatus(\n            PermissionStatus.defaults().setUserFromThriftClient(MasterContext.getConf()));\n    return options;\n  }","commit_id":"ab82cf802596960c2a296a34124189e009971af9","url":"https://github.com/amplab/tachyon"},{"original_method":"static TraversalResult createNotFoundResult(Inode inode, int index, List<Inode> persisted) {\n      return new TraversalResult(false, index, inode, persisted);\n    }","id":47537,"modified_method":"static TraversalResult createNotFoundResult(Inode inode, int index, List<Inode> toBePersisted) {\n      return new TraversalResult(false, index, inode, toBePersisted);\n    }","commit_id":"5ee6cb4c84218b8a9b2df41bcdabe4e8cff55dee","url":"https://github.com/amplab/tachyon"},{"original_method":"List<Inode> getPersisted() {\n      return mPersisted;\n    }","id":47538,"modified_method":"/**\n     * @return a list of existing Inodes that are found to be persisted during traversal.\n     */\n    List<Inode> getToBePersisted() {\n      return mToBePersisted;\n    }","commit_id":"5ee6cb4c84218b8a9b2df41bcdabe4e8cff55dee","url":"https://github.com/amplab/tachyon"},{"original_method":"private TraversalResult traverseToInode(String[] pathComponents, boolean persist)\n      throws InvalidPathException, IOException {\n    List<Inode> persisted = Lists.newArrayList();\n\n    if (pathComponents == null) {\n      throw new InvalidPathException(\"passed-in pathComponents is null\");\n    } else if (pathComponents.length == 0) {\n      throw new InvalidPathException(\"passed-in pathComponents is empty\");\n    } else if (pathComponents.length == 1) {\n      if (pathComponents[0].equals(\"\")) {\n        return TraversalResult.createFoundResult(mRoot, persisted);\n      } else {\n        throw new InvalidPathException(\"File name starts with \" + pathComponents[0]);\n      }\n    }\n\n    Inode current = mRoot;\n\n    // iterate from 1, because 0 is root and it's already added\n    for (int i = 1; i < pathComponents.length; i ++) {\n      Inode next = ((InodeDirectory) current).getChild(pathComponents[i]);\n      if (next == null) {\n        // The user might want to create the nonexistent directories, so return the traversal result\n        // current inode with the last Inode taken, and the index of the first path component that\n        // couldn't be found.\n        return TraversalResult.createNotFoundResult(current, i, persisted);\n      } else if (next.isFile()) {\n        // The inode can't have any children. If this is the last path component, we're good.\n        // Otherwise, we can't traverse further, so we clean up and throw an exception.\n        if (i == pathComponents.length - 1) {\n          return TraversalResult.createFoundResult(next, persisted);\n        } else {\n          throw new InvalidPathException(\n              \"Traversal failed. Component \" + i + \"(\" + next.getName() + \") is a file\");\n        }\n      } else {\n        // next is a directory and keep navigating\n        if (persist && !next.isPersisted()) {\n          next.setPersisted(true);\n          persisted.add(next);\n          String ufsPath = mMountTable.resolve(getPath(next)).toString();\n          UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n          ufs.mkdirs(ufsPath, false);\n        }\n        current = next;\n      }\n    }\n    return TraversalResult.createFoundResult(current, persisted);\n  }","id":47539,"modified_method":"private TraversalResult traverseToInode(String[] pathComponents, boolean persist)\n      throws InvalidPathException {\n    List<Inode> persisted = Lists.newArrayList();\n\n    if (pathComponents == null) {\n      throw new InvalidPathException(\"passed-in pathComponents is null\");\n    } else if (pathComponents.length == 0) {\n      throw new InvalidPathException(\"passed-in pathComponents is empty\");\n    } else if (pathComponents.length == 1) {\n      if (pathComponents[0].equals(\"\")) {\n        return TraversalResult.createFoundResult(mRoot, persisted);\n      } else {\n        throw new InvalidPathException(\"File name starts with \" + pathComponents[0]);\n      }\n    }\n\n    Inode current = mRoot;\n\n    // iterate from 1, because 0 is root and it's already added\n    for (int i = 1; i < pathComponents.length; i ++) {\n      Inode next = ((InodeDirectory) current).getChild(pathComponents[i]);\n      if (next == null) {\n        // The user might want to create the nonexistent directories, so return the traversal result\n        // current inode with the last Inode taken, and the index of the first path component that\n        // couldn't be found.\n        return TraversalResult.createNotFoundResult(current, i, persisted);\n      } else if (next.isFile()) {\n        // The inode can't have any children. If this is the last path component, we're good.\n        // Otherwise, we can't traverse further, so we clean up and throw an exception.\n        if (i == pathComponents.length - 1) {\n          return TraversalResult.createFoundResult(next, persisted);\n        } else {\n          throw new InvalidPathException(\n              \"Traversal failed. Component \" + i + \"(\" + next.getName() + \") is a file\");\n        }\n      } else {\n        // next is a directory and keep navigating\n        if (persist && !next.isPersisted()) {\n          persisted.add(next);\n        }\n        current = next;\n      }\n    }\n    return TraversalResult.createFoundResult(current, persisted);\n  }","commit_id":"5ee6cb4c84218b8a9b2df41bcdabe4e8cff55dee","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a file or directory at path.\n   *\n   * @param path the path\n   * @param options method options\n   * @return a {@link CreatePathResult} representing the modified inodes and created inodes during\n   *         path creation\n   * @throws FileAlreadyExistsException when there is already a file at path if we want to create a\n   *         directory there\n   * @throws BlockInfoException when blockSizeBytes is invalid\n   * @throws InvalidPathException when path is invalid, for example, (1) when there is nonexistent\n   *         necessary parent directories and recursive is false, (2) when one of the necessary\n   *         parent directories is actually a file\n   */\n  public CreatePathResult createPath(TachyonURI path, CreatePathOptions options)\n      throws FileAlreadyExistsException, BlockInfoException, InvalidPathException, IOException {\n    if (path.isRoot()) {\n      LOG.info(\"FileAlreadyExistsException: \" + path);\n      throw new FileAlreadyExistsException(path.toString());\n    }\n    if (!options.isDirectory() && options.getBlockSizeBytes() < 1) {\n      throw new BlockInfoException(\"Invalid block size \" + options.getBlockSizeBytes());\n    }\n\n    LOG.debug(\"createPath {}\", FormatUtils.parametersToString(path));\n\n    String[] pathComponents = PathUtils.getPathComponents(path.getPath());\n    String name = path.getName();\n\n    String[] parentPath = new String[pathComponents.length - 1];\n    System.arraycopy(pathComponents, 0, parentPath, 0, parentPath.length);\n\n    TraversalResult traversalResult = traverseToInode(parentPath, options.isPersisted());\n    // pathIndex is the index into pathComponents where we start filling in the path from the inode.\n    int pathIndex = parentPath.length;\n    if (!traversalResult.isFound()) {\n      // Then the path component at errorInd k doesn't exist. If it's not recursive, we throw an\n      // exception here. Otherwise we add the remaining path components to the list of components\n      // to create.\n      if (!options.isRecursive()) {\n        final String msg = \"File \" + path + \" creation failed. Component \"\n            + traversalResult.getNonexistentPathIndex() + \"(\"\n            + parentPath[traversalResult.getNonexistentPathIndex()] + \") does not exist\";\n        LOG.info(\"InvalidPathException: \" + msg);\n        throw new InvalidPathException(msg);\n      } else {\n        // We will start filling at the index of the non-existing step found by the traversal.\n        pathIndex = traversalResult.getNonexistentPathIndex();\n      }\n    }\n\n    if (!traversalResult.getInode().isDirectory()) {\n      throw new InvalidPathException(\"Could not traverse to parent directory of path \" + path\n          + \". Component \" + pathComponents[pathIndex - 1] + \" is not a directory.\");\n    }\n    InodeDirectory currentInodeDirectory = (InodeDirectory) traversalResult.getInode();\n    List<Inode> createdInodes = Lists.newArrayList();\n    List<Inode> modifiedInodes = Lists.newArrayList();\n    if (pathIndex < parentPath.length || currentInodeDirectory.getChild(name) == null) {\n      // (1) There are components in parent paths that need to be created. Or\n      // (2) The last component of the path needs to be created.\n      // In these two cases, the last traversed Inode will be modified.\n      modifiedInodes.add(currentInodeDirectory);\n    }\n\n    // Fill in the directories that were missing.\n    for (int k = pathIndex; k < parentPath.length; k ++) {\n      Inode dir =\n          new InodeDirectory.Builder().setName(pathComponents[k])\n              .setId(mDirectoryIdGenerator.getNewDirectoryId())\n              .setParentId(currentInodeDirectory.getId())\n              .setPersisted(options.isPersisted())\n              .setCreationTimeMs(options.getOperationTimeMs()).build();\n      dir.setPinned(currentInodeDirectory.isPinned());\n      currentInodeDirectory.addChild(dir);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n      if (options.isPersisted()) {\n        String ufsPath = mMountTable.resolve(getPath(dir)).toString();\n        UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n        ufs.mkdirs(ufsPath, false);\n      }\n      createdInodes.add(dir);\n      mInodes.add(dir);\n      currentInodeDirectory = (InodeDirectory) dir;\n    }\n\n    // Create the final path component. First we need to make sure that there isn't already a file\n    // here with that name. If there is an existing file that is a directory and we're creating a\n    // directory, update persistence property of the directories if needed, otherwise, nothing needs\n    // to be done.\n    Inode lastInode = currentInodeDirectory.getChild(name);\n    if (lastInode != null) {\n      if (lastInode.isDirectory() && options.isDirectory()) {\n        if (!lastInode.isPersisted() && options.isPersisted()) {\n          lastInode.setPersisted(true);\n          traversalResult.getPersisted().add(lastInode);\n          String ufsPath = mMountTable.resolve(getPath(lastInode)).toString();\n          UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n          ufs.mkdirs(ufsPath, false);\n        }\n        return new CreatePathResult(modifiedInodes, createdInodes, traversalResult.getPersisted());\n      }\n      LOG.info(\"FileAlreadyExistsException: \" + path);\n      throw new FileAlreadyExistsException(path.toString());\n    }\n    if (options.isDirectory()) {\n      lastInode =\n          new InodeDirectory.Builder().setName(name)\n              .setId(mDirectoryIdGenerator.getNewDirectoryId())\n              .setParentId(currentInodeDirectory.getId()).setPersisted(options.isPersisted())\n              .build();\n      if (options.isPersisted()) {\n        String ufsPath = mMountTable.resolve(getPath(lastInode)).toString();\n        UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n        ufs.mkdirs(ufsPath, false);\n      }\n    } else {\n      lastInode =\n          new InodeFile.Builder().setBlockContainerId(mContainerIdGenerator.getNewContainerId())\n              .setBlockSizeBytes(options.getBlockSizeBytes()).setTTL(options.getTTL()).setName(name)\n              .setParentId(currentInodeDirectory.getId()).setPersisted(options.isPersisted())\n              .setCreationTimeMs(options.getOperationTimeMs()).build();\n      if (currentInodeDirectory.isPinned()) {\n        // Update set of pinned file ids.\n        mPinnedInodeFileIds.add(lastInode.getId());\n      }\n    }\n    lastInode.setPinned(currentInodeDirectory.isPinned());\n\n    createdInodes.add(lastInode);\n    mInodes.add(lastInode);\n    currentInodeDirectory.addChild(lastInode);\n    currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n\n    LOG.debug(\"createFile: File Created: {} parent: \", lastInode, currentInodeDirectory);\n    return new CreatePathResult(modifiedInodes, createdInodes, traversalResult.getPersisted());\n  }","id":47540,"modified_method":"/**\n   * Creates a file or directory at path.\n   *\n   * @param path the path\n   * @param options method options\n   * @return a {@link CreatePathResult} representing the modified inodes and created inodes during\n   *         path creation\n   * @throws FileAlreadyExistsException when there is already a file at path if we want to create a\n   *         directory there\n   * @throws BlockInfoException when blockSizeBytes is invalid\n   * @throws InvalidPathException when path is invalid, for example, (1) when there is nonexistent\n   *         necessary parent directories and recursive is false, (2) when one of the necessary\n   *         parent directories is actually a file\n   */\n  public CreatePathResult createPath(TachyonURI path, CreatePathOptions options)\n      throws FileAlreadyExistsException, BlockInfoException, InvalidPathException, IOException {\n    if (path.isRoot()) {\n      LOG.info(\"FileAlreadyExistsException: \" + path);\n      throw new FileAlreadyExistsException(path.toString());\n    }\n    if (!options.isDirectory() && options.getBlockSizeBytes() < 1) {\n      throw new BlockInfoException(\"Invalid block size \" + options.getBlockSizeBytes());\n    }\n\n    LOG.debug(\"createPath {}\", FormatUtils.parametersToString(path));\n\n    String[] pathComponents = PathUtils.getPathComponents(path.getPath());\n    String name = path.getName();\n\n    String[] parentPath = new String[pathComponents.length - 1];\n    System.arraycopy(pathComponents, 0, parentPath, 0, parentPath.length);\n\n    TraversalResult traversalResult = traverseToInode(parentPath, options.isPersisted());\n    // pathIndex is the index into pathComponents where we start filling in the path from the inode.\n    int pathIndex = parentPath.length;\n    if (!traversalResult.isFound()) {\n      // Then the path component at errorInd k doesn't exist. If it's not recursive, we throw an\n      // exception here. Otherwise we add the remaining path components to the list of components\n      // to create.\n      if (!options.isRecursive()) {\n        final String msg = \"File \" + path + \" creation failed. Component \"\n            + traversalResult.getNonexistentPathIndex() + \"(\"\n            + parentPath[traversalResult.getNonexistentPathIndex()] + \") does not exist\";\n        LOG.info(\"InvalidPathException: \" + msg);\n        throw new InvalidPathException(msg);\n      } else {\n        // We will start filling at the index of the non-existing step found by the traversal.\n        pathIndex = traversalResult.getNonexistentPathIndex();\n      }\n    }\n\n    if (!traversalResult.getInode().isDirectory()) {\n      throw new InvalidPathException(\"Could not traverse to parent directory of path \" + path\n          + \". Component \" + pathComponents[pathIndex - 1] + \" is not a directory.\");\n    }\n    InodeDirectory currentInodeDirectory = (InodeDirectory) traversalResult.getInode();\n    List<Inode> createdInodes = Lists.newArrayList();\n    List<Inode> modifiedInodes = Lists.newArrayList();\n    if (pathIndex < parentPath.length || currentInodeDirectory.getChild(name) == null) {\n      // (1) There are components in parent paths that need to be created. Or\n      // (2) The last component of the path needs to be created.\n      // In these two cases, the last traversed Inode will be modified.\n      modifiedInodes.add(currentInodeDirectory);\n    }\n\n    // Fill in the directories that were missing.\n    for (int k = pathIndex; k < parentPath.length; k ++) {\n      Inode dir =\n          new InodeDirectory.Builder().setName(pathComponents[k])\n              .setId(mDirectoryIdGenerator.getNewDirectoryId())\n              .setParentId(currentInodeDirectory.getId())\n              .setPersisted(options.isPersisted())\n              .setCreationTimeMs(options.getOperationTimeMs()).build();\n      dir.setPinned(currentInodeDirectory.isPinned());\n      currentInodeDirectory.addChild(dir);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n      if (options.isPersisted()) {\n        String ufsPath = mMountTable.resolve(getPath(dir)).toString();\n        UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n        ufs.mkdirs(ufsPath, false);\n      }\n      createdInodes.add(dir);\n      mInodes.add(dir);\n      currentInodeDirectory = (InodeDirectory) dir;\n    }\n\n    // Create the final path component. First we need to make sure that there isn't already a file\n    // here with that name. If there is an existing file that is a directory and we're creating a\n    // directory, update persistence property of the directories if needed, otherwise, nothing needs\n    // to be done.\n    Inode lastInode = currentInodeDirectory.getChild(name);\n    if (lastInode != null) {\n      if (lastInode.isDirectory() && options.isDirectory()) {\n        if (!lastInode.isPersisted() && options.isPersisted()) {\n          traversalResult.getToBePersisted().add(lastInode);\n        }\n      } else {\n        LOG.info(\"FileAlreadyExistsException: \" + path);\n        throw new FileAlreadyExistsException(path.toString());\n      }\n    } else {\n      if (options.isDirectory()) {\n        lastInode =\n            new InodeDirectory.Builder().setName(name)\n                .setId(mDirectoryIdGenerator.getNewDirectoryId())\n                .setParentId(currentInodeDirectory.getId()).setPersisted(options.isPersisted())\n                .build();\n        if (options.isPersisted()) {\n          String ufsPath = mMountTable.resolve(getPath(lastInode)).toString();\n          UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n          ufs.mkdirs(ufsPath, false);\n        }\n      } else {\n        lastInode =\n            new InodeFile.Builder().setBlockContainerId(mContainerIdGenerator.getNewContainerId())\n                .setBlockSizeBytes(options.getBlockSizeBytes()).setTTL(options.getTTL())\n                .setName(name).setParentId(currentInodeDirectory.getId())\n                .setPersisted(options.isPersisted()).setCreationTimeMs(options.getOperationTimeMs())\n                .build();\n        if (currentInodeDirectory.isPinned()) {\n          // Update set of pinned file ids.\n          mPinnedInodeFileIds.add(lastInode.getId());\n        }\n      }\n      lastInode.setPinned(currentInodeDirectory.isPinned());\n\n      createdInodes.add(lastInode);\n      mInodes.add(lastInode);\n      currentInodeDirectory.addChild(lastInode);\n      currentInodeDirectory.setLastModificationTimeMs(options.getOperationTimeMs());\n    }\n\n    for (Inode inode : traversalResult.getToBePersisted()) {\n      String ufsPath = mMountTable.resolve(getPath(inode)).toString();\n      UnderFileSystem ufs = UnderFileSystem.get(ufsPath, MasterContext.getConf());\n      ufs.mkdirs(ufsPath, false);\n      inode.setPersisted(true);\n    }\n\n    LOG.debug(\"createFile: File Created: {} parent: \", lastInode, currentInodeDirectory);\n    return new CreatePathResult(modifiedInodes, createdInodes, traversalResult.getToBePersisted());\n  }","commit_id":"5ee6cb4c84218b8a9b2df41bcdabe4e8cff55dee","url":"https://github.com/amplab/tachyon"},{"original_method":"static TraversalResult createFoundResult(Inode inode, List<Inode> persisted) {\n      return new TraversalResult(true, -1, inode, persisted);\n    }","id":47541,"modified_method":"static TraversalResult createFoundResult(Inode inode, List<Inode> toBePersisted) {\n      return new TraversalResult(true, -1, inode, toBePersisted);\n    }","commit_id":"5ee6cb4c84218b8a9b2df41bcdabe4e8cff55dee","url":"https://github.com/amplab/tachyon"},{"original_method":"private TraversalResult(boolean found, int index, Inode inode, List<Inode> persisted) {\n      mFound = found;\n      mNonexistentIndex = index;\n      mInode = inode;\n      mPersisted = persisted;\n    }","id":47542,"modified_method":"private TraversalResult(boolean found, int index, Inode inode, List<Inode> toBePersisted) {\n      mFound = found;\n      mNonexistentIndex = index;\n      mInode = inode;\n      mToBePersisted = toBePersisted;\n    }","commit_id":"5ee6cb4c84218b8a9b2df41bcdabe4e8cff55dee","url":"https://github.com/amplab/tachyon"},{"original_method":"private void verifyLDAPServerConfiguration(\n\t\tlong companyId, long ldapServerId, String postfix) {\n\n\t\tDictionary<String, Object> dictionary = new HashMapDictionary<>();\n\n\t\tdictionary.put(\n\t\t\tLDAPConstants.AUTH_SEARCH_FILTER,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_AUTH_SEARCH_FILTER + postfix,\n\t\t\t\t\"(mail=@email_address@)\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.BASE_DN,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_BASE_DN + postfix,\n\t\t\t\t\"dc=example,dc=com\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.BASE_PROVIDER_URL,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_BASE_PROVIDER_URL + postfix,\n\t\t\t\t\"ldap://localhost:10389\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.CONTACT_CUSTOM_MAPPINGS,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_CONTACT_CUSTOM_MAPPINGS + postfix,\n\t\t\t\tStringPool.NEW_LINE));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.CONTACT_MAPPINGS,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_CONTACT_MAPPINGS + postfix,\n\t\t\t\tStringPool.NEW_LINE));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_DEFAULT_OBJECT_CLASSES,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_GROUP_DEFAULT_OBJECT_CLASSES + postfix,\n\t\t\t\tStringPool.COMMA));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_MAPPINGS,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_GROUP_MAPPINGS + postfix,\n\t\t\t\tStringPool.NEW_LINE));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_SEARCH_FILTER,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix,\n\t\t\t\t\"(objectClass=groupOfUniqueNames)\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_SEARCH_FILTER_ENABLED,\n\t\t\t_prefsProps.getBoolean(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER_ENABLED +\n\t\t\t\t\tpostfix,\n\t\t\t\ttrue));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUPS_DN,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_GROUPS_DN + postfix,\n\t\t\t\t\"ou=groups,dc=example,dc=com\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.SECURITY_CREDENTIAL,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_SECURITY_CREDENTIALS + postfix,\n\t\t\t\t\"secret\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.SECURITY_PRINCIPAL,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_SECURITY_PRINCIPAL + postfix,\n\t\t\t\t\"uid=admin,ou=system\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.SERVER_NAME,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_SERVER_NAME + postfix));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_CUSTOM_MAPPINGS,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_USER_CUSTOM_MAPPINGS + postfix,\n\t\t\t\tStringPool.NEW_LINE));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_DEFAULT_OBJECT_CLASSES,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_USER_DEFAULT_OBJECT_CLASSES + postfix,\n\t\t\t\tStringPool.COMMA));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_IGNORE_ATTRIBUTES,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_USER_IGNORE_ATTRIBUTES + postfix,\n\t\t\t\tStringPool.COMMA));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_MAPPINGS,\n\t\t\t_prefsProps.getStringArray(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_USER_MAPPINGS + postfix,\n\t\t\t\tStringPool.NEW_LINE));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_SEARCH_FILTER,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix,\n\t\t\t\t\"(objectClass=inetOrgPerson)\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USERS_DN,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_USERS_DN + postfix,\n\t\t\t\t\"users,dc=example,dc=com\"));\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Adding LDAP servier configuration for company \" + companyId +\n\t\t\t\t\t\" and LDAP server ID \" + ldapServerId +\n\t\t\t\t\t\t\" with properties: \" + dictionary);\n\t\t}\n\n\t\t_ldapServerConfigurationProvider.updateProperties(\n\t\t\tcompanyId, ldapServerId, dictionary);\n\t}","id":47543,"modified_method":"private void verifyLDAPServerConfiguration(\n\t\tlong companyId, long ldapServerId, String postfix) {\n\n\t\tDictionary<String, Object> dictionary = new HashMapDictionary<>();\n\n\t\tdictionary.put(\n\t\t\tLDAPConstants.AUTH_SEARCH_FILTER,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_AUTH_SEARCH_FILTER + postfix,\n\t\t\t\t\"(mail=@email_address@)\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.BASE_DN,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_BASE_DN + postfix,\n\t\t\t\t\"dc=example,dc=com\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.BASE_PROVIDER_URL,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_BASE_PROVIDER_URL + postfix,\n\t\t\t\t\"ldap://localhost:10389\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.CONTACT_CUSTOM_MAPPINGS,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_CONTACT_CUSTOM_MAPPINGS + postfix,\n\t\t\t\t\tStringPool.NEW_LINE)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.CONTACT_MAPPINGS,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_CONTACT_MAPPINGS + postfix,\n\t\t\t\t\tStringPool.NEW_LINE)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_DEFAULT_OBJECT_CLASSES,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_GROUP_DEFAULT_OBJECT_CLASSES +\n\t\t\t\t\t\tpostfix,\n\t\t\t\t\tStringPool.COMMA)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_MAPPINGS,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_GROUP_MAPPINGS + postfix,\n\t\t\t\t\tStringPool.NEW_LINE)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_SEARCH_FILTER,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix,\n\t\t\t\t\"(objectClass=groupOfUniqueNames)\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUP_SEARCH_FILTER_ENABLED,\n\t\t\t_prefsProps.getBoolean(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER_ENABLED +\n\t\t\t\t\tpostfix,\n\t\t\t\ttrue));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.GROUPS_DN,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_GROUPS_DN + postfix,\n\t\t\t\t\"ou=groups,dc=example,dc=com\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.SECURITY_CREDENTIAL,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_SECURITY_CREDENTIALS + postfix,\n\t\t\t\t\"secret\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.SECURITY_PRINCIPAL,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_SECURITY_PRINCIPAL + postfix,\n\t\t\t\t\"uid=admin,ou=system\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.SERVER_NAME,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_SERVER_NAME + postfix));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_CUSTOM_MAPPINGS,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_USER_CUSTOM_MAPPINGS + postfix,\n\t\t\t\t\tStringPool.NEW_LINE)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_DEFAULT_OBJECT_CLASSES,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_USER_DEFAULT_OBJECT_CLASSES +\n\t\t\t\t\t\tpostfix,\n\t\t\t\t\tStringPool.COMMA)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_IGNORE_ATTRIBUTES,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tLegacyLDAPPropsKeys.LDAP_USER_IGNORE_ATTRIBUTES + postfix,\n\t\t\t\t\tStringPool.COMMA)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_MAPPINGS,\n\t\t\tconvert(\n\t\t\t\t_prefsProps.getStringArray(\n\t\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_USER_MAPPINGS + postfix,\n\t\t\t\t\tStringPool.NEW_LINE)));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USER_SEARCH_FILTER,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tLegacyLDAPPropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix,\n\t\t\t\t\"(objectClass=inetOrgPerson)\"));\n\t\tdictionary.put(\n\t\t\tLDAPConstants.USERS_DN,\n\t\t\t_prefsProps.getString(\n\t\t\t\tcompanyId, LegacyLDAPPropsKeys.LDAP_USERS_DN + postfix,\n\t\t\t\t\"users,dc=example,dc=com\"));\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Adding LDAP servier configuration for company \" + companyId +\n\t\t\t\t\t\" and LDAP server ID \" + ldapServerId +\n\t\t\t\t\t\t\" with properties: \" + dictionary);\n\t\t}\n\n\t\t_ldapServerConfigurationProvider.updateProperties(\n\t\t\tcompanyId, ldapServerId, dictionary);\n\t}","commit_id":"5d9002b58eed1b4e7659c8887dcc6dacd21cdb30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void validateLDAPServerProperties(\n\t\tlong companyId, long ldapServerId,\n\t\tDictionary<String, Object> properties) {\n\n\t\tAssert.assertNotNull(properties);\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.AUTH_SEARCH_FILTER));\n\t\tAssert.assertEquals(\n\t\t\t\"(mail=@email_address@)\",\n\t\t\tproperties.get(LDAPConstants.AUTH_SEARCH_FILTER));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.BASE_DN));\n\t\tAssert.assertEquals(\n\t\t\t\"dc=liferay,dc=com\", properties.get(LDAPConstants.BASE_DN));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.BASE_PROVIDER_URL));\n\t\tAssert.assertEquals(\n\t\t\t\"ldap://liferay.com:10389\",\n\t\t\tproperties.get(LDAPConstants.BASE_PROVIDER_URL));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.COMPANY_ID));\n\t\tAssert.assertEquals(\n\t\t\tcompanyId, properties.get(LDAPConstants.COMPANY_ID));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.CONTACT_CUSTOM_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.isEmpty(\n\t\t\t\t(String[])properties.get(\n\t\t\t\t\tLDAPConstants.CONTACT_CUSTOM_MAPPINGS)));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\"birthday=\", \"country=\"},\n\t\t\t\t(String[])properties.get(LDAPConstants.CONTACT_MAPPINGS)));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.GROUP_DEFAULT_OBJECT_CLASSES));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\"top\", \"groupOfUniqueNames\"},\n\t\t\t\t(String[])properties.get(\n\t\t\t\t\tLDAPConstants.GROUP_DEFAULT_OBJECT_CLASSES)));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.GROUP_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"description=description\", \"groupName=cn\",\n\t\t\t\t\t\"user=uniqueMember\"\n\t\t\t\t},\n\t\t\t\t(String[])properties.get(LDAPConstants.GROUP_MAPPINGS)));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.GROUP_SEARCH_FILTER));\n\t\tAssert.assertEquals(\n\t\t\t\"(objectClass=groupOfUniqueNames)\",\n\t\t\tproperties.get(LDAPConstants.GROUP_SEARCH_FILTER));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.GROUPS_DN));\n\t\tAssert.assertEquals(\n\t\t\t\"ou=groups,dc=example,dc=com\",\n\t\t\tproperties.get(LDAPConstants.GROUPS_DN));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.LDAP_SERVER_ID));\n\t\tAssert.assertEquals(\n\t\t\tldapServerId, properties.get(LDAPConstants.LDAP_SERVER_ID));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.USER_SEARCH_FILTER));\n\t\tAssert.assertEquals(\n\t\t\t\"(objectClass=inetOrgPerson)\",\n\t\t\tproperties.get(LDAPConstants.USER_SEARCH_FILTER));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.SECURITY_CREDENTIAL));\n\t\tAssert.assertEquals(\n\t\t\t\"secret\", properties.get(LDAPConstants.SECURITY_CREDENTIAL));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.SECURITY_PRINCIPAL));\n\t\tAssert.assertEquals(\n\t\t\t\"uid=admin,ou=system\",\n\t\t\tproperties.get(LDAPConstants.SECURITY_PRINCIPAL));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.SERVER_NAME));\n\t\tAssert.assertEquals(\"test\", properties.get(LDAPConstants.SERVER_NAME));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.USER_CUSTOM_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.isEmpty(\n\t\t\t\t(String[])properties.get(LDAPConstants.USER_CUSTOM_MAPPINGS)));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.USER_DEFAULT_OBJECT_CLASSES));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"top\", \"person\", \"inetOrgPerson\", \"organizationalPerson\"\n\t\t\t\t},\n\t\t\t\t(String[])properties.get(\n\t\t\t\t\tLDAPConstants.USER_DEFAULT_OBJECT_CLASSES)));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.USER_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"emailAddress=mail\", \"firstName=givenName\",\n\t\t\t\t\t\"group=groupMembership\", \"jobTitle=title\", \"lastName=sn\",\n\t\t\t\t\t\"password=userPassword\", \"screenName=cn\", \"uuid=uuid\"\n\t\t\t\t},\n\t\t\t\t(String[])properties.get(LDAPConstants.USER_MAPPINGS)));\n\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.USERS_DN));\n\t\tAssert.assertEquals(\n\t\t\t\"ou=users,dc=example,dc=com\",\n\t\t\tproperties.get(LDAPConstants.USERS_DN));\n\t}","id":47544,"modified_method":"private void validateLDAPServerProperties(\n\t\tlong companyId, long ldapServerId,\n\t\tDictionary<String, Object> properties) {\n\n\t\tAssert.assertNotNull(properties);\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.AUTH_SEARCH_FILTER));\n\t\tAssert.assertEquals(\n\t\t\t\"(mail=@email_address@)\",\n\t\t\tproperties.get(LDAPConstants.AUTH_SEARCH_FILTER));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.BASE_DN));\n\t\tAssert.assertEquals(\n\t\t\t\"dc=liferay,dc=com\", properties.get(LDAPConstants.BASE_DN));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.BASE_PROVIDER_URL));\n\t\tAssert.assertEquals(\n\t\t\t\"ldap://liferay.com:10389\",\n\t\t\tproperties.get(LDAPConstants.BASE_PROVIDER_URL));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.COMPANY_ID));\n\t\tAssert.assertEquals(\n\t\t\tcompanyId, properties.get(LDAPConstants.COMPANY_ID));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.CONTACT_CUSTOM_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tValidator.isNull(\n\t\t\t\t(String)properties.get(LDAPConstants.CONTACT_CUSTOM_MAPPINGS)));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\"birthday=\", \"country=\"},\n\t\t\t\tStringUtil.split(\n\t\t\t\t\t(String)properties.get(LDAPConstants.CONTACT_MAPPINGS),\n\t\t\t\t\tStringPool.PIPE)));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.GROUP_DEFAULT_OBJECT_CLASSES));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\"top\", \"groupOfUniqueNames\"},\n\t\t\t\tStringUtil.split(\n\t\t\t\t\t(String)properties.get(\n\t\t\t\t\t\tLDAPConstants.GROUP_DEFAULT_OBJECT_CLASSES),\n\t\t\t\t\tStringPool.PIPE)));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.GROUP_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"description=description\", \"groupName=cn\",\n\t\t\t\t\t\"user=uniqueMember\"\n\t\t\t\t},\n\t\t\t\tStringUtil.split(\n\t\t\t\t\t(String)properties.get(LDAPConstants.GROUP_MAPPINGS),\n\t\t\t\t\tStringPool.PIPE)));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.GROUP_SEARCH_FILTER));\n\t\tAssert.assertEquals(\n\t\t\t\"(objectClass=groupOfUniqueNames)\",\n\t\t\tproperties.get(LDAPConstants.GROUP_SEARCH_FILTER));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.GROUPS_DN));\n\t\tAssert.assertEquals(\n\t\t\t\"ou=groups,dc=example,dc=com\",\n\t\t\tproperties.get(LDAPConstants.GROUPS_DN));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.LDAP_SERVER_ID));\n\t\tAssert.assertEquals(\n\t\t\tldapServerId, properties.get(LDAPConstants.LDAP_SERVER_ID));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.USER_SEARCH_FILTER));\n\t\tAssert.assertEquals(\n\t\t\t\"(objectClass=inetOrgPerson)\",\n\t\t\tproperties.get(LDAPConstants.USER_SEARCH_FILTER));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.SECURITY_CREDENTIAL));\n\t\tAssert.assertEquals(\n\t\t\t\"secret\", properties.get(LDAPConstants.SECURITY_CREDENTIAL));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.SECURITY_PRINCIPAL));\n\t\tAssert.assertEquals(\n\t\t\t\"uid=admin,ou=system\",\n\t\t\tproperties.get(LDAPConstants.SECURITY_PRINCIPAL));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.SERVER_NAME));\n\t\tAssert.assertEquals(\"test\", properties.get(LDAPConstants.SERVER_NAME));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.USER_CUSTOM_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tValidator.isNull(\n\t\t\t\t(String)properties.get(LDAPConstants.USER_CUSTOM_MAPPINGS)));\n\t\tAssert.assertNotNull(\n\t\t\tproperties.get(LDAPConstants.USER_DEFAULT_OBJECT_CLASSES));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"top\", \"person\", \"inetOrgPerson\", \"organizationalPerson\"\n\t\t\t\t},\n\t\t\t\tStringUtil.split(\n\t\t\t\t\t(String)properties.get(\n\t\t\t\t\t\tLDAPConstants.USER_DEFAULT_OBJECT_CLASSES),\n\t\t\t\t\tStringPool.PIPE)));\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.USER_MAPPINGS));\n\t\tAssert.assertTrue(\n\t\t\tArrayUtil.containsAll(\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"emailAddress=mail\", \"firstName=givenName\",\n\t\t\t\t\t\"group=groupMembership\", \"jobTitle=title\", \"lastName=sn\",\n\t\t\t\t\t\"password=userPassword\", \"screenName=cn\", \"uuid=uuid\"\n\t\t\t\t},\n\t\t\t\tStringUtil.split(\n\t\t\t\t\t(String)properties.get(LDAPConstants.USER_MAPPINGS),\n\t\t\t\t\tStringPool.PIPE)));\n\n\t\tAssert.assertNotNull(properties.get(LDAPConstants.USERS_DN));\n\t\tAssert.assertEquals(\n\t\t\t\"ou=users,dc=example,dc=com\",\n\t\t\tproperties.get(LDAPConstants.USERS_DN));\n\t}","commit_id":"5d9002b58eed1b4e7659c8887dcc6dacd21cdb30","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void update(AnActionEvent event) {\n    super.update(event);\n    Presentation presentation = event.getPresentation();\n    if (!presentation.isEnabled()) {\n      return;\n    }\n    DataContext dataContext = event.getDataContext();\n    presentation.setVisible(false);\n\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    CompilerConfiguration compilerConfiguration = CompilerConfiguration.getInstance(project);\n    final Module module = LangDataKeys.MODULE.getData(dataContext);\n    final Module moduleContext = LangDataKeys.MODULE_CONTEXT.getData(dataContext);\n\n    if (!compilerConfiguration.isAnnotationProcessorsEnabled() ||\n        compilerConfiguration.getAnnotationProcessorsMap().isEmpty() ||\n        module != null && !Boolean.TRUE.equals(compilerConfiguration.getAnotationProcessedModules().get(module))) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    presentation.setVisible(true);\n    final VirtualFile[] files = getCompilableFiles(project, PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext));\n    if (moduleContext == null && files.length == 0) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    String elementDescription = null;\n    if (moduleContext != null) {\n      elementDescription = CompilerBundle.message(\"action.compile.description.module\", moduleContext.getName());\n    }\n    else {\n      PsiPackage aPackage = null;\n      if (files.length == 1) {\n        final PsiDirectory directory = PsiManager.getInstance(project).findDirectory(files[0]);\n        if (directory != null) {\n          aPackage = JavaDirectoryService.getInstance().getPackage(directory);\n        }\n      }\n      else {\n        PsiElement element = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n        if (element instanceof PsiPackage) {\n          aPackage = (PsiPackage)element;\n        }\n      }\n\n      if (aPackage != null) {\n        String name = aPackage.getQualifiedName();\n        if (name.length() == 0) {\n          //noinspection HardCodedStringLiteral\n          name = \"<default>\";\n        }\n        elementDescription = \"'\" + name + \"'\";\n      }\n      else if (files.length == 1) {\n        final VirtualFile file = files[0];\n        FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(file);\n        if (CompilerManager.getInstance(project).isCompilableFileType(fileType)) {\n          elementDescription = \"'\" + file.getName() + \"'\";\n        }\n        else {\n          if (!ActionPlaces.MAIN_MENU.equals(event.getPlace())) {\n            // the action should be invisible in popups for non-java files\n            presentation.setEnabled(false);\n            presentation.setVisible(false);\n            return;\n          }\n        }\n      }\n      else {\n        elementDescription = CompilerBundle.message(\"action.compile.description.selected.files\");\n      }\n    }\n\n    if (elementDescription == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    presentation.setText(createPresentationText(elementDescription), true);\n    presentation.setEnabled(true);\n  }","id":47545,"modified_method":"public void update(AnActionEvent event) {\n    super.update(event);\n    Presentation presentation = event.getPresentation();\n    if (!presentation.isEnabled()) {\n      return;\n    }\n    DataContext dataContext = event.getDataContext();\n    presentation.setVisible(false);\n\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    CompilerConfiguration compilerConfiguration = CompilerConfiguration.getInstance(project);\n    final Module module = LangDataKeys.MODULE.getData(dataContext);\n    final Module moduleContext = LangDataKeys.MODULE_CONTEXT.getData(dataContext);\n\n    if (!compilerConfiguration.isAnnotationProcessorsEnabled() ||\n        compilerConfiguration.getAnnotationProcessorsMap().isEmpty() ||\n        module != null && StringUtil.isEmpty(compilerConfiguration.getAnotationProcessedModules().get(module))) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    presentation.setVisible(true);\n    presentation.setText(createPresentationText(\"\"), true);\n    final VirtualFile[] files = getCompilableFiles(project, PlatformDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext));\n    if (moduleContext == null && files.length == 0) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    String elementDescription = null;\n    if (moduleContext != null) {\n      elementDescription = CompilerBundle.message(\"action.compile.description.module\", moduleContext.getName());\n    }\n    else {\n      PsiPackage aPackage = null;\n      if (files.length == 1) {\n        final PsiDirectory directory = PsiManager.getInstance(project).findDirectory(files[0]);\n        if (directory != null) {\n          aPackage = JavaDirectoryService.getInstance().getPackage(directory);\n        }\n      }\n      else {\n        PsiElement element = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n        if (element instanceof PsiPackage) {\n          aPackage = (PsiPackage)element;\n        }\n      }\n\n      if (aPackage != null) {\n        String name = aPackage.getQualifiedName();\n        if (name.length() == 0) {\n          //noinspection HardCodedStringLiteral\n          name = \"<default>\";\n        }\n        elementDescription = \"'\" + name + \"'\";\n      }\n      else if (files.length == 1) {\n        final VirtualFile file = files[0];\n        FileType fileType = FileTypeManager.getInstance().getFileTypeByFile(file);\n        if (CompilerManager.getInstance(project).isCompilableFileType(fileType)) {\n          elementDescription = \"'\" + file.getName() + \"'\";\n        }\n        else {\n          if (!ActionPlaces.MAIN_MENU.equals(event.getPlace())) {\n            // the action should be invisible in popups for non-java files\n            presentation.setEnabled(false);\n            presentation.setVisible(false);\n            return;\n          }\n        }\n      }\n      else {\n        elementDescription = CompilerBundle.message(\"action.compile.description.selected.files\");\n      }\n    }\n\n    if (elementDescription == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    presentation.setText(createPresentationText(elementDescription), true);\n    presentation.setEnabled(true);\n  }","commit_id":"82be3de2ca6c3b6083518c3e68ac4e1e79f9c387","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** {@inheritDoc} */\n    public boolean canGenerateReport()\n    {\n        return project.getPluginManagement() != null;\n    }","id":47546,"modified_method":"/** {@inheritDoc} */\n    public boolean canGenerateReport()\n    {\n        return project.getPluginManagement() != null && project.getPluginManagement().getPlugins() != null\n            && !project.getPluginManagement().getPlugins().isEmpty();\n    }","commit_id":"f040cdf168ff43f65b4d34f5758e4b49900a8f9a","url":"https://github.com/apache/maven-plugins"},{"original_method":"private String[] getPluginRow( Plugin plugin, String link )\n        {\n            String artifactId = ArtifactUtils.getArtifactIdCell( plugin.getArtifactId(), link );\n            return new String[] { plugin.getGroupId(), artifactId, plugin.getVersion() };\n        }","id":47547,"modified_method":"private String[] getPluginRow( String groupId, String artifactId, String version, String link )\n        {\n            artifactId = ArtifactUtils.getArtifactIdCell( artifactId, link );\n            return new String[] { groupId, artifactId, version };\n        }","commit_id":"f040cdf168ff43f65b4d34f5758e4b49900a8f9a","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void renderSectionPluginManagement()\n        {\n            String[] tableHeader = getPluginTableHeader();\n\n            startSection( getTitle() );\n\n            if ( plugins != null )\n            {\n                // can't use straight artifact comparison because we want optional last\n                Collections.sort( plugins, getPluginComparator() );\n\n                startTable();\n                tableHeader( tableHeader );\n\n                for ( Iterator iterator = plugins.iterator(); iterator.hasNext(); )\n                {\n                    Plugin plugin = (Plugin) iterator.next();\n                    VersionRange versionRange;\n                    if ( plugin.getVersion() == null || \"\".equals( plugin.getVersion() ) )\n                    {\n                        versionRange = VersionRange.createFromVersion( Artifact.RELEASE_VERSION );\n                    }\n                    else\n                    {\n                        versionRange = VersionRange.createFromVersion( plugin.getVersion() );\n                    }\n\n                    Artifact pluginArtifact = artifactFactory.createParentArtifact( plugin.getGroupId(), plugin\n                        .getArtifactId(), versionRange.toString() );\n                    List artifactRepositories = project.getPluginArtifactRepositories();\n                    if ( artifactRepositories == null )\n                    {\n                        artifactRepositories = new ArrayList();\n                    }\n                    try\n                    {\n                        MavenProject pluginProject = mavenProjectBuilder.buildFromRepository( pluginArtifact,\n                                                                                              artifactRepositories,\n                                                                                              localRepository );\n                        tableRow( getPluginRow( plugin, pluginProject.getUrl() ) );\n                    }\n                    catch ( ProjectBuildingException e )\n                    {\n                        log.info( \"Could not build project for: \" + plugin.getArtifactId() + \":\" + e.getMessage(), e );\n                        tableRow( getPluginRow( plugin, null ) );\n                    }\n\n                }\n                endTable();\n            }\n\n            endSection();\n        }","id":47548,"modified_method":"private void renderSectionPluginManagement()\n        {\n            String[] tableHeader = getPluginTableHeader();\n\n            startSection( getTitle() );\n\n            // can't use straight artifact comparison because we want optional last\n            Collections.sort( pluginManagement, getPluginComparator() );\n\n            startTable();\n            tableHeader( tableHeader );\n\n            for ( Iterator iterator = pluginManagement.iterator(); iterator.hasNext(); )\n            {\n                Plugin plugin = (Plugin) iterator.next();\n                VersionRange versionRange;\n                if ( StringUtils.isEmpty( plugin.getVersion() ) )\n                {\n                    versionRange = VersionRange.createFromVersion( Artifact.RELEASE_VERSION );\n                }\n                else\n                {\n                    versionRange = VersionRange.createFromVersion( plugin.getVersion() );\n                }\n\n                Artifact pluginArtifact = artifactFactory.createParentArtifact( plugin.getGroupId(), plugin\n                    .getArtifactId(), versionRange.toString() );\n                List artifactRepositories = project.getPluginArtifactRepositories();\n                if ( artifactRepositories == null )\n                {\n                    artifactRepositories = new ArrayList();\n                }\n                try\n                {\n                    MavenProject pluginProject = mavenProjectBuilder.buildFromRepository( pluginArtifact,\n                                                                                          artifactRepositories,\n                                                                                          localRepository );\n                    tableRow( getPluginRow( pluginProject.getGroupId(), pluginProject.getArtifactId(), pluginProject\n                        .getVersion(), pluginProject.getUrl() ) );\n                }\n                catch ( ProjectBuildingException e )\n                {\n                    log.info( \"Could not build project for: \" + plugin.getArtifactId() + \":\" + e.getMessage(), e );\n                    tableRow( getPluginRow( plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion(), null ) );\n                }\n\n            }\n            endTable();\n\n            endSection();\n        }","commit_id":"f040cdf168ff43f65b4d34f5758e4b49900a8f9a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n         * @param sink\n         * @param locale\n         * @param i18n\n         * @param plugins\n         * @param project\n         * @param mavenProjectBuilder\n         * @param artifactFactory\n         * @param localRepository\n         */\n        public PluginManagementRenderer( Sink sink, Locale locale, I18N i18n, List plugins, MavenProject project,\n                                         MavenProjectBuilder mavenProjectBuilder, ArtifactFactory artifactFactory,\n                                         ArtifactRepository localRepository )\n        {\n            super( sink );\n\n            this.locale = locale;\n\n            this.plugins = plugins;\n\n            this.i18n = i18n;\n\n            this.project = project;\n\n            this.mavenProjectBuilder = mavenProjectBuilder;\n\n            this.artifactFactory = artifactFactory;\n\n            this.localRepository = localRepository;\n        }","id":47549,"modified_method":"/**\n         * @param sink\n         * @param locale\n         * @param i18n\n         * @param plugins\n         * @param project\n         * @param mavenProjectBuilder\n         * @param artifactFactory\n         * @param localRepository\n         */\n        public PluginManagementRenderer( Sink sink, Locale locale, I18N i18n, List plugins, MavenProject project,\n                                         MavenProjectBuilder mavenProjectBuilder, ArtifactFactory artifactFactory,\n                                         ArtifactRepository localRepository )\n        {\n            super( sink );\n\n            this.locale = locale;\n\n            this.pluginManagement = plugins;\n\n            this.i18n = i18n;\n\n            this.project = project;\n\n            this.mavenProjectBuilder = mavenProjectBuilder;\n\n            this.artifactFactory = artifactFactory;\n\n            this.localRepository = localRepository;\n        }","commit_id":"f040cdf168ff43f65b4d34f5758e4b49900a8f9a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n        public void renderBody()\n        {\n            // Dependencies report\n\n            if ( plugins.isEmpty() )\n            {\n                startSection( getTitle() );\n\n                // TODO: should the report just be excluded?\n                paragraph( getReportString( \"report.pluginManagement.nolist\" ) );\n\n                endSection();\n\n                return;\n            }\n\n            // === Section: Project Dependencies.\n            renderSectionPluginManagement();\n        }","id":47550,"modified_method":"/** {@inheritDoc} */\n        public void renderBody()\n        {\n            // === Section: Project PluginManagement.\n            renderSectionPluginManagement();\n        }","commit_id":"f040cdf168ff43f65b4d34f5758e4b49900a8f9a","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        ActionForward retval = mapping.findForward(\"default\");\n        DynaActionForm dynaForm = (DynaActionForm) formIn;\n\n        /*\n         * If we are a sat and we have setup pam authentication already, display the\n         * checkbox and instructions\n         */\n        String pamAuthService = Config.get().getString(ConfigDefaults.WEB_PAM_AUTH_SERVICE);\n        if (pamAuthService != null && pamAuthService.trim().length() > 0) {\n            request.setAttribute(\"displaypamcheckbox\", \"true\");\n        }\n\n        request.setAttribute(\"availablePrefixes\", UserActionHelper.getPrefixes());\n        if (isSubmitted(dynaForm)) {\n        /*\n         * If the usepam checkbox has been checked, the password fields aren't required.\n         * Since password is required in the db and since in all other cases it is req,\n         * we'll trick the validation by doing all of the manipulation before validating\n         * the form.\n         *\n         * Also, if the user for some reason does want to set a default password to stick\n         * in the db (even though it won't be used), we'll just validate it like a regular\n         * password and allow it.\n         */\n            if (dynaForm.get(\"usepam\") != null &&\n                    ((Boolean) dynaForm.get(\"usepam\")).booleanValue()) {\n                String hash = MD5Crypt.crypt(\"\" + System.currentTimeMillis());\n                if (dynaForm.get(UserActionHelper.DESIRED_PASS) == null ||\n                        dynaForm.get(UserActionHelper.DESIRED_PASS).equals(\"\")) {\n                    dynaForm.set(UserActionHelper.DESIRED_PASS, hash);\n                }\n                if (dynaForm.get(UserActionHelper.DESIRED_PASS_CONFIRM) == null ||\n                        dynaForm.get(UserActionHelper.DESIRED_PASS_CONFIRM).equals(\"\")) {\n                    dynaForm.set(UserActionHelper.DESIRED_PASS_CONFIRM, hash);\n                }\n            }\n\n            ActionErrors errors = RhnValidationHelper.validateDynaActionForm(\n                    this, dynaForm);\n\n            if (!errors.isEmpty()) {\n                getStrutsDelegate().saveMessages(request, errors);\n            }\n            else {\n                String name = dynaForm.getString(\"orgName\");\n                String email = dynaForm.getString(\"email\");\n                String login = dynaForm.getString(\"login\");\n                String pass = dynaForm.getString(\"desiredpassword\");\n                String passConfirm = dynaForm.getString(\"desiredpasswordConfirm\");\n                String fname = dynaForm.getString(\"firstNames\");\n                String lname = dynaForm.getString(\"lastName\");\n                String prefix = dynaForm.getString(\"prefix\");\n\n                if (!pass.equals(passConfirm)) {\n                    addMessage(request, \"error.password_mismatch\");\n                }\n                else {\n                    CreateOrgCommand cmd = new CreateOrgCommand(name, login, pass, email);\n\n                    //Should this user use pam authentication?\n                    if (dynaForm.get(\"usepam\") != null &&\n                            ((Boolean)dynaForm.get(\"usepam\")).booleanValue()) {\n                        cmd.setUsePam(true);\n                    }\n                    else {\n                        cmd.setUsePam(false);\n                    }\n\n                    cmd.setFirstName(fname);\n                    cmd.setLastName(lname);\n                    cmd.setPrefix(prefix);\n                    ValidatorError[] verrors = cmd.store();\n                    if (verrors != null) {\n                        ActionErrors ae =\n                            RhnValidationHelper.validatorErrorToActionErrors(verrors);\n                        getStrutsDelegate().saveMessages(request, ae);\n                    }\n                    else {\n                        createSuccessMessage(request, \"org.create.success\",\n                                cmd.getNewOrg().getName());\n                        retval = getStrutsDelegate().\n                                 forwardParam(mapping.findForward(\"success\"),\n                                 RequestContext.ORG_ID, cmd.getNewOrg().getId().toString());\n                    }\n                }\n            }\n        }\n        return retval;\n    }","id":47551,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        ActionForward retval = mapping.findForward(\"default\");\n        DynaActionForm dynaForm = (DynaActionForm) formIn;\n\n        /*\n         * If we are a sat and we have setup pam authentication already, display the\n         * checkbox and instructions\n         */\n        String pamAuthService = Config.get().getString(ConfigDefaults.WEB_PAM_AUTH_SERVICE);\n        if (pamAuthService != null && pamAuthService.trim().length() > 0) {\n            request.setAttribute(\"displaypamcheckbox\", \"true\");\n        }\n\n        request.setAttribute(\"availablePrefixes\", UserActionHelper.getPrefixes());\n        if (isSubmitted(dynaForm)) {\n        /*\n         * If the usepam checkbox has been checked, the password fields aren't required.\n         * Since password is required in the db and since in all other cases it is req,\n         * we'll trick the validation by doing all of the manipulation before validating\n         * the form.\n         *\n         * Also, if the user for some reason does want to set a default password to stick\n         * in the db (even though it won't be used), we'll just validate it like a regular\n         * password and allow it.\n         */\n            if (dynaForm.get(\"usepam\") != null &&\n                    ((Boolean) dynaForm.get(\"usepam\")).booleanValue()) {\n                String fakePassword = MD5Crypt.crypt(\"\" + System.currentTimeMillis()).\n                    substring(0, UserDefaults.get().getMaxPasswordLength());\n                if (StringUtils.isEmpty(\n                        (String) dynaForm.get(UserActionHelper.DESIRED_PASS))) {\n                    dynaForm.set(UserActionHelper.DESIRED_PASS, fakePassword);\n                }\n                if (StringUtils.isEmpty(\n                        (String) dynaForm.get(UserActionHelper.DESIRED_PASS_CONFIRM))) {\n                    dynaForm.set(UserActionHelper.DESIRED_PASS_CONFIRM, fakePassword);\n                }\n            }\n\n            ActionErrors errors = RhnValidationHelper.validateDynaActionForm(\n                    this, dynaForm);\n\n            if (!errors.isEmpty()) {\n                getStrutsDelegate().saveMessages(request, errors);\n            }\n            else {\n                String name = dynaForm.getString(\"orgName\");\n                String email = dynaForm.getString(\"email\");\n                String login = dynaForm.getString(\"login\");\n                String pass = dynaForm.getString(\"desiredpassword\");\n                String passConfirm = dynaForm.getString(\"desiredpasswordConfirm\");\n                String fname = dynaForm.getString(\"firstNames\");\n                String lname = dynaForm.getString(\"lastName\");\n                String prefix = dynaForm.getString(\"prefix\");\n\n                if (!pass.equals(passConfirm)) {\n                    addMessage(request, \"error.password_mismatch\");\n                }\n                else {\n                    CreateOrgCommand cmd = new CreateOrgCommand(name, login, pass, email);\n\n                    //Should this user use pam authentication?\n                    if (dynaForm.get(\"usepam\") != null &&\n                            ((Boolean)dynaForm.get(\"usepam\")).booleanValue()) {\n                        cmd.setUsePam(true);\n                    }\n                    else {\n                        cmd.setUsePam(false);\n                    }\n\n                    cmd.setFirstName(fname);\n                    cmd.setLastName(lname);\n                    cmd.setPrefix(prefix);\n                    ValidatorError[] verrors = cmd.store();\n                    if (verrors != null) {\n                        ActionErrors ae =\n                            RhnValidationHelper.validatorErrorToActionErrors(verrors);\n                        getStrutsDelegate().saveMessages(request, ae);\n                    }\n                    else {\n                        createSuccessMessage(request, \"org.create.success\",\n                                cmd.getNewOrg().getName());\n                        retval = getStrutsDelegate().\n                                 forwardParam(mapping.findForward(\"success\"),\n                                 RequestContext.ORG_ID, cmd.getNewOrg().getId().toString());\n                    }\n                }\n            }\n        }\n        return retval;\n    }","commit_id":"64667a91e02e48802a9b5bff64141644c5dafcf9","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void mergeDuplicates( Model model, ModelBuildingRequest request, ModelProblemCollector problems )\n    {\n        Build build = model.getBuild();\n        if ( build != null )\n        {\n            List<Plugin> original = build.getPlugins();\n            Map<Object, Plugin> normalized = new LinkedHashMap<Object, Plugin>();\n\n            for ( Plugin plugin : original )\n            {\n                Object key = plugin.getKey();\n                Plugin first = normalized.get( key );\n                if ( first != null )\n                {\n                    merger.mergePlugin( plugin, first );\n                }\n                normalized.put( key, plugin );\n            }\n\n            build.setPlugins( new ArrayList<Plugin>( normalized.values() ) );\n        }\n\n        if ( request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 )\n        {\n            /*\n             * NOTE: This is to keep backward-compat with Maven 2.x which did not validate that dependencies are unique\n             * within a single POM. Upon multiple declarations, 2.x just kept the last one. So when we're in\n             * lenient/compat mode, we have to deal with such broken POMs and mimic the way 2.x works.\n             */\n            Map<String, Dependency> dependencies = new LinkedHashMap<String, Dependency>();\n            for ( Dependency dependency : model.getDependencies() )\n            {\n                dependencies.put( dependency.getManagementKey(), dependency );\n            }\n            model.setDependencies( new ArrayList<Dependency>( dependencies.values() ) );\n        }\n    }","id":47552,"modified_method":"public void mergeDuplicates( Model model, ModelBuildingRequest request, ModelProblemCollector problems )\n    {\n        Build build = model.getBuild();\n        if ( build != null )\n        {\n            List<Plugin> original = build.getPlugins();\n            Map<Object, Plugin> normalized = new LinkedHashMap<Object, Plugin>();\n\n            for ( Plugin plugin : original )\n            {\n                Object key = plugin.getKey();\n                Plugin first = normalized.get( key );\n                if ( first != null )\n                {\n                    merger.mergePlugin( plugin, first );\n                }\n                normalized.put( key, plugin );\n            }\n\n            build.setPlugins( new ArrayList<Plugin>( normalized.values() ) );\n        }\n\n        /*\n         * NOTE: This is primarily to keep backward-compat with Maven 2.x which did not validate that dependencies are\n         * unique within a single POM. Upon multiple declarations, 2.x just kept the last one but retained the order of\n         * the first occurrence. So when we're in lenient/compat mode, we have to deal with such broken POMs and mimic\n         * the way 2.x works. When we're in strict mode, the removal of duplicates just saves other merging steps from\n         * aftereffects and bogus error messages.\n         */\n        Map<String, Dependency> dependencies = new LinkedHashMap<String, Dependency>();\n        for ( Dependency dependency : model.getDependencies() )\n        {\n            dependencies.put( dependency.getManagementKey(), dependency );\n        }\n        model.setDependencies( new ArrayList<Dependency>( dependencies.values() ) );\n    }","commit_id":"c980cfb28d6069dcd97ed58e57a6840fcaaca699","url":"https://github.com/apache/maven"},{"original_method":"private void validateDependencies( ModelProblemCollector problems, List<Dependency> dependencies, String prefix,\n                                       ModelBuildingRequest request )\n    {\n        Map<String, Dependency> index = new HashMap<String, Dependency>();\n\n        for ( Dependency dependency : dependencies )\n        {\n            String key = dependency.getManagementKey();\n\n            if ( \"pom\".equals( dependency.getType() ) && \"import\".equals( dependency.getScope() )\n                && StringUtils.isNotEmpty( dependency.getClassifier() ) )\n            {\n                addViolation( problems, false, \"'\" + prefix + \".classifier' must be empty for imported POM: \" + key );\n            }\n\n            Dependency existing = index.get( key );\n\n            if ( existing != null )\n            {\n                boolean warning = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n\n                String msg;\n                if ( String.valueOf( existing.getVersion() ).equals( dependency.getVersion() ) )\n                {\n                    msg = \"duplicate declaration of \" + dependency.getVersion();\n                }\n                else\n                {\n                    msg = existing.getVersion() + \" vs \" + dependency.getVersion();\n                }\n\n                addViolation( problems, warning, \"'\" + prefix\n                    + \".(groupId:artifactId:type:classifier)' must be unique: \" + key + \" -> \" + msg );\n            }\n            else\n            {\n                index.put( key, dependency );\n            }\n        }\n    }","id":47553,"modified_method":"private void validateDependencies( ModelProblemCollector problems, List<Dependency> dependencies, String prefix,\n                                       ModelBuildingRequest request )\n    {\n        Map<String, Dependency> index = new HashMap<String, Dependency>();\n\n        for ( Dependency dependency : dependencies )\n        {\n            String key = dependency.getManagementKey();\n\n            if ( \"pom\".equals( dependency.getType() ) && \"import\".equals( dependency.getScope() )\n                && StringUtils.isNotEmpty( dependency.getClassifier() ) )\n            {\n                addViolation( problems, false, \"'\" + prefix + \".classifier' must be empty for imported POM: \" + key );\n            }\n\n            Dependency existing = index.get( key );\n\n            if ( existing != null )\n            {\n                boolean warning = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n\n                String msg;\n                if ( StringUtils.isEmpty( existing.getVersion() ) && StringUtils.isEmpty( dependency.getVersion() ) )\n                {\n                    msg = \"duplicate declaration\";\n                }\n                else if ( existing.getVersion().equals( dependency.getVersion() ) )\n                {\n                    msg = \"duplicate declaration of version \" + dependency.getVersion();\n                }\n                else\n                {\n                    msg = \"version \" + existing.getVersion() + \" vs \" + dependency.getVersion();\n                }\n\n                addViolation( problems, warning, \"'\" + prefix\n                    + \".(groupId:artifactId:type:classifier)' must be unique: \" + key + \" -> \" + msg );\n            }\n            else\n            {\n                index.put( key, dependency );\n            }\n        }\n    }","commit_id":"c980cfb28d6069dcd97ed58e57a6840fcaaca699","url":"https://github.com/apache/maven"},{"original_method":"/**\n\t * Returns BATCH_SIZE value from configurationData()\n\t * \n\t * @return batch size for the display grid\n\t */\n\tprotected int batchSize() {\n\t\treturn Integer.parseInt((String) configurationData().valueForKey(BATCH_SIZE));\n\t}","id":47554,"modified_method":"/**\n\t * Returns BATCH_SIZE value from configurationData()\n\t * \n\t * @return batch size for the display grid\n\t */\n\tprotected int batchSize() {\n\t\tObject batchSizeObj = configurationData().objectForKey(AjaxGrid.BATCH_SIZE);\n\t\tint batchSize;\n\t\tif (batchSizeObj instanceof String) {\n\t\t\tbatchSize = Integer.parseInt((String)batchSizeObj);\n\t\t}\n\t\telse {\n\t\t\tbatchSize = ((Number)batchSizeObj).intValue();\n\t\t}\n\t\treturn batchSize;\n\t}","commit_id":"3831b3bb241c650dd6a4eef6b82b09d47b1a6550","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * @return displayGroup().numberOfObjectsPerBatch() as a String for the\n\t *         option input\n\t */\n\tpublic String currentBatchSize() {\n\t\treturn (String) configurationData().valueForKey(AjaxGrid.BATCH_SIZE);\n\t}","id":47555,"modified_method":"/**\n\t * @return displayGroup().numberOfObjectsPerBatch() as a String for the\n\t *         option input\n\t */\n\tpublic int currentBatchSize() {\n\t\tObject batchSizeObj = configurationData().objectForKey(AjaxGrid.BATCH_SIZE);\n\t\tint batchSize;\n\t\tif (batchSizeObj instanceof String) {\n\t\t\tbatchSize = Integer.parseInt((String)batchSizeObj);\n\t\t}\n\t\telse {\n\t\t\tbatchSize = ((Number)batchSizeObj).intValue();\n\t\t}\n\t\treturn batchSize;\n\t}","commit_id":"3831b3bb241c650dd6a4eef6b82b09d47b1a6550","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Ajax action method for updates to batch size. Grabs batch size from\n\t * request and updates configuration.\n\t */\n\tpublic void batchSizeUpdated() {\n\t\tString batchSizeString = (String) context().request().formValueForKey(\"batchSize\");\n\t\tint batchSizeIndex = Integer.parseInt(batchSizeString);\n\t\tconfigurationData().setObjectForKey(batchSizes().objectAtIndex(batchSizeIndex), AjaxGrid.BATCH_SIZE);\n\n\t\t// Keep display group in synch to avoid display update issues\n\t\tdisplayGroup().setNumberOfObjectsPerBatch(Integer.parseInt((String) configurationData().objectForKey(AjaxGrid.BATCH_SIZE)));\n\t}","id":47556,"modified_method":"/**\n\t * Ajax action method for updates to batch size. Grabs batch size from\n\t * request and updates configuration.\n\t */\n\tpublic void batchSizeUpdated() {\n\t\tString batchSizeString = (String) context().request().formValueForKey(\"batchSize\");\n\t\tint batchSizeIndex = Integer.parseInt(batchSizeString);\n\t\tconfigurationData().setObjectForKey(batchSizes().objectAtIndex(batchSizeIndex), AjaxGrid.BATCH_SIZE);\n\n\t\t// Keep display group in synch to avoid display update issues\n\t\t\n\t\tdisplayGroup().setNumberOfObjectsPerBatch(currentBatchSize());\n\t}","commit_id":"3831b3bb241c650dd6a4eef6b82b09d47b1a6550","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOElement template() {\n\t\ttry {\n\t\t\tWOElement element = null;\n\t\t\tString cacheKey = (String) valueForBinding(CACHE_KEY_BINDING);\n\t\t\tif (cacheKey != null) { // should cache\n\t\t\t\tCacheEntry cacheEntry = (CacheEntry) _cache.valueForKey(cacheKey);\n\t\t\t\tObject requestedVersion = valueForBinding(CACHE_VERSION_BINDING);\n\t\t\t\tif (cacheEntry != null && (requestedVersion == null || requestedVersion.equals(cacheEntry.version()))) {\n\t\t\t\t\t// requestedVersion matches or is null\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"using cache: \" + cacheKey + \" / \" + cacheEntry.version());\n\t\t\t\t\t}\n\t\t\t\t\telement = cacheEntry.element();\n\t\t\t\t}\n\t\t\t\telse { // no matching cache entry\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"updating cache: \" + cacheKey + \" / \" + (cacheEntry == null ? null : cacheEntry.version()) + \" -> \" + requestedVersion);\n\t\t\t\t\t}\n\t\t\t\t\telement = _template();\n\t\t\t\t\tcacheEntry = new CacheEntry(requestedVersion, element);\n\t\t\t\t\t_cache.takeValueForKey(cacheEntry, cacheKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { // no caching\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"caching disabled\");\n\t\t\t\t}\n\t\t\t\telement = _template();\n\t\t\t}\n\n\t\t\treturn element;\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\treturn WOComponent.templateWithHTMLString(new Error(\"template\", t).formatWithTemplate(errorTemplate()), \"\", null);\n\t\t}\n\t}","id":47557,"modified_method":"public WOElement template() {\n\t\ttry {\n\t\t\tWOElement element = null;\n\t\t\tString cacheKey = (String) valueForBinding(CACHE_KEY_BINDING);\n\t\t\tif (cacheKey != null) { // should cache\n\t\t\t\tCacheEntry cacheEntry = _cache.objectForKey(cacheKey);\n\t\t\t\tObject requestedVersion = valueForBinding(CACHE_VERSION_BINDING);\n\t\t\t\tif (cacheEntry != null && (requestedVersion == null || requestedVersion.equals(cacheEntry.version()))) {\n\t\t\t\t\t// requestedVersion matches or is null\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"using cache: \" + cacheKey + \" / \" + cacheEntry.version());\n\t\t\t\t\t}\n\t\t\t\t\telement = cacheEntry.element();\n\t\t\t\t}\n\t\t\t\telse { // no matching cache entry\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"updating cache: \" + cacheKey + \" / \" + (cacheEntry == null ? null : cacheEntry.version()) + \" -> \" + requestedVersion);\n\t\t\t\t\t}\n\t\t\t\t\telement = _template();\n\t\t\t\t\tcacheEntry = new CacheEntry(requestedVersion, element);\n\t\t\t\t\t_cache.takeValueForKey(cacheEntry, cacheKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { // no caching\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"caching disabled\");\n\t\t\t\t}\n\t\t\t\telement = _template();\n\t\t\t}\n\n\t\t\treturn element;\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\treturn WOComponent.templateWithHTMLString(new Error(\"template\", t).formatWithTemplate(errorTemplate()), \"\", null);\n\t\t}\n\t}","commit_id":"9c7d9a21e47d3ee82de27a0c33365be0e099aa50","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object valueForKeyPath(String keyPath) {\n\t\ttry {\n\t\t\tNSMutableArray keyPathComponents = NSArray.componentsSeparatedByString(keyPath, \".\").mutableClone();\n\t\t\tString firstKey = (String) keyPathComponents.removeObjectAtIndex(0);\n\t\t\tObject value;\n\t\t\tif (bindingKeys().contains(firstKey)) {\n\t\t\t\tObject o = valueForBinding(firstKey);\n\t\t\t\tif (keyPathComponents.count() > 0) {\n\t\t\t\t\tString remainingKeyPath = keyPathComponents.componentsJoinedByString(\".\");\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"get binding using keypath \" + firstKey + \" / \" + remainingKeyPath);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = NSKeyValueCodingAdditions.Utility.valueForKeyPath(o, remainingKeyPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"get binding value \" + firstKey);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = o;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proxyParent()) {\n\t\t\t\tif (log.isDebugEnabled()) { \n\t\t\t\t\tlog.debug(\"get parent binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tvalue = parent().valueForKeyPath(keyPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (log.isDebugEnabled()) { \n\t\t\t\t\tlog.debug(\"get dynamic binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tvalue = dynamicBindings().valueForKeyPath(keyPath);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t// save throwable\n\t\t\t_deferredError = new Error(\"takeValueForKeyPath\", t);\n\t\t\treturn null;\n\t\t}\n\t}","id":47558,"modified_method":"public Object valueForKeyPath(String keyPath) {\n\t\ttry {\n\t\t\tNSMutableArray<String> keyPathComponents = NSArray.componentsSeparatedByString(keyPath, \".\").mutableClone();\n\t\t\tString firstKey = (String) keyPathComponents.removeObjectAtIndex(0);\n\t\t\tObject value;\n\t\t\tif (bindingKeys().contains(firstKey)) {\n\t\t\t\tObject o = valueForBinding(firstKey);\n\t\t\t\tif (keyPathComponents.count() > 0) {\n\t\t\t\t\tString remainingKeyPath = keyPathComponents.componentsJoinedByString(\".\");\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"get binding using keypath \" + firstKey + \" / \" + remainingKeyPath);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = NSKeyValueCodingAdditions.Utility.valueForKeyPath(o, remainingKeyPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"get binding value \" + firstKey);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = o;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proxyParent()) {\n\t\t\t\tif (log.isDebugEnabled()) { \n\t\t\t\t\tlog.debug(\"get parent binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tvalue = parent().valueForKeyPath(keyPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (log.isDebugEnabled()) { \n\t\t\t\t\tlog.debug(\"get dynamic binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tvalue = dynamicBindings().valueForKeyPath(keyPath);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t// save throwable\n\t\t\t_deferredError = new Error(\"takeValueForKeyPath\", t);\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"9c7d9a21e47d3ee82de27a0c33365be0e099aa50","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void takeValueForKeyPath(Object value, String keyPath) {\n\t\ttry {\n\t\t\tNSMutableArray keyPathComponents = NSArray.componentsSeparatedByString(keyPath, \".\").mutableClone();\n\t\t\tString firstKey = (String) keyPathComponents.removeObjectAtIndex(0);\n\t\t\tif (bindingKeys().contains(firstKey)) {\n\t\t\t\tif (keyPathComponents.count() > 0) {\n\t\t\t\t\tObject o = valueForBinding(firstKey);\n\t\t\t\t\tString remainingKeyPath = keyPathComponents.componentsJoinedByString(\".\");\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"set binding using keypath \" + firstKey + \" / \" + remainingKeyPath);\n\t\t\t\t\t}\n\t\t\t\t\tNSKeyValueCodingAdditions.Utility.takeValueForKeyPath(o, value, remainingKeyPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"set binding value \" + firstKey);\n\t\t\t\t\t}\n\t\t\t\t\tsetValueForBinding(value, firstKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proxyParent()) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"set parent binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tparent().takeValueForKeyPath(value, keyPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"set dynamic binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tdynamicBindings().takeValueForKeyPath(value, keyPath);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_deferredError = new Error(\"takeValueForKeyPath\", t);\n\t\t}\n\t}","id":47559,"modified_method":"public void takeValueForKeyPath(Object value, String keyPath) {\n\t\ttry {\n\t\t\tNSMutableArray<String> keyPathComponents = NSArray.componentsSeparatedByString(keyPath, \".\").mutableClone();\n\t\t\tString firstKey = (String) keyPathComponents.removeObjectAtIndex(0);\n\t\t\tif (bindingKeys().contains(firstKey)) {\n\t\t\t\tif (keyPathComponents.count() > 0) {\n\t\t\t\t\tObject o = valueForBinding(firstKey);\n\t\t\t\t\tString remainingKeyPath = keyPathComponents.componentsJoinedByString(\".\");\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"set binding using keypath \" + firstKey + \" / \" + remainingKeyPath);\n\t\t\t\t\t}\n\t\t\t\t\tNSKeyValueCodingAdditions.Utility.takeValueForKeyPath(o, value, remainingKeyPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\t\tlog.debug(\"set binding value \" + firstKey);\n\t\t\t\t\t}\n\t\t\t\t\tsetValueForBinding(value, firstKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (proxyParent()) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"set parent binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tparent().takeValueForKeyPath(value, keyPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"set dynamic binding \" + keyPath);\n\t\t\t\t}\n\t\t\t\tdynamicBindings().takeValueForKeyPath(value, keyPath);\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_deferredError = new Error(\"takeValueForKeyPath\", t);\n\t\t}\n\t}","commit_id":"9c7d9a21e47d3ee82de27a0c33365be0e099aa50","url":"https://github.com/wocommunity/wonder"},{"original_method":"static Declaration getTopmostRefinedDeclaration(Declaration decl, Map<Method, Method> methodOverrides){\n        if (decl instanceof MethodOrValue\n                && ((MethodOrValue)decl).isParameter()\n                && decl.getContainer() instanceof Class) {\n            // Parameters in a refined class are not considered refinements themselves\n            // We have in find the refined attribute\n            Class c = (Class)decl.getContainer();\n            if (c.isAlias()) {\n                int index = c.getParameterList().getParameters().indexOf(findParamForDecl(((TypedDeclaration)decl)));\n                while (c.isAlias()) {\n                    c = c.getExtendedTypeDeclaration();\n                }\n                // be safe\n                if(c.getParameterList() == null\n                        || c.getParameterList().getParameters() == null\n                        || c.getParameterList().getParameters().size() <= index)\n                    return null;\n                decl = c.getParameterList().getParameters().get(index).getModel();\n            }\n            Declaration refinedDecl = c.getRefinedMember(decl.getName(), null, false);//?? elipses=false??\n            if(refinedDecl != null && refinedDecl != decl) {\n                return getTopmostRefinedDeclaration(refinedDecl, methodOverrides);\n            }\n            return decl;\n        } else if(decl instanceof MethodOrValue\n                && ((MethodOrValue)decl).isParameter() // a parameter\n                && ((decl.getContainer() instanceof Method && !(((Method)decl.getContainer()).isParameter())) // that's not parameter of a functional parameter \n                        || decl.getContainer() instanceof Specification // or is a parameter in a specification\n                        || (decl.getContainer() instanceof Method  \n                            && ((Method)decl.getContainer()).isParameter() \n                            && Strategy.createMethod((Method)decl.getContainer())))) {// or is a class functional parameter\n            // Parameters in a refined method are not considered refinements themselves\n            // so we have to look up the corresponding parameter in the container's refined declaration\n            Functional func = (Functional)getParameterized((MethodOrValue)decl);\n            if(func == null)\n                return decl;\n            Declaration kk = getTopmostRefinedDeclaration((Declaration)func, methodOverrides);\n            Functional refinedFunc = (Functional) kk;\n            // shortcut if the functional doesn't override anything\n            if(refinedFunc == func)\n                return decl;\n            if (func.getParameterLists().size() != refinedFunc.getParameterLists().size()) {\n                // invalid input\n                return decl;\n            }\n            for (int ii = 0; ii < func.getParameterLists().size(); ii++) {\n                if (func.getParameterLists().get(ii).getParameters().size() != refinedFunc.getParameterLists().get(ii).getParameters().size()) {\n                    // invalid input\n                    return decl;\n                }\n                // find the index of the parameter in the declaration\n                int index = 0;\n                for (Parameter px : func.getParameterLists().get(ii).getParameters()) {\n                    if (px.getModel().equals(decl)) {\n                        // And return the corresponding parameter from the refined declaration\n                        return refinedFunc.getParameterLists().get(ii).getParameters().get(index).getModel();\n                    }\n                    index++;\n                }\n                continue;\n            }\n        }else if(methodOverrides != null\n                && decl instanceof Method\n                && decl.getRefinedDeclaration() == decl\n                && decl.getContainer() instanceof Specification\n                && ((Specification)decl.getContainer()).getDeclaration() instanceof Method\n                && ((Method) ((Specification)decl.getContainer()).getDeclaration()).isShortcutRefinement()\n                // we do all the previous ones first because they are likely to filter out false positives cheaper than the\n                // hash lookup we do next to make sure it is really one of those cases\n                && methodOverrides.containsKey(decl)){\n            // special case for class X() extends T(){ m = function() => e; } which we inline\n            decl = methodOverrides.get(decl);\n        }\n        Declaration refinedDecl = decl.getRefinedDeclaration();\n        if(refinedDecl != null && refinedDecl != decl)\n            return getTopmostRefinedDeclaration(refinedDecl);\n        return decl;\n    }","id":47560,"modified_method":"static Declaration getTopmostRefinedDeclaration(Declaration decl, Map<Method, Method> methodOverrides){\n        if (decl instanceof MethodOrValue\n                && ((MethodOrValue)decl).isParameter()\n                && decl.getContainer() instanceof Class) {\n            // Parameters in a refined class are not considered refinements themselves\n            // We have in find the refined attribute\n            Class c = (Class)decl.getContainer();\n            boolean isAlias = c.isAlias();\n            boolean isActual = c.isActual();\n            // aliases and actual classes actually do refine their extended type parameters so the same rules apply wrt\n            // boxing and stuff\n            if (isAlias || isActual) {\n                int index = c.getParameterList().getParameters().indexOf(findParamForDecl(((TypedDeclaration)decl)));\n                // ATM we only consider aliases if we're looking at aliases, and same for actual, not mixing the two.\n                // Note(Stef): not entirely sure about that one, what about aliases of actual classes?\n                while ((isAlias && c.isAlias())\n                        || (isActual && c.isActual())) {\n                    c = c.getExtendedTypeDeclaration();\n                }\n                // be safe\n                if(c.getParameterList() == null\n                        || c.getParameterList().getParameters() == null\n                        || c.getParameterList().getParameters().size() <= index)\n                    return null;\n                decl = c.getParameterList().getParameters().get(index).getModel();\n            }\n\n            Declaration refinedDecl = c.getRefinedMember(decl.getName(), null, false);//?? elipses=false??\n            if(refinedDecl != null && refinedDecl != decl) {\n                return getTopmostRefinedDeclaration(refinedDecl, methodOverrides);\n            }\n            return decl;\n        } else if(decl instanceof MethodOrValue\n                && ((MethodOrValue)decl).isParameter() // a parameter\n                && ((decl.getContainer() instanceof Method && !(((Method)decl.getContainer()).isParameter())) // that's not parameter of a functional parameter \n                        || decl.getContainer() instanceof Specification // or is a parameter in a specification\n                        || (decl.getContainer() instanceof Method  \n                            && ((Method)decl.getContainer()).isParameter() \n                            && Strategy.createMethod((Method)decl.getContainer())))) {// or is a class functional parameter\n            // Parameters in a refined method are not considered refinements themselves\n            // so we have to look up the corresponding parameter in the container's refined declaration\n            Functional func = (Functional)getParameterized((MethodOrValue)decl);\n            if(func == null)\n                return decl;\n            Declaration kk = getTopmostRefinedDeclaration((Declaration)func, methodOverrides);\n            Functional refinedFunc = (Functional) kk;\n            // shortcut if the functional doesn't override anything\n            if(refinedFunc == func)\n                return decl;\n            if (func.getParameterLists().size() != refinedFunc.getParameterLists().size()) {\n                // invalid input\n                return decl;\n            }\n            for (int ii = 0; ii < func.getParameterLists().size(); ii++) {\n                if (func.getParameterLists().get(ii).getParameters().size() != refinedFunc.getParameterLists().get(ii).getParameters().size()) {\n                    // invalid input\n                    return decl;\n                }\n                // find the index of the parameter in the declaration\n                int index = 0;\n                for (Parameter px : func.getParameterLists().get(ii).getParameters()) {\n                    if (px.getModel().equals(decl)) {\n                        // And return the corresponding parameter from the refined declaration\n                        return refinedFunc.getParameterLists().get(ii).getParameters().get(index).getModel();\n                    }\n                    index++;\n                }\n                continue;\n            }\n        }else if(methodOverrides != null\n                && decl instanceof Method\n                && decl.getRefinedDeclaration() == decl\n                && decl.getContainer() instanceof Specification\n                && ((Specification)decl.getContainer()).getDeclaration() instanceof Method\n                && ((Method) ((Specification)decl.getContainer()).getDeclaration()).isShortcutRefinement()\n                // we do all the previous ones first because they are likely to filter out false positives cheaper than the\n                // hash lookup we do next to make sure it is really one of those cases\n                && methodOverrides.containsKey(decl)){\n            // special case for class X() extends T(){ m = function() => e; } which we inline\n            decl = methodOverrides.get(decl);\n        }\n        Declaration refinedDecl = decl.getRefinedDeclaration();\n        if(refinedDecl != null && refinedDecl != decl)\n            return getTopmostRefinedDeclaration(refinedDecl);\n        return decl;\n    }","commit_id":"96ad3261f90ac5cc31b0659770b573e900d47b13","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= transformDeclarationSharedFlags(cdecl);\n        result |= (cdecl.isAbstract() || cdecl.isFormal()) && (cdecl instanceof Class) && !cdecl.isAlias() ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() && (cdecl instanceof Class) ? FINAL : 0;\n\n        return result;\n    }","id":47561,"modified_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= transformDeclarationSharedFlags(cdecl);\n        // aliases cannot be abstract, especially since they're just placeholders\n        result |= (cdecl instanceof Class) && (cdecl.isAbstract() || cdecl.isFormal()) && !cdecl.isAlias() ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        // aliases are always final placeholders, final classes are also final\n        result |= (cdecl instanceof Class) && (cdecl.isAlias() || cdecl.isFinal())  ? FINAL : 0;\n\n        return result;\n    }","commit_id":"979db7180595eadc306bfedb8acd8346cdbe5c5e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= Decl.isShared(cdecl) ? PUBLIC : 0;\n        result |= cdecl.isAbstract() && (cdecl instanceof Class) ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() ? FINAL : 0;\n\n        return result;\n    }","id":47562,"modified_method":"private int transformClassDeclFlags(ClassOrInterface cdecl) {\n        int result = 0;\n\n        result |= Decl.isShared(cdecl) ? PUBLIC : 0;\n        result |= cdecl.isAbstract() && (cdecl instanceof Class) ? ABSTRACT : 0;\n        result |= (cdecl instanceof Interface) ? INTERFACE : 0;\n        result |= cdecl.isAlias() && (cdecl instanceof Class) ? FINAL : 0;\n\n        return result;\n    }","commit_id":"db7cb21e5cb86f37b0bba24acdf8b697fc9126ba","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        naming.noteDecl(model);\n        final String className;\n        String aliasedClassName = def.getIdentifier().getText();\n        if (def instanceof Tree.AnyInterface) {\n            className = Naming.declName(naming, model, QUALIFIED).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            className = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className, aliasedClassName);\n\n        if (def instanceof Tree.AnyClass) {\n            if(def instanceof Tree.ClassDefinition){\n                Tree.ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n                for (Tree.Parameter param : paramList.getParameters()) {\n                    classBuilder.parameter(param);\n                    DefaultArgument defaultArgument = param.getDefaultArgument();\n                    if (defaultArgument != null\n                            || param.getDeclarationModel().isSequenced()) {\n                        ClassDefinitionBuilder cbForDevaultValues;\n                        if (Strategy.defaultParameterMethodStatic(model)) {\n                            cbForDevaultValues = classBuilder;\n                        } else {\n                            cbForDevaultValues = classBuilder.getCompanionBuilder(model);\n                        }\n                        cbForDevaultValues.defs(makeParamDefaultValueMethod(false, def.getDeclarationModel(), paramList, param));\n                        // Add overloaded constructors for defaulted parameter\n                        MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                        makeOverloadsForDefaultedParameter(OL_BODY,\n                                overloadBuilder,\n                                model, paramList, param);\n                    }\n                }\n                satisfaction((Class)model, classBuilder);\n                at(def);\n            }else{\n                // class alias\n                classBuilder.constructorModifiers(PRIVATE);\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            //  Copy all the qualifying type's type parameters into the interface\n            ProducedType type = model.getType().getQualifyingType();\n            while (type != null) {\n                java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                if (typeArguments == null) {\n                    continue;\n                }\n                for (TypeParameter typeArgument : typeArguments) {\n                    classBuilder.typeParameter(typeArgument);\n                }\n                type = type.getQualifyingType();\n            }\n            \n            classBuilder.defs(makeCompanionAccessor((Interface)model, model.getType(), false));\n            // Build the companion class\n            buildCompanion(def, (Interface)model, classBuilder);   \n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = classBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.body(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .of(model.getSelfType())\n            .init(childDefs)\n            .build();\n    }","id":47563,"modified_method":"public List<JCTree> transform(final Tree.ClassOrInterface def) {\n        final ClassOrInterface model = def.getDeclarationModel();\n        naming.noteDecl(model);\n        final String className;\n        String aliasedClassName = def.getIdentifier().getText();\n        if (def instanceof Tree.AnyInterface) {\n            className = Naming.declName(naming, model, QUALIFIED).replaceFirst(\".*\\\\.\", \"\");\n        } else {\n            className = def.getIdentifier().getText();\n        }\n        ClassDefinitionBuilder classBuilder = ClassDefinitionBuilder\n                .klass(this, Decl.isAncestorLocal(def), className, aliasedClassName);\n\n        if (def instanceof Tree.AnyClass) {\n            if(def instanceof Tree.ClassDefinition){\n                Tree.ParameterList paramList = ((Tree.AnyClass)def).getParameterList();\n                for (Tree.Parameter param : paramList.getParameters()) {\n                    classBuilder.parameter(param);\n                    DefaultArgument defaultArgument = param.getDefaultArgument();\n                    if (defaultArgument != null\n                            || param.getDeclarationModel().isSequenced()) {\n                        ClassDefinitionBuilder cbForDevaultValues;\n                        if (Strategy.defaultParameterMethodStatic(model)) {\n                            cbForDevaultValues = classBuilder;\n                        } else {\n                            cbForDevaultValues = classBuilder.getCompanionBuilder(model);\n                        }\n                        cbForDevaultValues.defs(makeParamDefaultValueMethod(false, def.getDeclarationModel(), paramList, param));\n                        // Add overloaded constructors for defaulted parameter\n                        MethodDefinitionBuilder overloadBuilder = classBuilder.addConstructor();\n                        makeOverloadsForDefaultedParameter(OL_BODY,\n                                overloadBuilder,\n                                model, paramList, param);\n                    }\n                }\n                satisfaction((Class)model, classBuilder);\n                at(def);\n            }else{\n                // class alias\n                classBuilder.constructorModifiers(PRIVATE);\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n            }\n        }\n        \n        if (def instanceof Tree.AnyInterface) {\n            if(def instanceof Tree.InterfaceDefinition){\n                //  Copy all the qualifying type's type parameters into the interface\n                ProducedType type = model.getType().getQualifyingType();\n                while (type != null) {\n                    java.util.List<TypeParameter> typeArguments = type.getDeclaration().getTypeParameters();\n                    if (typeArguments == null) {\n                        continue;\n                    }\n                    for (TypeParameter typeArgument : typeArguments) {\n                        classBuilder.typeParameter(typeArgument);\n                    }\n                    type = type.getQualifyingType();\n                }\n                \n                classBuilder.defs(makeCompanionAccessor((Interface)model, model.getType(), false));\n                // Build the companion class\n                buildCompanion(def, (Interface)model, classBuilder);\n            }else{\n                // interface alias\n                classBuilder.annotations(makeAtAlias(model.getExtendedType()));\n            }\n        }\n        \n        // Transform the class/interface members\n        CeylonVisitor visitor = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = visitor.defs;\n        final boolean prevInInitializer = visitor.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = visitor.classBuilder;\n        List<JCStatement> childDefs;\n        try {\n            visitor.defs = new ListBuffer<JCTree>();\n            visitor.inInitializer = true;\n            visitor.classBuilder = classBuilder;\n            \n            def.visitChildren(visitor);\n            childDefs = (List<JCStatement>)visitor.getResult().toList();\n        } finally {\n            visitor.classBuilder = prevClassBuilder;\n            visitor.inInitializer = prevInInitializer;\n            visitor.defs = prevDefs;\n        }\n\n        // If it's a Class without initializer parameters...\n        if (Strategy.generateMain(def)) {\n            // ... then add a main() method\n            classBuilder.body(makeMainForClass(model));\n        }\n        \n        return classBuilder\n            .modelAnnotations(model.getAnnotations())\n            .modifiers(transformClassDeclFlags(def))\n            .satisfies(model.getSatisfiedTypes())\n            .caseTypes(model.getCaseTypes())\n            .of(model.getSelfType())\n            .init(childDefs)\n            .build();\n    }","commit_id":"db7cb21e5cb86f37b0bba24acdf8b697fc9126ba","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n   * List of all {@link org.sonar.server.computation.step.ComputationStep},\n   * ordered by execution sequence.\n   */\n  public List<Class<? extends ComputationStep>> orderedStepClasses() {\n    return Arrays.asList(\n      // extract report to a temp directory\n      ReportExtractionStep.class,\n\n      // Builds Component tree\n      BuildComponentTreeStep.class,\n      FillComponentsStep.class,\n      ValidateProjectStep.class,\n\n      FeedDebtModelStep.class,\n\n      // load project related stuffs\n      QualityGateLoadingStep.class,\n      FeedPeriodsStep.class,\n\n      // data computation\n      IntegrateIssuesStep.class,\n      CoreMetricFormulaExecutorStep.class,\n      CustomMeasuresCopyStep.class,\n\n      // SQALE measures depend on issues\n      SqaleMeasuresStep.class,\n      NewCoverageMeasuresStep.class,\n      NewCoverageAggregationStep.class,\n      CoverageMeasuresStep.class,\n\n      // Must be executed after computation of all measures\n      FillMeasuresWithVariationsStep.class,\n\n      // Must be executed after computation of differential measures\n      QualityGateMeasuresStep.class,\n      ComputeQProfileMeasureStep.class,\n      // Must be executed after computation of quality profile measure\n      QualityProfileEventsStep.class,\n\n      // Must be executed after computation of quality gate measure\n      QualityGateEventsStep.class,\n\n      // Persist data\n      PersistComponentsStep.class,\n      PersistSnapshotsStep.class,\n      PersistNumberOfDaysSinceLastCommitStep.class,\n      PersistMeasuresStep.class,\n      PersistIssuesStep.class,\n      PersistProjectLinksStep.class,\n      PersistEventsStep.class,\n      PersistDuplicationsStep.class,\n      PersistFileSourcesStep.class,\n      PersistTestsStep.class,\n\n      // Switch snapshot and purge\n      SwitchSnapshotStep.class,\n      IndexComponentsStep.class,\n      PurgeDatastoresStep.class,\n\n      // ES indexing is done after all db changes\n      ApplyPermissionsStep.class,\n      IndexIssuesStep.class,\n      IndexSourceLinesStep.class,\n      IndexTestsStep.class,\n\n      // notifications are sent at the end, so that webapp displays up-to-date information\n      SendIssueNotificationsStep.class);\n  }","id":47564,"modified_method":"/**\n   * List of all {@link org.sonar.server.computation.step.ComputationStep},\n   * ordered by execution sequence.\n   */\n  public List<Class<? extends ComputationStep>> orderedStepClasses() {\n    return Arrays.asList(\n      // extract report to a temp directory\n      ReportExtractionStep.class,\n\n      // Builds Component tree\n      BuildComponentTreeStep.class,\n      FillComponentsStep.class,\n      ValidateProjectStep.class,\n\n      FeedDebtModelStep.class,\n\n      // load project related stuffs\n      QualityGateLoadingStep.class,\n      FeedPeriodsStep.class,\n\n      // data computation\n      IntegrateIssuesStep.class,\n      CoreMetricFormulaExecutorStep.class,\n      CustomMeasuresCopyStep.class,\n\n      // SQALE measures depend on issues\n      SqaleMeasuresStep.class,\n      NewCoverageMeasuresStep.class,\n      CoverageMeasuresStep.class,\n\n      // Must be executed after computation of all measures\n      FillMeasuresWithVariationsStep.class,\n\n      // Must be executed after computation of differential measures\n      QualityGateMeasuresStep.class,\n      ComputeQProfileMeasureStep.class,\n      // Must be executed after computation of quality profile measure\n      QualityProfileEventsStep.class,\n\n      // Must be executed after computation of quality gate measure\n      QualityGateEventsStep.class,\n\n      // Persist data\n      PersistComponentsStep.class,\n      PersistSnapshotsStep.class,\n      PersistNumberOfDaysSinceLastCommitStep.class,\n      PersistMeasuresStep.class,\n      PersistIssuesStep.class,\n      PersistProjectLinksStep.class,\n      PersistEventsStep.class,\n      PersistDuplicationsStep.class,\n      PersistFileSourcesStep.class,\n      PersistTestsStep.class,\n\n      // Switch snapshot and purge\n      SwitchSnapshotStep.class,\n      IndexComponentsStep.class,\n      PurgeDatastoresStep.class,\n\n      // ES indexing is done after all db changes\n      ApplyPermissionsStep.class,\n      IndexIssuesStep.class,\n      IndexSourceLinesStep.class,\n      IndexTestsStep.class,\n\n      // notifications are sent at the end, so that webapp displays up-to-date information\n      SendIssueNotificationsStep.class);\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public NewCoverageMeasuresStep(TreeRootHolder treeRootHolder, PeriodsHolder periodsHolder, BatchReportReader batchReportReader,\n    MeasureRepository measureRepository, final MetricRepository metricRepository, NewCoverageMetricKeys... newCoverageMetricsList) {\n    this.treeRootHolder = treeRootHolder;\n    this.periodsHolder = periodsHolder;\n    this.batchReportReader = batchReportReader;\n    this.measureRepository = measureRepository;\n    this.newCoverageMetricsList = from(asList(newCoverageMetricsList))\n      .transform(new Function<NewCoverageMetricKeys, NewCoverageMetrics>() {\n        @Nullable\n        @Override\n        public NewCoverageMetrics apply(@Nullable NewCoverageMetricKeys input) {\n          return new NewCoverageMetrics(metricRepository, input);\n        }\n      })\n      .toList();\n  }","id":47565,"modified_method":"public NewCoverageMeasuresStep(TreeRootHolder treeRootHolder, PeriodsHolder periodsHolder, BatchReportReader batchReportReader,\n    MeasureRepository measureRepository, final MetricRepository metricRepository) {\n    this.treeRootHolder = treeRootHolder;\n    this.periodsHolder = periodsHolder;\n    this.batchReportReader = batchReportReader;\n    this.metricRepository = metricRepository;\n    this.measureRepository = measureRepository;\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void execute() {\n    new DepthTraversalTypeAwareVisitor(FILE, POST_ORDER) {\n      @Override\n      public void visitFile(Component file) {\n        if (!file.getFileAttributes().isUnitTest()) {\n          processFileComponent(file);\n        }\n      }\n    }.visit(treeRootHolder.getRoot());\n  }","id":47566,"modified_method":"@Override\n  public void execute() {\n    FormulaExecutorComponentVisitor.newBuilder(metricRepository, measureRepository)\n      .withVariationSupport(periodsHolder)\n      .buildFor(ImmutableList.<Formula>of(\n        // File coverage\n        new NewCoverageOnFileFormula(batchReportReader),\n        // IT File coverage\n        new NewCoverageOnITFileFormula(batchReportReader),\n        // Overall coverage\n        new NewOverallCoverageFormula(batchReportReader)\n        ))\n      .visit(treeRootHolder.getRoot());\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_computation_of_measures_for_new_conditions() {\n    treeRootHolder.setRoot(FILE_COMPONENT);\n    reportReader.putChangesets(Changesets.newBuilder()\n      .setComponentRef(1)\n      .addChangeset(Changesets.Changeset.newBuilder().build())\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2007-01-15\").getTime())\n        .build())\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2011-01-01\").getTime())\n        .build())\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(1)\n      .addChangesetIndexByLine(2)\n      .build()\n      );\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERAGE_LINE_HITS_DATA_KEY, newMeasureBuilder().create(\"10=2;11=3\"));\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), CONDITIONS_BY_LINE_KEY, newMeasureBuilder().create(\"11=4\"));\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERED_CONDITIONS_BY_LINE_KEY, newMeasureBuilder().create(\"11=1\"));\n\n    underTest.execute();\n\n    assertThat(toEntries(measureRepository.getNewRawMeasures(FILE_COMPONENT.getRef()))).containsOnly(\n      entryOf(NEW_LINES_TO_COVER_KEY, createMeasure(1d, null)),\n      entryOf(NEW_UNCOVERED_LINES_KEY, createMeasure(0d, null)),\n      entryOf(NEW_CONDITIONS_TO_COVER_KEY, createMeasure(4d, null)),\n      entryOf(NEW_UNCOVERED_CONDITIONS_KEY, createMeasure(3d, null))\n      );\n  }","id":47567,"modified_method":"@Test\n  public void verify_computation_of_measures_for_new_conditions_for_FILE() {\n    String coverageLineHitsData = COVERAGE_LINE_HITS_DATA_KEY;\n    String conditionsByLine = CONDITIONS_BY_LINE_KEY;\n    String coveredConditionsByLine = COVERED_CONDITIONS_BY_LINE_KEY;\n    String newLinesToCover = NEW_LINES_TO_COVER_KEY;\n    String newUncoveredLines = NEW_UNCOVERED_LINES_KEY;\n    String newConditionsToCover = NEW_CONDITIONS_TO_COVER_KEY;\n    String newUncoveredConditions = NEW_UNCOVERED_CONDITIONS_KEY;\n\n    verify_computation_of_measures_for_new_conditions(new MetricKeys(coverageLineHitsData, conditionsByLine, coveredConditionsByLine,\n      newLinesToCover, newUncoveredLines, newConditionsToCover, newUncoveredConditions));\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_no_measure_when_nothing_has_changed() {\n    treeRootHolder.setRoot(FILE_COMPONENT);\n    reportReader.putChangesets(BatchReport.Changesets.newBuilder()\n      .setComponentRef(1)\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2008-08-02\").getTime())\n        .build())\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .build());\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERAGE_LINE_HITS_DATA_KEY, newMeasureBuilder().create(\"2=1;3=1\"));\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), CONDITIONS_BY_LINE_KEY, newMeasureBuilder().create(\"2=1\"));\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERED_CONDITIONS_BY_LINE_KEY, newMeasureBuilder().create(\"2=1\"));\n\n    underTest.execute();\n\n    assertThat(toEntries(measureRepository.getNewRawMeasures(FILE_COMPONENT.getRef()))).containsOnly(\n      entryOf(NEW_LINES_TO_COVER_KEY, newMeasureBuilder().createNoValue()),\n      entryOf(NEW_UNCOVERED_LINES_KEY, newMeasureBuilder().createNoValue()),\n      entryOf(NEW_CONDITIONS_TO_COVER_KEY, newMeasureBuilder().createNoValue()),\n      entryOf(NEW_UNCOVERED_CONDITIONS_KEY, newMeasureBuilder().createNoValue())\n      );\n  }","id":47568,"modified_method":"@Test\n  public void verify_no_measure_when_nothing_has_changed() {\n    treeRootHolder.setRoot(FILE_COMPONENT);\n    reportReader.putChangesets(BatchReport.Changesets.newBuilder()\n      .setComponentRef(FILE_COMPONENT.getRef())\n      .addChangeset(Changesets.Changeset.newBuilder()\n          .setDate(parseDate(\"2008-08-02\").getTime())\n          .build())\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .build());\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERAGE_LINE_HITS_DATA_KEY, newMeasureBuilder().create(\"2=1;3=1\"));\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), CONDITIONS_BY_LINE_KEY, newMeasureBuilder().create(\"2=1\"));\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERED_CONDITIONS_BY_LINE_KEY, newMeasureBuilder().create(\"2=1\"));\n\n    underTest.execute();\n\n    assertThat(measureRepository.getNewRawMeasures(FILE_COMPONENT.getRef())).isEmpty();\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_measure_of_condition_not_computed_if_there_is_none() {\n    treeRootHolder.setRoot(FILE_COMPONENT);\n    reportReader.putChangesets(Changesets.newBuilder()\n      .setComponentRef(1)\n      .addChangeset(Changesets.Changeset.newBuilder().build())\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2007-01-15\").getTime())\n        .build())\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2011-01-01\").getTime())\n        .build())\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(1)\n      .addChangesetIndexByLine(2)\n      .build()\n      );\n\n    underTest.execute();\n\n    assertThat(measureRepository.isEmpty()).isTrue();\n  }","id":47569,"modified_method":"@Test\n  public void verify_measure_of_condition_not_computed_if_there_is_none() {\n    treeRootHolder.setRoot(FILE_COMPONENT);\n    reportReader.putChangesets(Changesets.newBuilder()\n            .setComponentRef(FILE_COMPONENT.getRef())\n            .addChangeset(Changesets.Changeset.newBuilder().build())\n            .addChangeset(Changesets.Changeset.newBuilder()\n                .setDate(parseDate(\"2007-01-15\").getTime())\n                .build())\n            .addChangeset(Changesets.Changeset.newBuilder()\n                .setDate(parseDate(\"2011-01-01\").getTime())\n                .build())\n            .addChangesetIndexByLine(0)\n            .addChangesetIndexByLine(1)\n            .addChangesetIndexByLine(2)\n            .build()\n    );\n\n    underTest.execute();\n\n    assertThat(measureRepository.isEmpty()).isTrue();\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_computation_of_measures_for_new_lines() {\n    treeRootHolder.setRoot(FILE_COMPONENT);\n    reportReader.putChangesets(BatchReport.Changesets.newBuilder()\n      .setComponentRef(1)\n      .addChangeset(Changesets.Changeset.newBuilder().build())\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2007-01-15\").getTime())\n        .build())\n      .addChangeset(Changesets.Changeset.newBuilder()\n        .setDate(parseDate(\"2011-01-01\").getTime())\n        .build())\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(1)\n      .addChangesetIndexByLine(2)\n      .build());\n    measureRepository.addRawMeasure(FILE_COMPONENT.getRef(), COVERAGE_LINE_HITS_DATA_KEY, newMeasureBuilder().create(\"10=2;11=3\"));\n\n    underTest.execute();\n\n    assertThat(toEntries(measureRepository.getNewRawMeasures(FILE_COMPONENT.getRef()))).containsOnly(\n      entryOf(NEW_LINES_TO_COVER_KEY, createMeasure(1d, null)),\n      entryOf(NEW_UNCOVERED_LINES_KEY, createMeasure(0d, null)),\n      entryOf(NEW_CONDITIONS_TO_COVER_KEY, createMeasure(0d, null)),\n      entryOf(NEW_UNCOVERED_CONDITIONS_KEY, createMeasure(0d, null))\n      );\n  }","id":47570,"modified_method":"@Test\n  public void verify_computation_of_measures_for_new_lines_for_FILE() {\n    String coverageLineHitsData = COVERAGE_LINE_HITS_DATA_KEY;\n    String newLinesToCover = NEW_LINES_TO_COVER_KEY;\n    String newUncoveredLines = NEW_UNCOVERED_LINES_KEY;\n    String newConditionsToCover = NEW_CONDITIONS_TO_COVER_KEY;\n    String newUncoveredConditions = NEW_UNCOVERED_CONDITIONS_KEY;\n\n    verify_computation_of_measures_for_new_lines(coverageLineHitsData,\n      newLinesToCover, newUncoveredLines, newConditionsToCover, newUncoveredConditions);\n  }","commit_id":"211a1e19207fa54ede307a3e3068521811714110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * @see org.apache.sling.installer.api.tasks.InstallTask#execute(org.apache.sling.installer.api.tasks.InstallationContext)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void execute(final InstallationContext ctx) {\n        synchronized ( ConfigTaskCreator.getLock() ) {\n            final ConfigurationAdmin ca = this.getConfigurationAdmin();\n\n            try {\n                final Configuration cfg = getConfiguration(ca, false);\n                if (cfg == null) {\n                    this.getLogger().debug(\"Cannot delete config , pid={} not found, ignored ({})\", getCompositePid(), getResource());\n                    this.setFinishedState(ResourceState.IGNORED);\n                } else {\n                    if ( !ConfigUtil.isSameData(cfg.getProperties(), this.getResource().getDictionary()) ) {\n                        this.getLogger().debug(\"Configuration has changed after it has been installed. Not removing!\");\n                        this.setFinishedState(ResourceState.IGNORED);\n                    } else {\n                        this.getLogger().debug(\"Deleting config {} ({})\", getCompositePid(), getResource());\n                        cfg.delete();\n                        ctx.log(\"Deleted configuration {} from resource {}\", getCompositePid(), getResource());\n                        this.setFinishedState(ResourceState.UNINSTALLED);\n                    }\n                }\n            } catch (Exception e) {\n                this.getLogger().debug(\"Exception during removal of config \" + this.getResource() + \" : \" + e.getMessage() + \". Retrying later.\", e);\n            }\n        }\n    }","id":47571,"modified_method":"/**\n     * @see org.apache.sling.installer.api.tasks.InstallTask#execute(org.apache.sling.installer.api.tasks.InstallationContext)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void execute(final InstallationContext ctx) {\n        synchronized ( ConfigTaskCreator.getLock() ) {\n            final ConfigurationAdmin ca = this.getConfigurationAdmin();\n\n            try {\n                final Configuration cfg = getConfiguration(ca, false);\n                if (cfg == null) {\n                    this.getLogger().debug(\"Cannot delete config , pid={} not found, ignored ({})\", getCompositePid(), getResource());\n                } else {\n                    if ( !ConfigUtil.isSameData(cfg.getProperties(), this.getResource().getDictionary()) ) {\n                        this.getLogger().debug(\"Configuration has changed after it has been installed!\");\n                    } else {\n                        this.getLogger().debug(\"Deleting config {} ({})\", getCompositePid(), getResource());\n                        cfg.delete();\n                        ctx.log(\"Deleted configuration {} from resource {}\", getCompositePid(), getResource());\n                    }\n                }\n            } catch (Exception e) {\n                this.getLogger().debug(\"Exception during removal of config \" + this.getResource() + \" : \" + e.getMessage() + \". Retrying later.\", e);\n            }\n            // we always set to uninstalled as the resource really has been deleted\n            this.setFinishedState(ResourceState.UNINSTALLED);\n        }\n    }","commit_id":"259c00c1ef3f1846736f98a33958d463599afdfd","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.osgi.service.cm.ConfigurationListener#configurationEvent(org.osgi.service.cm.ConfigurationEvent)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void configurationEvent(final ConfigurationEvent event) {\n        synchronized ( ConfigTaskCreator.getLock() ) {\n            final String id = (event.getFactoryPid() == null ? \"\" : event.getFactoryPid() + \".\") + event.getPid();\n            if ( event.getType() == ConfigurationEvent.CM_DELETED ) {\n                this.changeListener.resourceRemoved(InstallableResource.TYPE_CONFIG, id);\n            } else {\n                try {\n                    final Configuration config = ConfigUtil.getConfiguration(configAdmin,\n                            event.getFactoryPid(),\n                            event.getPid(),\n                            false);\n                    if ( config != null ) {\n                        final Dictionary<String, Object> dict = ConfigUtil.cleanConfiguration(config.getProperties());\n                        boolean persist = true;\n                        final Object persistProp = dict.get(ConfigurationConstants.PROPERTY_PERSISTENCE);\n                        if ( persistProp != null ) {\n                            if (persistProp instanceof Boolean) {\n                                persist = ((Boolean) persistProp).booleanValue();\n                            } else {\n                                persist = Boolean.valueOf(String.valueOf(persistProp));\n                            }\n                        }\n                        if ( persist ) {\n                            Map<String, Object> attrs = null;\n                            if ( config.getBundleLocation() != null ) {\n                                attrs = new HashMap<String, Object>();\n                                attrs.put(InstallableResource.INSTALLATION_HINT, config.getBundleLocation());\n                            }\n                            this.changeListener.resourceAddedOrUpdated(InstallableResource.TYPE_CONFIG, id, null, dict, attrs);\n                        }\n                    }\n                } catch ( final Exception ignore) {\n                    // ignore for now\n                }\n            }\n        }\n    }","id":47572,"modified_method":"/**\n     * @see org.osgi.service.cm.ConfigurationListener#configurationEvent(org.osgi.service.cm.ConfigurationEvent)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void configurationEvent(final ConfigurationEvent event) {\n        synchronized ( ConfigTaskCreator.getLock() ) {\n            final String id = (event.getFactoryPid() == null ? \"\" : event.getFactoryPid() + \".\") + event.getPid();\n            if ( event.getType() == ConfigurationEvent.CM_DELETED ) {\n                this.changeListener.resourceRemoved(InstallableResource.TYPE_CONFIG, id);\n            } else {\n                try {\n                    final Configuration config = ConfigUtil.getConfiguration(configAdmin,\n                            event.getFactoryPid(),\n                            event.getPid(),\n                            false);\n                    if ( config != null ) {\n                        final Dictionary<String, Object> dict = ConfigUtil.cleanConfiguration(config.getProperties());\n                        boolean persist = true;\n                        final Object persistProp = dict.get(ConfigurationConstants.PROPERTY_PERSISTENCE);\n                        if ( persistProp != null ) {\n                            if (persistProp instanceof Boolean) {\n                                persist = ((Boolean) persistProp).booleanValue();\n                            } else {\n                                persist = Boolean.valueOf(String.valueOf(persistProp));\n                            }\n                        }\n                        if ( persist ) {\n                            Map<String, Object> attrs = null;\n                            if ( config.getBundleLocation() != null ) {\n                                attrs = new HashMap<String, Object>();\n                                attrs.put(InstallableResource.INSTALLATION_HINT, config.getBundleLocation());\n                            }\n                            attrs.put(Constants.SERVICE_PID, event.getPid());\n                            // Factory?\n                            if (event.getFactoryPid() != null) {\n                                attrs.put(ConfigurationAdmin.SERVICE_FACTORYPID, event.getFactoryPid());\n                            }\n                            this.changeListener.resourceAddedOrUpdated(InstallableResource.TYPE_CONFIG, id, null, dict, attrs);\n                        }\n                    }\n                } catch ( final Exception ignore) {\n                    // ignore for now\n                }\n            }\n        }\n    }","commit_id":"259c00c1ef3f1846736f98a33958d463599afdfd","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.installer.api.ResourceChangeListener#resourceAddedOrUpdated(java.lang.String, java.lang.String, java.io.InputStream, java.util.Dictionary, Map)\n     */\n    public void resourceAddedOrUpdated(final String resourceType,\n            final String entityId,\n            final InputStream is,\n            final Dictionary<String, Object> dict,\n            final Map<String, Object> attributes) {\n        final String key = resourceType + ':' + entityId;\n        try {\n            final ResourceData data = ResourceData.create(is, dict);\n            synchronized ( this.resourcesLock ) {\n                final EntityResourceList erl = this.persistentList.getEntityResourceList(key);\n                logger.debug(\"Added or updated {} : {}\", key, erl);\n\n                // we first check for update\n                boolean updated = false;\n                if ( erl != null && erl.getFirstResource() != null ) {\n                    // check digest for dictionaries\n                    final TaskResource tr = erl.getFirstResource();\n                    if ( dict != null ) {\n                        final String digest = FileDataStore.computeDigest(dict);\n                        if ( tr.getState() == ResourceState.INSTALLED && tr.getDigest().equals(digest) ) {\n                            logger.debug(\"Resource did not change {}\", key);\n                            return;\n                        }\n                    }\n                    final UpdateHandler handler = this.findHandler(tr.getScheme());\n                    if ( handler == null ) {\n                        logger.debug(\"No handler found to handle update of resource with scheme {}\", tr.getScheme());\n                    } else {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = (localIS == null ? handler.handleUpdate(resourceType, entityId, tr.getURL(), data.getDictionary(), attributes)\n                                                                         : handler.handleUpdate(resourceType, entityId, tr.getURL(), localIS, attributes));\n                            if ( result != null ) {\n                                if ( !result.getURL().equals(tr.getURL()) && !result.getResourceIsMoved() ) {\n                                    // resource has been added!\n                                    final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                            result.getResourceId(),\n                                            null,\n                                            data.getDictionary(),\n                                            (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                            data.getDigest(result.getURL(), result.getDigest()),\n                                            result.getPriority(),\n                                            data.getDataFile());\n                                    final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                    final TransformationResult transRes = new TransformationResult();\n                                    transRes.setId(entityId);\n                                    transRes.setResourceType(resourceType);\n                                    this.persistentList.transform(rr, new TransformationResult[] {\n                                            transRes\n                                    });\n                                    final EntityResourceList newGroup = this.persistentList.getEntityResourceList(key);\n                                    newGroup.setFinishState(ResourceState.INSTALLED);\n                                    newGroup.compact();\n                                } else {\n                                    // resource has been updated or moved\n                                    ((RegisteredResourceImpl)tr).update(\n                                            data.getDataFile(), data.getDictionary(),\n                                            data.getDigest(result.getURL(), result.getDigest()),\n                                            result.getPriority(),\n                                            result.getURL());\n                                    // We first set the state of the resource to install to make setFinishState work in all cases\n                                    ((RegisteredResourceImpl)tr).setState(ResourceState.INSTALL);\n                                    erl.setFinishState(ResourceState.INSTALLED);\n                                    erl.compact();\n                                }\n                                updated = true;\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n                boolean created = false;\n                if ( !updated ) {\n                    // create\n                    final List<UpdateHandler> handlerList = this.updateHandlerTracker.getSortedServices();\n                    for(final UpdateHandler handler : handlerList) {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = (localIS == null ? handler.handleUpdate(resourceType, entityId, null, data.getDictionary(), attributes)\n                                                                         : handler.handleUpdate(resourceType, entityId, null, localIS, attributes));\n                            if ( result != null ) {\n                                final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                        result.getResourceId(),\n                                        null,\n                                        data.getDictionary(),\n                                        (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                        data.getDigest(result.getURL(), result.getDigest()),\n                                        result.getPriority(),\n                                        data.getDataFile());\n                                final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                final TransformationResult transRes = new TransformationResult();\n                                transRes.setId(entityId);\n                                transRes.setResourceType(resourceType);\n                                this.persistentList.transform(rr, new TransformationResult[] {\n                                        transRes\n                                });\n                                final EntityResourceList newGroup = this.persistentList.getEntityResourceList(key);\n                                newGroup.setFinishState(ResourceState.INSTALLED);\n                                newGroup.compact();\n                                created = true;\n                                break;\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n                    if ( !created ) {\n                        logger.debug(\"No handler found to handle creation of resource {}\", key);\n                    }\n                }\n                if ( updated || created ) {\n                    this.persistentList.save();\n                    this.wakeUp();\n                }\n\n            }\n        } catch (final IOException ioe) {\n            logger.error(\"Unable to handle resource add or update of \" + key, ioe);\n        } finally {\n            // always close the input stream!\n            if ( is != null ) {\n                try {\n                    is.close();\n                } catch (final IOException ignore) {\n                    // ignore\n                }\n            }\n        }\n    }","id":47573,"modified_method":"/**\n     * @see org.apache.sling.installer.api.ResourceChangeListener#resourceAddedOrUpdated(java.lang.String, java.lang.String, java.io.InputStream, java.util.Dictionary, Map)\n     */\n    public void resourceAddedOrUpdated(final String resourceType,\n            final String entityId,\n            final InputStream is,\n            final Dictionary<String, Object> dict,\n            final Map<String, Object> attributes) {\n        final String key = resourceType + ':' + entityId;\n        try {\n            final ResourceData data = ResourceData.create(is, dict);\n            synchronized ( this.resourcesLock ) {\n                final EntityResourceList erl = this.persistentList.getEntityResourceList(key);\n                logger.debug(\"Added or updated {} : {}\", key, erl);\n\n                // we first check for update\n                boolean updated = false;\n                if ( erl != null && erl.getFirstResource() != null ) {\n                    // check digest for dictionaries\n                    final TaskResource tr = erl.getFirstResource();\n                    if ( dict != null ) {\n                        final String digest = FileDataStore.computeDigest(dict);\n                        if ( tr.getState() == ResourceState.INSTALLED && tr.getDigest().equals(digest) ) {\n                            logger.debug(\"Resource did not change {}\", key);\n                            return;\n                        }\n                    }\n                    final UpdateHandler handler = this.findHandler(tr.getScheme());\n                    if ( handler == null ) {\n                        logger.debug(\"No handler found to handle update of resource with scheme {}\", tr.getScheme());\n                    } else {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = (localIS == null ? handler.handleUpdate(resourceType, entityId, tr.getURL(), data.getDictionary(), attributes)\n                                                                         : handler.handleUpdate(resourceType, entityId, tr.getURL(), localIS, attributes));\n                            if ( result != null ) {\n                                if ( !result.getURL().equals(tr.getURL()) && !result.getResourceIsMoved() ) {\n                                    // resource has been added!\n                                    final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                            result.getResourceId(),\n                                            null,\n                                            data.getDictionary(),\n                                            (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                            data.getDigest(result.getURL(), result.getDigest()),\n                                            result.getPriority(),\n                                            data.getDataFile());\n                                    final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                    final TransformationResult transRes = new TransformationResult();\n                                    transRes.setId(entityId);\n                                    transRes.setResourceType(resourceType);\n                                    if ( attributes != null ) {\n                                        transRes.setAttributes(attributes);\n                                    }\n                                    this.persistentList.transform(rr, new TransformationResult[] {\n                                            transRes\n                                    });\n                                    final EntityResourceList newGroup = this.persistentList.getEntityResourceList(key);\n                                    newGroup.setFinishState(ResourceState.INSTALLED);\n                                    newGroup.compact();\n                                } else {\n                                    // resource has been updated or moved\n                                    ((RegisteredResourceImpl)tr).update(\n                                            data.getDataFile(), data.getDictionary(),\n                                            data.getDigest(result.getURL(), result.getDigest()),\n                                            result.getPriority(),\n                                            result.getURL());\n                                    // We first set the state of the resource to install to make setFinishState work in all cases\n                                    ((RegisteredResourceImpl)tr).setState(ResourceState.INSTALL);\n                                    erl.setFinishState(ResourceState.INSTALLED);\n                                    erl.compact();\n                                }\n                                updated = true;\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n                boolean created = false;\n                if ( !updated ) {\n                    // create\n                    final List<UpdateHandler> handlerList = this.updateHandlerTracker.getSortedServices();\n                    for(final UpdateHandler handler : handlerList) {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = (localIS == null ? handler.handleUpdate(resourceType, entityId, null, data.getDictionary(), attributes)\n                                                                         : handler.handleUpdate(resourceType, entityId, null, localIS, attributes));\n                            if ( result != null ) {\n                                final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                        result.getResourceId(),\n                                        null,\n                                        data.getDictionary(),\n                                        (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                        data.getDigest(result.getURL(), result.getDigest()),\n                                        result.getPriority(),\n                                        data.getDataFile());\n                                final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                final TransformationResult transRes = new TransformationResult();\n                                transRes.setId(entityId);\n                                transRes.setResourceType(resourceType);\n                                if ( attributes != null ) {\n                                    transRes.setAttributes(attributes);\n                                }\n                                this.persistentList.transform(rr, new TransformationResult[] {\n                                        transRes\n                                });\n                                final EntityResourceList newGroup = this.persistentList.getEntityResourceList(key);\n                                newGroup.setFinishState(ResourceState.INSTALLED);\n                                newGroup.compact();\n                                created = true;\n                                break;\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n                    if ( !created ) {\n                        logger.debug(\"No handler found to handle creation of resource {}\", key);\n                    }\n                }\n                if ( updated || created ) {\n                    this.persistentList.save();\n                    this.wakeUp();\n                }\n\n            }\n        } catch (final IOException ioe) {\n            logger.error(\"Unable to handle resource add or update of \" + key, ioe);\n        } finally {\n            // always close the input stream!\n            if ( is != null ) {\n                try {\n                    is.close();\n                } catch (final IOException ignore) {\n                    // ignore\n                }\n            }\n        }\n    }","commit_id":"259c00c1ef3f1846736f98a33958d463599afdfd","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * @see org.apache.sling.installer.api.tasks.InstallTask#execute(org.apache.sling.installer.api.tasks.InstallationContext)\n\t */\n\tpublic void execute(final InstallationContext ctx) {\n\t    // this is just a sanity check which should never be reached\n        if (bundleId == 0) {\n            this.getLogger().debug(\"Bundle 0 is the framework bundle, ignoring request to start it\");\n            if ( this.getResource() != null ) {\n                this.setFinishedState(ResourceState.INSTALLED);\n            }\n            return;\n        }\n\n        // Do not execute this task if waiting for events\n        final long eventsCount = OsgiInstallerImpl.getTotalEventsCount();\n        if (eventsCount < eventsCountForRetrying) {\n            this.getLogger().debug(\"Task is not executable at this time, counters={}/{}\",\n                    eventsCountForRetrying, eventsCount);\n            if ( this.getResource() == null ) {\n                ctx.addTaskToNextCycle(this);\n            }\n            return;\n        }\n\n        final Bundle b = this.creator.getBundleContext().getBundle(bundleId);\n\t\tif (b == null) {\n\t\t    this.getLogger().info(\"Cannot start bundle, id not found: {}\", bundleId);\n\t\t\treturn;\n\t\t}\n\n        if (isBundleActive(b) ) {\n            this.getLogger().debug(\"Bundle already started, no action taken: {}/{}\", bundleId, b.getSymbolicName());\n            if ( this.getResource() != null ) {\n                this.setFinishedState(ResourceState.INSTALLED);\n            }\n            return;\n        }\n        // Try to start bundle, and if that doesn't work we'll need to retry\n        try {\n            b.start();\n            if ( this.getResource() != null ) {\n                this.setFinishedState(ResourceState.INSTALLED);\n            }\n            this.getLogger().info(\"Bundle started (retry count={}, bundle ID={}) : {}\",\n                    new Object[] {retryCount, bundleId, b.getSymbolicName()});\n        } catch (final BundleException e) {\n            this.getLogger().info(\"Could not start bundle (retry count={}, bundle ID={}) : {}. Reason: {}. Will retry.\",\n                    new Object[] {retryCount, bundleId, b.getSymbolicName(), e});\n\n            // Do the first retry immediately (in case \"something\" happenened right now\n            // that warrants a retry), but for the next ones wait for at least one bundle\n            // event or framework event\n            if (this.retryCount == 0) {\n                this.eventsCountForRetrying = OsgiInstallerImpl.getTotalEventsCount();\n            } else {\n                this.eventsCountForRetrying = OsgiInstallerImpl.getTotalEventsCount() + 1;\n            }\n            this.retryCount++;\n            if ( this.getResource() == null ) {\n                ctx.addTaskToNextCycle(this);\n            } else {\n                this.getResource().setTemporaryAttribute(ATTR_RC, this.retryCount);\n                this.getResource().setTemporaryAttribute(ATTR_EC, this.eventsCountForRetrying);\n            }\n        }\n\t}","id":47574,"modified_method":"/**\n\t * @see org.apache.sling.installer.api.tasks.InstallTask#execute(org.apache.sling.installer.api.tasks.InstallationContext)\n\t */\n\tpublic void execute(final InstallationContext ctx) {\n\t    // this is just a sanity check which should never be reached\n        if (bundleId == 0) {\n            this.getLogger().debug(\"Bundle 0 is the framework bundle, ignoring request to start it\");\n            if ( this.getResource() != null ) {\n                this.setFinishedState(ResourceState.INSTALLED);\n            }\n            return;\n        }\n\n        // Do not execute this task if waiting for events\n        final long eventsCount = OsgiInstallerImpl.getTotalEventsCount();\n        if (eventsCount < eventsCountForRetrying) {\n            this.getLogger().debug(\"Task is not executable at this time, counters={}/{}\",\n                    eventsCountForRetrying, eventsCount);\n            if ( this.getResource() == null ) {\n                ctx.addTaskToNextCycle(this);\n            }\n            return;\n        }\n\n        final Bundle b = this.creator.getBundleContext().getBundle(bundleId);\n\t\tif (b == null) {\n\t\t    this.getLogger().info(\"Cannot start bundle, id not found: {}\", bundleId);\n\t\t\treturn;\n\t\t}\n\n        final String fragmentHostHeader = getFragmentHostHeader(b);\n        if (fragmentHostHeader != null) {\n            this.getLogger().debug(\"Need to do a refresh of the bundle's host\");\n            for (final Bundle bundle : this.creator.getBundleContext().getBundles()) {\n                if (fragmentHostHeader.equals(bundle.getSymbolicName())) {\n                    this.getLogger().debug(\"Found host bundle to refresh {}\", bundle.getBundleId());\n                    this.creator.getPackageAdmin().refreshPackages(new Bundle[] { bundle });\n                    break;\n                }\n            }\n\n            this.setFinishedState(ResourceState.INSTALLED);\n        } else {\n            if (isBundleActive(b) ) {\n                this.getLogger().debug(\"Bundle already started, no action taken: {}/{}\", bundleId, b.getSymbolicName());\n                this.setFinishedState(ResourceState.INSTALLED);\n                return;\n            }\n            // Try to start bundle, and if that doesn't work we'll need to retry\n            try {\n                b.start();\n                this.setFinishedState(ResourceState.INSTALLED);\n                this.getLogger().info(\"Bundle started (retry count={}, bundle ID={}) : {}\",\n                        new Object[] {retryCount, bundleId, b.getSymbolicName()});\n            } catch (final BundleException e) {\n                this.getLogger().info(\"Could not start bundle (retry count={}, bundle ID={}) : {}. Reason: {}. Will retry.\",\n                        new Object[] {retryCount, bundleId, b.getSymbolicName(), e});\n\n                // Do the first retry immediately (in case \"something\" happenened right now\n                // that warrants a retry), but for the next ones wait for at least one bundle\n                // event or framework event\n                if (this.retryCount == 0) {\n                    this.eventsCountForRetrying = OsgiInstallerImpl.getTotalEventsCount();\n                } else {\n                    this.eventsCountForRetrying = OsgiInstallerImpl.getTotalEventsCount() + 1;\n                }\n                this.retryCount++;\n                if ( this.getResource() == null ) {\n                    ctx.addTaskToNextCycle(this);\n                } else {\n                    this.getResource().setTemporaryAttribute(ATTR_RC, this.retryCount);\n                    this.getResource().setTemporaryAttribute(ATTR_EC, this.eventsCountForRetrying);\n                }\n            }\n    \t}\n    }","commit_id":"2c426308c8ce690e01df0d28334e85b0a2c3ce78","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * Check if the bundle is active.\n\t * This is true if the bundle has the active state or of the bundle\n\t * is in the starting state and has the lazy activation policy.\n\t * Or if the bundle is a fragment, it's considered active as well\n\t */\n\tpublic static boolean isBundleActive(final Bundle b) {\n\t    if ( b.getState() == Bundle.ACTIVE ) {\n\t        return true;\n\t    }\n\t    if ( b.getState() == Bundle.STARTING && isLazyActivatian(b) ) {\n\t        return true;\n\t    }\n\t    if ( b.getHeaders().get(Constants.FRAGMENT_HOST) != null ) {\n\t        return true;\n\t    }\n        return false;\n\t}","id":47575,"modified_method":"/**\n\t * Check if the bundle is active.\n\t * This is true if the bundle has the active state or of the bundle\n\t * is in the starting state and has the lazy activation policy.\n\t * Or if the bundle is a fragment, it's considered active as well\n\t */\n\tpublic static boolean isBundleActive(final Bundle b) {\n\t    if ( b.getState() == Bundle.ACTIVE ) {\n\t        return true;\n\t    }\n\t    if ( b.getState() == Bundle.STARTING && isLazyActivatian(b) ) {\n\t        return true;\n\t    }\n\t    return ( getFragmentHostHeader(b) != null );\n\t}","commit_id":"2c426308c8ce690e01df0d28334e85b0a2c3ce78","url":"https://github.com/apache/sling"},{"original_method":"public ModelValidationResult validate( Model model )\n    {\n        ModelValidationResult result = new ModelValidationResult();\n\n        validateStringNotEmpty( \"modelVersion\", result, model.getModelVersion() );\n\n        validateId( \"groupId\", result, model.getGroupId() );\n\n        validateId( \"artifactId\", result, model.getArtifactId() );\n\n        validateStringNotEmpty( \"packaging\", result, model.getPackaging() );\n        \n        if ( !model.getModules().isEmpty() && !\"pom\".equals( model.getPackaging() ) )\n        {\n            result.addMessage( \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" +\n                    \"require 'pom' as packaging.\" );\n        }\n        \n        Parent parent = model.getParent();\n        if ( parent != null )\n        {\n            if ( parent.getGroupId().equals( model.getGroupId() ) && \n                    parent.getArtifactId().equals( model.getArtifactId() ) )\n            {\n                result.addMessage( \"The parent element cannot have the same ID as the project.\" );\n            }\n        }\n\n        validateStringNotEmpty( \"version\", result, model.getVersion() );\n\n        for ( Iterator it = model.getDependencies().iterator(); it.hasNext(); )\n        {\n            Dependency d = (Dependency) it.next();\n\n            validateId( \"dependencies.dependency.artifactId\", result, d.getArtifactId() );\n\n            validateId( \"dependencies.dependency.groupId\", result, d.getGroupId() );\n\n            validateStringNotEmpty( \"dependencies.dependency.type\", result, d.getType(), dependencySourceHint( d ) );\n\n            validateStringNotEmpty( \"dependencies.dependency.version\", result, d.getVersion(), dependencySourceHint( d ) );\n\n            if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage( \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n            }\n            else if ( !Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isNotEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage(\n                    \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n            }\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if ( mgmt != null )\n        {\n            for ( Iterator it = mgmt.getDependencies().iterator(); it.hasNext(); )\n            {\n                Dependency d = (Dependency) it.next();\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.artifactId\", result,\n                                                  d.getArtifactId() );\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.groupId\", result,\n                                                  d.getGroupId() );\n\n                if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n                }\n                else if ( !Artifact.SCOPE_SYSTEM.equals( d.getScope() ) && StringUtils.isNotEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n                }\n            }\n        }\n\n        Build build = model.getBuild();\n        if ( build != null )\n        {\n            for ( Iterator it = build.getPlugins().iterator(); it.hasNext(); )\n            {\n                Plugin p = (Plugin) it.next();\n\n                validateStringNotEmpty( \"build.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"build.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n\n            for ( Iterator it = build.getResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.resources.resource.directory\", result, r.getDirectory() );\n            }\n\n            for ( Iterator it = build.getTestResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.testResources.testResource.directory\", result, r.getDirectory() );\n            }\n        }\n\n        Reporting reporting = model.getReporting();\n        if ( reporting != null )\n        {\n            for ( Iterator it = reporting.getPlugins().iterator(); it.hasNext(); )\n            {\n                ReportPlugin p = (ReportPlugin) it.next();\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n        }\n\n        validateRepositories( result, model.getRepositories(), \"repositories.repository\" );\n\n        validateRepositories( result, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n\n        forcePluginExecutionIdCollision( model, result );\n\n        return result;\n    }","id":47576,"modified_method":"public ModelValidationResult validate( Model model )\n    {\n        ModelValidationResult result = new ModelValidationResult();\n\n        validateStringNotEmpty( \"modelVersion\", result, model.getModelVersion() );\n\n        validateId( \"groupId\", result, model.getGroupId() );\n\n        validateId( \"artifactId\", result, model.getArtifactId() );\n\n        validateStringNotEmpty( \"packaging\", result, model.getPackaging() );\n        \n        if ( !model.getModules().isEmpty() && !\"pom\".equals( model.getPackaging() ) )\n        {\n            result.addMessage( \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" +\n                    \"require 'pom' as packaging.\" );\n        }\n        \n        Parent parent = model.getParent();\n        if ( parent != null )\n        {\n            if ( parent.getGroupId().equals( model.getGroupId() ) && \n                    parent.getArtifactId().equals( model.getArtifactId() ) )\n            {\n                result.addMessage( \"The parent element cannot have the same ID as the project.\" );\n            }\n        }\n\n        validateStringNotEmpty( \"version\", result, model.getVersion() );\n\n        for ( Iterator it = model.getDependencies().iterator(); it.hasNext(); )\n        {\n            Dependency d = (Dependency) it.next();\n\n            validateId( \"dependencies.dependency.artifactId\", result, d.getArtifactId() );\n\n            validateId( \"dependencies.dependency.groupId\", result, d.getGroupId() );\n\n            validateStringNotEmpty( \"dependencies.dependency.type\", result, d.getType(), dependencySourceHint( d ) );\n\n            validateStringNotEmpty( \"dependencies.dependency.version\", result, d.getVersion(), dependencySourceHint( d ) );\n\n            if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) )\n            {\n                String systemPath = d.getSystemPath();\n                \n                if ( StringUtils.isEmpty( systemPath ) )\n                {\n                    result.addMessage( \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n                }\n                else\n                {\n                    if ( ! new File( systemPath ).isAbsolute() )\n                    {\n                        result.addMessage( \"For dependency \" + d + \": system-scoped dependency must \" +\n                                \"specify an absolute path systemPath.\" );\n                    }\n                }\n            }\n            else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n            {\n                result.addMessage(\n                    \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n            }\n        }\n\n        DependencyManagement mgmt = model.getDependencyManagement();\n        if ( mgmt != null )\n        {\n            for ( Iterator it = mgmt.getDependencies().iterator(); it.hasNext(); )\n            {\n                Dependency d = (Dependency) it.next();\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.artifactId\", result,\n                                                  d.getArtifactId() );\n\n                validateSubElementStringNotEmpty( d, \"dependencyManagement.dependencies.dependency.groupId\", result,\n                                                  d.getGroupId() );\n\n                if ( Artifact.SCOPE_SYSTEM.equals( d.getScope() ) )\n                {\n                    String systemPath = d.getSystemPath();\n                    \n                    if ( StringUtils.isEmpty( systemPath ) )\n                    {\n                        result.addMessage( \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\" );\n                    }\n                    else\n                    {\n                        if ( ! new File( systemPath ).isAbsolute() )\n                        {\n                            result.addMessage( \"For managed dependency \" + d + \": system-scoped dependency must \" +\n                                    \"specify an absolute path systemPath.\" );\n                        }\n                    }\n                }\n                else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n                {\n                    result.addMessage(\n                        \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\" );\n                }\n            }\n        }\n\n        Build build = model.getBuild();\n        if ( build != null )\n        {\n            for ( Iterator it = build.getPlugins().iterator(); it.hasNext(); )\n            {\n                Plugin p = (Plugin) it.next();\n\n                validateStringNotEmpty( \"build.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"build.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n\n            for ( Iterator it = build.getResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.resources.resource.directory\", result, r.getDirectory() );\n            }\n\n            for ( Iterator it = build.getTestResources().iterator(); it.hasNext(); )\n            {\n                Resource r = (Resource) it.next();\n\n                validateStringNotEmpty( \"build.testResources.testResource.directory\", result, r.getDirectory() );\n            }\n        }\n\n        Reporting reporting = model.getReporting();\n        if ( reporting != null )\n        {\n            for ( Iterator it = reporting.getPlugins().iterator(); it.hasNext(); )\n            {\n                ReportPlugin p = (ReportPlugin) it.next();\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.artifactId\", result, p.getArtifactId() );\n\n                validateStringNotEmpty( \"reporting.plugins.plugin.groupId\", result, p.getGroupId() );\n            }\n        }\n\n        validateRepositories( result, model.getRepositories(), \"repositories.repository\" );\n\n        validateRepositories( result, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n\n        forcePluginExecutionIdCollision( model, result );\n\n        return result;\n    }","commit_id":"c54202821e8edfcb7213a4f45fd20a318d4b8016","url":"https://github.com/apache/maven"},{"original_method":"public static void copyIDEALicense(final String sandboxHome, Sdk jdk){\n    if (isIDEALicenseInSandbox(sandboxHome + File.separator + CONFIG_DIR_NAME, sandboxHome + File.separator + \"system\", jdk.getHomePath() + File.separator + \"bin\") == null){\n      final File ideaLicense = isIDEALicenseInSandbox(PathManager.getConfigPath(), PathManager.getSystemPath(), PathManager.getBinPath());\n      if (ideaLicense != null){\n        try {\n          FileUtil.copy(ideaLicense, new File(new File(sandboxHome, CONFIG_DIR_NAME), LICENSE_PATH_PREFERRED));\n        }\n        catch (IOException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":47577,"modified_method":"public static void copyIDEALicense(final String sandboxHome) {\n    File sandboxSystemPath = new File(sandboxHome, \"system\");\n    File systemPath = new File(PathManager.getSystemPath());\n    File[] runningIdeaLicenses = systemPath.listFiles(new PatternFilenameFilter(\"idea\\\\d+\\\\.key\"));\n    if (runningIdeaLicenses != null) {\n      for (File license : runningIdeaLicenses) {\n        File devIdeaLicense = new File(sandboxSystemPath, license.getName());\n        if (!devIdeaLicense.exists()) {\n          try {\n            FileUtil.copy(license, devIdeaLicense);\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n      }\n    }\n  }","commit_id":"acf915b09f8678396b7bac271d0264fa53438064","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public RunProfileState getState(@NotNull final Executor executor, @NotNull final ExecutionEnvironment env) throws ExecutionException {\n    if (getModule() == null){\n      throw new ExecutionException(DevKitBundle.message(\"run.configuration.no.module.specified\"));\n    }\n    final ModuleRootManager rootManager = ModuleRootManager.getInstance(getModule());\n    final Sdk jdk = rootManager.getSdk();\n    if (jdk == null) {\n      throw CantRunException.noJdkForModule(getModule());\n    }\n\n    final Sdk ideaJdk = IdeaJdk.findIdeaJdk(jdk);\n    if (ideaJdk == null) {\n      throw new ExecutionException(DevKitBundle.message(\"sdk.type.incorrect.common\"));\n    }\n    String sandboxHome = ((Sandbox)ideaJdk.getSdkAdditionalData()).getSandboxHome();\n\n    if (sandboxHome == null){\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n\n    try {\n      sandboxHome = new File(sandboxHome).getCanonicalPath();\n    }\n    catch (IOException e) {\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n    final String canonicalSandbox = sandboxHome;\n\n    //copy license from running instance of idea\n    IdeaLicenseHelper.copyIDEALicense(sandboxHome, ideaJdk);\n\n    final JavaCommandLineState state = new JavaCommandLineState(env) {\n      @Override\n      protected JavaParameters createJavaParameters() throws ExecutionException {\n\n        final JavaParameters params = new JavaParameters();\n\n        ParametersList vm = params.getVMParametersList();\n\n        fillParameterList(vm, VM_PARAMETERS);\n        fillParameterList(params.getProgramParametersList(), PROGRAM_PARAMETERS);\n        Sdk usedIdeaJdk = ideaJdk;\n        if (isAlternativeJreEnabled() && !StringUtil.isEmptyOrSpaces(getAlternativeJrePath())) {\n          try {\n            usedIdeaJdk = (Sdk)usedIdeaJdk.clone();\n          }\n          catch (CloneNotSupportedException e) {\n            throw new ExecutionException(e.getMessage());\n          }\n          final SdkModificator sdkToSetUp = usedIdeaJdk.getSdkModificator();\n          sdkToSetUp.setHomePath(getAlternativeJrePath());\n          sdkToSetUp.commitChanges();\n        }\n        @NonNls String libPath = usedIdeaJdk.getHomePath() + File.separator + \"lib\";\n        vm.add(\"-Xbootclasspath/a:\" + libPath + File.separator + \"boot.jar\");\n\n        vm.defineProperty(\"idea.config.path\", canonicalSandbox + File.separator + \"config\");\n        vm.defineProperty(\"idea.system.path\", canonicalSandbox + File.separator + \"system\");\n        vm.defineProperty(\"idea.plugins.path\", canonicalSandbox + File.separator + \"plugins\");\n\n        if (SystemInfo.isMac) {\n          vm.defineProperty(\"idea.smooth.progress\", \"false\");\n          vm.defineProperty(\"apple.laf.useScreenMenuBar\", \"true\");\n        }\n\n        if (SystemInfo.isXWindow) {\n          if (VM_PARAMETERS == null || !VM_PARAMETERS.contains(\"-Dsun.awt.disablegrab\")) {\n            vm.defineProperty(\"sun.awt.disablegrab\", \"true\"); // See http://devnet.jetbrains.net/docs/DOC-1142\n          }\n        }\n\n        if (!vm.hasProperty(PlatformUtils.PLATFORM_PREFIX_KEY)) {\n          String buildNumber = IdeaJdk.getBuildNumber(usedIdeaJdk.getHomePath());\n\n          if (buildNumber != null) {\n            String prefix = IntelliJPlatformProduct.fromBuildNumber(buildNumber).getPlatformPrefix();\n            if (prefix != null) {\n              vm.defineProperty(PlatformUtils.PLATFORM_PREFIX_KEY, prefix);\n            }\n          }\n        }\n\n        params.setWorkingDirectory(usedIdeaJdk.getHomePath() + File.separator + \"bin\" + File.separator);\n\n        params.setJdk(usedIdeaJdk);\n\n        params.getClassPath().addFirst(libPath + File.separator + \"log4j.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"jdom.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"trove4j.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"openapi.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"util.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"extensions.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"bootstrap.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea_rt.jar\");\n        params.getClassPath().addFirst(((JavaSdkType)usedIdeaJdk.getSdkType()).getToolsPath(usedIdeaJdk));\n\n        params.setMainClass(\"com.intellij.idea.Main\");\n\n        return params;\n      }\n    };\n\n    return state;\n  }","id":47578,"modified_method":"@Override\n  public RunProfileState getState(@NotNull final Executor executor, @NotNull final ExecutionEnvironment env) throws ExecutionException {\n    if (getModule() == null){\n      throw new ExecutionException(DevKitBundle.message(\"run.configuration.no.module.specified\"));\n    }\n    final ModuleRootManager rootManager = ModuleRootManager.getInstance(getModule());\n    final Sdk jdk = rootManager.getSdk();\n    if (jdk == null) {\n      throw CantRunException.noJdkForModule(getModule());\n    }\n\n    final Sdk ideaJdk = IdeaJdk.findIdeaJdk(jdk);\n    if (ideaJdk == null) {\n      throw new ExecutionException(DevKitBundle.message(\"sdk.type.incorrect.common\"));\n    }\n    String sandboxHome = ((Sandbox)ideaJdk.getSdkAdditionalData()).getSandboxHome();\n\n    if (sandboxHome == null){\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n\n    try {\n      sandboxHome = new File(sandboxHome).getCanonicalPath();\n    }\n    catch (IOException e) {\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n    final String canonicalSandbox = sandboxHome;\n\n    //copy license from running instance of idea\n    IdeaLicenseHelper.copyIDEALicense(sandboxHome);\n\n    final JavaCommandLineState state = new JavaCommandLineState(env) {\n      @Override\n      protected JavaParameters createJavaParameters() throws ExecutionException {\n\n        final JavaParameters params = new JavaParameters();\n\n        ParametersList vm = params.getVMParametersList();\n\n        fillParameterList(vm, VM_PARAMETERS);\n        fillParameterList(params.getProgramParametersList(), PROGRAM_PARAMETERS);\n        Sdk usedIdeaJdk = ideaJdk;\n        if (isAlternativeJreEnabled() && !StringUtil.isEmptyOrSpaces(getAlternativeJrePath())) {\n          try {\n            usedIdeaJdk = (Sdk)usedIdeaJdk.clone();\n          }\n          catch (CloneNotSupportedException e) {\n            throw new ExecutionException(e.getMessage());\n          }\n          final SdkModificator sdkToSetUp = usedIdeaJdk.getSdkModificator();\n          sdkToSetUp.setHomePath(getAlternativeJrePath());\n          sdkToSetUp.commitChanges();\n        }\n        @NonNls String libPath = usedIdeaJdk.getHomePath() + File.separator + \"lib\";\n        vm.add(\"-Xbootclasspath/a:\" + libPath + File.separator + \"boot.jar\");\n\n        vm.defineProperty(\"idea.config.path\", canonicalSandbox + File.separator + \"config\");\n        vm.defineProperty(\"idea.system.path\", canonicalSandbox + File.separator + \"system\");\n        vm.defineProperty(\"idea.plugins.path\", canonicalSandbox + File.separator + \"plugins\");\n\n        if (SystemInfo.isMac) {\n          vm.defineProperty(\"idea.smooth.progress\", \"false\");\n          vm.defineProperty(\"apple.laf.useScreenMenuBar\", \"true\");\n        }\n\n        if (SystemInfo.isXWindow) {\n          if (VM_PARAMETERS == null || !VM_PARAMETERS.contains(\"-Dsun.awt.disablegrab\")) {\n            vm.defineProperty(\"sun.awt.disablegrab\", \"true\"); // See http://devnet.jetbrains.net/docs/DOC-1142\n          }\n        }\n\n        if (!vm.hasProperty(PlatformUtils.PLATFORM_PREFIX_KEY)) {\n          String buildNumber = IdeaJdk.getBuildNumber(usedIdeaJdk.getHomePath());\n\n          if (buildNumber != null) {\n            String prefix = IntelliJPlatformProduct.fromBuildNumber(buildNumber).getPlatformPrefix();\n            if (prefix != null) {\n              vm.defineProperty(PlatformUtils.PLATFORM_PREFIX_KEY, prefix);\n            }\n          }\n        }\n\n        params.setWorkingDirectory(usedIdeaJdk.getHomePath() + File.separator + \"bin\" + File.separator);\n\n        params.setJdk(usedIdeaJdk);\n\n        params.getClassPath().addFirst(libPath + File.separator + \"log4j.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"jdom.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"trove4j.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"openapi.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"util.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"extensions.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"bootstrap.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea_rt.jar\");\n        params.getClassPath().addFirst(((JavaSdkType)usedIdeaJdk.getSdkType()).getToolsPath(usedIdeaJdk));\n\n        params.setMainClass(\"com.intellij.idea.Main\");\n\n        return params;\n      }\n    };\n\n    return state;\n  }","commit_id":"acf915b09f8678396b7bac271d0264fa53438064","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** change default language for the router but don't save it */\n    public void setLang(String lang) {\n        // TODO: Protect with nonce or require POST\n        if (lang != null && lang.length() == 2)\n            _context.router().setConfigSetting(Messages.PROP_LANG, lang);\n    }","id":47579,"modified_method":"/** change default language for the router AND save it */\n    public void setLang(String lang) {\n        // Protected with nonce in css.jsi\n        if (lang != null && lang.length() == 2 && !lang.equals(_context.getProperty(Messages.PROP_LANG))) {\n            _context.router().setConfigSetting(Messages.PROP_LANG, lang);\n            _context.router().saveConfig();\n        }\n    }","commit_id":"b02fe536bcb94f12313006c3675225d2464e2e20","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setLang(String l) {\n        if((_lang == null || !_lang.equals(l)) && (l != null)) {\n            //Set language for router console\n            _lang = l;\n/*****\n TODO - Temporary for 0.8.4\n        Needed for desktopgui. But there's no nonce protection.\n        Move the following to CSSHelper setLang(), or disable completely,\n        See comments in CSSHelper\n*****/\n            if(_context == null) {\n                setContextId(null);\n            }\n\n            if (_context.getBooleanProperty(\"desktopgui.enabled\")) {\n                //Set language persistently throughout I2P\n                _context.router().setConfigSetting(Messages.PROP_LANG, _lang);\n                _context.router().saveConfig();\n                _context.setProperty(Messages.PROP_LANG, _lang);\n            }\n        }\n    }","id":47580,"modified_method":"public void setLang(String l) {\n/*****\n        if((_lang == null || !_lang.equals(l)) && (l != null)) {\n            //Set language for router console\n            _lang = l;\n TODO - Temporary for 0.8.4\n        Needed for desktopgui. But there's no nonce protection.\n        Move the following to CSSHelper setLang(), or disable completely,\n        See comments in CSSHelper\n            if(_context == null) {\n                setContextId(null);\n            }\n\n            if (_context.getBooleanProperty(\"desktopgui.enabled\")) {\n                //Set language persistently throughout I2P\n                _context.router().setConfigSetting(Messages.PROP_LANG, _lang);\n                _context.router().saveConfig();\n                _context.setProperty(Messages.PROP_LANG, _lang);\n            }\n        }\n*****/\n    }","commit_id":"b02fe536bcb94f12313006c3675225d2464e2e20","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Note - ensure all links in here are absolute, as the summary bar may be displayed\n     *         on lower-level directory errors.\n     */\n    public void renderSummaryHTML(Writer out) throws IOException {\n        StringBuilder buf = new StringBuilder(8*1024);\n        String theme = _context.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        \n        buf.append(\"<a href=\\\"/\\\" target=\\\"_top\\\"><img src=\\\"\")\n           .append(CSSHelper.BASE_THEME_PATH)\n           .append(theme)\n           .append(\"/images/i2plogo.png\\\" alt=\\\"\")\n           .append(_(\"I2P Router Console\"))\n           .append(\"\\\" title=\\\"\")\n           .append(_(\"I2P Router Console\"))\n           .append(\"\\\"><\/a><hr>\")\n           \n           .append(\"<h3><a href=\\\"/help\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"I2P Router Help &amp; FAQ\"))\n           .append(\"\\\">\")\n           .append(_(\"Help &amp; FAQ\"))\n           .append(\"<\/a><\/h3><hr>\");\n\n        File lpath = new File(_context.getBaseDir(), \"docs/toolbar.html\");\n        // you better have target=\"_top\" for the links in there...\n        if (lpath.exists()) {\n            ContentHelper linkhelper = new ContentHelper();\n            linkhelper.setPage(lpath.getAbsolutePath());\n            linkhelper.setMaxLines(\"100\");\n            buf.append(linkhelper.getContent());\n        } else {\n            buf.append(\"<h3><a href=\\\"/configclients\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Configure startup of clients and webapps (services); manually start dormant services\"))\n               .append(\"\\\">\")\n               .append(_(\"I2P Services\"))\n               .append(\"<\/a><\/h3>\\n\" +\n\n                       \"<hr><table>\" +\n\n                       \"<tr><td><a href=\\\"/susidns/index.jsp\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Manage your I2P hosts file here (I2P domain name resolution)\"))\n               .append(\"\\\">\")\n               .append(_(\"Addressbook\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/i2psnark/\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Built-in anonymous BitTorrent Client\"))\n               .append(\"\\\">\")\n               .append(_(\"Torrents\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/susimail/susimail\\\" target=\\\"blank\\\" title=\\\"\")\n               .append(_(\"Anonymous webmail client\"))\n               .append(\"\\\">\")\n               .append(_(\"Webmail\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"http://127.0.0.1:7658/\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Anonymous resident webserver\"))\n               .append(\"\\\">\")\n               .append(_(\"Webserver\"))\n               .append(\"<\/a>\")\n\n               .append(NavHelper.getClientAppLinks(_context))\n\n               .append(\"<\/td><\/tr><\/table>\\n\" +\n\n                       \"<hr><h3><a href=\\\"/config\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Configure I2P Router\"))\n               .append(\"\\\">\")\n               .append(_(\"I2P Internals\"))\n               .append(\"<\/a><\/h3><hr>\\n\" +\n\n                       \"<table><tr><td>\\n\" +\n\n                       \"<a href=\\\"/tunnels\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"View existing tunnels and tunnel build status\"))\n               .append(\"\\\">\")\n               .append(_(\"Tunnels\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/peers\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Show all current peer connections\"))\n               .append(\"\\\">\")\n               .append(_(\"Peers\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/profiles\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Show recent peer performance profiles\"))\n               .append(\"\\\">\")\n               .append(_(\"Profiles\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/netdb\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Show list of all known I2P routers\"))\n               .append(\"\\\">\")\n               .append(_(\"NetDB\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/logs\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Health Report\"))\n               .append(\"\\\">\")\n               .append(_(\"Logs\"))\n               .append(\"<\/a>\\n\" +\n\n           //          \"<a href=\\\"/jobs.jsp\\\" target=\\\"_top\\\" title=\\\"\")\n           //  .append(_(\"Show the router's workload, and how it's performing\"))\n           //  .append(\"\\\">\")\n           //  .append(_(\"Jobs\"))\n           //  .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/graphs\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Graph router performance\"))\n               .append(\"\\\">\")\n               .append(_(\"Graphs\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/stats\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Textual router performance statistics\"))\n               .append(\"\\\">\")\n               .append(_(\"Stats\"))\n               .append(\"<\/a>\\n\" +\n\n                        \"<a href=\\\"/i2ptunnel/\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Local Destinations\"))\n               .append(\"\\\">\")\n               .append(_(\"I2PTunnel\"))\n               .append(\"<\/a>\\n\");\n\n            File javadoc = new File(_context.getBaseDir(), \"docs/javadoc/index.html\");\n            if (javadoc.exists())\n                buf.append(\"<a href=\\\"/javadoc/index.html\\\" target=\\\"_blank\\\">Javadoc<\/a>\\n\");\n            buf.append(\"<\/td><\/tr><\/table>\\n\");\n\n            out.write(buf.toString());\n            buf.setLength(0);\n        }\n\n\n\n        buf.append(\"<hr><h3><a href=\\\"/help\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"I2P Router Help\"))\n           .append(\"\\\">\")\n           .append(_(\"General\"))\n           .append(\"<\/a><\/h3><hr>\\n\" +\n\n                   \"<table><tr>\" +\n                   \"<td align=\\\"left\\\"><b>\")\n           .append(_(\"Local Identity\"))\n           .append(\":<\/b><\/td>\" +\n                   \"<td align=\\\"right\\\">\" +\n                   \"<a title=\\\"\")\n           .append(_(\"Your unique I2P router identity is\"))\n           .append(' ')\n           .append(_helper.getIdent())\n           .append(\", \")\n           .append(_(\"never reveal it to anyone\"))\n           .append(\"\\\" href=\\\"/netdb?r=.\\\" target=\\\"_top\\\">\")\n           .append(_(\"show\"))\n           .append(\"<\/a><\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Version\"))\n           .append(\":<\/b><\/td>\" +\n                   \"<td align=\\\"right\\\">\")\n           .append(_helper.getVersion())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr title=\\\"\")\n           .append(_(\"How long we've been running for this session\"))\n           .append(\"\\\">\" +\n                   \"<td align=\\\"left\\\"><b>\")\n           .append(_(\"Uptime\"))\n           .append(\":<\/b><\/td>\" +\n                   \"<td align=\\\"right\\\">\")\n           .append(_helper.getUptime())\n           .append(\"<\/td><\/tr><\/table>\\n\" +\n\n                   \"<hr><h4><a href=\\\"/config#help\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"Help with configuring your firewall and router for optimal I2P performance\"))\n           .append(\"\\\">\")\n           .append(_(\"Network\"))\n           .append(\": \")\n           .append(_helper.getReachability())\n           .append(\"<\/a><\/h4><hr>\\n\");\n\n\n        // display all the time so we display the final failure message, and plugin update messages too\n        buf.append(UpdateHandler.getStatus());\n        if (_helper.updateAvailable() || _helper.unsignedUpdateAvailable()) {\n            if (\"true\".equals(System.getProperty(UpdateHandler.PROP_UPDATE_IN_PROGRESS))) {\n                // nothing\n            } else if(\n                      // isDone() is always false for now, see UpdateHandler\n                      // ((!update.isDone()) &&\n                      _helper.getAction() == null &&\n                      _helper.getUpdateNonce() == null &&\n                      ConfigRestartBean.getRestartTimeRemaining() > 12*60*1000) {\n                long nonce = _context.random().nextLong();\n                String prev = System.getProperty(\"net.i2p.router.web.UpdateHandler.nonce\");\n                if (prev != null)\n                    System.setProperty(\"net.i2p.router.web.UpdateHandler.noncePrev\", prev);\n                System.setProperty(\"net.i2p.router.web.UpdateHandler.nonce\", nonce+\"\");\n                String uri = _helper.getRequestURI();\n                buf.append(\"<p><form action=\\\"\").append(uri).append(\"\\\" method=\\\"POST\\\">\\n\");\n                buf.append(\"<input type=\\\"hidden\\\" name=\\\"updateNonce\\\" value=\\\"\").append(nonce).append(\"\\\" >\\n\");\n                if (_helper.updateAvailable()) {\n                    buf.append(\"<button type=\\\"submit\\\" name=\\\"updateAction\\\" value=\\\"signed\\\" >\")\n                       .append(_(\"Download\"))\n                       .append(' ')\n                       .append(_helper.getUpdateVersion())\n                       .append(' ')\n                       .append(_(\"Update\"))\n                       .append(\"<\/button>\\n\");\n                }\n                if (_helper.unsignedUpdateAvailable()) {\n                    buf.append(\"<button type=\\\"submit\\\" name=\\\"updateAction\\\" value=\\\"Unsigned\\\" >\")\n                       .append(_(\"Download Unsigned\"))\n                       .append(\"<br>\")\n                       .append(_(\"Update\"))\n                       .append(' ')\n                       .append(_helper.getUnsignedUpdateVersion())\n                       .append(\"<\/button>\\n\");\n                }\n                buf.append(\"<\/form>\\n\");\n            }\n        }\n\n\n\n\n        buf.append(\"<p>\")\n           .append(ConfigRestartBean.renderStatus(_helper.getRequestURI(), _helper.getAction(), _helper.getConsoleNonce()))\n\n           .append(\"<\/p><hr><h3><a href=\\\"/peers\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"Show all current peer connections\"))\n           .append(\"\\\">\")\n           .append(_(\"Peers\"))\n           .append(\"<\/a><\/h3><hr>\\n\" +\n\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Active\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\");\n        int active = _helper.getActivePeers();\n        buf.append(active)\n           .append(SummaryHelper.THINSP)\n           .append(Math.max(active, _helper.getActiveProfiles()))\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Fast\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getFastPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"High capacity\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getHighCapacityPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Integrated\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getWellIntegratedPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Known\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getAllPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<\/table><hr>\\n\");\n\n\n        out.write(buf.toString());\n        buf.setLength(0);\n\n\n        boolean anotherLine = false;\n        if (_helper.showFirewallWarning()) {\n            buf.append(\"<h4><a href=\\\"/config\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Help with firewall configuration\"))\n               .append(\"\\\">\")\n               .append(_(\"Check NAT/firewall\"))\n               .append(\"<\/a><\/h4>\");\n            anotherLine = true;\n        }\n\n        boolean reseedInProgress = Boolean.valueOf(System.getProperty(\"net.i2p.router.web.ReseedHandler.reseedInProgress\")).booleanValue();\n        // If showing the reseed link is allowed\n        if (_helper.allowReseed()) {\n            if (reseedInProgress) {\n                // While reseed occurring, show status message instead\n                buf.append(\"<i>\").append(System.getProperty(\"net.i2p.router.web.ReseedHandler.statusMessage\",\"\")).append(\"<\/i><br>\");\n            } else {\n                // While no reseed occurring, show reseed link\n                long nonce = _context.random().nextLong();\n                String prev = System.getProperty(\"net.i2p.router.web.ReseedHandler.nonce\");\n                if (prev != null) System.setProperty(\"net.i2p.router.web.ReseedHandler.noncePrev\", prev);\n                System.setProperty(\"net.i2p.router.web.ReseedHandler.nonce\", nonce+\"\");\n                String uri = _helper.getRequestURI();\n                buf.append(\"<p><form action=\\\"\").append(uri).append(\"\\\" method=\\\"POST\\\">\\n\");\n                buf.append(\"<input type=\\\"hidden\\\" name=\\\"reseedNonce\\\" value=\\\"\").append(nonce).append(\"\\\" >\\n\");\n                buf.append(\"<button type=\\\"submit\\\" value=\\\"Reseed\\\" >\").append(_(\"Reseed\")).append(\"<\/button><\/form><\/p>\\n\");\n            }\n            anotherLine = true;\n        }\n        // If a new reseed ain't running, and the last reseed had errors, show error message\n        if (!reseedInProgress) {\n            String reseedErrorMessage = System.getProperty(\"net.i2p.router.web.ReseedHandler.errorMessage\",\"\");\n            if (reseedErrorMessage.length() > 0) {\n                buf.append(\"<i>\").append(reseedErrorMessage).append(\"<\/i><br>\");\n                anotherLine = true;\n            }\n        }\n        if (anotherLine)\n            buf.append(\"<hr>\");\n\n\n        buf.append(\"<h3><a href=\\\"/config\\\" title=\\\"\")\n           .append(_(\"Configure router bandwidth allocation\"))\n           .append(\"\\\" target=\\\"_top\\\">\")\n           .append(_(\"Bandwidth in/out\"))\n           .append(\"<\/a><\/h3><hr>\" +\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(DataHelper.formatDuration2(3 * 1000))   // lie and say 3 sec since 1 sec would appear as 1000 ms\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getSecondKBps())\n           .append(\"Bps<\/td><\/tr>\\n\");\n\n        if (_context.router().getUptime() > 6*60*1000) {\n            buf.append(\"<tr><td align=\\\"left\\\"><b>\")\n           .append(DataHelper.formatDuration2(5 * 60 * 1000))   // 5 min\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getFiveMinuteKBps())\n           .append(\"Bps<\/td><\/tr>\\n\");\n        }\n\n        if (_context.router().getUptime() > 2*60*1000) {\n            buf.append(\"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Total\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getLifetimeKBps())\n           .append(\"Bps<\/td><\/tr>\\n\");\n        }\n\n        buf.append(\"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Used\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundTransferred())\n           .append(SummaryHelper.THINSP)\n           .append(_helper.getOutboundTransferred())\n           .append(\"<\/td><\/tr><\/table>\\n\" +\n\n                   \"<hr><h3><a href=\\\"/tunnels\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"View existing tunnels and tunnel build status\"))\n           .append(\"\\\">\")\n           .append(_(\"Tunnels\"))\n           .append(\"<\/a><\/h3><hr>\" +\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Exploratory\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundTunnels() + _helper.getOutboundTunnels())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                  \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Client\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundClientTunnels() + _helper.getOutboundClientTunnels())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Participating\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getParticipatingTunnels())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Share ratio\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getShareRatio())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<\/table><hr><h3><a href=\\\"/jobs\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"What's in the router's job queue?\"))\n           .append(\"\\\">\")\n           .append(_(\"Congestion\"))\n           .append(\"<\/a><\/h3><hr>\" +\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Job lag\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getJobLag())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Message delay\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getMessageDelay())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Tunnel lag\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getTunnelLag())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Backlog\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundBacklog())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<\/table><hr><h4>\")\n           .append(_(_helper.getTunnelStatus()))\n           .append(\"<\/h4><hr>\\n\")\n           .append(_helper.getDestinations());\n\n\n\n        out.write(buf.toString());\n    }","id":47581,"modified_method":"/**\n     *  Note - ensure all links in here are absolute, as the summary bar may be displayed\n     *         on lower-level directory errors.\n     */\n    public void renderSummaryHTML(Writer out) throws IOException {\n        StringBuilder buf = new StringBuilder(8*1024);\n        String theme = _context.getProperty(CSSHelper.PROP_THEME_NAME, CSSHelper.DEFAULT_THEME);\n        \n        buf.append(\"<a href=\\\"/\\\" target=\\\"_top\\\"><img src=\\\"\")\n           .append(CSSHelper.BASE_THEME_PATH)\n           .append(theme)\n           .append(\"/images/i2plogo.png\\\" alt=\\\"\")\n           .append(_(\"I2P Router Console\"))\n           .append(\"\\\" title=\\\"\")\n           .append(_(\"I2P Router Console\"))\n           .append(\"\\\"><\/a><hr>\")\n           \n           .append(\"<h3><a href=\\\"/help\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"I2P Router Help &amp; FAQ\"))\n           .append(\"\\\">\")\n           .append(_(\"Help &amp; FAQ\"))\n           .append(\"<\/a><\/h3><hr>\");\n\n        File lpath = new File(_context.getBaseDir(), \"docs/toolbar.html\");\n        // you better have target=\"_top\" for the links in there...\n        if (lpath.exists()) {\n            ContentHelper linkhelper = new ContentHelper();\n            linkhelper.setPage(lpath.getAbsolutePath());\n            linkhelper.setMaxLines(\"100\");\n            buf.append(linkhelper.getContent());\n        } else {\n            buf.append(\"<h3><a href=\\\"/configclients\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Configure startup of clients and webapps (services); manually start dormant services\"))\n               .append(\"\\\">\")\n               .append(_(\"I2P Services\"))\n               .append(\"<\/a><\/h3>\\n\" +\n\n                       \"<hr><table>\" +\n\n                       \"<tr><td><a href=\\\"/susidns/index.jsp\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Manage your I2P hosts file here (I2P domain name resolution)\"))\n               .append(\"\\\">\")\n               .append(_(\"Addressbook\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/i2psnark/\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Built-in anonymous BitTorrent Client\"))\n               .append(\"\\\">\")\n               .append(_(\"Torrents\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/susimail/susimail\\\" target=\\\"blank\\\" title=\\\"\")\n               .append(_(\"Anonymous webmail client\"))\n               .append(\"\\\">\")\n               .append(_(\"Webmail\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"http://127.0.0.1:7658/\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Anonymous resident webserver\"))\n               .append(\"\\\">\")\n               .append(_(\"Webserver\"))\n               .append(\"<\/a>\")\n\n               .append(NavHelper.getClientAppLinks(_context))\n\n               .append(\"<\/td><\/tr><\/table>\\n\" +\n\n                       \"<hr><h3><a href=\\\"/config\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Configure I2P Router\"))\n               .append(\"\\\">\")\n               .append(_(\"I2P Internals\"))\n               .append(\"<\/a><\/h3><hr>\\n\" +\n\n                       \"<table><tr><td>\\n\" +\n\n                       \"<a href=\\\"/tunnels\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"View existing tunnels and tunnel build status\"))\n               .append(\"\\\">\")\n               .append(_(\"Tunnels\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/peers\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Show all current peer connections\"))\n               .append(\"\\\">\")\n               .append(_(\"Peers\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/profiles\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Show recent peer performance profiles\"))\n               .append(\"\\\">\")\n               .append(_(\"Profiles\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/netdb\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Show list of all known I2P routers\"))\n               .append(\"\\\">\")\n               .append(_(\"NetDB\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/logs\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Health Report\"))\n               .append(\"\\\">\")\n               .append(_(\"Logs\"))\n               .append(\"<\/a>\\n\" +\n\n           //          \"<a href=\\\"/jobs.jsp\\\" target=\\\"_top\\\" title=\\\"\")\n           //  .append(_(\"Show the router's workload, and how it's performing\"))\n           //  .append(\"\\\">\")\n           //  .append(_(\"Jobs\"))\n           //  .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/graphs\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Graph router performance\"))\n               .append(\"\\\">\")\n               .append(_(\"Graphs\"))\n               .append(\"<\/a>\\n\" +\n\n                       \"<a href=\\\"/stats\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Textual router performance statistics\"))\n               .append(\"\\\">\")\n               .append(_(\"Stats\"))\n               .append(\"<\/a>\\n\" +\n\n                        \"<a href=\\\"/i2ptunnel/\\\" target=\\\"_blank\\\" title=\\\"\")\n               .append(_(\"Local Destinations\"))\n               .append(\"\\\">\")\n               .append(_(\"I2PTunnel\"))\n               .append(\"<\/a>\\n\");\n\n            File javadoc = new File(_context.getBaseDir(), \"docs/javadoc/index.html\");\n            if (javadoc.exists())\n                buf.append(\"<a href=\\\"/javadoc/index.html\\\" target=\\\"_blank\\\">Javadoc<\/a>\\n\");\n            buf.append(\"<\/td><\/tr><\/table>\\n\");\n\n            out.write(buf.toString());\n            buf.setLength(0);\n        }\n\n\n\n        buf.append(\"<hr><h3><a href=\\\"/help\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"I2P Router Help\"))\n           .append(\"\\\">\")\n           .append(_(\"General\"))\n           .append(\"<\/a><\/h3><hr>\\n\" +\n\n                   \"<table><tr>\" +\n                   \"<td align=\\\"left\\\"><b>\")\n           .append(_(\"Local Identity\"))\n           .append(\":<\/b><\/td>\" +\n                   \"<td align=\\\"right\\\">\" +\n                   \"<a title=\\\"\")\n           .append(_(\"Your unique I2P router identity is\"))\n           .append(' ')\n           .append(_helper.getIdent())\n           .append(\", \")\n           .append(_(\"never reveal it to anyone\"))\n           .append(\"\\\" href=\\\"/netdb?r=.\\\" target=\\\"_top\\\">\")\n           .append(_(\"show\"))\n           .append(\"<\/a><\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Version\"))\n           .append(\":<\/b><\/td>\" +\n                   \"<td align=\\\"right\\\">\")\n           .append(_helper.getVersion())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr title=\\\"\")\n           .append(_(\"How long we've been running for this session\"))\n           .append(\"\\\">\" +\n                   \"<td align=\\\"left\\\"><b>\")\n           .append(_(\"Uptime\"))\n           .append(\":<\/b><\/td>\" +\n                   \"<td align=\\\"right\\\">\")\n           .append(_helper.getUptime())\n           .append(\"<\/td><\/tr><\/table>\\n\" +\n\n                   \"<hr><h4><a href=\\\"/config#help\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"Help with configuring your firewall and router for optimal I2P performance\"))\n           .append(\"\\\">\")\n           .append(_(\"Network\"))\n           .append(\": \")\n           .append(_helper.getReachability())\n           .append(\"<\/a><\/h4><hr>\\n\");\n\n\n        // display all the time so we display the final failure message, and plugin update messages too\n        buf.append(UpdateHandler.getStatus());\n        if (_helper.updateAvailable() || _helper.unsignedUpdateAvailable()) {\n            if (\"true\".equals(System.getProperty(UpdateHandler.PROP_UPDATE_IN_PROGRESS))) {\n                // nothing\n            } else if(\n                      // isDone() is always false for now, see UpdateHandler\n                      // ((!update.isDone()) &&\n                      _helper.getAction() == null &&\n                      _helper.getUpdateNonce() == null &&\n                      ConfigRestartBean.getRestartTimeRemaining() > 12*60*1000) {\n                long nonce = _context.random().nextLong();\n                String prev = System.getProperty(\"net.i2p.router.web.UpdateHandler.nonce\");\n                if (prev != null)\n                    System.setProperty(\"net.i2p.router.web.UpdateHandler.noncePrev\", prev);\n                System.setProperty(\"net.i2p.router.web.UpdateHandler.nonce\", nonce+\"\");\n                String uri = _helper.getRequestURI();\n                buf.append(\"<form action=\\\"\").append(uri).append(\"\\\" method=\\\"POST\\\">\\n\");\n                buf.append(\"<input type=\\\"hidden\\\" name=\\\"updateNonce\\\" value=\\\"\").append(nonce).append(\"\\\" >\\n\");\n                if (_helper.updateAvailable()) {\n                    buf.append(\"<button type=\\\"submit\\\" name=\\\"updateAction\\\" value=\\\"signed\\\" >\")\n                       // Note to translators: parameter is a version, e.g. \"0.8.4\"\n                       .append(_(\"Download {0} Update\", _helper.getUpdateVersion()))\n                       .append(\"<\/button><br>\\n\");\n                }\n                if (_helper.unsignedUpdateAvailable()) {\n                    buf.append(\"<button type=\\\"submit\\\" name=\\\"updateAction\\\" value=\\\"Unsigned\\\" >\")\n                       // Note to translators: parameter is a date and time, e.g. \"02-Mar 20:34 UTC\"\n                       // <br> is optional, to help the browser make the lines even in the button\n                       // If the translation is shorter than the English, you should probably not include <br>\n                       .append(_(\"Download Unsigned<br>Update {0}\", _helper.getUnsignedUpdateVersion()))\n                       .append(\"<\/button><br>\\n\");\n                }\n                buf.append(\"<\/form>\\n\");\n            }\n        }\n\n\n\n\n        buf.append(ConfigRestartBean.renderStatus(_helper.getRequestURI(), _helper.getAction(), _helper.getConsoleNonce()))\n\n           .append(\"<hr><h3><a href=\\\"/peers\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"Show all current peer connections\"))\n           .append(\"\\\">\")\n           .append(_(\"Peers\"))\n           .append(\"<\/a><\/h3><hr>\\n\" +\n\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Active\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\");\n        int active = _helper.getActivePeers();\n        buf.append(active)\n           .append(SummaryHelper.THINSP)\n           .append(Math.max(active, _helper.getActiveProfiles()))\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Fast\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getFastPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"High capacity\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getHighCapacityPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Integrated\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getWellIntegratedPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Known\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getAllPeers())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<\/table><hr>\\n\");\n\n\n        out.write(buf.toString());\n        buf.setLength(0);\n\n\n        boolean anotherLine = false;\n        if (_helper.showFirewallWarning()) {\n            buf.append(\"<h4><a href=\\\"/config\\\" target=\\\"_top\\\" title=\\\"\")\n               .append(_(\"Help with firewall configuration\"))\n               .append(\"\\\">\")\n               .append(_(\"Check NAT/firewall\"))\n               .append(\"<\/a><\/h4>\");\n            anotherLine = true;\n        }\n\n        boolean reseedInProgress = Boolean.valueOf(System.getProperty(\"net.i2p.router.web.ReseedHandler.reseedInProgress\")).booleanValue();\n        // If showing the reseed link is allowed\n        if (_helper.allowReseed()) {\n            if (reseedInProgress) {\n                // While reseed occurring, show status message instead\n                buf.append(\"<i>\").append(System.getProperty(\"net.i2p.router.web.ReseedHandler.statusMessage\",\"\")).append(\"<\/i><br>\");\n            } else {\n                // While no reseed occurring, show reseed link\n                long nonce = _context.random().nextLong();\n                String prev = System.getProperty(\"net.i2p.router.web.ReseedHandler.nonce\");\n                if (prev != null) System.setProperty(\"net.i2p.router.web.ReseedHandler.noncePrev\", prev);\n                System.setProperty(\"net.i2p.router.web.ReseedHandler.nonce\", nonce+\"\");\n                String uri = _helper.getRequestURI();\n                buf.append(\"<p><form action=\\\"\").append(uri).append(\"\\\" method=\\\"POST\\\">\\n\");\n                buf.append(\"<input type=\\\"hidden\\\" name=\\\"reseedNonce\\\" value=\\\"\").append(nonce).append(\"\\\" >\\n\");\n                buf.append(\"<button type=\\\"submit\\\" value=\\\"Reseed\\\" >\").append(_(\"Reseed\")).append(\"<\/button><\/form><\/p>\\n\");\n            }\n            anotherLine = true;\n        }\n        // If a new reseed ain't running, and the last reseed had errors, show error message\n        if (!reseedInProgress) {\n            String reseedErrorMessage = System.getProperty(\"net.i2p.router.web.ReseedHandler.errorMessage\",\"\");\n            if (reseedErrorMessage.length() > 0) {\n                buf.append(\"<i>\").append(reseedErrorMessage).append(\"<\/i><br>\");\n                anotherLine = true;\n            }\n        }\n        if (anotherLine)\n            buf.append(\"<hr>\");\n\n\n        buf.append(\"<h3><a href=\\\"/config\\\" title=\\\"\")\n           .append(_(\"Configure router bandwidth allocation\"))\n           .append(\"\\\" target=\\\"_top\\\">\")\n           .append(_(\"Bandwidth in/out\"))\n           .append(\"<\/a><\/h3><hr>\" +\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(DataHelper.formatDuration2(3 * 1000))   // lie and say 3 sec since 1 sec would appear as 1000 ms\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getSecondKBps())\n           .append(\"Bps<\/td><\/tr>\\n\");\n\n        if (_context.router().getUptime() > 6*60*1000) {\n            buf.append(\"<tr><td align=\\\"left\\\"><b>\")\n           .append(DataHelper.formatDuration2(5 * 60 * 1000))   // 5 min\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getFiveMinuteKBps())\n           .append(\"Bps<\/td><\/tr>\\n\");\n        }\n\n        if (_context.router().getUptime() > 2*60*1000) {\n            buf.append(\"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Total\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getLifetimeKBps())\n           .append(\"Bps<\/td><\/tr>\\n\");\n        }\n\n        buf.append(\"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Used\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundTransferred())\n           .append(SummaryHelper.THINSP)\n           .append(_helper.getOutboundTransferred())\n           .append(\"<\/td><\/tr><\/table>\\n\" +\n\n                   \"<hr><h3><a href=\\\"/tunnels\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"View existing tunnels and tunnel build status\"))\n           .append(\"\\\">\")\n           .append(_(\"Tunnels\"))\n           .append(\"<\/a><\/h3><hr>\" +\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Exploratory\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundTunnels() + _helper.getOutboundTunnels())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                  \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Client\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundClientTunnels() + _helper.getOutboundClientTunnels())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Participating\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getParticipatingTunnels())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Share ratio\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getShareRatio())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<\/table><hr><h3><a href=\\\"/jobs\\\" target=\\\"_top\\\" title=\\\"\")\n           .append(_(\"What's in the router's job queue?\"))\n           .append(\"\\\">\")\n           .append(_(\"Congestion\"))\n           .append(\"<\/a><\/h3><hr>\" +\n                   \"<table>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Job lag\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getJobLag())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Message delay\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getMessageDelay())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Tunnel lag\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getTunnelLag())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<tr><td align=\\\"left\\\"><b>\")\n           .append(_(\"Backlog\"))\n           .append(\":<\/b><\/td><td align=\\\"right\\\">\")\n           .append(_helper.getInboundBacklog())\n           .append(\"<\/td><\/tr>\\n\" +\n\n                   \"<\/table><hr><h4>\")\n           .append(_(_helper.getTunnelStatus()))\n           .append(\"<\/h4><hr>\\n\")\n           .append(_helper.getDestinations());\n\n\n\n        out.write(buf.toString());\n    }","commit_id":"b02fe536bcb94f12313006c3675225d2464e2e20","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Write the a header for the current file to the output file.\n     *\n     * @param a_fileName\n     */\n    private void printFileHeader(String a_fileName) {\n        if (output != null) {\n            try {\n                char[] chars = new char[a_fileName.length() + 8];\n                Arrays.fill(chars, '#');\n                String header = new String(chars);\n                output.write(\"\\r\\n\" + header);\n                output.write(\"\\r\\n\");\n                output.write(\"### \" + a_fileName + \" ###\\r\\n\");\n                output.write(header + \"\\r\\n\\r\\n\");\n            } catch (IOException ex) {\n                logger.log(Level.SEVERE, String.format(\"Error writing to STIX report file %s\", reportPath), ex); //NON-NLS\n            }\n\n        }\n\n    }","id":47582,"modified_method":"/**\n     * Write the a header for the current file to the output file.\n     *\n     * @param a_fileName\n     */\n    private void printFileHeader(String a_fileName, BufferedWriter output) {\n        if (output != null) {\n            try {\n                char[] chars = new char[a_fileName.length() + 8];\n                Arrays.fill(chars, '#');\n                String header = new String(chars);\n                output.write(\"\\r\\n\" + header);\n                output.write(\"\\r\\n\");\n                output.write(\"### \" + a_fileName + \" ###\\r\\n\");\n                output.write(header + \"\\r\\n\\r\\n\");\n            } catch (IOException ex) {\n                logger.log(Level.SEVERE, String.format(\"Error writing to STIX report file %s\", reportPath), ex); //NON-NLS\n            }\n\n        }\n\n    }","commit_id":"dbe2091f1843b5d90d5c034b09b921bf72542827","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Process a STIX file.\n     *\n     * @param stixFile      - Name of the file\n     * @param progressPanel - Progress panel (for updating)\n     *\n     * @throws TskCoreException\n     */\n    private void processFile(String stixFile, ReportProgressPanel progressPanel) throws\n            TskCoreException {\n\n        // Load the STIX file\n        STIXPackage stix;\n        stix = loadSTIXFile(stixFile);\n\n        printFileHeader(stixFile);\n\n        // Save any observables listed up front\n        processObservables(stix);\n        progressPanel.increment();\n\n        // Make copies of the registry files\n        registryFileData = EvalRegistryObj.copyRegistryFiles();\n\n        // Process the indicators\n        processIndicators(stix);\n        progressPanel.increment();\n\n    }","id":47583,"modified_method":"/**\n     * Process a STIX file.\n     *\n     * @param stixFile      - Name of the file\n     * @param progressPanel - Progress panel (for updating)\n     *\n     * @throws TskCoreException\n     */\n    private void processFile(String stixFile, ReportProgressPanel progressPanel, BufferedWriter output) throws\n            TskCoreException {\n\n        // Load the STIX file\n        STIXPackage stix;\n        stix = loadSTIXFile(stixFile);\n\n        printFileHeader(stixFile, output);\n\n        // Save any observables listed up front\n        processObservables(stix);\n        progressPanel.increment();\n\n        // Make copies of the registry files\n        registryFileData = EvalRegistryObj.copyRegistryFiles();\n\n        // Process the indicators\n        processIndicators(stix, output);\n        progressPanel.increment();\n\n    }","commit_id":"dbe2091f1843b5d90d5c034b09b921bf72542827","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the full results string to the output file.\n     *\n     * @param ind       - Used to get the title, ID, and description of the\n     *                  indicator\n     * @param resultStr - Full results for this indicator\n     * @param found     - true if the indicator was found in datasource(s)\n     */\n    private void writeResultsToFile(Indicator ind, String resultStr, boolean found) {\n        if (output != null) {\n            try {\n                if (found) {\n                    output.write(\"----------------\\r\\n\"\n                            + \"Found indicator:\\r\\n\"); //NON-NLS\n                } else {\n                    output.write(\"-----------------------\\r\\n\"\n                            + \"Did not find indicator:\\r\\n\"); //NON-NLS\n                }\n                if (ind.getTitle() != null) {\n                    output.write(\"Title: \" + ind.getTitle() + \"\\r\\n\"); //NON-NLS\n                } else {\n                    output.write(\"\\r\\n\");\n                }\n                if (ind.getId() != null) {\n                    output.write(\"ID: \" + ind.getId() + \"\\r\\n\"); //NON-NLS\n                }\n\n                if (ind.getDescription() != null) {\n                    String desc = ind.getDescription().getValue();\n                    desc = desc.trim();\n                    output.write(\"Description: \" + desc + \"\\r\\n\"); //NON-NLS\n                }\n                output.write(\"\\r\\nObservable results:\\r\\n\" + resultStr + \"\\r\\n\\r\\n\"); //NON-NLS\n            } catch (IOException ex) {\n                logger.log(Level.SEVERE, String.format(\"Error writing to STIX report file %s\", reportPath), ex); //NON-NLS\n            }\n        }\n    }","id":47584,"modified_method":"/**\n     * Write the full results string to the output file.\n     *\n     * @param ind       - Used to get the title, ID, and description of the\n     *                  indicator\n     * @param resultStr - Full results for this indicator\n     * @param found     - true if the indicator was found in datasource(s)\n     */\n    private void writeResultsToFile(Indicator ind, String resultStr, boolean found, BufferedWriter output) {\n        if (output != null) {\n            try {\n                if (found) {\n                    output.write(\"----------------\\r\\n\"\n                            + \"Found indicator:\\r\\n\"); //NON-NLS\n                } else {\n                    output.write(\"-----------------------\\r\\n\"\n                            + \"Did not find indicator:\\r\\n\"); //NON-NLS\n                }\n                if (ind.getTitle() != null) {\n                    output.write(\"Title: \" + ind.getTitle() + \"\\r\\n\"); //NON-NLS\n                } else {\n                    output.write(\"\\r\\n\");\n                }\n                if (ind.getId() != null) {\n                    output.write(\"ID: \" + ind.getId() + \"\\r\\n\"); //NON-NLS\n                }\n\n                if (ind.getDescription() != null) {\n                    String desc = ind.getDescription().getValue();\n                    desc = desc.trim();\n                    output.write(\"Description: \" + desc + \"\\r\\n\"); //NON-NLS\n                }\n                output.write(\"\\r\\nObservable results:\\r\\n\" + resultStr + \"\\r\\n\\r\\n\"); //NON-NLS\n            } catch (IOException ex) {\n                logger.log(Level.SEVERE, String.format(\"Error writing to STIX report file %s\", reportPath), ex); //NON-NLS\n            }\n        }\n    }","commit_id":"dbe2091f1843b5d90d5c034b09b921bf72542827","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * .\n     *\n     * @param baseReportDir path to save the report\n     * @param progressPanel panel to update the report's progress\n     */\n    @Override\n    public void generateReport(String baseReportDir, ReportProgressPanel progressPanel) {\n        // Start the progress bar and setup the report\n        progressPanel.setIndeterminate(false);\n        progressPanel.start();\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.readSTIX\"));\n        reportPath = baseReportDir + getRelativeFilePath();\n\n        // Check if the user wants to display all output or just hits\n        reportAllResults = configPanel.getShowAllResults();\n\n        // Set up the output file\n        try {\n            File file = new File(reportPath);\n            output = new BufferedWriter(new FileWriter(file));\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, String.format(\"Unable to open STIX report file %s\", reportPath), ex); //NON-NLS\n            MessageNotifyUtil.Notify.show(\"STIXReportModule\", //NON-NLS\n                    NbBundle.getMessage(this.getClass(),\n                            \"STIXReportModule.notifyMsg.unableToOpenReportFile\",\n                            reportPath),\n                    MessageNotifyUtil.MessageType.ERROR);\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.completedWithErrors\"));\n            return;\n        }\n\n        // Keep track of whether any errors occur during processing\n        boolean hadErrors = false;\n\n        // Process the file/directory name entry\n        String stixFileName = configPanel.getStixFile();\n        if (stixFileName == null) {\n            logger.log(Level.SEVERE, \"STIXReportModuleConfigPanel.stixFile not initialized \"); //NON-NLS\n            MessageNotifyUtil.Message.error(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.notifyErr.noFildDirProvided\"));\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.noFildDirProvided\"));\n            return;\n        }\n        if (stixFileName.isEmpty()) {\n            logger.log(Level.SEVERE, \"No STIX file/directory provided \"); //NON-NLS\n            MessageNotifyUtil.Message.error(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.notifyErr.noFildDirProvided\"));\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.noFildDirProvided\"));\n            return;\n        }\n        File stixFile = new File(stixFileName);\n\n        if (!stixFile.exists()) {\n            logger.log(Level.SEVERE, String.format(\"Unable to open STIX file/directory %s\", stixFileName)); //NON-NLS\n            MessageNotifyUtil.Message.error(NbBundle.getMessage(this.getClass(),\n                    \"STIXReportModule.notifyMsg.unableToOpenFileDir\",\n                    stixFileName));\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.couldNotOpenFileDir\", stixFileName));\n            return;\n        }\n\n        // Store the path\n        ModuleSettings.setConfigSetting(\"STIX\", \"defaultPath\", stixFileName); //NON-NLS\n\n        // Create array of stix file(s)\n        File[] stixFiles;\n        if (stixFile.isFile()) {\n            stixFiles = new File[1];\n            stixFiles[0] = stixFile;\n        } else {\n            stixFiles = stixFile.listFiles();\n        }\n\n        // Set the length of the progress bar - we increment twice for each file\n        progressPanel.setMaximumProgress(stixFiles.length * 2 + 1);\n\n        // Process each STIX file\n        for (File file : stixFiles) {\n            try {\n                processFile(file.getAbsolutePath(), progressPanel);\n            } catch (TskCoreException ex) {\n                logger.log(Level.SEVERE, String.format(\"Unable to process STIX file %s\", file), ex); //NON-NLS\n                MessageNotifyUtil.Notify.show(\"STIXReportModule\", //NON-NLS\n                        ex.getLocalizedMessage(),\n                        MessageNotifyUtil.MessageType.ERROR);\n                hadErrors = true;\n            }\n\n            // Clear out the ID maps before loading the next file\n            idToObjectMap = new HashMap<String, ObjectType>();\n            idToResult = new HashMap<String, ObservableResult>();\n        }\n\n        // Close the output file\n        if (output != null) {\n            try {\n                output.close();\n            } catch (IOException ex) {\n                logger.log(Level.SEVERE, String.format(\"Error closing STIX report file %s\", reportPath), ex); //NON-NLS\n            }\n        }\n\n        // Set the progress bar to done. If any errors occurred along the way, modify\n        // the \"complete\" message to indicate this.\n        if (hadErrors) {\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.completedWithErrors\"));\n        } else {\n            progressPanel.complete(ReportStatus.COMPLETE);\n        }\n    }","id":47585,"modified_method":"/**\n     * .\n     *\n     * @param baseReportDir path to save the report\n     * @param progressPanel panel to update the report's progress\n     */\n    @Override\n    public void generateReport(String baseReportDir, ReportProgressPanel progressPanel) {\n        // Start the progress bar and setup the report\n        progressPanel.setIndeterminate(false);\n        progressPanel.start();\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.readSTIX\"));\n        reportPath = baseReportDir + getRelativeFilePath();\n\n        // Check if the user wants to display all output or just hits\n        reportAllResults = configPanel.getShowAllResults();\n\n        // Set up the output file\n        // Keep track of whether any errors occur during processing\n        boolean hadErrors = false;\n\n        // Process the file/directory name entry\n        String stixFileName = configPanel.getStixFile();\n        File reportFile = new File(reportPath);\n        if (stixFileName == null) {\n            logger.log(Level.SEVERE, \"STIXReportModuleConfigPanel.stixFile not initialized \"); //NON-NLS\n            MessageNotifyUtil.Message.error(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.notifyErr.noFildDirProvided\"));\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.noFildDirProvided\"));\n            new File(baseReportDir).delete();\n            return;\n        }\n        if (stixFileName.isEmpty()) {\n            logger.log(Level.SEVERE, \"No STIX file/directory provided \"); //NON-NLS\n            MessageNotifyUtil.Message.error(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.notifyErr.noFildDirProvided\"));\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.noFildDirProvided\"));\n            new File(baseReportDir).delete();\n            return;\n        }\n        File stixFile = new File(stixFileName);\n\n        if (!stixFile.exists()) {\n            logger.log(Level.SEVERE, String.format(\"Unable to open STIX file/directory %s\", stixFileName)); //NON-NLS\n            MessageNotifyUtil.Message.error(NbBundle.getMessage(this.getClass(),\n                    \"STIXReportModule.notifyMsg.unableToOpenFileDir\",\n                    stixFileName));\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.couldNotOpenFileDir\", stixFileName));\n            new File(baseReportDir).delete();\n            return;\n        }\n        \n        try (BufferedWriter output = new BufferedWriter(new FileWriter(reportFile))) {\n            // Store the path\n            ModuleSettings.setConfigSetting(\"STIX\", \"defaultPath\", stixFileName); //NON-NLS\n\n            // Create array of stix file(s)\n            File[] stixFiles;\n            if (stixFile.isFile()) {\n                stixFiles = new File[1];\n                stixFiles[0] = stixFile;\n            } else {\n                stixFiles = stixFile.listFiles();\n            }\n\n            // Set the length of the progress bar - we increment twice for each file\n            progressPanel.setMaximumProgress(stixFiles.length * 2 + 1);\n\n            // Process each STIX file\n            for (File file : stixFiles) {\n                try {\n                    processFile(file.getAbsolutePath(), progressPanel, output);\n                } catch (TskCoreException ex) {\n                    logger.log(Level.SEVERE, String.format(\"Unable to process STIX file %s\", file), ex); //NON-NLS\n                    MessageNotifyUtil.Notify.show(\"STIXReportModule\", //NON-NLS\n                            ex.getLocalizedMessage(),\n                            MessageNotifyUtil.MessageType.ERROR);\n                    hadErrors = true;\n                }\n\n                // Clear out the ID maps before loading the next file\n                idToObjectMap = new HashMap<String, ObjectType>();\n                idToResult = new HashMap<String, ObservableResult>();\n            }\n\n            // Close the output file\n            if (output != null) {\n                try {\n                    output.close();\n                } catch (IOException ex) {\n                    logger.log(Level.SEVERE, String.format(\"Error closing STIX report file %s\", reportPath), ex); //NON-NLS\n                }\n            }\n\n            // Set the progress bar to done. If any errors occurred along the way, modify\n            // the \"complete\" message to indicate this.\n            if (hadErrors) {\n                progressPanel.complete(ReportStatus.ERROR);\n                progressPanel.updateStatusLabel(\n                        NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.completedWithErrors\"));\n            } else {\n                Case.getCurrentCase().addReport(reportPath, stixFileName, \"\");\n                progressPanel.complete(ReportStatus.COMPLETE);\n            }\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, String.format(\"Unable to open STIX report file %s\", reportPath), ex); //NON-NLS\n            MessageNotifyUtil.Notify.show(\"STIXReportModule\", //NON-NLS\n                    NbBundle.getMessage(this.getClass(),\n                            \"STIXReportModule.notifyMsg.unableToOpenReportFile\",\n                            reportPath),\n                    MessageNotifyUtil.MessageType.ERROR);\n            progressPanel.complete(ReportStatus.ERROR);\n            progressPanel.updateStatusLabel(\n                    NbBundle.getMessage(this.getClass(), \"STIXReportModule.progress.completedWithErrors\"));\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to add report to database.\", ex);\n        }\n    }","commit_id":"dbe2091f1843b5d90d5c034b09b921bf72542827","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Process all STIX indicators and save results to output file and create\n     * artifacts.\n     *\n     * @param stix STIXPackage\n     */\n    private void processIndicators(STIXPackage stix) throws TskCoreException {\n        if (stix.getIndicators() != null) {\n            List<IndicatorBaseType> s = stix.getIndicators().getIndicators();\n            for (IndicatorBaseType t : s) {\n                if (t instanceof Indicator) {\n                    Indicator ind = (Indicator) t;\n                    if (ind.getObservable() != null) {\n                        if (ind.getObservable().getObject() != null) {\n                            ObservableResult result = evaluateSingleObservable(ind.getObservable(), \"\");\n                            if (result.isTrue() || reportAllResults) {\n                                writeResultsToFile(ind, result.getDescription(), result.isTrue());\n                            }\n                            if (result.isTrue()) {\n                                saveResultsAsArtifacts(ind, result);\n                            }\n                        } else if (ind.getObservable().getObservableComposition() != null) {\n                            ObservableResult result = evaluateObservableComposition(ind.getObservable().getObservableComposition(), \"  \");\n\n                            if (result.isTrue() || reportAllResults) {\n                                writeResultsToFile(ind, result.getDescription(), result.isTrue());\n                            }\n                            if (result.isTrue()) {\n                                saveResultsAsArtifacts(ind, result);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":47586,"modified_method":"/**\n     * Process all STIX indicators and save results to output file and create\n     * artifacts.\n     *\n     * @param stix STIXPackage\n     */\n    private void processIndicators(STIXPackage stix, BufferedWriter output) throws TskCoreException {\n        if (stix.getIndicators() != null) {\n            List<IndicatorBaseType> s = stix.getIndicators().getIndicators();\n            for (IndicatorBaseType t : s) {\n                if (t instanceof Indicator) {\n                    Indicator ind = (Indicator) t;\n                    if (ind.getObservable() != null) {\n                        if (ind.getObservable().getObject() != null) {\n                            ObservableResult result = evaluateSingleObservable(ind.getObservable(), \"\");\n                            if (result.isTrue() || reportAllResults) {\n                                writeResultsToFile(ind, result.getDescription(), result.isTrue(), output);\n                            }\n                            if (result.isTrue()) {\n                                saveResultsAsArtifacts(ind, result);\n                            }\n                        } else if (ind.getObservable().getObservableComposition() != null) {\n                            ObservableResult result = evaluateObservableComposition(ind.getObservable().getObservableComposition(), \"  \");\n\n                            if (result.isTrue() || reportAllResults) {\n                                writeResultsToFile(ind, result.getDescription(), result.isTrue(), output);\n                            }\n                            if (result.isTrue()) {\n                                saveResultsAsArtifacts(ind, result);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"dbe2091f1843b5d90d5c034b09b921bf72542827","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * The user made changes to the network config and wants to save them, so\n     * lets go ahead and do so.\n     *\n     */\n    private void saveChanges() {\n        boolean restartRequired = false;\n        \n        if (!_ratesOnly) {\n            // IP Settings\n            String oldUdp = _context.getProperty(UDPTransport.PROP_SOURCES, UDPTransport.DEFAULT_SOURCES);\n            String oldUHost = _context.getProperty(UDPTransport.PROP_EXTERNAL_HOST, \"\");\n            if (_udpAutoIP != null) {\n                String uhost = \"\";\n                if (_udpAutoIP.equals(\"fixed\")) {\n                    if (_udpHost1 != null && _udpHost1.length() > 0)\n                        uhost =  _udpHost1;\n                    else if (_udpHost2 != null && _udpHost2.length() > 0)\n                        uhost =  _udpHost2;\n                    else\n                        _udpAutoIP = UDPTransport.DEFAULT_SOURCES;\n                }\n                _context.router().setConfigSetting(UDPTransport.PROP_SOURCES, _udpAutoIP);\n                // Todo: Catch local IPs right here rather than complaining later\n                if (uhost.length() > 0)\n                    _context.router().setConfigSetting(UDPTransport.PROP_EXTERNAL_HOST, uhost);\n                else\n                    _context.router().removeConfigSetting(UDPTransport.PROP_EXTERNAL_HOST);\n                if ((!oldUdp.equals(_udpAutoIP)) || (!oldUHost.equals(uhost))) {\n                   addFormNotice(_(\"Updating IP address\"));\n                   restartRequired = true;\n                }\n            }\n\n            // NTCP Settings\n            // Normalize some things to make the following code a little easier...\n            String oldNHost = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, \"\");\n            String oldNPort = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_PORT, \"\");\n            String oldAutoHost = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, \"true\");\n            String sAutoPort = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"true\");\n            boolean oldAutoPort = \"true\".equalsIgnoreCase(sAutoPort);\n            if (_ntcpHostname == null) _ntcpHostname = \"\";\n            if (_ntcpPort == null) _ntcpPort = \"\";\n            if (_ntcpAutoIP == null) _ntcpAutoIP = \"true\";\n\n            if ((!oldAutoHost.equals(_ntcpAutoIP)) || ! oldNHost.equalsIgnoreCase(_ntcpHostname)) {\n                if (\"disabled\".equals(_ntcpAutoIP)) {\n                    addFormNotice(_(\"Disabling TCP completely\"));\n                } else if (\"false\".equals(_ntcpAutoIP) && _ntcpHostname.length() > 0) {\n                    // Todo: Catch local IPs right here rather than complaining later\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, _ntcpHostname);\n                    addFormNotice(_(\"Updating inbound TCP address to\") + \" \" + _ntcpHostname);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n                    if (\"false\".equals(_ntcpAutoIP))\n                        addFormNotice(_(\"Disabling inbound TCP\"));\n                    else\n                        addFormNotice(_(\"Updating inbound TCP address to auto\")); // true or always\n                }\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, _ntcpAutoIP);\n                _context.router().setConfigSetting(TransportManager.PROP_ENABLE_NTCP, \"\" + !\"disabled\".equals(_ntcpAutoIP));\n                restartRequired = true;\n            }\n            if (oldAutoPort != _ntcpAutoPort || ! oldNPort.equals(_ntcpPort)) {\n                if (_ntcpPort.length() > 0 && !_ntcpAutoPort) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT, _ntcpPort);\n                    addFormNotice(_(\"Updating inbound TCP port to\") + \" \" + _ntcpPort);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n                    addFormNotice(_(\"Updating inbound TCP port to auto\"));\n                }\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"\" + _ntcpAutoPort);\n                restartRequired = true;\n            }\n\n            // UDP Settings\n            if ( (_udpPort != null) && (_udpPort.length() > 0) ) {\n                String oldPort = \"\" + _context.getProperty(UDPTransport.PROP_INTERNAL_PORT, UDPTransport.DEFAULT_INTERNAL_PORT);\n                if (!oldPort.equals(_udpPort)) {\n                    _context.router().setConfigSetting(UDPTransport.PROP_INTERNAL_PORT, _udpPort);\n                    _context.router().setConfigSetting(UDPTransport.PROP_EXTERNAL_PORT, _udpPort);\n                    addFormNotice(_(\"Updating UDP port from\") + \" \" + oldPort + \" \" + _(\"to\") + \" \" + _udpPort);\n                    restartRequired = true;\n                }\n            }\n\n        }\n        \n        updateRates();\n        \n        boolean switchRequired = false;\n        if (!_ratesOnly) {\n            // If hidden mode value changes, restart is required\n            switchRequired = _hiddenMode != _context.router().isHidden();\n            if (switchRequired) {\n                _context.router().setConfigSetting(PROP_HIDDEN, \"\" + _hiddenMode);\n                if (_hiddenMode)\n                    addFormError(_(\"Gracefully restarting into Hidden Router Mode\"));\n                else\n                    addFormError(_(\"Gracefully restarting to exit Hidden Router Mode\"));\n            }\n\n            _context.router().setConfigSetting(Router.PROP_DYNAMIC_KEYS, \"\" + _dynamicKeys);\n\n            if (Boolean.valueOf(_context.getProperty(TransportManager.PROP_ENABLE_UPNP)).booleanValue() !=\n                _upnp) {\n                // This is minor, don't set restartRequired\n                if (_upnp)\n                    addFormNotice(_(\"Enabling UPnP, restart required to take effect\"));\n                else\n                    addFormNotice(_(\"Disabling UPnP, restart required to take effect\"));\n            }\n            _context.router().setConfigSetting(TransportManager.PROP_ENABLE_UPNP, \"\" + _upnp);\n\n            if (Boolean.valueOf(_context.getProperty(UDPTransport.PROP_LAPTOP_MODE)).booleanValue() !=\n                _laptop) {\n                // This is minor, don't set restartRequired\n                if (_laptop)\n                    addFormNotice(_(\"Enabling laptop mode\"));\n                else\n                    addFormNotice(_(\"Disabling laptop mode\"));\n            }\n            _context.router().setConfigSetting(UDPTransport.PROP_LAPTOP_MODE, \"\" + _laptop);\n\n            if (_requireIntroductions) {\n                _context.router().setConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS, \"true\");\n                addFormNotice(_(\"Requiring SSU introducers\"));\n            } else {\n                _context.router().removeConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS);\n            }\n\n            // Time sync enable, means NOT disabled \n            // Hmm router sets this at startup, not required here\n            //_context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n            \n            // Hidden in the GUI\n            //LoadTestManager.setEnableLoadTesting(_context, _enableLoadTesting);\n        }\n        \n        boolean saved = _context.router().saveConfig();\n        if ( (_action != null) && (_(\"Save changes\").equals(_action)) ) {\n            if (saved) \n                addFormNotice(_(\"Configuration saved successfully\"));\n            else\n                addFormNotice(_(\"Error saving the configuration (applied but not saved) - please see the error logs\"));\n        }\n        \n        if (switchRequired) {\n            hiddenSwitch();\n        } else if (restartRequired) {\n            //if (_context.hasWrapper()) {\n                // Wow this dumps all conns immediately and really isn't nice\n                addFormNotice(\"Performing a soft restart\");\n                _context.router().restart();\n                // restart() returns immediately now\n                //addFormNotice(\"Soft restart complete\");\n\n                // Most of the time we aren't changing addresses, just enabling or disabling\n                // things, so let's try just a new routerInfo and see how that works.\n                // Maybe we should restart if we change addresses though?\n                // No, this doesn't work well, really need to call SSU Transport externalAddressReceived(),\n                // but that's hard to get to, and doesn't handle port changes, etc.\n                // So don't do this...\n                //_context.router().rebuildRouterInfo();\n                //addFormNotice(\"Router Info rebuilt\");\n            //} else {\n                // There's a few changes that don't really require restart (e.g. enabling inbound TCP)\n                // But it would be hard to get right, so just do a restart.\n                //addFormError(_(\"Gracefully restarting I2P to change published router address\"));\n                //_context.router().shutdownGracefully(Router.EXIT_GRACEFUL_RESTART);\n            //}\n        }\n    }","id":47587,"modified_method":"/**\n     * The user made changes to the network config and wants to save them, so\n     * lets go ahead and do so.\n     *\n     */\n    private void saveChanges() {\n        boolean restartRequired = false;\n        \n        if (!_ratesOnly) {\n            // IP Settings\n            String oldUdp = _context.getProperty(UDPTransport.PROP_SOURCES, UDPTransport.DEFAULT_SOURCES);\n            String oldUHost = _context.getProperty(UDPTransport.PROP_EXTERNAL_HOST, \"\");\n            if (_udpAutoIP != null) {\n                String uhost = \"\";\n                if (_udpAutoIP.equals(\"fixed\")) {\n                    if (_udpHost1 != null && _udpHost1.length() > 0)\n                        uhost =  _udpHost1;\n                    else if (_udpHost2 != null && _udpHost2.length() > 0)\n                        uhost =  _udpHost2;\n                    else\n                        _udpAutoIP = UDPTransport.DEFAULT_SOURCES;\n                }\n                _context.router().setConfigSetting(UDPTransport.PROP_SOURCES, _udpAutoIP);\n                boolean valid = true;\n                if (uhost.length() > 0) {\n                    valid = verifyAddress(uhost);\n                    if (valid) {\n                        _context.router().setConfigSetting(UDPTransport.PROP_EXTERNAL_HOST, uhost);\n                    }\n                } else {\n                    _context.router().removeConfigSetting(UDPTransport.PROP_EXTERNAL_HOST);\n                }\n                if (valid && ((!oldUdp.equals(_udpAutoIP)) || (!oldUHost.equals(uhost)))) {\n                   addFormNotice(_(\"Updating IP address\"));\n                   restartRequired = true;\n                }\n            }\n\n            // NTCP Settings\n            // Normalize some things to make the following code a little easier...\n            String oldNHost = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, \"\");\n            String oldNPort = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_PORT, \"\");\n            String oldAutoHost = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, \"true\");\n            String sAutoPort = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"true\");\n            boolean oldAutoPort = \"true\".equalsIgnoreCase(sAutoPort);\n            if (_ntcpHostname == null) _ntcpHostname = \"\";\n            if (_ntcpPort == null) _ntcpPort = \"\";\n            if (_ntcpAutoIP == null) _ntcpAutoIP = \"true\";\n\n            if ((!oldAutoHost.equals(_ntcpAutoIP)) || ! oldNHost.equalsIgnoreCase(_ntcpHostname)) {\n                boolean valid = true;\n                if (\"disabled\".equals(_ntcpAutoIP)) {\n                    addFormNotice(_(\"Disabling TCP completely\"));\n                } else if (\"false\".equals(_ntcpAutoIP) && _ntcpHostname.length() > 0) {\n                    valid = verifyAddress(_ntcpHostname);\n                    if (valid) {\n                        _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, _ntcpHostname);\n                        addFormNotice(_(\"Updating inbound TCP address to\") + \" \" + _ntcpHostname);\n                    }\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n                    if (\"false\".equals(_ntcpAutoIP))\n                        addFormNotice(_(\"Disabling inbound TCP\"));\n                    else\n                        addFormNotice(_(\"Updating inbound TCP address to auto\")); // true or always\n                }\n                if (valid) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, _ntcpAutoIP);\n                    _context.router().setConfigSetting(TransportManager.PROP_ENABLE_NTCP, \"\" + !\"disabled\".equals(_ntcpAutoIP));\n                    restartRequired = true;\n                }\n            }\n            if (oldAutoPort != _ntcpAutoPort || ! oldNPort.equals(_ntcpPort)) {\n                if (_ntcpPort.length() > 0 && !_ntcpAutoPort) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT, _ntcpPort);\n                    addFormNotice(_(\"Updating inbound TCP port to\") + \" \" + _ntcpPort);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n                    addFormNotice(_(\"Updating inbound TCP port to auto\"));\n                }\n                _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"\" + _ntcpAutoPort);\n                restartRequired = true;\n            }\n\n            // UDP Settings\n            if ( (_udpPort != null) && (_udpPort.length() > 0) ) {\n                String oldPort = \"\" + _context.getProperty(UDPTransport.PROP_INTERNAL_PORT, UDPTransport.DEFAULT_INTERNAL_PORT);\n                if (!oldPort.equals(_udpPort)) {\n                    _context.router().setConfigSetting(UDPTransport.PROP_INTERNAL_PORT, _udpPort);\n                    _context.router().setConfigSetting(UDPTransport.PROP_EXTERNAL_PORT, _udpPort);\n                    addFormNotice(_(\"Updating UDP port from\") + \" \" + oldPort + \" \" + _(\"to\") + \" \" + _udpPort);\n                    restartRequired = true;\n                }\n            }\n\n        }\n        \n        updateRates();\n        \n        boolean switchRequired = false;\n        if (!_ratesOnly) {\n            // If hidden mode value changes, restart is required\n            switchRequired = _hiddenMode != _context.router().isHidden();\n            if (switchRequired) {\n                _context.router().setConfigSetting(PROP_HIDDEN, \"\" + _hiddenMode);\n                if (_hiddenMode)\n                    addFormError(_(\"Gracefully restarting into Hidden Router Mode\"));\n                else\n                    addFormError(_(\"Gracefully restarting to exit Hidden Router Mode\"));\n            }\n\n            _context.router().setConfigSetting(Router.PROP_DYNAMIC_KEYS, \"\" + _dynamicKeys);\n\n            if (Boolean.valueOf(_context.getProperty(TransportManager.PROP_ENABLE_UPNP)).booleanValue() !=\n                _upnp) {\n                // This is minor, don't set restartRequired\n                if (_upnp)\n                    addFormNotice(_(\"Enabling UPnP, restart required to take effect\"));\n                else\n                    addFormNotice(_(\"Disabling UPnP, restart required to take effect\"));\n            }\n            _context.router().setConfigSetting(TransportManager.PROP_ENABLE_UPNP, \"\" + _upnp);\n\n            if (Boolean.valueOf(_context.getProperty(UDPTransport.PROP_LAPTOP_MODE)).booleanValue() !=\n                _laptop) {\n                // This is minor, don't set restartRequired\n                if (_laptop)\n                    addFormNotice(_(\"Enabling laptop mode\"));\n                else\n                    addFormNotice(_(\"Disabling laptop mode\"));\n            }\n            _context.router().setConfigSetting(UDPTransport.PROP_LAPTOP_MODE, \"\" + _laptop);\n\n            if (_requireIntroductions) {\n                _context.router().setConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS, \"true\");\n                addFormNotice(_(\"Requiring SSU introducers\"));\n            } else {\n                _context.router().removeConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS);\n            }\n\n            // Time sync enable, means NOT disabled \n            // Hmm router sets this at startup, not required here\n            //_context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n            \n            // Hidden in the GUI\n            //LoadTestManager.setEnableLoadTesting(_context, _enableLoadTesting);\n        }\n        \n        boolean saved = _context.router().saveConfig();\n        if ( (_action != null) && (_(\"Save changes\").equals(_action)) ) {\n            if (saved) \n                addFormNotice(_(\"Configuration saved successfully\"));\n            else\n                addFormNotice(_(\"Error saving the configuration (applied but not saved) - please see the error logs\"));\n        }\n        \n        if (switchRequired) {\n            hiddenSwitch();\n        } else if (restartRequired) {\n            //if (_context.hasWrapper()) {\n                // Wow this dumps all conns immediately and really isn't nice\n                addFormNotice(\"Performing a soft restart\");\n                _context.router().restart();\n                // restart() returns immediately now\n                //addFormNotice(\"Soft restart complete\");\n\n                // Most of the time we aren't changing addresses, just enabling or disabling\n                // things, so let's try just a new routerInfo and see how that works.\n                // Maybe we should restart if we change addresses though?\n                // No, this doesn't work well, really need to call SSU Transport externalAddressReceived(),\n                // but that's hard to get to, and doesn't handle port changes, etc.\n                // So don't do this...\n                //_context.router().rebuildRouterInfo();\n                //addFormNotice(\"Router Info rebuilt\");\n            //} else {\n                // There's a few changes that don't really require restart (e.g. enabling inbound TCP)\n                // But it would be hard to get right, so just do a restart.\n                //addFormError(_(\"Gracefully restarting I2P to change published router address\"));\n                //_context.router().shutdownGracefully(Router.EXIT_GRACEFUL_RESTART);\n            //}\n        }\n    }","commit_id":"e249b223122f72d4a9f4992b7c90868c9ee83351","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected void processForm() {\n        if (\"Check for update now\".equals(_action)) {\n            NewsFetcher fetcher = NewsFetcher.getInstance(I2PAppContext.getGlobalContext());\n            fetcher.fetchNews();\n            if (fetcher.updateAvailable()) {\n                if ( (_updatePolicy == null) || (!_updatePolicy.equals(\"notify\")) )\n                    addFormNotice(\"Update available, attempting to download now\");\n                else\n                    addFormNotice(\"Update available, click button on left to download\");\n            } else\n                addFormNotice(\"No update available\");\n        }\n\n        if ( (_newsURL != null) && (_newsURL.length() > 0) ) {\n            String oldURL = ConfigUpdateHelper.getNewsURL(_context);\n            if ( (oldURL == null) || (!_newsURL.equals(oldURL)) ) {\n                _context.router().setConfigSetting(PROP_NEWS_URL, _newsURL);\n                addFormNotice(\"Updating news URL to \" + _newsURL);\n            }\n        }\n        \n        if ( (_proxyHost != null) && (_proxyHost.length() > 0) ) {\n            String oldHost = _context.router().getConfigSetting(PROP_PROXY_HOST);\n            if ( (oldHost == null) || (!_proxyHost.equals(oldHost)) ) {\n                _context.router().setConfigSetting(PROP_PROXY_HOST, _proxyHost);\n                addFormNotice(\"Updating proxy host to \" + _proxyHost);\n            }\n        }\n        \n        if ( (_proxyPort != null) && (_proxyPort.length() > 0) ) {\n            String oldPort = _context.router().getConfigSetting(PROP_PROXY_PORT);\n            if ( (oldPort == null) || (!_proxyPort.equals(oldPort)) ) {\n                _context.router().setConfigSetting(PROP_PROXY_PORT, _proxyPort);\n                addFormNotice(\"Updating proxy port to \" + _proxyPort);\n            }\n        }\n        \n        if (_updateThroughProxy) {\n            _context.router().setConfigSetting(PROP_SHOULD_PROXY, Boolean.TRUE.toString());\n        } else {\n            _context.router().setConfigSetting(PROP_SHOULD_PROXY, Boolean.FALSE.toString());\n        }\n        \n        String oldFreqStr = _context.router().getConfigSetting(PROP_REFRESH_FREQUENCY);\n        long oldFreq = -1;\n        if (oldFreqStr != null) \n            try { oldFreq = Long.parseLong(oldFreqStr); } catch (NumberFormatException nfe) {}\n        if (_refreshFrequency != oldFreq) {\n            _context.router().setConfigSetting(PROP_REFRESH_FREQUENCY, \"\"+_refreshFrequency);\n            addFormNotice(\"Updating refresh frequency to \" + DataHelper.formatDuration(_refreshFrequency));\n        }\n\n        if ( (_updatePolicy != null) && (_updatePolicy.length() > 0) ) {\n            String oldPolicy = _context.router().getConfigSetting(PROP_UPDATE_POLICY);\n            if ( (oldPolicy == null) || (!_updatePolicy.equals(oldPolicy)) ) {\n                _context.router().setConfigSetting(PROP_UPDATE_POLICY, _updatePolicy);\n                addFormNotice(\"Updating update policy to \" + _updatePolicy);\n            }\n        }\n\n        if ( (_updateURL != null) && (_updateURL.length() > 0) ) {\n            _updateURL = _updateURL.replaceAll(\"\\r\\n\", \",\").replaceAll(\"\\n\", \",\");\n            String oldURL = _context.router().getConfigSetting(PROP_UPDATE_URL);\n            if ( (oldURL == null) || (!_updateURL.equals(oldURL)) ) {\n                _context.router().setConfigSetting(PROP_UPDATE_URL, _updateURL);\n                addFormNotice(\"Updating update URLs.\");\n            }\n        }\n\n        if ( (_trustedKeys != null) && (_trustedKeys.length() > 0) ) {\n            String oldKeys = new TrustedUpdate(_context).getTrustedKeysString();\n            if ( (oldKeys == null) || (!_trustedKeys.equals(oldKeys)) ) {\n                _context.router().setConfigSetting(PROP_TRUSTED_KEYS, _trustedKeys);\n                addFormNotice(\"Updating trusted keys.\");\n            }\n        }\n        \n        _context.router().saveConfig();\n    }","id":47588,"modified_method":"protected void processForm() {\n        if (\"Check for update now\".equals(_action)) {\n            NewsFetcher fetcher = NewsFetcher.getInstance(I2PAppContext.getGlobalContext());\n            fetcher.fetchNews();\n            if (fetcher.shouldFetchUnsigned())\n                fetcher.fetchUnsigned();\n            if (fetcher.updateAvailable() || fetcher.unsignedUpdateAvailable()) {\n                if ( (_updatePolicy == null) || (!_updatePolicy.equals(\"notify\")) )\n                    addFormNotice(\"Update available, attempting to download now\");\n                else\n                    addFormNotice(\"Update available, click button on left to download\");\n            } else\n                addFormNotice(\"No update available\");\n        }\n\n        if ( (_newsURL != null) && (_newsURL.length() > 0) ) {\n            String oldURL = ConfigUpdateHelper.getNewsURL(_context);\n            if ( (oldURL == null) || (!_newsURL.equals(oldURL)) ) {\n                _context.router().setConfigSetting(PROP_NEWS_URL, _newsURL);\n                addFormNotice(\"Updating news URL to \" + _newsURL);\n            }\n        }\n        \n        if ( (_proxyHost != null) && (_proxyHost.length() > 0) ) {\n            String oldHost = _context.router().getConfigSetting(PROP_PROXY_HOST);\n            if ( (oldHost == null) || (!_proxyHost.equals(oldHost)) ) {\n                _context.router().setConfigSetting(PROP_PROXY_HOST, _proxyHost);\n                addFormNotice(\"Updating proxy host to \" + _proxyHost);\n            }\n        }\n        \n        if ( (_proxyPort != null) && (_proxyPort.length() > 0) ) {\n            String oldPort = _context.router().getConfigSetting(PROP_PROXY_PORT);\n            if ( (oldPort == null) || (!_proxyPort.equals(oldPort)) ) {\n                _context.router().setConfigSetting(PROP_PROXY_PORT, _proxyPort);\n                addFormNotice(\"Updating proxy port to \" + _proxyPort);\n            }\n        }\n        \n        _context.router().setConfigSetting(PROP_SHOULD_PROXY, \"\" + _updateThroughProxy);\n        _context.router().setConfigSetting(PROP_UPDATE_UNSIGNED, \"\" + _updateUnsigned);\n        \n        String oldFreqStr = _context.router().getConfigSetting(PROP_REFRESH_FREQUENCY);\n        long oldFreq = -1;\n        if (oldFreqStr != null) \n            try { oldFreq = Long.parseLong(oldFreqStr); } catch (NumberFormatException nfe) {}\n        if (_refreshFrequency != oldFreq) {\n            _context.router().setConfigSetting(PROP_REFRESH_FREQUENCY, \"\"+_refreshFrequency);\n            addFormNotice(\"Updating refresh frequency to \" + DataHelper.formatDuration(_refreshFrequency));\n        }\n\n        if ( (_updatePolicy != null) && (_updatePolicy.length() > 0) ) {\n            String oldPolicy = _context.router().getConfigSetting(PROP_UPDATE_POLICY);\n            if ( (oldPolicy == null) || (!_updatePolicy.equals(oldPolicy)) ) {\n                _context.router().setConfigSetting(PROP_UPDATE_POLICY, _updatePolicy);\n                addFormNotice(\"Updating update policy to \" + _updatePolicy);\n            }\n        }\n\n        if ( (_updateURL != null) && (_updateURL.length() > 0) ) {\n            _updateURL = _updateURL.replaceAll(\"\\r\\n\", \",\").replaceAll(\"\\n\", \",\");\n            String oldURL = _context.router().getConfigSetting(PROP_UPDATE_URL);\n            if ( (oldURL == null) || (!_updateURL.equals(oldURL)) ) {\n                _context.router().setConfigSetting(PROP_UPDATE_URL, _updateURL);\n                addFormNotice(\"Updating update URLs.\");\n            }\n        }\n\n        if ( (_trustedKeys != null) && (_trustedKeys.length() > 0) ) {\n            String oldKeys = new TrustedUpdate(_context).getTrustedKeysString();\n            if ( (oldKeys == null) || (!_trustedKeys.equals(oldKeys)) ) {\n                _context.router().setConfigSetting(PROP_TRUSTED_KEYS, _trustedKeys);\n                addFormNotice(\"Updating trusted keys.\");\n            }\n        }\n        \n        if ( (_zipURL != null) && (_zipURL.length() > 0) ) {\n            String oldURL = _context.router().getConfigSetting(PROP_ZIP_URL);\n            if ( (oldURL == null) || (!_zipURL.equals(oldURL)) ) {\n                _context.router().setConfigSetting(PROP_ZIP_URL, _zipURL);\n                addFormNotice(\"Updating unsigned update URL to \" + _zipURL);\n            }\n        }\n        \n        _context.router().saveConfig();\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean shouldFetchNews() {\n        updateLastFetched();\n        String freq = _context.getProperty(ConfigUpdateHandler.PROP_REFRESH_FREQUENCY);\n        if (freq == null)\n            freq = ConfigUpdateHandler.DEFAULT_REFRESH_FREQUENCY;\n        try {\n            long ms = Long.parseLong(freq);\n            if (ms <= 0)\n                return false;\n            \n            if (_lastFetch + ms < _context.clock().now()) {\n                return true;\n            } else {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Last fetched \" + DataHelper.formatDuration(_context.clock().now() - _lastFetch) + \" ago\");\n                return false;\n            }\n        } catch (NumberFormatException nfe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Invalid refresh frequency: \" + freq);\n            return false;\n        }\n    }","id":47589,"modified_method":"private boolean shouldFetchNews() {\n        updateLastFetched();\n        String freq = _context.getProperty(ConfigUpdateHandler.PROP_REFRESH_FREQUENCY,\n                                           ConfigUpdateHandler.DEFAULT_REFRESH_FREQUENCY);\n        try {\n            long ms = Long.parseLong(freq);\n            if (ms <= 0)\n                return false;\n            \n            if (_lastFetch + ms < _context.clock().now()) {\n                return true;\n            } else {\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"Last fetched \" + DataHelper.formatDuration(_context.clock().now() - _lastFetch) + \" ago\");\n                return false;\n            }\n        } catch (NumberFormatException nfe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Invalid refresh frequency: \" + freq);\n            return false;\n        }\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void fetchNews() {\n        String newsURL = ConfigUpdateHelper.getNewsURL(_context);\n        boolean shouldProxy = Boolean.valueOf(_context.getProperty(ConfigUpdateHandler.PROP_SHOULD_PROXY, ConfigUpdateHandler.DEFAULT_SHOULD_PROXY)).booleanValue();\n        String proxyHost = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_HOST, ConfigUpdateHandler.DEFAULT_PROXY_HOST);\n        String port = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_PORT, ConfigUpdateHandler.DEFAULT_PROXY_PORT);\n        if (_tempFile.exists())\n            _tempFile.delete();\n        \n        int proxyPort = -1;\n        try {\n            proxyPort = Integer.parseInt(port);\n            EepGet get = null;\n            if (shouldProxy)\n                get = new EepGet(_context, true, proxyHost, proxyPort, 2, _tempFile.getAbsolutePath(), newsURL, true, null, _lastModified);\n            else\n                get = new EepGet(_context, false, null, 0, 0, _tempFile.getAbsolutePath(), newsURL, true, null, _lastModified);\n            get.addStatusListener(this);\n            if (get.fetch())\n                _lastModified = get.getLastModified();\n        } catch (Throwable t) {\n            _log.error(\"Error fetching the news\", t);\n        }\n    }","id":47590,"modified_method":"public void fetchNews() {\n        String newsURL = ConfigUpdateHelper.getNewsURL(_context);\n        boolean shouldProxy = Boolean.valueOf(_context.getProperty(ConfigUpdateHandler.PROP_SHOULD_PROXY, ConfigUpdateHandler.DEFAULT_SHOULD_PROXY)).booleanValue();\n        String proxyHost = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_HOST, ConfigUpdateHandler.DEFAULT_PROXY_HOST);\n        int proxyPort = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_PORT, ConfigUpdateHandler.DEFAULT_PROXY_PORT_INT);\n        if (_tempFile.exists())\n            _tempFile.delete();\n        \n        try {\n            EepGet get = null;\n            if (shouldProxy)\n                get = new EepGet(_context, true, proxyHost, proxyPort, 2, _tempFile.getAbsolutePath(), newsURL, true, null, _lastModified);\n            else\n                get = new EepGet(_context, false, null, 0, 0, _tempFile.getAbsolutePath(), newsURL, true, null, _lastModified);\n            get.addStatusListener(this);\n            if (get.fetch())\n                _lastModified = get.getLastModified();\n        } catch (Throwable t) {\n            _log.error(\"Error fetching the news\", t);\n        }\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n        try { Thread.sleep(_context.random().nextLong(5*60*1000)); } catch (InterruptedException ie) {}\n        while (true) {\n            if (!_updateAvailable) checkForUpdates();\n            if (shouldFetchNews())\n                fetchNews();\n            try { Thread.sleep(10*60*1000); } catch (InterruptedException ie) {}\n        }\n    }","id":47591,"modified_method":"public void run() {\n        try { Thread.sleep(_context.random().nextLong(5*60*1000)); } catch (InterruptedException ie) {}\n        while (true) {\n            if (!_updateAvailable) checkForUpdates();\n            if (shouldFetchNews()) {\n                fetchNews();\n                if (shouldFetchUnsigned())\n                    fetchUnsignedHead();\n            }\n            try { Thread.sleep(10*60*1000); } catch (InterruptedException ie) {}\n        }\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"protected void update() {\n            _status = \"<b>Updating<\/b>\";\n            String updateURL = selectUpdateURL();\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Selected update URL: \" + updateURL);\n            boolean shouldProxy = Boolean.valueOf(_context.getProperty(ConfigUpdateHandler.PROP_SHOULD_PROXY, ConfigUpdateHandler.DEFAULT_SHOULD_PROXY)).booleanValue();\n            String proxyHost = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_HOST, ConfigUpdateHandler.DEFAULT_PROXY_HOST);\n            String port = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_PORT, ConfigUpdateHandler.DEFAULT_PROXY_PORT);\n            int proxyPort = -1;\n            try {\n                proxyPort = Integer.parseInt(port);\n            } catch (NumberFormatException nfe) {\n                return;\n            }\n            try {\n                EepGet get = null;\n                if (shouldProxy)\n                    // 40 retries!!\n                    get = new EepGet(_context, proxyHost, proxyPort, 40, SIGNED_UPDATE_FILE, updateURL, false);\n                else\n                    get = new EepGet(_context, 1, _updateFile, updateURL, false);\n                get.addStatusListener(UpdateRunner.this);\n                get.fetch();\n            } catch (Throwable t) {\n                _context.logManager().getLog(UpdateHandler.class).error(\"Error updating\", t);\n            }\n        }","id":47592,"modified_method":"protected void update() {\n            _status = \"<b>Updating<\/b>\";\n            String updateURL = selectUpdateURL();\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Selected update URL: \" + updateURL);\n            boolean shouldProxy = Boolean.valueOf(_context.getProperty(ConfigUpdateHandler.PROP_SHOULD_PROXY, ConfigUpdateHandler.DEFAULT_SHOULD_PROXY)).booleanValue();\n            String proxyHost = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_HOST, ConfigUpdateHandler.DEFAULT_PROXY_HOST);\n            int proxyPort = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_PORT, ConfigUpdateHandler.DEFAULT_PROXY_PORT_INT);\n            try {\n                if (shouldProxy)\n                    // 40 retries!!\n                    _get = new EepGet(_context, proxyHost, proxyPort, 40, _updateFile, updateURL, false);\n                else\n                    _get = new EepGet(_context, 1, _updateFile, updateURL, false);\n                _get.addStatusListener(UpdateRunner.this);\n                _get.fetch();\n            } catch (Throwable t) {\n                _context.logManager().getLog(UpdateHandler.class).error(\"Error updating\", t);\n            }\n        }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void transferComplete(long alreadyTransferred, long bytesTransferred, long bytesRemaining, String url, String outputFile, boolean notModified) {\n            _status = \"<b>Update downloaded<\/b>\";\n            TrustedUpdate up = new TrustedUpdate(_context);\n            File f = new File(_updateFile);\n            File to = new File(_context.getBaseDir(), Router.UPDATE_FILE);\n            String err = up.migrateVerified(RouterVersion.VERSION, f, to);\n            f.delete();\n            if (err == null) {\n                String policy = _context.getProperty(ConfigUpdateHandler.PROP_UPDATE_POLICY);\n                this.done = true;\n                if (\"install\".equals(policy)) {\n                    _log.log(Log.CRIT, \"Update was VERIFIED, restarting to install it\");\n                    _status = \"<b>Update verified<\/b><br />Restarting\";\n                    restart();\n                } else {\n                    _log.log(Log.CRIT, \"Update was VERIFIED, will be installed at next restart\");\n                    _status = \"<b>Update downloaded<\/b><br />\";\n                    if (System.getProperty(\"wrapper.version\") != null)\n                        _status += \"Click Restart to install\";\n                    else\n                        _status += \"Click Shutdown and restart to install\";\n                    if (up.newVersion() != null)\n                        _status += \" Version \" + up.newVersion();\n                }\n            } else {\n                err = err + \" from \" + url;\n                _log.log(Log.CRIT, err);\n                _status = \"<b>\" + err + \"<\/b>\";\n            }\n        }","id":47593,"modified_method":"public void transferComplete(long alreadyTransferred, long bytesTransferred, long bytesRemaining, String url, String outputFile, boolean notModified) {\n            _status = \"<b>Update downloaded<\/b>\";\n            TrustedUpdate up = new TrustedUpdate(_context);\n            File f = new File(_updateFile);\n            File to = new File(_context.getBaseDir(), Router.UPDATE_FILE);\n            String err = up.migrateVerified(RouterVersion.VERSION, f, to);\n            f.delete();\n            if (err == null) {\n                String policy = _context.getProperty(ConfigUpdateHandler.PROP_UPDATE_POLICY);\n                this.done = true;\n                // So unsigned update handler doesn't overwrite unless newer.\n                String lastmod = _get.getLastModified();\n                long modtime = 0;\n                if (lastmod != null)\n                    modtime = NewsFetcher.parse822Date(lastmod);\n                if (modtime <= 0)\n                    modtime = _context.clock().now();\n                _context.router().setConfigSetting(PROP_LAST_UPDATE_TIME, \"\" + modtime);\n                _context.router().saveConfig();\n                if (\"install\".equals(policy)) {\n                    _log.log(Log.CRIT, \"Update was VERIFIED, restarting to install it\");\n                    _status = \"<b>Update verified<\/b><br />Restarting\";\n                    restart();\n                } else {\n                    _log.log(Log.CRIT, \"Update was VERIFIED, will be installed at next restart\");\n                    _status = \"<b>Update downloaded<\/b><br />\";\n                    if (System.getProperty(\"wrapper.version\") != null)\n                        _status += \"Click Restart to install\";\n                    else\n                        _status += \"Click Shutdown and restart to install\";\n                    if (up.newVersion() != null)\n                        _status += \" Version \" + up.newVersion();\n                }\n            } else {\n                err = err + \" from \" + url;\n                _log.log(Log.CRIT, err);\n                _status = \"<b>\" + err + \"<\/b>\";\n            }\n        }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void update() {\n        // don't block waiting for the other one to finish\n        if (\"true\".equals(System.getProperty(PROP_UPDATE_IN_PROGRESS, \"false\"))) {\n            _log.error(\"Update already running\");\n            return;\n        }\n        synchronized (UpdateHandler.class) {\n            if (_updateRunner == null)\n                _updateRunner = new UpdateRunner();\n            if (_updateRunner.isRunning()) {\n                return;\n            } else {\n                System.setProperty(PROP_UPDATE_IN_PROGRESS, \"true\");\n                I2PThread update = new I2PThread(_updateRunner, \"Update\");\n                update.start();\n            }\n        }\n    }","id":47594,"modified_method":"public void update() {\n        // don't block waiting for the other one to finish\n        if (\"true\".equals(System.getProperty(PROP_UPDATE_IN_PROGRESS))) {\n            _log.error(\"Update already running\");\n            return;\n        }\n        synchronized (UpdateHandler.class) {\n            if (_updateRunner == null)\n                _updateRunner = new UpdateRunner();\n            if (_updateRunner.isRunning()) {\n                return;\n            } else {\n                System.setProperty(PROP_UPDATE_IN_PROGRESS, \"true\");\n                I2PThread update = new I2PThread(_updateRunner, \"Update\");\n                update.start();\n            }\n        }\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void restart() {\n        _context.addShutdownTask(new ConfigServiceHandler.UpdateWrapperManagerTask(Router.EXIT_GRACEFUL_RESTART));\n        _context.router().shutdownGracefully(Router.EXIT_GRACEFUL_RESTART);\n    }","id":47595,"modified_method":"protected void restart() {\n        _context.addShutdownTask(new ConfigServiceHandler.UpdateWrapperManagerTask(Router.EXIT_GRACEFUL_RESTART));\n        _context.router().shutdownGracefully(Router.EXIT_GRACEFUL_RESTART);\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setUpdateNonce(String nonce) { \n        if (nonce == null) return;\n        if (nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.nonce\")) ||\n            nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.noncePrev\"))) {\n            update();\n        }\n    }","id":47596,"modified_method":"public void setUpdateNonce(String nonce) { \n        if (nonce == null) return;\n        if (nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.nonce\")) ||\n            nonce.equals(System.getProperty(\"net.i2p.router.web.UpdateHandler.noncePrev\"))) {\n            if (_action != null && _action.contains(\"Unsigned\")) {\n                // Not us, have NewsFetcher instantiate the correct class.\n                NewsFetcher fetcher = NewsFetcher.getInstance(_context);\n                fetcher.fetchUnsigned();\n            } else {\n                update();\n            }\n        }\n    }","commit_id":"3febcf6043a5a0e6506dd8f275fc7a046fc7763b","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * The user made changes to the network config and wants to save them, so\n     * lets go ahead and do so.\n     *\n     */\n    private void saveChanges() {\n        boolean restartRequired = false;\n        \n        if (!_ratesOnly) {\n            // Normalize some things to make the following code a little easier...\n            String oldNHost = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n            if (oldNHost == null) oldNHost = \"\";\n            String oldNPort = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n            if (oldNPort == null) oldNPort = \"\";\n            String sAutoHost = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP);\n            String sAutoPort = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT);\n            boolean oldAutoHost = \"true\".equalsIgnoreCase(sAutoHost);\n            boolean oldAutoPort = \"true\".equalsIgnoreCase(sAutoPort);\n            if (_ntcpHostname == null) _ntcpHostname = \"\";\n            if (_ntcpPort == null) _ntcpPort = \"\";\n\n            if (oldAutoHost != _ntcpAutoIP || ! oldNHost.equalsIgnoreCase(_ntcpHostname)) {\n                if (_ntcpAutoIP) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, \"true\");\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n                    addFormNotice(\"Updating inbound TCP address to auto\");\n                } else if (_ntcpHostname.length() > 0) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, _ntcpHostname);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP);\n                    addFormNotice(\"Updating inbound TCP address to \" + _ntcpHostname);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP);\n                    addFormNotice(\"Disabling inbound TCP\");\n                }\n                restartRequired = true;\n            }\n            if (oldAutoPort != _ntcpAutoPort || ! oldNPort.equals(_ntcpPort)) {\n                if ( _ntcpAutoPort ) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"true\");\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n                    addFormNotice(\"Updating inbound TCP port to auto\");\n                } else if (_ntcpPort.length() > 0) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT, _ntcpPort);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT);\n                    addFormNotice(\"Updating inbound TCP port to \" + _ntcpPort);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT);\n                    addFormNotice(\"Disabling inbound TCP\");\n                }\n                restartRequired = true;\n            }\n\n            if ( (_udpPort != null) && (_udpPort.length() > 0) ) {\n                String oldPort = \"\" + _context.getProperty(UDPTransport.PROP_INTERNAL_PORT, UDPTransport.DEFAULT_INTERNAL_PORT);\n                if (!oldPort.equals(_udpPort)) {\n                    _context.router().setConfigSetting(UDPTransport.PROP_INTERNAL_PORT, _udpPort);\n                    addFormNotice(\"Updating UDP port from \" + oldPort + \" to \" + _udpPort);\n                    restartRequired = true;\n                }\n            }\n\n        }\n        \n        updateRates();\n        \n        if (!_ratesOnly) {\n            if (_sharePct != null) {\n                String old = _context.router().getConfigSetting(Router.PROP_BANDWIDTH_SHARE_PERCENTAGE);\n                if ( (old == null) || (!old.equalsIgnoreCase(_sharePct)) ) {\n                    _context.router().setConfigSetting(Router.PROP_BANDWIDTH_SHARE_PERCENTAGE, _sharePct);\n                    addFormNotice(\"Updating bandwidth share percentage\");\n                }\n            }\n\n            // If hidden mode value changes, restart is required\n            if (_hiddenMode && \"false\".equalsIgnoreCase(_context.getProperty(Router.PROP_HIDDEN, \"false\"))) {\n                _context.router().setConfigSetting(Router.PROP_HIDDEN, \"true\");\n                _context.router().addCapabilities(_context.router().getRouterInfo());\n                addFormNotice(\"Gracefully restarting into Hidden Router Mode. Make sure you have no 0-1 length \"\n                              + \"<a href=\\\"configtunnels.jsp\\\">tunnels!<\/a>\");\n                hiddenSwitch();\n            }\n\n            if (!_hiddenMode && \"true\".equalsIgnoreCase(_context.getProperty(Router.PROP_HIDDEN, \"false\"))) {\n                _context.router().removeConfigSetting(Router.PROP_HIDDEN);\n                _context.router().getRouterInfo().delCapability(RouterInfo.CAPABILITY_HIDDEN);\n                addFormNotice(\"Gracefully restarting to exit Hidden Router Mode\");\n                hiddenSwitch();\n            }\n\n            if (_dynamicKeys) {\n                _context.router().setConfigSetting(Router.PROP_DYNAMIC_KEYS, \"true\");\n            } else {\n                _context.router().removeConfigSetting(Router.PROP_DYNAMIC_KEYS);\n            }\n\n            if (_requireIntroductions) {\n                _context.router().setConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS, \"true\");\n                addFormNotice(\"Requiring SSU introduers\");\n            } else {\n                _context.router().removeConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS);\n            }\n\n            if (true || _timeSyncEnabled) {\n                // Time sync enable, means NOT disabled \n                _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n            } else {\n                _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"true\");\n            }\n            \n            LoadTestManager.setEnableLoadTesting(_context, _enableLoadTesting);\n        }\n        \n        boolean saved = _context.router().saveConfig();\n        if ( (_action != null) && (\"Save changes\".equals(_action)) ) {\n            if (saved) \n                addFormNotice(\"Configuration saved successfully\");\n            else\n                addFormNotice(\"Error saving the configuration (applied but not saved) - please see the error logs\");\n        }\n        \n        if (restartRequired) {\n            //addFormNotice(\"Performing a soft restart\");\n            //_context.router().restart();\n            //addFormNotice(\"Soft restart complete\");\n            // Most of the time we aren't changing addresses, just enabling or disabling\n            // things, so let's try just a new routerInfo and see how that works.\n            // Maybe we should restart if we change addresses though?\n            _context.router().rebuildRouterInfo();\n            addFormNotice(\"Router Info rebuilt\");\n        }\n    }","id":47597,"modified_method":"/**\n     * The user made changes to the network config and wants to save them, so\n     * lets go ahead and do so.\n     *\n     */\n    private void saveChanges() {\n        boolean restartRequired = false;\n        \n        if (!_ratesOnly) {\n            // Normalize some things to make the following code a little easier...\n            String oldNHost = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n            if (oldNHost == null) oldNHost = \"\";\n            String oldNPort = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n            if (oldNPort == null) oldNPort = \"\";\n            String sAutoHost = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP);\n            String sAutoPort = _context.router().getConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT);\n            boolean oldAutoHost = \"true\".equalsIgnoreCase(sAutoHost);\n            boolean oldAutoPort = \"true\".equalsIgnoreCase(sAutoPort);\n            if (_ntcpHostname == null) _ntcpHostname = \"\";\n            if (_ntcpPort == null) _ntcpPort = \"\";\n\n            if (oldAutoHost != _ntcpAutoIP || ! oldNHost.equalsIgnoreCase(_ntcpHostname)) {\n                if (_ntcpAutoIP) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, \"true\");\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n                    addFormNotice(\"Updating inbound TCP address to auto\");\n                } else if (_ntcpHostname.length() > 0) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, _ntcpHostname);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP);\n                    addFormNotice(\"Updating inbound TCP address to \" + _ntcpHostname);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP);\n                    addFormNotice(\"Disabling inbound TCP\");\n                }\n                restartRequired = true;\n            }\n            if (oldAutoPort != _ntcpAutoPort || ! oldNPort.equals(_ntcpPort)) {\n                if ( _ntcpAutoPort ) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"true\");\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n                    addFormNotice(\"Updating inbound TCP port to auto\");\n                } else if (_ntcpPort.length() > 0) {\n                    _context.router().setConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT, _ntcpPort);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT);\n                    addFormNotice(\"Updating inbound TCP port to \" + _ntcpPort);\n                } else {\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\n                    _context.router().removeConfigSetting(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT);\n                    addFormNotice(\"Disabling inbound TCP\");\n                }\n                restartRequired = true;\n            }\n\n            if ( (_udpPort != null) && (_udpPort.length() > 0) ) {\n                String oldPort = \"\" + _context.getProperty(UDPTransport.PROP_INTERNAL_PORT, UDPTransport.DEFAULT_INTERNAL_PORT);\n                if (!oldPort.equals(_udpPort)) {\n                    _context.router().setConfigSetting(UDPTransport.PROP_INTERNAL_PORT, _udpPort);\n                    addFormNotice(\"Updating UDP port from \" + oldPort + \" to \" + _udpPort);\n                    restartRequired = true;\n                }\n            }\n\n        }\n        \n        updateRates();\n        \n        if (!_ratesOnly) {\n            if (_sharePct != null) {\n                String old = _context.router().getConfigSetting(Router.PROP_BANDWIDTH_SHARE_PERCENTAGE);\n                if ( (old == null) || (!old.equalsIgnoreCase(_sharePct)) ) {\n                    _context.router().setConfigSetting(Router.PROP_BANDWIDTH_SHARE_PERCENTAGE, _sharePct);\n                    addFormNotice(\"Updating bandwidth share percentage\");\n                }\n            }\n\n            // If hidden mode value changes, restart is required\n            if (_hiddenMode && \"false\".equalsIgnoreCase(_context.getProperty(Router.PROP_HIDDEN, \"false\"))) {\n                _context.router().setConfigSetting(Router.PROP_HIDDEN, \"true\");\n                _context.router().addCapabilities(_context.router().getRouterInfo());\n                addFormNotice(\"Gracefully restarting into Hidden Router Mode. Make sure you have no 0-1 length \"\n                              + \"<a href=\\\"configtunnels.jsp\\\">tunnels!<\/a>\");\n                hiddenSwitch();\n            }\n\n            if (!_hiddenMode && \"true\".equalsIgnoreCase(_context.getProperty(Router.PROP_HIDDEN, \"false\"))) {\n                _context.router().removeConfigSetting(Router.PROP_HIDDEN);\n                _context.router().getRouterInfo().delCapability(RouterInfo.CAPABILITY_HIDDEN);\n                addFormNotice(\"Gracefully restarting to exit Hidden Router Mode\");\n                hiddenSwitch();\n            }\n\n            _context.router().setConfigSetting(Router.PROP_DYNAMIC_KEYS, \"\" + _dynamicKeys);\n\n            if (Boolean.valueOf(_context.getProperty(TransportManager.PROP_ENABLE_UPNP)).booleanValue() !=\n                _upnp) {\n                if (_upnp)\n                    addFormNotice(\"Enabling UPnP, restart required to take effect\");\n                else\n                    addFormNotice(\"Disabling UPnP, restart required to take effect\");\n            }\n            _context.router().setConfigSetting(TransportManager.PROP_ENABLE_UPNP, \"\" + _upnp);\n\n            if (_requireIntroductions) {\n                _context.router().setConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS, \"true\");\n                addFormNotice(\"Requiring SSU introduers\");\n            } else {\n                _context.router().removeConfigSetting(UDPTransport.PROP_FORCE_INTRODUCERS);\n            }\n\n            // Time sync enable, means NOT disabled \n            _context.router().setConfigSetting(Timestamper.PROP_DISABLED, \"false\");\n            \n            LoadTestManager.setEnableLoadTesting(_context, _enableLoadTesting);\n        }\n        \n        boolean saved = _context.router().saveConfig();\n        if ( (_action != null) && (\"Save changes\".equals(_action)) ) {\n            if (saved) \n                addFormNotice(\"Configuration saved successfully\");\n            else\n                addFormNotice(\"Error saving the configuration (applied but not saved) - please see the error logs\");\n        }\n        \n        if (restartRequired) {\n            //addFormNotice(\"Performing a soft restart\");\n            //_context.router().restart();\n            //addFormNotice(\"Soft restart complete\");\n            // Most of the time we aren't changing addresses, just enabling or disabling\n            // things, so let's try just a new routerInfo and see how that works.\n            // Maybe we should restart if we change addresses though?\n            _context.router().rebuildRouterInfo();\n            addFormNotice(\"Router Info rebuilt\");\n        }\n    }","commit_id":"accf3dbf3fca6100e4f7f5f009aa1f697b55dff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void renderStatusHTML(Writer out, String urlBase, int sortFlags) throws IOException {\n        TreeMap transports = new TreeMap();\n        for (int i = 0; i < _transports.size(); i++) {\n            Transport t = (Transport)_transports.get(i);\n            transports.put(t.getStyle(), t);\n        }\n        for (Iterator iter = transports.values().iterator(); iter.hasNext(); ) {\n            Transport t= (Transport)iter.next();\n            t.renderStatusHTML(out, urlBase, sortFlags);\n        }\n        StringBuffer buf = new StringBuffer(4*1024);\n        buf.append(\"<p><b>Router Transport Addresses:<\/b><br /><pre>\\n\");\n        for (int i = 0; i < _transports.size(); i++) {\n            Transport t = (Transport)_transports.get(i);\n            if (t.getCurrentAddress() != null)\n                buf.append(t.getCurrentAddress()).append(\"\\n\\n\");\n            else\n                buf.append(t.getStyle()).append(\" is used for outbound connections only\\n\\n\");\n        }\n        buf.append(\"<\/pre>\\n\");\n        out.write(buf.toString());\n        out.write(_upnpManager.renderStatusHTML());\n        buf.append(\"<\/p>\\n\");\n        out.flush();\n    }","id":47598,"modified_method":"public void renderStatusHTML(Writer out, String urlBase, int sortFlags) throws IOException {\n        TreeMap transports = new TreeMap();\n        for (int i = 0; i < _transports.size(); i++) {\n            Transport t = (Transport)_transports.get(i);\n            transports.put(t.getStyle(), t);\n        }\n        for (Iterator iter = transports.values().iterator(); iter.hasNext(); ) {\n            Transport t= (Transport)iter.next();\n            t.renderStatusHTML(out, urlBase, sortFlags);\n        }\n        StringBuffer buf = new StringBuffer(4*1024);\n        buf.append(\"<p><b>Router Transport Addresses:<\/b><br /><pre>\\n\");\n        for (int i = 0; i < _transports.size(); i++) {\n            Transport t = (Transport)_transports.get(i);\n            if (t.getCurrentAddress() != null)\n                buf.append(t.getCurrentAddress()).append(\"\\n\\n\");\n            else\n                buf.append(t.getStyle()).append(\" is used for outbound connections only\\n\\n\");\n        }\n        buf.append(\"<\/pre>\\n\");\n        out.write(buf.toString());\n        if (_upnpManager != null)\n            out.write(_upnpManager.renderStatusHTML());\n        buf.append(\"<\/p>\\n\");\n        out.flush();\n    }","commit_id":"accf3dbf3fca6100e4f7f5f009aa1f697b55dff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void transportAddressChanged() {\n        _upnpManager.update(getAddresses());\n    }","id":47599,"modified_method":"public void transportAddressChanged() {\n        if (_upnpManager != null)\n            _upnpManager.update(getAddresses());\n    }","commit_id":"accf3dbf3fca6100e4f7f5f009aa1f697b55dff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public TransportManager(RouterContext context) {\n        _context = context;\n        _log = _context.logManager().getLog(TransportManager.class);\n        _context.statManager().createRateStat(\"transport.shitlistOnUnreachable\", \"Add a peer to the shitlist since none of the transports can reach them\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.noBidsYetNotAllUnreachable\", \"Add a peer to the shitlist since none of the transports can reach them\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailShitlisted\", \"Could not attempt to bid on message, as they were shitlisted\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailSelf\", \"Could not attempt to bid on message, as it targeted ourselves\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailNoTransports\", \"Could not attempt to bid on message, as none of the transports could attempt it\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailAllTransports\", \"Could not attempt to bid on message, as all of the transports had failed\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _transports = new ArrayList();\n        _upnpManager = new UPnPManager(context);\n    }","id":47600,"modified_method":"public TransportManager(RouterContext context) {\n        _context = context;\n        _log = _context.logManager().getLog(TransportManager.class);\n        _context.statManager().createRateStat(\"transport.shitlistOnUnreachable\", \"Add a peer to the shitlist since none of the transports can reach them\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.noBidsYetNotAllUnreachable\", \"Add a peer to the shitlist since none of the transports can reach them\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailShitlisted\", \"Could not attempt to bid on message, as they were shitlisted\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailSelf\", \"Could not attempt to bid on message, as it targeted ourselves\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailNoTransports\", \"Could not attempt to bid on message, as none of the transports could attempt it\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _context.statManager().createRateStat(\"transport.bidFailAllTransports\", \"Could not attempt to bid on message, as all of the transports had failed\", \"Transport\", new long[] { 60*1000, 10*60*1000, 60*60*1000 });\n        _transports = new ArrayList();\n        if (Boolean.valueOf(_context.getProperty(PROP_ENABLE_UPNP)).booleanValue())\n            _upnpManager = new UPnPManager(context);\n    }","commit_id":"accf3dbf3fca6100e4f7f5f009aa1f697b55dff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void stopListening() {\n        _upnpManager.stop();\n        for (int i = 0; i < _transports.size(); i++) {\n            ((Transport)_transports.get(i)).stopListening();\n        }\n        _transports.clear();\n    }","id":47601,"modified_method":"public void stopListening() {\n        if (_upnpManager != null)\n            _upnpManager.stop();\n        for (int i = 0; i < _transports.size(); i++) {\n            ((Transport)_transports.get(i)).stopListening();\n        }\n        _transports.clear();\n    }","commit_id":"accf3dbf3fca6100e4f7f5f009aa1f697b55dff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void startListening() {\n        _upnpManager.start();\n        configTransports();\n        _log.debug(\"Starting up the transport manager\");\n        for (int i = 0; i < _transports.size(); i++) {\n            Transport t = (Transport)_transports.get(i);\n            RouterAddress addr = t.startListening();\n            _log.debug(\"Transport \" + i + \" (\" + t.getStyle() + \") started\");\n        }\n        _log.debug(\"Done start listening on transports\");\n        _context.router().rebuildRouterInfo();\n    }","id":47602,"modified_method":"public void startListening() {\n        if (_upnpManager != null)\n            _upnpManager.start();\n        configTransports();\n        _log.debug(\"Starting up the transport manager\");\n        for (int i = 0; i < _transports.size(); i++) {\n            Transport t = (Transport)_transports.get(i);\n            RouterAddress addr = t.startListening();\n            _log.debug(\"Transport \" + i + \" (\" + t.getStyle() + \") started\");\n        }\n        _log.debug(\"Done start listening on transports\");\n        _context.router().rebuildRouterInfo();\n    }","commit_id":"accf3dbf3fca6100e4f7f5f009aa1f697b55dff8","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one. E.g. the method may be <code>IFoo.bar()<\/code> and the\n\t * target class may be <code>DefaultFoo<\/code>. In this case, the method may be\n\t * <code>DefaultFoo.bar()<\/code>. This enables attributes on that method to be found.\n\t * <p><b>NOTE:<\/b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not<\/i> resolve Java 5 bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable (e.g. for obtaining metadata from\n\t * the original method definition).\n\t * <p><b>NOTE:<\/b>Since Spring 3.1.1, if java security settings disallow reflective\n\t * access (e.g. calls to {@code Class#getDeclaredMethods} etc, this implementation\n\t * will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation.\n\t * May be <code>null<\/code> or may not even implement the method.\n\t * @return the specific target method, or the original method if the\n\t * <code>targetClass<\/code> doesn't implement it or is <code>null<\/code>\n\t */\n\tpublic static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n\t\tMethod specificMethod = null;\n\t\tif (method != null && isOverridable(method, targetClass) &&\n\t\t\t\ttargetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n\t\t\ttry {\n\t\t\t\tspecificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t} catch (AccessControlException ex) {\n\t\t\t\t// security settings are disallowing reflective access; leave\n\t\t\t\t// 'specificMethod' null and fall back to 'method' below\n\t\t\t}\n\t\t}\n\t\treturn (specificMethod != null ? specificMethod : method);\n\t}","id":47603,"modified_method":"/**\n\t * Given a method, which may come from an interface, and a target class used\n\t * in the current reflective invocation, find the corresponding target method\n\t * if there is one. E.g. the method may be <code>IFoo.bar()<\/code> and the\n\t * target class may be <code>DefaultFoo<\/code>. In this case, the method may be\n\t * <code>DefaultFoo.bar()<\/code>. This enables attributes on that method to be found.\n\t * <p><b>NOTE:<\/b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n\t * this method does <i>not<\/i> resolve Java 5 bridge methods automatically.\n\t * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n\t * if bridge method resolution is desirable (e.g. for obtaining metadata from\n\t * the original method definition).\n\t * <p><b>NOTE:<\/b> Since Spring 3.1.1, if Java security settings disallow reflective\n\t * access (e.g. calls to {@code Class#getDeclaredMethods} etc, this implementation\n\t * will fall back to returning the originally provided method.\n\t * @param method the method to be invoked, which may come from an interface\n\t * @param targetClass the target class for the current invocation.\n\t * May be <code>null<\/code> or may not even implement the method.\n\t * @return the specific target method, or the original method if the\n\t * <code>targetClass<\/code> doesn't implement it or is <code>null<\/code>\n\t */\n\tpublic static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n\t\tif (method != null && isOverridable(method, targetClass) &&\n\t\t\t\ttargetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n\t\t\ttry {\n\t\t\t\tif (Modifier.isPublic(method.getModifiers())) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn targetClass.getMethod(method.getName(), method.getParameterTypes());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t\t\treturn method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMethod specificMethod =\n\t\t\t\t\t\t\tReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n\t\t\t\t\treturn (specificMethod != null ? specificMethod : method);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AccessControlException ex) {\n\t\t\t\t// Security settings are disallowing reflective access; fall back to 'method' below.\n\t\t\t}\n\t\t}\n\t\treturn method;\n\t}","commit_id":"49294c9d008ab63d3b33d708fc48b3f4321785db","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n   * @param className  class where member should be found\n   * @param memberName member that starts with dot (<code>.<\/code>) is treated as method.\n   *                   It is treated parent class otherwise\n   * @return member or null if not found\n   */\n  @NotNull\n  protected PyElement findMember(@NotNull String className, @NotNull String memberName) {\n    boolean findMethod = memberName.contains(\".\");\n    PyElement result = (findMethod ? findMethod(className, memberName.substring(1)) : findClass(memberName));\n    Assert.assertNotNull(String.format(\"No member %s found in class %s\", memberName, className), result);\n    return result;\n  }","id":47604,"modified_method":"/**\n   * @param className  class where member should be found\n   * @param memberName member that starts with dot (<code>.<\/code>) is treated as method.\n   *                   member that starts with dash (<code>#<\/code>) is treated as attribute.\n   *                   It is treated parent class otherwise\n   * @return member or null if not found\n   */\n  @NotNull\n  protected PyElement findMember(@NotNull String className, @NotNull String memberName) {\n    final PyElement result;\n    //TODO: Get rid of this chain of copy pastes\n    if (memberName.contains(\".\")) {\n      result = findMethod(className, memberName.substring(1));\n    }\n    else if (memberName.contains(\"#\")) {\n      result = findField(className, memberName.substring(1));\n    }\n    else {\n      result = findClass(memberName);\n    }\n    Assert.assertNotNull(String.format(\"No member %s found in class %s\", memberName, className), result);\n    return result;\n  }","commit_id":"7ae9d1d2b1b8e35e00e9ceea2023b10c7129e151","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks that some members are not allowed\n   */\n  public void testDisabledMembers() throws Exception {\n    PyPullUpPresenterImpl sut = configureByClass(\"SomeMembersDisabled\");\n    EasyMock.expect(myView.getSelectedParent()).andReturn(getClassByName(\"SubParent1\")).anyTimes();\n\n    myMocksControl.replay();\n    sut.launch();\n\n    Assert.assertTrue(\"No members selected\", myMemberInfos.hasCaptured());\n    List<PyMemberInfo> members = myMemberInfos.getValue();\n    Assert.assertFalse(\"No members selected\", members.isEmpty());\n    Collection<Pair<String, Boolean>> memberNamesAndStatus = Collections2.transform(members, new NameAndStatusTransformer(sut));\n\n    //Pair will return correct type\n    @SuppressWarnings(\"unchecked\") Matcher<Iterable<? extends Pair<String, Boolean>>> matcher = Matchers\n      .containsInAnyOrder(\n        Pair.create(\"date\", true),\n        Pair.create(\"SubParent1\", false),\n        Pair.create(\"foo\", false),\n        Pair.create(\"bar\", true));\n    Assert.assertThat(\"Wrong members or their states\", memberNamesAndStatus, matcher);\n\n\n  }","id":47605,"modified_method":"/**\n   * Checks that some members are not allowed\n   */\n  public void testDisabledMembers() throws Exception {\n    PyPullUpPresenterImpl sut = configureByClass(\"SomeMembersDisabled\");\n    EasyMock.expect(myView.getSelectedParent()).andReturn(getClassByName(\"SubParent1\")).anyTimes();\n\n    myMocksControl.replay();\n    sut.launch();\n\n    Assert.assertTrue(\"No members selected\", myMemberInfos.hasCaptured());\n    List<PyMemberInfo> members = myMemberInfos.getValue();\n    Assert.assertFalse(\"No members selected\", members.isEmpty());\n    Collection<Pair<String, Boolean>> memberNamesAndStatus = Collections2.transform(members, new NameAndStatusTransformer(sut));\n\n    //Pair will return correct type\n    @SuppressWarnings(\"unchecked\") Matcher<Iterable<? extends Pair<String, Boolean>>> matcher = Matchers\n      .containsInAnyOrder(\n        Pair.create(\"date\", true),\n        Pair.create(\"CLASS_FIELD\", true),\n        Pair.create(\"SubParent1\", false),\n        Pair.create(\"foo\", false),\n        Pair.create(\"bar\", true));\n    Assert.assertThat(\"Wrong members or their states\", memberNamesAndStatus, matcher);\n\n\n  }","commit_id":"7ae9d1d2b1b8e35e00e9ceea2023b10c7129e151","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void configure(final DeploymentPhaseContext context, final ComponentConfiguration componentConfiguration, final ViewDescription description, final ViewConfiguration configuration) throws DeploymentUnitProcessingException {\n            // Create method indexes\n            final DeploymentReflectionIndex reflectionIndex = context.getDeploymentUnit().getAttachment(REFLECTION_INDEX);\n            final List<Method> methods = configuration.getProxyFactory().getCachedMethods();\n            for (final Method method : methods) {\n                final Method componentMethod = ClassReflectionIndexUtil.findMethod(reflectionIndex, componentConfiguration.getComponentClass(), MethodIdentifier.getIdentifierForMethod(method));\n                if (componentMethod != null) {\n                    configuration.addViewInterceptor(method, new ImmediateInterceptorFactory(new ComponentDispatcherInterceptor(componentMethod)), InterceptorOrder.View.COMPONENT_DISPATCHER);\n                    configuration.addClientInterceptor(method, CLIENT_DISPATCHER_INTERCEPTOR_FACTORY, InterceptorOrder.Client.CLIENT_DISPATCHER);\n                }\n            }\n\n            configuration.addClientPostConstructInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ClientPostConstruct.TERMINAL_INTERCEPTOR);\n            configuration.addClientPreDestroyInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ClientPreDestroy.TERMINAL_INTERCEPTOR);\n        }","id":47606,"modified_method":"public void configure(final DeploymentPhaseContext context, final ComponentConfiguration componentConfiguration, final ViewDescription description, final ViewConfiguration configuration) throws DeploymentUnitProcessingException {\n            // Create method indexes\n            final DeploymentReflectionIndex reflectionIndex = context.getDeploymentUnit().getAttachment(REFLECTION_INDEX);\n            final List<Method> methods = configuration.getProxyFactory().getCachedMethods();\n            for (final Method method : methods) {\n                MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifierForMethod(method);\n                Method componentMethod = ClassReflectionIndexUtil.findMethod(reflectionIndex, componentConfiguration.getComponentClass(), methodIdentifier);\n\n                if (componentMethod != null) {\n\n                    if ((BRIDGE & componentMethod.getModifiers()) != 0) {\n                        Collection<Method> otherMethods = ClassReflectionIndexUtil.findMethods(reflectionIndex, reflectionIndex.getClassIndex(componentConfiguration.getComponentClass()), methodIdentifier.getName(), methodIdentifier.getParameterTypes());\n                        //try and find the non-bridge method to delegate to\n                        for (final Method other : otherMethods) {\n                            if ((BRIDGE & other.getModifiers()) == 0) {\n                                componentMethod = other;\n                                break;\n                            }\n                        }\n                    }\n\n                    configuration.addViewInterceptor(method, new ImmediateInterceptorFactory(new ComponentDispatcherInterceptor(componentMethod)), InterceptorOrder.View.COMPONENT_DISPATCHER);\n                    configuration.addClientInterceptor(method, CLIENT_DISPATCHER_INTERCEPTOR_FACTORY, InterceptorOrder.Client.CLIENT_DISPATCHER);\n                }\n            }\n\n            configuration.addClientPostConstructInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ClientPostConstruct.TERMINAL_INTERCEPTOR);\n            configuration.addClientPreDestroyInterceptor(Interceptors.getTerminalInterceptorFactory(), InterceptorOrder.ClientPreDestroy.TERMINAL_INTERCEPTOR);\n        }","commit_id":"b64c7b3692ea1271ea920b6f1a9b433b80ea0bc2","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected Method retrieveAction(GroovyObject controller, String actionName,\n             HttpServletResponse response) {\n        Method action = ReflectionUtils.findMethod(controller.getClass(), actionName, NOARGS);\n        if (action != null) {\n            ReflectionUtils.makeAccessible(action);\n        }\n\n        if (action == null || action.getAnnotation(Action.class) == null) {\n            try {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return null;\n            } catch (IOException e) {\n                throw new ControllerExecutionException(\"I/O error sending 404 error\", e);\n            }\n        }\n        return action;\n    }","id":47607,"modified_method":"@Override\n    protected Method retrieveAction(GroovyObject controller, String actionName,\n             HttpServletResponse response) {\n        Method action = (controller != null && actionName != null) ? ReflectionUtils.findMethod(controller.getClass(), actionName, NOARGS) : null;\n        if (action != null) {\n            ReflectionUtils.makeAccessible(action);\n        }\n\n        if (action == null || action.getAnnotation(Action.class) == null) {\n            try {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n                return null;\n            } catch (IOException e) {\n                throw new ControllerExecutionException(\"I/O error sending 404 error\", e);\n            }\n        }\n        return action;\n    }","commit_id":"f42a6c10e5101bcfc5237bf8f7b0340d676b78f5","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected Object retrieveAction(GroovyObject controller, String actionName, HttpServletResponse response) {\n        Pair<Class<?>, String> key = new Pair<Class<?>, String>(controller.getClass(), actionName);\n\n        Method mAction = controllerToActionMethodCache.get(key);\n\n        if (mAction != null) {\n            if (mAction != NULL_METHOD_HOLDER) {    \n                return mAction;\n            } else {\n                return sendNotFoundError(response);                                \n            }\n        }\n\n        MetaProperty metaProperty = controllerToMetaPropertyCache.get(key);\n\n        if (metaProperty == null) {\n            Class<?> controllerClass = AopProxyUtils.ultimateTargetClass(controller);\n\n            mAction = ReflectionUtils.findMethod(controllerClass, actionName, NOARGS);\n            if (mAction != null) {\n                ReflectionUtils.makeAccessible(mAction);\n                if (mAction.getAnnotation(Action.class) != null) {\n                    if (!developmentMode) {\n                        controllerToActionMethodCache.put(key, mAction);\n                    }\n                    return mAction;\n                }\n                else if (!developmentMode) {\n                    controllerToActionMethodCache.put(key, NULL_METHOD_HOLDER);\n                }\n            }\n        }\n\n        if (metaProperty == null) {\n            metaProperty = controller.getMetaClass().getMetaProperty(actionName);\n            if (!developmentMode) {\n                if (metaProperty != null) {\n                    controllerToMetaPropertyCache.put(key, metaProperty);\n                }\n                else {\n                    controllerToMetaPropertyCache.put(key, NULL_META_PROPERTY_HOLDER);\n                }\n            }\n        }\n\n        Object closureAction = null;\n\n        if (metaProperty != null) {\n            if (metaProperty == NULL_META_PROPERTY_HOLDER) {\n                return sendNotFoundError(response);    \n            }\n            if (metaProperty.getType() == Object.class || Closure.class.isAssignableFrom(metaProperty.getType())) {\n                closureAction = metaProperty.getProperty(controller);\n            }\n            else {\n                log.error(\"Invalid type for \" + actionName + \" in \" + controller.getClass().getName() + \". type is \"\n                        + metaProperty.getType());\n                if (!developmentMode) {\n                    controllerToMetaPropertyCache.put(key, NULL_META_PROPERTY_HOLDER);\n                }\n            }\n        }\n\n        if (!(closureAction instanceof Closure)) {\n            return sendNotFoundError(response);\n        }\n\n        return closureAction;\n    }","id":47608,"modified_method":"@Override\n    protected Object retrieveAction(GroovyObject controller, String actionName, HttpServletResponse response) {\n        if(controller==null || actionName==null) {\n            return sendNotFoundError(response);\n        }\n        \n        Pair<Class<?>, String> key = new Pair<Class<?>, String>(controller.getClass(), actionName);\n\n        Method mAction = controllerToActionMethodCache.get(key);\n\n        if (mAction != null) {\n            if (mAction != NULL_METHOD_HOLDER) {    \n                return mAction;\n            } else {\n                return sendNotFoundError(response);                                \n            }\n        }\n\n        MetaProperty metaProperty = controllerToMetaPropertyCache.get(key);\n\n        if (metaProperty == null) {\n            Class<?> controllerClass = AopProxyUtils.ultimateTargetClass(controller);\n\n            mAction = ReflectionUtils.findMethod(controllerClass, actionName, NOARGS);\n            if (mAction != null) {\n                ReflectionUtils.makeAccessible(mAction);\n                if (mAction.getAnnotation(Action.class) != null) {\n                    if (!developmentMode) {\n                        controllerToActionMethodCache.put(key, mAction);\n                    }\n                    return mAction;\n                }\n                else if (!developmentMode) {\n                    controllerToActionMethodCache.put(key, NULL_METHOD_HOLDER);\n                }\n            }\n        }\n\n        if (metaProperty == null) {\n            metaProperty = controller.getMetaClass().getMetaProperty(actionName);\n            if (!developmentMode) {\n                if (metaProperty != null) {\n                    controllerToMetaPropertyCache.put(key, metaProperty);\n                }\n                else {\n                    controllerToMetaPropertyCache.put(key, NULL_META_PROPERTY_HOLDER);\n                }\n            }\n        }\n\n        Object closureAction = null;\n\n        if (metaProperty != null) {\n            if (metaProperty == NULL_META_PROPERTY_HOLDER) {\n                return sendNotFoundError(response);    \n            }\n            if (metaProperty.getType() == Object.class || Closure.class.isAssignableFrom(metaProperty.getType())) {\n                closureAction = metaProperty.getProperty(controller);\n            }\n            else {\n                log.error(\"Invalid type for \" + actionName + \" in \" + controller.getClass().getName() + \". type is \"\n                        + metaProperty.getType());\n                if (!developmentMode) {\n                    controllerToMetaPropertyCache.put(key, NULL_META_PROPERTY_HOLDER);\n                }\n            }\n        }\n\n        if (!(closureAction instanceof Closure)) {\n            return sendNotFoundError(response);\n        }\n\n        return closureAction;\n    }","commit_id":"f42a6c10e5101bcfc5237bf8f7b0340d676b78f5","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected Object doInvoke(MuleEvent event) throws Exception\n    {\n        MuleMessage message = event.getMessage();\n\n        String path = (String) message.getInboundProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        String contextPath = (String) message.getInboundProperty(HttpConnector.HTTP_CONTEXT_PATH_PROPERTY);\n        String query = null;\n        int queryIdx = path.indexOf('?');\n        if (queryIdx != -1)\n        {\n            query = path.substring(queryIdx + 1);\n            path = path.substring(0, queryIdx);\n        }\n\n        URI endpointUri = event.getMessageSourceURI();\n        String host = message.getInboundProperty(\"Host\", endpointUri.getHost());\n        String method = message.getInboundProperty(HttpConnector.HTTP_METHOD_PROPERTY);\n        InBoundHeaders headers = new InBoundHeaders();\n        for (Object prop : message.getInboundPropertyNames())\n        {\n            Object property = message.getInboundProperty(prop.toString());\n            if (property != null)\n            {\n                headers.add(prop.toString(), property.toString());\n            }\n        }\n\n        String scheme;\n        if (\"servlet\".equals(endpointUri.getScheme()))\n        {\n            scheme = \"http\";\n        }\n        else\n        {\n            scheme = endpointUri.getScheme();\n        }\n\n        URI baseUri = getBaseUri(endpointUri, scheme, host, contextPath);\n        URI completeUri = getCompleteUri(endpointUri, scheme, host, path, query);\n        ContainerRequest req = new ContainerRequest(application, method, baseUri, completeUri, headers,\n            getInputStream(message));\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Base URI: \" + baseUri);\n            logger.debug(\"Complete URI: \" + completeUri);\n        }\n\n        MuleResponseWriter writer = new MuleResponseWriter(message);\n        ContainerResponse res = new ContainerResponse(application, req, writer);\n\n        application.handleRequest(req, res);\n\n        return writer.getResponse();\n    }","id":47609,"modified_method":"@Override\n    protected Object doInvoke(MuleEvent event) throws Exception\n    {\n        MuleMessage message = event.getMessage();\n\n        String path = message.getInboundProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        String contextPath = message.getInboundProperty(HttpConnector.HTTP_CONTEXT_PATH_PROPERTY);\n        String query = null;\n        int queryIdx = path.indexOf('?');\n        if (queryIdx != -1)\n        {\n            query = path.substring(queryIdx + 1);\n            path = path.substring(0, queryIdx);\n        }\n\n        URI endpointUri = event.getMessageSourceURI();\n        String host = message.getInboundProperty(\"Host\", endpointUri.getHost());\n        String method = message.getInboundProperty(HttpConnector.HTTP_METHOD_PROPERTY);\n        InBoundHeaders headers = new InBoundHeaders();\n        for (Object prop : message.getInboundPropertyNames())\n        {\n            if (prop.equals(HttpConnector.HTTP_COOKIES_PROPERTY))\n            {\n                org.apache.commons.httpclient.Cookie[] apacheCookies = message\n                        .getInboundProperty(HttpConnector.HTTP_COOKIES_PROPERTY);\n                for (org.apache.commons.httpclient.Cookie apacheCookie : apacheCookies)\n                {\n                    Cookie cookie = new Cookie(apacheCookie.getName(), apacheCookie.getValue());\n                    headers.addObject(HttpConstants.HEADER_COOKIE, cookie);\n                }\n            } else\n            {\n                Object property = message.getInboundProperty(prop.toString());\n                if (property != null)\n                {\n                    headers.add(prop.toString(), property.toString());\n                }\n            }\n        }\n\n        String scheme;\n        if (\"servlet\".equals(endpointUri.getScheme()))\n        {\n            scheme = \"http\";\n        }\n        else\n        {\n            scheme = endpointUri.getScheme();\n        }\n\n        URI baseUri = getBaseUri(endpointUri, scheme, host, contextPath);\n        URI completeUri = getCompleteUri(endpointUri, scheme, host, path, query);\n        ContainerRequest req = new ContainerRequest(application, method, baseUri, completeUri, headers,\n            getInputStream(message));\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Base URI: \" + baseUri);\n            logger.debug(\"Complete URI: \" + completeUri);\n        }\n\n        MuleResponseWriter writer = new MuleResponseWriter(message);\n        ContainerResponse res = new ContainerResponse(application, req, writer);\n\n        application.handleRequest(req, res);\n\n        return writer.getResponse();\n    }","commit_id":"2df8bf08231644d80f1541f7772e95ad18fc68bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setExceptionMapper(ExceptionMapper<?> exceptionMapper)\n    {\n        exceptionMappers.add(exceptionMapper);\n    }","id":47610,"modified_method":"public void setExceptionMappers(List<ExceptionMapper<?>> exceptionMappers)\n    {\n        this.exceptionMappers.addAll(exceptionMappers);\n    }","commit_id":"2df8bf08231644d80f1541f7772e95ad18fc68bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setContextResolver(ContextResolver<?> contextResolver)\n    {\n       contextResolvers.add(contextResolver);\n    }","id":47611,"modified_method":"public void setContextResolvers(List<ContextResolver<?>> contextResolvers)\n    {\n        this.contextResolvers.addAll(contextResolvers);\n    }","commit_id":"2df8bf08231644d80f1541f7772e95ad18fc68bb","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getMethodOrOperationName(MuleEvent event) throws DispatchException\n    {\n        // People can specify a CXF operation, which may in fact be different\n        // than the method name. If that's not found, we'll default back to the \n        // mule method property. \n        String method = event.getMessage().getInvocationProperty(CxfConstants.OPERATION);\n\n        if (method == null)\n        {\n            method = (String) event.getMessage().getInvocationProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        }\n\n        if (method == null)\n        {\n            method = defaultMethodName;\n        }\n        \n        if (method == null && proxy)\n        {\n            return \"invoke\";\n        }\n\n        if (method == null)\n        {\n            throw new DispatchException(SoapMessages.cannotInvokeCallWithoutOperation(), event.getMessage(),\n                event.getEndpoint());\n        }\n\n        return method;\n    }","id":47612,"modified_method":"protected String getMethodOrOperationName(MuleEvent event) throws DispatchException\n    {\n        // People can specify a CXF operation, which may in fact be different\n        // than the method name. If that's not found, we'll default back to the \n        // mule method property. \n        String method = event.getMessage().getInvocationProperty(CxfConstants.OPERATION);\n\n        if (method == null)\n        {\n            method = event.getMessage().getInvocationProperty(MuleProperties.MULE_METHOD_PROPERTY);\n        }\n\n        if (method == null)\n        {\n            method = defaultMethodName;\n        }\n        \n        if (method == null && proxy)\n        {\n            return \"invoke\";\n        }\n\n        if (method == null)\n        {\n            throw new DispatchException(SoapMessages.cannotInvokeCallWithoutOperation(), event.getMessage(),\n                event.getEndpoint());\n        }\n\n        return method;\n    }","commit_id":"a7f291144efde2acc290017b582e473e904285cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public MuleSession retrieveSessionInfoFromMessage(MuleMessage message) throws MuleException\n    {\n        MuleSession session = null;\n        \n        Cookie[] cookies = (Cookie[]) message.getOutboundProperty(HttpConnector.HTTP_COOKIES_PROPERTY);\n        if (cookies != null && cookies.length > 0)\n        {\n            byte[] serializedSession = Base64.decode(cookies[0].getValue());\n            \n            if (serializedSession != null)\n            {\n                session = (MuleSession) SerializationUtils.deserialize(serializedSession);\n            }\n        }\n        return session;\n    }","id":47613,"modified_method":"public MuleSession retrieveSessionInfoFromMessage(MuleMessage message) throws MuleException\n    {\n        MuleSession session = null;\n\n        Cookie[] cookies = message.getOutboundProperty(HttpConnector.HTTP_COOKIES_PROPERTY);\n        if (cookies != null && cookies.length > 0)\n        {\n            byte[] serializedSession = Base64.decode(cookies[0].getValue());\n            \n            if (serializedSession != null)\n            {\n                session = (MuleSession) SerializationUtils.deserialize(serializedSession);\n            }\n        }\n        return session;\n    }","commit_id":"a7f291144efde2acc290017b582e473e904285cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public MuleSession retrieveSessionInfoFromMessage(MuleMessage message) throws MuleException\n    {\n        MuleSession session = null;\n        byte[] serializedSession = (byte[]) message.getInboundProperty(MuleProperties.MULE_SESSION_PROPERTY);\n\n        if (serializedSession != null)\n        {\n            session = (MuleSession) SerializationUtils.deserialize(serializedSession);\n        }\n        return session;\n    }","id":47614,"modified_method":"public MuleSession retrieveSessionInfoFromMessage(MuleMessage message) throws MuleException\n    {\n        MuleSession session = null;\n        byte[] serializedSession = message.getInboundProperty(MuleProperties.MULE_SESSION_PROPERTY);\n\n        if (serializedSession != null)\n        {\n            session = (MuleSession) SerializationUtils.deserialize(serializedSession);\n        }\n        return session;\n    }","commit_id":"a7f291144efde2acc290017b582e473e904285cd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected MuleEvent sendToDestination(MuleEvent event) throws MuleException, IOException\n    {\n        try\n        {\n            final MessageImpl m = new MessageImpl();\n            final MuleMessage muleReqMsg = event.getMessage();\n            String method = muleReqMsg.getInboundProperty(HttpConnector.HTTP_METHOD_PROPERTY);\n\n            String ct = muleReqMsg.getInboundProperty(HttpConstants.HEADER_CONTENT_TYPE);\n            if (ct != null)\n            {\n                m.put(Message.CONTENT_TYPE, ct);\n            }\n\n            String path = muleReqMsg.getInboundProperty(HttpConnector.HTTP_REQUEST_PATH_PROPERTY);\n            if (path == null)\n            {\n                path = \"\";\n            }\n\n            if (method != null)\n            {\n                m.put(Message.HTTP_REQUEST_METHOD, method);\n                m.put(Message.PATH_INFO, path);\n                Object basePath = muleReqMsg.getInboundProperty(HttpConnector.HTTP_CONTEXT_PATH_PROPERTY);\n                m.put(Message.BASE_PATH, basePath);\n\n                method = method.toUpperCase();\n            }\n\n            if (!\"GET\".equals(method))\n            {\n                Object payload = event.getMessage().getPayload();\n\n                setPayload(event, m, payload);\n            }\n\n            // TODO: Not sure if this is 100% correct - DBD\n            String soapAction = getSoapAction(event.getMessage());\n            m.put(org.mule.module.cxf.SoapConstants.SOAP_ACTION_PROPERTY_CAPS, soapAction);\n            \n            // For MULE-6829\n            if (shouldSoapActionHeader())\n            {\n                // Add protocol headers with the soap action so that the SoapActionInInterceptor can find them if it is soap v1.1\n                Map<String, List<String>> protocolHeaders = new HashMap<String, List<String>>();\n                if (soapAction != null && !soapAction.isEmpty())\n                {\n                    List<String> soapActions = new ArrayList<String>();\n                    // An HTTP client MUST use [SOAPAction] header field when issuing a SOAP HTTP Request.\n                    // The header field value of empty string (\"\") means that the intent of the SOAP message is provided by the HTTP Request-URI. \n                    // No value means that there is no indication of the intent of the message.\n                    soapActions.add(soapAction);\n                    protocolHeaders.put(SoapBindingConstants.SOAP_ACTION, soapActions);\n                }\n\n                String eventRequestUri = event.getMessageSourceURI().toString();\n                if (eventRequestUri.startsWith(JmsConnector.JMS))\n                {\n                    String contentType = muleReqMsg.getInboundProperty(SoapJMSConstants.CONTENTTYPE_FIELD) != null ? (String) muleReqMsg.getInboundProperty(SoapJMSConstants.CONTENTTYPE_FIELD) : \"text/xml\";\n                    String requestUri = muleReqMsg.getInboundProperty(SoapJMSConstants.REQUESTURI_FIELD) != null ? (String) muleReqMsg.getInboundProperty(SoapJMSConstants.REQUESTURI_FIELD) : eventRequestUri;\n\n                    protocolHeaders.put(SoapJMSConstants.CONTENTTYPE_FIELD, Collections.singletonList(contentType));\n                    protocolHeaders.put(SoapJMSConstants.REQUESTURI_FIELD, Collections.singletonList(requestUri));\n                }\n\n                m.put(Message.PROTOCOL_HEADERS, protocolHeaders);\n            }\n\n            org.apache.cxf.transport.Destination d;\n            \n            if (server != null) \n            {\n                d = server.getDestination();\n            }\n            else\n            {\n                String serviceUri = getUri(event);\n\n                DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);\n                DestinationFactory df = dfm.getDestinationFactoryForUri(serviceUri);\n                \n                EndpointInfo ei = new EndpointInfo();\n                ei.setAddress(serviceUri);\n                d = df.getDestination(ei);\n            }\n\n            // Set up a listener for the response\n            m.put(LocalConduit.DIRECT_DISPATCH, Boolean.TRUE);\n            m.setDestination(d);\n\n            ExchangeImpl exchange = new ExchangeImpl();\n            // mule will close the stream so don't let cxf, otherwise cxf will close it too early\n            exchange.put(StaxInEndingInterceptor.STAX_IN_NOCLOSE, Boolean.TRUE);\n            exchange.setInMessage(m);\n\n            // if there is a fault, then we need an event in here because we won't\n            // have a responseEvent from the MuleInvoker\n            exchange.put(CxfConstants.MULE_EVENT, event);\n\n            // invoke the actual web service up until right before we serialize the\n            // response\n            d.getMessageObserver().onMessage(m);\n            \n            // get the response event\n            MuleEvent responseEvent = (MuleEvent) exchange.get(CxfConstants.MULE_EVENT);\n\n            // If there isn't one, there was probably a fault, so use the original\n            // event\n            if (responseEvent == null || VoidMuleEvent.getInstance().equals(responseEvent)\n                || !event.getExchangePattern().hasResponse())\n            {\n                return null;\n            }\n            \n            MuleMessage muleResMsg = responseEvent.getMessage();\n            muleResMsg.setPayload(getRessponseOutputHandler(m));\n\n            // Handle a fault if there is one.\n            Message faultMsg = m.getExchange().getOutFaultMessage();\n            if (faultMsg != null)\n            {\n                Exception ex = faultMsg.getContent(Exception.class);\n                if (ex != null)\n                {\n                    ExceptionPayload exceptionPayload = new DefaultExceptionPayload(ex);\n                    event.getMessage().setExceptionPayload(exceptionPayload);\n                    muleResMsg.setOutboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 500);\n                }\n            }\n\n            return responseEvent;\n        }\n        catch (MuleException e)\n        {\n            logger.warn(\"Could not dispatch message to CXF!\", e);\n            throw e;\n        }\n    }","id":47615,"modified_method":"protected MuleEvent sendToDestination(MuleEvent event) throws MuleException, IOException\n    {\n        try\n        {\n            final MessageImpl m = new MessageImpl();\n            final MuleMessage muleReqMsg = event.getMessage();\n            String method = muleReqMsg.getInboundProperty(HttpConnector.HTTP_METHOD_PROPERTY);\n\n            String ct = muleReqMsg.getInboundProperty(HttpConstants.HEADER_CONTENT_TYPE);\n            if (ct != null)\n            {\n                m.put(Message.CONTENT_TYPE, ct);\n            }\n\n            String path = muleReqMsg.getInboundProperty(HttpConnector.HTTP_REQUEST_PATH_PROPERTY);\n            if (path == null)\n            {\n                path = \"\";\n            }\n\n            if (method != null)\n            {\n                m.put(Message.HTTP_REQUEST_METHOD, method);\n                m.put(Message.PATH_INFO, path);\n                Object basePath = muleReqMsg.getInboundProperty(HttpConnector.HTTP_CONTEXT_PATH_PROPERTY);\n                m.put(Message.BASE_PATH, basePath);\n\n                method = method.toUpperCase();\n            }\n\n            if (!\"GET\".equals(method))\n            {\n                Object payload = event.getMessage().getPayload();\n\n                setPayload(event, m, payload);\n            }\n\n            // TODO: Not sure if this is 100% correct - DBD\n            String soapAction = getSoapAction(event.getMessage());\n            m.put(org.mule.module.cxf.SoapConstants.SOAP_ACTION_PROPERTY_CAPS, soapAction);\n            \n            // For MULE-6829\n            if (shouldSoapActionHeader())\n            {\n                // Add protocol headers with the soap action so that the SoapActionInInterceptor can find them if it is soap v1.1\n                Map<String, List<String>> protocolHeaders = new HashMap<String, List<String>>();\n                if (soapAction != null && !soapAction.isEmpty())\n                {\n                    List<String> soapActions = new ArrayList<String>();\n                    // An HTTP client MUST use [SOAPAction] header field when issuing a SOAP HTTP Request.\n                    // The header field value of empty string (\"\") means that the intent of the SOAP message is provided by the HTTP Request-URI. \n                    // No value means that there is no indication of the intent of the message.\n                    soapActions.add(soapAction);\n                    protocolHeaders.put(SoapBindingConstants.SOAP_ACTION, soapActions);\n                }\n\n                String eventRequestUri = event.getMessageSourceURI().toString();\n                if (eventRequestUri.startsWith(JmsConnector.JMS))\n                {\n                    String contentType = muleReqMsg.getInboundProperty(SoapJMSConstants.CONTENTTYPE_FIELD);\n                    if (contentType == null)\n                    {\n                        contentType = \"text/xml\";\n                    }\n                    protocolHeaders.put(SoapJMSConstants.CONTENTTYPE_FIELD, Collections.singletonList(contentType));\n\n                    String requestUri = muleReqMsg.getInboundProperty(SoapJMSConstants.REQUESTURI_FIELD);\n                    if (requestUri == null)\n                    {\n                        requestUri = eventRequestUri;\n                    }\n                    protocolHeaders.put(SoapJMSConstants.REQUESTURI_FIELD, Collections.singletonList(requestUri));\n                }\n\n                m.put(Message.PROTOCOL_HEADERS, protocolHeaders);\n            }\n\n            org.apache.cxf.transport.Destination d;\n            \n            if (server != null) \n            {\n                d = server.getDestination();\n            }\n            else\n            {\n                String serviceUri = getUri(event);\n\n                DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);\n                DestinationFactory df = dfm.getDestinationFactoryForUri(serviceUri);\n                \n                EndpointInfo ei = new EndpointInfo();\n                ei.setAddress(serviceUri);\n                d = df.getDestination(ei);\n            }\n\n            // Set up a listener for the response\n            m.put(LocalConduit.DIRECT_DISPATCH, Boolean.TRUE);\n            m.setDestination(d);\n\n            ExchangeImpl exchange = new ExchangeImpl();\n            // mule will close the stream so don't let cxf, otherwise cxf will close it too early\n            exchange.put(StaxInEndingInterceptor.STAX_IN_NOCLOSE, Boolean.TRUE);\n            exchange.setInMessage(m);\n\n            // if there is a fault, then we need an event in here because we won't\n            // have a responseEvent from the MuleInvoker\n            exchange.put(CxfConstants.MULE_EVENT, event);\n\n            // invoke the actual web service up until right before we serialize the\n            // response\n            d.getMessageObserver().onMessage(m);\n            \n            // get the response event\n            MuleEvent responseEvent = (MuleEvent) exchange.get(CxfConstants.MULE_EVENT);\n\n            // If there isn't one, there was probably a fault, so use the original\n            // event\n            if (responseEvent == null || VoidMuleEvent.getInstance().equals(responseEvent)\n                || !event.getExchangePattern().hasResponse())\n            {\n                return null;\n            }\n            \n            MuleMessage muleResMsg = responseEvent.getMessage();\n            muleResMsg.setPayload(getRessponseOutputHandler(m));\n\n            // Handle a fault if there is one.\n            Message faultMsg = m.getExchange().getOutFaultMessage();\n            if (faultMsg != null)\n            {\n                Exception ex = faultMsg.getContent(Exception.class);\n                if (ex != null)\n                {\n                    ExceptionPayload exceptionPayload = new DefaultExceptionPayload(ex);\n                    event.getMessage().setExceptionPayload(exceptionPayload);\n                    muleResMsg.setOutboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 500);\n                }\n            }\n\n            return responseEvent;\n        }\n        catch (MuleException e)\n        {\n            logger.warn(\"Could not dispatch message to CXF!\", e);\n            throw e;\n        }\n    }","commit_id":"45d7552312e018ab22eb460102304a4537eac7b2","url":"https://github.com/mulesoft/mule"},{"original_method":"public Response toResponse(BeanBadRequestException exception)\n    {\n        int status = Response.Status.BAD_REQUEST.getStatusCode();\n        return Response.status(status).entity(exception.getMessage()).type(\"text/plain\").build();\n    }","id":47616,"modified_method":"public Response toResponse(BeanBadRequestException exception)\n    {\n        int status = Response.Status.BAD_REQUEST.getStatusCode();\n        return Response.status(status).entity(exception.getMessage()).type(MimeTypes.TEXT).build();\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"@GET\n    @Produces(\"text/plain\")\n    @Path(\"/throwBadRequestException\")\n    public HelloWorld throwHelloBeanException() throws BeanBadRequestException {\n        throw  new BeanBadRequestException(\"beans are rotten\");\n    }","id":47617,"modified_method":"@GET\n    @Produces(\"text/plain\")\n    @Path(\"/throwBadRequestException\")\n    public HelloBean throwHelloBeanException() throws BeanBadRequestException\n    {\n        throw new BeanBadRequestException(\"beans are rotten\");\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected Object doInvoke(MuleEvent event) throws Exception\n    {\n        MuleMessage message = event.getMessage();\n\n        String path = (String) message.getInboundProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        String contextPath = (String) message.getInboundProperty(HttpConnector.HTTP_CONTEXT_PATH_PROPERTY);\n        String query = null;\n        int queryIdx = path.indexOf('?');\n        if (queryIdx != -1)\n        {\n            query = path.substring(queryIdx + 1);\n            path = path.substring(0, queryIdx);\n        }\n\n        URI endpointUri = event.getMessageSourceURI();\n        String host = message.getInboundProperty(\"Host\", endpointUri.getHost());\n        String method = message.getInboundProperty(HttpConnector.HTTP_METHOD_PROPERTY);\n        InBoundHeaders headers = new InBoundHeaders();\n        for (Object prop : message.getInboundPropertyNames())\n        {\n            Object property = message.getInboundProperty(prop.toString());\n            if (property != null)\n            {\n                headers.add(prop.toString(), property.toString());\n            }\n        }\n\n        String scheme;\n        if (\"servlet\".equals(endpointUri.getScheme()))\n        {\n            scheme = \"http\";\n        }\n        else\n        {\n            scheme = endpointUri.getScheme();\n        }\n\n        URI baseUri = getBaseUri(endpointUri, scheme, host, contextPath);\n        URI completeUri = getCompleteUri(endpointUri, scheme, host, path, query);\n        ContainerRequest req = new ContainerRequest(application, method, baseUri, completeUri, headers,\n            getInputStream(message));\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Base URI: \" + baseUri);\n            logger.debug(\"Complete URI: \" + completeUri);\n        }\n\n        MuleResponseWriter writer = new MuleResponseWriter(message);\n        ContainerResponse res = new ContainerResponse(application, req, writer);\n\n        application.handleRequest(req, res);\n\n        return writer.getResponse();\n    }","id":47618,"modified_method":"@Override\n    protected Object doInvoke(MuleEvent event) throws Exception\n    {\n        MuleMessage message = event.getMessage();\n\n        String path = message.getInboundProperty(HttpConnector.HTTP_REQUEST_PROPERTY);\n        String contextPath = message.getInboundProperty(HttpConnector.HTTP_CONTEXT_PATH_PROPERTY);\n        String query = null;\n        int queryIdx = path.indexOf('?');\n        if (queryIdx != -1)\n        {\n            query = path.substring(queryIdx + 1);\n            path = path.substring(0, queryIdx);\n        }\n\n        URI endpointUri = event.getMessageSourceURI();\n        String host = message.getInboundProperty(\"Host\", endpointUri.getHost());\n        String method = message.getInboundProperty(HttpConnector.HTTP_METHOD_PROPERTY);\n        InBoundHeaders headers = new InBoundHeaders();\n        for (Object prop : message.getInboundPropertyNames())\n        {\n            Object property = message.getInboundProperty(prop.toString());\n            if (property != null)\n            {\n                headers.add(prop.toString(), property.toString());\n            }\n        }\n\n        String scheme;\n        if (\"servlet\".equals(endpointUri.getScheme()))\n        {\n            scheme = \"http\";\n        }\n        else\n        {\n            scheme = endpointUri.getScheme();\n        }\n\n        URI baseUri = getBaseUri(endpointUri, scheme, host, contextPath);\n        URI completeUri = getCompleteUri(endpointUri, scheme, host, path, query);\n        ContainerRequest req = new ContainerRequest(application, method, baseUri, completeUri, headers,\n            getInputStream(message));\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Base URI: \" + baseUri);\n            logger.debug(\"Complete URI: \" + completeUri);\n        }\n\n        MuleResponseWriter writer = new MuleResponseWriter(message);\n        ContainerResponse res = new ContainerResponse(application, req, writer);\n\n        application.handleRequest(req, res);\n\n        return writer.getResponse();\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"private String getHelloWorldMessage () {\n        return \"{\\\"message\\\":\\\"Hello World \\\",\\\"number\\\":0}\";\n    }","id":47619,"modified_method":"private String getHelloWorldMessage()\n    {\n        return \"{\\\"message\\\":\\\"Hello World\\\",\\\"number\\\":0}\";\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testMultipleContextResolver() throws Exception\n    {\n        MuleClient client = muleContext.getClient();\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_GET);\n        MuleMessage result = client.send(\"http://localhost:63081/helloworld/sayHelloWorldWithJson\", \"\", props);\n        assertEquals((Integer)200, result.getInboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 0));\n        assertEquals(getHelloWorldMessage(), result.getPayloadAsString());\n    }","id":47620,"modified_method":"@Test\n    public void supportsMultipleContextResolver() throws Exception\n    {\n        LocalMuleClient client = muleContext.getClient();\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_GET);\n\n        MuleMessage result = client.send(\"http://localhost:\" + port.getNumber() + \"/helloworld/sayHelloWithJson/World\", TEST_MESSAGE, props);\n\n        assertEquals((Integer) HttpConstants.SC_OK, result.getInboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 0));\n        assertEquals(getHelloWorldMessage(), result.getPayloadAsString());\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testBeanBadRequestException() throws Exception\n    {\n        MuleClient client = muleContext.getClient();\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_GET);\n        MuleMessage result = client.send(\"http://localhost:63081/helloworld/throwBadRequestException\", \"\", props);\n        assertEquals((Integer)400, result.getInboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 0));\n\n    }","id":47621,"modified_method":"@Test\n    public void mapsToBeanBadRequestException() throws Exception\n    {\n        LocalMuleClient client = muleContext.getClient();\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_GET);\n\n        MuleMessage result = client.send(\"http://localhost:\" + port.getNumber() + \"/helloworld/throwBadRequestException\", TEST_MESSAGE, props);\n\n        assertEquals((Integer) HttpConstants.SC_BAD_REQUEST, result.getInboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 0));\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testHelloWorlException() throws Exception\n    {\n        MuleClient client = muleContext.getClient();\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_GET);\n        MuleMessage result = client.send(\"http://localhost:63081/helloworld/throwException\", \"\", props);\n        assertEquals( (Integer)503, result.getInboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 0));\n\n    }","id":47622,"modified_method":"@Test\n    public void mapsToHelloWorldException() throws Exception\n    {\n        LocalMuleClient client = muleContext.getClient();\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(HttpConnector.HTTP_METHOD_PROPERTY, HttpConstants.METHOD_GET);\n\n        MuleMessage result = client.send(\"http://localhost:\" + port.getNumber() + \"/helloworld/throwException\", TEST_MESSAGE, props);\n\n        assertEquals((Integer) HttpConstants.SC_SERVICE_UNAVAILABLE, result.getInboundProperty(HttpConnector.HTTP_STATUS_PROPERTY, 0));\n    }","commit_id":"9723cb6cf42be3bb546f5305840990e0c9a30d5c","url":"https://github.com/mulesoft/mule"},{"original_method":"public List<Object> requestSend(int number, String endpoint, Map properties) throws Exception\n    {\n        List<Object> results = new ArrayList<Object>(number);\n        for (int i = 0; i < number; i++)\n        {\n            MuleMessage result = client.send(endpoint, createRequest(), properties);\n            if (result != null)\n            {\n                results.add(result.getPayload());\n            }\n        }\n        return results;\n    }","id":47623,"modified_method":"public List<Object> requestSend(int number, String endpoint, Map properties) throws Exception\n    {\n        List<Object> results = new ArrayList<Object>(number);\n        for (int i = 0; i < number; i++)\n        {\n            MuleMessage result = remoteClient.sendRemote(endpoint, createRequest(), properties);\n            \n            if (result != null)\n            {\n                results.add(result.getPayload());\n            }\n        }\n        return results;\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"public void request(CustomerQuoteRequest request, boolean sync) throws Exception\n    {\n        if (!sync)\n        {\n            client.dispatch(\"CustomerRequests\", request, null);\n            System.out.println(LocaleMessage.sentAsync());\n            // let the request catch up\n            Thread.sleep(3000);\n        }\n        else\n        {\n            MuleMessage result = client.send(\"CustomerRequests\", request, null);\n            if (result == null)\n            {\n                System.out.println(LocaleMessage.requestError());\n            }\n            else\n            {\n                System.out.println(LocaleMessage.requestResponse(result.getPayload()));\n            }\n        }\n    }","id":47624,"modified_method":"public void request(CustomerQuoteRequest request, boolean sync) throws Exception\n    {\n        if (!sync)\n        {\n            remoteClient.dispatchRemote(\"CustomerRequests\", request, null);\n            System.out.println(LocaleMessage.sentAsync());\n            // let the request catch up\n            Thread.sleep(3000);\n            \n        }\n        else\n        {\n            MuleMessage result = remoteClient.sendRemote(\"CustomerRequests\", request, null);\n            if (result == null)\n            {\n                System.out.println(LocaleMessage.requestError());\n            }\n            else\n            {\n                System.out.println(LocaleMessage.requestResponse(result.getPayload()));\n            }\n        }\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void sendRandomRequests(int number, boolean synchronous) throws Exception\n    {\n        if (synchronous)\n        {\n            List<Object> list = requestSend(number, \"CustomerRequests\");\n            int i = 1;\n            for (Iterator<Object> iterator = list.iterator(); iterator.hasNext(); i++)\n            {\n                System.out.println(\n                    LocaleMessage.request(i, iterator.next().toString()));\n            }\n        }\n        else\n        {\n            this.requestDispatch(number, \"CustomerRequests\");\n        }\n    }","id":47625,"modified_method":"protected void sendRandomRequests(int number, boolean synchronous) throws Exception\n    {\n        if (synchronous)\n        {\n            List<Object> list = requestSend(number, \"CustomerRequests\");\n            int i = 1;\n            System.out.println(\"sendRandomRequests\");\n            for (Iterator<Object> iterator = list.iterator(); iterator.hasNext(); i++)\n            {\n                System.out.println(\"sendRandomRequests results :\" +\n                    LocaleMessage.request(i, iterator.next().toString()));\n            }\n        }\n        else\n        {\n            this.requestDispatch(number, \"CustomerRequests\");\n            System.out.println(LocaleMessage.sentAsync());\n        }\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void init() throws Exception\n    {\n        MuleContext muleContext = null;\n        if (config != null)\n        {\n            MuleContextFactory muleContextFactory = new DefaultMuleContextFactory();\n            muleContext = muleContextFactory.createMuleContext(getConfigBuilder());\n            // this is to support running within our test case framework, which\n            // starts the muleContext and with the qa framework which doesn't\n            if(!muleContext.isStarted() && !muleContext.isStarting())\n            {\n                muleContext.start();                \n            }\n        }\n\n        client = new MuleClient(muleContext);\n\n        customers.add(new Customer(\"Jenson Button\", 123));\n        customers.add(new Customer(\"Michael Schumacker\", 456));\n        customers.add(new Customer(\"Juan Pablo Montoya\", 789));\n        customers.add(new Customer(\"David Colthard\", 101));\n        customers.add(new Customer(\"Rubens Barrichello\", 112));\n        customers.add(new Customer(\"Mark Webber\", 131));\n        customers.add(new Customer(\"Takuma Sato\", 415));\n        customers.add(new Customer(\"Kimi Raikkonen\", 161));\n        customers.add(new Customer(\"Ralf Schumacher\", 718));\n        customers.add(new Customer(\"Jarno Trulli\", 192));\n    }","id":47626,"modified_method":"protected void init() throws Exception\n    {\n        MuleClient muleClient = new MuleClient(true);\n        remoteClient = muleClient.getRemoteDispatcher(\"tcp://localhost:5555\");\n        customers.add(new Customer(\"Jenson Button\", 123));\n        customers.add(new Customer(\"Michael Schumacker\", 456));\n        customers.add(new Customer(\"Juan Pablo Montoya\", 789));\n        customers.add(new Customer(\"David Colthard\", 101));\n        customers.add(new Customer(\"Rubens Barrichello\", 112));\n        customers.add(new Customer(\"Mark Webber\", 131));\n        customers.add(new Customer(\"Takuma Sato\", 415));\n        customers.add(new Customer(\"Kimi Raikkonen\", 161));\n        customers.add(new Customer(\"Ralf Schumacher\", 718));\n        customers.add(new Customer(\"Jarno Trulli\", 192));\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"public void requestDispatch(int number, String endpoint) throws Exception\n    {\n        for (int i = 0; i < number; i++)\n        {\n            client.dispatch(endpoint, createRequest(), null);\n        }\n    }","id":47627,"modified_method":"public void requestDispatch(int number, String endpoint) throws Exception\n    {\n        for (int i = 0; i < number; i++)\n        {\n            remoteClient.dispatchRemote(endpoint, createRequest(), null);\n        }\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void dispose() throws Exception\n    {\n        client.dispose();\n    }","id":47628,"modified_method":"protected void dispose() throws Exception\n    {\n        remoteClient.dispose();\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void init() throws Exception\n    {\n        String dbName = MuleDerbyTestUtils.loadDatabaseName(\"derby.properties\", \"database.name\");\n        System.getProperties().put(\"hibernate.dbURL\", \"jdbc:derby:\" + dbName + \";sql.enforce_strict_size=true\");\n        // before initialisation occurs, the database must be cleaned and a new one created\n        MuleDerbyTestUtils.defaultDerbyCleanAndInit(\"derby.properties\", \"database.name\");\n        super.init();\n    }","id":47629,"modified_method":"@Override\n    protected void init() throws Exception\n    {\n        /*\n        String dbName = MuleDerbyTestUtils.loadDatabaseName(\"derby.properties\", \"database.name\");\n        System.getProperties().put(\"hibernate.dbURL\", \"jdbc:derby:\" + dbName + \";sql.enforce_strict_size=true\");\n        // before initialisation occurs, the database must be cleaned and a new one created\n        MuleDerbyTestUtils.defaultDerbyCleanAndInit(\"derby.properties\", \"database.name\");\n        */\n        super.init();\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"public static void main(String[] args) throws Exception\n    {\n        String configFile = \"loan-broker-bpm-mule-config.xml\";\n    \n        if (args != null && args.length > 0 \n            // This is a hack for MULE-4082 which assumes that if the parameter is a \n            // Mule config file, it will contain a \".\" in the name\n            && args[0].contains(\".\"))\n        {\n            configFile = args[0];\n        }\n        LoanBrokerApp loanBrokerApp = new LoanBrokerApp(configFile);\n        loanBrokerApp.run(false);\n    }","id":47630,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        //String configFile = \"loan-broker-bpm-mule-config.xml\";\n    /*\n        if (args != null && args.length > 0 \n            // This is a hack for MULE-4082 which assumes that if the parameter is a \n            // Mule config file, it will contain a \".\" in the name\n            && args[0].contains(\".\"))\n        {\n            configFile = args[0];\n        }\n    */\n        //LoanBrokerApp loanBrokerApp = new LoanBrokerApp(configFile);\n        LoanBrokerApp loanBrokerApp = new LoanBrokerApp();\n        loanBrokerApp.run(false);\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"public LoanBrokerApp(String config) throws Exception\n    {\n        super(config);\n    }","id":47631,"modified_method":"public LoanBrokerApp() throws Exception\n    {\n        super();\n    }","commit_id":"b4ed01d6257bac6f2f6e9227cd0e22fe7704d3bf","url":"https://github.com/mulesoft/mule"},{"original_method":"public ERXJavaScript(String s, NSDictionary nsdictionary, WOElement woelement) {\n\t\tsuper(\"script\", nsdictionary, woelement);\n\t\t_scriptFile = (WOAssociation)_associations.removeObjectForKey(\"scriptFile\");\n\t\t_scriptString = (WOAssociation)_associations.removeObjectForKey(\"scriptString\");\n\t\t_scriptSource = (WOAssociation)_associations.removeObjectForKey(\"scriptSource\");\n\t\t_filename = (WOAssociation)_associations.removeObjectForKey(\"filename\");\n\t\t_language = (WOAssociation)_associations.removeObjectForKey(\"language\");\n\t\t_scriptKey = (WOAssociation)_associations.removeObjectForKey(\"scriptKey\");\n\t\t_hideInComment = (WOAssociation)_associations.removeObjectForKey(\"hideInComment\");\n\t\t_scriptFramework = (WOAssociation) _associations.removeObjectForKey(\"scriptFramework\");\n\t\t_framework = (WOAssociation) _associations.removeObjectForKey(\"framework\");\n\t\t_generateCompleteURLs = (WOAssociation) _associations.removeObjectForKey(\"generateCompleteURLs\");\n\t\tif((_scriptFile != null && _scriptString != null) \n\t\t\t\t|| (_scriptFile != null && (_scriptSource != null || _filename != null)) \n\t\t\t\t|| (_scriptString != null && (_scriptSource != null || _filename != null))) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'scriptString' or 'scriptSource/filename' attributes can be specified.\");\n\t\t}\n\t\tif (_scriptFramework != null && _framework != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFramework' or 'framework' can be specified.\");\n\t\t}\n\t\tif (_scriptSource != null && _filename != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'filename' can be specified.\");\n\t\t}\n\t}","id":47632,"modified_method":"public ERXJavaScript(String s, NSDictionary nsdictionary, WOElement woelement) {\n\t\tsuper(\"script\", nsdictionary, woelement);\n\t\t_scriptFile = (WOAssociation)_associations.removeObjectForKey(\"scriptFile\");\n\t\t_scriptString = (WOAssociation)_associations.removeObjectForKey(\"scriptString\");\n\t\t_scriptSource = (WOAssociation)_associations.removeObjectForKey(\"scriptSource\");\n\t\t_filename = (WOAssociation)_associations.removeObjectForKey(\"filename\");\n\t\t_language = (WOAssociation)_associations.removeObjectForKey(\"language\");\n\t\t_scriptKey = (WOAssociation)_associations.removeObjectForKey(\"scriptKey\");\n\t\t_hideInComment = (WOAssociation)_associations.removeObjectForKey(\"hideInComment\");\n\t\t_scriptFramework = (WOAssociation) _associations.removeObjectForKey(\"scriptFramework\");\n\t\t_framework = (WOAssociation) _associations.removeObjectForKey(\"framework\");\n\t\tif((_scriptFile != null && _scriptString != null) \n\t\t\t\t|| (_scriptFile != null && (_scriptSource != null || _filename != null)) \n\t\t\t\t|| (_scriptString != null && (_scriptSource != null || _filename != null))) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'scriptString' or 'scriptSource/filename' attributes can be specified.\");\n\t\t}\n\t\tif (_scriptFramework != null && _framework != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFramework' or 'framework' can be specified.\");\n\t\t}\n\t\tif (_scriptSource != null && _filename != null) {\n\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> Only one of 'scriptFile' or 'filename' can be specified.\");\n\t\t}\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void appendAttributesToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\tWOComponent wocomponent = wocontext.component();\n\t\tworesponse._appendContentAsciiString(\" type=\\\"text/javascript\\\"\");\n\t\t\n\t\tString framework = null;\n\t\tString scriptName = null;\n\t\t\n\t\tString src = null;\n\t\tif(_scriptSource != null || _filename != null) {\n\t\t\tString srcFromBindings;\n\t\t\tif (_scriptSource != null) {\n\t\t\t\tsrcFromBindings = (String)_scriptSource.valueInComponent(wocomponent);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrcFromBindings = (String) _filename.valueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(srcFromBindings != null) {\n\t\t\t\tif(!WOStaticURLUtilities.isRelativeURL(srcFromBindings)) {\n\t\t\t\t\tsrc = srcFromBindings;\n\t\t\t\t} else {\n\t\t\t\t\tif(!WOStaticURLUtilities.isFragmentURL(srcFromBindings)) {\n\t\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscriptName = srcFromBindings;\n\t\t\t\t\t\tsrc = wocontext._urlForResourceNamed(srcFromBindings, framework, true);\n\t\t\t\t\t\tif(src == null) {\n\t\t\t\t\t\t\tsrc = wocomponent.baseURL() + \"/\" + srcFromBindings;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_generateCompleteURLs != null && _generateCompleteURLs.booleanValueInComponent(wocomponent) && ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\t\tsrc = ERXResourceManager._completeURLForResource(src, wocontext);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn(\"relative fragment URL\" + srcFromBindings);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tObject key = null;\n\t\tif(src == null && _scriptKey != null) {\n\t\t\tkey = _scriptKey.valueInComponent(wocomponent);\n\t\t\tif(key != null) {\n\t\t\t\tERXExpiringCache<Object, WOResponse> cache = ERXJavaScript.cache(wocontext.session());\n\t\t\t\tboolean render = cache.isStale(key);\n\t\t\t\trender |= ERXApplication.isDevelopmentModeSafe();\n\t\t\t\tif(render) {\n\t\t\t\t\tWOResponse newresponse = new WOResponse();\n\t\t\t\t\tsuper.appendChildrenToResponse(newresponse, wocontext);\n\t\t\t\t\tnewresponse.setHeader(\"application/x-javascript\", \"content-type\");\n\t\t\t\t\tcache.setObjectForKey(newresponse, key);\n\t\t\t\t}\n\t\t\t\tsrc = wocontext.directActionURLForActionNamed(Script.class.getName() + \"/\" + key, null);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(src != null) {\n\t\t\tworesponse._appendContentAsciiString(\" src=\\\"\");\n\t\t\tworesponse.appendContentString(src);\n\t\t\tworesponse.appendContentCharacter('\"');\n\t\t}\n\t\t\n\t\tsuper.appendAttributesToResponse(woresponse, wocontext);\n\t\t\n\t\tif (scriptName != null) {\n\t\t\tERXResponseRewriter.resourceAddedToHead(wocontext, framework, scriptName);\n\t\t}\n\t}","id":47633,"modified_method":"@Override\n\tpublic void appendAttributesToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\tWOComponent wocomponent = wocontext.component();\n\t\tworesponse._appendContentAsciiString(\" type=\\\"text/javascript\\\"\");\n\t\t\n\t\tString framework = null;\n\t\tString scriptName = null;\n\t\t\n\t\tString src = null;\n\t\tif(_scriptSource != null || _filename != null) {\n\t\t\tString srcFromBindings;\n\t\t\tif (_scriptSource != null) {\n\t\t\t\tsrcFromBindings = (String)_scriptSource.valueInComponent(wocomponent);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrcFromBindings = (String) _filename.valueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(srcFromBindings != null) {\n\t\t\t\tif(!WOStaticURLUtilities.isRelativeURL(srcFromBindings)) {\n\t\t\t\t\tsrc = srcFromBindings;\n\t\t\t\t} else {\n\t\t\t\t\tif(!WOStaticURLUtilities.isFragmentURL(srcFromBindings)) {\n\t\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscriptName = srcFromBindings;\n\t\t\t\t\t\tsrc = wocontext._urlForResourceNamed(srcFromBindings, framework, true);\n\t\t\t\t\t\tif(src == null) {\n\t\t\t\t\t\t\tsrc = wocomponent.baseURL() + \"/\" + srcFromBindings;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\t\tsrc = ERXResourceManager._completeURLForResource(src, null, wocontext);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.warn(\"relative fragment URL\" + srcFromBindings);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tObject key = null;\n\t\tif(src == null && _scriptKey != null) {\n\t\t\tkey = _scriptKey.valueInComponent(wocomponent);\n\t\t\tif(key != null) {\n\t\t\t\tERXExpiringCache<Object, WOResponse> cache = ERXJavaScript.cache(wocontext.session());\n\t\t\t\tboolean render = cache.isStale(key);\n\t\t\t\trender |= ERXApplication.isDevelopmentModeSafe();\n\t\t\t\tif(render) {\n\t\t\t\t\tWOResponse newresponse = new WOResponse();\n\t\t\t\t\tsuper.appendChildrenToResponse(newresponse, wocontext);\n\t\t\t\t\tnewresponse.setHeader(\"application/x-javascript\", \"content-type\");\n\t\t\t\t\tcache.setObjectForKey(newresponse, key);\n\t\t\t\t}\n\t\t\t\tsrc = wocontext.directActionURLForActionNamed(Script.class.getName() + \"/\" + key, null);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(src != null) {\n\t\t\tworesponse._appendContentAsciiString(\" src=\\\"\");\n\t\t\tworesponse.appendContentString(src);\n\t\t\tworesponse.appendContentCharacter('\"');\n\t\t}\n\t\t\n\t\tsuper.appendAttributesToResponse(woresponse, wocontext);\n\t\t\n\t\tif (scriptName != null) {\n\t\t\tERXResponseRewriter.resourceAddedToHead(wocontext, framework, scriptName);\n\t\t}\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void appendChildrenToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\t\tString script = \"\";\n\t\t\tboolean hideInComment = true;\n\t\t\tWOComponent wocomponent = wocontext.component();\n\t\t\tif(_hideInComment != null) {\n\t\t\t\thideInComment = _hideInComment.booleanValueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"<!--\");\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(_scriptFile != null) {\n\t\t\t\tString filename = (String) _scriptFile.valueInComponent(wocomponent);\n\t\t\t\tif(filename != null) {\n\t\t\t\t\tString framework = null;\n\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\tjava.net.URL url = WOApplication.application().resourceManager().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\turl = wocontext.component()._componentDefinition().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\t}\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : cannot find script file '\" + filename + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tscript = _NSStringUtilities.stringFromPathURL(url);\n\t\t\t\t\tif (_generateCompleteURLs != null && _generateCompleteURLs.booleanValueInComponent(wocomponent) && ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\tscript = ERXResourceManager._completeURLForResource(script, wocontext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else if(_scriptString != null) {\n\t\t\t\tObject obj1 = _scriptString.valueInComponent(wocomponent);\n\t\t\t\tif(obj1 != null) {\n\t\t\t\t\tscript = obj1.toString();\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else {\n\t\t\t\tsuper.appendChildrenToResponse(woresponse, wocontext);\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"//-->\");\n\t\t\t}\n\t}","id":47634,"modified_method":"@Override\n\tpublic void appendChildrenToResponse(WOResponse woresponse, WOContext wocontext) {\n\t\t\tString script = \"\";\n\t\t\tboolean hideInComment = true;\n\t\t\tWOComponent wocomponent = wocontext.component();\n\t\t\tif(_hideInComment != null) {\n\t\t\t\thideInComment = _hideInComment.booleanValueInComponent(wocomponent);\n\t\t\t}\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"<!--\");\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(_scriptFile != null) {\n\t\t\t\tString filename = (String) _scriptFile.valueInComponent(wocomponent);\n\t\t\t\tif(filename != null) {\n\t\t\t\t\tString framework = null;\n\t\t\t\t\tif(_scriptFramework != null) {\n\t\t\t\t\t\tframework = (String) _scriptFramework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (_framework != null) {\n\t\t\t\t\t\tframework = (String) _framework.valueInComponent(wocomponent);\n\t\t\t\t\t}\n\t\t\t\t\tjava.net.URL url = WOApplication.application().resourceManager().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\turl = wocontext.component()._componentDefinition().pathURLForResourceNamed(filename, framework, wocontext._languages());\n\t\t\t\t\t}\n\t\t\t\t\tif(url == null) {\n\t\t\t\t\t\tthrow new WODynamicElementCreationException(\"<\" + getClass().getName() + \"> : cannot find script file '\" + filename + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tscript = _NSStringUtilities.stringFromPathURL(url);\n\t\t\t\t\tif (ERXResourceManager._shouldGenerateCompleteResourceURL(wocontext)) {\n\t\t\t\t\t\tscript = ERXResourceManager._completeURLForResource(script, null, wocontext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else if(_scriptString != null) {\n\t\t\t\tObject obj1 = _scriptString.valueInComponent(wocomponent);\n\t\t\t\tif(obj1 != null) {\n\t\t\t\t\tscript = obj1.toString();\n\t\t\t\t}\n\t\t\t\tworesponse.appendContentString(script);\n\t\t\t} else {\n\t\t\t\tsuper.appendChildrenToResponse(woresponse, wocontext);\n\t\t\t}\n\t\t\tworesponse.appendContentCharacter('\\n');\n\t\t\tif(hideInComment) {\n\t\t\t\tworesponse._appendContentAsciiString(\"//-->\");\n\t\t\t}\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns whether or not complete resource URLs should be generated.\n\t * @param context the context\n\t * @return whether or not complete resource URLs should be generated\n\t */\n\tpublic static boolean _shouldGenerateCompleteResourceURL(WOContext context) {\n\t\treturn ((ERXWOContext)context)._generatingCompleteURLs() && !ERXApplication.erxApplication().rewriteDirectConnectURL();\n\t}","id":47635,"modified_method":"/**\n\t * Returns whether or not complete resource URLs should be generated.\n\t * @param context the context\n\t * @return whether or not complete resource URLs should be generated\n\t */\n\tpublic static boolean _shouldGenerateCompleteResourceURL(WOContext context) {\n\t\treturn context instanceof ERXWOContext && ((ERXWOContext)context)._generatingCompleteResourceURLs() && !ERXApplication.erxApplication().rewriteDirectConnectURL();\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns a fully qualified URL for the given partial resource URL (i.e. turns /whatever into http://server/whatever). \n\t * @param url the partial resource URL\n\t * @param context the current context\n\t * @return the complete URL\n\t */\n\tpublic static String _completeURLForResource(String url, WOContext context) {\n\t\tString completeUrl;\n\t\tboolean secure = ERXRequest.isRequestSecure(context.request());\n\t\tif ((secure && ERXProperties.stringForKey(\"er.extensions.ERXResourceManager.secureResourceUrlPrefix\") == null) || (!secure && ERXProperties.stringForKey(\"er.extensions.ERXResourceManager.resourceUrlPrefix\") == null)) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tString serverPortStr = context.request()._serverPort();\n\t\t\tint serverPort = (serverPortStr == null) ? 0 : Integer.parseInt(serverPortStr); \n\t\t\t((ERXRequest) context.request())._completeURLPrefix(sb, secure, serverPort);\n\t\t\tsb.append(url);\n\t\t\tcompleteUrl = sb.toString();\n\t\t}\n\t\telse {\n\t\t\tcompleteUrl = url;\n\t\t}\n\t\treturn completeUrl;\n\t}","id":47636,"modified_method":"/**\n\t * Returns a fully qualified URL for the given partial resource URL (i.e. turns /whatever into http://server/whatever). \n\t * @param url the partial resource URL\n\t * @param secure whether or not to generate a secure URL\n\t * @param context the current context\n\t * @return the complete URL\n\t */\n\tpublic static String _completeURLForResource(String url, Boolean secure, WOContext context) {\n\t\tString completeUrl;\n\t\tboolean requestIsSecure = ERXRequest.isRequestSecure(context.request());\n\t\tboolean resourceIsSecure = (secure == null) ? requestIsSecure : secure.booleanValue();\n\t\tif ((resourceIsSecure && ERXProperties.stringForKey(\"er.extensions.ERXResourceManager.secureResourceUrlPrefix\") == null) || (!resourceIsSecure && ERXProperties.stringForKey(\"er.extensions.ERXResourceManager.resourceUrlPrefix\") == null)) {\n\t\t\tStringBuffer sb = new StringBuffer();\n      String serverPortStr = context.request()._serverPort();\n      int serverPort = (serverPortStr == null) ? 0 : Integer.parseInt(serverPortStr);\n\t\t\tcontext.request()._completeURLPrefix(sb, resourceIsSecure, serverPort);\n\t\t\tsb.append(url);\n\t\t\tcompleteUrl = sb.toString();\n\t\t}\n\t\telse {\n\t\t\tcompleteUrl = url;\n\t\t}\n\t\treturn completeUrl;\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Adds a reference to an arbitrary file with a correct resource url wrapped\n\t * between startTag and endTag in the html head tag if it isn't already\n\t * present in the response.\n\t * \n\t * @param response\n\t * @param context \n\t * @param framework \n\t * @param fileName\n\t * @param startTag\n\t * @param endTag\n\t * @param fallbackStartTag\n\t * @param fallbackEndTag\n\t * @param tagMissingBehavior\n\t * \n\t * @return whether or not the content was added\n\t */\n\tpublic static boolean addResourceInHead(WOResponse response, WOContext context, String framework, String fileName, String startTag, String endTag, String fallbackStartTag, String fallbackEndTag, TagMissingBehavior tagMissingBehavior) {\n\t\tboolean inserted = true;\n\t\t\n\t\tString replacementResourceStr = ERXProperties.stringForKey(\"er.extensions.ERXResponseRewriter.resource.\" + framework + \".\" + fileName);\n\t\tif (replacementResourceStr != null) {\n\t\t\tint dotIndex = replacementResourceStr.indexOf('.');\n\t\t\tframework = replacementResourceStr.substring(0, dotIndex);\n\t\t\tfileName = replacementResourceStr.substring(dotIndex + 1);\n\t\t}\n\t\t\n\t\tif (!ERXResponseRewriter.isResourceAddedToHead(context, framework, fileName) && (_delagate == null || _delagate.responseRewriterShouldAddResource(framework, fileName))) {\n\t\t\tboolean insert = true;\n\t\t\t\n\t\t\tif (_delagate != null) {\n\t\t\t\tResource replacementResource = _delagate.responseRewriterWillAddResource(framework, fileName);\n\t\t\t\tif (replacementResource != null) {\n\t\t\t\t\tframework = replacementResource.framework();\n\t\t\t\t\tfileName = replacementResource.fileName();\n\t\t\t\t\t\n\t\t\t\t\t// double-check that the replacement hasn't already been added\n\t\t\t\t\tif (ERXResponseRewriter.isResourceAddedToHead(context, framework, fileName)) {\n\t\t\t\t\t\tinsert = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (insert) {\n\t\t\t\tString url;\n\t\t\t\tif (fileName.indexOf(\"://\") != -1 || fileName.startsWith(\"/\")) {\n\t\t\t\t\turl = fileName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tWOResourceManager rm = WOApplication.application().resourceManager();\n\t\t\t\t\tNSArray languages = null;\n\t\t\t\t\tif (context.hasSession()) {\n\t\t\t\t\t\tlanguages = context.session().languages();\n\t\t\t\t\t}\n\t\t\t\t\turl = rm.urlForResourceNamed(fileName, framework, languages, context.request());\n\t\t\t\t\tif (ERXProperties.stringForKey(ERXResponseRewriter.SECURE_RESOURCES_KEY) != null) {\n\t\t\t\t\t\tStringBuffer urlBuffer = new StringBuffer();\n\t\t\t\t\t\tcontext.request()._completeURLPrefix(urlBuffer, ERXProperties.booleanForKey(ERXResponseRewriter.SECURE_RESOURCES_KEY), 0);\n\t\t\t\t\t\turlBuffer.append(url);\n\t\t\t\t\t\turl = urlBuffer.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString html = startTag + url + endTag + \"\\n\";\n\t\t\t\tif (fallbackStartTag == null && fallbackEndTag == null) {\n\t\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeHead(response, context, html, tagMissingBehavior);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeHead(response, context, html, TagMissingBehavior.Skip);\n\t\t\t\t\tif (!inserted) {\n\t\t\t\t\t\tString fallbackHtml = fallbackStartTag + url + fallbackEndTag + \"\\n\";\n\t\t\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeTag(response, context, fallbackHtml, null, TagMissingBehavior.Top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inserted) {\n\t\t\t\t\tERXResponseRewriter.resourceAddedToHead(context, framework, fileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn inserted;\n\t}","id":47637,"modified_method":"/**\n\t * Adds a reference to an arbitrary file with a correct resource url wrapped\n\t * between startTag and endTag in the html head tag if it isn't already\n\t * present in the response.\n\t * \n\t * @param response\n\t * @param context \n\t * @param framework \n\t * @param fileName\n\t * @param startTag\n\t * @param endTag\n\t * @param fallbackStartTag\n\t * @param fallbackEndTag\n\t * @param tagMissingBehavior\n\t * \n\t * @return whether or not the content was added\n\t */\n\tpublic static boolean addResourceInHead(WOResponse response, WOContext context, String framework, String fileName, String startTag, String endTag, String fallbackStartTag, String fallbackEndTag, TagMissingBehavior tagMissingBehavior) {\n\t\tboolean inserted = true;\n\t\t\n\t\tString replacementResourceStr = ERXProperties.stringForKey(\"er.extensions.ERXResponseRewriter.resource.\" + framework + \".\" + fileName);\n\t\tif (replacementResourceStr != null) {\n\t\t\tint dotIndex = replacementResourceStr.indexOf('.');\n\t\t\tframework = replacementResourceStr.substring(0, dotIndex);\n\t\t\tfileName = replacementResourceStr.substring(dotIndex + 1);\n\t\t}\n\t\t\n\t\tif (!ERXResponseRewriter.isResourceAddedToHead(context, framework, fileName) && (_delagate == null || _delagate.responseRewriterShouldAddResource(framework, fileName))) {\n\t\t\tboolean insert = true;\n\t\t\t\n\t\t\tif (_delagate != null) {\n\t\t\t\tResource replacementResource = _delagate.responseRewriterWillAddResource(framework, fileName);\n\t\t\t\tif (replacementResource != null) {\n\t\t\t\t\tframework = replacementResource.framework();\n\t\t\t\t\tfileName = replacementResource.fileName();\n\t\t\t\t\t\n\t\t\t\t\t// double-check that the replacement hasn't already been added\n\t\t\t\t\tif (ERXResponseRewriter.isResourceAddedToHead(context, framework, fileName)) {\n\t\t\t\t\t\tinsert = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (insert) {\n\t\t\t\tString url;\n\t\t\t\tif (fileName.indexOf(\"://\") != -1 || fileName.startsWith(\"/\")) {\n\t\t\t\t\turl = fileName;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tWOResourceManager rm = WOApplication.application().resourceManager();\n\t\t\t\t\tNSArray languages = null;\n\t\t\t\t\tif (context.hasSession()) {\n\t\t\t\t\t\tlanguages = context.session().languages();\n\t\t\t\t\t}\n\t\t\t\t\turl = rm.urlForResourceNamed(fileName, framework, languages, context.request());\n\t\t\t\t\tboolean generateCompleteResourceURLs = ERXResourceManager._shouldGenerateCompleteResourceURL(context);\n\t\t\t\t\tboolean secureAllResources = ERXProperties.booleanForKey(ERXResponseRewriter.SECURE_RESOURCES_KEY) && !ERXRequest.isRequestSecure(context.request());\n\t\t\t\t\tif (generateCompleteResourceURLs || secureAllResources) {\n\t\t\t\t\t\turl = ERXResourceManager._completeURLForResource(url, secureAllResources ? Boolean.TRUE : null, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString html = startTag + url + endTag + \"\\n\";\n\t\t\t\tif (fallbackStartTag == null && fallbackEndTag == null) {\n\t\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeHead(response, context, html, tagMissingBehavior);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeHead(response, context, html, TagMissingBehavior.Skip);\n\t\t\t\t\tif (!inserted) {\n\t\t\t\t\t\tString fallbackHtml = fallbackStartTag + url + fallbackEndTag + \"\\n\";\n\t\t\t\t\t\tinserted = ERXResponseRewriter.insertInResponseBeforeTag(response, context, fallbackHtml, null, TagMissingBehavior.Top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inserted) {\n\t\t\t\t\tERXResponseRewriter.resourceAddedToHead(context, framework, fileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn inserted;\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * returns the complete url to the style sheet.\n\t * \n\t * @return style sheet url\n\t */\n\tpublic String styleSheetUrl() {\n\t\tString url = (String) valueForBinding(\"styleSheetUrl\");\n\t\turl = (url == null ? (String) valueForBinding(\"href\") : url);\n\t\tif (url == null) {\n\t\t\tString name = styleSheetName();\n\t\t\tif (name != null) {\n\t\t\t\turl = application().resourceManager().urlForResourceNamed(styleSheetName(), styleSheetFrameworkName(), languages(), context().request());\n\t\t\t\tif (booleanValueForBinding(\"generateCompleteURLs\") && ERXResourceManager._shouldGenerateCompleteResourceURL(context())) {\n\t\t\t\t\turl = ERXResourceManager._completeURLForResource(url, context());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"ERXStyleSheet.styleSheetUrl: \" + url);\n\t\treturn url;\n\t}","id":47638,"modified_method":"/**\n\t * returns the complete url to the style sheet.\n\t * \n\t * @return style sheet url\n\t */\n\tpublic String styleSheetUrl() {\n\t\tString url = (String) valueForBinding(\"styleSheetUrl\");\n\t\turl = (url == null ? (String) valueForBinding(\"href\") : url);\n\t\tif (url == null) {\n\t\t\tString name = styleSheetName();\n\t\t\tif (name != null) {\n\t\t\t\turl = application().resourceManager().urlForResourceNamed(styleSheetName(), styleSheetFrameworkName(), languages(), context().request());\n\t\t\t\tif (ERXResourceManager._shouldGenerateCompleteResourceURL(context())) {\n\t\t\t\t\turl = ERXResourceManager._completeURLForResource(url, null, context());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn url;\n\t}","commit_id":"71518cbddddec5d0dc17fcb1d857ab5801f370bc","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void startNode() {\n        startNode(\"plugin-test-node\", ImmutableSettings.settingsBuilder()\n                .put(\"discovery.zen.ping.multicast.enabled\", false)\n                .put(\"path.plugins\", PLUGIN_DIR));\n    }","id":47639,"modified_method":"private void startNode() {\n        startNode(NODE_NAME, ImmutableSettings.settingsBuilder()\n                .put(\"discovery.zen.ping.multicast.enabled\", false)\n                /*.put(\"path.plugins\", PLUGIN_DIR)*/);\n    }","commit_id":"73a7b06d21ad9790e5e4eed551f0f88d5fa7c8c6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void assertPluginAvailable(String pluginName) {\n        HttpClient httpClient = new HttpClient(\"http://127.0.0.1:9200/\");\n        HttpClientResponse response = httpClient.request(\"_plugin/\" + pluginName + \"/\");\n        assertThat(response.errorCode(), Matchers.equalTo(RestStatus.OK.getStatus()));\n    }","id":47640,"modified_method":"private void assertPluginAvailable(String pluginName) {\n        HttpClient httpClient = new HttpClient(\"http://127.0.0.1:9200/\");\n        //checking that the http connector is working properly\n        HttpClientResponse response = httpClient.request(\"\");\n        assertThat(response.errorCode(), equalTo(RestStatus.OK.getStatus()));\n        assertThat(response.response(), containsString(NODE_NAME));\n        //checking now that the plugin is available\n        response = httpClient.request(\"_plugin/\" + pluginName + \"/\");\n        assertThat(response.errorCode(), equalTo(RestStatus.OK.getStatus()));\n    }","commit_id":"73a7b06d21ad9790e5e4eed551f0f88d5fa7c8c6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void downloadAndExtract(String pluginName, String pluginUrl) throws Exception {\n        Tuple<Settings, Environment> initialSettings = InternalSettingsPerparer.prepareSettings(\n                ImmutableSettings.settingsBuilder().put(\"path.plugins\", PLUGIN_DIR).build(), false);\n        if (!initialSettings.v2().pluginsFile().exists()) {\n            FileSystemUtils.mkdirs(initialSettings.v2().pluginsFile());\n        }\n        PluginManager pluginManager = new PluginManager(initialSettings.v2(), pluginUrl);\n        pluginManager.downloadAndExtract(pluginName, false);\n    }","id":47641,"modified_method":"private static void downloadAndExtract(String pluginName, String pluginUrl) throws Exception {\n        Tuple<Settings, Environment> initialSettings = InternalSettingsPerparer.prepareSettings(\n                ImmutableSettings.settingsBuilder()/*.put(\"path.plugins\", PLUGIN_DIR)*/.build(), false);\n        if (!initialSettings.v2().pluginsFile().exists()) {\n            FileSystemUtils.mkdirs(initialSettings.v2().pluginsFile());\n        }\n        PluginManager pluginManager = new PluginManager(initialSettings.v2(), pluginUrl);\n        pluginManager.downloadAndExtract(pluginName, false);\n    }","commit_id":"73a7b06d21ad9790e5e4eed551f0f88d5fa7c8c6","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public SolrCloudFixture(String solrHome) throws Exception {\n\n\t\t// String testHome = SolrTestCaseJ4.TEST_HOME();\n\t\t// miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, new\n\t\t// File(testHome, \"solr-no-core.xml\"),\n\t\t// null, null);\n\t\tminiCluster = new MiniSolrCloudCluster(1, \"/solr\", new File(solrHome,\n\t\t\t\t\"solr-no-core.xml\"), null, null);\n\t\tString zkAddr = miniCluster.getZkServer().getZkAddress();\n\t\tString zkHost = miniCluster.getZkServer().getZkHost();\n\n\t\tbuildZooKeeper(zkHost, zkAddr, new File(solrHome), \"solrconfig.xml\",\n\t\t\t\t\"schema.xml\");\n\t\tList<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n\t\tfor (JettySolrRunner jetty : jettys) {\n\t\t\tif (!jetty.isRunning()) {\n\t\t\t\tSystem.out.println(\"JETTY NOT RUNNING!\");\n\t\t\t} else {\n\t\t\t\t// jetty.stop();\n\t\t\t\t// jetty.start();\n\t\t\t\tSystem.out.println(\"JETTY RUNNING\");\n\t\t\t\tSystem.out.println(\"AT:  \" + jetty.getBaseUrl());\n\t\t\t\tSystem.out.println(\"PORTT\" + jetty.getLocalPort());\n\t\t\t}\n\t\t}\n\n\t\tsolrClient = new CloudSolrServer(zkAddr, true);\n\t\tsolrClient.connect();\n\n\t\tcreateCollection(solrClient, \"collection1\", 1, 1, \"conf1\");\n\t\tsolrClient.setDefaultCollection(\"collection1\");\n\n\t\tSolrInputDocument doc = new SolrInputDocument();\n\t\tdoc.setField(\"id\", \"1\");\n\n\t\tsolrClient.add(doc);\n\t\tsolrClient.commit();\n\t}","id":47642,"modified_method":"public SolrCloudFixture(String solrHome) throws Exception {\n\n\t\t// String testHome = SolrTestCaseJ4.TEST_HOME();\n\t\t// miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, new\n\t\t// File(testHome, \"solr-no-core.xml\"),\n\t\t// null, null);\n\t\tminiCluster = new MiniSolrCloudCluster(1, \"/solr\", new File(solrHome,\n\t\t\t\t\"solr-no-core.xml\"), null, null);\n\t\tString zkAddr = miniCluster.getZkServer().getZkAddress();\n\t\tString zkHost = miniCluster.getZkServer().getZkHost();\n\n\t\tbuildZooKeeper(zkHost, zkAddr, new File(solrHome), \"solrconfig.xml\",\n\t\t\t\t\"schema.xml\");\n\t\tList<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n\t\tfor (JettySolrRunner jetty : jettys) {\n\t\t\tif (!jetty.isRunning()) {\n\t\t\t\tSystem.out.println(\"JETTY NOT RUNNING!\");\n\t\t\t} else {\n\t\t\t\t// jetty.stop();\n\t\t\t\t// jetty.start();\n\t\t\t\tSystem.out.println(\"JETTY RUNNING\");\n\t\t\t\tSystem.out.println(\"AT:  \" + jetty.getBaseUrl());\n\t\t\t\tSystem.out.println(\"PORTT\" + jetty.getLocalPort());\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tsolrClient = new CloudSolrServer(zkAddr, true);\n\t\tsolrClient.connect();\n\n\t\tcreateCollection(solrClient, \"collection1\", 1, 1, \"conf1\");\n\t\tThread.sleep(1000); // takes some time to setup the collection... otherwise you'll get no live solr servers\t\t\n\t\tsolrClient.setDefaultCollection(\"collection1\");\n\n\t\tSolrInputDocument doc = new SolrInputDocument();\n\t\tdoc.setField(\"id\", \"1\");\n\n\t\tsolrClient.add(doc);\n\t\tsolrClient.commit();\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"public void teardown() {\n\t\tSystem.clearProperty(\"zkHost\");\n\t\tSystem.clearProperty(\"solr.test.sys.prop1\");\n\t\tSystem.clearProperty(\"solr.test.sys.prop2\");\n\t\tSystem.clearProperty(\"solrcloud.skip.autorecovery\");\n\t\tSystem.clearProperty(\"jetty.port\");\n\n\t}","id":47643,"modified_method":"public void teardown() throws Exception {\n\t\tsolrClient.shutdown();\n\t\tminiCluster.shutdown();\n\t\t\n\t\tsolrClient = null;\n\t\tminiCluster = null;\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"void shutdownServers(SolrServerReference ref, boolean remove) {\n        try {\n            if (ref.getSolrServer() != null) {\n                LOG.info(\"Shutting down solr server: {}\", ref.getSolrServer());\n                ref.getSolrServer().shutdown();\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error shutting down solr server. This exception is ignored.\", e);\n        }\n        try {\n            if (ref.getUpdateSolrServer() != null) {\n                LOG.info(\"Shutting down update solr server: {}\", ref.getUpdateSolrServer());\n                ref.getUpdateSolrServer().shutdownNow();\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Error shutting down streaming solr server. This exception is ignored.\", e);\n        }\n\n        if (remove) {\n            SolrEndpoint key = null;\n            for (Map.Entry<SolrEndpoint, SolrServerReference> entry : servers.entrySet()) {\n                if (entry.getValue() == ref) {\n                    key = entry.getKey();\n                    break;\n                }\n            }\n            if (key != null) {\n                servers.remove(key);\n            }\n        }\n\n    }","id":47644,"modified_method":"void shutdownServers(SolrServerReference ref, boolean remove) {\n        try {\n            shutdownServer(ref.getSolrServer());\n        } catch (Exception e) {\n            LOG.warn(\"Error shutting down solr server. This exception is ignored.\", e);\n        }\n        try {\n            shutdownServer(ref.getUpdateSolrServer());\n        } catch (Exception e) {\n            LOG.warn(\"Error shutting down streaming solr server. This exception is ignored.\", e);\n        }\n        \n        try {\n            shutdownServer(ref.getCloudSolrServer());\n        } catch (Exception e) {\n            LOG.warn(\"Error shutting down streaming solr server. This exception is ignored.\", e);\n        }\n\n        if (remove) {\n            SolrEndpoint key = null;\n            for (Map.Entry<SolrEndpoint, SolrServerReference> entry : servers.entrySet()) {\n                if (entry.getValue() == ref) {\n                    key = entry.getKey();\n                    break;\n                }\n            }\n            if (key != null) {\n                servers.remove(key);\n            }\n        }\n\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"@Parameters\n    public static Collection<Object[]> serverTypes() {\n    \tObject[][] serverTypes = {{true}, {false}};\n    \treturn Arrays.asList(serverTypes);\n    }","id":47645,"modified_method":"@Parameters\n    public static Collection<Object[]> serverTypes() {\n    \tObject[][] serverTypes = {{SolrFixtures.TestServerType.USE_CLOUD},\n    \t\t\t\t\t\t\t  {SolrFixtures.TestServerType.USE_HTTPS},\n    \t\t\t\t\t\t\t  {SolrFixtures.TestServerType.USE_HTTP}};\n    \treturn Arrays.asList(serverTypes);\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"public SolrComponentTestSupport(Boolean useHttps) {\n    \tthis.solrFixtures = new SolrFixtures(useHttps);\n    }","id":47646,"modified_method":"public SolrComponentTestSupport(SolrFixtures.TestServerType serverToTest) {\n    \tthis.solrFixtures = new SolrFixtures(serverToTest);\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Producer createProducer() throws Exception {\n        // do we have servers?\n        SolrComponent.SolrServerReference ref = getComponent().getSolrServers(this);\n        if (ref == null) {\n\n            // no then create new servers\n            HttpSolrServer solrServer = new HttpSolrServer(url);\n            ConcurrentUpdateSolrServer solrStreamingServer = new ConcurrentUpdateSolrServer(url, streamingQueueSize, streamingThreadCount);\n\n            // set the properties on the solr server\n            if (maxRetries != null) {\n                solrServer.setMaxRetries(maxRetries);\n            }\n            if (soTimeout != null) {\n                solrServer.setSoTimeout(soTimeout);\n            }\n            if (connectionTimeout != null) {\n                solrServer.setConnectionTimeout(connectionTimeout);\n            }\n            if (defaultMaxConnectionsPerHost != null) {\n                solrServer.setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n            }\n            if (maxTotalConnections != null) {\n                solrServer.setMaxTotalConnections(maxTotalConnections);\n            }\n            if (followRedirects != null) {\n                solrServer.setFollowRedirects(followRedirects);\n            }\n            if (allowCompression != null) {\n                solrServer.setAllowCompression(allowCompression);\n            }\n\n            ref = new SolrComponent.SolrServerReference();\n            ref.setSolrServer(solrServer);\n            ref.setUpdateSolrServer(solrStreamingServer);\n\n            getComponent().addSolrServers(this, ref);\n        }\n\n        ref.addReference();\n        return new SolrProducer(this, ref.getSolrServer(), ref.getUpdateSolrServer());\n    }","id":47647,"modified_method":"@Override\n    public Producer createProducer() throws Exception {\n        // do we have servers?\n        SolrComponent.SolrServerReference ref = getComponent().getSolrServers(this);\n        if (ref == null) {\n            // no then create new servers\n            ref = new SolrComponent.SolrServerReference();\n        \tCloudSolrServer cloudServer = getCloudServer();\n        \tif (cloudServer == null) {\n\t            HttpSolrServer solrServer = new HttpSolrServer(url);\n\t            ConcurrentUpdateSolrServer solrStreamingServer = new ConcurrentUpdateSolrServer(url, streamingQueueSize, streamingThreadCount);\n\t\n\t            // set the properties on the solr server\n\t            if (maxRetries != null) {\n\t                solrServer.setMaxRetries(maxRetries);\n\t            }\n\t            if (soTimeout != null) {\n\t                solrServer.setSoTimeout(soTimeout);\n\t            }\n\t            if (connectionTimeout != null) {\n\t                solrServer.setConnectionTimeout(connectionTimeout);\n\t            }\n\t            if (defaultMaxConnectionsPerHost != null) {\n\t                solrServer.setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n\t            }\n\t            if (maxTotalConnections != null) {\n\t                solrServer.setMaxTotalConnections(maxTotalConnections);\n\t            }\n\t            if (followRedirects != null) {\n\t                solrServer.setFollowRedirects(followRedirects);\n\t            }\n\t            if (allowCompression != null) {\n\t                solrServer.setAllowCompression(allowCompression);\n\t            }\n\t            ref.setSolrServer(solrServer);\n\t            ref.setUpdateSolrServer(solrStreamingServer);\n        \t}\n            ref.setCloudSolrServer(cloudServer);\n\n            getComponent().addSolrServers(this, ref);\n        }\n\n        ref.addReference();\n        return new SolrProducer(this, ref.getSolrServer(), ref.getUpdateSolrServer(), ref.getCloudSolrServer());\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"static void createSolrFixtures() throws Exception {\n    \tsolrHttpsRunner = JettySolrFactory.createJettyTestFixture(true);\n    \thttpsPort = solrHttpsRunner.getLocalPort();\n    \tlog.info(\"Started Https Test Server: \" + solrHttpsRunner.getBaseUrl());    \t\n    \tsolrHttpsServer = new HttpSolrServer(\"https://localhost:\" + httpsPort + \"/solr\");\n        solrHttpsServer.setConnectionTimeout(60000);\n        \n       // solrHttpsServer.deleteByQuery(\"*:*\");\n        \n    \tsolrRunner = JettySolrFactory.createJettyTestFixture(false);\n    \tport = solrRunner.getLocalPort();\n    \t\n    \tsolrServer = new HttpSolrServer(\"http://localhost:\" + port + \"/solr\");\n    \t\n    \tlog.info(\"Started Test Server: \" + solrRunner.getBaseUrl());\n    \t\n    \t//cloudFixture = new SolrCloudFixture(\"src/test/resources/solr\");\n\n    }","id":47648,"modified_method":"static void createSolrFixtures() throws Exception {\n\t\tsolrHttpsRunner = JettySolrFactory.createJettyTestFixture(true);\n\t\thttpsPort = solrHttpsRunner.getLocalPort();\n\t\tlog.info(\"Started Https Test Server: \" + solrHttpsRunner.getBaseUrl());\n\t\tsolrHttpsServer = new HttpSolrServer(\"https://localhost:\" + httpsPort\n\t\t\t\t+ \"/solr\");\n\t\tsolrHttpsServer.setConnectionTimeout(60000);\n\n\t\tsolrRunner = JettySolrFactory.createJettyTestFixture(false);\n\t\tport = solrRunner.getLocalPort();\n\n\t\tsolrServer = new HttpSolrServer(\"http://localhost:\" + port + \"/solr\");\n\n\t\tlog.info(\"Started Test Server: \" + solrRunner.getBaseUrl());\n\t\tcloudFixture = new SolrCloudFixture(\"src/test/resources/solr\");\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"String solrRouteUri() {\n\t\tif (useHttps) {\n\t\t\treturn \"solrs://localhost:\" + httpsPort + \"/solr\";\n\t\t} else {\n\t\t\treturn \"solr://localhost:\" + port + \"/solr\";\n\t\t}\n    }","id":47649,"modified_method":"String solrRouteUri() {\n\t\tif (serverType == TestServerType.USE_HTTPS) {\n\t\t\treturn \"solrs://localhost:\" + httpsPort + \"/solr\";\n\t\t} else if (serverType == TestServerType.USE_CLOUD) {\n\t\t\tString zkHostStr = cloudFixture.miniCluster.getZkServer()\n\t\t\t\t\t.getZkHost();\n\t\t\treturn \"solrCloud://localhost:\" + httpsPort + \"/solr?zkHost=\"\n\t\t\t\t\t+ zkHostStr + \"&collection=collection1\";\n\t\t} else {\n\t\t\treturn \"solr://localhost:\" + port + \"/solr\";\n\t\t}\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"SolrServer getServer() {\n    \tif (useHttps) {\n    \t\treturn this.solrHttpsServer;\n    \t} else {\n    \t\treturn this.solrServer;\n    \t}\n    }","id":47650,"modified_method":"SolrServer getServer() {\n\t\tif (serverType == TestServerType.USE_HTTPS) {\n\t\t\treturn this.solrHttpsServer;\n\t\t} else if (serverType == TestServerType.USE_CLOUD) {\n\t\t\treturn this.cloudFixture.solrClient;\n\t\t} else {\n\t\t\treturn this.solrServer;\n\t\t}\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"public static void clearIndex() throws SolrServerException, IOException {\n    \t if (solrServer != null) {\n             // Clear the Solr index.\n             solrServer.deleteByQuery(\"*:*\");\n             solrServer.commit();\n         }\n         if (solrHttpsServer != null) {\n         \tsolrHttpsServer.deleteByQuery(\"*:*\");\n         \tsolrHttpsServer.commit();\n         }\n    }","id":47651,"modified_method":"public static void clearIndex() throws SolrServerException, IOException {\n\t\tif (solrServer != null) {\n\t\t\t// Clear the Solr index.\n\t\t\tsolrServer.deleteByQuery(\"*:*\");\n\t\t\tsolrServer.commit();\n\t\t}\n\t\tif (solrHttpsServer != null) {\n\t\t\tsolrHttpsServer.deleteByQuery(\"*:*\");\n\t\t\tsolrHttpsServer.commit();\n\t\t}\n\t\tif (cloudFixture != null) {\n\t\t\tcloudFixture.solrClient.deleteByQuery(\"*:*\");\n\t\t\tcloudFixture.solrClient.commit();\n\t\t}\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"public static void teardownSolrFixtures() throws Exception {\n        if (solrRunner != null) {\n            solrRunner.stop();\n        }\n        if (solrHttpsRunner != null) {\n            solrHttpsRunner.stop();\n        }\n    }","id":47652,"modified_method":"public static void teardownSolrFixtures() throws Exception {\n\t\tif (solrRunner != null) {\n\t\t\tsolrRunner.stop();\n\t\t}\n\t\tif (solrHttpsRunner != null) {\n\t\t\tsolrHttpsRunner.stop();\n\t\t}\n\t\tif (cloudFixture != null) {\n\t\t\tcloudFixture.teardown();\n\t\t}\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"public SolrProducer(SolrEndpoint endpoint, HttpSolrServer solrServer, ConcurrentUpdateSolrServer streamingSolrServer) {\n        super(endpoint);\n        this.solrServer = solrServer;\n        this.streamingSolrServer = streamingSolrServer;\n    }","id":47653,"modified_method":"public SolrProducer(SolrEndpoint endpoint, SolrServer solrServer, SolrServer concSolrServer, SolrServer cloudSolrServer) {\n        super(endpoint);\n        this.httpServer = solrServer;\n        this.concSolrServer = concSolrServer;\n        this.cloudSolrServer = cloudSolrServer;\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"private void insert(Exchange exchange, boolean isStreaming) throws Exception {\n        Object body = exchange.getIn().getBody();\n        if (body instanceof WrappedFile) {\n            body = ((WrappedFile<?>)body).getFile();\n        }\n\n        if (body instanceof File) {\n            MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();\n            String mimeType = mimeTypesMap.getContentType((File)body);\n            ContentStreamUpdateRequest updateRequest = new ContentStreamUpdateRequest(getRequestHandler());\n            updateRequest.addFile((File) body, mimeType);\n\n            for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n                if (entry.getKey().startsWith(SolrConstants.PARAM)) {\n                    String paramName = entry.getKey().substring(SolrConstants.PARAM.length());\n                    updateRequest.setParam(paramName, entry.getValue().toString());\n                }\n            }\n\n            if (isStreaming) {\n                updateRequest.process(streamingSolrServer);\n            } else {\n                updateRequest.process(solrServer);\n            }\n\n        } else if (body instanceof SolrInputDocument) {\n\n            UpdateRequest updateRequest = new UpdateRequest(getRequestHandler());\n            updateRequest.add((SolrInputDocument) body);\n\n            if (isStreaming) {\n                updateRequest.process(streamingSolrServer);\n            } else {\n                updateRequest.process(solrServer);\n            }\n\n        } else {\n\n            boolean hasSolrHeaders = false;\n            for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n                if (entry.getKey().startsWith(SolrConstants.FIELD)) {\n                    hasSolrHeaders = true;\n                    break;\n                }\n            }\n\n            if (hasSolrHeaders) {\n\n                UpdateRequest updateRequest = new UpdateRequest(getRequestHandler());\n\n                SolrInputDocument doc = new SolrInputDocument();\n                for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n                    if (entry.getKey().startsWith(SolrConstants.FIELD)) {\n                        String fieldName = entry.getKey().substring(SolrConstants.FIELD.length());\n                        doc.setField(fieldName, entry.getValue());\n                    }\n                }\n                updateRequest.add(doc);\n\n                if (isStreaming) {\n                    updateRequest.process(streamingSolrServer);\n                } else {\n                    updateRequest.process(solrServer);\n                }\n\n            } else if (body instanceof String) {\n\n                String bodyAsString = (String) body;\n\n                if (!bodyAsString.startsWith(\"<add\")) {\n                    bodyAsString = \"<add>\" + bodyAsString + \"<\/add>\";\n                }\n\n                DirectXmlRequest xmlRequest = new DirectXmlRequest(getRequestHandler(), bodyAsString);\n\n                if (isStreaming) {\n                    streamingSolrServer.request(xmlRequest);\n                } else {\n                    solrServer.request(xmlRequest);\n                }\n            } else {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unable to find data in Exchange to update Solr\");\n            }\n        }\n    }","id":47654,"modified_method":"private void insert(Exchange exchange, SolrServer solrServer) throws Exception {\n        Object body = exchange.getIn().getBody();\n        if (body instanceof WrappedFile) {\n            body = ((WrappedFile<?>)body).getFile();\n        }\n\n        if (body instanceof File) {\n            MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();\n            String mimeType = mimeTypesMap.getContentType((File)body);\n            ContentStreamUpdateRequest updateRequest = new ContentStreamUpdateRequest(getRequestHandler());\n            updateRequest.addFile((File) body, mimeType);\n\n            for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n                if (entry.getKey().startsWith(SolrConstants.PARAM)) {\n                    String paramName = entry.getKey().substring(SolrConstants.PARAM.length());\n                    updateRequest.setParam(paramName, entry.getValue().toString());\n                }\n            }\n\n            updateRequest.process(solrServer);\n\n        } else if (body instanceof SolrInputDocument) {\n\n            UpdateRequest updateRequest = new UpdateRequest(getRequestHandler());\n            updateRequest.add((SolrInputDocument) body);\n\n            updateRequest.process(solrServer);\n\n        } else {\n\n            boolean hasSolrHeaders = false;\n            for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n                if (entry.getKey().startsWith(SolrConstants.FIELD)) {\n                    hasSolrHeaders = true;\n                    break;\n                }\n            }\n\n            if (hasSolrHeaders) {\n\n                UpdateRequest updateRequest = new UpdateRequest(getRequestHandler());\n\n                SolrInputDocument doc = new SolrInputDocument();\n                for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n                    if (entry.getKey().startsWith(SolrConstants.FIELD)) {\n                        String fieldName = entry.getKey().substring(SolrConstants.FIELD.length());\n                        doc.setField(fieldName, entry.getValue());\n                    }\n                }\n                updateRequest.add(doc);\n                updateRequest.process(solrServer);\n\n            } else if (body instanceof String) {\n\n                String bodyAsString = (String) body;\n\n                if (!bodyAsString.startsWith(\"<add\")) {\n                    bodyAsString = \"<add>\" + bodyAsString + \"<\/add>\";\n                }\n\n                DirectXmlRequest xmlRequest = new DirectXmlRequest(getRequestHandler(), bodyAsString);\n\n                solrServer.request(xmlRequest);                \n            } else {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"unable to find data in Exchange to update Solr\");\n            }\n        }\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void process(Exchange exchange) throws Exception {\n\n        String operation = (String) exchange.getIn().getHeader(SolrConstants.OPERATION);\n\n        if (operation == null) {\n            throw new IllegalArgumentException(SolrConstants.OPERATION + \" header is missing\");\n        }\n\n        if (operation.equalsIgnoreCase(SolrConstants.OPERATION_INSERT)) {\n            insert(exchange, false);\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_INSERT_STREAMING)) {\n            insert(exchange, true);\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_DELETE_BY_ID)) {\n            solrServer.deleteById(exchange.getIn().getBody(String.class));\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_DELETE_BY_QUERY)) {\n            solrServer.deleteByQuery(exchange.getIn().getBody(String.class));\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ADD_BEAN)) {\n            solrServer.addBean(exchange.getIn().getBody());\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_COMMIT)) {\n            solrServer.commit();\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ROLLBACK)) {\n            solrServer.rollback();\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_OPTIMIZE)) {\n            solrServer.optimize();\n        } else {\n            throw new IllegalArgumentException(SolrConstants.OPERATION + \" header value '\" + operation + \"' is not supported\");\n        }\n    }","id":47655,"modified_method":"@Override\n    public void process(Exchange exchange) throws Exception {\n\n        String operation = (String) exchange.getIn().getHeader(SolrConstants.OPERATION);\n\n        if (operation == null) {\n            throw new IllegalArgumentException(SolrConstants.OPERATION + \" header is missing\");\n        }\n        \n        SolrServer serverToUse = getBestSolrServer(operation);\n\n        if (operation.equalsIgnoreCase(SolrConstants.OPERATION_INSERT)) {\n            insert(exchange, serverToUse);\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_INSERT_STREAMING)) {\n            insert(exchange, serverToUse);\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_DELETE_BY_ID)) {\n        \tserverToUse.deleteById(exchange.getIn().getBody(String.class));\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_DELETE_BY_QUERY)) {\n        \tserverToUse.deleteByQuery(exchange.getIn().getBody(String.class));\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ADD_BEAN)) {\n        \tserverToUse.addBean(exchange.getIn().getBody());\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_COMMIT)) {\n        \tserverToUse.commit();\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ROLLBACK)) {\n        \tserverToUse.rollback();\n        } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_OPTIMIZE)) {\n        \tserverToUse.optimize();\n        } else {\n            throw new IllegalArgumentException(SolrConstants.OPERATION + \" header value '\" + operation + \"' is not supported\");\n        }\n    }","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"public SolrTransactionsTest(Boolean useHttps) {\n\t\tsuper(useHttps);\n\t\t// TODO Auto-generated constructor stub\n\t}","id":47656,"modified_method":"public SolrTransactionsTest(SolrFixtures.TestServerType serverToTest) {\n\t\tsuper(serverToTest);\n\t\t// TODO Auto-generated constructor stub\n\t}","commit_id":"1ad4708f81d4d71c4724900cf077bd3c8a63661b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void run() {\n      try {\n        EventQueue eventQueue = myVmProxy.eventQueue();\n        while (!isStopped()) {\n          try {\n            final EventSet eventSet = eventQueue.remove();\n\n            final boolean methodWatcherActive = myReturnValueWatcher != null && myReturnValueWatcher.isEnabled();\n            int processed = 0;\n            for (Event event : eventSet) {\n              if (methodWatcherActive) {\n                if (event instanceof MethodExitEvent) {\n                  if (myReturnValueWatcher.processMethodExitEvent((MethodExitEvent)event)) {\n                    processed++;\n                  }\n                  continue;\n                }\n              }\n              if (event instanceof ThreadStartEvent) {\n                processed++;\n                final ThreadReference thread = ((ThreadStartEvent)event).thread();\n                getManagerThread().schedule(new DebuggerCommandImpl() {\n                  @Override\n                  protected void action() throws Exception {\n                    getVirtualMachineProxy().threadStarted(thread);\n                    myDebugProcessDispatcher.getMulticaster().threadStarted(DebugProcessEvents.this, thread);\n                  }\n                });\n              }\n              else if (event instanceof ThreadDeathEvent) {\n                processed++;\n                final ThreadReference thread = ((ThreadDeathEvent)event).thread();\n                getManagerThread().schedule(new DebuggerCommandImpl() {\n                  @Override\n                  protected void action() throws Exception {\n                    getVirtualMachineProxy().threadStopped(thread);\n                    myDebugProcessDispatcher.getMulticaster().threadStopped(DebugProcessEvents.this, thread);\n                  }\n                });\n              }\n            }\n\n            if (processed == eventSet.size()) {\n              eventSet.resume();\n              continue;\n            }\n\n            getManagerThread().invokeAndWait(new DebuggerCommandImpl() {\n              @Override\n              protected void action() throws Exception {\n                if (eventSet.suspendPolicy() == EventRequest.SUSPEND_ALL) {\n                  // check if there is already one request with policy SUSPEND_ALL\n                  for (SuspendContextImpl context : getSuspendManager().getEventContexts()) {\n                    if (context.getSuspendPolicy() == EventRequest.SUSPEND_ALL) {\n                      if (Registry.is(\"debugger.step.resumes.one.thread\") && getStepEvent(eventSet) != null) {\n                        // if step event is present - switch context\n                        getSuspendManager().resume(context);\n                        //((SuspendManagerImpl)getSuspendManager()).popContext(context);\n                        continue;\n                      }\n                      if (!DebuggerSession.enableBreakpointsDuringEvaluation()) {\n                        eventSet.resume();\n                        return;\n                      }\n                    }\n                  }\n                }\n\n                SuspendContextImpl suspendContext = null;\n\n                StepEvent stepEvent = getStepEvent(eventSet);\n                if (Registry.is(\"debugger.step.resumes.one.thread\") && stepEvent != null) {\n                  for (SuspendContextImpl context : getSuspendManager().getEventContexts()) {\n                    ThreadReferenceProxyImpl threadProxy = getVirtualMachineProxy().getThreadReferenceProxy(stepEvent.thread());\n                    if (context.getSuspendPolicy() == EventRequest.SUSPEND_ALL &&\n                        context.isExplicitlyResumed(threadProxy)) {\n                      context.myResumedThreads.remove(threadProxy);\n                      suspendContext = context;\n                      suspendContext.myVotesToVote = eventSet.size();\n                      break;\n                    }\n                  }\n                }\n\n                if (suspendContext == null) {\n                  suspendContext = getSuspendManager().pushSuspendContext(eventSet);\n                }\n\n                for (EventIterator eventIterator = eventSet.eventIterator(); eventIterator.hasNext();) {\n                  final Event event = eventIterator.nextEvent();\n                  //if (LOG.isDebugEnabled()) {\n                  //  LOG.debug(\"EVENT : \" + event);\n                  //}\n                  try {\n                    if (event instanceof VMStartEvent) {\n                      //Sun WTK fails when J2ME when event set is resumed on VMStartEvent\n                      processVMStartEvent(suspendContext, (VMStartEvent)event);\n                    }\n                    else if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n                      processVMDeathEvent(suspendContext, event);\n                    }\n                    else if (event instanceof ClassPrepareEvent) {\n                      processClassPrepareEvent(suspendContext, (ClassPrepareEvent)event);\n                    }\n                    //AccessWatchpointEvent, BreakpointEvent, ExceptionEvent, MethodEntryEvent, MethodExitEvent,\n                    //ModificationWatchpointEvent, StepEvent, WatchpointEvent\n                    else if (event instanceof StepEvent) {\n                      processStepEvent(suspendContext, (StepEvent)event);\n                    }\n                    else if (event instanceof LocatableEvent) {\n                      processLocatableEvent(suspendContext, (LocatableEvent)event);\n                    }\n                    else if (event instanceof ClassUnloadEvent) {\n                      processDefaultEvent(suspendContext);\n                    }\n                  }\n                  catch (VMDisconnectedException e) {\n                    LOG.debug(e);\n                  }\n                  catch (InternalException e) {\n                    LOG.info(e);\n                  }\n                  catch (Throwable e) {\n                    LOG.error(e);\n                  }\n                }\n              }\n            });\n          }\n          catch (InternalException e) {\n            LOG.debug(e);\n          }\n          catch (InterruptedException e) {\n            throw e;\n          }\n          catch (VMDisconnectedException e) {\n            throw e;\n          }\n          catch (ProcessCanceledException e) {\n            throw e;\n          }\n          catch (Throwable e) {\n            LOG.debug(e);\n          }\n        }\n      }\n      catch (InterruptedException e) {\n        invokeVMDeathEvent();\n      }\n      catch (VMDisconnectedException e) {\n        invokeVMDeathEvent();\n      }\n      finally {\n        Thread.interrupted(); // reset interrupted status\n      }\n    }","id":47657,"modified_method":"@Override\n    public void run() {\n      try {\n        EventQueue eventQueue = myVmProxy.eventQueue();\n        while (!isStopped()) {\n          try {\n            final EventSet eventSet = eventQueue.remove();\n\n            final boolean methodWatcherActive = myReturnValueWatcher != null && myReturnValueWatcher.isEnabled();\n            int processed = 0;\n            for (Event event : eventSet) {\n              if (methodWatcherActive) {\n                if (myReturnValueWatcher.processEvent(event)) {\n                  processed++;\n                  continue;\n                }\n              }\n              if (event instanceof ThreadStartEvent) {\n                processed++;\n                final ThreadReference thread = ((ThreadStartEvent)event).thread();\n                getManagerThread().schedule(new DebuggerCommandImpl() {\n                  @Override\n                  protected void action() throws Exception {\n                    getVirtualMachineProxy().threadStarted(thread);\n                    myDebugProcessDispatcher.getMulticaster().threadStarted(DebugProcessEvents.this, thread);\n                  }\n                });\n              }\n              else if (event instanceof ThreadDeathEvent) {\n                processed++;\n                final ThreadReference thread = ((ThreadDeathEvent)event).thread();\n                getManagerThread().schedule(new DebuggerCommandImpl() {\n                  @Override\n                  protected void action() throws Exception {\n                    getVirtualMachineProxy().threadStopped(thread);\n                    myDebugProcessDispatcher.getMulticaster().threadStopped(DebugProcessEvents.this, thread);\n                  }\n                });\n              }\n            }\n\n            if (processed == eventSet.size()) {\n              eventSet.resume();\n              continue;\n            }\n\n            getManagerThread().invokeAndWait(new DebuggerCommandImpl() {\n              @Override\n              protected void action() throws Exception {\n                if (eventSet.suspendPolicy() == EventRequest.SUSPEND_ALL) {\n                  // check if there is already one request with policy SUSPEND_ALL\n                  for (SuspendContextImpl context : getSuspendManager().getEventContexts()) {\n                    if (context.getSuspendPolicy() == EventRequest.SUSPEND_ALL) {\n                      if (Registry.is(\"debugger.step.resumes.one.thread\") && getStepEvent(eventSet) != null) {\n                        // if step event is present - switch context\n                        getSuspendManager().resume(context);\n                        //((SuspendManagerImpl)getSuspendManager()).popContext(context);\n                        continue;\n                      }\n                      if (!DebuggerSession.enableBreakpointsDuringEvaluation()) {\n                        eventSet.resume();\n                        return;\n                      }\n                    }\n                  }\n                }\n\n                SuspendContextImpl suspendContext = null;\n\n                StepEvent stepEvent = getStepEvent(eventSet);\n                if (Registry.is(\"debugger.step.resumes.one.thread\") && stepEvent != null) {\n                  for (SuspendContextImpl context : getSuspendManager().getEventContexts()) {\n                    ThreadReferenceProxyImpl threadProxy = getVirtualMachineProxy().getThreadReferenceProxy(stepEvent.thread());\n                    if (context.getSuspendPolicy() == EventRequest.SUSPEND_ALL &&\n                        context.isExplicitlyResumed(threadProxy)) {\n                      context.myResumedThreads.remove(threadProxy);\n                      suspendContext = context;\n                      suspendContext.myVotesToVote = eventSet.size();\n                      break;\n                    }\n                  }\n                }\n\n                if (suspendContext == null) {\n                  suspendContext = getSuspendManager().pushSuspendContext(eventSet);\n                }\n\n                for (Event event : eventSet) {\n                  //if (LOG.isDebugEnabled()) {\n                  //  LOG.debug(\"EVENT : \" + event);\n                  //}\n                  try {\n                    if (event instanceof VMStartEvent) {\n                      //Sun WTK fails when J2ME when event set is resumed on VMStartEvent\n                      processVMStartEvent(suspendContext, (VMStartEvent)event);\n                    }\n                    else if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n                      processVMDeathEvent(suspendContext, event);\n                    }\n                    else if (event instanceof ClassPrepareEvent) {\n                      processClassPrepareEvent(suspendContext, (ClassPrepareEvent)event);\n                    }\n                    //AccessWatchpointEvent, BreakpointEvent, ExceptionEvent, MethodEntryEvent, MethodExitEvent,\n                    //ModificationWatchpointEvent, StepEvent, WatchpointEvent\n                    else if (event instanceof StepEvent) {\n                      processStepEvent(suspendContext, (StepEvent)event);\n                    }\n                    else if (event instanceof LocatableEvent) {\n                      processLocatableEvent(suspendContext, (LocatableEvent)event);\n                    }\n                    else if (event instanceof ClassUnloadEvent) {\n                      processDefaultEvent(suspendContext);\n                    }\n                  }\n                  catch (VMDisconnectedException e) {\n                    LOG.debug(e);\n                  }\n                  catch (InternalException e) {\n                    LOG.info(e);\n                  }\n                  catch (Throwable e) {\n                    LOG.error(e);\n                  }\n                }\n              }\n            });\n          }\n          catch (InternalException e) {\n            LOG.debug(e);\n          }\n          catch (InterruptedException e) {\n            throw e;\n          }\n          catch (VMDisconnectedException e) {\n            throw e;\n          }\n          catch (ProcessCanceledException e) {\n            throw e;\n          }\n          catch (Throwable e) {\n            LOG.debug(e);\n          }\n        }\n      }\n      catch (InterruptedException e) {\n        invokeVMDeathEvent();\n      }\n      catch (VMDisconnectedException e) {\n        invokeVMDeathEvent();\n      }\n      finally {\n        Thread.interrupted(); // reset interrupted status\n      }\n    }","commit_id":"54a033766411810ae23335ad8e4805bcfee2f9a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processLocatableEvent(final SuspendContextImpl suspendContext, final LocatableEvent event) {\n    if (myReturnValueWatcher != null && event instanceof MethodExitEvent) {\n      if (myReturnValueWatcher.processMethodExitEvent(((MethodExitEvent)event))) {\n        return;\n      }\n    }\n\n    ThreadReference thread = event.thread();\n    //LOG.assertTrue(thread.isSuspended());\n    preprocessEvent(suspendContext, thread);\n\n    //we use schedule to allow processing other events during processing this one\n    //this is especially necessary if a method is breakpoint condition\n    getManagerThread().schedule(new SuspendContextCommandImpl(suspendContext) {\n      @Override\n      public void contextAction() throws Exception {\n        final SuspendManager suspendManager = getSuspendManager();\n        SuspendContextImpl evaluatingContext = SuspendManagerUtil.getEvaluatingContext(suspendManager, getSuspendContext().getThread());\n\n        if (evaluatingContext != null && !DebuggerSession.enableBreakpointsDuringEvaluation()) {\n          // is inside evaluation, so ignore any breakpoints\n          suspendManager.voteResume(suspendContext);\n          return;\n        }\n\n        final LocatableEventRequestor requestor = (LocatableEventRequestor) getRequestsManager().findRequestor(event.request());\n\n        boolean resumePreferred = requestor != null && DebuggerSettings.SUSPEND_NONE.equals(requestor.getSuspendPolicy());\n        boolean requestHit;\n        try {\n          requestHit = (requestor != null) && requestor.processLocatableEvent(this, event);\n        }\n        catch (final LocatableEventRequestor.EventProcessingException ex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(ex.getMessage());\n          }\n          final boolean[] considerRequestHit = new boolean[]{true};\n          DebuggerInvocationUtil.invokeAndWait(getProject(), new Runnable() {\n            @Override\n            public void run() {\n              final String displayName = requestor instanceof Breakpoint? ((Breakpoint)requestor).getDisplayName() : requestor.getClass().getSimpleName();\n              final String message = DebuggerBundle.message(\"error.evaluating.breakpoint.condition.or.action\", displayName, ex.getMessage());\n              considerRequestHit[0] = Messages.showYesNoDialog(getProject(), message, ex.getTitle(), Messages.getQuestionIcon()) == Messages.YES;\n            }\n          }, ModalityState.NON_MODAL);\n          requestHit = considerRequestHit[0];\n          resumePreferred = !requestHit;\n        }\n\n        if (requestHit && requestor instanceof Breakpoint) {\n          // if requestor is a breakpoint and this breakpoint was hit, no matter its suspend policy\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              XDebugSession session = getSession().getXDebugSession();\n              if (session != null) {\n                XBreakpoint breakpoint = ((Breakpoint)requestor).getXBreakpoint();\n                if (breakpoint != null) {\n                  ((XDebugSessionImpl)session).processDependencies(breakpoint);\n                }\n              }\n            }\n          });\n        }\n\n        if(!requestHit || resumePreferred) {\n          suspendManager.voteResume(suspendContext);\n        }\n        else {\n          if (myReturnValueWatcher != null) {\n            myReturnValueWatcher.disable();\n          }\n          //if (suspendContext.getSuspendPolicy() == EventRequest.SUSPEND_ALL) {\n          //  // there could be explicit resume as a result of call to voteSuspend()\n          //  // e.g. when breakpoint was considered invalid, in that case the filter will be applied _after_\n          //  // resuming and all breakpoints in other threads will be ignored.\n          //  // As resume() implicitly cleares the filter, the filter must be always applied _before_ any resume() action happens\n          //  myBreakpointManager.applyThreadFilter(DebugProcessEvents.this, event.thread());\n          //}\n          suspendManager.voteSuspend(suspendContext);\n          showStatusText(DebugProcessEvents.this, event);\n        }\n      }\n    });\n  }","id":47658,"modified_method":"private void processLocatableEvent(final SuspendContextImpl suspendContext, final LocatableEvent event) {\n    ThreadReference thread = event.thread();\n    //LOG.assertTrue(thread.isSuspended());\n    preprocessEvent(suspendContext, thread);\n\n    //we use schedule to allow processing other events during processing this one\n    //this is especially necessary if a method is breakpoint condition\n    getManagerThread().schedule(new SuspendContextCommandImpl(suspendContext) {\n      @Override\n      public void contextAction() throws Exception {\n        final SuspendManager suspendManager = getSuspendManager();\n        SuspendContextImpl evaluatingContext = SuspendManagerUtil.getEvaluatingContext(suspendManager, getSuspendContext().getThread());\n\n        if (evaluatingContext != null && !DebuggerSession.enableBreakpointsDuringEvaluation()) {\n          // is inside evaluation, so ignore any breakpoints\n          suspendManager.voteResume(suspendContext);\n          return;\n        }\n\n        final LocatableEventRequestor requestor = (LocatableEventRequestor) getRequestsManager().findRequestor(event.request());\n\n        boolean resumePreferred = requestor != null && DebuggerSettings.SUSPEND_NONE.equals(requestor.getSuspendPolicy());\n        boolean requestHit;\n        try {\n          requestHit = (requestor != null) && requestor.processLocatableEvent(this, event);\n        }\n        catch (final LocatableEventRequestor.EventProcessingException ex) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(ex.getMessage());\n          }\n          final boolean[] considerRequestHit = new boolean[]{true};\n          DebuggerInvocationUtil.invokeAndWait(getProject(), new Runnable() {\n            @Override\n            public void run() {\n              final String displayName = requestor instanceof Breakpoint? ((Breakpoint)requestor).getDisplayName() : requestor.getClass().getSimpleName();\n              final String message = DebuggerBundle.message(\"error.evaluating.breakpoint.condition.or.action\", displayName, ex.getMessage());\n              considerRequestHit[0] = Messages.showYesNoDialog(getProject(), message, ex.getTitle(), Messages.getQuestionIcon()) == Messages.YES;\n            }\n          }, ModalityState.NON_MODAL);\n          requestHit = considerRequestHit[0];\n          resumePreferred = !requestHit;\n        }\n\n        if (requestHit && requestor instanceof Breakpoint) {\n          // if requestor is a breakpoint and this breakpoint was hit, no matter its suspend policy\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              XDebugSession session = getSession().getXDebugSession();\n              if (session != null) {\n                XBreakpoint breakpoint = ((Breakpoint)requestor).getXBreakpoint();\n                if (breakpoint != null) {\n                  ((XDebugSessionImpl)session).processDependencies(breakpoint);\n                }\n              }\n            }\n          });\n        }\n\n        if(!requestHit || resumePreferred) {\n          suspendManager.voteResume(suspendContext);\n        }\n        else {\n          if (myReturnValueWatcher != null) {\n            myReturnValueWatcher.disable();\n          }\n          //if (suspendContext.getSuspendPolicy() == EventRequest.SUSPEND_ALL) {\n          //  // there could be explicit resume as a result of call to voteSuspend()\n          //  // e.g. when breakpoint was considered invalid, in that case the filter will be applied _after_\n          //  // resuming and all breakpoints in other threads will be ignored.\n          //  // As resume() implicitly cleares the filter, the filter must be always applied _before_ any resume() action happens\n          //  myBreakpointManager.applyThreadFilter(DebugProcessEvents.this, event.thread());\n          //}\n          suspendManager.voteSuspend(suspendContext);\n          showStatusText(DebugProcessEvents.this, event);\n        }\n      }\n    });\n  }","commit_id":"54a033766411810ae23335ad8e4805bcfee2f9a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateRequestState(final boolean enabled, @Nullable final ThreadReference thread) {\n    try {\n      final MethodExitRequest request = myRequest;\n      if (request != null) {\n        myRequest = null;\n        myRequestManager.deleteEventRequest(request);\n      }\n      if (enabled) {\n        myLastExecutedMethod = null;\n        myLastMethodReturnValue = null;\n        myRequest = createRequest(thread);\n        myRequest.enable();\n      }\n    }\n    catch (ObjectCollectedException ignored) {\n    }\n  }","id":47659,"modified_method":"private void updateRequestState(final boolean enabled, @Nullable final ThreadReference thread) {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    try {\n      if (myEntryRequest != null) {\n        myRequestManager.deleteEventRequest(myEntryRequest);\n        myEntryRequest = null;\n      }\n      if (myExitRequest != null) {\n        myRequestManager.deleteEventRequest(myExitRequest);\n        myExitRequest = null;\n      }\n      if (enabled) {\n        myLastExecutedMethod = null;\n        myLastMethodReturnValue = null;\n        myThread = thread;\n\n        if (Registry.is(\"debugger.watch.return.speedup\")) {\n          createEntryRequest().enable();\n        }\n        createExitRequest().enable();\n      }\n    }\n    catch (ObjectCollectedException ignored) {\n    }\n  }","commit_id":"54a033766411810ae23335ad8e4805bcfee2f9a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processMethodExitEvent(MethodExitEvent event) {\n    if (event.request() != myRequest) {\n      return false;\n    }\n    try {\n      final Method method = event.method();\n      //myLastMethodReturnValue = event.returnValue();\n      try {\n        if (myReturnValueMethod == null) {\n          //noinspection HardCodedStringLiteral\n          myReturnValueMethod = MethodExitEvent.class.getDeclaredMethod(\"returnValue\", ArrayUtil.EMPTY_CLASS_ARRAY);\n        }\n        final Value retVal = (Value)myReturnValueMethod.invoke(event);\n        \n        if (method == null || !\"void\".equals(method.returnTypeName())) {\n          // remember methods with non-void return types only\n          myLastExecutedMethod = method;\n          myLastMethodReturnValue = retVal;\n        }\n      }\n      catch (NoSuchMethodException ignored) {\n      }\n      catch (IllegalAccessException ignored) {\n      }\n      catch (InvocationTargetException ignored) {\n      }\n    }\n    catch (UnsupportedOperationException ex) {\n      LOG.error(ex);\n    }\n    return true;\n  }","id":47660,"modified_method":"private void processMethodExitEvent(MethodExitEvent event) {\n    try {\n      if (Registry.is(\"debugger.watch.return.speedup\") && Comparing.equal(event.request().getProperty(METHOD_KEY), event.method())) {\n        enableEntryWatching(true);\n        createExitRequest().enable();\n      }\n      final Method method = event.method();\n      //myLastMethodReturnValue = event.returnValue();\n      try {\n        if (myReturnValueMethod == null) {\n          //noinspection HardCodedStringLiteral\n          myReturnValueMethod = MethodExitEvent.class.getDeclaredMethod(\"returnValue\", ArrayUtil.EMPTY_CLASS_ARRAY);\n        }\n        final Value retVal = (Value)myReturnValueMethod.invoke(event);\n        \n        if (method == null || !\"void\".equals(method.returnTypeName())) {\n          // remember methods with non-void return types only\n          myLastExecutedMethod = method;\n          myLastMethodReturnValue = retVal;\n        }\n      }\n      catch (NoSuchMethodException ignored) {\n      }\n      catch (IllegalAccessException ignored) {\n      }\n      catch (InvocationTargetException ignored) {\n      }\n    }\n    catch (UnsupportedOperationException ex) {\n      LOG.error(ex);\n    }\n  }","commit_id":"54a033766411810ae23335ad8e4805bcfee2f9a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n\tpublic void testXCSRFToken() throws Exception {\n\t\ttestPortlet = new TestPortlet(map) {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = resourceResponse.createActionURL();\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portalAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_auth\");\n\n\t\t\t\tprintWriter.write(portalAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\t// Get the portal authentication token by making a resource request\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tMap<String, List<String>> responseMap =\n\t\t\tPortletContainerTestUtil.request(portletURL.toString());\n\n\t\tString portalAuthenticationToken = PortletContainerTestUtil.getString(\n\t\t\tresponseMap, \"body\");\n\n\t\tList<String> cookies = responseMap.get(\"Set-Cookie\");\n\n\t\tmap.clear();\n\n\t\t// Make an action request using the portal authentication token\n\n\t\tportletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.removeParameter(url, \"p_auth\");\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", cookies);\n\t\theaders.put(\n\t\t\t\"X-CSRF-Token\",\n\t\t\tCollections.singletonList(portalAuthenticationToken));\n\n\t\tresponseMap = PortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(\n\t\t\t\"200\", PortletContainerTestUtil.getString(responseMap, \"code\"));\n\t\tAssert.assertTrue(map.containsKey(\"processAction\"));\n\t}","id":47661,"modified_method":"@Test\n\tpublic void testXCSRFToken() throws Exception {\n\t\ttestPortlet = new TestPortlet(map) {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = resourceResponse.createActionURL();\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portalAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_auth\");\n\n\t\t\t\tprintWriter.write(portalAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletContainerTestUtil.PortalAuthentication portalAuthentication =\n\t\t\tPortletContainerTestUtil.getPortalAuthentication(\n\t\t\t\thttpServletRequest, layout, TEST_PORTLET_ID);\n\n\t\tmap.clear();\n\n\t\t// Make an action request using the portal authentication token\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.removeParameter(url, \"p_auth\");\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", portalAuthentication.getCookies());\n\t\theaders.put(\n\t\t\t\"X-CSRF-Token\",\n\t\t\tCollections.singletonList(\n\t\t\t\tportalAuthentication.getPortalAuthenticationToken()));\n\n\t\tMap<String, List<String>> responseMap =\n\t\t\tPortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(\n\t\t\t\"200\", PortletContainerTestUtil.getString(responseMap, \"code\"));\n\t\tAssert.assertTrue(map.containsKey(\"processAction\"));\n\t}","commit_id":"c08396fa2468efe50d8ffe78015fe37b1344bea6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPortalAuthenticationToken() throws Exception {\n\t\ttestPortlet = new TestPortlet(map) {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = resourceResponse.createActionURL();\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portalAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_auth\");\n\n\t\t\t\tprintWriter.write(portalAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\t// Get the portal authentication token by making a resource request\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tMap<String, List<String>> responseMap =\n\t\t\tPortletContainerTestUtil.request(portletURL.toString());\n\n\t\tString portalAuthenticationToken = PortletContainerTestUtil.getString(\n\t\t\tresponseMap, \"body\");\n\n\t\tList<String> cookies = responseMap.get(\"Set-Cookie\");\n\n\t\tmap.clear();\n\n\t\t// Make an action request using the portal authentication token\n\n\t\tportletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_auth\", portalAuthenticationToken);\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", cookies);\n\n\t\tresponseMap = PortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(\n\t\t\t\"200\", PortletContainerTestUtil.getString(responseMap, \"code\"));\n\t\tAssert.assertTrue(map.containsKey(\"processAction\"));\n\t}","id":47662,"modified_method":"@Test\n\tpublic void testPortalAuthenticationToken() throws Exception {\n\t\ttestPortlet = new TestPortlet(map) {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = resourceResponse.createActionURL();\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portalAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_auth\");\n\n\t\t\t\tprintWriter.write(portalAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletContainerTestUtil.PortalAuthentication portalAuthentication =\n\t\t\tPortletContainerTestUtil.getPortalAuthentication(\n\t\t\t\thttpServletRequest, layout, TEST_PORTLET_ID);\n\n\t\tmap.clear();\n\n\t\t// Make an action request using the portal authentication token\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(\n\t\t\turl, \"p_auth\", portalAuthentication.getPortalAuthenticationToken());\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", portalAuthentication.getCookies());\n\n\t\tMap<String, List<String>> responseMap =\n\t\t\tPortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(\n\t\t\t\"200\", PortletContainerTestUtil.getString(responseMap, \"code\"));\n\t\tAssert.assertTrue(map.containsKey(\"processAction\"));\n\t}","commit_id":"c08396fa2468efe50d8ffe78015fe37b1344bea6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Table(\n    \t\tfinal File tablefile,\n    \t\tfinal Row rowdef,\n    \t\tfinal int buffersize,\n    \t\tfinal int initialSpace,\n    \t\tboolean useTailCache,\n    \t\tfinal boolean exceed134217727,\n    \t\tfinal boolean warmUp) throws SpaceExceededException {\n\n        this.rowdef = rowdef;\n        this.buffersize = buffersize;\n        this.minmemremaining = Math.max(200L * 1024L * 1024L, MemoryControl.available() / 10);\n        //this.fail = 0;\n        // define the taildef, a row like the rowdef but without the first column\n        final Column[] cols = new Column[rowdef.columns() - 1];\n        for (int i = 0; i < cols.length; i++) {\n            cols[i] = rowdef.column(i + 1);\n        }\n        this.taildef = new Row(cols, NaturalOrder.naturalOrder);\n\n        // initialize table file\n        boolean freshFile = false;\n        if (!tablefile.exists()) {\n            // make new file\n            freshFile = true;\n            FileOutputStream fos = null;\n            try {\n                fos = new FileOutputStream(tablefile);\n            } catch (final FileNotFoundException e) {\n                // should not happen\n                Log.logSevere(\"Table\", \"\", e);\n            }\n            if (fos != null) try { fos.close(); } catch (final IOException e) {}\n        }\n\n        try {\n            // open an existing table file\n            final int fileSize = (int) tableSize(tablefile, rowdef.objectsize, true);\n\n            // initialize index and copy table\n            final int  records = Math.max(fileSize, initialSpace);\n            final long neededRAM4table = 200L * 1024L * 1024L + records * (this.taildef.objectsize + rowdef.primaryKeyLength + 4L) * 3L / 2L;\n            this.table = null;\n            try {\n                this.table = ((exceed134217727 || neededRAM4table < maxarraylength) &&\n            \t    \t      useTailCache && MemoryControl.request(neededRAM4table, true)) ? new RowSet(this.taildef, records) : null;\n            } catch (SpaceExceededException e) {\n            \tthis.table = null;\n            } catch (Throwable e) {\n            \tthis.table = null;\n            }\n            Log.logInfo(\"TABLE\", \"initialization of \" + tablefile.getName() + \". table copy: \" + ((this.table == null) ? \"no\" : \"yes\") + \", available RAM: \" + (MemoryControl.available() / 1024L / 1024L) + \"MB, needed: \" + (neededRAM4table / 1024L / 1024L) + \"MB, allocating space for \" + records + \" entries\");\n            final long neededRAM4index = 100L * 1024L * 1024L + records * (rowdef.primaryKeyLength + 4L) * 3L / 2L;\n            if (records > 0 && !MemoryControl.request(neededRAM4index, true)) {\n                // despite calculations seemed to show that there is enough memory for the table AND the index\n                // there is now not enough memory left for the index. So delete the table again to free the memory\n                // for the index\n                Log.logSevere(\"TABLE\", tablefile.getName() + \": not enough RAM (\" + (MemoryControl.available() / 1024L / 1024L) + \"MB) left for index, deleting allocated table space to enable index space allocation (needed: \" + (neededRAM4index / 1024L / 1024L) + \"MB)\");\n                this.table = null; System.gc();\n                Log.logSevere(\"TABLE\", tablefile.getName() + \": RAM after releasing the table: \" + (MemoryControl.available() / 1024L / 1024L) + \"MB\");\n            }\n            this.index = new RowHandleMap(rowdef.primaryKeyLength, rowdef.objectOrder, 4, records, tablefile.getAbsolutePath());\n            final RowHandleMap errors = new RowHandleMap(rowdef.primaryKeyLength, NaturalOrder.naturalOrder, 4, records, tablefile.getAbsolutePath() + \".errors\");\n            Log.logInfo(\"TABLE\", tablefile + \": TABLE \" + tablefile.toString() + \" has table copy \" + ((this.table == null) ? \"DISABLED\" : \"ENABLED\"));\n\n            // read all elements from the file into the copy table\n            Log.logInfo(\"TABLE\", \"initializing RAM index for TABLE \" + tablefile.getName() + \", please wait.\");\n            int i = 0;\n            byte[] key;\n            if (this.table == null) {\n                final Iterator<byte[]> ki = new ChunkIterator(tablefile, rowdef.objectsize, rowdef.primaryKeyLength);\n                while (ki.hasNext()) {\n                    key = ki.next();\n                    // write the key into the index table\n                    assert key != null;\n                    if (key == null) {i++; continue;}\n                    if (rowdef.objectOrder.wellformed(key)) {\n                        this.index.putUnique(key, i++);\n                    } else {\n                        errors.putUnique(key, i++);\n                    }\n                }\n            } else {\n                byte[] record;\n                key = new byte[rowdef.primaryKeyLength];\n                final Iterator<byte[]> ri = new ChunkIterator(tablefile, rowdef.objectsize, rowdef.objectsize);\n                while (ri.hasNext()) {\n                    record = ri.next();\n                    assert record != null;\n                    if (record == null) {i++; continue;}\n                    System.arraycopy(record, 0, key, 0, rowdef.primaryKeyLength);\n\n                    // write the key into the index table\n                    if (rowdef.objectOrder.wellformed(key)) {\n                        this.index.putUnique(key, i++);\n                        // write the tail into the table\n                        try {\n                            this.table.addUnique(this.taildef.newEntry(record, rowdef.primaryKeyLength, true));\n                        } catch (final SpaceExceededException e) {\n                            this.table = null;\n                            break;\n                        }\n                    } else {\n                        errors.putUnique(key, i++);\n                    }\n                }\n                Runtime.getRuntime().gc();\n                if (abandonTable()) {\n                    this.table = null;\n                }\n            }\n            this.index.trim();\n\n            // open the file\n            this.file = new BufferedRecords(new Records(tablefile, rowdef.objectsize), this.buffersize);\n            assert this.file.size() == this.index.size() : \"file.size() = \" + this.file.size() + \", index.size() = \" + this.index.size() + \", file = \" + filename();\n\n            // clean up the file by cleaning badly formed entries\n            final int errorc = errors.size();\n            int errorcc = 0;\n            int idx;\n            for (final Map.Entry<byte[], Long> entry: errors) {\n                idx = (int) entry.getValue().longValue();\n                removeInFile(idx);\n                key = entry.getKey();\n                if (key == null) continue;\n                Log.logWarning(\"Table\", \"removing not well-formed entry \" + idx + \" with key: \" + NaturalOrder.arrayList(key, 0, key.length) + \", \" + errorcc++ + \"/\" + errorc);\n            }\n            errors.close();\n            assert this.file.size() == this.index.size() : \"file.size() = \" + this.file.size() + \", index.size() = \" + this.index.size() + \", file = \" + filename();\n\n            // warm up\n            if (!freshFile && warmUp) {warmUp0();}\n        } catch (final FileNotFoundException e) {\n            // should never happen\n            Log.logSevere(\"Table\", \"\", e);\n            throw new kelondroException(e.getMessage());\n        } catch (final IOException e) {\n            Log.logSevere(\"Table\", \"\", e);\n            throw new kelondroException(e.getMessage());\n        }\n\n        // track this table\n        tableTracker.put(tablefile.toString(), this);\n    }","id":47663,"modified_method":"public Table(\n    \t\tfinal File tablefile,\n    \t\tfinal Row rowdef,\n    \t\tfinal int buffersize,\n    \t\tfinal int initialSpace,\n    \t\tboolean useTailCache,\n    \t\tfinal boolean exceed134217727,\n    \t\tfinal boolean warmUp) throws SpaceExceededException {\n\n        this.rowdef = rowdef;\n        this.buffersize = buffersize;\n        this.minmemremaining = Math.max(200L * 1024L * 1024L, MemoryControl.available() / 10);\n        //this.fail = 0;\n        // define the taildef, a row like the rowdef but without the first column\n        final Column[] cols = new Column[rowdef.columns() - 1];\n        for (int i = 0; i < cols.length; i++) {\n            cols[i] = rowdef.column(i + 1);\n        }\n        this.taildef = new Row(cols, NaturalOrder.naturalOrder);\n\n        // initialize table file\n        boolean freshFile = false;\n        if (!tablefile.exists()) {\n            // make new file\n            freshFile = true;\n            FileOutputStream fos = null;\n            try {\n                fos = new FileOutputStream(tablefile);\n            } catch (final FileNotFoundException e) {\n                // should not happen\n                Log.logSevere(\"Table\", \"\", e);\n            }\n            if (fos != null) try { fos.close(); } catch (final IOException e) {}\n        }\n\n        try {\n            // open an existing table file\n            final int fileSize = (int) tableSize(tablefile, rowdef.objectsize, true);\n\n            // initialize index and copy table\n            final int  records = Math.max(fileSize, initialSpace);\n            final long neededRAM4table = 200L * 1024L * 1024L + records * (this.taildef.objectsize + rowdef.primaryKeyLength + 4L) * 3L / 2L;\n            this.table = null;\n            \n            try {\n                this.table = ((exceed134217727 || neededRAM4table < maxarraylength) &&\n            \t    \t      useTailCache && MemoryControl.available() > 600L * 1024L * 1024L &&\n            \t    \t      MemoryControl.request(neededRAM4table, true)) ? new RowSet(this.taildef, records) : null;\n            } catch (SpaceExceededException e) {\n            \tthis.table = null;\n            } catch (Throwable e) {\n            \tthis.table = null;\n            }\n            \n            Log.logInfo(\"TABLE\", \"initialization of \" + tablefile.getName() + \". table copy: \" + ((this.table == null) ? \"no\" : \"yes\") + \", available RAM: \" + (MemoryControl.available() / 1024L / 1024L) + \"MB, needed: \" + (neededRAM4table / 1024L / 1024L) + \"MB, allocating space for \" + records + \" entries\");\n            final long neededRAM4index = 100L * 1024L * 1024L + records * (rowdef.primaryKeyLength + 4L) * 3L / 2L;\n            if (records > 0 && !MemoryControl.request(neededRAM4index, true)) {\n                // despite calculations seemed to show that there is enough memory for the table AND the index\n                // there is now not enough memory left for the index. So delete the table again to free the memory\n                // for the index\n                Log.logSevere(\"TABLE\", tablefile.getName() + \": not enough RAM (\" + (MemoryControl.available() / 1024L / 1024L) + \"MB) left for index, deleting allocated table space to enable index space allocation (needed: \" + (neededRAM4index / 1024L / 1024L) + \"MB)\");\n                this.table = null; System.gc();\n                Log.logSevere(\"TABLE\", tablefile.getName() + \": RAM after releasing the table: \" + (MemoryControl.available() / 1024L / 1024L) + \"MB\");\n            }\n            this.index = new RowHandleMap(rowdef.primaryKeyLength, rowdef.objectOrder, 4, records, tablefile.getAbsolutePath());\n            final RowHandleMap errors = new RowHandleMap(rowdef.primaryKeyLength, NaturalOrder.naturalOrder, 4, records, tablefile.getAbsolutePath() + \".errors\");\n            Log.logInfo(\"TABLE\", tablefile + \": TABLE \" + tablefile.toString() + \" has table copy \" + ((this.table == null) ? \"DISABLED\" : \"ENABLED\"));\n\n            // read all elements from the file into the copy table\n            Log.logInfo(\"TABLE\", \"initializing RAM index for TABLE \" + tablefile.getName() + \", please wait.\");\n            int i = 0;\n            byte[] key;\n            if (this.table == null) {\n                final Iterator<byte[]> ki = new ChunkIterator(tablefile, rowdef.objectsize, rowdef.primaryKeyLength);\n                while (ki.hasNext()) {\n                    key = ki.next();\n                    // write the key into the index table\n                    assert key != null;\n                    if (key == null) {i++; continue;}\n                    if (rowdef.objectOrder.wellformed(key)) {\n                        this.index.putUnique(key, i++);\n                    } else {\n                        errors.putUnique(key, i++);\n                    }\n                }\n            } else {\n                byte[] record;\n                key = new byte[rowdef.primaryKeyLength];\n                final Iterator<byte[]> ri = new ChunkIterator(tablefile, rowdef.objectsize, rowdef.objectsize);\n                while (ri.hasNext()) {\n                    record = ri.next();\n                    assert record != null;\n                    if (record == null) {i++; continue;}\n                    System.arraycopy(record, 0, key, 0, rowdef.primaryKeyLength);\n\n                    // write the key into the index table\n                    if (rowdef.objectOrder.wellformed(key)) {\n                        this.index.putUnique(key, i++);\n                        // write the tail into the table\n                        try {\n                            this.table.addUnique(this.taildef.newEntry(record, rowdef.primaryKeyLength, true));\n                        } catch (final SpaceExceededException e) {\n                            this.table = null;\n                            break;\n                        }\n                    } else {\n                        errors.putUnique(key, i++);\n                    }\n                }\n                Runtime.getRuntime().gc();\n                if (abandonTable()) {\n                    this.table = null;\n                }\n            }\n            this.index.trim();\n\n            // open the file\n            this.file = new BufferedRecords(new Records(tablefile, rowdef.objectsize), this.buffersize);\n            assert this.file.size() == this.index.size() : \"file.size() = \" + this.file.size() + \", index.size() = \" + this.index.size() + \", file = \" + filename();\n\n            // clean up the file by cleaning badly formed entries\n            final int errorc = errors.size();\n            int errorcc = 0;\n            int idx;\n            for (final Map.Entry<byte[], Long> entry: errors) {\n                idx = (int) entry.getValue().longValue();\n                removeInFile(idx);\n                key = entry.getKey();\n                if (key == null) continue;\n                Log.logWarning(\"Table\", \"removing not well-formed entry \" + idx + \" with key: \" + NaturalOrder.arrayList(key, 0, key.length) + \", \" + errorcc++ + \"/\" + errorc);\n            }\n            errors.close();\n            assert this.file.size() == this.index.size() : \"file.size() = \" + this.file.size() + \", index.size() = \" + this.index.size() + \", file = \" + filename();\n\n            // warm up\n            if (!freshFile && warmUp) {warmUp0();}\n        } catch (final FileNotFoundException e) {\n            // should never happen\n            Log.logSevere(\"Table\", \"\", e);\n            throw new kelondroException(e.getMessage());\n        } catch (final IOException e) {\n            Log.logSevere(\"Table\", \"\", e);\n            throw new kelondroException(e.getMessage());\n        }\n\n        // track this table\n        tableTracker.put(tablefile.toString(), this);\n    }","commit_id":"888a985dc65b768e3560863f2279e7d9c11aade0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Bank[] getLenderList(CreditProfile creditProfile, Double loanAmount)\n    {\n        Bank[] lenders;\n        if ((loanAmount.doubleValue() >= (double) 20000))\n        {\n            lenders = new Bank[2];\n            lenders[0] = new Bank(\"Bank1\", getEndpoint(\"Bank1\"));\n            lenders[1] =new Bank(\"Bank2\", getEndpoint(\"Bank2\"));\n\n        } else if (((loanAmount.doubleValue() >= (double) 10000) && (loanAmount.doubleValue() <= (double) 19999)))\n        {\n            lenders = new Bank[2];\n            lenders[0] = new Bank(\"Bank3\", getEndpoint(\"Bank3\"));\n            lenders[1] = new Bank(\"Bank4\", getEndpoint(\"Bank4\"));\n        } else\n        {\n            lenders = new Bank[1];\n            lenders[0] = new Bank(\"Bank5\", getEndpoint(\"Bank5\"));\n        }\n\n        List recipients = new ArrayList(lenders.length);\n        for (int i =0;i < lenders.length; i++)\n        {\n            recipients.add(lenders[i].getEndpoint());\n        }\n\n        RequestContext.setProperty(\"recipients\", recipients);\n        return lenders;\n    }","id":47664,"modified_method":"public Bank[] getLenderList(CreditProfile creditProfile, Double loanAmount)\n    {\n        Bank[] lenders;\n        if ((loanAmount.doubleValue() >= (double) 20000))\n        {\n            lenders = new Bank[2];\n            lenders[0] = new Bank(\"Bank1\", getEndpoint(\"Bank1\"));\n            lenders[1] =new Bank(\"Bank2\", getEndpoint(\"Bank2\"));\n\n        } else if (((loanAmount.doubleValue() >= (double) 10000) && (loanAmount.doubleValue() <= (double) 19999)))\n        {\n            lenders = new Bank[2];\n            lenders[0] = new Bank(\"Bank3\", getEndpoint(\"Bank3\"));\n            lenders[1] = new Bank(\"Bank4\", getEndpoint(\"Bank4\"));\n        } else\n        {\n            lenders = new Bank[1];\n            lenders[0] = new Bank(\"Bank5\", getEndpoint(\"Bank5\"));\n        }\n\n        StringBuffer recipients = new StringBuffer();\n        for (int i =0;i < lenders.length; i++)\n        {\n            recipients.append(lenders[i].getEndpoint()).append(\",\");\n        }\n\n        RequestContext.setProperty(\"recipients\", recipients.substring(0, recipients.length()-1));\n        return lenders;\n    }","commit_id":"4a12c8df466783143bd8f5a2d1995f1798f9a1c2","url":"https://github.com/mulesoft/mule"},{"original_method":"public static void main(String[] args) {\n        Main loanConsumer = null;\n        int response = 0;\n        try {\n            loanConsumer = new Main(\"mule-config.xml\");\n\n\n            while (response != 'q') {\n                System.out.println(\"\\n[1] make a loan request\");\n                System.out.println(\"[q] quit\");\n                System.out.println(\"\\nPlease make your selection: \");\n\n                response = getSelection();\n                if (response == '1') {\n                    CustomerQuoteRequest request = getRequestFromUser();\n                    loanConsumer.request(request, true);\n                } else if (response == 'q') {\n                    System.out.println(\"Exiting now\");\n                    loanConsumer.close();\n                    System.exit(0);\n                } else {\n                    System.out.println(\"That response is not recognised, try again:\");\n                }\n            }\n\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace(System.err);\n            System.exit(1);\n        }\n    }","id":47665,"modified_method":"public static void main(String[] args) {\n        Main loanConsumer = null;\n        int response = 0;\n        try {\n                System.out.println(StringMessageHelper.getBoilerPlate(\"Welcome to the Mule Loan broker ESB example. This example demonstrates using JMS, Web Services, Http/Rest and EJBs using an ESB topology. \" +\n                        \"\\nFor more information see http://mule.codehaus.org/LoanBroker.\" +\n                        \"\\n\\nThe example demonstrates integrating EJB applications in 2 ways -\" +\n                        \"\\n1. Calling out to a remote EJB using a Mule endpoint.\" +\n                         \"\\n2. Managing an Ejb as a Mule component.  This Allows a remote Ejb to be used in the same way as any other Mule component.\" +\n                         \"\\nBoth behave the same way but but the second method enabled tighter integration\" +\n                         \"\\nPlease select [1], [2] or [q]uit\", '*', 90));\n\n\n                response = getSelection();\n                if (response == '1')\n                {\n                    System.out.println(\"Loading 'Ejb via an Endpoint' version\");\n                    loanConsumer = new Main(\"mule-config.xml\");\n                } else if(response == 'q')\n                {\n                    System.out.println(\"Bye\");\n                    System.exit(0);\n                } else\n                {\n                    System.out.println(\"Loading 'Managed Ejb Component' version\");\n                    loanConsumer = new Main(\"mule-config-with-ejb-container.xml\");\n                }\n\n            while (response != 'q') {\n                System.out.println(\"\\n[1] make a loan request\");\n                System.out.println(\"[q] quit\");\n                System.out.println(\"\\nPlease make your selection: \");\n\n                response = getSelection();\n                if (response == '1') {\n                    CustomerQuoteRequest request = getRequestFromUser();\n                    UMOMessage result = loanConsumer.request(request);\n                    if (result == null) {\n                        System.out.println(\"A result was not received, an error must have occurred. Check the logs.\");\n                    } else {\n                        System.out.println(\"Loan Consumer received a Quote: \" + result.getPayload());\n                    }\n                } else if (response == 'q') {\n                    System.out.println(\"Exiting now\");\n                    loanConsumer.close();\n                    System.exit(0);\n                } else {\n                    System.out.println(\"That response is not recognised, try again:\");\n                }\n            }\n\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace(System.err);\n            System.exit(1);\n        }\n    }","commit_id":"4a12c8df466783143bd8f5a2d1995f1798f9a1c2","url":"https://github.com/mulesoft/mule"},{"original_method":"public Main(String config) throws UMOException {\n        MuleXmlConfigurationBuilder builder = new MuleXmlConfigurationBuilder();\n        builder.configure(config);\n        init();\n    }","id":47666,"modified_method":"public Main(String config) throws UMOException {\n        MuleXmlConfigurationBuilder builder = new MuleXmlConfigurationBuilder();\n        builder.configure(config);\n        client = new MuleClient();\n    }","commit_id":"4a12c8df466783143bd8f5a2d1995f1798f9a1c2","url":"https://github.com/mulesoft/mule"},{"original_method":"public void request(CustomerQuoteRequest request, boolean sync) throws Exception {\n        if (!sync) {\n            client.dispatch(\"vm://LoanBrokerRequests\", request, null);\n            System.out.println(\"Sent Async request\");\n            //let the request catch up\n            Thread.sleep(1500);\n        } else {\n            UMOMessage result = client.send(\"vm://loan.broker.requests\", request, null);\n            if (result == null) {\n                System.out.println(\"A result was not received, an error must have occurred. Check the logs.\");\n            } else {\n                System.out.println(\"Loan Consumer received a Quote: \" + result.getPayload());\n            }\n        }\n    }","id":47667,"modified_method":"public UMOMessage request(CustomerQuoteRequest request) throws Exception {\n         return client.send(\"vm://loan.broker.requests\", request, null);\n    }","commit_id":"4a12c8df466783143bd8f5a2d1995f1798f9a1c2","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public void startNewTask(String name) {\n    List<GitRepository> repositories = myRepositoryManager.getRepositories();\n    myBrancher.checkoutNewBranch(name, repositories);\n  }","id":47668,"modified_method":"@Override\n  public TaskInfo startNewTask(final String taskName) {\n    List<GitRepository> repositories = myRepositoryManager.getRepositories();\n    myBrancher.checkoutNewBranch(taskName, repositories);\n\n    MultiMap<String, String> map = new MultiMap<String, String>();\n    for (GitRepository repository : repositories) {\n      map.putValue(taskName, repository.getPresentableUrl());\n    }\n    return new TaskInfo(map);\n  }","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    TaskManagerImpl taskManager = (TaskManagerImpl)TaskManager.getManager(myProject);\n\n    taskManager.getState().markAsInProgress = isMarkAsInProgress();\n    TaskManager.VcsOperation operation = getVcsOperation();\n    taskManager.getState().vcsOperation = operation.ordinal();\n    if (taskManager.isVcsEnabled()) {\n      taskManager.getState().createChangelist = myCreateChangelist.isSelected();\n    }\n\n    TaskRepository repository = myTask.getRepository();\n    if (isMarkAsInProgress() && repository != null) {\n      try {\n        repository.setTaskState(myTask, TaskState.IN_PROGRESS);\n      }\n      catch (Exception ex) {\n        Messages.showErrorDialog(myProject, \"Could not set state for \" + myTask.getId(), \"Error\");\n        LOG.warn(ex);\n      }\n    }\n    LocalTask localTask = taskManager.activateTask(myTask, isClearContext());\n    taskManager.performVcsOperation(localTask, operation);\n    if (myTask.getType() == TaskType.EXCEPTION && AnalyzeTaskStacktraceAction.hasTexts(myTask)) {\n      AnalyzeTaskStacktraceAction.analyzeStacktrace(myTask, myProject);\n    }\n    super.doOKAction();\n  }","id":47669,"modified_method":"@Override\n  protected void doOKAction() {\n    TaskManagerImpl taskManager = (TaskManagerImpl)TaskManager.getManager(myProject);\n\n    taskManager.getState().markAsInProgress = isMarkAsInProgress();\n    TaskManager.VcsOperation operation = getVcsOperation();\n    taskManager.getState().vcsOperation = operation.ordinal();\n    if (taskManager.isVcsEnabled()) {\n      taskManager.getState().createChangelist = myCreateChangelist.isSelected();\n    }\n\n    TaskRepository repository = myTask.getRepository();\n    if (isMarkAsInProgress() && repository != null) {\n      try {\n        repository.setTaskState(myTask, TaskState.IN_PROGRESS);\n      }\n      catch (Exception ex) {\n        Messages.showErrorDialog(myProject, \"Could not set state for \" + myTask.getId(), \"Error\");\n        LOG.warn(ex);\n      }\n    }\n    LocalTask activeTask = taskManager.getActiveTask();\n    LocalTask localTask = taskManager.activateTask(myTask, isClearContext());\n    taskManager.activateInVcs(localTask, activeTask, operation);\n    if (myTask.getType() == TaskType.EXCEPTION && AnalyzeTaskStacktraceAction.hasTexts(myTask)) {\n      AnalyzeTaskStacktraceAction.analyzeStacktrace(myTask, myProject);\n    }\n    super.doOKAction();\n  }","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testGitTaskHandler() throws Exception {\n\n    List<GitRepository> repositories = initRepositories(\"community\", \"idea\");\n    GitRepository repository = repositories.get(0);\n\n    VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(getProject());\n    assertEquals(1, handlers.length);\n    VcsTaskHandler handler = handlers[0];\n\n    final String first = \"first\";\n    handler.startNewTask(first);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    final String second = \"second\";\n    handler.startNewTask(second);\n    assertEquals(3, repository.getBranches().getLocalBranches().size());\n    assertEquals(second, repository.getCurrentBranch().getName());\n\n    handler.switchTask(first);\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.closeTask(second);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n  }","id":47670,"modified_method":"public void testGitTaskHandler() throws Exception {\n\n    List<GitRepository> repositories = initRepositories(\"community\", \"idea\");\n    GitRepository repository = repositories.get(0);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(getProject());\n    assertEquals(1, handlers.length);\n    VcsTaskHandler handler = handlers[0];\n\n    VcsTaskHandler.TaskInfo defaultInfo = handler.getActiveTask();\n    final String first = \"first\";\n    VcsTaskHandler.TaskInfo firstInfo = handler.startNewTask(first);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(defaultInfo);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    final String second = \"second\";\n    VcsTaskHandler.TaskInfo secondInfo = handler.startNewTask(second);\n    assertEquals(3, repository.getBranches().getLocalBranches().size());\n    assertEquals(second, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(firstInfo);\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.closeTask(secondInfo);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n  }","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract void performVcsOperation(LocalTask task, VcsOperation operation);","id":47671,"modified_method":"public abstract void activateInVcs(LocalTask task, @Nullable LocalTask previousActive, VcsOperation operation);","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void performVcsOperation(LocalTask task, VcsOperation operation) {\n    String name = getChangelistName(task);\n    if (operation == VcsOperation.CREATE_CHANGELIST) {\n      String comment = TaskUtil.getChangeListComment(task);\n      createChangeList(task, name, comment);\n    }\n    else if (operation == VcsOperation.CREATE_BRANCH) {\n      VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(myProject);\n      for (VcsTaskHandler handler : handlers) {\n        handler.startNewTask(name);\n      }\n    }\n  }","id":47672,"modified_method":"@Override\n  public void activateInVcs(LocalTask task, LocalTask previousActive, VcsOperation operation) {\n    String name = getChangelistName(task);\n    if (operation == VcsOperation.CREATE_CHANGELIST) {\n      String comment = TaskUtil.getChangeListComment(task);\n      createChangeList(task, name, comment);\n    }\n    else if (operation == VcsOperation.CREATE_BRANCH) {\n      VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(myProject);\n      if (previousActive != null) {\n\n      }\n      for (VcsTaskHandler handler : handlers) {\n        handler.startNewTask(name);\n      }\n      final BranchInfo info = new BranchInfo();\n      info.name = name;\n      task.addBranch(info);\n    }\n  }","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public LocalTask activateTask(@NotNull final Task origin, boolean clearContext) {\n    LocalTask activeTask = getActiveTask();\n    if (origin.equals(activeTask)) return activeTask;\n\n    saveActiveTask();\n\n    if (clearContext) {\n      myContextManager.clearContext();\n    }\n    myContextManager.restoreContext(origin);\n\n    final LocalTask task = doActivate(origin, true);\n\n    if (!isVcsEnabled()) return task;\n    List<ChangeListInfo> changeLists = task.getChangeLists();\n    if (!changeLists.isEmpty()) {\n      ChangeListInfo info = changeLists.get(0);\n      LocalChangeList changeList = myChangeListManager.getChangeList(info.id);\n      if (changeList == null) {\n        changeList = myChangeListManager.addChangeList(info.name, info.comment);\n        info.id = changeList.getId();\n      }\n      myChangeListManager.setDefaultChangeList(changeList);\n    }\n    return task;\n  }","id":47673,"modified_method":"@Override\n  public LocalTask activateTask(@NotNull final Task origin, boolean clearContext) {\n    LocalTask activeTask = getActiveTask();\n    if (origin.equals(activeTask)) return activeTask;\n\n    saveActiveTask();\n\n    if (clearContext) {\n      myContextManager.clearContext();\n    }\n    myContextManager.restoreContext(origin);\n\n    final LocalTask task = doActivate(origin, true);\n\n    if (!isVcsEnabled()) return task;\n\n    List<ChangeListInfo> changeLists = task.getChangeLists();\n    if (!changeLists.isEmpty()) {\n      ChangeListInfo info = changeLists.get(0);\n      LocalChangeList changeList = myChangeListManager.getChangeList(info.id);\n      if (changeList == null) {\n        changeList = myChangeListManager.addChangeList(info.name, info.comment);\n        info.id = changeList.getId();\n      }\n      myChangeListManager.setDefaultChangeList(changeList);\n    }\n    List<BranchInfo> branches = task.getBranches();\n    if (!branches.isEmpty()) {\n      BranchInfo info = branches.get(0);\n      VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(myProject);\n      for (VcsTaskHandler handler : handlers) {\n//        handler.switchToTask(info.name);\n      }\n    }\n    return task;\n  }","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void activateAndCreateChangelist(Task task) {\n    LocalTask localTask = myTaskManager.activateTask(task, false);\n    if (localTask.getChangeLists().isEmpty()) {\n      myTaskManager.performVcsOperation(localTask, TaskManager.VcsOperation.CREATE_CHANGELIST);\n    }\n  }","id":47674,"modified_method":"private void activateAndCreateChangelist(Task task) {\n    LocalTask activeTask = myTaskManager.getActiveTask();\n    LocalTask localTask = myTaskManager.activateTask(task, false);\n    if (localTask.getChangeLists().isEmpty()) {\n      myTaskManager.activateInVcs(localTask, activeTask, TaskManager.VcsOperation.CREATE_CHANGELIST);\n    }\n  }","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract void startNewTask(String name);","id":47675,"modified_method":"public abstract TaskInfo startNewTask(String taskName);","commit_id":"7da87c3672cc0844b370a1c688e93a9c5e6c8990","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SimpleOpenTaskDialog(@NotNull final Project project, @NotNull final Task task) {\n    super(project, false);\n    myProject = project;\n    myTask = task;\n    TaskManagerImpl taskManager = (TaskManagerImpl)TaskManager.getManager(myProject);\n    setTitle(\"Open Task\");\n    myTaskNameLabel.setText(TaskUtil.getTrimmedSummary(task));\n\n    TaskManagerImpl manager = (TaskManagerImpl)TaskManager.getManager(project);\n    ControlBinder binder = new ControlBinder(manager.getState());\n    binder.bindAnnotations(this);\n    binder.reset();\n\n    TaskRepository repository = task.getRepository();\n    myMarkAsInProgressBox.setSelected(manager.getState().markAsInProgress);\n    if (repository == null || !repository.getRepositoryType().getPossibleTaskStates().contains(TaskState.IN_PROGRESS)) {\n      myMarkAsInProgressBox.setVisible(false);\n    }\n\n    myClearContext.setSelected(taskManager.getState().clearContext);\n\n    myButtonEnumModel = RadioButtonEnumModel.bindEnum(TaskManager.VcsOperation.class, myVcsGroup);\n    AbstractVcs vcs = manager.getActiveVcs();\n    if (vcs == null) {\n      myVcsPanel.setVisible(false);\n      myCreateChangelist.setEnabled(false);\n      myCreateChangelist.setSelected(false);\n    }\n    else {\n      myVcsPanel.setBorder(IdeBorderFactory.createTitledBorder(vcs.getDisplayName() + \" operations\", false));\n      if (/*vcs.getType() == VcsType.distributed*/ false) {\n        myCreateChangelist.setVisible(false);\n        myButtonEnumModel.setSelected(taskManager.getState().vcsOperation);\n      }\n      else {\n        myDistributedVcsPanel.setVisible(false);\n        myCreateChangelist.setSelected(taskManager.getState().createChangelist);\n        myCreateChangelist.setEnabled(true);\n      }\n    }\n    init();\n    getPreferredFocusedComponent();\n  }","id":47676,"modified_method":"public SimpleOpenTaskDialog(@NotNull final Project project, @NotNull final Task task) {\n    super(project, false);\n    myProject = project;\n    myTask = task;\n    TaskManagerImpl taskManager = (TaskManagerImpl)TaskManager.getManager(myProject);\n    setTitle(\"Open Task\");\n    myTaskNameLabel.setText(TaskUtil.getTrimmedSummary(task));\n\n    TaskManagerImpl manager = (TaskManagerImpl)TaskManager.getManager(project);\n    ControlBinder binder = new ControlBinder(manager.getState());\n    binder.bindAnnotations(this);\n    binder.reset();\n\n    TaskRepository repository = task.getRepository();\n    myMarkAsInProgressBox.setSelected(manager.getState().markAsInProgress);\n    if (repository == null || !repository.getRepositoryType().getPossibleTaskStates().contains(TaskState.IN_PROGRESS)) {\n      myMarkAsInProgressBox.setVisible(false);\n    }\n\n    myClearContext.setSelected(taskManager.getState().clearContext);\n\n    myButtonEnumModel = RadioButtonEnumModel.bindEnum(TaskManager.VcsOperation.class, myVcsGroup);\n    AbstractVcs vcs = manager.getActiveVcs();\n    if (vcs == null) {\n      myVcsPanel.setVisible(false);\n      myCreateChangelist.setEnabled(false);\n      myCreateChangelist.setSelected(false);\n    }\n    else {\n      myVcsPanel.setBorder(IdeBorderFactory.createTitledBorder(vcs.getDisplayName() + \" operations\", false));\n      if (vcs.getType() == VcsType.distributed && ApplicationManager.getApplication().isInternal()) {\n        myCreateChangelist.setVisible(false);\n        myButtonEnumModel.setSelected(taskManager.getState().vcsOperation);\n      }\n      else {\n        myDistributedVcsPanel.setVisible(false);\n        myCreateChangelist.setSelected(taskManager.getState().createChangelist);\n        myCreateChangelist.setEnabled(true);\n      }\n    }\n    init();\n    getPreferredFocusedComponent();\n  }","commit_id":"3264d8eaeea1de728482471f81af3a8bfde62d9e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testGitTaskHandler() throws Exception {\n\n    List<GitRepository> repositories = initRepositories(\"community\", \"idea\");\n    GitRepository repository = repositories.get(0);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(getProject());\n    assertEquals(1, handlers.length);\n    VcsTaskHandler handler = handlers[0];\n\n    VcsTaskHandler.TaskInfo defaultInfo = handler.getActiveTask();\n    final String first = \"first\";\n    VcsTaskHandler.TaskInfo firstInfo = handler.startNewTask(first);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(defaultInfo);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    final String second = \"second\";\n    VcsTaskHandler.TaskInfo secondInfo = handler.startNewTask(second);\n    assertEquals(3, repository.getBranches().getLocalBranches().size());\n    assertEquals(second, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(firstInfo);\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.closeTask(secondInfo);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n  }","id":47677,"modified_method":"public void _testGitTaskHandler() throws Exception {\n\n    List<GitRepository> repositories = initRepositories(\"community\", \"idea\");\n    GitRepository repository = repositories.get(0);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(getProject());\n    assertEquals(1, handlers.length);\n    VcsTaskHandler handler = handlers[0];\n\n    VcsTaskHandler.TaskInfo defaultInfo = handler.getActiveTask();\n    final String first = \"first\";\n    VcsTaskHandler.TaskInfo firstInfo = handler.startNewTask(first);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(defaultInfo);\n    assertEquals(\"master\", repository.getCurrentBranch().getName());\n\n    final String second = \"second\";\n    VcsTaskHandler.TaskInfo secondInfo = handler.startNewTask(second);\n    assertEquals(3, repository.getBranches().getLocalBranches().size());\n    assertEquals(second, repository.getCurrentBranch().getName());\n\n    handler.switchToTask(firstInfo);\n    assertEquals(first, repository.getCurrentBranch().getName());\n\n    handler.closeTask(secondInfo);\n    assertEquals(2, repository.getBranches().getLocalBranches().size());\n  }","commit_id":"3264d8eaeea1de728482471f81af3a8bfde62d9e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public LocalTask activateTask(@NotNull final Task origin, boolean clearContext) {\n    LocalTask activeTask = getActiveTask();\n    if (origin.equals(activeTask)) return activeTask;\n\n    saveActiveTask();\n\n    if (clearContext) {\n      myContextManager.clearContext();\n    }\n    myContextManager.restoreContext(origin);\n\n    final LocalTask task = doActivate(origin, true);\n\n    if (!isVcsEnabled()) return task;\n\n    List<ChangeListInfo> changeLists = task.getChangeLists();\n    if (!changeLists.isEmpty()) {\n      ChangeListInfo info = changeLists.get(0);\n      LocalChangeList changeList = myChangeListManager.getChangeList(info.id);\n      if (changeList == null) {\n        changeList = myChangeListManager.addChangeList(info.name, info.comment);\n        info.id = changeList.getId();\n      }\n      myChangeListManager.setDefaultChangeList(changeList);\n    }\n    List<BranchInfo> branches = task.getBranches();\n    if (!branches.isEmpty()) {\n      BranchInfo info = branches.get(0);\n      VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(myProject);\n      for (VcsTaskHandler handler : handlers) {\n//        handler.switchToTask(info.name);\n      }\n    }\n    return task;\n  }","id":47678,"modified_method":"@Override\n  public LocalTask activateTask(@NotNull final Task origin, boolean clearContext) {\n    LocalTask activeTask = getActiveTask();\n    if (origin.equals(activeTask)) return activeTask;\n\n    saveActiveTask();\n\n    if (clearContext) {\n      myContextManager.clearContext();\n    }\n    myContextManager.restoreContext(origin);\n\n    final LocalTask task = doActivate(origin, true);\n\n    return restoreVcsContext(task);\n  }","commit_id":"3264d8eaeea1de728482471f81af3a8bfde62d9e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void activateInVcs(LocalTask task, LocalTask previousActive, VcsOperation operation) {\n    String name = getChangelistName(task);\n    if (operation == VcsOperation.CREATE_CHANGELIST) {\n      String comment = TaskUtil.getChangeListComment(task);\n      createChangeList(task, name, comment);\n    }\n    else if (operation == VcsOperation.CREATE_BRANCH) {\n      VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(myProject);\n      if (previousActive != null) {\n\n      }\n      for (VcsTaskHandler handler : handlers) {\n        handler.startNewTask(name);\n      }\n      final BranchInfo info = new BranchInfo();\n      info.name = name;\n      task.addBranch(info);\n    }\n  }","id":47679,"modified_method":"@Override\n  public void activateInVcs(LocalTask task, LocalTask previousActive, VcsOperation operation) {\n    String name = getChangelistName(task);\n    if (operation == VcsOperation.CREATE_CHANGELIST) {\n      String comment = TaskUtil.getChangeListComment(task);\n      createChangeList(task, name, comment);\n    }\n    else if (operation == VcsOperation.CREATE_BRANCH) {\n      VcsTaskHandler[] handlers = VcsTaskHandler.getAllHandlers(myProject);\n      for (VcsTaskHandler handler : handlers) {\n        if (previousActive != null) {\n          addBranches(previousActive, handler.getActiveTask());\n        }\n        addBranches(task, handler.startNewTask(name));\n      }\n    }\n  }","commit_id":"3264d8eaeea1de728482471f81af3a8bfde62d9e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (SplitFieldToRowsMeta) smi;\n    data = (SplitFieldToRowsData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      data.rownr = 1L;\n\n      try {\n        if ( meta.isDelimiterRegex() ) {\n          data.delimiterPattern = Pattern.compile( environmentSubstitute( meta.getDelimiter() ) );\n        } else {\n          data.delimiterPattern = Pattern.compile( Pattern.quote( environmentSubstitute( meta.getDelimiter() ) ) );\n        }\n      } catch ( PatternSyntaxException pse ) {\n        log.logError( pse.getMessage() );\n        throw pse;\n      }\n\n      return true;\n    }\n    return false;\n  }","id":47680,"modified_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (SplitFieldToRowsMeta) smi;\n    data = (SplitFieldToRowsData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      data.rownr = 1L;\n\n      try {\n        String delimiter = Const.nullToEmpty( meta.getDelimiter() );\n        if ( meta.isDelimiterRegex() ) {\n          data.delimiterPattern = Pattern.compile( environmentSubstitute( delimiter ) );\n        } else {\n          data.delimiterPattern = Pattern.compile( Pattern.quote( environmentSubstitute( delimiter ) ) );\n        }\n      } catch ( PatternSyntaxException pse ) {\n        log.logError( pse.getMessage() );\n        throw pse;\n      }\n\n      return true;\n    }\n    return false;\n  }","commit_id":"47560270a85b39b4767f4db9d19998c182063e6b","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public synchronized boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(SplitFieldToRowsMeta)smi;\n\t\tdata=(SplitFieldToRowsData)sdi;\n\n\t\tObject[] r = getRow();   // get row from rowset, wait for our turn, indicate busy!\n\t\tif (r == null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean ok = splitField(getInputRowMeta(), r);\n\t\tif (!ok)\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\t\n        if (checkFeedback(getLinesRead())) {\n\t\t\tif(log.isBasic()) \n\t\t\t{\n\t\t\t\tif(log.isBasic()) logBasic(Messages.getString(\"SplitFieldToRows.Log.LineNumber\")+getLinesRead()); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","id":47681,"modified_method":"public synchronized boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(SplitFieldToRowsMeta)smi;\n\t\tdata=(SplitFieldToRowsData)sdi;\n\n\t\tObject[] r = getRow();   // get row from rowset, wait for our turn, indicate busy!\n\t\tif (r == null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean ok = splitField(getInputRowMeta(), r);\n\t\tif (!ok)\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\t\t\t\n        if (checkFeedback(getLinesRead())) {\n\t\t\tif(log.isDetailed()) \n\t\t\t{\n\t\t\t\tif(log.isDetailed()) logBasic(Messages.getString(\"SplitFieldToRows.Log.LineNumber\")+getLinesRead()); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta = (SplitFieldToRowsMeta)smi;\n\t\tdata = (SplitFieldToRowsData)sdi;\n\t\t\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t    return true;\n\t\t}\n\t\treturn false;\n\t}","id":47682,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta = (SplitFieldToRowsMeta)smi;\n\t\tdata = (SplitFieldToRowsData)sdi;\n\t\t\n\t\tif (super.init(smi, sdi))\n\t\t{\n\t\t\tdata.rownr = 1L;\n\t\t    return true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean splitField(RowMetaInterface rowMeta, Object[] rowData) throws KettleException\n\t{\n\t\tif (first)\n\t\t{\n\t\t\tfirst = false;\n\t\t\t\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t\t\n\t\t\tdata.fieldnr = rowMeta.indexOfValue(meta.getSplitField());\n\t\t\t\n\t\t\tint numErrors = 0;\n\t\t\tif (Const.isEmpty(meta.getNewFieldname()))\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"SplitFieldToRows.Log.NewFieldNameIsNull\")); //$NON-NLS-1$\n\t\t\t\tnumErrors++;\n\t\t\t}\n\n\t\t\tif (data.fieldnr < 0)\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"SplitFieldToRows.Log.CouldNotFindFieldToSplit\", meta.getSplitField())); //$NON-NLS-1$\n\t\t\t\tnumErrors++;\n\t\t\t}\n\t\t\t\n\t\t\tif (!rowMeta.getValueMeta(data.fieldnr).isString())\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"SplitFieldToRows.Log.SplitFieldNotValid\",meta.getSplitField())); //$NON-NLS-1$\n\t\t\t\tnumErrors++;\n\t\t\t}\n\n\t\t\tif (numErrors > 0)\n\t\t\t{\n\t\t\t\tsetErrors(numErrors);\n\t\t\t\tstopAll();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tdata.splitMeta = rowMeta.getValueMeta(data.fieldnr);\n\t\t}\n\t\t\n\t\tString originalString = data.splitMeta.getString(rowData[data.fieldnr]);\n\t\tif (originalString == null) {\n\t\t\toriginalString = \"\";\n\t\t}\n\t\t\n\t\tSimpleTokenizer tokenizer = new SimpleTokenizer(originalString, meta.getDelimiter());\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\tObject[] outputRow = RowDataUtil.createResizedCopy(rowData, data.outputRowMeta.size());\n\t\t\toutputRow[rowMeta.size()] = tokenizer.nextToken();\n\t\t\tputRow(data.outputRowMeta, outputRow);\n\t\t}\n\t\t\n\t\treturn true;\n\t}","id":47683,"modified_method":"private boolean splitField(RowMetaInterface rowMeta, Object[] rowData) throws KettleException\n\t{\n\t\tif (first)\n\t\t{\n\t\t\tfirst = false;\n\t\t\t\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t\t\n\t\t\tString realSplitFieldName=environmentSubstitute(meta.getSplitField());\n\t\t\tdata.fieldnr = rowMeta.indexOfValue(realSplitFieldName);\n\t\t\t\n\t\t\tint numErrors = 0;\n\t\t\tif (Const.isEmpty(meta.getNewFieldname()))\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"SplitFieldToRows.Log.NewFieldNameIsNull\")); //$NON-NLS-1$\n\t\t\t\tnumErrors++;\n\t\t\t}\n\n\t\t\tif (data.fieldnr < 0)\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"SplitFieldToRows.Log.CouldNotFindFieldToSplit\", realSplitFieldName)); //$NON-NLS-1$\n\t\t\t\tnumErrors++;\n\t\t\t}\n\t\t\t\n\t\t\tif (!rowMeta.getValueMeta(data.fieldnr).isString())\n\t\t\t{\n\t\t\t\tlogError(Messages.getString(\"SplitFieldToRows.Log.SplitFieldNotValid\",realSplitFieldName)); //$NON-NLS-1$\n\t\t\t\tnumErrors++;\n\t\t\t}\n\n\t\t\tif(meta.includeRowNumber())\t\n\t\t\t{\n\t\t\t\tString realRowNumberField=environmentSubstitute(meta.getRowNumberField());\n\t\t\t\tif(Const.isEmpty(realRowNumberField))\n\t\t\t\t{\n\t\t\t\t\tlog.logError(toString(), Messages.getString(\"SplitFieldToRows.Exception.RownrFieldMissing\"));\n\t\t\t\t\tnumErrors++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (numErrors > 0)\n\t\t\t{\n\t\t\t\tsetErrors(numErrors);\n\t\t\t\tstopAll();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tdata.splitMeta = rowMeta.getValueMeta(data.fieldnr);\n\t\t\tdata.realDelimiter=environmentSubstitute(meta.getDelimiter());\n\t\t}\n\t\t\n\t\tString originalString = data.splitMeta.getString(rowData[data.fieldnr]);\n\t\tif (originalString == null) {\n\t\t\toriginalString = \"\";\n\t\t}\n\t\t\n\t\tif(meta.includeRowNumber() && meta.resetRowNumber()) data.rownr=1L;\n\t\t\n\t\tSimpleTokenizer tokenizer = new SimpleTokenizer(originalString, data.realDelimiter);\n\t\twhile (tokenizer.hasMoreTokens()) {\n\t\t\tObject[] outputRow = RowDataUtil.createResizedCopy(rowData, data.outputRowMeta.size());\n\t\t\toutputRow[rowMeta.size()] = tokenizer.nextToken();\n\t\t\t// Include row number in output?\n\t\t\tif(meta.includeRowNumber())\n\t\t\t{\n\t\t\t\toutputRow[rowMeta.size()+1]=data.rownr;\n\t\t\t}\n\t\t\tputRow(data.outputRowMeta, outputRow);\n\t\t\tdata.rownr ++;\n\t\t}\n\t\t\n\t\treturn true;\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public SplitFieldToRowsData()\n\t{\n\t\tsuper();\n\t}","id":47684,"modified_method":"public SplitFieldToRowsData()\n\t{\n\t\tsuper();\n\t\trealDelimiter=null;\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getData()\n\t{\t\n\t\twStepname.selectAll();\n\n\t\twSplitfield.setText(Const.NVL(input.getSplitField(), \"\"));\n\t\twDelimiter.setText(Const.NVL(input.getDelimiter(), \"\"));\n\t\twValName.setText(Const.NVL(input.getNewFieldname(), \"\"));\n\t}","id":47685,"modified_method":"public void getData()\n\t{\t\n\t\twStepname.selectAll();\n\n\t\twSplitfield.setText(Const.NVL(input.getSplitField(), \"\"));\n\t\twDelimiter.setText(Const.NVL(input.getDelimiter(), \"\"));\n\t\twValName.setText(Const.NVL(input.getNewFieldname(), \"\"));\n\t\twInclRownum.setSelection(input.includeRowNumber());\n\t\tif (input.getRowNumberField()!=null) wInclRownumField.setText(input.getRowNumberField());\n\t\twResetRownum.setSelection(input.resetRowNumber());\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"SplitFieldToRowsDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"SplitFieldToRowsDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Typefield line\n\t\twlSplitfield=new Label(shell, SWT.RIGHT);\n\t\twlSplitfield.setText(Messages.getString(\"SplitFieldToRowsDialog.SplitField.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSplitfield);\n\t\tfdlSplitfield=new FormData();\n\t\tfdlSplitfield.left = new FormAttachment(0, 0);\n\t\tfdlSplitfield.right= new FormAttachment(middle, -margin);\n\t\tfdlSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\twlSplitfield.setLayoutData(fdlSplitfield);\n\t\twSplitfield=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSplitfield.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wSplitfield);\n\t\twSplitfield.addModifyListener(lsMod);\n\t\tfdSplitfield=new FormData();\n\t\tfdSplitfield.left = new FormAttachment(middle, 0);\n\t\tfdSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\tfdSplitfield.right= new FormAttachment(100, 0);\n\t\twSplitfield.setLayoutData(fdSplitfield);\n\n\t\t// Typefield line\n\t\twlDelimiter=new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"SplitFieldToRowsDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tfdlDelimiter=new FormData();\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\tfdlDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\n\t\twDelimiter=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twDelimiter.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tfdDelimiter=new FormData();\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\tfdDelimiter.right= new FormAttachment(100, 0);\n\t\twDelimiter.setLayoutData(fdDelimiter);\n\n\t\t// ValName line\n\t\twlValName=new Label(shell, SWT.RIGHT);\n\t\twlValName.setText(Messages.getString(\"SplitFieldToRowsDialog.NewFieldName.Label\")); //$NON-NLS-1$\n        props.setLook( wlValName );\n\t\tfdlValName=new FormData();\n\t\tfdlValName.left = new FormAttachment(0, 0);\n\t\tfdlValName.right= new FormAttachment(middle, -margin);\n\t\tfdlValName.top  = new FormAttachment(wDelimiter, margin);\n\t\twlValName.setLayoutData(fdlValName);\n\t\twValName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twValName.setText(\"\"); //$NON-NLS-1$\n        props.setLook( wValName );\n\t\twValName.addModifyListener(lsMod);\n\t\tfdValName=new FormData();\n\t\tfdValName.left = new FormAttachment(middle, 0);\n\t\tfdValName.right= new FormAttachment(100, 0);\n\t\tfdValName.top  = new FormAttachment(wDelimiter, margin);\n\t\twValName.setLayoutData(fdValName);\n\n        wOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n        BaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel}, margin, wValName);\n        \n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twValName.addSelectionListener( lsDef );\n\t\t\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t    if (!display.readAndDispatch()) {\n\t\t\t\tdisplay.sleep();\n\t\t\t}\n\t\t}\n\t\treturn stepname;\n\t}","id":47686,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"SplitFieldToRowsDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"SplitFieldToRowsDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\n\t\t// Typefield line\n\t\twlSplitfield=new Label(shell, SWT.RIGHT);\n\t\twlSplitfield.setText(Messages.getString(\"SplitFieldToRowsDialog.SplitField.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlSplitfield);\n\t\tfdlSplitfield=new FormData();\n\t\tfdlSplitfield.left = new FormAttachment(0, 0);\n\t\tfdlSplitfield.right= new FormAttachment(middle, -margin);\n\t\tfdlSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\twlSplitfield.setLayoutData(fdlSplitfield);\n\t\t\n\t\twSplitfield=new ComboVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twSplitfield.setToolTipText(Messages.getString(\"HTTPDialog.UrlField.Tooltip\"));\n\t\tprops.setLook(wSplitfield);\n\t\twSplitfield.addModifyListener(lsMod);\n\t\tfdSplitfield=new FormData();\n\t\tfdSplitfield.left = new FormAttachment(middle, 0);\n\t\tfdSplitfield.top  = new FormAttachment(wStepname, margin);\n\t\tfdSplitfield.right= new FormAttachment(100, 0);\n\t\twSplitfield.setLayoutData(fdSplitfield);\n\t\twSplitfield.addFocusListener(new FocusListener()\n         {\n            public void focusLost(org.eclipse.swt.events.FocusEvent e)\n             {\n             }\n             public void focusGained(org.eclipse.swt.events.FocusEvent e)\n             {\n                 Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\n                 shell.setCursor(busy);\n                 BaseStepDialog.getFieldsFromPrevious(wSplitfield, transMeta, stepMeta);\n                 shell.setCursor(null);\n                 busy.dispose();\n             }\n         }\n     );\n\n\t\t// Delimiter line\n\t\twlDelimiter=new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"SplitFieldToRowsDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tfdlDelimiter=new FormData();\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\tfdlDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\n\t\twDelimiter=new TextVar(transMeta,shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twDelimiter.setText(\"\"); //$NON-NLS-1$\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tfdDelimiter=new FormData();\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.top  = new FormAttachment(wSplitfield, margin);\n\t\tfdDelimiter.right= new FormAttachment(100, 0);\n\t\twDelimiter.setLayoutData(fdDelimiter);\n\n\t\t// ValName line\n\t\twlValName=new Label(shell, SWT.RIGHT);\n\t\twlValName.setText(Messages.getString(\"SplitFieldToRowsDialog.NewFieldName.Label\")); //$NON-NLS-1$\n        props.setLook( wlValName );\n\t\tfdlValName=new FormData();\n\t\tfdlValName.left = new FormAttachment(0, 0);\n\t\tfdlValName.right= new FormAttachment(middle, -margin);\n\t\tfdlValName.top  = new FormAttachment(wDelimiter, margin);\n\t\twlValName.setLayoutData(fdlValName);\n\t\twValName=new TextVar(transMeta,shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twValName.setText(\"\"); //$NON-NLS-1$\n        props.setLook( wValName );\n\t\twValName.addModifyListener(lsMod);\n\t\tfdValName=new FormData();\n\t\tfdValName.left = new FormAttachment(middle, 0);\n\t\tfdValName.right= new FormAttachment(100, 0);\n\t\tfdValName.top  = new FormAttachment(wDelimiter, margin);\n\t\twValName.setLayoutData(fdValName);\n\n\t\t///////////////////////////////// \n\t\t// START OF Additional Fields GROUP  //\n\t\t///////////////////////////////// \n\n\t\twAdditionalFields = new Group(shell, SWT.SHADOW_NONE);\n\t\tprops.setLook(wAdditionalFields);\n\t\twAdditionalFields.setText(Messages.getString(\"SplitFieldToRowsDialog.wAdditionalFields.Label\"));\n\t\t\n\t\tFormLayout AdditionalFieldsgroupLayout = new FormLayout();\n\t\tAdditionalFieldsgroupLayout.marginWidth = 10;\n\t\tAdditionalFieldsgroupLayout.marginHeight = 10;\n\t\twAdditionalFields.setLayout(AdditionalFieldsgroupLayout);\n\t\t\n\t\twlInclRownum=new Label(wAdditionalFields, SWT.RIGHT);\n\t\twlInclRownum.setText(Messages.getString(\"SplitFieldToRowsDialog.InclRownum.Label\"));\n \t\tprops.setLook(wlInclRownum);\n\t\tfdlInclRownum=new FormData();\n\t\tfdlInclRownum.left = new FormAttachment(0, 0);\n\t\tfdlInclRownum.top  = new FormAttachment(wValName, margin);\n\t\tfdlInclRownum.right= new FormAttachment(middle, -margin);\n\t\twlInclRownum.setLayoutData(fdlInclRownum);\n\t\twInclRownum=new Button(wAdditionalFields, SWT.CHECK );\n \t\tprops.setLook(wInclRownum);\n\t\twInclRownum.setToolTipText(Messages.getString(\"SplitFieldToRowsDialog.InclRownum.Tooltip\"));\n\t\tfdRownum=new FormData();\n\t\tfdRownum.left = new FormAttachment(middle, 0);\n\t\tfdRownum.top  = new FormAttachment(wValName, margin);\n\t\twInclRownum.setLayoutData(fdRownum);\n\t\twInclRownum.addSelectionListener(new SelectionAdapter() \n\t\t{\n\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t{\n\t\t\t\tsetIncludeRownum();\n\t\t\t}\n\t\t}\n\t);\n\n\t\twlInclRownumField=new Label(wAdditionalFields, SWT.RIGHT);\n\t\twlInclRownumField.setText(Messages.getString(\"SplitFieldToRowsDialog.InclRownumField.Label\"));\n \t\tprops.setLook(wlInclRownumField);\n\t\tfdlInclRownumField=new FormData();\n\t\tfdlInclRownumField.left = new FormAttachment(wInclRownum, margin);\n\t\tfdlInclRownumField.top  = new FormAttachment(wValName, margin);\n\t\twlInclRownumField.setLayoutData(fdlInclRownumField);\n\t\twInclRownumField=new TextVar(transMeta,wAdditionalFields, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wInclRownumField);\n\t\twInclRownumField.addModifyListener(lsMod);\n\t\tfdInclRownumField=new FormData();\n\t\tfdInclRownumField.left = new FormAttachment(wlInclRownumField, margin);\n\t\tfdInclRownumField.top  = new FormAttachment(wValName, margin);\n\t\tfdInclRownumField.right= new FormAttachment(100, 0);\n\t\twInclRownumField.setLayoutData(fdInclRownumField);\n\t\t\n\t\t\n\t\twlResetRownum=new Label(wAdditionalFields, SWT.RIGHT);\n\t\twlResetRownum.setText(Messages.getString(\"SplitFieldToRowsDialog.ResetRownum.Label\"));\n \t\tprops.setLook(wlResetRownum);\n\t\tfdlResetRownum=new FormData();\n\t\tfdlResetRownum.left = new FormAttachment(wInclRownum, margin);\n\t\tfdlResetRownum.top  = new FormAttachment(wInclRownumField, margin);\n\t\twlResetRownum.setLayoutData(fdlResetRownum);\n\t\twResetRownum=new Button(wAdditionalFields, SWT.CHECK );\n \t\tprops.setLook(wResetRownum);\n\t\twResetRownum.setToolTipText(Messages.getString(\"SplitFieldToRowsDialog.ResetRownum.Tooltip\"));\n\t\tfdRownum=new FormData();\n\t\tfdRownum.left = new FormAttachment(wlResetRownum, margin);\n\t\tfdRownum.top  = new FormAttachment(wInclRownumField, margin);\t\n\t\twResetRownum.setLayoutData(fdRownum);\n\t\t\n\t\t\n\t\tfdAdditionalFields = new FormData();\n\t\tfdAdditionalFields.left = new FormAttachment(0, margin);\n\t\tfdAdditionalFields.top = new FormAttachment(wValName, margin);\n\t\tfdAdditionalFields.right = new FormAttachment(100, -margin);\n\t\twAdditionalFields.setLayoutData(fdAdditionalFields);\n\t\t\n\t\t///////////////////////////////// \n\t\t// END OF Additional Fields GROUP  //\n\t\t///////////////////////////////// \n\t\t\n\t\t\n        wOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\n        BaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel}, margin, wAdditionalFields);\n        \n\t\t// Add listeners\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\t\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twValName.addSelectionListener( lsDef );\n\t\t\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t    if (!display.readAndDispatch()) {\n\t\t\t\tdisplay.sleep();\n\t\t\t}\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\n\t\tstepname = wStepname.getText(); // return value\n\t\tinput.setSplitField( wSplitfield.getText() );\n\t\tinput.setDelimiter( wDelimiter.getText() );\n\t\tinput.setNewFieldname(wValName.getText());\n\t\tdispose();\n\t}","id":47687,"modified_method":"private void ok()\n\t{\n\t\tif (Const.isEmpty(wStepname.getText())) return;\n\t\t\n\t\tstepname = wStepname.getText(); // return value\n\t\tinput.setSplitField( wSplitfield.getText() );\n\t\tinput.setDelimiter( wDelimiter.getText() );\n\t\tinput.setNewFieldname(wValName.getText());\n\t\tinput.setIncludeRowNumber( wInclRownum.getSelection() );\n\t\tinput.setRowNumberField( wInclRownumField.getText() );\n\t\tinput.setResetRowNumber( wResetRownum.getSelection() );\n\t\tdispose();\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getFields(RowMetaInterface row, String name, RowMetaInterface[] info, StepMeta nextStep, VariableSpace space) throws KettleStepException {\n\t\t\n\t\tValueMetaInterface v = new ValueMeta(newFieldname, ValueMetaInterface.TYPE_STRING);\n\t\tv.setOrigin(name);\n\t\t\n\t\trow.addValueMeta( v );\n\t}","id":47688,"modified_method":"public void getFields(RowMetaInterface row, String name, RowMetaInterface[] info, StepMeta nextStep, VariableSpace space) throws KettleStepException {\n\t\t\n\t\tValueMetaInterface v = new ValueMeta(newFieldname, ValueMetaInterface.TYPE_STRING);\n\t\tv.setOrigin(name);\n\t\trow.addValueMeta( v );\n\t\t\n\t\t// include row number\n\t\tif (includeRowNumber)\n\t\t{\n\t\t\tv = new ValueMeta(space.environmentSubstitute(rowNumberField), ValueMeta.TYPE_INTEGER);\n\t\t\tv.setLength(ValueMetaInterface.DEFAULT_INTEGER_LENGTH, 0);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValueMeta(v);\n\t\t}\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta, RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info) {\n\t\tString error_message=\"\"; //$NON-NLS-1$\n\t\tCheckResult cr;\n\t\t\n\t\t// Look up fields in the input stream <prev>\n\t\tif (prev!=null && prev.size()>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.StepReceivingFields\",prev.size()+\"\"), stepMeta); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tremarks.add(cr);\n\t\t\t\n\t\t\terror_message = \"\"; //$NON-NLS-1$\n\t\t\t\n\t\t\tValueMetaInterface v = prev.searchValueMeta(splitField);\n\t\t\tif (v==null)\n\t\t\t{\n\t\t\t\terror_message=Messages.getString(\"SplitFieldToRowsMeta.CheckResult.FieldToSplitNotPresentInInputStream\" , splitField); //$NON-NLS-1$ \n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.FieldToSplitFoundInInputStream\" , splitField), stepMeta); //$NON-NLS-1$ \n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message=Messages.getString(\"SplitFieldToRowsMeta.CheckResult.CouldNotReadFieldsFromPreviousStep\")+Const.CR; //$NON-NLS-1$\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.StepReceivingInfoFromOtherStep\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.NoInputReceivedFromOtherStep\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\tif (Const.isEmpty(newFieldname))\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.NewFieldNameIsNull\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","id":47689,"modified_method":"public void check(List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta, RowMetaInterface prev, String[] input, String[] output, RowMetaInterface info) {\n\t\tString error_message=\"\"; //$NON-NLS-1$\n\t\tCheckResult cr;\n\t\t\n\t\t// Look up fields in the input stream <prev>\n\t\tif (prev!=null && prev.size()>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.StepReceivingFields\",prev.size()+\"\"), stepMeta); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tremarks.add(cr);\n\t\t\t\n\t\t\terror_message = \"\"; //$NON-NLS-1$\n\t\t\t\n\t\t\tValueMetaInterface v = prev.searchValueMeta(splitField);\n\t\t\tif (v==null)\n\t\t\t{\n\t\t\t\terror_message=Messages.getString(\"SplitFieldToRowsMeta.CheckResult.FieldToSplitNotPresentInInputStream\" , splitField); //$NON-NLS-1$ \n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.FieldToSplitFoundInInputStream\" , splitField), stepMeta); //$NON-NLS-1$ \n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message=Messages.getString(\"SplitFieldToRowsMeta.CheckResult.CouldNotReadFieldsFromPreviousStep\")+Const.CR; //$NON-NLS-1$\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\n\t\t// See if we have input streams leading to this step!\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.StepReceivingInfoFromOtherStep\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.NoInputReceivedFromOtherStep\"), stepMeta); //$NON-NLS-1$\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\tif (Const.isEmpty(newFieldname))\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.NewFieldNameIsNull\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\tif(includeRowNumber)\n\t\t{\n\t\t\tif(Const.isEmpty(transMeta.environmentSubstitute(rowNumberField)))\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.RowNumberFieldMissing\"), stepMeta);\n\t\t\telse\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"SplitFieldToRowsMeta.CheckResult.RowNumberFieldOk\"), stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsplitField = XMLHandler.getTagValue(stepnode, \"splitfield\"); //$NON-NLS-1$\n\t\t\tdelimiter  = XMLHandler.getTagValue(stepnode, \"delimiter\"); //$NON-NLS-1$\n\t\t\tnewFieldname = XMLHandler.getTagValue(stepnode, \"newfield\"); //$NON-NLS-1$\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"SplitFieldToRowsMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\n\t\t}\n\t}","id":47690,"modified_method":"private void readData(Node stepnode)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsplitField = XMLHandler.getTagValue(stepnode, \"splitfield\"); //$NON-NLS-1$\n\t\t\tdelimiter  = XMLHandler.getTagValue(stepnode, \"delimiter\"); //$NON-NLS-1$\n\t\t\tnewFieldname = XMLHandler.getTagValue(stepnode, \"newfield\"); //$NON-NLS-1$\n\t\t\tincludeRowNumber  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"rownum\"));\n\t\t\tresetRowNumber  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"resetrownumber\"));\n\t\t\trowNumberField    = XMLHandler.getTagValue(stepnode, \"rownum_field\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"SplitFieldToRowsMeta.Exception.UnableToLoadStepInfoFromXML\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException {\n\t\ttry\n\t\t{\n\t\t\tsplitField  = rep.getStepAttributeString(id_step, \"splitfield\"); //$NON-NLS-1$\n\t\t\tdelimiter   = rep.getStepAttributeString(id_step, \"delimiter\"); //$NON-NLS-1$\n\t\t\tnewFieldname  = rep.getStepAttributeString(id_step, \"newfield\"); //$NON-NLS-1$\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SplitFieldToRowsMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\n\t\t}\n\t}","id":47691,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException {\n\t\ttry\n\t\t{\n\t\t\tsplitField  = rep.getStepAttributeString(id_step, \"splitfield\"); //$NON-NLS-1$\n\t\t\tdelimiter   = rep.getStepAttributeString(id_step, \"delimiter\"); //$NON-NLS-1$\n\t\t\tnewFieldname  = rep.getStepAttributeString(id_step, \"newfield\"); //$NON-NLS-1$\n\t\t\tincludeRowNumber  = rep.getStepAttributeBoolean(id_step, \"rownum\");\n\t\t\trowNumberField    = rep.getStepAttributeString (id_step, \"rownum_field\");\n\t\t\tresetRowNumber     = rep.getStepAttributeBoolean (id_step, \"reset_rownumber\");\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SplitFieldToRowsMeta.Exception.UnexpectedErrorInReadingStepInfo\"), e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer();\n\n\t\tretval.append(\"   \"+XMLHandler.addTagValue(\"splitfield\", splitField)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"   \"+XMLHandler.addTagValue(\"delimiter\", delimiter)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"   \"+XMLHandler.addTagValue(\"newfield\", newFieldname)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n\t\treturn retval.toString();\n\t}","id":47692,"modified_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer();\n\n\t\tretval.append(\"   \"+XMLHandler.addTagValue(\"splitfield\", splitField)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"   \"+XMLHandler.addTagValue(\"delimiter\", delimiter)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"   \"+XMLHandler.addTagValue(\"newfield\", newFieldname)); //$NON-NLS-1$ //$NON-NLS-2$\n        retval.append(\"   \"+XMLHandler.addTagValue(\"rownum\",          includeRowNumber));\n        retval.append(\"   \"+XMLHandler.addTagValue(\"rownum_field\",    rowNumberField));\n        retval.append(\"   \"+XMLHandler.addTagValue(\"resetrownumber\",  resetRowNumber));\n\t\t\n\t\treturn retval.toString();\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"splitfield\", splitField); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"delimiter\",  delimiter); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"newfield\",  newFieldname); //$NON-NLS-1$\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SplitFieldToRowsMeta.Exception.UnableToSaveStepInfoToRepository\")+id_step, e); //$NON-NLS-1$\n\t\t}\n\t}","id":47693,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"splitfield\", splitField); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"delimiter\",  delimiter); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"newfield\",  newFieldname); //$NON-NLS-1$\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownum\",          includeRowNumber);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"reset_rownumber\",  resetRowNumber);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"rownum_field\",    rowNumberField);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"SplitFieldToRowsMeta.Exception.UnableToSaveStepInfoToRepository\")+id_step, e); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDefault()\n\t{\n\t\tsplitField = \"\"; //$NON-NLS-1$\n\t\tdelimiter  = \";\"; //$NON-NLS-1$\n\t\tnewFieldname = \"\";\n\t}","id":47694,"modified_method":"public void setDefault()\n\t{\n\t\tsplitField = \"\"; //$NON-NLS-1$\n\t\tdelimiter  = \";\"; //$NON-NLS-1$\n\t\tnewFieldname = \"\";\n\t\tincludeRowNumber = false;\n\t\trowNumberField   = \"\";\n\t\tresetRowNumber=true;\n\t}","commit_id":"7939ac47b90e84825f38463955b4ea5f760e2460","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void registerHttp(Container container) throws Exception {\n        int httpPort = getHttpPort(container);\n        int httpConnectionPort = getHttpConnectionPort(container);\n        String httpUrl = getHttpUrl(container.getId(), httpConnectionPort);\n        setData(curator, CONTAINER_HTTP.getPath(container.getId()), httpUrl);\n        fabricService.getPortService().registerPort(container, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n        Configuration configuration = configurationAdmin.getConfiguration(HTTP_PID);\n        updateIfNeeded(configuration, HTTP_BINDING_PORT_KEY, httpPort);\n    }","id":47695,"modified_method":"private void registerHttp(Container container) throws Exception {\n        boolean httpEnabled = isHttpEnabled();\n        boolean httpsEnabled = isHttpsEnabled();\n        String protocol = httpsEnabled && !httpEnabled ? \"https\" : \"http\";\n        int httpPort = httpsEnabled && !httpEnabled ? getHttpsPort(container) : getHttpPort(container);\n        int httpConnectionPort = httpsEnabled && !httpEnabled ? getHttpConnectionPort(container) : getHttpsConnectionPort(container);\n        String httpUrl = getHttpUrl(protocol, container.getId(), httpConnectionPort);\n        setData(curator, CONTAINER_HTTP.getPath(container.getId()), httpUrl);\n        fabricService.getPortService().registerPort(container, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n        Configuration configuration = configurationAdmin.getConfiguration(HTTP_PID);\n        updateIfNeeded(configuration, HTTP_BINDING_PORT_KEY, httpPort);\n    }","commit_id":"652ba84a127acfef8c34a8e7301750d22d4f3bf0","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Receives notification of a Configuration that has changed.\n     *\n     * @param event The <code>ConfigurationEvent<\/code>.\n     */\n    @Override\n    public void configurationEvent(ConfigurationEvent event) {\n        try {\n            Container current = getContainer();\n\n            String name = System.getProperty(SystemProperties.KARAF_NAME);\n            if (event.getPid().equals(SSH_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                Configuration config = configurationAdmin.getConfiguration(SSH_PID);\n                int sshPort = Integer.parseInt((String) config.getProperties().get(SSH_BINDING_PORT_KEY));\n                int sshConnectionPort = getSshConnectionPort(current);\n                String sshUrl = getSshUrl(name, sshConnectionPort);\n                setData(curator, CONTAINER_SSH.getPath(name), sshUrl);\n                if (fabricService.getPortService().lookupPort(current, SSH_PID, SSH_BINDING_PORT_KEY) != sshPort) {\n                    fabricService.getPortService().unRegisterPort(current, SSH_PID);\n                    fabricService.getPortService().registerPort(current, SSH_PID, SSH_BINDING_PORT_KEY, sshPort);\n                }\n            }\n            if (event.getPid().equals(HTTP_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                Configuration config = configurationAdmin.getConfiguration(HTTP_PID);\n                int httpPort = Integer.parseInt((String) config.getProperties().get(HTTP_BINDING_PORT_KEY));\n                int httpConnectionPort = getHttpConnectionPort(current);\n                String httpUrl = getHttpUrl(name, httpConnectionPort);\n                setData(curator, CONTAINER_HTTP.getPath(name), httpUrl);\n                if (fabricService.getPortService().lookupPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY) != httpPort) {\n                    fabricService.getPortService().unRegisterPort(current, HTTP_PID);\n                    fabricService.getPortService().registerPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n                }\n            }\n            if (event.getPid().equals(MANAGEMENT_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                Configuration config = configurationAdmin.getConfiguration(MANAGEMENT_PID);\n                int rmiServerPort = Integer.parseInt((String) config.getProperties().get(RMI_SERVER_BINDING_PORT_KEY));\n                int rmiServerConnectionPort = getRmiServerConnectionPort(current);\n                int rmiRegistryPort = Integer.parseInt((String) config.getProperties().get(RMI_REGISTRY_BINDING_PORT_KEY));\n                int rmiRegistryConnectionPort = getRmiRegistryPort(current);\n                String jmxUrl = getJmxUrl(name, rmiServerConnectionPort, rmiRegistryConnectionPort);\n                setData(curator, CONTAINER_JMX.getPath(name), jmxUrl);\n                if (fabricService.getPortService().lookupPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY) != rmiRegistryPort\n                        || fabricService.getPortService().lookupPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY) != rmiServerPort) {\n                    fabricService.getPortService().unRegisterPort(current, MANAGEMENT_PID);\n                    fabricService.getPortService().registerPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY, rmiServerPort);\n                    fabricService.getPortService().registerPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY, rmiRegistryPort);\n                }\n\n            }\n        } catch (Exception e) {\n\n        }\n    }","id":47696,"modified_method":"/**\n     * Receives notification of a Configuration that has changed.\n     *\n     * @param event The <code>ConfigurationEvent<\/code>.\n     */\n    @Override\n    public void configurationEvent(ConfigurationEvent event) {\n        try {\n            Container current = getContainer();\n\n            String name = System.getProperty(SystemProperties.KARAF_NAME);\n            if (event.getPid().equals(SSH_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                Configuration config = configurationAdmin.getConfiguration(SSH_PID);\n                int sshPort = Integer.parseInt((String) config.getProperties().get(SSH_BINDING_PORT_KEY));\n                int sshConnectionPort = getSshConnectionPort(current);\n                String sshUrl = getSshUrl(name, sshConnectionPort);\n                setData(curator, CONTAINER_SSH.getPath(name), sshUrl);\n                if (fabricService.getPortService().lookupPort(current, SSH_PID, SSH_BINDING_PORT_KEY) != sshPort) {\n                    fabricService.getPortService().unRegisterPort(current, SSH_PID);\n                    fabricService.getPortService().registerPort(current, SSH_PID, SSH_BINDING_PORT_KEY, sshPort);\n                }\n            }\n            if (event.getPid().equals(HTTP_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                Configuration config = configurationAdmin.getConfiguration(HTTP_PID);\n                boolean httpEnabled = isHttpEnabled();\n                boolean httpsEnabled = isHttpsEnabled();\n                String protocol = httpsEnabled && !httpEnabled ? \"https\" : \"http\";\n                int httpPort = httpsEnabled && !httpEnabled ? Integer.parseInt((String) config.getProperties().get(HTTPS_BINDING_PORT_KEY)) : Integer.parseInt((String) config.getProperties().get(HTTP_BINDING_PORT_KEY)) ;\n                int httpConnectionPort =  httpsEnabled && !httpEnabled ? getHttpsConnectionPort(current) : getHttpConnectionPort(current);\n                String httpUrl = getHttpUrl(protocol, name, httpConnectionPort);\n                setData(curator, CONTAINER_HTTP.getPath(name), httpUrl);\n                if (fabricService.getPortService().lookupPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY) != httpPort) {\n                    fabricService.getPortService().unRegisterPort(current, HTTP_PID);\n                    fabricService.getPortService().registerPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n                }\n            }\n            if (event.getPid().equals(MANAGEMENT_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                Configuration config = configurationAdmin.getConfiguration(MANAGEMENT_PID);\n                int rmiServerPort = Integer.parseInt((String) config.getProperties().get(RMI_SERVER_BINDING_PORT_KEY));\n                int rmiServerConnectionPort = getRmiServerConnectionPort(current);\n                int rmiRegistryPort = Integer.parseInt((String) config.getProperties().get(RMI_REGISTRY_BINDING_PORT_KEY));\n                int rmiRegistryConnectionPort = getRmiRegistryPort(current);\n                String jmxUrl = getJmxUrl(name, rmiServerConnectionPort, rmiRegistryConnectionPort);\n                setData(curator, CONTAINER_JMX.getPath(name), jmxUrl);\n                if (fabricService.getPortService().lookupPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY) != rmiRegistryPort\n                        || fabricService.getPortService().lookupPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY) != rmiServerPort) {\n                    fabricService.getPortService().unRegisterPort(current, MANAGEMENT_PID);\n                    fabricService.getPortService().registerPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY, rmiServerPort);\n                    fabricService.getPortService().registerPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY, rmiRegistryPort);\n                }\n\n            }\n        } catch (Exception e) {\n\n        }\n    }","commit_id":"652ba84a127acfef8c34a8e7301750d22d4f3bf0","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private String getHttpUrl(String name, int httpConnectionPort) throws IOException, KeeperException, InterruptedException {\n        return \"http://${zk:\" + name + \"/ip}:\" + httpConnectionPort;\n    }","id":47697,"modified_method":"private String getHttpUrl(String protocol, String name, int httpConnectionPort) throws IOException, KeeperException, InterruptedException {\n        return protocol+\"://${zk:\" + name + \"/ip}:\" + httpConnectionPort;\n    }","commit_id":"652ba84a127acfef8c34a8e7301750d22d4f3bf0","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void registerHttp(Container container) throws Exception {\n        boolean httpEnabled = isHttpEnabled();\n        boolean httpsEnabled = isHttpsEnabled();\n        String protocol = httpsEnabled && !httpEnabled ? \"https\" : \"http\";\n        int httpPort = httpsEnabled && !httpEnabled ? getHttpsPort(container) : getHttpPort(container);\n        int httpConnectionPort = httpsEnabled && !httpEnabled ? getHttpsConnectionPort(container) : getHttpConnectionPort(container);\n        String httpUrl = getHttpUrl(protocol, container.getId(), httpConnectionPort);\n        setData(curator.get(), CONTAINER_HTTP.getPath(container.getId()), httpUrl);\n        fabricService.get().getPortService().registerPort(container, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n        Configuration configuration = configAdmin.get().getConfiguration(HTTP_PID, null);\n        updateIfNeeded(configuration, HTTP_BINDING_PORT_KEY, httpPort);\n    }","id":47698,"modified_method":"private void registerHttp(Container container) throws Exception {\n        boolean httpEnabled = isHttpEnabled();\n        boolean httpsEnabled = isHttpsEnabled();\n        String protocol = httpsEnabled && !httpEnabled ? \"https\" : \"http\";\n        int httpConnectionPort = httpsEnabled && !httpEnabled ? getHttpsConnectionPort(container) : getHttpConnectionPort(container);\n        String httpUrl = getHttpUrl(protocol, container.getId(), httpConnectionPort);\n        setData(curator.get(), CONTAINER_HTTP.getPath(container.getId()), httpUrl);\n        if(httpEnabled){\n        \tint httpPort = getHttpPort(container);\n        \tfabricService.get().getPortService().registerPort(container, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n        \tConfiguration configuration = configAdmin.get().getConfiguration(HTTP_PID, null);\n        \tupdateIfNeeded(configuration, HTTP_BINDING_PORT_KEY, httpPort);\n        }\n        if(httpsEnabled){\n        \tint httpsPort = getHttpsPort(container);\n        \tfabricService.get().getPortService().registerPort(container, HTTP_PID, HTTPS_BINDING_PORT_KEY, httpsPort);\n        }\n    }","commit_id":"815fe8836fcaea06e67837524a45201e5d7e4964","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Receives notification of a Configuration that has changed.\n     *\n     * @param event The <code>ConfigurationEvent<\/code>.\n     */\n    @Override\n    public void configurationEvent(ConfigurationEvent event) {\n        if (isValid()) {\n            try {\n                Container current = getContainer();\n                RuntimeProperties sysprops = runtimeProperties.get();\n                String karafName = sysprops.getProperty(SystemProperties.KARAF_NAME);\n                if (event.getPid().equals(SSH_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                    Configuration config = configAdmin.get().getConfiguration(SSH_PID, null);\n                    int sshPort = Integer.parseInt((String) config.getProperties().get(SSH_BINDING_PORT_KEY));\n                    int sshConnectionPort = getSshConnectionPort(current, sshPort);\n                    String sshUrl = getSshUrl(karafName, sshConnectionPort);\n                    setData(curator.get(), CONTAINER_SSH.getPath(karafName), sshUrl);\n                    if (fabricService.get().getPortService().lookupPort(current, SSH_PID, SSH_BINDING_PORT_KEY) != sshPort) {\n                        fabricService.get().getPortService().unregisterPort(current, SSH_PID);\n                        fabricService.get().getPortService().registerPort(current, SSH_PID, SSH_BINDING_PORT_KEY, sshPort);\n                    }\n                }\n                if (event.getPid().equals(HTTP_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                    Configuration config = configAdmin.get().getConfiguration(HTTP_PID, null);\n                    boolean httpEnabled = isHttpEnabled();\n                    boolean httpsEnabled = isHttpsEnabled();\n                    String protocol = httpsEnabled && !httpEnabled ? \"https\" : \"http\";\n                    int httpPort = httpsEnabled && !httpEnabled ? Integer.parseInt((String) config.getProperties().get(HTTPS_BINDING_PORT_KEY)) : Integer\n                            .parseInt((String) config.getProperties().get(HTTP_BINDING_PORT_KEY));\n                    int httpConnectionPort = httpsEnabled && !httpEnabled ? getHttpsConnectionPort(current) : getHttpConnectionPort(current, httpPort);\n                    String httpUrl = getHttpUrl(protocol, karafName, httpConnectionPort);\n                    setData(curator.get(), CONTAINER_HTTP.getPath(karafName), httpUrl);\n                    if (fabricService.get().getPortService().lookupPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY) != httpPort) {\n                        fabricService.get().getPortService().unregisterPort(current, HTTP_PID);\n                        fabricService.get().getPortService().registerPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n                    }\n                }\n                if (event.getPid().equals(MANAGEMENT_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                    Configuration config = configAdmin.get().getConfiguration(MANAGEMENT_PID, null);\n                    int rmiServerPort = Integer.parseInt((String) config.getProperties().get(RMI_SERVER_BINDING_PORT_KEY));\n                    int rmiServerConnectionPort = getRmiServerConnectionPort(current, rmiServerPort);\n                    int rmiRegistryPort = Integer.parseInt((String) config.getProperties().get(RMI_REGISTRY_BINDING_PORT_KEY));\n                    int rmiRegistryConnectionPort = getRmiRegistryConnectionPort(current, rmiRegistryPort);\n                    String jmxUrl = getJmxUrl(karafName, rmiServerConnectionPort, rmiRegistryConnectionPort);\n                    setData(curator.get(), CONTAINER_JMX.getPath(karafName), jmxUrl);\n                    //Whenever the JMX URL changes we need to make sure that the java.rmi.server.hostname points to a valid address.\n                    sysprops.setProperty(SystemProperties.JAVA_RMI_SERVER_HOSTNAME, current.getIp());\n                    if (fabricService.get().getPortService().lookupPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY) != rmiRegistryPort\n                            || fabricService.get().getPortService().lookupPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY) != rmiServerPort) {\n                        fabricService.get().getPortService().unregisterPort(current, MANAGEMENT_PID);\n                        fabricService.get().getPortService().registerPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY, rmiServerPort);\n                        fabricService.get().getPortService().registerPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY, rmiRegistryPort);\n                    }\n\n                }\n            } catch (Exception e) {\n                // ignored\n            }\n        }\n    }","id":47699,"modified_method":"/**\n     * Receives notification of a Configuration that has changed.\n     *\n     * @param event The <code>ConfigurationEvent<\/code>.\n     */\n    @Override\n    public void configurationEvent(ConfigurationEvent event) {\n        if (isValid()) {\n            try {\n                Container current = getContainer();\n                RuntimeProperties sysprops = runtimeProperties.get();\n                String karafName = sysprops.getProperty(SystemProperties.KARAF_NAME);\n                if (event.getPid().equals(SSH_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                    Configuration config = configAdmin.get().getConfiguration(SSH_PID, null);\n                    int sshPort = Integer.parseInt((String) config.getProperties().get(SSH_BINDING_PORT_KEY));\n                    int sshConnectionPort = getSshConnectionPort(current, sshPort);\n                    String sshUrl = getSshUrl(karafName, sshConnectionPort);\n                    setData(curator.get(), CONTAINER_SSH.getPath(karafName), sshUrl);\n                    if (fabricService.get().getPortService().lookupPort(current, SSH_PID, SSH_BINDING_PORT_KEY) != sshPort) {\n                        fabricService.get().getPortService().unregisterPort(current, SSH_PID);\n                        fabricService.get().getPortService().registerPort(current, SSH_PID, SSH_BINDING_PORT_KEY, sshPort);\n                    }\n                }\n                if (event.getPid().equals(HTTP_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                    Configuration config = configAdmin.get().getConfiguration(HTTP_PID, null);\n                    boolean httpEnabled = isHttpEnabled();\n                    boolean httpsEnabled = isHttpsEnabled();\n                    String protocol = httpsEnabled && !httpEnabled ? \"https\" : \"http\";\n                    int httpConnectionPort = -1;\n                    if(httpEnabled){\n                    \tint httpPort = Integer.parseInt((String) config.getProperties().get(HTTP_BINDING_PORT_KEY));\n                    \thttpConnectionPort = getHttpConnectionPort(current, httpPort);\n                    \tif (fabricService.get().getPortService().lookupPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY) != httpPort) {\n                            fabricService.get().getPortService().unregisterPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY);\n                            fabricService.get().getPortService().registerPort(current, HTTP_PID, HTTP_BINDING_PORT_KEY, httpPort);\n                        }\n                    }\n                    if(httpsEnabled){\n                    \tint httpsPort = Integer.parseInt((String) config.getProperties().get(HTTPS_BINDING_PORT_KEY));\n                    \tif(httpConnectionPort == -1){\n                    \t\thttpConnectionPort = getHttpsConnectionPort(current);\n                    \t}\n                    \tif (fabricService.get().getPortService().lookupPort(current, HTTP_PID, HTTPS_BINDING_PORT_KEY) != httpsPort) {\n                            fabricService.get().getPortService().unregisterPort(current, HTTP_PID, HTTPS_BINDING_PORT_KEY);\n                            fabricService.get().getPortService().registerPort(current, HTTP_PID, HTTPS_BINDING_PORT_KEY, httpsPort);\n                        }\n                    }\n                    String httpUrl = getHttpUrl(protocol, karafName, httpConnectionPort);\n                    setData(curator.get(), CONTAINER_HTTP.getPath(karafName), httpUrl);\n                }\n                if (event.getPid().equals(MANAGEMENT_PID) && event.getType() == ConfigurationEvent.CM_UPDATED) {\n                    Configuration config = configAdmin.get().getConfiguration(MANAGEMENT_PID, null);\n                    int rmiServerPort = Integer.parseInt((String) config.getProperties().get(RMI_SERVER_BINDING_PORT_KEY));\n                    int rmiServerConnectionPort = getRmiServerConnectionPort(current, rmiServerPort);\n                    int rmiRegistryPort = Integer.parseInt((String) config.getProperties().get(RMI_REGISTRY_BINDING_PORT_KEY));\n                    int rmiRegistryConnectionPort = getRmiRegistryConnectionPort(current, rmiRegistryPort);\n                    String jmxUrl = getJmxUrl(karafName, rmiServerConnectionPort, rmiRegistryConnectionPort);\n                    setData(curator.get(), CONTAINER_JMX.getPath(karafName), jmxUrl);\n                    //Whenever the JMX URL changes we need to make sure that the java.rmi.server.hostname points to a valid address.\n                    sysprops.setProperty(SystemProperties.JAVA_RMI_SERVER_HOSTNAME, current.getIp());\n                    if (fabricService.get().getPortService().lookupPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY) != rmiRegistryPort\n                            || fabricService.get().getPortService().lookupPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY) != rmiServerPort) {\n                        fabricService.get().getPortService().unregisterPort(current, MANAGEMENT_PID);\n                        fabricService.get().getPortService().registerPort(current, MANAGEMENT_PID, RMI_SERVER_BINDING_PORT_KEY, rmiServerPort);\n                        fabricService.get().getPortService().registerPort(current, MANAGEMENT_PID, RMI_REGISTRY_BINDING_PORT_KEY, rmiRegistryPort);\n                    }\n\n                }\n            } catch (Exception e) {\n                // ignored\n            }\n        }\n    }","commit_id":"815fe8836fcaea06e67837524a45201e5d7e4964","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@NotNull\n  public PsiElement[] getChildren() {\n    PsiIdentifier name = getNameIdentifier();\n    PsiDocComment docComment = getDocComment();\n    PsiModifierList modifierList = getModifierList();\n    PsiReferenceList extendsList = getExtendsList();\n    PsiReferenceList implementsList = getImplementsList();\n    PsiField[] fields = getFields();\n    PsiMethod[] methods = getMethods();\n    PsiClass[] classes = getInnerClasses();\n\n    int count =\n      (docComment != null ? 1 : 0)\n      + (modifierList != null ? 1 : 0)\n      + (name != null ? 1 : 0)\n      + (extendsList != null ? 1 : 0)\n      + (implementsList != null ? 1 : 0)\n      + fields.length\n      + methods.length\n      + classes.length;\n    PsiElement[] children = new PsiElement[count];\n\n    int offset = 0;\n    if (docComment != null) {\n      children[offset++] = docComment;\n    }\n    if (modifierList != null) {\n      children[offset++] = modifierList;\n    }\n    if (name != null) {\n      children[offset++] = name;\n    }\n    if (extendsList != null) {\n      children[offset++] = extendsList;\n    }\n    if (implementsList != null) {\n      children[offset++] = implementsList;\n    }\n    System.arraycopy(fields, 0, children, offset, fields.length);\n    offset += fields.length;\n    System.arraycopy(methods, 0, children, offset, methods.length);\n    offset += methods.length;\n    System.arraycopy(classes, 0, children, offset, classes.length);\n    /*offset += classes.length;*/\n\n    return children;\n  }","id":47700,"modified_method":"@NotNull\n  public PsiElement[] getChildren() {\n    PsiIdentifier name = getNameIdentifier();\n    PsiDocComment docComment = getDocComment();\n    PsiModifierList modifierList = getModifierList();\n    PsiReferenceList extendsList = getExtendsList();\n    PsiReferenceList implementsList = getImplementsList();\n    PsiField[] fields = getFields();\n    PsiMethod[] methods = getMethods();\n    PsiClass[] classes = getInnerClasses();\n\n    int count =\n      (docComment != null ? 1 : 0)\n      + 1 // modifierList\n      + 1 // name\n      + 1 // extends list\n      + 1 // implementsList\n      + fields.length\n      + methods.length\n      + classes.length;\n    PsiElement[] children = new PsiElement[count];\n\n    int offset = 0;\n    if (docComment != null) {\n      children[offset++] = docComment;\n    }\n\n    children[offset++] = modifierList;\n    children[offset++] = name;\n    children[offset++] = extendsList;\n    children[offset++] = implementsList;\n\n    System.arraycopy(fields, 0, children, offset, fields.length);\n    offset += fields.length;\n    System.arraycopy(methods, 0, children, offset, methods.length);\n    offset += methods.length;\n    System.arraycopy(classes, 0, children, offset, classes.length);\n    /*offset += classes.length;*/\n\n    return children;\n  }","commit_id":"2e287cd7d6838bbbc7c823c3010ea2b10c251488","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processDeclarations(PsiScopeProcessor processor,\n                                     PsiSubstitutor substitutor,\n                                     PsiElement lastParent,\n                                     PsiElement place) {\n    return PsiClassImplUtil.processDeclarationsInClass(this, processor, substitutor, new HashSet(), lastParent, place, false);\n  }","id":47701,"modified_method":"public boolean processDeclarations(PsiScopeProcessor processor,\n                                     PsiSubstitutor substitutor,\n                                     PsiElement lastParent,\n                                     PsiElement place) {\n    return PsiClassImplUtil.processDeclarationsInClass(this, processor, substitutor, new HashSet<PsiClass>(), lastParent, place, false);\n  }","commit_id":"2e287cd7d6838bbbc7c823c3010ea2b10c251488","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setMirror(TreeElement element) {\n    LOG.assertTrue(isValid());\n    LOG.assertTrue(myMirror == null);\n    myMirror = element;\n    PsiClass mirror = (PsiClass)SourceTreeToPsiMap.treeElementToPsi(element);\n\n    if (getDocComment() != null) {\n        ((ClsElementImpl)getDocComment()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getDocComment()));\n    }\n      ((ClsElementImpl)getModifierList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getModifierList()));\n      ((ClsElementImpl)getNameIdentifier()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getNameIdentifier()));\n    if (!isAnnotationType() && !isEnum()) {\n        ((ClsElementImpl)getExtendsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getExtendsList()));\n    }\n      ((ClsElementImpl)getImplementsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getImplementsList()));\n      ((ClsElementImpl)getTypeParameterList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getTypeParameterList()));\n\n    PsiField[] fields = getFields();\n    PsiField[] mirrorFields = mirror.getFields();\n    if (LOG.assertTrue(fields.length == mirrorFields.length)) {\n      for (int i = 0; i < fields.length; i++) {\n          ((ClsElementImpl)fields[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorFields[i]));\n      }\n    }\n\n    PsiMethod[] methods = getMethods();\n    PsiMethod[] mirrorMethods = mirror.getMethods();\n    if (LOG.assertTrue(methods.length == mirrorMethods.length)) {\n      for (int i = 0; i < methods.length; i++) {\n          ((ClsElementImpl)methods[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorMethods[i]));\n      }\n    }\n\n    PsiClass[] classes = getInnerClasses();\n    PsiClass[] mirrorClasses = mirror.getInnerClasses();\n    if (LOG.assertTrue(classes.length == mirrorClasses.length)) {\n      for (int i = 0; i < classes.length; i++) {\n          ((ClsElementImpl)classes[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorClasses[i]));\n      }\n    }\n  }","id":47702,"modified_method":"public void setMirror(TreeElement element) {\n    LOG.assertTrue(isValid());\n    LOG.assertTrue(myMirror == null);\n    myMirror = element;\n    PsiClass mirror = (PsiClass)SourceTreeToPsiMap.treeElementToPsi(element);\n\n    final PsiDocComment docComment = getDocComment();\n    if (docComment != null) {\n        ((ClsElementImpl)docComment).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getDocComment()));\n    }\n      ((ClsElementImpl)getModifierList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getModifierList()));\n      ((ClsElementImpl)getNameIdentifier()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getNameIdentifier()));\n    if (!isAnnotationType() && !isEnum()) {\n        ((ClsElementImpl)getExtendsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getExtendsList()));\n    }\n      ((ClsElementImpl)getImplementsList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getImplementsList()));\n      ((ClsElementImpl)getTypeParameterList()).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirror.getTypeParameterList()));\n\n    PsiField[] fields = getFields();\n    PsiField[] mirrorFields = mirror.getFields();\n    if (LOG.assertTrue(fields.length == mirrorFields.length)) {\n      for (int i = 0; i < fields.length; i++) {\n          ((ClsElementImpl)fields[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorFields[i]));\n      }\n    }\n\n    PsiMethod[] methods = getMethods();\n    PsiMethod[] mirrorMethods = mirror.getMethods();\n    if (LOG.assertTrue(methods.length == mirrorMethods.length)) {\n      for (int i = 0; i < methods.length; i++) {\n          ((ClsElementImpl)methods[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorMethods[i]));\n      }\n    }\n\n    PsiClass[] classes = getInnerClasses();\n    PsiClass[] mirrorClasses = mirror.getInnerClasses();\n    if (LOG.assertTrue(classes.length == mirrorClasses.length)) {\n      for (int i = 0; i < classes.length; i++) {\n          ((ClsElementImpl)classes[i]).setMirror((TreeElement)SourceTreeToPsiMap.psiElementToTree(mirrorClasses[i]));\n      }\n    }\n  }","commit_id":"2e287cd7d6838bbbc7c823c3010ea2b10c251488","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiClass getSourceMirrorClass() {\n    PsiElement parent = getParent();\n    if (parent instanceof PsiFile) {\n      PsiJavaFile fileNavigationElement = (PsiJavaFile) parent.getNavigationElement();\n      for (PsiClass aClass : fileNavigationElement.getClasses()) {\n        if (aClass.getName().equals(getName())) return aClass;\n      }\n    }\n    else {\n      ClsClassImpl parentClass = (ClsClassImpl)parent;\n      PsiClass parentSourceMirror = parentClass.getSourceMirrorClass();\n      if (parentSourceMirror == null) return null;\n      PsiClass[] innerClasses = parentSourceMirror.getInnerClasses();\n      for (PsiClass innerClass : innerClasses) {\n        if (innerClass.getName().equals(getName())) return innerClass;\n      }\n    }\n\n    return null;\n  }","id":47703,"modified_method":"public PsiClass getSourceMirrorClass() {\n    PsiElement parent = getParent();\n    final String name = getName();\n    if (parent instanceof PsiFile) {\n      PsiJavaFile fileNavigationElement = (PsiJavaFile) parent.getNavigationElement();\n      for (PsiClass aClass : fileNavigationElement.getClasses()) {\n        if (name.equals(aClass.getName())) return aClass;\n      }\n    }\n    else {\n      ClsClassImpl parentClass = (ClsClassImpl)parent;\n      PsiClass parentSourceMirror = parentClass.getSourceMirrorClass();\n      if (parentSourceMirror == null) return null;\n      PsiClass[] innerClasses = parentSourceMirror.getInnerClasses();\n      for (PsiClass innerClass : innerClasses) {\n        if (name.equals(innerClass.getName())) return innerClass;\n      }\n    }\n\n    return null;\n  }","commit_id":"2e287cd7d6838bbbc7c823c3010ea2b10c251488","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private BytePointer readClassAttribute(@NonNls String attributeName) throws ClsFormatException {\n    ClassFileData classFileData = getClassFileData();\n    BytePointer ptr = new BytePointer(classFileData.getData(), classFileData.getConstantPoolEnd() + 6);\n    int count = ClsUtil.readU2(ptr);\n    ptr.offset += count * 2; // skip interfaces\n    count = ClsUtil.readU2(ptr);\n    for (int i = 0; i < count; i++) { // skip fields\n      ptr.offset += 6;\n      ClsUtil.skipAttributes(ptr);\n    }\n    count = ClsUtil.readU2(ptr);\n    for (int i = 0; i < count; i++) { // skip methods\n      ptr.offset += 6;\n      ClsUtil.skipAttributes(ptr);\n    }\n\n    BytePointer attribute = getClassFileData().findAttribute(ptr.offset, attributeName);\n    return attribute;\n  }","id":47704,"modified_method":"private BytePointer readClassAttribute(@NonNls String attributeName) throws ClsFormatException {\n    ClassFileData classFileData = getClassFileData();\n    BytePointer ptr = new BytePointer(classFileData.getData(), classFileData.getConstantPoolEnd() + 6);\n    int count = ClsUtil.readU2(ptr);\n    ptr.offset += count * 2; // skip interfaces\n    count = ClsUtil.readU2(ptr);\n    for (int i = 0; i < count; i++) { // skip fields\n      ptr.offset += 6;\n      ClsUtil.skipAttributes(ptr);\n    }\n    count = ClsUtil.readU2(ptr);\n    for (int i = 0; i < count; i++) { // skip methods\n      ptr.offset += 6;\n      ClsUtil.skipAttributes(ptr);\n    }\n\n    return getClassFileData().findAttribute(ptr.offset, attributeName);\n  }","commit_id":"2e287cd7d6838bbbc7c823c3010ea2b10c251488","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getRepCode(String attributeKey) {\r\n      return findAttribute(attributeKey).getRepCode();\r\n    }","id":47705,"modified_method":"public String getRepCode(String attributeKey) {\r\n      KettleAttributeInterface attr = findAttribute(attributeKey);\r\n      return Const.isEmpty(attr.getRepCode())?attr.getXmlCode():attr.getRepCode();\r\n    }","commit_id":"ee949aae8291f94d9a128eea67fab31596a559e3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    public Object getValue(ELContext context, Object base, Object property) {\n        if (context == null) {\n            throw new NullPointerException();\n        }\n\n        if (base == null) {\n            context.setPropertyResolved(base, property);\n            if (property != null) {\n                String key = property.toString();\n                PageContext page = (PageContext) context\n                        .getContext(JspContext.class);\n                return page.findAttribute(key);\n            }\n        }\n\n        return null;\n    }","id":47706,"modified_method":"@Override\n    public Object getValue(ELContext context, Object base, Object property) {\n        if (context == null) {\n            throw new NullPointerException();\n        }\n\n        Object result = null;\n\n        if (base == null) {\n            context.setPropertyResolved(base, property);\n            if (property != null) {\n                String key = property.toString();\n                PageContext page = (PageContext) context\n                        .getContext(JspContext.class);\n                result = page.findAttribute(key);\n\n                if (result == null) {\n                    // This might be the name of an import class\n                    ImportHandler importHandler = context.getImportHandler();\n                    if (importHandler != null) {\n                        Class<?> clazz = importHandler.resolveClass(key);\n                        if (clazz != null) {\n                            result = new ELClass(clazz);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }","commit_id":"50b7795d05a506be321f329042c14fcfde5370cd","url":"https://github.com/apache/tomcat"},{"original_method":"private static JComponent createTitle(String titleText) {\n    JLabel titleLabel = new JLabel(titleText);\n    titleLabel.setFont(getTitleFont());\n    titleLabel.setForeground(UIUtil.getLabelDisabledForeground());\n    final Color bg = UIUtil.getListBackground();\n    SeparatorComponent separatorComponent =\n      new SeparatorComponent(titleLabel.getPreferredSize().height / 2, bg.darker(), bg.brighter());\n\n    JPanel result = new JPanel(new BorderLayout(5, 10));\n    result.add(titleLabel, BorderLayout.WEST);\n    result.add(separatorComponent, BorderLayout.CENTER);\n    result.setBackground(bg);\n\n    return result;\n  }","id":47707,"modified_method":"private static JComponent createTitle(String titleText) {\n    JLabel titleLabel = new JLabel(titleText);\n    titleLabel.setFont(getTitleFont());\n    titleLabel.setForeground(UIUtil.getLabelDisabledForeground());\n    final Color bg = UIUtil.getListBackground();\n    SeparatorComponent separatorComponent =\n      new SeparatorComponent(titleLabel.getPreferredSize().height / 2, new JBColor(bg.darker(), Gray._80), null);\n\n    JPanel result = new JPanel(new BorderLayout(5, 10));\n    result.add(titleLabel, BorderLayout.WEST);\n    result.add(separatorComponent, BorderLayout.CENTER);\n    result.setBackground(bg);\n\n    return result;\n  }","commit_id":"9929e0fd17210b9daa9577ea845767b32dff62d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n      Component cmp;\n      PsiFile file;\n      myLocationString = null;\n      if (isMoreItem(index)) {\n        cmp = More.get(isSelected);\n      } else if (value instanceof VirtualFile && myProject != null && (file = PsiManager.getInstance(myProject).findFile((VirtualFile)value)) != null) {\n        cmp = new GotoFileCellRenderer(list.getWidth()).getListCellRendererComponent(list, file, index, isSelected, cellHasFocus);\n      } else if (value instanceof PsiElement) {\n        cmp = myPsiRenderer.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      } else {\n        cmp = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      }\n      if (myLocationString != null || value instanceof BooleanOptionDescription) {\n        final JPanel panel = new JPanel(new BorderLayout());\n        panel.setBackground(UIUtil.getListBackground(isSelected));\n        panel.add(cmp, BorderLayout.CENTER);\n        final Component rightComponent;\n        if (value instanceof BooleanOptionDescription) {\n          final OnOffButton button = new OnOffButton();\n          button.setSelected(((BooleanOptionDescription)value).isOptionEnabled());\n          rightComponent = button;\n        }\n        else {\n          rightComponent = myLocation.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        }\n        panel.add(rightComponent, BorderLayout.EAST);\n        cmp = panel;\n      }\n\n      cmp.setBackground(UIUtil.getListBackground(isSelected));\n      Color bg = cmp.getBackground();\n      myMainPanel.setBorder(new CustomLineBorder(bg, 0, 0, 2, 0));\n      String title = myTitleIndexes.getTitle(index);\n      myMainPanel.removeAll();\n      if (title != null) {\n        myTitle.setText(title);\n        myMainPanel.add(createTitle(\" \" + title), BorderLayout.NORTH);\n      }\n      myMainPanel.add(cmp, BorderLayout.CENTER);\n      final int width = myMainPanel.getPreferredSize().width;\n      if (width > myPopupActualWidth) {\n        myPopupActualWidth = width;\n        schedulePopupUpdate();\n      }\n      return myMainPanel;\n    }","id":47708,"modified_method":"@Override\n    public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {\n      Component cmp;\n      PsiFile file;\n      myLocationString = null;\n      if (isMoreItem(index)) {\n        cmp = More.get(isSelected);\n      } else if (value instanceof VirtualFile && myProject != null && (file = PsiManager.getInstance(myProject).findFile((VirtualFile)value)) != null) {\n        cmp = new GotoFileCellRenderer(list.getWidth()).getListCellRendererComponent(list, file, index, isSelected, cellHasFocus);\n      } else if (value instanceof PsiElement) {\n        cmp = myPsiRenderer.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      } else {\n        cmp = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n      }\n      if (myLocationString != null || value instanceof BooleanOptionDescription) {\n        final JPanel panel = new JPanel(new BorderLayout());\n        panel.setBackground(UIUtil.getListBackground(isSelected));\n        panel.add(cmp, BorderLayout.CENTER);\n        final Component rightComponent;\n        if (value instanceof BooleanOptionDescription) {\n          final OnOffButton button = new OnOffButton();\n          button.setSelected(((BooleanOptionDescription)value).isOptionEnabled());\n          rightComponent = button;\n        }\n        else {\n          rightComponent = myLocation.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n        }\n        panel.add(rightComponent, BorderLayout.EAST);\n        cmp = panel;\n      }\n\n      Color bg = cmp.getBackground();\n      cmp.setBackground(UIUtil.getListBackground(isSelected));\n      if (bg == null) {\n        bg = cmp.getBackground();\n      }\n      myMainPanel.setBorder(new CustomLineBorder(bg, 0, 0, 2, 0));\n      String title = myTitleIndexes.getTitle(index);\n      myMainPanel.removeAll();\n      if (title != null) {\n        myTitle.setText(title);\n        myMainPanel.add(createTitle(\" \" + title), BorderLayout.NORTH);\n      }\n      myMainPanel.add(cmp, BorderLayout.CENTER);\n      final int width = myMainPanel.getPreferredSize().width;\n      if (width > myPopupActualWidth) {\n        myPopupActualWidth = width;\n        schedulePopupUpdate();\n      }\n      return myMainPanel;\n    }","commit_id":"9929e0fd17210b9daa9577ea845767b32dff62d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private OptionsPanel() {\n      super(new GridBagLayout());\n\n      GridBagConstraints gc = new GridBagConstraints();\n      gc.weighty = 0;\n      gc.weightx = 1;\n      gc.fill = GridBagConstraints.HORIZONTAL;\n      gc.anchor = GridBagConstraints.NORTHWEST;\n\n      mySuggestNullables = new JCheckBox(\"Suggest @Nullable annotation for method possibly return null. Requires JDK5.0 and annotations.jar from IDEA distribution\");\n      mySuggestNullables.setSelected(SUGGEST_NULLABLE_ANNOTATIONS);\n      mySuggestNullables.getModel().addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          SUGGEST_NULLABLE_ANNOTATIONS = mySuggestNullables.isSelected();\n        }\n      });\n      gc.insets = new Insets(0, 0, 15, 0);\n      gc.gridy = 0;\n      add(mySuggestNullables, gc);\n    }","id":47709,"modified_method":"private OptionsPanel() {\n      super(new GridBagLayout());\n\n      GridBagConstraints gc = new GridBagConstraints();\n      gc.weighty = 0;\n      gc.weightx = 1;\n      gc.fill = GridBagConstraints.HORIZONTAL;\n      gc.anchor = GridBagConstraints.NORTHWEST;\n\n      //mySuggestNullables = new JCheckBox(\"Suggest @Nullable annotation for method possibly return null.\\n Requires JDK5.0 and annotations.jar from IDEA distribution\");\n      mySuggestNullables = new JCheckBox(\"<html><body>Suggest @Nullable annotation for method possibly return null.<br> Requires JDK5.0 and annotations.jar from IDEA distribution<\/body><\/html>\");\n      mySuggestNullables.setSelected(SUGGEST_NULLABLE_ANNOTATIONS);\n      mySuggestNullables.getModel().addChangeListener(new ChangeListener() {\n        public void stateChanged(ChangeEvent e) {\n          SUGGEST_NULLABLE_ANNOTATIONS = mySuggestNullables.isSelected();\n        }\n      });\n      gc.insets = new Insets(0, 0, 15, 0);\n      gc.gridy = 0;\n      add(mySuggestNullables, gc);\n    }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Applies specified decoration.\n   */\n  public final void apply(final WindowInfo info) {\n    if (Comparing.equal(myInfo, info)) {\n      return;\n    }\n    myInfo = info;\n    // Active\n    final boolean active = info.isActive();\n    myTitlePanel.setActive(active, !info.isSliding());\n    //todo myToolWindowBorder.setActive(active);\n    myFloatingDockSeparator.setActive(active);\n    myDockAutoHideSeparator.setActive(active);\n    myAutoHideHideSeparator.setActive(active);\n    // Icon\n    if (myInfo.isFloating()) {\n      myTitleLabel.setIcon(myToolWindow.getIcon());\n    }\n    else {\n      myTitleLabel.setIcon(null);\n    }\n    // Anchor\n    final ToolWindowAnchor anchor = myInfo.getAnchor();\n    if (info.isSliding()) {\n      myDivider.invalidate();\n      if (ToolWindowAnchor.TOP == anchor) {\n        add(myDivider, BorderLayout.SOUTH);\n      }\n      else if (ToolWindowAnchor.LEFT == anchor) {\n        add(myDivider, BorderLayout.EAST);\n      }\n      else if (ToolWindowAnchor.BOTTOM == anchor) {\n        add(myDivider, BorderLayout.NORTH);\n      }\n      else if (ToolWindowAnchor.RIGHT == anchor) {\n        add(myDivider, BorderLayout.WEST);\n      }\n      myDivider.setPreferredSize(new Dimension(DIVIDER_WIDTH, DIVIDER_WIDTH));\n    }\n    else { // docked and floating windows don't have divider\n      remove(myDivider);\n    }\n    validate();\n    repaint();\n    // Type\n    if (myInfo.isDocked()) {\n      myToggleFloatingModeButton.setIcon(active ? ourFloatingIcon : ourFloatingInactiveIcon);\n      myToggleDockModeButton.setVisible(true);\n      myDockAutoHideSeparator.setVisible(true);\n      myToggleDockModeButton.setIcon(active ? ourSlidingIcon : ourSlidingInactiveIcon);\n      myToggleAutoHideModeButton.setVisible(true);\n      myAutoHideHideSeparator.setVisible(true);\n      myToggleAutoHideModeButton.setIcon(active ?\n                                         (myInfo.isAutoHide() ? ourAuthoHideOnIcon : ourAuthoHideOffIcon) :\n                                         (myInfo.isAutoHide() ? ourAuthoHideOnInactiveIcon : ourAuthoHideOffInactiveIcon));\n      myHideButton.setVisible(true);\n    }\n    else if (myInfo.isFloating()) {\n      myToggleFloatingModeButton.setIcon(active ? ourFixIcon : ourFixInactiveIcon);\n      myToggleDockModeButton.setVisible(false);\n      myDockAutoHideSeparator.setVisible(false);\n      myToggleAutoHideModeButton.setVisible(true);\n      myAutoHideHideSeparator.setVisible(true);\n      myToggleAutoHideModeButton.setIcon(active ?\n                                         myInfo.isAutoHide() ? ourAuthoHideOnIcon : ourAuthoHideOffIcon :\n                                         myInfo.isAutoHide() ? ourAuthoHideOnInactiveIcon : ourAuthoHideOffInactiveIcon);\n      myHideButton.setVisible(true);\n    }\n    else if (myInfo.isSliding()) {\n      myToggleFloatingModeButton.setIcon(active ? ourFloatingIcon : ourFloatingInactiveIcon);\n      myToggleDockModeButton.setVisible(true);\n      myDockAutoHideSeparator.setVisible(true);\n      myToggleDockModeButton.setIcon(active ? ourDockedIcon : ourDockedInactiveIcon);\n      myToggleAutoHideModeButton.setVisible(false);\n      myAutoHideHideSeparator.setVisible(false);\n      myHideButton.setVisible(true);\n    }\n    myHideButton.setIcon(active ? ourHideIcon : ourHideInactiveIcon);\n    //\n    updateTitle();\n    updateTooltips();\n\n    // Push \"apply\" request forward\n\n    if (myInfo.isFloating() && myInfo.isVisible()) {\n      final FloatingDecorator floatingDecorator = (FloatingDecorator) SwingUtilities.getAncestorOfClass(FloatingDecorator.class, this);\n      LOG.assertTrue(floatingDecorator != null);\n      floatingDecorator.apply(myInfo);\n    }\n  }","id":47710,"modified_method":"/**\n   * Applies specified decoration.\n   */\n  public final void apply(final WindowInfo info) {\n    if (Comparing.equal(myInfo, info)) {\n      return;\n    }\n    myInfo = info;\n    // Active\n    final boolean active = info.isActive();\n    myTitlePanel.setActive(active, !info.isSliding());\n    myTitleLabel.setForeground(active ? SystemColor.activeCaptionText : SystemColor.inactiveCaptionText);\n\n    //todo myToolWindowBorder.setActive(active);\n    myFloatingDockSeparator.setActive(active);\n    myDockAutoHideSeparator.setActive(active);\n    myAutoHideHideSeparator.setActive(active);\n    // Icon\n    if (myInfo.isFloating()) {\n      myTitleLabel.setIcon(myToolWindow.getIcon());\n    }\n    else {\n      myTitleLabel.setIcon(null);\n    }\n    // Anchor\n    final ToolWindowAnchor anchor = myInfo.getAnchor();\n    if (info.isSliding()) {\n      myDivider.invalidate();\n      if (ToolWindowAnchor.TOP == anchor) {\n        add(myDivider, BorderLayout.SOUTH);\n      }\n      else if (ToolWindowAnchor.LEFT == anchor) {\n        add(myDivider, BorderLayout.EAST);\n      }\n      else if (ToolWindowAnchor.BOTTOM == anchor) {\n        add(myDivider, BorderLayout.NORTH);\n      }\n      else if (ToolWindowAnchor.RIGHT == anchor) {\n        add(myDivider, BorderLayout.WEST);\n      }\n      myDivider.setPreferredSize(new Dimension(DIVIDER_WIDTH, DIVIDER_WIDTH));\n    }\n    else { // docked and floating windows don't have divider\n      remove(myDivider);\n    }\n    validate();\n    repaint();\n    // Type\n    if (myInfo.isDocked()) {\n      myToggleFloatingModeButton.setIcon(active ? ourFloatingIcon : ourFloatingInactiveIcon);\n      myToggleDockModeButton.setVisible(true);\n      myDockAutoHideSeparator.setVisible(true);\n      myToggleDockModeButton.setIcon(active ? ourSlidingIcon : ourSlidingInactiveIcon);\n      myToggleAutoHideModeButton.setVisible(true);\n      myAutoHideHideSeparator.setVisible(true);\n      myToggleAutoHideModeButton.setIcon(active ?\n                                         (myInfo.isAutoHide() ? ourAuthoHideOnIcon : ourAuthoHideOffIcon) :\n                                         (myInfo.isAutoHide() ? ourAuthoHideOnInactiveIcon : ourAuthoHideOffInactiveIcon));\n      myHideButton.setVisible(true);\n    }\n    else if (myInfo.isFloating()) {\n      myToggleFloatingModeButton.setIcon(active ? ourFixIcon : ourFixInactiveIcon);\n      myToggleDockModeButton.setVisible(false);\n      myDockAutoHideSeparator.setVisible(false);\n      myToggleAutoHideModeButton.setVisible(true);\n      myAutoHideHideSeparator.setVisible(true);\n      myToggleAutoHideModeButton.setIcon(active ?\n                                         myInfo.isAutoHide() ? ourAuthoHideOnIcon : ourAuthoHideOffIcon :\n                                         myInfo.isAutoHide() ? ourAuthoHideOnInactiveIcon : ourAuthoHideOffInactiveIcon);\n      myHideButton.setVisible(true);\n    }\n    else if (myInfo.isSliding()) {\n      myToggleFloatingModeButton.setIcon(active ? ourFloatingIcon : ourFloatingInactiveIcon);\n      myToggleDockModeButton.setVisible(true);\n      myDockAutoHideSeparator.setVisible(true);\n      myToggleDockModeButton.setIcon(active ? ourDockedIcon : ourDockedInactiveIcon);\n      myToggleAutoHideModeButton.setVisible(false);\n      myAutoHideHideSeparator.setVisible(false);\n      myHideButton.setVisible(true);\n    }\n    myHideButton.setIcon(active ? ourHideIcon : ourHideInactiveIcon);\n    //\n    updateTitle();\n    updateTooltips();\n\n    // Push \"apply\" request forward\n\n    if (myInfo.isFloating() && myInfo.isVisible()) {\n      final FloatingDecorator floatingDecorator = (FloatingDecorator) SwingUtilities.getAncestorOfClass(FloatingDecorator.class, this);\n      LOG.assertTrue(floatingDecorator != null);\n      floatingDecorator.apply(myInfo);\n    }\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void init() {\n    enableEvents(ComponentEvent.COMPONENT_EVENT_MASK);\n    // Compose title bar\n    final Component strut = Box.createHorizontalStrut(3);\n    myTitlePanel.add(strut, BorderLayout.WEST);\n    myTitleLabel.setForeground(Color.white);\n    myTitlePanel.add(myTitleLabel, BorderLayout.CENTER);\n\n    final JPanel buttonPanel = new JPanel(new GridBagLayout());\n    buttonPanel.setOpaque(false);\n    buttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 2));\n    buttonPanel.add(myToggleFloatingModeButton,\n                    new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.EAST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myFloatingDockSeparator,\n                    new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myToggleDockModeButton,\n                    new GridBagConstraints(2, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myDockAutoHideSeparator,\n                    new GridBagConstraints(3, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myToggleAutoHideModeButton,\n                    new GridBagConstraints(4, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myAutoHideHideSeparator,\n                    new GridBagConstraints(5, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myHideButton,\n                    new GridBagConstraints(6, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n\n    myTitlePanel.add(buttonPanel, BorderLayout.EAST);\n    final JPanel contentPane = new JPanel(new BorderLayout());\n    contentPane.setBorder(myToolWindowBorder);\n    contentPane.add(myTitlePanel, BorderLayout.NORTH);\n    JPanel innerPanel = new JPanel(new BorderLayout());\n    innerPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));\n    JComponent toolWindowComponent = myToolWindow.getComponent();\n    innerPanel.add(toolWindowComponent, BorderLayout.CENTER);\n    contentPane.add(innerPanel, BorderLayout.CENTER);\n    add(contentPane, BorderLayout.CENTER);\n\n    // Add listeners\n\n    myToggleFloatingModeButton.addActionListener(myToggleFloatingModeAction);\n    myToggleDockModeButton.addActionListener(myToggleDockModeAction);\n    myToggleAutoHideModeButton.addActionListener(myToggleAutoHideModeAction);\n    myHideButton.addActionListener(myHideAction);\n    myTitleLabel.addMouseListener(new PopupHandler() {\n      public void invokePopup(final Component comp, final int x, final int y) {\n        final ActionGroup group = createPopupGroup();\n        final ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group);\n        popupMenu.getComponent().show(comp, x, y);\n      }\n    });\n    myTitleLabel.addMouseListener(new MouseAdapter() {\n      public void mousePressed(final MouseEvent e) {\n        if (!e.isPopupTrigger()) {\n          fireActivated();\n        }\n      }\n    });\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        ToolWindowManager.getInstance(myProject).activateEditorComponent();\n      }\n    },\n                           KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),\n                           JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n  }","id":47711,"modified_method":"private void init() {\n    enableEvents(ComponentEvent.COMPONENT_EVENT_MASK);\n    // Compose title bar\n    final Component strut = Box.createHorizontalStrut(3);\n    myTitlePanel.add(strut, BorderLayout.WEST);\n    myTitleLabel.setForeground(SystemColor.activeCaptionText);\n    myTitlePanel.add(myTitleLabel, BorderLayout.CENTER);\n\n    final JPanel buttonPanel = new JPanel(new GridBagLayout());\n    buttonPanel.setOpaque(false);\n    buttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 2));\n    buttonPanel.add(myToggleFloatingModeButton,\n                    new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.EAST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myFloatingDockSeparator,\n                    new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myToggleDockModeButton,\n                    new GridBagConstraints(2, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myDockAutoHideSeparator,\n                    new GridBagConstraints(3, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myToggleAutoHideModeButton,\n                    new GridBagConstraints(4, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myAutoHideHideSeparator,\n                    new GridBagConstraints(5, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n    buttonPanel.add(myHideButton,\n                    new GridBagConstraints(6, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n\n    myTitlePanel.add(buttonPanel, BorderLayout.EAST);\n    final JPanel contentPane = new JPanel(new BorderLayout());\n    contentPane.setBorder(myToolWindowBorder);\n    contentPane.add(myTitlePanel, BorderLayout.NORTH);\n    JPanel innerPanel = new JPanel(new BorderLayout());\n    innerPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));\n    JComponent toolWindowComponent = myToolWindow.getComponent();\n    innerPanel.add(toolWindowComponent, BorderLayout.CENTER);\n    contentPane.add(innerPanel, BorderLayout.CENTER);\n    add(contentPane, BorderLayout.CENTER);\n\n    // Add listeners\n\n    myToggleFloatingModeButton.addActionListener(myToggleFloatingModeAction);\n    myToggleDockModeButton.addActionListener(myToggleDockModeAction);\n    myToggleAutoHideModeButton.addActionListener(myToggleAutoHideModeAction);\n    myHideButton.addActionListener(myHideAction);\n    myTitleLabel.addMouseListener(new PopupHandler() {\n      public void invokePopup(final Component comp, final int x, final int y) {\n        final ActionGroup group = createPopupGroup();\n        final ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group);\n        popupMenu.getComponent().show(comp, x, y);\n      }\n    });\n    myTitleLabel.addMouseListener(new MouseAdapter() {\n      public void mousePressed(final MouseEvent e) {\n        if (!e.isPopupTrigger()) {\n          fireActivated();\n        }\n      }\n    });\n\n    registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        ToolWindowManager.getInstance(myProject).activateEditorComponent();\n      }\n    },\n                           KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),\n                           JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Stripe(final int anchor){\n    super(new GridBagLayout());\n    setBackground(new Color(247, 243, 239));\n    myAnchor = anchor;\n    myKeymapManagerListener=new MyKeymapManagerListener();\n    myWeakKeymapManagerListener=new WeakKeymapManagerListener(KeymapManagerEx.getInstanceEx(),myKeymapManagerListener);\n    myUISettingsListener=new MyUISettingsListener();\n  }","id":47712,"modified_method":"Stripe(final int anchor){\n    super(new GridBagLayout());\n    //setBackground(new Color(247, 243, 239));\n    myAnchor = anchor;\n    myKeymapManagerListener=new MyKeymapManagerListener();\n    myWeakKeymapManagerListener=new WeakKeymapManagerListener(KeymapManagerEx.getInstanceEx(),myKeymapManagerListener);\n    myUISettingsListener=new MyUISettingsListener();\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paint(final Graphics g,final JComponent c){\n    final StripeButton button=(StripeButton)c;\n\n    final String text=button.getText();\n    final Icon icon=(button.isEnabled()) ? button.getIcon() : button.getDisabledIcon();\n\n    if((icon==null)&&(text==null)){\n      return;\n    }\n\n    final FontMetrics fm=button.getFontMetrics(button.getFont());\n    ourViewInsets=c.getInsets(ourViewInsets);\n\n    ourViewRect.x=ourViewInsets.left;\n    ourViewRect.y=ourViewInsets.top;\n\n    final ToolWindowAnchor anchor=button.getWindowInfo().getAnchor();\n\n    // Use inverted height & width\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      ourViewRect.height=c.getWidth()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getHeight()-(ourViewInsets.top+ourViewInsets.bottom);\n    } else{\n      ourViewRect.height=c.getHeight()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getWidth()-(ourViewInsets.top+ourViewInsets.bottom);\n    }\n\n    ourIconRect.x=ourIconRect.y=ourIconRect.width=ourIconRect.height=0;\n    ourTextRect.x=ourTextRect.y=ourTextRect.width=ourTextRect.height=0;\n\n    final String clippedText=SwingUtilities.layoutCompoundLabel(\n      c,fm,text,icon,\n      button.getVerticalAlignment(),button.getHorizontalAlignment(),\n      button.getVerticalTextPosition(),button.getHorizontalTextPosition(),\n      ourViewRect,ourIconRect,ourTextRect,\n      button.getText()==null ? 0 : button.getIconTextGap()\n    );\n\n    // Paint button's background\n\n    final Graphics2D g2=(Graphics2D)g;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n    g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n\n    final ButtonModel model=button.getModel();\n    if (model.isArmed() && model.isPressed() || model.isSelected()) {\n//      g.setColor(button.getBackground().darker());\n//      g.fillRect(0, 0, button.getWidth(), button.getHeight());\n      g.setColor(button.getBackground());\n      g.fillRect(0, 0, button.getWidth(), button.getHeight());\n      g.setColor(button.getBackground().darker());\n      g.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    } else /*if (button.isOpaque())*/ {\n      g.setColor(button.getBackground());\n      g.fillRect(0, 0, button.getWidth(), button.getHeight());\n      g.setColor(Color.GRAY);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n\n    AffineTransform tr=null;\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      tr=g2.getTransform();\n      if(ToolWindowAnchor.RIGHT==anchor){\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, ourIconRect.x);\n        }\n        g2.rotate(Math.PI/2);\n        g2.translate(0,-c.getWidth());\n      } else {\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, c.getHeight() - ourIconRect.x - icon.getIconHeight());\n        }\n        g2.rotate(-Math.PI/2);\n        g2.translate(-c.getHeight(),0);\n      }\n    }\n    else{\n      if(icon!=null){\n        icon.paintIcon(c,g2,ourIconRect.x,ourIconRect.y);\n      }\n    }\n\n    // paint text\n\n    if(text!=null){\n      if(model.isEnabled()){\n        if(model.isArmed()&&model.isPressed()||model.isSelected()){\n          g.setColor(button.getBackground());\n        } else{\n          g.setColor(button.getForeground());\n        }\n      } else{\n        g.setColor(button.getBackground().darker());\n      }\n      /* Draw the Text */\n      if(model.isEnabled()){\n        /*** paint the text normally */\n        g.setColor(button.getForeground());\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      } else{\n        /*** paint the text disabled ***/\n        if(model.isSelected()){\n          g.setColor(c.getBackground());\n        } else{\n          g.setColor(getDisabledTextColor());\n        }\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      }\n    }\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      g2.setTransform(tr);\n    }\n  }","id":47713,"modified_method":"public void paint(final Graphics g,final JComponent c){\n    final StripeButton button=(StripeButton)c;\n\n    final String text=button.getText();\n    final Icon icon=(button.isEnabled()) ? button.getIcon() : button.getDisabledIcon();\n\n    if((icon==null)&&(text==null)){\n      return;\n    }\n\n    final FontMetrics fm=button.getFontMetrics(button.getFont());\n    ourViewInsets=c.getInsets(ourViewInsets);\n\n    ourViewRect.x=ourViewInsets.left;\n    ourViewRect.y=ourViewInsets.top;\n\n    final ToolWindowAnchor anchor=button.getWindowInfo().getAnchor();\n\n    // Use inverted height & width\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      ourViewRect.height=c.getWidth()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getHeight()-(ourViewInsets.top+ourViewInsets.bottom);\n    } else{\n      ourViewRect.height=c.getHeight()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getWidth()-(ourViewInsets.top+ourViewInsets.bottom);\n    }\n\n    ourIconRect.x=ourIconRect.y=ourIconRect.width=ourIconRect.height=0;\n    ourTextRect.x=ourTextRect.y=ourTextRect.width=ourTextRect.height=0;\n\n    final String clippedText=SwingUtilities.layoutCompoundLabel(\n      c,fm,text,icon,\n      button.getVerticalAlignment(),button.getHorizontalAlignment(),\n      button.getVerticalTextPosition(),button.getHorizontalTextPosition(),\n      ourViewRect,ourIconRect,ourTextRect,\n      button.getText()==null ? 0 : button.getIconTextGap()\n    );\n\n    // Paint button's background\n\n    final Graphics2D g2=(Graphics2D)g;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n    g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n\n    final ButtonModel model=button.getModel();\n\n    g.setColor(new JPanel().getBackground());\n    g.fillRect(0, 0, button.getWidth(), button.getHeight());\n\n    if (model.isArmed() && model.isPressed() || model.isSelected()) {\n      final Graphics2D g2d = (Graphics2D) g;\n      final GradientPaint paint;\n      if (ToolWindowAnchor.TOP == anchor || ToolWindowAnchor.BOTTOM == anchor) {\n        paint = new GradientPaint(0, 0, button.getBackground().darker(), 0, button.getHeight(), button.getBackground().brighter());\n      }\n      else {\n        paint = new GradientPaint(0, 0, button.getBackground().darker(), button.getWidth(), 0, button.getBackground().brighter());\n      }\n      g2d.setPaint(paint);\n      g2d.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n\n      /*\n      g.setColor(button.getBackground().darker());\n      g.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n      */\n      g.setColor(Color.black);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    } else /*if (button.isOpaque())*/ {\n      g.setColor(button.getBackground());\n      g.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n      g.setColor(Color.GRAY);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n\n    AffineTransform tr=null;\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      tr=g2.getTransform();\n      if(ToolWindowAnchor.RIGHT==anchor){\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, ourIconRect.x);\n        }\n        g2.rotate(Math.PI/2);\n        g2.translate(0,-c.getWidth());\n      } else {\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, c.getHeight() - ourIconRect.x - icon.getIconHeight());\n        }\n        g2.rotate(-Math.PI/2);\n        g2.translate(-c.getHeight(),0);\n      }\n    }\n    else{\n      if(icon!=null){\n        icon.paintIcon(c,g2,ourIconRect.x,ourIconRect.y);\n      }\n    }\n\n    // paint text\n\n    if(text!=null){\n      if(model.isEnabled()){\n        if(model.isArmed()&&model.isPressed()||model.isSelected()){\n          g.setColor(button.getBackground());\n        } else{\n          g.setColor(button.getForeground());\n        }\n      } else{\n        g.setColor(button.getBackground().darker());\n      }\n      /* Draw the Text */\n      if(model.isEnabled()){\n        /*** paint the text normally */\n        g.setColor(button.getForeground());\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      } else{\n        /*** paint the text disabled ***/\n        if(model.isSelected()){\n          g.setColor(c.getBackground());\n        } else{\n          g.setColor(getDisabledTextColor());\n        }\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      }\n    }\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      g2.setTransform(tr);\n    }\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"TitlePanel() {\n    super(new BorderLayout());\n    myFrameTicker = new Alarm();\n    myAnimator = new MyAnimator();\n    setLayout(new BorderLayout());\n\n    // Initial boundary color\n\n    myBndStartRed = BND_DISABLE_COLOR.getRed();\n    myBndStartGreen = BND_DISABLE_COLOR.getGreen();\n    myBndStartBlue = BND_DISABLE_COLOR.getBlue();\n\n    myBndEndRed = BND_ENABLE_COLOR.getRed();\n    myBndEndGreen = BND_ENABLE_COLOR.getGreen();\n    myBndEndBlue = BND_ENABLE_COLOR.getBlue();\n\n    // Initial center color\n\n    myCntStartRed = CNT_DISABLE_COLOR.getRed();\n    myCntStartGreen = CNT_DISABLE_COLOR.getGreen();\n    myCntStartBlue = CNT_DISABLE_COLOR.getBlue();\n\n    myCntEndRed = CNT_ENABLE_COLOR.getRed();\n    myCntEndGreen = CNT_ENABLE_COLOR.getGreen();\n    myCntEndBlue = CNT_ENABLE_COLOR.getBlue();\n\n    myCurrentFrame = TOTAL_FRAME_COUNT;\n    updateColor();\n  }","id":47714,"modified_method":"TitlePanel() {\n    super(new BorderLayout());\n    myFrameTicker = new Alarm();\n    myAnimator = new MyAnimator();\n    setLayout(new BorderLayout());\n\n    setupColors(false);\n\n    myCurrentFrame = TOTAL_FRAME_COUNT;\n    updateColor();\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void setActive(final boolean active, boolean animate) {\n    if (active == myActive) {\n      return;\n    }\n    myActive = active;\n    myFrameTicker.cancelAllRequests();\n    if (myCurrentFrame > 0) { // reverse rendering\n      myCurrentFrame = TOTAL_FRAME_COUNT - myCurrentFrame;\n    }\n    if (active) {\n\n      // Boundary color\n\n      myBndStartRed = BND_DISABLE_COLOR.getRed();\n      myBndStartGreen = BND_DISABLE_COLOR.getGreen();\n      myBndStartBlue = BND_DISABLE_COLOR.getBlue();\n\n      myBndEndRed = BND_ENABLE_COLOR.getRed();\n      myBndEndGreen = BND_ENABLE_COLOR.getGreen();\n      myBndEndBlue = BND_ENABLE_COLOR.getBlue();\n\n      // Center color\n\n      myCntStartRed = CNT_DISABLE_COLOR.getRed();\n      myCntStartGreen = CNT_DISABLE_COLOR.getGreen();\n      myCntStartBlue = CNT_DISABLE_COLOR.getBlue();\n\n      myCntEndRed = CNT_ENABLE_COLOR.getRed();\n      myCntEndGreen = CNT_ENABLE_COLOR.getGreen();\n      myCntEndBlue = CNT_ENABLE_COLOR.getBlue();\n    }\n    else {\n\n      // Boundary color\n\n      myBndStartRed = BND_ENABLE_COLOR.getRed();\n      myBndStartGreen = BND_ENABLE_COLOR.getGreen();\n      myBndStartBlue = BND_ENABLE_COLOR.getBlue();\n\n      myBndEndRed = BND_DISABLE_COLOR.getRed();\n      myBndEndGreen = BND_DISABLE_COLOR.getGreen();\n      myBndEndBlue = BND_DISABLE_COLOR.getBlue();\n\n      // Center color\n\n      myCntStartRed = CNT_ENABLE_COLOR.getRed();\n      myCntStartGreen = CNT_ENABLE_COLOR.getGreen();\n      myCntStartBlue = CNT_ENABLE_COLOR.getBlue();\n\n      myCntEndRed = CNT_DISABLE_COLOR.getRed();\n      myCntEndGreen = CNT_DISABLE_COLOR.getGreen();\n      myCntEndBlue = CNT_DISABLE_COLOR.getBlue();\n    }\n    if (animate) {\n      myFrameTicker.addRequest(myAnimator, DELAY);\n    }\n  }","id":47715,"modified_method":"public final void setActive(final boolean active, boolean animate) {\n    if (active == myActive) {\n      return;\n    }\n    myActive = active;\n    myFrameTicker.cancelAllRequests();\n    if (myCurrentFrame > 0) { // reverse rendering\n      myCurrentFrame = TOTAL_FRAME_COUNT - myCurrentFrame;\n    }\n\n    setupColors(active);\n\n    if (animate) {\n      myFrameTicker.addRequest(myAnimator, DELAY);\n    }\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n    final Graphics2D g2d = (Graphics2D) g;\n    g2d.setPaint(new GradientPaint(0, 0, myBndColor, 0, getHeight() / 2, myCntColor));\n    g2d.fillRect(0, 0, getWidth(), getHeight() / 2);\n    g2d.setPaint(new GradientPaint(0, getHeight() / 2, myCntColor, 0, getHeight() - 1, myBndColor));\n    g2d.fillRect(0, getHeight() / 2, getWidth(), getHeight() - 1);\n  }","id":47716,"modified_method":"protected final void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n    final Graphics2D g2d = (Graphics2D) g;\n    g2d.setPaint(new GradientPaint(0, 0, myBndColor, 0, getHeight(), myCntColor));\n    g2d.fillRect(0, 0, getWidth(), getHeight());\n    g2d.setColor(myActive ? SystemColor.activeCaptionBorder : SystemColor.inactiveCaptionBorder);\n    g2d.drawLine(0, 0, getWidth(), 0);\n  }","commit_id":"188af8ea880ab116654df500ea4282a0b0086977","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Dimension getMaximumSize() {\n    return myPrefSize;\n  }","id":47717,"modified_method":"public Dimension getMaximumSize() {\n    return getPreferredSize();\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n\n    Icon icon;\n\n    if (myTimer.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = myPassiveIcon;\n    }\n\n    int x = (getWidth() - icon.getIconWidth()) / 2;\n    int y = (getHeight() - icon.getIconHeight()) / 2;\n\n    icon.paintIcon(this, g, x, y);\n  }","id":47718,"modified_method":"protected void paintComponent(Graphics g) {\n    if (isOpaque()) {\n      g.setColor(getBackground());\n      g.fillRect(0, 0, getWidth(), getHeight());\n    }\n\n    Icon icon;\n\n    if (myTimer.isRunning()) {\n      icon = myIcons[myCurrentIconIndex];\n    } else {\n      icon = myPassiveIcon;\n    }\n\n    final Rectangle clipBounds = g.getClipBounds();\n    int x = (clipBounds.width - icon.getIconWidth()) / 2;\n    int y = (clipBounds.height - icon.getIconHeight()) / 2;\n\n    icon.paintIcon(this, g, x, y);\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Dimension getMinimumSize() {\n    return myPrefSize;\n  }","id":47719,"modified_method":"public Dimension getMinimumSize() {\n    return getPreferredSize();\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Dimension getPreferredSize() {\n    return myPrefSize;\n  }","id":47720,"modified_method":"public Dimension getPreferredSize() {\n    final Insets insets = getInsets();\n    return new Dimension(myPrefSize.width + insets.left + insets.right, myPrefSize.height + insets.top + insets.bottom);\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InfoAndProgressPanel(final StatusBarImpl statusBar) {\n    myStatusBar = statusBar;\n    setOpaque(false);\n\n    myProgressIcon = new AsyncProcessIcon(\"Background process\");\n    myProgressIcon.setToolTipText(\"View \" + ProcessPopup.BACKGROUND_PROCESSES);\n    new BaseButtonBehavior(myProgressIcon) {\n      protected void execute() {\n        triggerPopupShowing();\n      }\n    };\n    myProgressIcon.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n    myProgressIcon.setBorder(new EmptyBorder(0, 2, 0, 2));\n\n    myUpdateQueue = new MergingUpdateQueue(\"Progress indicator\", 250, true, null);\n    myPopup = new ProcessPopup(this);\n\n    restoreEmptyStatus();\n  }","id":47721,"modified_method":"public InfoAndProgressPanel(final StatusBarImpl statusBar) {\n    myStatusBar = statusBar;\n    setOpaque(false);\n\n    myProgressIcon = new AsyncProcessIcon(\"Background process\");\n    myProgressIcon.setOpaque(true);\n    myProgressIcon.setToolTipText(\"View \" + ProcessPopup.BACKGROUND_PROCESSES);\n    new BaseButtonBehavior(myProgressIcon) {\n      protected void execute() {\n        triggerPopupShowing();\n      }\n    };\n    myProgressIcon.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\n    myUpdateQueue = new MergingUpdateQueue(\"Progress indicator\", 250, true, null);\n    myPopup = new ProcessPopup(this);\n\n    restoreEmptyStatus();\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildInProcessCount() {\n    removeAll();\n    setLayout(new BorderLayout());\n\n    final JPanel progressCountPanel = new JPanel(new BorderLayout(0, 2));\n    String processWord = myOriginals.size() == 1 ? \" process\" : \" processes\";\n    final LinkLabel label = new LinkLabel(myOriginals.size() + processWord + \" running...\", null, new LinkListener() {\n      public void linkSelected(final LinkLabel aSource, final Object aLinkData) {\n        triggerPopupShowing();\n      }\n    });\n    progressCountPanel.add(label, BorderLayout.CENTER);\n    label.setBorder(new EmptyBorder(0, 2, 0, 0));\n\n    final Wrapper icon = new Wrapper(myProgressIcon);\n    progressCountPanel.add(icon, BorderLayout.EAST);\n\n    progressCountPanel.setBorder(createLeftEdgeBorder());\n\n    add(myStatusBar.myInfoPanel, BorderLayout.CENTER);\n    add(progressCountPanel, BorderLayout.EAST);\n\n    revalidate();\n    repaint();\n  }","id":47722,"modified_method":"private void buildInProcessCount() {\n    removeAll();\n    setLayout(new BorderLayout());\n\n    final JPanel progressCountPanel = new JPanel(new BorderLayout(0, 2));\n    String processWord = myOriginals.size() == 1 ? \" process\" : \" processes\";\n    final LinkLabel label = new LinkLabel(myOriginals.size() + processWord + \" running...\", null, new LinkListener() {\n      public void linkSelected(final LinkLabel aSource, final Object aLinkData) {\n        triggerPopupShowing();\n      }\n    });\n    label.setOpaque(true);\n\n    final Wrapper labelComp = new Wrapper(label);\n    labelComp.setBorder(new EmptyBorder(0, 4, 0, 0));\n\n    progressCountPanel.add(labelComp, BorderLayout.CENTER);\n\n    myProgressIcon.setBorder(createInsetBorder());\n    progressCountPanel.add(myProgressIcon, BorderLayout.EAST);\n\n    progressCountPanel.setBorder(new StatusBarImpl.SeparatorBorder.Left());\n\n    add(myStatusBar.myInfoPanel, BorderLayout.CENTER);\n    add(progressCountPanel, BorderLayout.EAST);\n\n    revalidate();\n    repaint();\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void restoreEmptyStatus() {\n    removeAll();\n    setLayout(new BorderLayout());\n    add(myStatusBar.myInfoPanel, BorderLayout.CENTER);\n    final Wrapper icon = new Wrapper(myProgressIcon);\n    icon.setBorder(createLeftEdgeBorder());\n    add(icon, BorderLayout.EAST);\n    myProgressIcon.suspend();\n    myStatusBar.myInfoPanel.revalidate();\n    myStatusBar.myInfoPanel.repaint();\n  }","id":47723,"modified_method":"private void restoreEmptyStatus() {\n    removeAll();\n    setLayout(new BorderLayout());\n    add(myStatusBar.myInfoPanel, BorderLayout.CENTER);\n    myProgressIcon.setBorder(createSeparatorBorder());\n    add(myProgressIcon, BorderLayout.EAST);\n    myProgressIcon.suspend();\n    myStatusBar.myInfoPanel.revalidate();\n    myStatusBar.myInfoPanel.repaint();\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildInInlineIndicator(final InlineProgressIndicator inline) {\n    removeAll();\n    setLayout(new GridLayout(1, 2));\n    add(myStatusBar.myInfoPanel);\n\n    final JPanel inlineComponent = new JPanel(new BorderLayout());\n    inlineComponent.add(inline.getComponent(), BorderLayout.CENTER);\n    inlineComponent.setBorder(createLeftEdgeBorder());\n\n    final Wrapper icon = new Wrapper(myProgressIcon);\n    icon.setBorder(createLeftEdgeBorder());\n\n    inlineComponent.add(icon, BorderLayout.EAST);\n\n    add(inlineComponent);\n\n    myStatusBar.myInfoPanel.revalidate();\n    myStatusBar.myInfoPanel.repaint();\n  }","id":47724,"modified_method":"private void buildInInlineIndicator(final InlineProgressIndicator inline) {\n    removeAll();\n    setLayout(new GridLayout(1, 2));\n    add(myStatusBar.myInfoPanel);\n\n    final JPanel inlinePanel = new JPanel(new BorderLayout());\n\n    inline.getComponent().setBorder(createSeparatorBorder());\n    inlinePanel.add(inline.getComponent(), BorderLayout.CENTER);\n\n    myProgressIcon.setBorder(createSeparatorBorder());\n    inlinePanel.add(myProgressIcon, BorderLayout.EAST);\n\n    add(inlinePanel);\n\n    myStatusBar.myInfoPanel.revalidate();\n    myStatusBar.myInfoPanel.repaint();\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Border createLeftEdgeBorder() {\n    return BorderFactory.createCompoundBorder(new EdgeBorder(EdgeBorder.EDGE_LEFT), new EmptyBorder(0, 0, 0, 0));\n  }","id":47725,"modified_method":"private Border createInsetBorder() {\n    return new EmptyBorder(0, 3, 0, 2);\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InlineProgressIndicator(boolean compact, ProcessInfo processInfo) {\n    myCompact = compact;\n\n    myCancelButton = new InplaceButton(IconLoader.getIcon(\"/actions/cleanLight.png\"), IconLoader.getIcon(\"/actions/clean.png\")) {\n      protected void execute() {\n        cancelRequest();\n      }\n    };\n    myCancelButton.setToolTipText(processInfo.getCancelTooltip());\n\n    if (myCompact) {\n      myComponent.setLayout(new BorderLayout(0, 0));\n      final JPanel textAndProgress = new JPanel(new BorderLayout());\n      myText.setHorizontalAlignment(JLabel.RIGHT);\n      textAndProgress.add(myText, BorderLayout.CENTER);\n      textAndProgress.add(myProgress, BorderLayout.EAST);\n      myComponent.add(textAndProgress, BorderLayout.CENTER);\n      myComponent.add(myCancelButton, BorderLayout.EAST);\n      myComponent.setToolTipText(processInfo.getProcessTitle() + \". \" + IdeBundle.message(\"progress.text.clickToViewProgressWindow\"));\n      myProgress.setActive(false);\n    } else {\n      myComponent.setLayout(new BorderLayout());\n      myComponent.add(myCancelButton, BorderLayout.EAST);\n      myComponent.add(myText, BorderLayout.NORTH);\n      myComponent.add(myProgress, BorderLayout.CENTER);\n      myComponent.add(myText2, BorderLayout.SOUTH);\n    }\n\n    UIUtil.removeQuaquaVisualMarginsIn(myComponent);\n\n    if (!myCompact) {\n      myText.recomputeSize();\n      myText2.recomputeSize();\n    }\n  }","id":47726,"modified_method":"public InlineProgressIndicator(boolean compact, ProcessInfo processInfo) {\n    myCompact = compact;\n\n    myCancelButton = new InplaceButton(IconLoader.getIcon(\"/actions/cleanLight.png\"), IconLoader.getIcon(\"/actions/clean.png\")) {\n      protected void execute() {\n        cancelRequest();\n      }\n    };\n    myCancelButton.setOpaque(true);\n    myCancelButton.setToolTipText(processInfo.getCancelTooltip());\n\n    if (myCompact) {\n      myComponent.setLayout(new BorderLayout(2, 0));\n      final JPanel textAndProgress = new JPanel(new BorderLayout());\n      myText.setHorizontalAlignment(JLabel.RIGHT);\n      textAndProgress.add(myText, BorderLayout.CENTER);\n      textAndProgress.add(myProgress, BorderLayout.EAST);\n      myComponent.add(textAndProgress, BorderLayout.CENTER);\n      myComponent.add(myCancelButton, BorderLayout.EAST);\n      myComponent.setToolTipText(processInfo.getProcessTitle() + \". \" + IdeBundle.message(\"progress.text.clickToViewProgressWindow\"));\n      myProgress.setActive(false);\n    } else {\n      myComponent.setLayout(new BorderLayout());\n      myCancelButton.setBorder(new EmptyBorder(0, 2, 0, 0));\n      myComponent.add(myCancelButton, BorderLayout.EAST);\n      myComponent.add(myText, BorderLayout.NORTH);\n      myComponent.add(myProgress, BorderLayout.CENTER);\n      myComponent.add(myText2, BorderLayout.SOUTH);\n    }\n\n    UIUtil.removeQuaquaVisualMarginsIn(myComponent);\n\n    if (!myCompact) {\n      myText.recomputeSize();\n      myText2.recomputeSize();\n    }\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void paintComponent(final Graphics g) {\n    g.setColor(getBackground());\n    g.fillRect(0, 0, getWidth(), getHeight());\n\n    GradientPaint paint = new GradientPaint(getWidth()/2, 0, getBackground().darker(), getWidth()/2, getHeight()/10, getBackground());\n    final Graphics2D g2 = (Graphics2D) g;\n    g2.setPaint(paint);\n    g.fillRect(0, 0, getWidth(), getHeight()/10);\n\n    paint = new GradientPaint(getWidth()/2, getHeight() - getHeight()/7, getBackground(), getWidth()/2, getHeight() - 1, getBackground().darker());\n    g2.setPaint(paint);\n    g.fillRect(0, getHeight() - getHeight()/7, getWidth(), getHeight());\n  }","id":47727,"modified_method":"protected final void paintComponent(final Graphics g) {\n    g.setColor(getBackground());\n    g.fillRect(0, 0, getWidth(), getHeight());\n\n    final Color dark = getBackground().darker();\n\n    g.setColor(dark);\n    g.drawLine(0, 0, getWidth(), 0);\n\n    final Color lighter = new Color(dark.getRed(), dark.getGreen(), dark.getBlue(), 75);\n    g.setColor(lighter);\n    g.drawLine(0, 1, getWidth(), 1);\n\n    g.drawLine(0, getHeight() - 1, getWidth(), getHeight() - 1);\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void constructUI() {\n    setLayout(new BorderLayout());\n\n    final Border lineBorder = new EdgeBorder(EdgeBorder.EDGE_RIGHT);\n    final Border emptyBorder = BorderFactory.createEmptyBorder(3, 2, 2, 2);\n    final Border compoundBorder = BorderFactory.createCompoundBorder(emptyBorder, lineBorder);\n\n    myInfoPanel.setBorder(emptyBorder);\n    myInfoPanel.setOpaque(false);\n\n    myInfoAndProgressPanel = new InfoAndProgressPanel(this);\n    myInfoAndProgressPanel.setBorder(compoundBorder);\n\n    add(myInfoAndProgressPanel, BorderLayout.CENTER);\n\n    final GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.fill = GridBagConstraints.BOTH;\n    gbConstraints.weightx = 1;\n\n    final JPanel rightPanel = new JPanel(new GridBagLayout());\n    rightPanel.setOpaque(false);\n\n    gbConstraints.fill = GridBagConstraints.VERTICAL;\n    gbConstraints.weightx = 0;\n    gbConstraints.weighty = 1;\n\n    myPositionPanel.setBorder(compoundBorder);\n    myPositionPanel.setOpaque(false);\n    rightPanel.add(myPositionPanel, gbConstraints);\n\n    myToggleReadOnlyAttributePanel.setBorder(compoundBorder);\n    myToggleReadOnlyAttributePanel.setOpaque(false);\n    setWriteStatus(false);\n    rightPanel.add(myToggleReadOnlyAttributePanel, gbConstraints);\n\n    myStatusPanel.setBorder(compoundBorder);\n    myStatusPanel.setOpaque(false);\n    rightPanel.add(myStatusPanel, gbConstraints);\n\n    myEditorHighlightingPanel.setBorder(compoundBorder);\n    myEditorHighlightingPanel.setOpaque(false);\n    rightPanel.add(myEditorHighlightingPanel, gbConstraints);\n\n    myCustomIndicationsPanel.setVisible(false); // Will become visible when any of indications really adds.\n    myCustomIndicationsPanel.setBorder(compoundBorder);\n    myCustomIndicationsPanel.setOpaque(false);\n    rightPanel.add(myCustomIndicationsPanel, gbConstraints);\n\n    myMessagePanel.setOpaque(false);\n    rightPanel.add(myMessagePanel, gbConstraints);\n\n    //  myMemoryUsagePanel.setOpaque(false);\n    myMemoryUsagePanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));\n\n    gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n    gbConstraints.anchor = GridBagConstraints.WEST;\n    rightPanel.add(myMemoryUsagePanel, gbConstraints);\n\n    add(rightPanel, BorderLayout.EAST);\n  }","id":47728,"modified_method":"protected void constructUI() {\n    setLayout(new BorderLayout());\n\n    final Border lineBorder = new SeparatorBorder.Left();\n    final Border emptyBorder = BorderFactory.createEmptyBorder(0, 2, 0, 2);\n    final Border separatorLeft = BorderFactory.createCompoundBorder(emptyBorder, lineBorder);\n\n    myInfoPanel.setBorder(emptyBorder);\n    myInfoPanel.setOpaque(false);\n\n    myInfoAndProgressPanel = new InfoAndProgressPanel(this);\n\n    add(myInfoAndProgressPanel, BorderLayout.CENTER);\n\n    final GridBagConstraints gbConstraints = new GridBagConstraints();\n    gbConstraints.fill = GridBagConstraints.BOTH;\n    gbConstraints.weightx = 1;\n\n    final JPanel rightPanel = new JPanel(new GridBagLayout());\n    rightPanel.setOpaque(false);\n\n    gbConstraints.fill = GridBagConstraints.VERTICAL;\n    gbConstraints.weightx = 0;\n    gbConstraints.weighty = 1;\n\n    myPositionPanel.setBorder(separatorLeft);\n    myPositionPanel.setOpaque(false);\n    rightPanel.add(myPositionPanel, gbConstraints);\n\n    myToggleReadOnlyAttributePanel.setBorder(separatorLeft);\n    myToggleReadOnlyAttributePanel.setOpaque(false);\n    setWriteStatus(false);\n    rightPanel.add(myToggleReadOnlyAttributePanel, gbConstraints);\n\n    myStatusPanel.setBorder(separatorLeft);\n    myStatusPanel.setOpaque(false);\n    rightPanel.add(myStatusPanel, gbConstraints);\n\n    myEditorHighlightingPanel.setBorder(separatorLeft);\n    myEditorHighlightingPanel.setOpaque(false);\n    rightPanel.add(myEditorHighlightingPanel, gbConstraints);\n\n    myCustomIndicationsPanel.setVisible(false); // Will become visible when any of indications really adds.\n    myCustomIndicationsPanel.setBorder(separatorLeft);\n    myCustomIndicationsPanel.setOpaque(false);\n    rightPanel.add(myCustomIndicationsPanel, gbConstraints);\n\n    myMessagePanel.setOpaque(false);\n    rightPanel.add(myMessagePanel, gbConstraints);\n\n    //  myMemoryUsagePanel.setOpaque(false);\n    myMemoryUsagePanel.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));\n\n    gbConstraints.fill = GridBagConstraints.HORIZONTAL;\n    gbConstraints.anchor = GridBagConstraints.WEST;\n    rightPanel.add(myMemoryUsagePanel, gbConstraints);\n\n    add(rightPanel, BorderLayout.EAST);\n\n    setBorder(new EmptyBorder(2, 0, 1, 0));\n  }","commit_id":"4c763145373ce8b171ea3ac40bb10b155f34be3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public XmlAttributeDescriptor[] getAttributeDescriptors(XmlTag xmlTag) {\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      final Map<String, XmlAttributeDescriptor> result = new LinkedHashMap<String, XmlAttributeDescriptor>();\n      for (String directiveName : FileBasedIndex.getInstance().getAllKeys(AngularDirectivesIndex.INDEX_ID, project)) {\n        result.put(directiveName, createDescriptor(project, directiveName));\n      }\n      // marker entry: if ng-model is present then angular.js file was indexed and there's no need to add all\n      // predefined entries\n      if (!result.containsKey(\"ng-model\")) {\n        for (String name : DIRECTIVE_NAMES) {\n          result.put(name, createDescriptor(project, name));\n        }\n      }\n      return result.values().toArray(new XmlAttributeDescriptor[result.size()]);\n    }\n    return DESCRIPTORS;\n  }","id":47729,"modified_method":"@Override\n  public XmlAttributeDescriptor[] getAttributeDescriptors(XmlTag xmlTag) {\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      final Map<String, XmlAttributeDescriptor> result = new LinkedHashMap<String, XmlAttributeDescriptor>();\n      for (String directiveName : FileBasedIndex.getInstance().getAllKeys(AngularDirectivesIndex.INDEX_ID, project)) {\n        result.put(directiveName, createDescriptor(project, directiveName));\n      }\n      return result.values().toArray(new XmlAttributeDescriptor[result.size()]);\n    }\n    return XmlAttributeDescriptor.EMPTY;\n  }","commit_id":"0521127f1ded0b5282efc754125349c5e00ab71b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public XmlAttributeDescriptor getAttributeDescriptor(final String attrName, XmlTag xmlTag) {\n    final String attributeName = normalizeAttributeName(attrName);\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      if (FileBasedIndex.getInstance().getAllKeys(AngularDirectivesIndex.INDEX_ID, project).contains(attributeName) ||\n          // fallback for predefined entries\n          ATTRIBUTE_BY_NAME.containsKey(attributeName)) {\n        return createDescriptor(project, attributeName);\n      }\n    }\n    return ATTRIBUTE_BY_NAME.get(attributeName);\n  }","id":47730,"modified_method":"@Nullable\n  @Override\n  public XmlAttributeDescriptor getAttributeDescriptor(final String attrName, XmlTag xmlTag) {\n    final String attributeName = normalizeAttributeName(attrName);\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      return FileBasedIndex.getInstance().getAllKeys(AngularDirectivesIndex.INDEX_ID, project).contains(attributeName) ?\n             createDescriptor(project, attributeName) : null;\n    }\n    return null;\n  }","commit_id":"0521127f1ded0b5282efc754125349c5e00ab71b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testControllerCompletion() {\n    myFixture.testCompletion(\"controller.html\", \"controller.after.html\", \"custom.js\");\n  }","id":47731,"modified_method":"public void testControllerCompletion() {\n    myFixture.testCompletion(\"controller.html\", \"controller.after.html\", \"custom.js\", \"angular.js\");\n  }","commit_id":"0521127f1ded0b5282efc754125349c5e00ab71b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkMethod(@NotNull PsiMethod psiMethod, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (psiMethod instanceof SyntheticElement) return null;\n    if (IGNORE_DEPRECATED && (psiMethod.isDeprecated() || psiMethod.getContainingClass().isDeprecated())) {\n      return null;\n    }\n    if (myIgnoreSimpleAccessors && PropertyUtil.isSimplePropertyAccessor(psiMethod)) {\n      return null;\n    }\n    PsiDocComment docComment = psiMethod.getDocComment();\n    final PsiMethod[] superMethods = psiMethod.findSuperMethods();\n    final boolean required = isJavaDocRequired(psiMethod);\n    if (docComment == null) {\n      if (required) {\n        if (superMethods.length > 0) return null;\n        ExtensionPoint<Condition<PsiMember>> point = Extensions.getRootArea().getExtensionPoint(ExtensionPoints.JAVADOC_LOCAL);\n        final Condition<PsiMember>[] addins = point.getExtensions();\n        for (Condition<PsiMember> addin : addins) {\n          if (addin.value(psiMethod)) return null;\n        }\n        if (superMethods.length == 0) {\n          final PsiIdentifier nameIdentifier = psiMethod.getNameIdentifier();\n          return nameIdentifier != null ? new ProblemDescriptor[] { createDescriptor(nameIdentifier, REQUIRED_JAVADOC_IS_ABSENT, manager,\n                                                                                     isOnTheFly)} : null;\n        }\n        else {\n          return null;\n        }\n      }\n      else {\n        return null;\n      }\n    }\n\n    final PsiElement[] descriptionElements = docComment.getDescriptionElements();\n    for (PsiElement descriptionElement : descriptionElements) {\n      if (descriptionElement instanceof PsiInlineDocTag) {\n        if (\"inheritDoc\".equals(((PsiInlineDocTag)descriptionElement).getName())) return null;\n      }\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n\n    checkInlineTags(manager, problems, descriptionElements,\n                    JavadocManager.SERVICE.getInstance(docComment.getProject()), isOnTheFly);\n\n    final PsiDocTag tagByName = docComment.findTagByName(\"inheritDoc\");\n    if (tagByName != null) {\n      final String tagName = tagByName.getName();\n      final JavadocTagInfo tagInfo = JavadocManager.SERVICE.getInstance(tagByName.getProject()).getTagInfo(tagName);\n      if (tagInfo != null && tagInfo.isValidInContext(psiMethod)){\n        return null;\n      }\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isReturnRequired = false;\n    boolean isReturnAbsent = true;\n    if (superMethods.length == 0 && !psiMethod.isConstructor() && PsiType.VOID != psiMethod.getReturnType() && isTagRequired(psiMethod, \"return\")) {\n      isReturnRequired = true;\n      for (PsiDocTag tag : tags) {\n        if (\"return\".equals(tag.getName())) {\n          isReturnAbsent = false;\n          break;\n        }\n      }\n    }\n\n    ArrayList<PsiParameter> absentParameters = null;\n    if (required && superMethods.length == 0 && isTagRequired(psiMethod, \"param\") ) {\n      PsiParameter[] params = psiMethod.getParameterList().getParameters();\n      for (PsiParameter param : params) {\n        if (!isFound(tags, param)) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiParameter>(2);\n          absentParameters.add(param);\n        }\n      }\n    }\n\n\n\n    if (required && isReturnRequired && isReturnAbsent) {\n      final PsiIdentifier psiIdentifier = psiMethod.getNameIdentifier();\n      if (psiIdentifier != null) {\n        problems.add(createMissingTagDescriptor(psiIdentifier, \"return\", manager, isOnTheFly));\n      }\n    }\n\n    if (absentParameters != null) {\n      for (PsiParameter psiParameter : absentParameters) {\n        final PsiIdentifier nameIdentifier = psiMethod.getNameIdentifier();\n        if (nameIdentifier != null) {\n          problems.add(createMissingParamTagDescriptor(nameIdentifier, psiParameter, manager, isOnTheFly));\n        }\n      }\n    }\n\n    if (!myIgnoreEmptyDescriptions) {\n      for (PsiDocTag tag : tags) {\n        if (\"param\".equals(tag.getName())) {\n          final PsiElement[] dataElements = tag.getDataElements();\n          final PsiDocTagValue valueElement = tag.getValueElement();\n          boolean hasProblemsWithTag = dataElements.length < 2;\n          if (!hasProblemsWithTag) {\n            final StringBuilder buf = new StringBuilder();\n            for (PsiElement element : dataElements) {\n              if (element != valueElement){\n                buf.append(element.getText());\n              }\n            }\n            hasProblemsWithTag = buf.toString().trim().length() == 0;\n          }\n          if (hasProblemsWithTag) {\n            if (valueElement != null) {\n              problems.add(createDescriptor(valueElement,\n                                            InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@param \" + valueElement.getText() + \"<\/code>\"),\n                                            manager, isOnTheFly));\n            }\n\n          }\n        }\n      }\n    }\n\n    if (required && superMethods.length == 0 && isTagRequired(psiMethod, \"@throws\") && psiMethod.getThrowsList().getReferencedTypes().length > 0) {\n      final Map<PsiClassType, PsiClass> declaredExceptions = new HashMap<PsiClassType, PsiClass>();\n      final PsiClassType[] classTypes = psiMethod.getThrowsList().getReferencedTypes();\n      for (PsiClassType classType : classTypes) {\n        final PsiClass psiClass = classType.resolve();\n        if (psiClass != null){\n          declaredExceptions.put(classType, psiClass);\n        }\n      }\n      processThrowsTags(tags, declaredExceptions, manager, problems, isOnTheFly);\n      if (!declaredExceptions.isEmpty()) {\n        for (PsiClassType declaredException : declaredExceptions.keySet()) {\n          problems.add(createMissingThrowsTagDescriptor(psiMethod, manager, declaredException, isOnTheFly));\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiMethod, tags, manager, isOnTheFly);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n\n    checkForPeriodInDoc(docComment, problems, manager, isOnTheFly);\n    checkForBadCharacters(docComment, problems, manager, isOnTheFly);\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        if (extractTagDescription(tag).length() == 0) {\n          PsiDocTagValue value = tag.getValueElement();\n          if (value instanceof PsiDocParamRef) {\n            PsiDocParamRef paramRef = (PsiDocParamRef)value;\n            PsiParameter[] params = psiMethod.getParameterList().getParameters();\n            for (PsiParameter param : params) {\n              if (paramRef.getReference().isReferenceTo(param)) {\n                problems.add(createDescriptor(value,\n                                              InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor\", \"<code>@param<\/code>\", \"<code>\" + param.getName() + \"<\/code>\"),\n                                              manager, isOnTheFly));\n              }\n            }\n          }\n        }\n      }\n      else\n        if (\"return\".equals(tag.getName()) && !myIgnoreEmptyDescriptions) {\n          if (extractTagDescription(tag).length() == 0) {\n            String message = InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@return<\/code>\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(tag.getNameElement(), message, (LocalQuickFix)null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                           isOnTheFly);\n            problems.add(descriptor);\n          }\n        }\n    }\n\n    checkDuplicateTags(tags, problems, manager, isOnTheFly);\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","id":47732,"modified_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkMethod(@NotNull PsiMethod psiMethod, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (psiMethod instanceof SyntheticElement) return null;\n    if (IGNORE_DEPRECATED && (psiMethod.isDeprecated() || psiMethod.getContainingClass().isDeprecated())) {\n      return null;\n    }\n    if (myIgnoreSimpleAccessors && PropertyUtil.isSimplePropertyAccessor(psiMethod)) {\n      return null;\n    }\n    PsiDocComment docComment = psiMethod.getDocComment();\n    final PsiMethod[] superMethods = psiMethod.findSuperMethods();\n    final boolean required = isJavaDocRequired(psiMethod);\n    if (docComment == null) {\n      if (required) {\n        if (superMethods.length > 0) return null;\n        ExtensionPoint<Condition<PsiMember>> point = Extensions.getRootArea().getExtensionPoint(ExtensionPoints.JAVADOC_LOCAL);\n        final Condition<PsiMember>[] addins = point.getExtensions();\n        for (Condition<PsiMember> addin : addins) {\n          if (addin.value(psiMethod)) return null;\n        }\n        if (superMethods.length == 0) {\n          final PsiIdentifier nameIdentifier = psiMethod.getNameIdentifier();\n          return nameIdentifier != null ? new ProblemDescriptor[] { createDescriptor(nameIdentifier, REQUIRED_JAVADOC_IS_ABSENT, manager,\n                                                                                     isOnTheFly)} : null;\n        }\n        else {\n          return null;\n        }\n      }\n      else {\n        return null;\n      }\n    }\n\n    final PsiElement[] descriptionElements = docComment.getDescriptionElements();\n    for (PsiElement descriptionElement : descriptionElements) {\n      if (descriptionElement instanceof PsiInlineDocTag) {\n        if (\"inheritDoc\".equals(((PsiInlineDocTag)descriptionElement).getName())) return null;\n      }\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n\n    checkInlineTags(manager, problems, descriptionElements,\n                    JavadocManager.SERVICE.getInstance(docComment.getProject()), isOnTheFly);\n\n    final PsiDocTag tagByName = docComment.findTagByName(\"inheritDoc\");\n    if (tagByName != null) {\n      final String tagName = tagByName.getName();\n      final JavadocTagInfo tagInfo = JavadocManager.SERVICE.getInstance(tagByName.getProject()).getTagInfo(tagName);\n      if (tagInfo != null && tagInfo.isValidInContext(psiMethod)){\n        return null;\n      }\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n\n    boolean isReturnRequired = false;\n    boolean isReturnAbsent = true;\n    if (superMethods.length == 0 && !psiMethod.isConstructor() && PsiType.VOID != psiMethod.getReturnType() && isTagRequired(psiMethod, \"return\")) {\n      isReturnRequired = true;\n      for (PsiDocTag tag : tags) {\n        if (\"return\".equals(tag.getName())) {\n          isReturnAbsent = false;\n          break;\n        }\n      }\n    }\n\n    ArrayList<PsiParameter> absentParameters = null;\n    if (required && superMethods.length == 0 && isTagRequired(psiMethod, \"param\") ) {\n      PsiParameter[] params = psiMethod.getParameterList().getParameters();\n      for (PsiParameter param : params) {\n        if (!isFound(tags, param)) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiParameter>(2);\n          absentParameters.add(param);\n        }\n      }\n    }\n\n\n\n    if (required && isReturnRequired && isReturnAbsent) {\n      problems.add(createMissingTagDescriptor(docComment.getFirstChild(), \"return\", manager, isOnTheFly));\n    }\n\n    if (absentParameters != null) {\n      for (PsiParameter psiParameter : absentParameters) {\n        problems.add(createMissingParamTagDescriptor(docComment.getFirstChild(), psiParameter, manager, isOnTheFly));\n      }\n    }\n\n    if (!myIgnoreEmptyDescriptions) {\n      for (PsiDocTag tag : tags) {\n        if (\"param\".equals(tag.getName())) {\n          final PsiElement[] dataElements = tag.getDataElements();\n          final PsiDocTagValue valueElement = tag.getValueElement();\n          boolean hasProblemsWithTag = dataElements.length < 2;\n          if (!hasProblemsWithTag) {\n            final StringBuilder buf = new StringBuilder();\n            for (PsiElement element : dataElements) {\n              if (element != valueElement){\n                buf.append(element.getText());\n              }\n            }\n            hasProblemsWithTag = buf.toString().trim().length() == 0;\n          }\n          if (hasProblemsWithTag) {\n            if (valueElement != null) {\n              problems.add(createDescriptor(valueElement,\n                                            InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@param \" + valueElement.getText() + \"<\/code>\"),\n                                            manager, isOnTheFly));\n            }\n\n          }\n        }\n      }\n    }\n\n    if (required && superMethods.length == 0 && isTagRequired(psiMethod, \"@throws\") && psiMethod.getThrowsList().getReferencedTypes().length > 0) {\n      final Map<PsiClassType, PsiClass> declaredExceptions = new HashMap<PsiClassType, PsiClass>();\n      final PsiClassType[] classTypes = psiMethod.getThrowsList().getReferencedTypes();\n      for (PsiClassType classType : classTypes) {\n        final PsiClass psiClass = classType.resolve();\n        if (psiClass != null){\n          declaredExceptions.put(classType, psiClass);\n        }\n      }\n      processThrowsTags(tags, declaredExceptions, manager, problems, isOnTheFly);\n      if (!declaredExceptions.isEmpty()) {\n        for (PsiClassType declaredException : declaredExceptions.keySet()) {\n          problems.add(createMissingThrowsTagDescriptor(docComment.getFirstChild(), manager, declaredException, isOnTheFly));\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiMethod, tags, manager, isOnTheFly);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n\n    checkForPeriodInDoc(psiMethod, docComment, problems, manager, isOnTheFly);\n    checkForBadCharacters(docComment, problems, manager, isOnTheFly);\n    for (PsiDocTag tag : tags) {\n      if (\"param\".equals(tag.getName())) {\n        if (extractTagDescription(tag).length() == 0) {\n          PsiDocTagValue value = tag.getValueElement();\n          if (value instanceof PsiDocParamRef) {\n            PsiDocParamRef paramRef = (PsiDocParamRef)value;\n            PsiParameter[] params = psiMethod.getParameterList().getParameters();\n            for (PsiParameter param : params) {\n              if (paramRef.getReference().isReferenceTo(param)) {\n                problems.add(createDescriptor(value,\n                                              InspectionsBundle.message(\"inspection.javadoc.method.problem.descriptor\", \"<code>@param<\/code>\", \"<code>\" + param.getName() + \"<\/code>\"),\n                                              manager, isOnTheFly));\n              }\n            }\n          }\n        }\n      }\n      else\n        if (\"return\".equals(tag.getName()) && !myIgnoreEmptyDescriptions) {\n          if (extractTagDescription(tag).length() == 0) {\n            String message = InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>@return<\/code>\");\n            ProblemDescriptor descriptor = manager.createProblemDescriptor(tag.getNameElement(), message, (LocalQuickFix)null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                           isOnTheFly);\n            problems.add(descriptor);\n          }\n        }\n    }\n\n    checkDuplicateTags(tags, problems, manager, isOnTheFly);\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkClass(@NotNull PsiClass psiClass, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (psiClass instanceof PsiAnonymousClass) return null;\n    if (psiClass instanceof PsiSyntheticClass) return null;\n    if (psiClass instanceof PsiTypeParameter) return null;\n    if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {\n      return null;\n    }\n    PsiDocComment docComment = psiClass.getDocComment();\n    final PsiIdentifier nameIdentifier = psiClass.getNameIdentifier();\n    final PsiElement elementToHighlight = nameIdentifier != null ? nameIdentifier : psiClass;\n    final boolean required = isJavaDocRequired(psiClass);\n    if (docComment == null) {\n      return required\n             ? new ProblemDescriptor[]{createDescriptor(elementToHighlight, REQUIRED_JAVADOC_IS_ABSENT, manager, isOnTheFly)}\n             : null;\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n    @NonNls String[] tagsToCheck = {\"author\", \"version\", \"since\"};\n    @NonNls String[] absentDescriptionKeys = {\n      \"inspection.javadoc.problem.missing.author.description\",\n      \"inspection.javadoc.problem.missing.version.description\",\n      \"inspection.javadoc.problem.missing.since.description\"};\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    if (required) {\n      boolean[] isTagRequired = new boolean[tagsToCheck.length];\n      boolean[] isTagPresent = new boolean[tagsToCheck.length];\n\n      boolean someTagsAreRequired = false;\n      for (int i = 0; i < tagsToCheck.length; i++) {\n        final String tag = tagsToCheck[i];\n        someTagsAreRequired |= isTagRequired[i] = isTagRequired(psiClass, tag);\n      }\n\n      if (someTagsAreRequired) {\n        for (PsiDocTag tag : tags) {\n          String tagName = tag.getName();\n          for (int i = 0; i < tagsToCheck.length; i++) {\n            final String tagToCheck = tagsToCheck[i];\n            if (tagToCheck.equals(tagName)) {\n              isTagPresent[i] = true;\n            }\n          }\n        }\n      }\n\n      for (int i = 0; i < tagsToCheck.length; i++) {\n        final String tagToCheck = tagsToCheck[i];\n        if (isTagRequired[i] && !isTagPresent[i]) {\n          problems.add(createMissingTagDescriptor(elementToHighlight, tagToCheck, manager, isOnTheFly));\n        }\n      }\n    }\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiClass, tags, manager, isOnTheFly);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n    checkForPeriodInDoc(docComment, problems, manager, isOnTheFly);\n    checkInlineTags(manager, problems, docComment.getDescriptionElements(),\n                    JavadocManager.SERVICE.getInstance(docComment.getProject()), isOnTheFly);\n    checkForBadCharacters(docComment, problems, manager, isOnTheFly);\n    for (PsiDocTag tag : tags) {\n      for (int i = 0; i < tagsToCheck.length; i++) {\n        final String tagToCheck = tagsToCheck[i];\n        if (tagToCheck.equals(tag.getName()) && extractTagDescription(tag).length() == 0) {\n          problems.add(createDescriptor(elementToHighlight, InspectionsBundle.message(absentDescriptionKeys[i]), manager, isOnTheFly));\n        }\n      }\n    }\n\n    checkDuplicateTags(tags, problems, manager, isOnTheFly);\n\n    if (required && isTagRequired(psiClass, \"param\") && psiClass.hasTypeParameters() && nameIdentifier != null) {\n      ArrayList<PsiTypeParameter> absentParameters = null;\n      final PsiTypeParameter[] typeParameters = psiClass.getTypeParameters();\n      for (PsiTypeParameter typeParameter : typeParameters) {\n        if (!isFound(tags, typeParameter)) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiTypeParameter>(1);\n          absentParameters.add(typeParameter);\n        }\n      }\n      if (absentParameters != null) {\n        for (PsiTypeParameter psiTypeParameter : absentParameters) {\n          problems.add(createMissingParamTagDescriptor(nameIdentifier, psiTypeParameter, manager, isOnTheFly));\n        }\n      }\n    }\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","id":47733,"modified_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkClass(@NotNull PsiClass psiClass, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (psiClass instanceof PsiAnonymousClass) return null;\n    if (psiClass instanceof PsiSyntheticClass) return null;\n    if (psiClass instanceof PsiTypeParameter) return null;\n    if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {\n      return null;\n    }\n    PsiDocComment docComment = psiClass.getDocComment();\n    final PsiIdentifier nameIdentifier = psiClass.getNameIdentifier();\n    final PsiElement elementToHighlight = nameIdentifier != null ? nameIdentifier : psiClass;\n    final boolean required = isJavaDocRequired(psiClass);\n    if (docComment == null) {\n      return required\n             ? new ProblemDescriptor[]{createDescriptor(elementToHighlight, REQUIRED_JAVADOC_IS_ABSENT, manager, isOnTheFly)}\n             : null;\n    }\n\n    PsiDocTag[] tags = docComment.getTags();\n    final ArrayList<ProblemDescriptor> problems = getRequiredTagProblems(psiClass, docComment.getFirstChild(), tags, manager, isOnTheFly, required);\n\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiClass, tags, manager, isOnTheFly);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n    checkForPeriodInDoc(psiClass, docComment, problems, manager, isOnTheFly);\n    checkInlineTags(manager, problems, docComment.getDescriptionElements(),\n                    JavadocManager.SERVICE.getInstance(docComment.getProject()), isOnTheFly);\n    checkForBadCharacters(docComment, problems, manager, isOnTheFly);\n    checkDuplicateTags(tags, problems, manager, isOnTheFly);\n\n    if (required && isTagRequired(psiClass, \"param\") && psiClass.hasTypeParameters() && nameIdentifier != null) {\n      ArrayList<PsiTypeParameter> absentParameters = null;\n      final PsiTypeParameter[] typeParameters = psiClass.getTypeParameters();\n      for (PsiTypeParameter typeParameter : typeParameters) {\n        if (!isFound(tags, typeParameter)) {\n          if (absentParameters == null) absentParameters = new ArrayList<PsiTypeParameter>(1);\n          absentParameters.add(typeParameter);\n        }\n      }\n      if (absentParameters != null) {\n        for (PsiTypeParameter psiTypeParameter : absentParameters) {\n          problems.add(createMissingParamTagDescriptor(nameIdentifier, psiTypeParameter, manager, isOnTheFly));\n        }\n      }\n    }\n\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static ProblemDescriptor createMissingThrowsTagDescriptor(final PsiMethod method,\n                                                                    final InspectionManager manager,\n                                                                    final PsiClassType exceptionClassType, boolean isOnTheFly) {\n    @NonNls String tag = \"throws\";\n    String message = InspectionsBundle.message(\"inspection.javadoc.problem.missing.tag\", \"<code>@\" + tag + \"<\/code> \" + exceptionClassType.getCanonicalText());\n    final String firstDeclaredException = exceptionClassType.getCanonicalText();\n    final PsiIdentifier nameIdentifier = method.getNameIdentifier();\n    return nameIdentifier != null ? createDescriptor(nameIdentifier, message,new AddMissingTagFix(tag, firstDeclaredException), manager,\n                                                     isOnTheFly) : null;\n  }","id":47734,"modified_method":"@Nullable\n  private static ProblemDescriptor createMissingThrowsTagDescriptor(final PsiElement elementToHighlight,\n                                                                    final InspectionManager manager,\n                                                                    final PsiClassType exceptionClassType, boolean isOnTheFly) {\n    @NonNls String tag = \"throws\";\n    String message = InspectionsBundle.message(\"inspection.javadoc.problem.missing.tag\", \"<code>@\" + tag + \"<\/code> \" + exceptionClassType.getCanonicalText());\n    final String firstDeclaredException = exceptionClassType.getCanonicalText();\n    return createDescriptor(elementToHighlight, message, new AddMissingTagFix(tag, firstDeclaredException), manager, isOnTheFly);\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isJavaDocRequired(PsiModifierListOwner psiElement) {\n    final RefJavaUtil refUtil = RefJavaUtil.getInstance();\n    int actualAccess = getAccessNumber(refUtil.getAccessModifier(psiElement));\n    if (psiElement instanceof PsiClass) {\n      PsiClass psiClass = (PsiClass)psiElement;\n      if (PsiTreeUtil.getParentOfType(psiClass, PsiClass.class) != null) {\n        return actualAccess <= getAccessNumber(INNER_CLASS_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n      }\n\n      return actualAccess <= getAccessNumber(TOP_LEVEL_CLASS_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    if (psiElement instanceof PsiMethod) {\n      psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      while (psiElement != null) {\n        actualAccess = Math.max(actualAccess, getAccessNumber(refUtil.getAccessModifier(psiElement)));\n        psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      }\n\n      return actualAccess <= getAccessNumber(METHOD_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    if (psiElement instanceof PsiField) {\n      psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      while (psiElement != null) {\n        actualAccess = Math.max(actualAccess, getAccessNumber(refUtil.getAccessModifier(psiElement)));\n        psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      }\n\n      return actualAccess <= getAccessNumber(FIELD_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    return false;\n  }","id":47735,"modified_method":"private boolean isJavaDocRequired(PsiModifierListOwner psiElement) {\n    final RefJavaUtil refUtil = RefJavaUtil.getInstance();\n    int actualAccess = getAccessNumber(refUtil.getAccessModifier(psiElement));\n    if (psiElement instanceof PsiPackage) {\n      return 1 <= getAccessNumber(PACKAGE_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    if (psiElement instanceof PsiClass) {\n      PsiClass psiClass = (PsiClass)psiElement;\n      if (PsiTreeUtil.getParentOfType(psiClass, PsiClass.class) != null) {\n        return actualAccess <= getAccessNumber(INNER_CLASS_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n      }\n\n      return actualAccess <= getAccessNumber(TOP_LEVEL_CLASS_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    if (psiElement instanceof PsiMethod) {\n      psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      while (psiElement != null) {\n        actualAccess = Math.max(actualAccess, getAccessNumber(refUtil.getAccessModifier(psiElement)));\n        psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      }\n\n      return actualAccess <= getAccessNumber(METHOD_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    if (psiElement instanceof PsiField) {\n      psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      while (psiElement != null) {\n        actualAccess = Math.max(actualAccess, getAccessNumber(refUtil.getAccessModifier(psiElement)));\n        psiElement = PsiTreeUtil.getParentOfType(psiElement, PsiClass.class);\n      }\n\n      return actualAccess <= getAccessNumber(FIELD_OPTIONS.ACCESS_JAVADOC_REQUIRED_FOR);\n    }\n\n    return false;\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"SimplifiableIfStatement\"})\n  private boolean isTagRequired(PsiElement context, @NonNls String tag) {\n    if (context instanceof PsiClass) {\n      if (PsiTreeUtil.getParentOfType(context, PsiClass.class) != null) {\n        return isTagRequired(INNER_CLASS_OPTIONS, tag);\n      }\n\n      return isTagRequired(TOP_LEVEL_CLASS_OPTIONS, tag);\n    }\n\n    if (context instanceof PsiMethod) {\n      return isTagRequired(METHOD_OPTIONS, tag);\n    }\n\n    if (context instanceof PsiField) {\n      return isTagRequired(FIELD_OPTIONS, tag);\n    }\n\n    return false;\n  }","id":47736,"modified_method":"@SuppressWarnings({\"SimplifiableIfStatement\"})\n  private boolean isTagRequired(PsiElement context, @NonNls String tag) {\n    if (context instanceof PsiPackage) {\n      return isTagRequired(PACKAGE_OPTIONS, tag);\n    }\n\n    if (context instanceof PsiClass) {\n      if (PsiTreeUtil.getParentOfType(context, PsiClass.class) != null) {\n        return isTagRequired(INNER_CLASS_OPTIONS, tag);\n      }\n\n      return isTagRequired(TOP_LEVEL_CLASS_OPTIONS, tag);\n    }\n\n    if (context instanceof PsiMethod) {\n      return isTagRequired(METHOD_OPTIONS, tag);\n    }\n\n    if (context instanceof PsiField) {\n      return isTagRequired(FIELD_OPTIONS, tag);\n    }\n\n    return false;\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkField(@NotNull PsiField psiField, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiField.isDeprecated() || psiField.getContainingClass().isDeprecated())) {\n      return null;\n    }\n\n    PsiDocComment docComment = psiField.getDocComment();\n    if (docComment == null) {\n      return isJavaDocRequired(psiField)\n             ? new ProblemDescriptor[]{createDescriptor(psiField.getNameIdentifier(), REQUIRED_JAVADOC_IS_ABSENT, manager, isOnTheFly)}\n             : null;\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiField, docComment.getTags(), manager, isOnTheFly);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n    checkInlineTags(manager, problems, docComment.getDescriptionElements(),\n                    JavadocManager.SERVICE.getInstance(docComment.getProject()), isOnTheFly);\n    checkForPeriodInDoc(docComment, problems, manager, isOnTheFly);\n    checkDuplicateTags(docComment.getTags(), problems, manager, isOnTheFly);\n    checkForBadCharacters(docComment, problems, manager, isOnTheFly);\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","id":47737,"modified_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkField(@NotNull PsiField psiField, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (IGNORE_DEPRECATED && (psiField.isDeprecated() || psiField.getContainingClass().isDeprecated())) {\n      return null;\n    }\n\n    PsiDocComment docComment = psiField.getDocComment();\n    if (docComment == null) {\n      return isJavaDocRequired(psiField)\n             ? new ProblemDescriptor[]{createDescriptor(psiField.getNameIdentifier(), REQUIRED_JAVADOC_IS_ABSENT, manager, isOnTheFly)}\n             : null;\n    }\n\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    ArrayList<ProblemDescriptor> tagProblems = getTagValuesProblems(psiField, docComment.getTags(), manager, isOnTheFly);\n    if (tagProblems != null) {\n      problems.addAll(tagProblems);\n    }\n    checkInlineTags(manager, problems, docComment.getDescriptionElements(),\n                    JavadocManager.SERVICE.getInstance(docComment.getProject()), isOnTheFly);\n    checkForPeriodInDoc(psiField, docComment, problems, manager, isOnTheFly);\n    checkDuplicateTags(docComment.getTags(), problems, manager, isOnTheFly);\n    checkForBadCharacters(docComment, problems, manager, isOnTheFly);\n    return problems.isEmpty()\n           ? null\n           : problems.toArray(new ProblemDescriptor[problems.size()]);\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkForPeriodInDoc(PsiDocComment docComment,\n                                   ArrayList<ProblemDescriptor> problems,\n                                   InspectionManager manager, boolean onTheFly) {\n    if (IGNORE_JAVADOC_PERIOD) return;\n    PsiDocTag[] tags = docComment.getTags();\n    int dotIndex = docComment.getText().indexOf('.');\n    int tagOffset = 0;\n    if (dotIndex >= 0) {      //need to find first valid tag\n      final PsiDocCommentOwner owner = PsiTreeUtil.getParentOfType(docComment, PsiDocCommentOwner.class);\n      for (PsiDocTag tag : tags) {\n        final String tagName = tag.getName();\n        final JavadocTagInfo tagInfo = JavadocManager.SERVICE.getInstance(tag.getProject()).getTagInfo(tagName);\n        if (tagInfo != null && tagInfo.isValidInContext(owner) && !tagInfo.isInline()) {\n          tagOffset = tag.getTextOffset();\n          break;\n        }\n      }\n    }\n\n    if (dotIndex == -1 || tagOffset > 0 && dotIndex + docComment.getTextOffset() > tagOffset) {\n      problems.add(manager.createProblemDescriptor(docComment.getFirstChild(),\n                                                   InspectionsBundle.message(\"inspection.javadoc.problem.descriptor1\"),\n                                                   null,\n                                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING, onTheFly, false));\n    }\n  }","id":47738,"modified_method":"private void checkForPeriodInDoc(PsiElement context,\n                                   PsiDocComment docComment,\n                                   ArrayList<ProblemDescriptor> problems,\n                                   InspectionManager manager, boolean onTheFly) {\n    if (IGNORE_JAVADOC_PERIOD) return;\n    PsiDocTag[] tags = docComment.getTags();\n    int dotIndex = docComment.getText().indexOf('.');\n    int tagOffset = 0;\n    if (dotIndex >= 0) {      //need to find first valid tag\n      for (PsiDocTag tag : tags) {\n        final String tagName = tag.getName();\n        final JavadocTagInfo tagInfo = JavadocManager.SERVICE.getInstance(tag.getProject()).getTagInfo(tagName);\n        if (tagInfo != null && tagInfo.isValidInContext(context) && !tagInfo.isInline()) {\n          tagOffset = tag.getTextOffset();\n          break;\n        }\n      }\n    }\n\n    if (dotIndex == -1 || tagOffset > 0 && dotIndex + docComment.getTextOffset() > tagOffset) {\n      problems.add(manager.createProblemDescriptor(docComment.getFirstChild(),\n                                                   InspectionsBundle.message(\"inspection.javadoc.problem.descriptor1\"),\n                                                   null,\n                                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING, onTheFly, false));\n    }\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ArrayList<ProblemDescriptor> getTagValuesProblems(PsiDocCommentOwner context, PsiDocTag[] tags, InspectionManager inspectionManager,\n                                                            boolean isOnTheFly) {\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    nextTag:\n    for (PsiDocTag tag : tags) {\n      final JavadocManager manager = JavadocManager.SERVICE.getInstance(tag.getProject());\n      String tagName = tag.getName();\n      JavadocTagInfo tagInfo = manager.getTagInfo(tagName);\n\n      if (tagInfo == null || !tagInfo.isValidInContext(context)) {\n        if (checkTagInfo(inspectionManager, tagInfo, tag, isOnTheFly, problems)) continue nextTag;\n      }\n\n      PsiDocTagValue value = tag.getValueElement();\n      final JavadocTagInfo info = manager.getTagInfo(tagName);\n      if (info != null && !info.isValidInContext(context)) continue;\n      String message = info == null ? null : info.checkTagValue(value);\n\n      final PsiReference reference = value != null ? value.getReference() : null;\n      if (message == null && reference != null) {\n        PsiElement element = reference.resolve();\n        if (element == null) {\n          final int textOffset = value.getTextOffset();\n\n          if (textOffset == value.getTextRange().getEndOffset()) {\n            problems.add(inspectionManager.createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.problem.name.expected\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                   isOnTheFly, true));\n          }\n        }\n      }\n\n      if (message != null) {\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        if (valueElement == null){\n          problems.add(inspectionManager.createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.method.problem.missing.tag.description\", \"<code>\" + tag.getName() + \"<\/code>\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                 isOnTheFly, true));\n        } else {\n          problems.add(createDescriptor(valueElement, message, inspectionManager, isOnTheFly));\n        }\n      }\n      checkInlineTags(inspectionManager, problems, tag.getDataElements(), manager, isOnTheFly);\n    }\n\n    return problems.isEmpty() ? null : problems;\n  }","id":47739,"modified_method":"@Nullable\n  private ArrayList<ProblemDescriptor> getTagValuesProblems(PsiElement context, PsiDocTag[] tags, InspectionManager inspectionManager,\n                                                            boolean isOnTheFly) {\n    final ArrayList<ProblemDescriptor> problems = new ArrayList<ProblemDescriptor>(2);\n    for (PsiDocTag tag : tags) {\n      final JavadocManager manager = JavadocManager.SERVICE.getInstance(tag.getProject());\n      String tagName = tag.getName();\n      JavadocTagInfo tagInfo = manager.getTagInfo(tagName);\n\n      if (tagInfo == null || !tagInfo.isValidInContext(context)) {\n        if (checkTagInfo(inspectionManager, tagInfo, tag, isOnTheFly, problems)) continue;\n      }\n\n      PsiDocTagValue value = tag.getValueElement();\n      if (tagInfo != null && !tagInfo.isValidInContext(context)) continue;\n      String message = tagInfo == null ? null : tagInfo.checkTagValue(value);\n\n      final PsiReference reference = value != null ? value.getReference() : null;\n      if (message == null && reference != null) {\n        PsiElement element = reference.resolve();\n        if (element == null) {\n          final int textOffset = value.getTextOffset();\n\n          if (textOffset == value.getTextRange().getEndOffset()) {\n            problems.add(inspectionManager.createProblemDescriptor(tag, InspectionsBundle.message(\"inspection.javadoc.problem.name.expected\"), null, ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                   isOnTheFly, true));\n          }\n        }\n      }\n\n      if (message != null) {\n        final PsiDocTagValue valueElement = tag.getValueElement();\n        if (valueElement == null){\n          problems.add(inspectionManager.createProblemDescriptor(tag, InspectionsBundle.message(\n            \"inspection.javadoc.method.problem.missing.tag.description\", \"<code>\" + tag.getName() + \"<\/code>\"), (LocalQuickFix)null,\n                                                                 ProblemHighlightType.GENERIC_ERROR_OR_WARNING, isOnTheFly)); }\n        else {\n          problems.add(createDescriptor(valueElement, message, inspectionManager, isOnTheFly));\n        }\n      }\n      checkInlineTags(inspectionManager, problems, tag.getDataElements(), manager, isOnTheFly);\n    }\n\n    return problems.isEmpty() ? null : problems;\n  }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OptionsPanel() {\n      super(new GridBagLayout());\n      GridBagConstraints gc = new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1, 0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0),0,0 );\n      add(createAdditionalJavadocTagsPanel(), gc);\n      JTabbedPane tabs = new JBTabbedPane(SwingConstants.BOTTOM);\n      @NonNls String[] tags = new String[]{\"@author\", \"@version\", \"@since\", \"@param\"};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title\"), createOptionsPanel(new String[]{NONE, PUBLIC, PACKAGE_LOCAL},\n                                                                                                    tags,\n                                                                                                    TOP_LEVEL_CLASS_OPTIONS));\n      tags = new String[]{\"@return\", \"@param\", InspectionsBundle.message(\"inspection.javadoc.throws.or.exception.option\")};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.method\"), createOptionsPanel(new String[]{NONE, PUBLIC, PROTECTED, PACKAGE_LOCAL, PRIVATE},\n                                                                                                           tags,\n                                                                                                           METHOD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.field\"), createOptionsPanel(new String[]{NONE, PUBLIC, PROTECTED, PACKAGE_LOCAL, PRIVATE},\n                                                                                                          null,\n                                                                                                          FIELD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.inner.class\"), createOptionsPanel(new String[]{NONE, PUBLIC, PROTECTED, PACKAGE_LOCAL, PRIVATE},\n                                                                                                                null,\n                                                                                                                INNER_CLASS_OPTIONS));\n      add(tabs, gc);\n\n      final JCheckBox checkBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.deprecated\"),\n                                               IGNORE_DEPRECATED);\n      checkBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_DEPRECATED = checkBox.isSelected();\n        }\n      });\n      gc.gridwidth = 1;\n      add(checkBox, gc);\n      final JCheckBox periodCheckBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.period\"),\n                                                     IGNORE_JAVADOC_PERIOD);\n      periodCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_JAVADOC_PERIOD = periodCheckBox.isSelected();\n        }\n      });\n      add(periodCheckBox, gc);\n\n      final JCheckBox ignoreDuplicateThrowsCheckBox = new JCheckBox(\"Ignore duplicate throws tag\",\n                                                     IGNORE_DUPLICATED_THROWS);\n      ignoreDuplicateThrowsCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_DUPLICATED_THROWS = ignoreDuplicateThrowsCheckBox.isSelected();\n        }\n      });\n      add(ignoreDuplicateThrowsCheckBox, gc);\n\n      final JCheckBox ignorePointToItselfCheckBox = new JCheckBox(\"Ignore javadoc pointing to itself\", IGNORE_POINT_TO_ITSELF);\n      ignorePointToItselfCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_POINT_TO_ITSELF = ignorePointToItselfCheckBox.isSelected();\n        }\n      });\n      add(ignorePointToItselfCheckBox, gc);\n      final JCheckBox ignoreSimpleAccessorsCheckBox = new JCheckBox(\"Ignore simple property accessors\", myIgnoreSimpleAccessors);\n      ignoreSimpleAccessorsCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          myIgnoreSimpleAccessors = ignoreSimpleAccessorsCheckBox.isSelected();\n        }\n      });\n      add(ignoreSimpleAccessorsCheckBox, gc);\n    }","id":47740,"modified_method":"public OptionsPanel() {\n      super(new GridBagLayout());\n      GridBagConstraints gc = new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1, 0, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL, new Insets(0,0,0,0),0,0 );\n      add(createAdditionalJavadocTagsPanel(), gc);\n      JTabbedPane tabs = new JBTabbedPane(SwingConstants.BOTTOM);\n      @NonNls String[] tags;\n      tags = new String[]{\"@author\", \"@version\", \"@since\"};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.package\"), createOptionsPanel(new String[]{NONE, PUBLIC},\n                                                                                                            tags,PACKAGE_OPTIONS));\n\n      tags = new String[]{\"@author\", \"@version\", \"@since\", \"@param\"};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title\"), createOptionsPanel(new String[]{NONE, PUBLIC, PACKAGE_LOCAL},\n                                                                                                    tags,\n                                                                                                    TOP_LEVEL_CLASS_OPTIONS));\n      tags = new String[]{\"@return\", \"@param\", InspectionsBundle.message(\"inspection.javadoc.throws.or.exception.option\")};\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.method\"), createOptionsPanel(new String[]{NONE, PUBLIC, PROTECTED, PACKAGE_LOCAL, PRIVATE},\n                                                                                                           tags,\n                                                                                                           METHOD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.field\"), createOptionsPanel(new String[]{NONE, PUBLIC, PROTECTED, PACKAGE_LOCAL, PRIVATE},\n                                                                                                          null,\n                                                                                                          FIELD_OPTIONS));\n      tabs.add(InspectionsBundle.message(\"inspection.javadoc.option.tab.title.inner.class\"), createOptionsPanel(new String[]{NONE, PUBLIC, PROTECTED, PACKAGE_LOCAL, PRIVATE},\n                                                                                                                null,\n                                                                                                                INNER_CLASS_OPTIONS));\n      add(tabs, gc);\n\n      final JCheckBox checkBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.deprecated\"),\n                                               IGNORE_DEPRECATED);\n      checkBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_DEPRECATED = checkBox.isSelected();\n        }\n      });\n      gc.gridwidth = 1;\n      add(checkBox, gc);\n      final JCheckBox periodCheckBox = new JCheckBox(InspectionsBundle.message(\"inspection.javadoc.option.ignore.period\"),\n                                                     IGNORE_JAVADOC_PERIOD);\n      periodCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_JAVADOC_PERIOD = periodCheckBox.isSelected();\n        }\n      });\n      add(periodCheckBox, gc);\n\n      final JCheckBox ignoreDuplicateThrowsCheckBox = new JCheckBox(\"Ignore duplicate throws tag\",\n                                                     IGNORE_DUPLICATED_THROWS);\n      ignoreDuplicateThrowsCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_DUPLICATED_THROWS = ignoreDuplicateThrowsCheckBox.isSelected();\n        }\n      });\n      add(ignoreDuplicateThrowsCheckBox, gc);\n\n      final JCheckBox ignorePointToItselfCheckBox = new JCheckBox(\"Ignore javadoc pointing to itself\", IGNORE_POINT_TO_ITSELF);\n      ignorePointToItselfCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          IGNORE_POINT_TO_ITSELF = ignorePointToItselfCheckBox.isSelected();\n        }\n      });\n      add(ignorePointToItselfCheckBox, gc);\n      final JCheckBox ignoreSimpleAccessorsCheckBox = new JCheckBox(\"Ignore simple property accessors\", myIgnoreSimpleAccessors);\n      ignoreSimpleAccessorsCheckBox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          myIgnoreSimpleAccessors = ignoreSimpleAccessorsCheckBox.isSelected();\n        }\n      });\n      add(ignoreSimpleAccessorsCheckBox, gc);\n    }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory();\n      try {\n        final PsiDocCommentOwner owner = PsiTreeUtil.getParentOfType(descriptor.getEndElement(), PsiDocCommentOwner.class);\n        if (owner != null) {\n          if (!CodeInsightUtil.preparePsiElementsForWrite(owner)) return;\n          final PsiDocComment docComment = owner.getDocComment();\n          final PsiDocTag tag = factory.createDocTagFromText(\"@\" + myTag + \" \" + myValue);\n          if (docComment != null) {\n            PsiElement addedTag;\n            final PsiElement anchor = getAnchor(descriptor);\n            if (anchor != null) {\n              addedTag = docComment.addBefore(tag, anchor);\n            }\n            else {\n              addedTag = docComment.add(tag);\n            }\n            moveCaretTo(addedTag);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }","id":47741,"modified_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory();\n      try {\n        final PsiDocComment docComment = PsiTreeUtil.getParentOfType(descriptor.getEndElement(), PsiDocComment.class);\n        if (docComment != null) {\n          if (!CodeInsightUtil.preparePsiElementsForWrite(docComment)) return;\n          final PsiDocTag tag = factory.createDocTagFromText(\"@\" + myTag + \" \" + myValue);\n          PsiElement addedTag;\n          final PsiElement anchor = getAnchor(descriptor);\n          if (anchor != null) {\n            addedTag = docComment.addBefore(tag, anchor);\n          }\n          else {\n            addedTag = docComment.add(tag);\n          }\n          moveCaretTo(addedTag);\n        }\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n    }","commit_id":"a8695ad7d5584d7fa5e8ab533b9de74ad5a32f79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AngularBindingDescriptor(Project project,\n                                  String attributeName) {\n    super(project, attributeName, null);\n  }","id":47742,"modified_method":"public AngularBindingDescriptor(PsiElement element,\n                                  String attributeName) {\n    super(element.getProject(), attributeName, null);\n    myElement = element;\n  }","commit_id":"ed43d978381935ce00c7f70b66d9d82ff49b0a42","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public XmlAttributeDescriptor getAttributeDescriptor(final String attrName, XmlTag xmlTag) {\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      if (AngularAttributesRegistry.isEventAttribute(attrName, project) ||\n          AngularAttributesRegistry.isVariableAttribute(attrName, project)) {\n        return createDescriptor(project, attrName);\n      }\n      if (AngularAttributesRegistry.isBindingAttribute(attrName, project)) {\n        return new AngularBindingDescriptor(project, attrName);\n      }\n\n      final String attributeName = DirectiveUtil.normalizeAttributeName(attrName);\n      ThreeState attributeAvailable = isApplicable(project, attributeName, xmlTag, AngularDirectivesDocIndex.KEY);\n      if (attributeAvailable == ThreeState.UNSURE) {\n        attributeAvailable = isApplicable(project, attributeName, xmlTag, AngularDirectivesIndex.KEY);\n      }\n      return attributeAvailable == ThreeState.YES ? createDescriptor(project, attributeName) : null;\n    }\n    return null;\n  }","id":47743,"modified_method":"@Nullable\n  @Override\n  public XmlAttributeDescriptor getAttributeDescriptor(final String attrName, XmlTag xmlTag) {\n    if (xmlTag != null) {\n      final Project project = xmlTag.getProject();\n      if (AngularAttributesRegistry.isEventAttribute(attrName, project) ||\n          AngularAttributesRegistry.isVariableAttribute(attrName, project)) {\n        return createDescriptor(project, attrName);\n      }\n\n      final String attributeName = DirectiveUtil.normalizeAttributeName(attrName);\n      ThreeState attributeAvailable = isApplicable(project, attributeName, xmlTag, AngularDirectivesDocIndex.KEY);\n      if (attributeAvailable == ThreeState.UNSURE) {\n        attributeAvailable = isApplicable(project, attributeName, xmlTag, AngularDirectivesIndex.KEY);\n      }\n      if (attributeAvailable == ThreeState.YES) {\n        return createDescriptor(project, attributeName);\n      }\n      if (AngularAttributesRegistry.isBindingAttribute(attrName, project)) {\n        return new AngularBindingDescriptor(xmlTag, attrName);\n      }\n    }\n    return null;\n  }","commit_id":"ed43d978381935ce00c7f70b66d9d82ff49b0a42","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public XmlAttributeDescriptor[] getAttributesDescriptors(@Nullable XmlTag context) {\n    final String string = getDeclaration().getTypeString();\n    final String attributes = string.split(\";\", -1)[3];\n    final String[] split = attributes.split(\",\");\n    final XmlAttributeDescriptor[] result;\n    if (split.length == 1 && split[0].isEmpty()) {\n      result = XmlAttributeDescriptor.EMPTY;\n    } else {\n      result = new XmlAttributeDescriptor[split.length];\n      for (int i = 0; i < split.length; i++) {\n        result[i] = new AnyXmlAttributeDescriptor(DirectiveUtil.getAttributeName(split[i]));\n      }\n    }\n\n    final XmlAttributeDescriptor[] commonAttributes = HtmlNSDescriptorImpl.getCommonAttributeDescriptors(context);\n    return ArrayUtil.mergeArrays(result, commonAttributes);\n  }","id":47744,"modified_method":"@Override\n  public XmlAttributeDescriptor[] getAttributesDescriptors(@Nullable XmlTag context) {\n    final JSImplicitElement declaration = getDeclaration();\n    final String string = declaration.getTypeString();\n    final String attributes = string.split(\";\", -1)[3];\n    final String[] split = attributes.split(\",\");\n    final XmlAttributeDescriptor[] result;\n    if (context != null && AngularIndexUtil.hasAngularJS2(context.getProject())) {\n      result = AngularBindingDescriptor.getBindingDescriptors(declaration);\n    } else if (split.length == 1 && split[0].isEmpty()) {\n      result = XmlAttributeDescriptor.EMPTY;\n    } else {\n      result = new XmlAttributeDescriptor[split.length];\n      for (int i = 0; i < split.length; i++) {\n        result[i] = new AnyXmlAttributeDescriptor(DirectiveUtil.getAttributeName(split[i]));\n      }\n    }\n    final XmlAttributeDescriptor[] commonAttributes = HtmlNSDescriptorImpl.getCommonAttributeDescriptors(context);\n    return ArrayUtil.mergeArrays(result, commonAttributes);\n  }","commit_id":"ed43d978381935ce00c7f70b66d9d82ff49b0a42","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n\t * select contacts and apply sort\n\t * \n\t * @param qp\n\t *            the query parameter\n\t * \n\t * @return list of contacts\n\t */\n\tpublic Iterator<Contact> find(QueryParam qp)\n\t{\n\t\tList<Contact> sublist = getIndex(qp.getSort(), qp.isSortAsc()).subList(qp.getFirst(),\n\t\t\tqp.getFirst() + qp.getCount());\n\t\treturn sublist.iterator();\n\t}","id":47745,"modified_method":"/**\n\t * select contacts and apply sort\n\t * \n\t * @param qp\n\t *            the query parameter\n\t * \n\t * @return list of contacts\n\t */\n\tpublic Iterator<Contact> find(QueryParam qp)\n\t{\n\t\tList<Contact> sublist = getIndex(qp.getSort()).subList(qp.getFirst(),\n\t\t\tqp.getFirst() + qp.getCount());\n\t\treturn sublist.iterator();\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * retrieves contacts from database starting with index <code>first<\/code> and ending with\n\t * <code>first+count<\/code>\n\t * \n\t * @see org.apache.wicket.markup.repeater.data.IDataProvider#iterator(int, int)\n\t */\n\tpublic Iterator<Contact> iterator(int first, int count)\n\t{\n\t\treturn getContactsDB().find(first, count, \"firstName\", true).iterator();\n\t}","id":47746,"modified_method":"/**\n\t * retrieves contacts from database starting with index <code>first<\/code> and ending with\n\t * <code>first+count<\/code>\n\t * \n\t * @see org.apache.wicket.markup.repeater.data.IDataProvider#iterator(int, int)\n\t */\n\tpublic Iterator<Contact> iterator(int first, int count)\n\t{\n\t\treturn getContactsDB().find(first, count, new SortParam(\"firstName\", SortOrder.ASCENDING)).iterator();\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"public final Iterator iterator(int first, int count)\n\t{\n\t\tQueryParam qp = new QueryParam(first, count, getSort().getProperty(), getSort()\n\t\t\t\t.isAscending());\n\t\treturn getContactDao().find(qp);\n\t}","id":47747,"modified_method":"public final Iterator iterator(int first, int count)\n\t{\n\t\tQueryParam qp = new QueryParam(first, count, getSort());\n\t\treturn getContactDao().find(qp);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"public ContactDataProvider()\n\t{\n\t\tsetSort(\"firstName\", true);\n\t}","id":47748,"modified_method":"public ContactDataProvider()\n\t{\n\t\tsetSort(\"firstName\", SortOrder.ASCENDING);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * delete contact from the database\r\n\t * \r\n\t * @param contact\r\n\t */\r\n\tpublic void delete(final Contact contact)\r\n\t{\r\n\t\tContact c = map.remove(contact.getId());\r\n\r\n\t\tfnameIdx.remove(contact);\r\n\t\tlnameIdx.remove(contact);\r\n\t\tfnameDescIdx.remove(contact);\r\n\t\tlnameDescIdx.remove(contact);\r\n\r\n\t\tcontact.setId(0);\r\n\t}","id":47749,"modified_method":"/**\r\n\t * delete contact from the database\r\n\t * \r\n\t * @param contact\r\n\t */\r\n\tpublic void delete(final Contact contact)\r\n\t{\r\n\t\tmap.remove(contact.getId());\r\n\r\n\t\tfnameIdx.remove(contact);\r\n\t\tlnameIdx.remove(contact);\r\n\t\tfnameDescIdx.remove(contact);\r\n\t\tlnameDescIdx.remove(contact);\r\n\r\n\t\tcontact.setId(0);\r\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * delete contact from the database\n\t * \n\t * @param contact\n\t */\n\tpublic void delete(final Contact contact)\n\t{\n\t\tContact c = map.remove(contact.getId());\n\n\t\tfnameIdx.remove(contact);\n\t\tlnameIdx.remove(contact);\n\t\tfnameDescIdx.remove(contact);\n\t\tlnameDescIdx.remove(contact);\n\n\t\tcontact.setId(0);\n\t}","id":47750,"modified_method":"/**\n\t * delete contact from the database\n\t * \n\t * @param contact\n\t */\n\tpublic void delete(final Contact contact)\n\t{\n\t\tmap.remove(contact.getId());\n\n\t\tfnameIdx.remove(contact);\n\t\tlnameIdx.remove(contact);\n\t\tfnameDescIdx.remove(contact);\n\t\tlnameDescIdx.remove(contact);\n\n\t\tcontact.setId(0);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * constructor\n\t */\n\tpublic FormPage()\n\t{\n\t\tform = new Form(\"form\");\n\t\tadd(form);\n\n\t\t// create a repeater that will display the list of contacts.\n\t\tRefreshingView<Contact> refreshingView = new RefreshingView<Contact>(\"simple\")\n\t\t{\n\t\t\t@Override\n\t\t\tprotected Iterator<IModel<Contact>> getItemModels()\n\t\t\t{\n\t\t\t\t// for simplicity we only show the first 10 contacts\n\t\t\t\tIterator<Contact> contacts = DatabaseLocator.getDatabase().find(0, 10, \"firstName\",\n\t\t\t\t\ttrue).iterator();\n\n\t\t\t\t// the iterator returns contact objects, but we need it to\n\t\t\t\t// return models, we use this handy adapter class to perform\n\t\t\t\t// on-the-fly conversion.\n\t\t\t\treturn new ModelIteratorAdapter<Contact>(contacts)\n\t\t\t\t{\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected IModel<Contact> model(Contact object)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new CompoundPropertyModel<Contact>(\n\t\t\t\t\t\t\tnew DetachableContactModel(object));\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final Item<Contact> item)\n\t\t\t{\n\t\t\t\t// populate the row of the repeater\n\t\t\t\tIModel<Contact> contact = item.getModel();\n\t\t\t\titem.add(new ActionPanel(\"actions\", contact));\n\t\t\t\titem.add(new TextField<Long>(\"id\"));\n\t\t\t\titem.add(new TextField<String>(\"firstName\"));\n\t\t\t\titem.add(new TextField<String>(\"lastName\"));\n\t\t\t\titem.add(new TextField<String>(\"homePhone\"));\n\t\t\t\titem.add(new TextField<String>(\"cellPhone\"));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected Item<Contact> newItem(String id, int index, IModel<Contact> model)\n\t\t\t{\n\t\t\t\t// this item sets markup class attribute to either 'odd' or\n\t\t\t\t// 'even' for decoration\n\t\t\t\treturn new OddEvenItem<Contact>(id, index, model);\n\t\t\t}\n\t\t};\n\n\t\t// because we are in a form we need to preserve state of the component\n\t\t// hierarchy (because it might contain things like form errors that\n\t\t// would be lost if the hierarchy for each item was recreated every\n\t\t// request by default), so we use an item reuse strategy.\n\t\trefreshingView.setItemReuseStrategy(ReuseIfModelsEqualStrategy.getInstance());\n\n\n\t\tform.add(refreshingView);\n\t}","id":47751,"modified_method":"/**\n\t * constructor\n\t */\n\tpublic FormPage()\n\t{\n\t\tform = new Form(\"form\");\n\t\tadd(form);\n\n\t\t// create a repeater that will display the list of contacts.\n\t\tRefreshingView<Contact> refreshingView = new RefreshingView<Contact>(\"simple\")\n\t\t{\n\t\t\t@Override\n\t\t\tprotected Iterator<IModel<Contact>> getItemModels()\n\t\t\t{\n\t\t\t\t// for simplicity we only show the first 10 contacts\n\t\t\t\tSortParam sort = new SortParam(\"firstName\", SortOrder.ASCENDING);\n\t\t\t\tIterator<Contact> contacts = DatabaseLocator.getDatabase().find(0, 10, sort).iterator();\n\n\t\t\t\t// the iterator returns contact objects, but we need it to\n\t\t\t\t// return models, we use this handy adapter class to perform\n\t\t\t\t// on-the-fly conversion.\n\t\t\t\treturn new ModelIteratorAdapter<Contact>(contacts)\n\t\t\t\t{\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected IModel<Contact> model(Contact object)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new CompoundPropertyModel<Contact>(\n\t\t\t\t\t\t\tnew DetachableContactModel(object));\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final Item<Contact> item)\n\t\t\t{\n\t\t\t\t// populate the row of the repeater\n\t\t\t\tIModel<Contact> contact = item.getModel();\n\t\t\t\titem.add(new ActionPanel(\"actions\", contact));\n\t\t\t\titem.add(new TextField<Long>(\"id\"));\n\t\t\t\titem.add(new TextField<String>(\"firstName\"));\n\t\t\t\titem.add(new TextField<String>(\"lastName\"));\n\t\t\t\titem.add(new TextField<String>(\"homePhone\"));\n\t\t\t\titem.add(new TextField<String>(\"cellPhone\"));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected Item<Contact> newItem(String id, int index, IModel<Contact> model)\n\t\t\t{\n\t\t\t\t// this item sets markup class attribute to either 'odd' or\n\t\t\t\t// 'even' for decoration\n\t\t\t\treturn new OddEvenItem<Contact>(id, index, model);\n\t\t\t}\n\t\t};\n\n\t\t// because we are in a form we need to preserve state of the component\n\t\t// hierarchy (because it might contain things like form errors that\n\t\t// would be lost if the hierarchy for each item was recreated every\n\t\t// request by default), so we use an item reuse strategy.\n\t\trefreshingView.setItemReuseStrategy(ReuseIfModelsEqualStrategy.getInstance());\n\n\n\t\tform.add(refreshingView);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see org.apache.wicket.extensions.markup.html.repeater.data.sort.OrderByLink.ICssProvider#getClassAttributeValue(org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortState,\n\t\t *      java.lang.String)\n\t\t */\n\t\tpublic String getClassAttributeValue(ISortState state, String property)\n\t\t{\n\t\t\tint dir = state.getPropertySortOrder(property);\n\t\t\tif (dir == ISortState.ASCENDING)\n\t\t\t{\n\t\t\t\treturn ascending;\n\t\t\t}\n\t\t\telse if (dir == ISortState.DESCENDING)\n\t\t\t{\n\t\t\t\treturn descending;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn none;\n\t\t\t}\n\t\t}","id":47752,"modified_method":"/**\n\t\t * @see org.apache.wicket.extensions.markup.html.repeater.data.sort.OrderByLink.ICssProvider#getClassAttributeValue(org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortState,\n\t\t *      java.lang.String)\n\t\t */\n\t\tpublic String getClassAttributeValue(ISortState state, String property)\n\t\t{\n\t\t\tSortOrder dir = state.getPropertySortOrder(property);\n\t\t\tif (dir == SortOrder.ASCENDING)\n\t\t\t{\n\t\t\t\treturn ascending;\n\t\t\t}\n\t\t\telse if (dir == SortOrder.DESCENDING)\n\t\t\t{\n\t\t\t\treturn descending;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn none;\n\t\t\t}\n\t\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Re-sort data provider according to this link\n\t * \n\t * @return this\n\t */\n\tpublic final OrderByLink sort()\n\t{\n\t\tif (isVersioned())\n\t\t{\n\t\t\t// version the old state\n\t\t\taddStateChange();\n\t\t}\n\n\t\tISortState state = stateLocator.getSortState();\n\n\t\tint oldDir = state.getPropertySortOrder(property);\n\n\t\tint newDir = ISortState.ASCENDING;\n\n\t\tif (oldDir == ISortState.ASCENDING)\n\t\t{\n\t\t\tnewDir = ISortState.DESCENDING;\n\t\t}\n\n\t\tstate.setPropertySortOrder(property, newDir);\n\n\t\treturn this;\n\t}","id":47753,"modified_method":"/**\n\t * Re-sort data provider according to this link\n\t * \n\t * @return this\n\t */\n\tpublic final OrderByLink sort()\n\t{\n\t\tif (isVersioned())\n\t\t{\n\t\t\t// version the old state\n\t\t\taddStateChange();\n\t\t}\n\n\t\tISortState state = stateLocator.getSortState();\n\t\tSortOrder order = state.getPropertySortOrder(property);\n\t\tstate.setPropertySortOrder(property, order.nextOrderInCycle());\n\n\t\treturn this;\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Set to return <tt>count<\/tt> elements, starting at the <tt>first<\/tt> element.\n\t * \n\t * @param first\n\t *            First element to return.\n\t * @param count\n\t *            Number of elements to return.\n\t */\n\tpublic QueryParam(int first, int count)\n\t{\n\t\tthis(first, count, null, true);\n\t}","id":47754,"modified_method":"/**\n\t * Set to return <tt>count<\/tt> elements, starting at the <tt>first<\/tt> element.\n\t * \n\t * @param first\n\t *            First element to return.\n\t * @param count\n\t *            Number of elements to return.\n\t */\n\tpublic QueryParam(int first, int count)\n\t{\n\t\tthis(first, count, null);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"public String getSort()\n\t{\n\t\treturn sort;\n\t}","id":47755,"modified_method":"public SortParam getSort()\n\t{\n\t\treturn sort;\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Set to return <tt>count<\/tt> sorted elements, starting at the <tt>first<\/tt> element.\n\t * \n\t * @param first\n\t *            First element to return.\n\t * @param count\n\t *            Number of elements to return.\n\t * @param sort\n\t *            Column to sort on.\n\t * @param sortAsc\n\t *            Sort ascending or descending.\n\t */\n\tpublic QueryParam(int first, int count, String sort, boolean sortAsc)\n\t{\n\t\tthis.first = first;\n\t\tthis.count = count;\n\t\tthis.sort = sort;\n\t\tthis.sortAsc = sortAsc;\n\t}","id":47756,"modified_method":"/**\n\t * Set to return <tt>count<\/tt> sorted elements, starting at the <tt>first<\/tt> element.\n\t * \n\t * @param first\n\t *            First element to return.\n\t * @param count\n *            Number of elements to return.\n\t * @param sort\n\t */\n\tpublic QueryParam(int first, int count, SortParam sort)\n\t{\n\t\tthis.first = first;\n\t\tthis.count = count;\n\t\tthis.sort = sort;\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortState#setPropertySortOrder(java.lang.String,\n\t *      int)\n\t */\n\tpublic void setPropertySortOrder(String property, int dir)\n\t{\n\t\tif (property == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument [property] cannot be null\");\n\t\t}\n\n\t\tparam = new SortParam(property, dir == ISortState.ASCENDING);\n\t}","id":47757,"modified_method":"/**\n\t * @see org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortState#setPropertySortOrder(String, org.apache.wicket.extensions.markup.html.repeater.data.sort.SortOrder)\n\t */\n\tpublic void setPropertySortOrder(String property, SortOrder order)\n\t{\n\t\tArgs.notNull(property, \"property\");\n\t\tArgs.notNull(order, \"order\");\n\n\t\tparam = new SortParam(property, order);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortState#getPropertySortOrder(java.lang.String)\n\t */\n\tpublic int getPropertySortOrder(String property)\n\t{\n\t\tif (property == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"argument [property] cannot be null\");\n\t\t}\n\n\t\tif (param == null || !param.getProperty().equals(property))\n\t\t{\n\t\t\treturn NONE;\n\t\t}\n\t\telse if (param.isAscending())\n\t\t{\n\t\t\treturn ASCENDING;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn DESCENDING;\n\t\t}\n\n\t}","id":47758,"modified_method":"/**\n\t * @see org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortState#getPropertySortOrder(java.lang.String)\n\t */\n\tpublic SortOrder getPropertySortOrder(String property)\n\t{\n\t\tArgs.notNull(property, \"property\");\n\n\t\tif (param == null || param.getProperty().equals(property) == false)\n\t\t{\n\t\t\treturn SortOrder.NONE;\n\t\t}\n\t\treturn param.getOrder();\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param property\n\t *            sort property\n\t * @param asc\n\t *            sort direction\n\t */\n\tpublic SortParam(String property, boolean asc)\n\t{\n\t\tthis.property = property;\n\t\tthis.asc = asc;\n\t}","id":47759,"modified_method":"/**\n\t * @param property\n\t *            sort property\n\t * @param order\n\t *            sort order\n\t */\n\tpublic SortParam(String property, SortOrder order)\n\t{\n\t\tthis.property = property;\n\t\tthis.order = order;\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see java.lang.Object#toString()\n\t */\n\tpublic String toString()\n\t{\n\t\treturn new StringBuilder().append(\"[SortParam property=\").append(getProperty()).append(\n\t\t\t\t\" ascending=\").append(asc).append(\"]\").toString();\n\t}","id":47760,"modified_method":"/**\n\t * @see java.lang.Object#toString()\n\t */\n\tpublic String toString()\n\t{\n\t\treturn new StringBuilder().append(\"[SortParam property=\").append(getProperty()).append(\n\t\t\t\t\" order=\").append(order.name()).append(\"]\").toString();\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\tpublic boolean equals(Object rhs)\n\t{\n\t\tif (rhs instanceof SortParam)\n\t\t{\n\t\t\tSortParam param = (SortParam)rhs;\n\t\t\treturn getProperty().equals(param.getProperty()) &&\n\t\t\t\t\tisAscending() == param.isAscending();\n\t\t}\n\t\treturn false;\n\t}","id":47761,"modified_method":"@Override\n\tpublic boolean equals(Object o)\n\t{\n\t\tif (this == o)\n\t\t\treturn true;\n\n\t\tif ((o instanceof SortParam) == false)\n\t\t\treturn false;\n\n\t\tSortParam sortParam = (SortParam)o;\n\n\t\treturn order == sortParam.order && property.equals(sortParam.property);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.repeater.data.IDataProvider#iterator(int, int)\n\t */\n\tpublic Iterator<Contact> iterator(int first, int count)\n\t{\n\t\tSortParam sp = getSort();\n\t\treturn getContactsDB().find(first, count, sp.getProperty(), sp.isAscending()).iterator();\n\t}","id":47762,"modified_method":"/**\n\t * @see org.apache.wicket.markup.repeater.data.IDataProvider#iterator(int, int)\n\t */\n\tpublic Iterator<Contact> iterator(int first, int count)\n\t{\n\t\treturn getContactsDB().find(first, count, getSort()).iterator();\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * constructor\n\t */\n\tpublic SortableContactDataProvider()\n\t{\n\t\t// set default sort\n\t\tsetSort(\"firstName\", true);\n\t}","id":47763,"modified_method":"/**\n\t * constructor\n\t */\n\tpublic SortableContactDataProvider()\n\t{\n\t\t// set default sort\n\t\tsetSort(\"firstName\", SortOrder.ASCENDING);\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * constructor\r\n\t */\r\n\tpublic SortableContactDataProvider()\r\n\t{\r\n\t\t// set default sort\r\n\t\tsetSort(\"firstName\", true);\r\n\t}","id":47764,"modified_method":"/**\r\n\t * constructor\r\n\t */\r\n\tpublic SortableContactDataProvider()\r\n\t{\r\n\t\t// set default sort\r\n\t\tsetSort(\"firstName\", SortOrder.ASCENDING);\r\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * @see org.apache.wicket.markup.repeater.data.IDataProvider#iterator(int, int)\r\n\t */\r\n\tpublic Iterator<Contact> iterator(int first, int count)\r\n\t{\r\n\t\tSortParam sp = getSort();\r\n\t\treturn getContactsDB().find(first, count, sp.getProperty(), sp.isAscending()).iterator();\r\n\t}","id":47765,"modified_method":"/**\r\n\t * @see org.apache.wicket.markup.repeater.data.IDataProvider#iterator(int, int)\r\n\t */\r\n\tpublic Iterator<Contact> iterator(int first, int count)\r\n\t{\r\n\t\treturn getContactsDB().find(first, count, getSort()).iterator();\r\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the current sort state\n\t * \n\t * @param property\n\t *            sort property\n\t * @param ascending\n\t *            sort direction\n\t */\n\tpublic void setSort(String property, boolean ascending)\n\t{\n\t\tsetSort(new SortParam(property, ascending));\n\t}","id":47766,"modified_method":"/**\n\t * Sets the current sort state\n\t * \n\t * @param property\n\t *            sort property\n\t * @param ascending\n\t *            sort direction\n\t */\n\tpublic void setSort(String property, SortOrder order)\n\t{\n\t\tsetSort(new SortParam(property, order));\n\t}","commit_id":"292bc17841ec0f674f4367bfdb68c5e7cd03b222","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Create a data excel worksheet for attendee's informaiton, which is in the gradebook import format\n\t */\n\tprivate Workbook createAttendanceDataWorksheet(List<SignupMeetingWrapper> wrappers) {\n\t\tString eventTitle = rb.getString(\"sheet_name_Attendance_data\", \"Attendance\");\n\t\tSheet sheet = wb.createSheet(eventTitle);\n\t\tPrintSetup printSetup = sheet.getPrintSetup();\n\t\tprintSetup.setLandscape(true);\n\t\tsheet.setFitToPage(true);\n\t\tsheet.setHorizontallyCenter(true);\n\t\t//Map to store all data\n\t\tMap<String, List<Integer>> m = new HashMap<String, List<Integer>>();\n\n\t\tif (wrappers == null)\n\t\t\treturn wb;\n\n\t\t/* Define column numbers and width here */\n\t\tint numberOfColumn = wrappers.size()+1;\n\t\tsheet.setColumnWidth(0, 25 * 256);// event title\n\n\t\tint rowNum = 0;\n\t\tCell cell = null;\n\t\tRow titleRow = sheet.createRow(rowNum++);\n\t\ttitleRow.setHeightInPoints(rowHigh);\n\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\ttitleRow.createCell(i).setCellStyle(styles.get(\"item_leftBold\"));\n\t\t}\n\n\t\tint cellNum = 0;\n\t\ttitleRow.getCell(cellNum++)\n\t\t.setCellValue(rb.getString(\"wksheet_attendance_UserID\", \"UserID\"));\n\t\tint index=-1;\n\n\t\tfor (SignupMeetingWrapper wrp : wrappers) {\n\n\t\t\tif (wrp.getMeeting().isAllowAttendance()){\n\n\t\t\t\tindex++;\n\t\t\t\ttitleRow.getCell(cellNum++)\n\t\t\t\t.setCellValue(wrp.getMeeting().getTitle());\n\n\t\t\t\tList<SignupTimeslot> tsItems = wrp.getMeeting().getSignupTimeSlots();\n\t\t\t\tif (tsItems != null) {\n\t\t\t\t\tfor (SignupTimeslot tsItem : tsItems) {\n\t\t\t\t\t\t/*strange thing happen for hibernate, tsItem can be null for mySql 4.x*/\n\t\t\t\t\t\tList<SignupAttendee> attendees = tsItem == null ? null : tsItem.getAttendees();\n\t\t\t\t\t\tif (attendees != null) {\n\t\t\t\t\t\t\tfor (SignupAttendee att : attendees) {\n\n\t\t\t\t\t\t\t\t//If attended then score is 1 else 0\n\t\t\t\t\t\t\t\tInteger attended = 0;\n\t\t\t\t\t\t\t\tif (att.isAttended()){\n\t\t\t\t\t\t\t\t\tattended = 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tUser attendee = sakaiFacade.getUser(att.getAttendeeUserId());\n\t\t\t\t\t\t\t\tString attendeeEID= attendee.getEid();\n\t\t\t\t\t\t\t\tif (m.containsKey(attendeeEID)){\n\t\t\t\t\t\t\t\t\t//Integer value=m.get(attendeeEID).get(index);\n\t\t\t\t\t\t\t\t\tList<Integer> attendanceList = m.get(attendeeEID);\n\t\t\t\t\t\t\t\t\tif (attendanceList.get(index)!=null){\n\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attendanceList.get(index)+attended);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attended);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tList<Integer> newList= Arrays.asList(new Integer[wrappers.size()]);\n\t\t\t\t\t\t\t\t\tnewList.set(index,attended);\n\t\t\t\t\t\t\t\t\tm.put(attendeeEID, newList);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Recording attendance for waitlisted user Signup-106\n\t\t\t\t\t\tList<SignupAttendee> waitingList = tsItem == null ? null : tsItem.getWaitingList();\n\t\t\t\t\t\tif (waitingList != null) {\n\t\t\t\t\t\t\t//For waitlisted user, if added it is scored, if not ignored\n\t\t\t\t\t\t\tInteger attended=1;\n\t\t\t\t\t\t\tfor (SignupAttendee wt : waitingList) {\n\n\t\t\t\t\t\t\t\tif (wt.isAttended()){\n\t\t\t\t\t\t\t\t\tUser attendee = sakaiFacade.getUser(wt.getAttendeeUserId());\n\t\t\t\t\t\t\t\t\tString attendeeEID= attendee.getEid();\n\t\t\t\t\t\t\t\t\tif (m.containsKey(attendeeEID)){\n\t\t\t\t\t\t\t\t\t\t//Integer value=m.get(attendeeEID).get(index);\n\t\t\t\t\t\t\t\t\t\tList<Integer> attendanceList = m.get(attendeeEID);\n\t\t\t\t\t\t\t\t\t\tif (attendanceList.get(index)!=null){\n\t\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attendanceList.get(index)+attended);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attended);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tList<Integer> newList= Arrays.asList(new Integer[wrappers.size()]);\n\t\t\t\t\t\t\t\t\t\tnewList.set(index,attended);\n\t\t\t\t\t\t\t\t\t\tm.put(attendeeEID, newList);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//populate the map into workbook\n\t\tIterator it = m.entrySet().iterator();\n\t\twhile (it.hasNext()) {\n\n\t\t\t//key value pair of Map\n\t\t\tMap.Entry pairs = (Map.Entry)it.next();\n\n\t\t\t//create new row\n\t\t\tRow row = sheet.createRow(rowNum++);\n\t\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\t\trow.createCell(i).setCellStyle(styles.get(\"item_left\"));\n\t\t\t}\n\t\t\tcellNum = 0;\n\t\t\trow.getCell(cellNum++).setCellValue((String)pairs.getKey());\n\t\t\tList<Integer> attendanceList= (List)pairs.getValue();\t\t\t\n\t\t\tfor (int i=0; i < attendanceList.size(); i++) {\n\t\t\t\tif (attendanceList.get(i)!=null){\n\t\t\t\t\trow.getCell(cellNum++).setCellValue(attendanceList.get(i));\n\t\t\t\t}\n\t\t\t\telse{ //empty value if null\n\t\t\t\t\trow.getCell(cellNum++).setCellValue(\"\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn wb;\n\t}","id":47767,"modified_method":"/**\n\t * Create a data excel worksheet for attendee's informaiton, which is in the gradebook import format\n\t */\n\tprivate Workbook createAttendanceDataWorksheet(List<SignupMeetingWrapper> wrappers) {\n\t\tString eventTitle = rb.getString(\"sheet_name_Attendance_data\", \"Attendance\");\n\t\tSheet sheet = wb.createSheet(eventTitle);\n\t\tPrintSetup printSetup = sheet.getPrintSetup();\n\t\tprintSetup.setLandscape(true);\n\t\tsheet.setFitToPage(true);\n\t\tsheet.setHorizontallyCenter(true);\n\t\t//Map to store all data\n\t\tMap<String, List<Integer>> m = new HashMap<String, List<Integer>>();\n\n\t\tif (wrappers == null)\n\t\t\treturn wb;\n\n\t\t/* Define column numbers and width here */\n\t\tint numberOfColumn = wrappers.size()+1;\n\t\tsheet.setColumnWidth(0, 25 * 256);// event title\n\n\t\tint rowNum = 0;\n\t\tCell cell = null;\n\t\tRow titleRow = sheet.createRow(rowNum++);\n\t\ttitleRow.setHeightInPoints(rowHigh);\n\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\ttitleRow.createCell(i).setCellStyle(styles.get(\"item_leftBold\"));\n\t\t}\n\n\t\tint cellNum = 0;\n\t\ttitleRow.getCell(cellNum++)\n\t\t.setCellValue(rb.getString(\"wksheet_attendance_UserID\", \"UserID\"));\n\t\tint index=-1;\n\n\t\tfor (SignupMeetingWrapper wrp : wrappers) {\n\n\t\t\tif (wrp.getMeeting().isAllowAttendance()){\n\n\t\t\t\tindex++;\n\t\t\t\ttitleRow.getCell(cellNum++)\n\t\t\t\t.setCellValue(wrp.getMeeting().getTitle());\n\n\t\t\t\tList<SignupTimeslot> tsItems = wrp.getMeeting().getSignupTimeSlots();\n\t\t\t\tif (tsItems != null) {\n\t\t\t\t\tfor (SignupTimeslot tsItem : tsItems) {\n\t\t\t\t\t\t/*strange thing happen for hibernate, tsItem can be null for mySql 4.x*/\n\t\t\t\t\t\tList<SignupAttendee> attendees = tsItem == null ? null : getValidAttendees(tsItem.getAttendees());\n\t\t\t\t\t\tif (attendees != null) {\n\t\t\t\t\t\t\tfor (SignupAttendee att : attendees) {\n\n\t\t\t\t\t\t\t\t//If attended then score is 1 else 0\n\t\t\t\t\t\t\t\tInteger attended = 0;\n\t\t\t\t\t\t\t\tif (att.isAttended()){\n\t\t\t\t\t\t\t\t\tattended = 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tUser attendee = sakaiFacade.getUser(att.getAttendeeUserId());\n\t\t\t\t\t\t\t\tString attendeeEID= attendee.getEid();\n\t\t\t\t\t\t\t\tif (m.containsKey(attendeeEID)){\n\t\t\t\t\t\t\t\t\t//Integer value=m.get(attendeeEID).get(index);\n\t\t\t\t\t\t\t\t\tList<Integer> attendanceList = m.get(attendeeEID);\n\t\t\t\t\t\t\t\t\tif (attendanceList.get(index)!=null){\n\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attendanceList.get(index)+attended);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attended);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tList<Integer> newList= Arrays.asList(new Integer[wrappers.size()]);\n\t\t\t\t\t\t\t\t\tnewList.set(index,attended);\n\t\t\t\t\t\t\t\t\tm.put(attendeeEID, newList);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//Recording attendance for waitlisted user Signup-106\n\t\t\t\t\t\tList<SignupAttendee> waitingList = tsItem == null ? null : tsItem.getWaitingList();\n\t\t\t\t\t\tif (waitingList != null) {\n\t\t\t\t\t\t\t//For waitlisted user, if added it is scored, if not ignored\n\t\t\t\t\t\t\tInteger attended=1;\n\t\t\t\t\t\t\tfor (SignupAttendee wt : waitingList) {\n\n\t\t\t\t\t\t\t\tif (wt.isAttended()){\n\t\t\t\t\t\t\t\t\tUser attendee = sakaiFacade.getUser(wt.getAttendeeUserId());\n\t\t\t\t\t\t\t\t\tString attendeeEID= attendee.getEid();\n\t\t\t\t\t\t\t\t\tif (m.containsKey(attendeeEID)){\n\t\t\t\t\t\t\t\t\t\t//Integer value=m.get(attendeeEID).get(index);\n\t\t\t\t\t\t\t\t\t\tList<Integer> attendanceList = m.get(attendeeEID);\n\t\t\t\t\t\t\t\t\t\tif (attendanceList.get(index)!=null){\n\t\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attendanceList.get(index)+attended);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t\tattendanceList.set(index, attended);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tList<Integer> newList= Arrays.asList(new Integer[wrappers.size()]);\n\t\t\t\t\t\t\t\t\t\tnewList.set(index,attended);\n\t\t\t\t\t\t\t\t\t\tm.put(attendeeEID, newList);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//populate the map into workbook\n\t\tIterator it = m.entrySet().iterator();\n\t\twhile (it.hasNext()) {\n\n\t\t\t//key value pair of Map\n\t\t\tMap.Entry pairs = (Map.Entry)it.next();\n\n\t\t\t//create new row\n\t\t\tRow row = sheet.createRow(rowNum++);\n\t\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\t\trow.createCell(i).setCellStyle(styles.get(\"item_left\"));\n\t\t\t}\n\t\t\tcellNum = 0;\n\t\t\trow.getCell(cellNum++).setCellValue((String)pairs.getKey());\n\t\t\tList<Integer> attendanceList= (List)pairs.getValue();\t\t\t\n\t\t\tfor (int i=0; i < attendanceList.size(); i++) {\n\t\t\t\tif (attendanceList.get(i)!=null){\n\t\t\t\t\trow.getCell(cellNum++).setCellValue(attendanceList.get(i));\n\t\t\t\t}\n\t\t\t\telse{ //empty value if null\n\t\t\t\t\trow.getCell(cellNum++).setCellValue(\"\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn wb;\n\t}","commit_id":"9bf2585ff02cba80ad5d516749e0da1d103faeef","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Create a full version excel worksheet\n\t */\n\tprivate void createWorksheet(SignupMeetingWrapper wrapper, int serialNum, boolean hasSerialNum) {\n\t\tString validSheetName = CreateValidWorksheetName(wrapper.getMeeting().getTitle(),serialNum,hasSerialNum);\n\t\t\t\n\t\tSheet sheet = wb.createSheet(validSheetName);\n\t\tPrintSetup printSetup = sheet.getPrintSetup();\n\t\tprintSetup.setLandscape(true);\n\t\tsheet.setFitToPage(true);\n\t\tsheet.setHorizontallyCenter(true);\n\n\t\tsheet.setColumnWidth(0, 3 * 256);\n\t\tsheet.setColumnWidth(1, 3 * 256);\n\t\tsheet.setColumnWidth(2, 17 * 256);\n\t\tsheet.setColumnWidth(3, 15 * 256);\n\t\tsheet.setColumnWidth(4, 22 * 256);\n\t\tsheet.setColumnWidth(5, 22 * 256);\n\t\tsheet.setColumnWidth(6, 22 * 256);\n\n\t\t// title row\n\t\tRow titleRow = sheet.createRow(0);\n\t\ttitleRow.setHeightInPoints(35);\n\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\ttitleRow.createCell(i).setCellStyle(styles.get(\"title\"));\n\t\t}\n\t\tCell titleCell = titleRow.getCell(2);\n\t\ttitleCell.setCellValue(wrapper.getMeeting().getTitle());\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$C$1:$H$1\"));\n\n\t\t// owner row\n\t\tRow row = sheet.createRow(2);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tCell cell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_owner\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(wrapper.getCreator());\n\n\t\t// meeting Date row\n\t\trow = sheet.createRow(3);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_date\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getTime(wrapper.getStartTime()).toStringLocalDate());\n\n\t\t// Time Period row\n\t\trow = sheet.createRow(4);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_time_period\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getMeetingPeriod(wrapper.getMeeting()));\n\n\t\t// Sign-up Begins row\n\t\trow = sheet.createRow(5);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_signup_start\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getTime(wrapper.getMeeting().getSignupBegins()).toStringLocalDate()\n\t\t\t\t+ \", \" + getTime(wrapper.getMeeting().getSignupBegins()).toStringLocalTime());\n\n\t\t// Sign-up Ends row\n\t\trow = sheet.createRow(6);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_signup_deadline\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getTime(wrapper.getMeeting().getSignupDeadline()).toStringLocalDate()\n\t\t\t\t+ \", \" + getTime(wrapper.getMeeting().getSignupDeadline()).toStringLocalTime());\n\n\t\t// Available To row\n\t\trow = sheet.createRow(7);\n\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\trow.createCell(i);\n\t\t}\n\t\tcell = row.getCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_publish_to\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.getCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left_wrap\"));\n\t\tString availSitesGroups = getAvailableSitesGroups(wrapper.getMeeting());\n\t\tcell.setCellValue(availSitesGroups);\n\t\tint rownum = getNumRows(availSitesGroups);\n\t\trow.setHeightInPoints(rowHigh * rownum);\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$D$8:$F$8\"));\n\n\t\t// Description row\n\t\trow = sheet.createRow(8);\n\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\trow.createCell(i);// setCellStyle(styles.get(\"description\"));\n\t\t}\n\t\t// cell = row.createCell(2);\n\t\tcell = row.getCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_description\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.getCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left_wrap_top\"));\n\t\tString description = wrapper.getMeeting().getDescription();\n\t\tif (description != null && description.length() > 0) {\n\t\t\tdescription = ExcelPlainTextFormat\n\t\t\t\t\t.convertFormattedHtmlTextToExcelPlaintext(description);\n\t\t\trow.setHeightInPoints(rowHigh * getDescRowNum(description));\n\t\t}\n\t\tcell.setCellValue(description);\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$D$9:$H$9\"));\n\n\t\t/* add attachment links */\n\t\tint cur_rowNum = 9;\n\t\trow = sheet.createRow(cur_rowNum);\n\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\trow.createCell(i);\n\t\t}\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.getCell(2);\n\t\tcell.setCellValue(rb.getString(\"attachments\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tList<SignupAttachment> attachs = wrapper.getEventMainAttachments();\n\t\tif (attachs != null && !attachs.isEmpty()) {\n\t\t\tfor (int i = 0; i < attachs.size(); i++) {\n\t\t\t\tSignupAttachment attach = attachs.get(i);\n\t\t\t\tif (i > 0) {// start with second attachment\n\t\t\t\t\tcur_rowNum++;\n\t\t\t\t\trow = sheet.createRow(cur_rowNum);// create next\n\t\t\t\t\t// attachment row\n\t\t\t\t\trow.setHeightInPoints(rowHigh);\n\t\t\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\t\t\trow.createCell(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcell = row.getCell(3);\n\t\t\t\tcell.setCellStyle(styles.get(\"hyperLink\"));\n\t\t\t\tcell.setCellValue(attach.getFilename());\n\t\t\t\tcell.setHyperlink(setAttachmentURLLinks(attach));\n\t\t\t}\n\t\t} else {\n\t\t\tcell = row.getCell(3);\n\t\t\tcell.setCellStyle(styles.get(\"item_left_wrap\"));\n\t\t\tcell.setCellValue(rb.getString(\"event_no_attachment\"));\n\t\t}\n\n\t\t/* Case: for announcement event */\n\t\tif (ANNOUNCEMENT.equals(wrapper.getMeeting().getMeetingType())) {\n\t\t\trow = sheet.createRow(cur_rowNum + 3);\n\t\t\trow.setHeightInPoints(rowHigh);\n\t\t\tcell = row.createCell(3);\n\t\t\tcell.setCellValue(rb.getString(\"event_is_open_session\",\n\t\t\t\t\t\"This is an open session meeting. No sign-up is necessary.\"));\n\t\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\n\t\t\treturn;\n\t\t}\n\n\t\t/* Case: for group and individual events */\n\t\t// Table titles row\n\t\tcur_rowNum = cur_rowNum + 2;\n\t\trow = sheet.createRow(cur_rowNum);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tfor (int i = 2; i <= 7; i++) {\n\t\t\trow.createCell(i).setCellStyle(styles.get(\"tabColNames\"));\n\t\t}\n\t\tcell = row.getCell(2);\n\t\tcurrentTabTitles = isOrganizer(wrapper.getMeeting()) ? tabTitles_Organizor\n\t\t\t\t: tabTitles_Participant;\n\t\tcell.setCellValue(currentTabTitles[0]);\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$C$\" + (cur_rowNum + 1) + \":$D$\"\n\t\t\t\t+ (cur_rowNum + 1)));\n\t\tcell = row.getCell(4);\n\t\tcell.setCellValue(currentTabTitles[1]);\n\t\tcell = row.getCell(5);\n\t\tcell.setCellValue(currentTabTitles[2]);\n\t\tcell = row.getCell(6);\n\t\tcell.setCellValue(currentTabTitles[3]);\n\n\t\t// Table schedule Info\n\t\tint rowNum = cur_rowNum + 1;\n\t\tList<SignupTimeslot> tsItems = wrapper.getMeeting().getSignupTimeSlots();\n\t\tif (tsItems != null) {\n\t\t\tfor (SignupTimeslot tsItem : tsItems) {\n\t\t\t\t/*strange thing happen for hibernate, it can be null for mySql 4.x*/\n\t\t\t\tif (tsItem == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow = sheet.createRow(rowNum);\n\t\t\t\tint rowHighNum = 1;\n\t\t\t\trowNum++;\n\t\t\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\t\t\trow.createCell(i).setCellStyle(styles.get(\"tabItem_fields\"));\n\t\t\t\t}\n\t\t\t\t// timeslot period\n\t\t\t\tcell = row.getCell(2);\n\t\t\t\tcell.setCellValue(getTimeSlotPeriod(tsItem, wrapper.getMeeting()\n\t\t\t\t\t\t.isMeetingCrossDays()));\n\t\t\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$C$\" + rowNum + \":$D$\" + rowNum));// \"$C$11:$D$11\"\n\n\t\t\t\t// Max # of participants\n\t\t\t\tcell = row.getCell(4);\n\t\t\t\tif (tsItem.isUnlimitedAttendee())\n\t\t\t\t\tcell.setCellValue(rb.getString(\"event_unlimited\"));\n\t\t\t\telse if (isOrganizer(wrapper.getMeeting())) {\n\t\t\t\t\tcell.setCellValue(tsItem.getMaxNoOfAttendees());\n\t\t\t\t} else {\n\t\t\t\t\tint availableSpots = tsItem.getAttendees() != null ? tsItem\n\t\t\t\t\t\t\t.getMaxNoOfAttendees()\n\t\t\t\t\t\t\t- tsItem.getAttendees().size() : tsItem.getMaxNoOfAttendees();\n\t\t\t\t\tavailableSpots = availableSpots < 1 ? 0 : availableSpots;\n\t\t\t\t\tString value = String.valueOf(availableSpots);\n\t\t\t\t\tif (tsItem.isLocked())\n\t\t\t\t\t\tvalue = rb.getString(\"event_is_locked\");\n\t\t\t\t\telse if (tsItem.isCanceled())\n\t\t\t\t\t\tvalue = rb.getString(\"event_is_canceled\");\n\n\t\t\t\t\tcell.setCellValue(value);\n\t\t\t\t}\n\n\t\t\t\t// attendee\n\t\t\t\tcell = row.getCell(5);\n\t\t\t\tList<SignupAttendee> attendees = tsItem.getAttendees();\n\t\t\t\tString aNames = rb.getString(\"event_show_no_attendee_info\");\n\t\t\t\tif (isDisplayNames(wrapper.getMeeting())) {\n\t\t\t\t\tif (attendees != null && attendees.size() > rowHighNum) {\n\t\t\t\t\t\trowHighNum = attendees.size();\n\t\t\t\t\t}\n\t\t\t\t\taNames = getNames(attendees);\n\t\t\t\t}\n\t\t\t\tif (tsItem.isCanceled() && isOrganizer(wrapper.getMeeting())) {\n\t\t\t\t\taNames = rb.getString(\"event_is_canceled\");\n\t\t\t\t}\n\t\t\t\tcell.setCellValue(aNames);\n\t\t\t\tcell.setCellStyle(styles.get(\"attendee_layout\"));\n\n\t\t\t\t// waiters\n\t\t\t\tcell = row.getCell(6);\n\t\t\t\tString fieldValue = \"\";\n\t\t\t\tif (isOrganizer(wrapper.getMeeting())) {\n\t\t\t\t\tList<SignupAttendee> waiters = tsItem.getWaitingList();\n\t\t\t\t\tif (waiters != null && waiters.size() > rowHighNum) {\n\t\t\t\t\t\trowHighNum = waiters.size();\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue = getNames(waiters);\n\t\t\t\t} else {\n\t\t\t\t\tfieldValue = getYourStatus(tsItem);\n\t\t\t\t}\n\t\t\t\tcell.setCellValue(fieldValue);\n\t\t\t\tcell.setCellStyle(styles.get(\"attendee_layout\"));\n\n\t\t\t\t// set row high\n\t\t\t\trow.setHeightInPoints(rowHigh * rowHighNum);\n\t\t\t}\n\t\t}\n\n\t\t// end of table line\n\t\trow = sheet.createRow(rowNum);\n\t\tfor (int i = 2; i <= 7; i++) {\n\t\t\trow.createCell(i).setCellStyle(styles.get(\"tab_endline\"));\n\t\t}\n\n\t\t/* process attendee's comments */\n\t\trowNum = rowNum + 2;\n\t\t// Comment Title row\n\t\tRow commentsRow = sheet.createRow(rowNum);\n\t\tcommentsRow.setHeightInPoints(25);\n\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\tcommentsRow.createCell(i).setCellStyle(styles.get(\"commentTitle\"));\n\t\t}\n\t\tCell commentsCell = commentsRow.getCell(2);\n\t\tcommentsCell.setCellValue(rb.getString(\"event_comments_title\", \"Participant's Comments\"));\n\t\tsheet.addMergedRegion(CellRangeAddress\n\t\t\t\t.valueOf(\"$C$\" + (rowNum + 1) + \":$H$\" + (rowNum + 1)));\n\t\t// separate line\n\t\trowNum++;\n\t\trow = sheet.createRow(rowNum);\n\t\tfor (int i = 2; i <= 4; i++) {\n\t\t\trow.createCell(i).setCellStyle(styles.get(\"tab_endline\"));\n\t\t}\n\n\t\trowNum++;\n\t\t;\n\t\tboolean hasComment = false;\n\t\tif (tsItems != null) {\n\t\t\tfor (SignupTimeslot ts : tsItems) {\n\t\t\t\t/*strange thing happen for hibernate, it can be null for mySql 4.x*/\n\t\t\t\tList<SignupAttendee> attendees = ts != null ? ts.getAttendees() : null;\n\t\t\t\tif (attendees != null) {\n\t\t\t\t\tfor (SignupAttendee att : attendees) {\n\t\t\t\t\t\tif (isOrganizer(wrapper.getMeeting()) || isViewerSelf(att)) {\n\t\t\t\t\t\t\tString comment = att.getComments();\n\t\t\t\t\t\t\tif (comment != null && comment.trim().length() > 0) {\n\t\t\t\t\t\t\t\trow = sheet.createRow(rowNum++);\n\t\t\t\t\t\t\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\t\t\t\t\t\t\trow.createCell(i);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcell = row.getCell(2);\n\t\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getUserDisplayName(att\n\t\t\t\t\t\t\t\t\t\t.getAttendeeUserId())\n\t\t\t\t\t\t\t\t\t\t+ \":\");\n\t\t\t\t\t\t\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\t\t\t\t\t\t\tcell = row.getCell(3);\n\t\t\t\t\t\t\t\tcell.setCellStyle(styles.get(\"item_left_wrap_top\"));\n\t\t\t\t\t\t\t\tcomment = ExcelPlainTextFormat\n\t\t\t\t\t\t\t\t\t\t.convertFormattedHtmlTextToExcelPlaintext(comment);\n\t\t\t\t\t\t\t\trow.setHeightInPoints(rowHigh * getDescRowNum(comment));\n\n\t\t\t\t\t\t\t\tcell.setCellValue(comment);\n\t\t\t\t\t\t\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$D$\" + rowNum\n\t\t\t\t\t\t\t\t\t\t+ \":$H$\" + rowNum));\n\t\t\t\t\t\t\t\trowNum++;// one row space between comment\n\t\t\t\t\t\t\t\thasComment = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (!hasComment) {\n\t\t\trow = sheet.createRow(rowNum);\n\t\t\trow.createCell(2);\n\t\t\tcell = row.getCell(2);\n\t\t\tcell.setCellValue(rb.getString(\"event_no_comments\",\n\t\t\t\t\t\"There is no comments written by participants.\"));\n\t\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\t}\n\n\t}","id":47768,"modified_method":"/**\n\t * Create a full version excel worksheet\n\t */\n\tprivate void createWorksheet(SignupMeetingWrapper wrapper, int serialNum, boolean hasSerialNum) {\n\t\tString validSheetName = CreateValidWorksheetName(wrapper.getMeeting().getTitle(),serialNum,hasSerialNum);\n\t\t\t\n\t\tSheet sheet = wb.createSheet(validSheetName);\n\t\tPrintSetup printSetup = sheet.getPrintSetup();\n\t\tprintSetup.setLandscape(true);\n\t\tsheet.setFitToPage(true);\n\t\tsheet.setHorizontallyCenter(true);\n\n\t\tsheet.setColumnWidth(0, 3 * 256);\n\t\tsheet.setColumnWidth(1, 3 * 256);\n\t\tsheet.setColumnWidth(2, 17 * 256);\n\t\tsheet.setColumnWidth(3, 15 * 256);\n\t\tsheet.setColumnWidth(4, 22 * 256);\n\t\tsheet.setColumnWidth(5, 22 * 256);\n\t\tsheet.setColumnWidth(6, 22 * 256);\n\n\t\t// title row\n\t\tRow titleRow = sheet.createRow(0);\n\t\ttitleRow.setHeightInPoints(35);\n\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\ttitleRow.createCell(i).setCellStyle(styles.get(\"title\"));\n\t\t}\n\t\tCell titleCell = titleRow.getCell(2);\n\t\ttitleCell.setCellValue(wrapper.getMeeting().getTitle());\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$C$1:$H$1\"));\n\n\t\t// owner row\n\t\tRow row = sheet.createRow(2);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tCell cell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_owner\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(wrapper.getCreator());\n\n\t\t// meeting Date row\n\t\trow = sheet.createRow(3);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_date\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getTime(wrapper.getStartTime()).toStringLocalDate());\n\n\t\t// Time Period row\n\t\trow = sheet.createRow(4);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_time_period\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getMeetingPeriod(wrapper.getMeeting()));\n\n\t\t// Sign-up Begins row\n\t\trow = sheet.createRow(5);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_signup_start\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getTime(wrapper.getMeeting().getSignupBegins()).toStringLocalDate()\n\t\t\t\t+ \", \" + getTime(wrapper.getMeeting().getSignupBegins()).toStringLocalTime());\n\n\t\t// Sign-up Ends row\n\t\trow = sheet.createRow(6);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.createCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_signup_deadline\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.createCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left\"));\n\t\tcell.setCellValue(getTime(wrapper.getMeeting().getSignupDeadline()).toStringLocalDate()\n\t\t\t\t+ \", \" + getTime(wrapper.getMeeting().getSignupDeadline()).toStringLocalTime());\n\n\t\t// Available To row\n\t\trow = sheet.createRow(7);\n\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\trow.createCell(i);\n\t\t}\n\t\tcell = row.getCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_publish_to\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.getCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left_wrap\"));\n\t\tString availSitesGroups = getAvailableSitesGroups(wrapper.getMeeting());\n\t\tcell.setCellValue(availSitesGroups);\n\t\tint rownum = getNumRows(availSitesGroups);\n\t\trow.setHeightInPoints(rowHigh * rownum);\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$D$8:$F$8\"));\n\n\t\t// Description row\n\t\trow = sheet.createRow(8);\n\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\trow.createCell(i);// setCellStyle(styles.get(\"description\"));\n\t\t}\n\t\t// cell = row.createCell(2);\n\t\tcell = row.getCell(2);\n\t\tcell.setCellValue(rb.getString(\"event_description\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tcell = row.getCell(3);\n\t\tcell.setCellStyle(styles.get(\"item_left_wrap_top\"));\n\t\tString description = wrapper.getMeeting().getDescription();\n\t\tif (description != null && description.length() > 0) {\n\t\t\tdescription = ExcelPlainTextFormat\n\t\t\t\t\t.convertFormattedHtmlTextToExcelPlaintext(description);\n\t\t\trow.setHeightInPoints(rowHigh * getDescRowNum(description));\n\t\t}\n\t\tcell.setCellValue(description);\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$D$9:$H$9\"));\n\n\t\t/* add attachment links */\n\t\tint cur_rowNum = 9;\n\t\trow = sheet.createRow(cur_rowNum);\n\t\tfor (int i = 1; i <= 5; i++) {\n\t\t\trow.createCell(i);\n\t\t}\n\t\trow.setHeightInPoints(rowHigh);\n\t\tcell = row.getCell(2);\n\t\tcell.setCellValue(rb.getString(\"attachments\"));\n\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\tList<SignupAttachment> attachs = wrapper.getEventMainAttachments();\n\t\tif (attachs != null && !attachs.isEmpty()) {\n\t\t\tfor (int i = 0; i < attachs.size(); i++) {\n\t\t\t\tSignupAttachment attach = attachs.get(i);\n\t\t\t\tif (i > 0) {// start with second attachment\n\t\t\t\t\tcur_rowNum++;\n\t\t\t\t\trow = sheet.createRow(cur_rowNum);// create next\n\t\t\t\t\t// attachment row\n\t\t\t\t\trow.setHeightInPoints(rowHigh);\n\t\t\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\t\t\trow.createCell(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcell = row.getCell(3);\n\t\t\t\tcell.setCellStyle(styles.get(\"hyperLink\"));\n\t\t\t\tcell.setCellValue(attach.getFilename());\n\t\t\t\tcell.setHyperlink(setAttachmentURLLinks(attach));\n\t\t\t}\n\t\t} else {\n\t\t\tcell = row.getCell(3);\n\t\t\tcell.setCellStyle(styles.get(\"item_left_wrap\"));\n\t\t\tcell.setCellValue(rb.getString(\"event_no_attachment\"));\n\t\t}\n\n\t\t/* Case: for announcement event */\n\t\tif (ANNOUNCEMENT.equals(wrapper.getMeeting().getMeetingType())) {\n\t\t\trow = sheet.createRow(cur_rowNum + 3);\n\t\t\trow.setHeightInPoints(rowHigh);\n\t\t\tcell = row.createCell(3);\n\t\t\tcell.setCellValue(rb.getString(\"event_is_open_session\",\n\t\t\t\t\t\"This is an open session meeting. No sign-up is necessary.\"));\n\t\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\n\t\t\treturn;\n\t\t}\n\n\t\t/* Case: for group and individual events */\n\t\t// Table titles row\n\t\tcur_rowNum = cur_rowNum + 2;\n\t\trow = sheet.createRow(cur_rowNum);\n\t\trow.setHeightInPoints(rowHigh);\n\t\tfor (int i = 2; i <= 7; i++) {\n\t\t\trow.createCell(i).setCellStyle(styles.get(\"tabColNames\"));\n\t\t}\n\t\tcell = row.getCell(2);\n\t\tcurrentTabTitles = isOrganizer(wrapper.getMeeting()) ? tabTitles_Organizor\n\t\t\t\t: tabTitles_Participant;\n\t\tcell.setCellValue(currentTabTitles[0]);\n\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$C$\" + (cur_rowNum + 1) + \":$D$\"\n\t\t\t\t+ (cur_rowNum + 1)));\n\t\tcell = row.getCell(4);\n\t\tcell.setCellValue(currentTabTitles[1]);\n\t\tcell = row.getCell(5);\n\t\tcell.setCellValue(currentTabTitles[2]);\n\t\tcell = row.getCell(6);\n\t\tcell.setCellValue(currentTabTitles[3]);\n\n\t\t// Table schedule Info\n\t\tint rowNum = cur_rowNum + 1;\n\t\tList<SignupTimeslot> tsItems = wrapper.getMeeting().getSignupTimeSlots();\n\t\tif (tsItems != null) {\n\t\t\tfor (SignupTimeslot tsItem : tsItems) {\n\t\t\t\t/*strange thing happen for hibernate, it can be null for mySql 4.x*/\n\t\t\t\tif (tsItem == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trow = sheet.createRow(rowNum);\n\t\t\t\tint rowHighNum = 1;\n\t\t\t\trowNum++;\n\t\t\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\t\t\trow.createCell(i).setCellStyle(styles.get(\"tabItem_fields\"));\n\t\t\t\t}\n\t\t\t\t// timeslot period\n\t\t\t\tcell = row.getCell(2);\n\t\t\t\tcell.setCellValue(getTimeSlotPeriod(tsItem, wrapper.getMeeting()\n\t\t\t\t\t\t.isMeetingCrossDays()));\n\t\t\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$C$\" + rowNum + \":$D$\" + rowNum));// \"$C$11:$D$11\"\n\n\t\t\t\t// Max # of participants\n\t\t\t\tcell = row.getCell(4);\n\t\t\t\tif (tsItem.isUnlimitedAttendee())\n\t\t\t\t\tcell.setCellValue(rb.getString(\"event_unlimited\"));\n\t\t\t\telse if (isOrganizer(wrapper.getMeeting())) {\n\t\t\t\t\tcell.setCellValue(tsItem.getMaxNoOfAttendees());\n\t\t\t\t} else {\n\t\t\t\t\tint availableSpots = getValidAttendees(tsItem.getAttendees()) != null ? tsItem\n\t\t\t\t\t\t\t.getMaxNoOfAttendees()\n\t\t\t\t\t\t\t- getValidAttendees(tsItem.getAttendees()).size() : tsItem.getMaxNoOfAttendees();\n\t\t\t\t\tavailableSpots = availableSpots < 1 ? 0 : availableSpots;\n\t\t\t\t\tString value = String.valueOf(availableSpots);\n\t\t\t\t\tif (tsItem.isLocked())\n\t\t\t\t\t\tvalue = rb.getString(\"event_is_locked\");\n\t\t\t\t\telse if (tsItem.isCanceled())\n\t\t\t\t\t\tvalue = rb.getString(\"event_is_canceled\");\n\n\t\t\t\t\tcell.setCellValue(value);\n\t\t\t\t}\n\n\t\t\t\t// attendee\n\t\t\t\tcell = row.getCell(5);\n\t\t\t\tList<SignupAttendee> attendees = getValidAttendees(tsItem.getAttendees());\n\t\t\t\tString aNames = rb.getString(\"event_show_no_attendee_info\");\n\t\t\t\tif (isDisplayNames(wrapper.getMeeting())) {\n\t\t\t\t\tif (attendees != null && attendees.size() > rowHighNum) {\n\t\t\t\t\t\trowHighNum = attendees.size();\n\t\t\t\t\t}\n\t\t\t\t\taNames = getNames(attendees);\n\t\t\t\t}\n\t\t\t\tif (tsItem.isCanceled() && isOrganizer(wrapper.getMeeting())) {\n\t\t\t\t\taNames = rb.getString(\"event_is_canceled\");\n\t\t\t\t}\n\t\t\t\tcell.setCellValue(aNames);\n\t\t\t\tcell.setCellStyle(styles.get(\"attendee_layout\"));\n\n\t\t\t\t// waiters\n\t\t\t\tcell = row.getCell(6);\n\t\t\t\tString fieldValue = \"\";\n\t\t\t\tif (isOrganizer(wrapper.getMeeting())) {\n\t\t\t\t\tList<SignupAttendee> waiters = tsItem.getWaitingList();\n\t\t\t\t\tif (waiters != null && waiters.size() > rowHighNum) {\n\t\t\t\t\t\trowHighNum = waiters.size();\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue = getNames(waiters);\n\t\t\t\t} else {\n\t\t\t\t\tfieldValue = getYourStatus(tsItem);\n\t\t\t\t}\n\t\t\t\tcell.setCellValue(fieldValue);\n\t\t\t\tcell.setCellStyle(styles.get(\"attendee_layout\"));\n\n\t\t\t\t// set row high\n\t\t\t\trow.setHeightInPoints(rowHigh * rowHighNum);\n\t\t\t}\n\t\t}\n\n\t\t// end of table line\n\t\trow = sheet.createRow(rowNum);\n\t\tfor (int i = 2; i <= 7; i++) {\n\t\t\trow.createCell(i).setCellStyle(styles.get(\"tab_endline\"));\n\t\t}\n\n\t\t/* process attendee's comments */\n\t\trowNum = rowNum + 2;\n\t\t// Comment Title row\n\t\tRow commentsRow = sheet.createRow(rowNum);\n\t\tcommentsRow.setHeightInPoints(25);\n\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\tcommentsRow.createCell(i).setCellStyle(styles.get(\"commentTitle\"));\n\t\t}\n\t\tCell commentsCell = commentsRow.getCell(2);\n\t\tcommentsCell.setCellValue(rb.getString(\"event_comments_title\", \"Participant's Comments\"));\n\t\tsheet.addMergedRegion(CellRangeAddress\n\t\t\t\t.valueOf(\"$C$\" + (rowNum + 1) + \":$H$\" + (rowNum + 1)));\n\t\t// separate line\n\t\trowNum++;\n\t\trow = sheet.createRow(rowNum);\n\t\tfor (int i = 2; i <= 4; i++) {\n\t\t\trow.createCell(i).setCellStyle(styles.get(\"tab_endline\"));\n\t\t}\n\n\t\trowNum++;\n\t\t;\n\t\tboolean hasComment = false;\n\t\tif (tsItems != null) {\n\t\t\tfor (SignupTimeslot ts : tsItems) {\n\t\t\t\t/*strange thing happen for hibernate, it can be null for mySql 4.x*/\n\t\t\t\tList<SignupAttendee> attendees = ts != null ? getValidAttendees(ts.getAttendees()) : null;\n\t\t\t\tif (attendees != null) {\n\t\t\t\t\tfor (SignupAttendee att : attendees) {\n\t\t\t\t\t\tif (isOrganizer(wrapper.getMeeting()) || isViewerSelf(att)) {\n\t\t\t\t\t\t\tString comment = att.getComments();\n\t\t\t\t\t\t\tif (comment != null && comment.trim().length() > 0) {\n\t\t\t\t\t\t\t\trow = sheet.createRow(rowNum++);\n\t\t\t\t\t\t\t\tfor (int i = 1; i <= 7; i++) {\n\t\t\t\t\t\t\t\t\trow.createCell(i);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcell = row.getCell(2);\n\t\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getUserDisplayName(att\n\t\t\t\t\t\t\t\t\t\t.getAttendeeUserId())\n\t\t\t\t\t\t\t\t\t\t+ \":\");\n\t\t\t\t\t\t\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\t\t\t\t\t\t\tcell = row.getCell(3);\n\t\t\t\t\t\t\t\tcell.setCellStyle(styles.get(\"item_left_wrap_top\"));\n\t\t\t\t\t\t\t\tcomment = ExcelPlainTextFormat\n\t\t\t\t\t\t\t\t\t\t.convertFormattedHtmlTextToExcelPlaintext(comment);\n\t\t\t\t\t\t\t\trow.setHeightInPoints(rowHigh * getDescRowNum(comment));\n\n\t\t\t\t\t\t\t\tcell.setCellValue(comment);\n\t\t\t\t\t\t\t\tsheet.addMergedRegion(CellRangeAddress.valueOf(\"$D$\" + rowNum\n\t\t\t\t\t\t\t\t\t\t+ \":$H$\" + rowNum));\n\t\t\t\t\t\t\t\trowNum++;// one row space between comment\n\t\t\t\t\t\t\t\thasComment = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (!hasComment) {\n\t\t\trow = sheet.createRow(rowNum);\n\t\t\trow.createCell(2);\n\t\t\tcell = row.getCell(2);\n\t\t\tcell.setCellValue(rb.getString(\"event_no_comments\",\n\t\t\t\t\t\"There is no comments written by participants.\"));\n\t\t\tcell.setCellStyle(styles.get(\"item_leftBold\"));\n\t\t}\n\n\t}","commit_id":"9bf2585ff02cba80ad5d516749e0da1d103faeef","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Create a data excel worksheet for attendee's informaiton\n\t */\n\tprivate Workbook createAttendeeDataWorksheet(List<SignupMeetingWrapper> wrappers) {\n\t\tString eventTitle = rb.getString(\"sheet_name_Attendee_schedules\", \"Attendees' Schedules\");\n\t\tSheet sheet = wb.createSheet(eventTitle);\n\t\tPrintSetup printSetup = sheet.getPrintSetup();\n\t\tprintSetup.setLandscape(true);\n\t\tsheet.setFitToPage(true);\n\t\tsheet.setHorizontallyCenter(true);\n\n\t\t/* Define column numbers and width here */\n\t\tint numberOfColumn = 13;\n\t\tsheet.setColumnWidth(0, 25 * 256);// event title\n\t\tsheet.setColumnWidth(1, 20 * 256);// attendee display name\n\t\tsheet.setColumnWidth(2, 20 * 256);// attendee user id\n\t\tsheet.setColumnWidth(3, 25 * 256);// attendee user email\n\t\tsheet.setColumnWidth(4, 25 * 256);// site name\n\t\tsheet.setColumnWidth(5, 20 * 256);// appointment start time\n\t\tsheet.setColumnWidth(6, 16 * 256);// duration\n\t\tsheet.setColumnWidth(7, 22 * 256);// #num of attendees\n\t\tsheet.setColumnWidth(8, 25 * 256);// #user comment\n\t\tsheet.setColumnWidth(9, 20 * 256);// event owner\n\t\tsheet.setColumnWidth(10, 20 * 256);// event location\n\t\tsheet.setColumnWidth(11, 20 * 256);// event category\n\t\tsheet.setColumnWidth(12, 20 * 256);// event start time\n\t\tsheet.setColumnWidth(13, 20 * 256);// duration\n\n\t\tif (wrappers == null)\n\t\t\treturn wb;\n\n\t\tint rowNum = 0;\n\t\tCell cell = null;\n\t\tRow titleRow = sheet.createRow(rowNum++);\n\t\ttitleRow.setHeightInPoints(rowHigh);\n\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\ttitleRow.createCell(i).setCellStyle(styles.get(\"item_leftBold\"));\n\t\t}\n\n\t\tint cellNum = 0;\n\t\ttitleRow.getCell(cellNum++)\n\t\t\t\t.setCellValue(rb.getString(\"wksheet_meeting_name\", \"Event Name\"));\n\t\ttitleRow.getCell(cellNum++)\n\t\t\t\t.setCellValue(rb.getString(\"wksheet_user_name\", \"Attendee Name\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_user_id\", \"Attendee User Id\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_user_email\", \"Email\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_site_name\", \"Site Title\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_appointment_start_time\", \"Appointment Time\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_appointment_duration\", \"Duration (min)\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_num_of_attendees\", \"#Num Attendees in Slot\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_user_comment\", \"User Comment\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_organizer\", \"Organizer\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_location\", \"Location\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_category\", \"Category\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_meeting_start_time\", \"Event Start Time\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_meeting_duration\", \"Event Duration (min)\"));\n\n\t\tfor (SignupMeetingWrapper wrp : wrappers) {\n\t\t\tList<SignupTimeslot> tsItems = wrp.getMeeting().getSignupTimeSlots();\n\t\t\tif (tsItems != null) {\n\t\t\t\tfor (SignupTimeslot tsItem : tsItems) {\n\t\t\t\t\t/*strange thing happen for hibernate, tsItem can be null for mySql 4.x*/\n\t\t\t\t\tList<SignupAttendee> attendees = tsItem == null ? null : tsItem.getAttendees();\n\t\t\t\t\tif (attendees != null) {\n\t\t\t\t\t\tfor (SignupAttendee att : attendees) {\n\t\t\t\t\t\t\tRow row = sheet.createRow(rowNum++);\n\t\t\t\t\t\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\t\t\t\t\t\trow.createCell(i).setCellStyle(styles.get(\"item_left\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUser attendee = sakaiFacade.getUser(att.getAttendeeUserId());\n\t\t\t\t\t\t\t/* reset */\n\t\t\t\t\t\t\tcellNum = 0;\n\n\t\t\t\t\t\t\t/* meeting title */\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(wrp.getMeeting().getTitle());\n\n\t\t\t\t\t\t\t/* attendee name */\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(attendee ==null? \"--\" :attendee.getDisplayName());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(attendee ==null? \"--\" : attendee.getEid());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(attendee ==null? \"--\" : attendee.getEmail());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getSiteTitle(att.getSignupSiteId()));\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getTimeService().newTime(\n\t\t\t\t\t\t\t\t\ttsItem.getStartTime().getTime()).toStringLocalFull());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getDurationLength(tsItem.getEndTime(), tsItem\n\t\t\t\t\t\t\t\t\t.getStartTime()));// minutes\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(tsItem.getAttendees().size());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(att.getComments());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getUserDisplayName(wrp.getMeeting()\n\t\t\t\t\t\t\t\t\t.getCreatorUserId()));\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(wrp.getMeeting().getLocation());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(wrp.getMeeting().getCategory());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getTimeService().newTime(\n\t\t\t\t\t\t\t\t\twrp.getMeeting().getStartTime().getTime()).toStringLocalFull());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getDurationLength(wrp.getMeeting().getEndTime(), wrp\n\t\t\t\t\t\t\t\t\t.getMeeting().getStartTime()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn wb;\n\t}","id":47769,"modified_method":"/**\n\t * Create a data excel worksheet for attendee's informaiton\n\t */\n\tprivate Workbook createAttendeeDataWorksheet(List<SignupMeetingWrapper> wrappers) {\n\t\tString eventTitle = rb.getString(\"sheet_name_Attendee_schedules\", \"Attendees' Schedules\");\n\t\tSheet sheet = wb.createSheet(eventTitle);\n\t\tPrintSetup printSetup = sheet.getPrintSetup();\n\t\tprintSetup.setLandscape(true);\n\t\tsheet.setFitToPage(true);\n\t\tsheet.setHorizontallyCenter(true);\n\n\t\t/* Define column numbers and width here */\n\t\tint numberOfColumn = 13;\n\t\tsheet.setColumnWidth(0, 25 * 256);// event title\n\t\tsheet.setColumnWidth(1, 20 * 256);// attendee display name\n\t\tsheet.setColumnWidth(2, 20 * 256);// attendee user id\n\t\tsheet.setColumnWidth(3, 25 * 256);// attendee user email\n\t\tsheet.setColumnWidth(4, 25 * 256);// site name\n\t\tsheet.setColumnWidth(5, 20 * 256);// appointment start time\n\t\tsheet.setColumnWidth(6, 16 * 256);// duration\n\t\tsheet.setColumnWidth(7, 22 * 256);// #num of attendees\n\t\tsheet.setColumnWidth(8, 25 * 256);// #user comment\n\t\tsheet.setColumnWidth(9, 20 * 256);// event owner\n\t\tsheet.setColumnWidth(10, 20 * 256);// event location\n\t\tsheet.setColumnWidth(11, 20 * 256);// event category\n\t\tsheet.setColumnWidth(12, 20 * 256);// event start time\n\t\tsheet.setColumnWidth(13, 20 * 256);// duration\n\n\t\tif (wrappers == null)\n\t\t\treturn wb;\n\n\t\tint rowNum = 0;\n\t\tCell cell = null;\n\t\tRow titleRow = sheet.createRow(rowNum++);\n\t\ttitleRow.setHeightInPoints(rowHigh);\n\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\ttitleRow.createCell(i).setCellStyle(styles.get(\"item_leftBold\"));\n\t\t}\n\n\t\tint cellNum = 0;\n\t\ttitleRow.getCell(cellNum++)\n\t\t\t\t.setCellValue(rb.getString(\"wksheet_meeting_name\", \"Event Name\"));\n\t\ttitleRow.getCell(cellNum++)\n\t\t\t\t.setCellValue(rb.getString(\"wksheet_user_name\", \"Attendee Name\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_user_id\", \"Attendee User Id\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_user_email\", \"Email\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_site_name\", \"Site Title\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_appointment_start_time\", \"Appointment Time\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_appointment_duration\", \"Duration (min)\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_num_of_attendees\", \"#Num Attendees in Slot\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_user_comment\", \"User Comment\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_organizer\", \"Organizer\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_location\", \"Location\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(rb.getString(\"wksheet_category\", \"Category\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_meeting_start_time\", \"Event Start Time\"));\n\t\ttitleRow.getCell(cellNum++).setCellValue(\n\t\t\t\trb.getString(\"wksheet_meeting_duration\", \"Event Duration (min)\"));\n\n\t\tfor (SignupMeetingWrapper wrp : wrappers) {\n\t\t\tList<SignupTimeslot> tsItems = wrp.getMeeting().getSignupTimeSlots();\n\t\t\tif (tsItems != null) {\n\t\t\t\tfor (SignupTimeslot tsItem : tsItems) {\n\t\t\t\t\t/*strange thing happen for hibernate, tsItem can be null for mySql 4.x*/\n\t\t\t\t\tList<SignupAttendee> attendees = tsItem == null ? null : getValidAttendees(tsItem.getAttendees());\n\t\t\t\t\tif (attendees != null) {\n\t\t\t\t\t\tfor (SignupAttendee att : attendees) {\n\t\t\t\t\t\t\tRow row = sheet.createRow(rowNum++);\n\t\t\t\t\t\t\tfor (int i = 0; i <= numberOfColumn; i++) {\n\t\t\t\t\t\t\t\trow.createCell(i).setCellStyle(styles.get(\"item_left\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUser attendee = sakaiFacade.getUser(att.getAttendeeUserId());\n\t\t\t\t\t\t\t/* reset */\n\t\t\t\t\t\t\tcellNum = 0;\n\n\t\t\t\t\t\t\t/* meeting title */\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(wrp.getMeeting().getTitle());\n\n\t\t\t\t\t\t\t/* attendee name */\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(attendee ==null? \"--\" :attendee.getDisplayName());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(attendee ==null? \"--\" : attendee.getEid());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(attendee ==null? \"--\" : attendee.getEmail());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getSiteTitle(att.getSignupSiteId()));\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getTimeService().newTime(\n\t\t\t\t\t\t\t\t\ttsItem.getStartTime().getTime()).toStringLocalFull());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getDurationLength(tsItem.getEndTime(), tsItem\n\t\t\t\t\t\t\t\t\t.getStartTime()));// minutes\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getValidAttendees(tsItem.getAttendees()).size());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(att.getComments());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getUserDisplayName(wrp.getMeeting()\n\t\t\t\t\t\t\t\t\t.getCreatorUserId()));\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(wrp.getMeeting().getLocation());\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(wrp.getMeeting().getCategory());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(sakaiFacade.getTimeService().newTime(\n\t\t\t\t\t\t\t\t\twrp.getMeeting().getStartTime().getTime()).toStringLocalFull());\n\n\t\t\t\t\t\t\tcell = row.getCell(cellNum++);\n\t\t\t\t\t\t\tcell.setCellValue(getDurationLength(wrp.getMeeting().getEndTime(), wrp\n\t\t\t\t\t\t\t\t\t.getMeeting().getStartTime()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn wb;\n\t}","commit_id":"9bf2585ff02cba80ad5d516749e0da1d103faeef","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static void cleanupElements(final Project project, final Runnable runnable, final PsiElement... scope) {\n    final List<SmartPsiElementPointer<PsiElement>> elements = new ArrayList<SmartPsiElementPointer<PsiElement>>();\n    final SmartPointerManager manager = SmartPointerManager.getInstance(project);\n    for (PsiElement element : scope) {\n      elements.add(manager.createSmartPsiElementPointer(element));\n    }\n\n    Runnable cleanupRunnable = new Runnable() {\n      @Override\n      public void run() {\n        final List<PsiElement> psiElements = new ArrayList<PsiElement>();\n        for (SmartPsiElementPointer<PsiElement> element : elements) {\n          PsiElement psiElement = element.getElement();\n          if (psiElement != null && psiElement.isPhysical()) {\n            psiElements.add(psiElement);\n          }\n        }\n        if (psiElements.isEmpty()) {\n          return;\n        }\n        GlobalInspectionContextBase globalContext = (GlobalInspectionContextBase)InspectionManager.getInstance(project).createNewGlobalContext(false);\n        final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n        AnalysisScope analysisScope = new AnalysisScope(new LocalSearchScope(psiElements.toArray(new PsiElement[psiElements.size()])), project);\n        globalContext.codeCleanup(project, analysisScope, profile, null, runnable, true);\n      }\n    };\n\n    Application application = ApplicationManager.getApplication();\n    if (application.isWriteAccessAllowed()) {\n      application.invokeLater(cleanupRunnable);\n    }\n    else {\n      cleanupRunnable.run();\n    }\n  }","id":47770,"modified_method":"public static void cleanupElements(final Project project, final Runnable runnable, final PsiElement... scope) {\n    final List<SmartPsiElementPointer<PsiElement>> elements = new ArrayList<SmartPsiElementPointer<PsiElement>>();\n    final SmartPointerManager manager = SmartPointerManager.getInstance(project);\n    for (PsiElement element : scope) {\n      elements.add(manager.createSmartPsiElementPointer(element));\n    }\n\n    Runnable cleanupRunnable = new Runnable() {\n      @Override\n      public void run() {\n        final List<PsiElement> psiElements = new ArrayList<PsiElement>();\n        for (SmartPsiElementPointer<PsiElement> element : elements) {\n          PsiElement psiElement = element.getElement();\n          if (psiElement != null && psiElement.isPhysical()) {\n            psiElements.add(psiElement);\n          }\n        }\n        if (psiElements.isEmpty()) {\n          return;\n        }\n        GlobalInspectionContextBase globalContext = (GlobalInspectionContextBase)InspectionManager.getInstance(project).createNewGlobalContext(false);\n        final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n        AnalysisScope analysisScope = new AnalysisScope(new LocalSearchScope(psiElements.toArray(new PsiElement[psiElements.size()])), project);\n        globalContext.codeCleanup(project, analysisScope, profile, null, runnable, true);\n      }\n    };\n\n    Application application = ApplicationManager.getApplication();\n    if (application.isWriteAccessAllowed() && !application.isUnitTestMode()) {\n      application.invokeLater(cleanupRunnable);\n    }\n    else {\n      cleanupRunnable.run();\n    }\n  }","commit_id":"f90ba61bcfc47eb2b71a87c4b81e3daf4d6941d3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void insertGenerationInfos(InsertionContext context, List<PsiGenerationInfo<PsiMethod>> infos) {\n    List<PsiGenerationInfo<PsiMethod>> newInfos = GenerateMembersUtil\n      .insertMembersAtOffset(context.getFile(), context.getStartOffset(), infos);\n    if (!newInfos.isEmpty()) {\n      newInfos.get(0).positionCaret(context.getEditor(), true);\n    }\n  }","id":47771,"modified_method":"private static void insertGenerationInfos(InsertionContext context, List<PsiGenerationInfo<PsiMethod>> infos) {\n    List<PsiGenerationInfo<PsiMethod>> newInfos = GenerateMembersUtil\n      .insertMembersAtOffset(context.getFile(), context.getStartOffset(), infos);\n    if (!newInfos.isEmpty()) {\n      final List<PsiElement> elements = new ArrayList<PsiElement>();\n      for (GenerationInfo member : newInfos) {\n        if (!(member instanceof TemplateGenerationInfo)) {\n          final PsiMember psiMember = member.getPsiMember();\n          if (psiMember != null) {\n            elements.add(psiMember);\n          }\n        }\n      }\n\n      GlobalInspectionContextBase.cleanupElements(context.getProject(), null, elements.toArray(new PsiElement[elements.size()]));\n      newInfos.get(0).positionCaret(context.getEditor(), true);\n    }\n  }","commit_id":"f90ba61bcfc47eb2b71a87c4b81e3daf4d6941d3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(final RefreshSessionImpl session) {\n    if (session.isAsynchronous()) {\n      queueSession(session, ModalityState.NON_MODAL);\n    }\n    else {\n      final Application app = ApplicationManager.getApplication();\n      boolean isEDT = app.isDispatchThread();\n      if (isEDT || app.isWriteAccessAllowed()) {\n        session.scan();\n        session.fireEvents();\n      }\n      else {\n        if (app.isReadAccessAllowed()) {\n          LOG.error(\"Do not call synchronous refresh from inside read action except for event dispatch thread. This will eventually cause deadlock if there are events to fire\");\n          return;\n        }\n\n        queueSession(session, ModalityState.defaultModalityState());\n        session.waitFor();\n      }\n    }\n  }","id":47772,"modified_method":"public void execute(final RefreshSessionImpl session) {\n    if (session.isAsynchronous()) {\n      queueSession(session, ModalityState.NON_MODAL);\n    }\n    else {\n      final Application app = ApplicationManager.getApplication();\n      boolean isEDT = app.isDispatchThread();\n      final boolean hasWriteAction = app.isWriteAccessAllowed();\n      if (isEDT || hasWriteAction) {\n        session.scan();\n        if (hasWriteAction) {\n          session.fireEvents();\n        }\n        else {\n          app.runWriteAction(new Runnable() {\n            public void run() {\n              session.fireEvents();\n            }\n          });\n        }\n      }\n      else {\n        if (app.isReadAccessAllowed()) {\n          LOG.error(\"Do not call synchronous refresh from inside read action except for event dispatch thread. This will eventually cause deadlock if there are events to fire\");\n          return;\n        }\n\n        queueSession(session, ModalityState.defaultModalityState());\n        session.waitFor();\n      }\n    }\n  }","commit_id":"152a39ec0a2d90680e716b659ec732ec3202ed19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RunResult<T> execute() {\n    final RunResult<T> result = new RunResult<T>(this);\n\n    try {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          performWriteCommandAction(result);\n        }\n      };\n      Application application = ApplicationManager.getApplication();\n      if (application.isWriteAccessAllowed()) {\n        runnable.run();\n      }\n      else {\n        GuiUtils.invokeAndWait(runnable);\n      }\n    } catch (Throwable e) {\n      if (e instanceof InvocationTargetException) e = e.getCause();\n      if (e instanceof Error) throw (Error)e;\n      else if (e instanceof RuntimeException) throw (RuntimeException)e;\n      throw new Error(e);\n    }\n    return result;\n  }","id":47773,"modified_method":"public RunResult<T> execute() {\n    final RunResult<T> result = new RunResult<T>(this);\n\n    try {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          performWriteCommandAction(result);\n        }\n      };\n      Application application = ApplicationManager.getApplication();\n      if (application.isWriteAccessAllowed() || application.isDispatchThread()) {\n        runnable.run();\n      }\n      else {\n        GuiUtils.invokeAndWait(runnable);\n      }\n    } catch (Throwable e) {\n      if (e instanceof InvocationTargetException) e = e.getCause();\n      if (e instanceof Error) throw (Error)e;\n      else if (e instanceof RuntimeException) throw (RuntimeException)e;\n      throw new Error(e);\n    }\n    return result;\n  }","commit_id":"3d09b6d06319d17a565333e7035ebab783815197","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Restore keys from the given cooldown queue. Find any keys that are due to be\n\t * restored, restore all requests both persistent and non-persistent for those keys.\n\t * @param queue\n\t * @param persistent\n\t * @param container\n\t * @return Long.MAX_VALUE if nothing is queued in the next WAIT_AFTER_NOTHING_TO_START\n\t * millis, the time at which the next key is due to be restored if there are keys queued\n\t * to be restarted in the near future.\n\t */\n\tprivate long moveKeysFromCooldownQueue(CooldownQueue queue, boolean persistent, ObjectContainer container) {\n\t\tif(queue == null) return Long.MAX_VALUE;\n\t\tlong now = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Moving keys from cooldown queue persistent=\"+persistent);\n\t\t/*\n\t\t * Only go around once. We will be called again. If there are keys to move, then RequestStarter will not\n\t\t * sleep, because it will start them. Then it will come back here. If we are off-thread i.e. on the database\n\t\t * thread, then we will wake it up if we find keys... and we'll be scheduled again.\n\t\t * \n\t\t * FIXME: I think we need to restore all the listeners for a single key \n\t\t * simultaneously to avoid some kind of race condition? Or could we just\n\t\t * restore the one request on the queue? Maybe it's just a misguided\n\t\t * optimisation? IIRC we had some severe problems when we didn't have \n\t\t * this, related to requests somehow being lost altogether... Is it \n\t\t * essential? We can save a query if it's not... Is this about requests\n\t\t * or about keys? Should we limit all requests across any \n\t\t * SendableRequest's to 3 every half hour for a specific key? Probably \n\t\t * yes...? In which case, can the cooldown queue be entirely in RAM,\n\t\t * and would it be useful for it to be? Less disk, more RAM... for fast\n\t\t * nodes with little RAM it would be bad...\n\t\t */\n\t\tfinal int MAX_KEYS = 20;\n\t\tObject ret = queue.removeKeyBefore(now, WAIT_AFTER_NOTHING_TO_START, container, MAX_KEYS);\n\t\tif(ret == null) return Long.MAX_VALUE;\n\t\tif(ret instanceof Long) {\n\t\t\treturn (Long) ret;\n\t\t}\n\t\tKey[] keys = (Key[]) ret;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(key, 5);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\trestoreKey(key, container, now);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(key, 5);\n\t\t}\n\t\treturn Long.MAX_VALUE;\n\t}","id":47774,"modified_method":"/**\n\t * Restore keys from the given cooldown queue. Find any keys that are due to be\n\t * restored, restore all requests both persistent and non-persistent for those keys.\n\t * @param queue\n\t * @param persistent\n\t * @param container\n\t * @return Long.MAX_VALUE if nothing is queued in the next WAIT_AFTER_NOTHING_TO_START\n\t * millis, the time at which the next key is due to be restored if there are keys queued\n\t * to be restarted in the near future.\n\t */\n\tprivate long moveKeysFromCooldownQueue(CooldownQueue queue, boolean persistent, ObjectContainer container) {\n\t\tif(queue == null) return Long.MAX_VALUE;\n\t\tlong now = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Moving keys from cooldown queue persistent=\"+persistent);\n\t\t/*\n\t\t * Only go around once. We will be called again. If there are keys to move, then RequestStarter will not\n\t\t * sleep, because it will start them. Then it will come back here. If we are off-thread i.e. on the database\n\t\t * thread, then we will wake it up if we find keys... and we'll be scheduled again.\n\t\t * \n\t\t * FIXME: I think we need to restore all the listeners for a single key \n\t\t * simultaneously to avoid some kind of race condition? Or could we just\n\t\t * restore the one request on the queue? Maybe it's just a misguided\n\t\t * optimisation? IIRC we had some severe problems when we didn't have \n\t\t * this, related to requests somehow being lost altogether... Is it \n\t\t * essential? We can save a query if it's not... Is this about requests\n\t\t * or about keys? Should we limit all requests across any \n\t\t * SendableRequest's to 3 every half hour for a specific key? Probably \n\t\t * yes...? In which case, can the cooldown queue be entirely in RAM,\n\t\t * and would it be useful for it to be? Less disk, more RAM... for fast\n\t\t * nodes with little RAM it would be bad...\n\t\t */\n\t\tfinal int MAX_KEYS = 20;\n\t\tObject ret;\n\t\tClientRequestScheduler otherScheduler = \n\t\t\t(isSSKScheduler ? this.clientContext.getSskFetchScheduler() : this.clientContext.getChkFetchScheduler());\n\t\tif(queue instanceof PersistentCooldownQueue) {\n\t\t\tret = ((PersistentCooldownQueue)queue).removeKeyBefore(now, WAIT_AFTER_NOTHING_TO_START, container, MAX_KEYS, (PersistentCooldownQueue)otherScheduler.persistentCooldownQueue);\n\t\t} else\n\t\t\tret = queue.removeKeyBefore(now, WAIT_AFTER_NOTHING_TO_START, container, MAX_KEYS);\n\t\tif(ret == null) return Long.MAX_VALUE;\n\t\tif(ret instanceof Long) {\n\t\t\treturn (Long) ret;\n\t\t}\n\t\tKey[] keys = (Key[]) ret;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(key, 5);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tif(key instanceof NodeSSK == isSSKScheduler)\n\t\t\t\trestoreKey(key, container, now);\n\t\t\telse\n\t\t\t\totherScheduler.restoreKey(key, container, now); \n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(key, 5);\n\t\t}\n\t\treturn Long.MAX_VALUE;\n\t}","commit_id":"9a483f2ecb5e7a312658fd232171ed8b2065e77b","url":"https://github.com/freenet/fred"},{"original_method":"public Object removeKeyBefore(final long now, long dontCareAfterMillis, ObjectContainer container, int maxCount) {\n\t\t// Will be called repeatedly until no more keys are returned, so it doesn't\n\t\t// matter very much if they're not in order.\n\t\t\n\t\t// This query returns bogus results (cooldown items with times in the future).\n//\t\tObjectSet results = container.query(new Predicate() {\n//\t\t\tpublic boolean match(PersistentCooldownQueueItem persistentCooldownQueueItem) {\n//\t\t\t\tif(persistentCooldownQueueItem.time >= now) return false;\n//\t\t\t\tif(persistentCooldownQueueItem.parent != PersistentCooldownQueue.this) return false;\n//\t\t\t\treturn true;\n//\t\t\t}\n//\t\t});\n\t\t// Lets re-code it in SODA.\n\t\tlong tStart = System.currentTimeMillis();\n\t\tQuery query = container.query();\n\t\tquery.constrain(PersistentCooldownQueueItem.class);\n\t\t// Don't constrain on parent.\n\t\t// parent index is humongous, so we get a huge memory spike, queries take ages.\n\t\t// Just check manually.\n\t\tquery.descend(\"time\").orderAscending().constrain(Long.valueOf(now + dontCareAfterMillis)).smaller();\n\t\tObjectSet results = query.execute();\n\t\tif(results.hasNext()) {\n\t\t\tlong tEnd = System.currentTimeMillis();\n\t\t\tif(tEnd - tStart > 1000)\n\t\t\t\tLogger.error(this, \"Query took \"+(tEnd-tStart));\n\t\t\telse\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Query took \"+(tEnd-tStart));\n\t\t\tArrayList v = new ArrayList(Math.min(maxCount, results.size()));\n\t\t\twhile(results.hasNext() && v.size() < maxCount) {\n\t\t\t\tPersistentCooldownQueueItem i = (PersistentCooldownQueueItem) results.next();\n\t\t\t\tif(i.parent != this) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i.time >= now) {\n\t\t\t\t\tif(v.isEmpty()) return i.time;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontainer.activate(i.key, 5);\n\t\t\t\tif(i.client == null || !container.ext().isStored(i.client)) {\n\t\t\t\t\tLogger.normal(this, \"Client has been removed but not the persistent cooldown queue item: time \"+i.time+\" for key \"+i.key);\n\t\t\t\t}\n\t\t\t\tif(i.key == null) {\n\t\t\t\t\tLogger.error(this, \"Key is null on cooldown queue! i = \"+i+\" client=\"+i.client+\" key as bytes = \"+i.keyAsBytes);\n\t\t\t\t} else {\n\t\t\t\t\tv.add(i.key.cloneKey());\n\t\t\t\t\ti.key.removeFrom(container);\n\t\t\t\t}\n\t\t\t\ti.delete(container);\n\t\t\t}\n\t\t\tif(!v.isEmpty()) {\n\t\t\t\treturn v.toArray(new Key[v.size()]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":47775,"modified_method":"public Object removeKeyBefore(final long now, long dontCareAfterMillis, ObjectContainer container, int maxCount) {\n\t\treturn removeKeyBefore(now, dontCareAfterMillis, container, maxCount, null);\n\t}","commit_id":"9a483f2ecb5e7a312658fd232171ed8b2065e77b","url":"https://github.com/freenet/fred"},{"original_method":"private void moveKeysFromCooldownQueue(CooldownQueue queue, ObjectContainer container) {\n\t\tif(queue == null) return;\n\t\tlong now = System.currentTimeMillis();\n\t\tKey key;\n\t\twhile((key = queue.removeKeyBefore(now, container)) != null) { \n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tSendableGet[] gets = schedCore.getClientsForPendingKey(key);\n\t\t\tSendableGet[] transientGets = schedTransient.getClientsForPendingKey(key);\n\t\t\tif(gets == null && transientGets == null) {\n\t\t\t\t// Not an error as this can happen due to race conditions etc.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key but no keys queued?? for \"+key);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(gets != null)\n\t\t\t\tfor(int i=0;i<gets.length;i++)\n\t\t\t\t\tgets[i].requeueAfterCooldown(key, now);\n\t\t\t\tif(transientGets != null)\n\t\t\t\tfor(int i=0;i<transientGets.length;i++)\n\t\t\t\t\ttransientGets[i].requeueAfterCooldown(key, now);\n\t\t\t}\n\t\t}\n\t}","id":47776,"modified_method":"private void moveKeysFromCooldownQueue(CooldownQueue queue, ObjectContainer container) {\n\t\tif(queue == null) return;\n\t\tlong now = System.currentTimeMillis();\n\t\tfinal int MAX_KEYS = 1024;\n\t\twhile(true) {\n\t\tKey[] keys = queue.removeKeyBefore(now, container, MAX_KEYS);\n\t\tif(keys == null) return;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tSendableGet[] gets = schedCore.getClientsForPendingKey(key);\n\t\t\tSendableGet[] transientGets = schedTransient.getClientsForPendingKey(key);\n\t\t\tif(gets == null && transientGets == null) {\n\t\t\t\t// Not an error as this can happen due to race conditions etc.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key but no keys queued?? for \"+key);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(gets != null)\n\t\t\t\tfor(int i=0;i<gets.length;i++)\n\t\t\t\t\tgets[i].requeueAfterCooldown(key, now);\n\t\t\t\tif(transientGets != null)\n\t\t\t\tfor(int i=0;i<transientGets.length;i++)\n\t\t\t\t\ttransientGets[i].requeueAfterCooldown(key, now);\n\t\t\t}\n\t\t}\n\t\tif(keys.length < MAX_KEYS) return;\n\t\t}\n\t}","commit_id":"247f1365be50f636d8ff0a86a66d6c187937479e","url":"https://github.com/freenet/fred"},{"original_method":"public Key removeKeyBefore(final long now, ObjectContainer container) {\n\t\t// Will be called repeatedly until no more keys are returned, so it doesn't\n\t\t// matter very much if they're not in order.\n\t\tObjectSet results = container.query(new Predicate() {\n\t\t\tpublic boolean match(Item item) {\n\t\t\t\tif(item.parent != PersistentCooldownQueue.this) return false;\n\t\t\t\tif(item.time > now) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tif(results.hasNext()) {\n\t\t\tItem i = (Item) results.next();\n\t\t\tcontainer.delete(i);\n\t\t\treturn i.key;\n\t\t} else\n\t\t\treturn null;\n\t}","id":47777,"modified_method":"public Key[] removeKeyBefore(final long now, ObjectContainer container, int maxCount) {\n\t\t// Will be called repeatedly until no more keys are returned, so it doesn't\n\t\t// matter very much if they're not in order.\n\t\tObjectSet results = container.query(new Predicate() {\n\t\t\tpublic boolean match(Item item) {\n\t\t\t\tif(item.parent != PersistentCooldownQueue.this) return false;\n\t\t\t\tif(item.time > now) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tif(results.hasNext()) {\n\t\t\tArrayList v = new ArrayList(Math.min(maxCount, results.size()));\n\t\t\twhile(results.hasNext() && v.size() < maxCount) {\n\t\t\t\tItem i = (Item) results.next();\n\t\t\t\tv.add(i.key);\n\t\t\t}\n\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t} else\n\t\t\treturn null;\n\t}","commit_id":"247f1365be50f636d8ff0a86a66d6c187937479e","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized Key removeKeyBefore(long now, ObjectContainer container) {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tboolean foundIT = false;\n\t\tif(Logger.shouldLog(Logger.DEBUG, this)) {\n\t\t\tfoundIT = bigLog();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remove key before \"+now+\" : startPtr=\"+startPtr+\" endPtr=\"+endPtr+\" holes=\"+holes+\" keys.length=\"+keys.length);\n\t\tif(holes < 0) Logger.error(this, \"holes = \"+holes+\" !!\");\n\t\tif(foundIT) {\n\t\t\tif(logMINOR) Logger.minor(this, \"FOUND IT!\"); // FIXME remove\n\t\t}\n\t\twhile(true) {\n\t\t\tif(startPtr == endPtr) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No keys queued\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlong time = times[startPtr];\n\t\t\tKey key = keys[startPtr];\n\t\t\tif(key == null) {\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tholes--;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Skipped hole\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(time > now) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"First key is later at time \"+time);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tkeys[startPtr] = null;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Returning key \"+key);\n\t\t\treturn key;\n\t\t}\n\t}","id":47778,"modified_method":"public synchronized Key[] removeKeyBefore(long now, ObjectContainer container, int maxKeys) {\n\t\tArrayList v = new ArrayList();\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tboolean foundIT = false;\n\t\tif(Logger.shouldLog(Logger.DEBUG, this)) {\n\t\t\tfoundIT = bigLog();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remove key before \"+now+\" : startPtr=\"+startPtr+\" endPtr=\"+endPtr+\" holes=\"+holes+\" keys.length=\"+keys.length);\n\t\tif(holes < 0) Logger.error(this, \"holes = \"+holes+\" !!\");\n\t\tif(foundIT) {\n\t\t\tif(logMINOR) Logger.minor(this, \"FOUND IT!\"); // FIXME remove\n\t\t}\n\t\twhile(true) {\n\t\t\tif(startPtr == endPtr) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No keys queued\");\n\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t}\n\t\t\tlong time = times[startPtr];\n\t\t\tKey key = keys[startPtr];\n\t\t\tif(key == null) {\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tholes--;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Skipped hole\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(time > now) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"First key is later at time \"+time);\n\t\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t\t}\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tkeys[startPtr] = null;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Returning key \"+key);\n\t\t\tv.add(key);\n\t\t}\n\t}","commit_id":"247f1365be50f636d8ff0a86a66d6c187937479e","url":"https://github.com/freenet/fred"},{"original_method":"private boolean moveKeysFromCooldownQueue(CooldownQueue queue, boolean persistent, ObjectContainer container) {\n\t\tif(queue == null) return false;\n\t\tlong now = System.currentTimeMillis();\n\t\t/*\n\t\t * Only go around once. We will be called again. If there are keys to move, then RequestStarter will not\n\t\t * sleep, because it will start them. Then it will come back here. If we are off-thread i.e. on the database\n\t\t * thread, then we will wake it up if we find keys... and we'll be scheduled again.\n\t\t * \n\t\t * FIXME: I think we need to restore all the listeners for a single key \n\t\t * simultaneously to avoid some kind of race condition? Or could we just\n\t\t * restore the one request on the queue? Maybe it's just a misguided\n\t\t * optimisation? IIRC we had some severe problems when we didn't have \n\t\t * this, related to requests somehow being lost altogether... Is it \n\t\t * essential? We can save a query if it's not... Is this about requests\n\t\t * or about keys? Should we limit all requests across any \n\t\t * SendableRequest's to 3 every half hour for a specific key? Probably \n\t\t * yes...? In which case, can the cooldown queue be entirely in RAM,\n\t\t * and would it be useful for it to be? Less disk, more RAM... for fast\n\t\t * nodes with little RAM it would be bad...\n\t\t */\n\t\tfinal int MAX_KEYS = 20;\n\t\tKey[] keys = queue.removeKeyBefore(now, container, MAX_KEYS);\n\t\tif(keys == null) return false;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(key, 5);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tSendableGet[] reqs = schedCore.requestsForKey(key, container, clientContext);\n\t\t\tSendableGet[] transientReqs = schedTransient.requestsForKey(key, container, clientContext);\n\t\t\tif(reqs == null && transientReqs == null) {\n\t\t\t\t// Not an error as this can happen due to race conditions etc.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key but no keys queued?? for \"+key);\n\t\t\t}\n\t\t\tif(reqs != null) {\n\t\t\t\tfor(int i=0;i<reqs.length;i++) {\n\t\t\t\t\t// Requests may or may not be returned activated from requestsForKey(), so don't check\n\t\t\t\t\t// But do deactivate them once we're done with them.\n\t\t\t\t\tcontainer.activate(reqs[i], 1);\n\t\t\t\t\treqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t\t\tcontainer.deactivate(reqs[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(transientReqs != null) {\n\t\t\t\tfor(int i=0;i<transientReqs.length;i++)\n\t\t\t\t\ttransientReqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(key, 5);\n\t\t}\n\t\treturn true;\n\t}","id":47779,"modified_method":"private long moveKeysFromCooldownQueue(CooldownQueue queue, boolean persistent, ObjectContainer container) {\n\t\tif(queue == null) return Long.MAX_VALUE;\n\t\tlong now = System.currentTimeMillis();\n\t\t/*\n\t\t * Only go around once. We will be called again. If there are keys to move, then RequestStarter will not\n\t\t * sleep, because it will start them. Then it will come back here. If we are off-thread i.e. on the database\n\t\t * thread, then we will wake it up if we find keys... and we'll be scheduled again.\n\t\t * \n\t\t * FIXME: I think we need to restore all the listeners for a single key \n\t\t * simultaneously to avoid some kind of race condition? Or could we just\n\t\t * restore the one request on the queue? Maybe it's just a misguided\n\t\t * optimisation? IIRC we had some severe problems when we didn't have \n\t\t * this, related to requests somehow being lost altogether... Is it \n\t\t * essential? We can save a query if it's not... Is this about requests\n\t\t * or about keys? Should we limit all requests across any \n\t\t * SendableRequest's to 3 every half hour for a specific key? Probably \n\t\t * yes...? In which case, can the cooldown queue be entirely in RAM,\n\t\t * and would it be useful for it to be? Less disk, more RAM... for fast\n\t\t * nodes with little RAM it would be bad...\n\t\t */\n\t\tfinal int MAX_KEYS = 20;\n\t\tObject ret = queue.removeKeyBefore(now, WAIT_AFTER_NOTHING_TO_START, container, MAX_KEYS);\n\t\tif(ret == null) return Long.MAX_VALUE;\n\t\tif(ret instanceof Long) {\n\t\t\treturn (Long) ret;\n\t\t}\n\t\tKey[] keys = (Key[]) ret;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(key, 5);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tSendableGet[] reqs = schedCore.requestsForKey(key, container, clientContext);\n\t\t\tSendableGet[] transientReqs = schedTransient.requestsForKey(key, container, clientContext);\n\t\t\tif(reqs == null && transientReqs == null) {\n\t\t\t\t// Not an error as this can happen due to race conditions etc.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key but no keys queued?? for \"+key);\n\t\t\t}\n\t\t\tif(reqs != null) {\n\t\t\t\tfor(int i=0;i<reqs.length;i++) {\n\t\t\t\t\t// Requests may or may not be returned activated from requestsForKey(), so don't check\n\t\t\t\t\t// But do deactivate them once we're done with them.\n\t\t\t\t\tcontainer.activate(reqs[i], 1);\n\t\t\t\t\treqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t\t\tcontainer.deactivate(reqs[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(transientReqs != null) {\n\t\t\t\tfor(int i=0;i<transientReqs.length;i++)\n\t\t\t\t\ttransientReqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(key, 5);\n\t\t}\n\t\treturn Long.MAX_VALUE;\n\t}","commit_id":"2d42f59ed33cb46648cefbd880f099f2d7684f24","url":"https://github.com/freenet/fred"},{"original_method":"public void queueFillRequestStarterQueue() {\n\t\tif(lastFilledStarterQueueEmpty > 0 &&\n\t\t\t\tSystem.currentTimeMillis() - lastFilledStarterQueueEmpty < 60*1000)\n\t\t\treturn;\n\t\tif(starterQueueLength() > MAX_STARTER_QUEUE_SIZE / 2)\n\t\t\treturn;\n\t\tjobRunner.queue(requestStarterQueueFiller, NativeThread.MAX_PRIORITY, true);\n\t}","id":47780,"modified_method":"public void queueFillRequestStarterQueue() {\n\t\tif(nextQueueFillRequestStarterQueue > 0 &&\n\t\t\t\tSystem.currentTimeMillis() < nextQueueFillRequestStarterQueue)\n\t\t\treturn;\n\t\tif(starterQueueLength() > MAX_STARTER_QUEUE_SIZE / 2)\n\t\t\treturn;\n\t\tjobRunner.queue(requestStarterQueueFiller, NativeThread.MAX_PRIORITY, true);\n\t}","commit_id":"2d42f59ed33cb46648cefbd880f099f2d7684f24","url":"https://github.com/freenet/fred"},{"original_method":"private void fillRequestStarterQueue(ObjectContainer container, ClientContext context, SendableRequest[] mightBeActive) {\n\t\tif(logMINOR) Logger.minor(this, \"Filling request queue... (SSK=\"+isSSKScheduler+\" insert=\"+isInsertScheduler);\n\t\tshort fuzz = -1;\n\t\tif(PRIORITY_SOFT.equals(choosenPriorityScheduler))\n\t\t\tfuzz = -1;\n\t\telse if(PRIORITY_HARD.equals(choosenPriorityScheduler))\n\t\t\tfuzz = 0;\n\t\tboolean added = false;\n\t\tsynchronized(starterQueue) {\n\t\t\tif(logMINOR && (!isSSKScheduler) && (!isInsertScheduler)) {\n\t\t\t\tLogger.minor(this, \"Scheduling CHK fetches...\");\n\t\t\t\tfor(SendableRequest req : runningPersistentRequests) {\n\t\t\t\t\tboolean wasActive = container.ext().isActive(req);\n\t\t\t\t\tif(!wasActive) container.activate(req, 1);\n\t\t\t\t\tLogger.minor(this, \"Running persistent request: \"+req);\n\t\t\t\t\tif(!wasActive) container.deactivate(req, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Recompute starterQueueLength\n\t\t\tint length = 0;\n\t\t\tPersistentChosenRequest old = null;\n\t\t\tfor(PersistentChosenRequest req : starterQueue) {\n\t\t\t\tif(old == req)\n\t\t\t\t\tLogger.error(this, \"DUPLICATE CHOSEN REQUESTS ON QUEUE: \"+req);\n\t\t\t\tif(old != null && old.request == req.request)\n\t\t\t\t\tLogger.error(this, \"DUPLICATE REQUEST ON QUEUE: \"+old+\" vs \"+req+\" both \"+req.request);\n\t\t\t\tboolean ignoreActive = false;\n\t\t\t\tif(mightBeActive != null) {\n\t\t\t\t\tfor(SendableRequest tmp : mightBeActive)\n\t\t\t\t\t\tif(tmp == req.request) ignoreActive = true;\n\t\t\t\t}\n\t\t\t\tif(!ignoreActive) {\n\t\t\t\t\tif(container.ext().isActive(req.request))\n\t\t\t\t\t\tLogger.error(this, \"REQUEST ALREADY ACTIVATED: \"+req.request+\" for \"+req+\" while checking request queue in filling request queue\");\n\t\t\t\t\telse if(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not already activated for \"+req+\" in while checking request queue in filling request queue\");\n\t\t\t\t} else if(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Ignoring active because just registered: \"+req.request);\n\t\t\t\treq.pruneDuplicates(ClientRequestScheduler.this);\n\t\t\t\told = req;\n\t\t\t\tlength += req.sizeNotStarted();\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Queue size: \"+length+\" SSK=\"+isSSKScheduler+\" insert=\"+isInsertScheduler);\n\t\t\tif(length >= MAX_STARTER_QUEUE_SIZE) {\n\t\t\t\tif(length >= WARNING_STARTER_QUEUE_SIZE)\n\t\t\t\t\tLogger.error(this, \"Queue already full: \"+length);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(length > MAX_STARTER_QUEUE_SIZE * 3 / 4) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif((!isSSKScheduler) && (!isInsertScheduler)) {\n\t\t\tLogger.minor(this, \"Scheduling CHK fetches...\");\n\t\t}\n\t\twhile(true) {\n\t\t\tSendableRequest request = schedCore.removeFirstInner(fuzz, random, offeredKeys, starter, schedTransient, false, true, Short.MAX_VALUE, Integer.MAX_VALUE, context, container);\n\t\t\tif(request == null) {\n\t\t\t\tsynchronized(ClientRequestScheduler.this) {\n\t\t\t\t\tif(!added) \n\t\t\t\t\t\tlastFilledStarterQueueEmpty = System.currentTimeMillis();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadded = true;\n\t\t\tboolean full = addToStarterQueue(request, container);\n\t\t\tcontainer.deactivate(request, 1);\n\t\t\tstarter.wakeUp();\n\t\t\tif(full) return;\n\t\t}\n\t}","id":47781,"modified_method":"private void fillRequestStarterQueue(ObjectContainer container, ClientContext context, SendableRequest[] mightBeActive) {\n\t\tif(logMINOR) Logger.minor(this, \"Filling request queue... (SSK=\"+isSSKScheduler+\" insert=\"+isInsertScheduler);\n\t\tboolean wakeUp = false;\n\t\tlong noLaterThan = Long.MAX_VALUE;\n\t\tnoLaterThan = moveKeysFromCooldownQueue(persistentCooldownQueue, true, container);\n\t\tnoLaterThan = Math.min(noLaterThan, moveKeysFromCooldownQueue(transientCooldownQueue, false, container));\n\t\tif(noLaterThan != Long.MAX_VALUE)\n\t\t\twakeUp = true;\n\t\tshort fuzz = -1;\n\t\tif(PRIORITY_SOFT.equals(choosenPriorityScheduler))\n\t\t\tfuzz = -1;\n\t\telse if(PRIORITY_HARD.equals(choosenPriorityScheduler))\n\t\t\tfuzz = 0;\n\t\tboolean added = false;\n\t\tboolean finished = false;\n\t\tsynchronized(starterQueue) {\n\t\t\tif(logMINOR && (!isSSKScheduler) && (!isInsertScheduler)) {\n\t\t\t\tLogger.minor(this, \"Scheduling CHK fetches...\");\n\t\t\t\tfor(SendableRequest req : runningPersistentRequests) {\n\t\t\t\t\tboolean wasActive = container.ext().isActive(req);\n\t\t\t\t\tif(!wasActive) container.activate(req, 1);\n\t\t\t\t\tLogger.minor(this, \"Running persistent request: \"+req);\n\t\t\t\t\tif(!wasActive) container.deactivate(req, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Recompute starterQueueLength\n\t\t\tint length = 0;\n\t\t\tPersistentChosenRequest old = null;\n\t\t\tfor(PersistentChosenRequest req : starterQueue) {\n\t\t\t\tif(old == req)\n\t\t\t\t\tLogger.error(this, \"DUPLICATE CHOSEN REQUESTS ON QUEUE: \"+req);\n\t\t\t\tif(old != null && old.request == req.request)\n\t\t\t\t\tLogger.error(this, \"DUPLICATE REQUEST ON QUEUE: \"+old+\" vs \"+req+\" both \"+req.request);\n\t\t\t\tboolean ignoreActive = false;\n\t\t\t\tif(mightBeActive != null) {\n\t\t\t\t\tfor(SendableRequest tmp : mightBeActive)\n\t\t\t\t\t\tif(tmp == req.request) ignoreActive = true;\n\t\t\t\t}\n\t\t\t\tif(!ignoreActive) {\n\t\t\t\t\tif(container.ext().isActive(req.request))\n\t\t\t\t\t\tLogger.error(this, \"REQUEST ALREADY ACTIVATED: \"+req.request+\" for \"+req+\" while checking request queue in filling request queue\");\n\t\t\t\t\telse if(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not already activated for \"+req+\" in while checking request queue in filling request queue\");\n\t\t\t\t} else if(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Ignoring active because just registered: \"+req.request);\n\t\t\t\treq.pruneDuplicates(ClientRequestScheduler.this);\n\t\t\t\told = req;\n\t\t\t\tlength += req.sizeNotStarted();\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Queue size: \"+length+\" SSK=\"+isSSKScheduler+\" insert=\"+isInsertScheduler);\n\t\t\tif(length >= MAX_STARTER_QUEUE_SIZE) {\n\t\t\t\tif(length >= WARNING_STARTER_QUEUE_SIZE)\n\t\t\t\t\tLogger.error(this, \"Queue already full: \"+length);\n\t\t\t\tfinished = true;\n\t\t\t}\n\t\t\tif(length > MAX_STARTER_QUEUE_SIZE * 3 / 4) {\n\t\t\t\tfinished = true;\n\t\t\t}\n\t\t}\n\t\tif(finished) {\n\t\t\tif(wakeUp) starter.wakeUp();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif((!isSSKScheduler) && (!isInsertScheduler)) {\n\t\t\tLogger.minor(this, \"Scheduling CHK fetches...\");\n\t\t}\n\t\twhile(true) {\n\t\t\tSendableRequest request = schedCore.removeFirstInner(fuzz, random, offeredKeys, starter, schedTransient, false, true, Short.MAX_VALUE, Integer.MAX_VALUE, context, container);\n\t\t\tif(request == null) {\n\t\t\t\tsynchronized(ClientRequestScheduler.this) {\n\t\t\t\t\t// Don't wake up for a while, but no later than the time we expect the next item to come off the cooldown queue\n\t\t\t\t\tif(!added) {\n\t\t\t\t\t\tif(noLaterThan != Long.MAX_VALUE)\n\t\t\t\t\t\t\tnextQueueFillRequestStarterQueue = Math.min(System.currentTimeMillis() + WAIT_AFTER_NOTHING_TO_START, noLaterThan + 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnextQueueFillRequestStarterQueue = System.currentTimeMillis() + WAIT_AFTER_NOTHING_TO_START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(wakeUp) starter.wakeUp();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tadded = true;\n\t\t\tboolean full = addToStarterQueue(request, container);\n\t\t\tcontainer.deactivate(request, 1);\n\t\t\tstarter.wakeUp();\n\t\t\tif(full) return;\n\t\t}\n\t}","commit_id":"2d42f59ed33cb46648cefbd880f099f2d7684f24","url":"https://github.com/freenet/fred"},{"original_method":"public Key[] removeKeyBefore(final long now, ObjectContainer container, int maxCount) {\n\t\t// Will be called repeatedly until no more keys are returned, so it doesn't\n\t\t// matter very much if they're not in order.\n\t\t\n\t\t// This query returns bogus results (cooldown items with times in the future).\n//\t\tObjectSet results = container.query(new Predicate() {\n//\t\t\tpublic boolean match(PersistentCooldownQueueItem persistentCooldownQueueItem) {\n//\t\t\t\tif(persistentCooldownQueueItem.time >= now) return false;\n//\t\t\t\tif(persistentCooldownQueueItem.parent != PersistentCooldownQueue.this) return false;\n//\t\t\t\treturn true;\n//\t\t\t}\n//\t\t});\n\t\t// Lets re-code it in SODA.\n\t\tlong tStart = System.currentTimeMillis();\n\t\tQuery query = container.query();\n\t\tquery.constrain(PersistentCooldownQueueItem.class);\n\t\tquery.descend(\"time\").constrain(new Long(now)).smaller()\n\t\t\t.and(query.descend(\"parent\").constrain(this).identity());\n\t\tObjectSet results = query.execute();\n\t\tif(results.hasNext()) {\n\t\t\tlong tEnd = System.currentTimeMillis();\n\t\t\tif(tEnd - tStart > 1000)\n\t\t\t\tLogger.error(this, \"Query took \"+(tEnd-tStart));\n\t\t\telse\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Query took \"+(tEnd-tStart));\n\t\t\tArrayList v = new ArrayList(Math.min(maxCount, results.size()));\n\t\t\twhile(results.hasNext() && v.size() < maxCount) {\n\t\t\t\tPersistentCooldownQueueItem i = (PersistentCooldownQueueItem) results.next();\n\t\t\t\tif(i.time >= now) {\n\t\t\t\t\tLogger.error(this, \"removeKeyBefore(): time >= now: diff=\"+(now-i.time));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i.parent != this) {\n\t\t\t\t\tLogger.error(this, \"parent=\"+i.parent+\" but should be \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontainer.delete(i);\n\t\t\t\tv.add(i.key);\n\t\t\t}\n\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t} else {\n\t\t\tlong tEnd = System.currentTimeMillis();\n\t\t\tif(tEnd - tStart > 1000)\n\t\t\t\tLogger.error(this, \"Query took \"+(tEnd-tStart));\n\t\t\telse\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Query took \"+(tEnd-tStart));\n\t\t\treturn null;\n\t\t}\n\t}","id":47782,"modified_method":"public Object removeKeyBefore(final long now, long dontCareAfterMillis, ObjectContainer container, int maxCount) {\n\t\t// Will be called repeatedly until no more keys are returned, so it doesn't\n\t\t// matter very much if they're not in order.\n\t\t\n\t\t// This query returns bogus results (cooldown items with times in the future).\n//\t\tObjectSet results = container.query(new Predicate() {\n//\t\t\tpublic boolean match(PersistentCooldownQueueItem persistentCooldownQueueItem) {\n//\t\t\t\tif(persistentCooldownQueueItem.time >= now) return false;\n//\t\t\t\tif(persistentCooldownQueueItem.parent != PersistentCooldownQueue.this) return false;\n//\t\t\t\treturn true;\n//\t\t\t}\n//\t\t});\n\t\t// Lets re-code it in SODA.\n\t\tlong tStart = System.currentTimeMillis();\n\t\tQuery query = container.query();\n\t\tquery.constrain(PersistentCooldownQueueItem.class);\n\t\tquery.descend(\"time\").constrain(new Long(now)).smaller()\n\t\t\t.and(query.descend(\"parent\").constrain(this).identity());\n\t\tObjectSet results = query.execute();\n\t\tif(results.hasNext()) {\n\t\t\tlong tEnd = System.currentTimeMillis();\n\t\t\tif(tEnd - tStart > 1000)\n\t\t\t\tLogger.error(this, \"Query took \"+(tEnd-tStart));\n\t\t\telse\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Query took \"+(tEnd-tStart));\n\t\t\tArrayList v = new ArrayList(Math.min(maxCount, results.size()));\n\t\t\twhile(results.hasNext() && v.size() < maxCount) {\n\t\t\t\tPersistentCooldownQueueItem i = (PersistentCooldownQueueItem) results.next();\n\t\t\t\tif(i.time >= now) {\n\t\t\t\t\tLogger.error(this, \"removeKeyBefore(): time >= now: diff=\"+(now-i.time));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i.parent != this) {\n\t\t\t\t\tLogger.error(this, \"parent=\"+i.parent+\" but should be \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcontainer.delete(i);\n\t\t\t\tv.add(i.key);\n\t\t\t}\n\t\t\tif(!v.isEmpty()) {\n\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t} else {\n\t\t\t\tquery = container.query();\n\t\t\t\tquery.descend(\"time\").orderAscending().constrain(new Long(now + dontCareAfterMillis)).smaller().\n\t\t\t\t\tand(query.descend(\"parent\").constrain(this).identity());\n\t\t\t\tresults = query.execute();\n\t\t\t\tif(results.hasNext()) {\n\t\t\t\t\treturn ((PersistentCooldownQueueItem) results.next()).time;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlong tEnd = System.currentTimeMillis();\n\t\t\tif(tEnd - tStart > 1000)\n\t\t\t\tLogger.error(this, \"Query took \"+(tEnd-tStart));\n\t\t\telse\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Query took \"+(tEnd-tStart));\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"2d42f59ed33cb46648cefbd880f099f2d7684f24","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized Key[] removeKeyBefore(long now, ObjectContainer container, int maxKeys) {\n\t\tArrayList v = new ArrayList();\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tboolean foundIT = false;\n\t\tif(Logger.shouldLog(Logger.DEBUG, this)) {\n\t\t\tfoundIT = bigLog();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remove key before \"+now+\" : startPtr=\"+startPtr+\" endPtr=\"+endPtr+\" holes=\"+holes+\" keys.length=\"+keys.length);\n\t\tif(holes < 0) Logger.error(this, \"holes = \"+holes+\" !!\");\n\t\tif(foundIT) {\n\t\t\tif(logMINOR) Logger.minor(this, \"FOUND IT!\"); // FIXME remove\n\t\t}\n\t\twhile(true) {\n\t\t\tif(startPtr == endPtr) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No keys queued\");\n\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t}\n\t\t\tlong time = times[startPtr];\n\t\t\tKey key = keys[startPtr];\n\t\t\tif(key == null) {\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tholes--;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Skipped hole\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(time > now) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"First key is later at time \"+time);\n\t\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t\t}\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tkeys[startPtr] = null;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Returning key \"+key);\n\t\t\tv.add(key);\n\t\t\tif(v.size() == maxKeys)\n\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t}\n\t}","id":47783,"modified_method":"public synchronized Object removeKeyBefore(long now, long dontCareAfterMillis, ObjectContainer container, int maxKeys) {\n\t\tArrayList v = new ArrayList();\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tboolean foundIT = false;\n\t\tif(Logger.shouldLog(Logger.DEBUG, this)) {\n\t\t\tfoundIT = bigLog();\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remove key before \"+now+\" : startPtr=\"+startPtr+\" endPtr=\"+endPtr+\" holes=\"+holes+\" keys.length=\"+keys.length);\n\t\tif(holes < 0) Logger.error(this, \"holes = \"+holes+\" !!\");\n\t\tif(foundIT) {\n\t\t\tif(logMINOR) Logger.minor(this, \"FOUND IT!\"); // FIXME remove\n\t\t}\n\t\twhile(true) {\n\t\t\tif(startPtr == endPtr) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"No keys queued\");\n\t\t\t\tif(!v.isEmpty())\n\t\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t\telse\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlong time = times[startPtr];\n\t\t\tKey key = keys[startPtr];\n\t\t\tif(key == null) {\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tholes--;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Skipped hole\");\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(time > now) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"First key is later at time \"+time);\n\t\t\t\t\tif(!v.isEmpty())\n\t\t\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t\t\telse if(time < (now + dontCareAfterMillis)) \n\t\t\t\t\t\treturn Long.valueOf(time);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ttimes[startPtr] = 0;\n\t\t\t\tkeys[startPtr] = null;\n\t\t\t\tclients[startPtr] = null;\n\t\t\t\tstartPtr++;\n\t\t\t\tif(startPtr == times.length) startPtr = 0;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Returning key \"+key);\n\t\t\tv.add(key);\n\t\t\tif(v.size() == maxKeys) {\n\t\t\t\tif(!v.isEmpty())\n\t\t\t\t\treturn (Key[]) v.toArray(new Key[v.size()]);\n\t\t\t\telse return null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"2d42f59ed33cb46648cefbd880f099f2d7684f24","url":"https://github.com/freenet/fred"},{"original_method":"void realRun() {\n\t\tChosenBlock req = null;\n\t\tsentRequestTime = System.currentTimeMillis();\n\t\t// The last time at which we sent a request or decided not to\n\t\tlong cycleTime = sentRequestTime;\n\t\twhile(true) {\n\t\t\t// Allow 5 minutes before we start killing requests due to not connecting.\n\t\t\tOpennetManager om;\n\t\t\tif(core.node.peers.countConnectedPeers() < 3 && (om = core.node.getOpennet()) != null &&\n\t\t\t\t\tSystem.currentTimeMillis() - om.getCreationTime() < 5*60*1000) {\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\twait(1000);\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!isInsert)\n\t\t\t\tsched.moveKeysFromCooldownQueue();\n\t\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\tif(req == null) {\n\t\t\t\treq = sched.grabRequest();\n\t\t\t}\n\t\t\tif(req != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Running \"+req+\" priority \"+req.getPriority());\n\t\t\t\t// Wait\n\t\t\t\tlong delay = throttle.getDelay();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Delay=\"+delay+\" from \"+throttle);\n\t\t\t\tlong sleepUntil = cycleTime + delay;\n\t\t\t\tif(!LOCAL_REQUESTS_COMPETE_FAIRLY) {\n\t\t\t\t\tinputBucket.blockingGrab((int)(Math.max(0, averageInputBytesPerRequest.currentValue())));\n\t\t\t\t\toutputBucket.blockingGrab((int)(Math.max(0, averageOutputBytesPerRequest.currentValue())));\n\t\t\t\t}\n\t\t\t\tlong now;\n\t\t\t\tdo {\n\t\t\t\t\tnow = System.currentTimeMillis();\n\t\t\t\t\tif(now < sleepUntil)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(sleepUntil - now);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Slept: \"+(sleepUntil-now)+\"ms\");\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t} while(now < sleepUntil);\n\t\t\t\tString reason;\n\t\t\t\tif(LOCAL_REQUESTS_COMPETE_FAIRLY) {\n\t\t\t\t\tif((reason = stats.shouldRejectRequest(true, isInsert, isSSK, true, false, null)) != null) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Not sending local request: \"+reason);\n\t\t\t\t\t\t// Wait one throttle-delay before trying again\n\t\t\t\t\t\tcycleTime = System.currentTimeMillis();\n\t\t\t\t\t\tcontinue; // Let local requests compete with all the others\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstats.waitUntilNotOverloaded(isInsert);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Waiting...\");\t\t\t\t\n\t\t\t\t// Always take the lock on RequestStarter first. AFAICS we don't synchronize on RequestStarter anywhere else.\n\t\t\t\t// Nested locks here prevent extra latency when there is a race, and therefore allow us to sleep indefinitely\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\treq = sched.grabRequest();\n\t\t\t\t\tif(req == null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twait(100*1000); // as close to indefinite as I'm comfortable with! Toad\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(req == null) continue;\n\t\t\tif(!startRequest(req, logMINOR)) {\n\t\t\t\t// Don't log if it's a cancelled transient request.\n\t\t\t\tif(!((!req.isPersistent()) && req.isCancelled()))\n\t\t\t\t\tLogger.normal(this, \"No requests to start on \"+req);\n\t\t\t}\n\t\t\treq = null;\n\t\t\tcycleTime = sentRequestTime = System.currentTimeMillis();\n\t\t}\n\t}","id":47784,"modified_method":"void realRun() {\n\t\tChosenBlock req = null;\n\t\tsentRequestTime = System.currentTimeMillis();\n\t\t// The last time at which we sent a request or decided not to\n\t\tlong cycleTime = sentRequestTime;\n\t\twhile(true) {\n\t\t\t// Allow 5 minutes before we start killing requests due to not connecting.\n\t\t\tOpennetManager om;\n\t\t\tif(core.node.peers.countConnectedPeers() < 3 && (om = core.node.getOpennet()) != null &&\n\t\t\t\t\tSystem.currentTimeMillis() - om.getCreationTime() < 5*60*1000) {\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\twait(1000);\n\t\t\t\t\t}\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\tif(req == null) {\n\t\t\t\treq = sched.grabRequest();\n\t\t\t}\n\t\t\tif(req != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Running \"+req+\" priority \"+req.getPriority());\n\t\t\t\t// Wait\n\t\t\t\tlong delay = throttle.getDelay();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Delay=\"+delay+\" from \"+throttle);\n\t\t\t\tlong sleepUntil = cycleTime + delay;\n\t\t\t\tif(!LOCAL_REQUESTS_COMPETE_FAIRLY) {\n\t\t\t\t\tinputBucket.blockingGrab((int)(Math.max(0, averageInputBytesPerRequest.currentValue())));\n\t\t\t\t\toutputBucket.blockingGrab((int)(Math.max(0, averageOutputBytesPerRequest.currentValue())));\n\t\t\t\t}\n\t\t\t\tlong now;\n\t\t\t\tdo {\n\t\t\t\t\tnow = System.currentTimeMillis();\n\t\t\t\t\tif(now < sleepUntil)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(sleepUntil - now);\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Slept: \"+(sleepUntil-now)+\"ms\");\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t} while(now < sleepUntil);\n\t\t\t\tString reason;\n\t\t\t\tif(LOCAL_REQUESTS_COMPETE_FAIRLY) {\n\t\t\t\t\tif((reason = stats.shouldRejectRequest(true, isInsert, isSSK, true, false, null)) != null) {\n\t\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\t\tLogger.minor(this, \"Not sending local request: \"+reason);\n\t\t\t\t\t\t// Wait one throttle-delay before trying again\n\t\t\t\t\t\tcycleTime = System.currentTimeMillis();\n\t\t\t\t\t\tcontinue; // Let local requests compete with all the others\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstats.waitUntilNotOverloaded(isInsert);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Waiting...\");\t\t\t\t\n\t\t\t\t// Always take the lock on RequestStarter first. AFAICS we don't synchronize on RequestStarter anywhere else.\n\t\t\t\t// Nested locks here prevent extra latency when there is a race, and therefore allow us to sleep indefinitely\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\treq = sched.grabRequest();\n\t\t\t\t\tif(req == null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twait(100*1000); // as close to indefinite as I'm comfortable with! Toad\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(req == null) continue;\n\t\t\tif(!startRequest(req, logMINOR)) {\n\t\t\t\t// Don't log if it's a cancelled transient request.\n\t\t\t\tif(!((!req.isPersistent()) && req.isCancelled()))\n\t\t\t\t\tLogger.normal(this, \"No requests to start on \"+req);\n\t\t\t}\n\t\t\treq = null;\n\t\t\tcycleTime = sentRequestTime = System.currentTimeMillis();\n\t\t}\n\t}","commit_id":"2d42f59ed33cb46648cefbd880f099f2d7684f24","url":"https://github.com/freenet/fred"},{"original_method":"private void addPropertyBigInteger(\r\n        PropertiesImpl props,\r\n        String typeId,\r\n        Set<String> filter,\r\n        String id,\r\n        BigInteger value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyIntegerImpl(id, value));\r\n    }","id":47785,"modified_method":"/**\r\n     * Adds bigint property to a PropertiesImpl.<p>\r\n     *  \r\n     * @param props the properties \r\n     * @param typeId the type id \r\n     * @param filter the property filter string \r\n     * @param id the property id \r\n     * @param value the property value \r\n     */\r\n    private void addPropertyBigInteger(\r\n        PropertiesImpl props,\r\n        String typeId,\r\n        Set<String> filter,\r\n        String id,\r\n        BigInteger value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyIntegerImpl(id, value));\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.apache.chemistry.opencmis.commons.spi.ObjectService#deleteContentStream(java.lang.String, org.apache.chemistry.opencmis.commons.spi.Holder, org.apache.chemistry.opencmis.commons.spi.Holder, org.apache.chemistry.opencmis.commons.data.ExtensionsData)\r\n     */\r\n    public void deleteContentStream(\r\n        CallContext context,\r\n        Holder<String> objectId,\r\n        Holder<String> changeToken,\r\n        ExtensionsData extension) {\r\n\r\n        // TODO: Auto-generated method stub\r\n        throw new CmisNotSupportedException(\"Not supported!\");\r\n\r\n    }","id":47786,"modified_method":"/**\r\n     * @see org.apache.chemistry.opencmis.commons.spi.ObjectService#deleteContentStream(java.lang.String, org.apache.chemistry.opencmis.commons.spi.Holder, org.apache.chemistry.opencmis.commons.spi.Holder, org.apache.chemistry.opencmis.commons.data.ExtensionsData)\r\n     */\r\n    public void deleteContentStream(\r\n        CallContext context,\r\n        Holder<String> objectId,\r\n        Holder<String> changeToken,\r\n        ExtensionsData extension) {\r\n\r\n        throw new CmisConstraintException(\"Content streams may not be deleted.\");\r\n\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void addPropertyDateTime(\r\n        PropertiesImpl props,\r\n        String typeId,\r\n        Set<String> filter,\r\n        String id,\r\n        GregorianCalendar value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyDateTimeImpl(id, value));\r\n    }","id":47787,"modified_method":"/**\r\n     * Adds a date/time property to a PropertiesImpl.<p>\r\n     *  \r\n     * @param props the properties \r\n     * @param typeId the type id \r\n     * @param filter the property filter string \r\n     * @param id the property id \r\n     * @param value the property value \r\n     */\r\n    private void addPropertyDateTime(\r\n        PropertiesImpl props,\r\n        String typeId,\r\n        Set<String> filter,\r\n        String id,\r\n        GregorianCalendar value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyDateTimeImpl(id, value));\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Gathers all base properties of a file or folder.\r\n     */\r\n    private Properties compileProperties(\r\n        CallContext context,\r\n        CmsResource file,\r\n        Set<String> orgfilter,\r\n        ObjectInfoImpl objectInfo) {\r\n\r\n        if (file == null) {\r\n            throw new IllegalArgumentException(\"File must not be null!\");\r\n        }\r\n\r\n        // copy filter\r\n        Set<String> filter = (orgfilter == null ? null : new HashSet<String>(orgfilter));\r\n\r\n        // find base type\r\n        String typeId = null;\r\n\r\n        if (file.isFolder()) {\r\n            typeId = CmsCmisTypeManager.FOLDER_TYPE_ID;\r\n            objectInfo.setBaseType(BaseTypeId.CMIS_FOLDER);\r\n            objectInfo.setTypeId(typeId);\r\n            objectInfo.setContentType(null);\r\n            objectInfo.setFileName(null);\r\n            objectInfo.setHasAcl(true);\r\n            objectInfo.setHasContent(false);\r\n            objectInfo.setVersionSeriesId(null);\r\n            objectInfo.setIsCurrentVersion(true);\r\n            objectInfo.setRelationshipSourceIds(null);\r\n            objectInfo.setRelationshipTargetIds(null);\r\n            objectInfo.setRenditionInfos(null);\r\n            objectInfo.setSupportsDescendants(true);\r\n            objectInfo.setSupportsFolderTree(true);\r\n            objectInfo.setSupportsPolicies(false);\r\n            objectInfo.setSupportsRelationships(false);\r\n            objectInfo.setWorkingCopyId(null);\r\n            objectInfo.setWorkingCopyOriginalId(null);\r\n        } else {\r\n            typeId = CmsCmisTypeManager.DOCUMENT_TYPE_ID;\r\n            objectInfo.setBaseType(BaseTypeId.CMIS_DOCUMENT);\r\n            objectInfo.setTypeId(typeId);\r\n            objectInfo.setHasAcl(true);\r\n            objectInfo.setHasContent(true);\r\n            objectInfo.setHasParent(true);\r\n            objectInfo.setVersionSeriesId(null);\r\n            objectInfo.setIsCurrentVersion(true);\r\n            objectInfo.setRelationshipSourceIds(null);\r\n            objectInfo.setRelationshipTargetIds(null);\r\n            objectInfo.setRenditionInfos(null);\r\n            objectInfo.setSupportsDescendants(false);\r\n            objectInfo.setSupportsFolderTree(false);\r\n            objectInfo.setSupportsPolicies(false);\r\n            objectInfo.setSupportsRelationships(false);\r\n            objectInfo.setWorkingCopyId(null);\r\n            objectInfo.setWorkingCopyOriginalId(null);\r\n        }\r\n\r\n        // let's do it\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n            PropertiesImpl result = new PropertiesImpl();\r\n\r\n            // id\r\n            String id = file.getStructureId().toString();\r\n            addPropertyId(result, typeId, filter, PropertyIds.OBJECT_ID, id);\r\n            objectInfo.setId(id);\r\n\r\n            // name\r\n            String name = file.getName();\r\n            addPropertyString(result, typeId, filter, PropertyIds.NAME, name);\r\n            objectInfo.setName(name);\r\n\r\n            // created and modified by\r\n            addPropertyString(result, typeId, filter, PropertyIds.CREATED_BY, \"<unknown>\");\r\n            addPropertyString(result, typeId, filter, PropertyIds.LAST_MODIFIED_BY, \"<unknown>\");\r\n            objectInfo.setCreatedBy(\"<unknown>\");\r\n\r\n            // creation and modification date\r\n            GregorianCalendar lastModified = millisToCalendar(file.getDateLastModified());\r\n            addPropertyDateTime(result, typeId, filter, PropertyIds.CREATION_DATE, lastModified);\r\n            addPropertyDateTime(result, typeId, filter, PropertyIds.LAST_MODIFICATION_DATE, lastModified);\r\n            objectInfo.setCreationDate(lastModified);\r\n            objectInfo.setLastModificationDate(lastModified);\r\n\r\n            // change token - always null\r\n            addPropertyString(result, typeId, filter, PropertyIds.CHANGE_TOKEN, null);\r\n\r\n            // directory or file\r\n            if (file.isFolder()) {\r\n                // base type and type name\r\n                addPropertyId(result, typeId, filter, PropertyIds.BASE_TYPE_ID, BaseTypeId.CMIS_FOLDER.value());\r\n                addPropertyId(result, typeId, filter, PropertyIds.OBJECT_TYPE_ID, TypeManager.FOLDER_TYPE_ID);\r\n                String path = file.getRootPath();\r\n                addPropertyString(result, typeId, filter, PropertyIds.PATH, (path.length() == 0 ? \"/\" : path));\r\n\r\n                // folder properties\r\n                if (!m_root.equals(file)) {\r\n                    CmsResource parent = cms.readParentFolder(file.getStructureId());\r\n                    addPropertyId(result, typeId, filter, PropertyIds.PARENT_ID, (m_root.equals(parent)\r\n                    ? m_root.getStructureId().toString()\r\n                    : parent.getStructureId().toString()));\r\n                    objectInfo.setHasParent(true);\r\n                } else {\r\n                    addPropertyId(result, typeId, filter, PropertyIds.PARENT_ID, null);\r\n                    objectInfo.setHasParent(false);\r\n                }\r\n\r\n                addPropertyIdList(result, typeId, filter, PropertyIds.ALLOWED_CHILD_OBJECT_TYPE_IDS, null);\r\n            } else {\r\n                // base type and type name\r\n                addPropertyId(result, typeId, filter, PropertyIds.BASE_TYPE_ID, BaseTypeId.CMIS_DOCUMENT.value());\r\n                addPropertyId(result, typeId, filter, PropertyIds.OBJECT_TYPE_ID, TypeManager.DOCUMENT_TYPE_ID);\r\n\r\n                // file properties\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_IMMUTABLE, false);\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_LATEST_VERSION, true);\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_MAJOR_VERSION, true);\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_LATEST_MAJOR_VERSION, true);\r\n                addPropertyString(result, typeId, filter, PropertyIds.VERSION_LABEL, file.getName());\r\n                addPropertyId(result, typeId, filter, PropertyIds.VERSION_SERIES_ID, file.getStructureId().toString());\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_VERSION_SERIES_CHECKED_OUT, false);\r\n                addPropertyString(result, typeId, filter, PropertyIds.VERSION_SERIES_CHECKED_OUT_BY, null);\r\n                addPropertyString(result, typeId, filter, PropertyIds.VERSION_SERIES_CHECKED_OUT_ID, null);\r\n                addPropertyString(result, typeId, filter, PropertyIds.CHECKIN_COMMENT, \"\");\r\n\r\n                if (file.getLength() == 0) {\r\n                    addPropertyBigInteger(result, typeId, filter, PropertyIds.CONTENT_STREAM_LENGTH, null);\r\n                    addPropertyString(result, typeId, filter, PropertyIds.CONTENT_STREAM_MIME_TYPE, null);\r\n                    addPropertyString(result, typeId, filter, PropertyIds.CONTENT_STREAM_FILE_NAME, null);\r\n\r\n                    objectInfo.setHasContent(false);\r\n                    objectInfo.setContentType(null);\r\n                    objectInfo.setFileName(null);\r\n                } else {\r\n                    addPropertyInteger(result, typeId, filter, PropertyIds.CONTENT_STREAM_LENGTH, file.getLength());\r\n                    addPropertyString(\r\n                        result,\r\n                        typeId,\r\n                        filter,\r\n                        PropertyIds.CONTENT_STREAM_MIME_TYPE,\r\n                        OpenCms.getResourceManager().getMimeType(\r\n                            file.getRootPath(),\r\n                            null,\r\n                            CmsResourceManager.MIMETYPE_TEXT));\r\n                    addPropertyString(result, typeId, filter, PropertyIds.CONTENT_STREAM_FILE_NAME, file.getName());\r\n\r\n                    objectInfo.setHasContent(true);\r\n                    objectInfo.setContentType(OpenCms.getResourceManager().getMimeType(\r\n                        file.getRootPath(),\r\n                        null,\r\n                        CmsResourceManager.MIMETYPE_TEXT));\r\n                    objectInfo.setFileName(file.getName());\r\n                }\r\n\r\n                addPropertyId(result, typeId, filter, PropertyIds.CONTENT_STREAM_ID, null);\r\n            }\r\n\r\n            List<CmsProperty> props = cms.readPropertyObjects(file, true);\r\n            Set<String> propertiesToAdd = new HashSet<String>(m_typeManager.getCmsPropertyNames());\r\n            for (CmsProperty prop : props) {\r\n                addPropertyString(\r\n                    result,\r\n                    typeId,\r\n                    filter,\r\n                    CmsCmisTypeManager.PROPERTY_PREFIX + prop.getName(),\r\n                    prop.getValue());\r\n                propertiesToAdd.remove(prop.getName());\r\n            }\r\n            for (String propName : propertiesToAdd) {\r\n                addPropertyString(result, typeId, filter, CmsCmisTypeManager.PROPERTY_PREFIX + propName, null);\r\n            }\r\n            I_CmsResourceType resType = OpenCms.getResourceManager().getResourceType(file);\r\n            addPropertyString(result, typeId, filter, CmsCmisTypeManager.PROPERTY_RESOURCE_TYPE, resType.getTypeName());\r\n            return result;\r\n        } catch (Exception e) {\r\n            if (e instanceof CmisBaseException) {\r\n                throw (CmisBaseException)e;\r\n            }\r\n            throw new CmisRuntimeException(e.getMessage(), e);\r\n        }\r\n    }","id":47788,"modified_method":"/**\r\n     * Gathers all base properties of a file or folder.\r\n     */\r\n    private Properties compileProperties(\r\n        CallContext context,\r\n        CmsResource file,\r\n        Set<String> orgfilter,\r\n        ObjectInfoImpl objectInfo) {\r\n\r\n        if (file == null) {\r\n            throw new IllegalArgumentException(\"Resource may not be null.\");\r\n        }\r\n\r\n        // copy filter\r\n        Set<String> filter = (orgfilter == null ? null : new HashSet<String>(orgfilter));\r\n\r\n        // find base type\r\n        String typeId = null;\r\n\r\n        if (file.isFolder()) {\r\n            typeId = CmsCmisTypeManager.FOLDER_TYPE_ID;\r\n            objectInfo.setBaseType(BaseTypeId.CMIS_FOLDER);\r\n            objectInfo.setTypeId(typeId);\r\n            objectInfo.setContentType(null);\r\n            objectInfo.setFileName(null);\r\n            objectInfo.setHasAcl(false);\r\n            objectInfo.setHasContent(false);\r\n            objectInfo.setVersionSeriesId(null);\r\n            objectInfo.setIsCurrentVersion(true);\r\n            objectInfo.setRelationshipSourceIds(null);\r\n            objectInfo.setRelationshipTargetIds(null);\r\n            objectInfo.setRenditionInfos(null);\r\n            objectInfo.setSupportsDescendants(true);\r\n            objectInfo.setSupportsFolderTree(true);\r\n            objectInfo.setSupportsPolicies(false);\r\n            objectInfo.setSupportsRelationships(false);\r\n            objectInfo.setWorkingCopyId(null);\r\n            objectInfo.setWorkingCopyOriginalId(null);\r\n        } else {\r\n            typeId = CmsCmisTypeManager.DOCUMENT_TYPE_ID;\r\n            objectInfo.setBaseType(BaseTypeId.CMIS_DOCUMENT);\r\n            objectInfo.setTypeId(typeId);\r\n            objectInfo.setHasAcl(false);\r\n            objectInfo.setHasContent(true);\r\n            objectInfo.setHasParent(true);\r\n            objectInfo.setVersionSeriesId(null);\r\n            objectInfo.setIsCurrentVersion(true);\r\n            objectInfo.setRelationshipSourceIds(null);\r\n            objectInfo.setRelationshipTargetIds(null);\r\n            objectInfo.setRenditionInfos(null);\r\n            objectInfo.setSupportsDescendants(false);\r\n            objectInfo.setSupportsFolderTree(false);\r\n            objectInfo.setSupportsPolicies(false);\r\n            objectInfo.setSupportsRelationships(false);\r\n            objectInfo.setWorkingCopyId(null);\r\n            objectInfo.setWorkingCopyOriginalId(null);\r\n        }\r\n\r\n        // let's do it\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n            PropertiesImpl result = new PropertiesImpl();\r\n\r\n            // id\r\n            String id = file.getStructureId().toString();\r\n            addPropertyId(result, typeId, filter, PropertyIds.OBJECT_ID, id);\r\n            objectInfo.setId(id);\r\n\r\n            // name\r\n            String name = file.getName();\r\n            addPropertyString(result, typeId, filter, PropertyIds.NAME, name);\r\n            objectInfo.setName(name);\r\n\r\n            // created and modified by\r\n            CmsUUID creatorId = file.getUserCreated();\r\n            CmsUUID modifierId = file.getUserLastModified();\r\n            String creatorName = creatorId.toString();\r\n            String modifierName = modifierId.toString();\r\n            try {\r\n                CmsUser user = cms.readUser(creatorId);\r\n                creatorName = user.getName();\r\n            } catch (CmsException e) {\r\n                // ignore, use id as name \r\n            }\r\n            try {\r\n                CmsUser user = cms.readUser(modifierId);\r\n                modifierName = user.getName();\r\n            } catch (CmsException e) {\r\n                // ignore, use id as name\r\n            }\r\n\r\n            addPropertyString(result, typeId, filter, PropertyIds.CREATED_BY, creatorName);\r\n            addPropertyString(result, typeId, filter, PropertyIds.LAST_MODIFIED_BY, modifierName);\r\n            objectInfo.setCreatedBy(creatorName);\r\n\r\n            // creation and modification date\r\n            GregorianCalendar lastModified = millisToCalendar(file.getDateLastModified());\r\n            GregorianCalendar created = millisToCalendar(file.getDateCreated());\r\n\r\n            addPropertyDateTime(result, typeId, filter, PropertyIds.CREATION_DATE, created);\r\n            addPropertyDateTime(result, typeId, filter, PropertyIds.LAST_MODIFICATION_DATE, lastModified);\r\n            objectInfo.setCreationDate(created);\r\n            objectInfo.setLastModificationDate(lastModified);\r\n\r\n            // change token - always null\r\n            addPropertyString(result, typeId, filter, PropertyIds.CHANGE_TOKEN, null);\r\n\r\n            // directory or file\r\n            if (file.isFolder()) {\r\n                // base type and type name\r\n                addPropertyId(result, typeId, filter, PropertyIds.BASE_TYPE_ID, BaseTypeId.CMIS_FOLDER.value());\r\n                addPropertyId(result, typeId, filter, PropertyIds.OBJECT_TYPE_ID, TypeManager.FOLDER_TYPE_ID);\r\n                String path = file.getRootPath();\r\n                addPropertyString(result, typeId, filter, PropertyIds.PATH, (path.length() == 0 ? \"/\" : path));\r\n\r\n                // folder properties\r\n                if (!m_root.equals(file)) {\r\n                    CmsResource parent = cms.readParentFolder(file.getStructureId());\r\n                    addPropertyId(result, typeId, filter, PropertyIds.PARENT_ID, (m_root.equals(parent)\r\n                    ? m_root.getStructureId().toString()\r\n                    : parent.getStructureId().toString()));\r\n                    objectInfo.setHasParent(true);\r\n                } else {\r\n                    addPropertyId(result, typeId, filter, PropertyIds.PARENT_ID, null);\r\n                    objectInfo.setHasParent(false);\r\n                }\r\n\r\n                addPropertyIdList(result, typeId, filter, PropertyIds.ALLOWED_CHILD_OBJECT_TYPE_IDS, null);\r\n            } else {\r\n                // base type and type name\r\n                addPropertyId(result, typeId, filter, PropertyIds.BASE_TYPE_ID, BaseTypeId.CMIS_DOCUMENT.value());\r\n                addPropertyId(result, typeId, filter, PropertyIds.OBJECT_TYPE_ID, TypeManager.DOCUMENT_TYPE_ID);\r\n\r\n                // file properties\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_IMMUTABLE, false);\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_LATEST_VERSION, true);\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_MAJOR_VERSION, true);\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_LATEST_MAJOR_VERSION, true);\r\n                addPropertyString(result, typeId, filter, PropertyIds.VERSION_LABEL, file.getName());\r\n                addPropertyId(result, typeId, filter, PropertyIds.VERSION_SERIES_ID, file.getStructureId().toString());\r\n                addPropertyBoolean(result, typeId, filter, PropertyIds.IS_VERSION_SERIES_CHECKED_OUT, false);\r\n                addPropertyString(result, typeId, filter, PropertyIds.VERSION_SERIES_CHECKED_OUT_BY, null);\r\n                addPropertyString(result, typeId, filter, PropertyIds.VERSION_SERIES_CHECKED_OUT_ID, null);\r\n                addPropertyString(result, typeId, filter, PropertyIds.CHECKIN_COMMENT, \"\");\r\n\r\n                if (file.getLength() == 0) {\r\n                    addPropertyBigInteger(result, typeId, filter, PropertyIds.CONTENT_STREAM_LENGTH, null);\r\n                    addPropertyString(result, typeId, filter, PropertyIds.CONTENT_STREAM_MIME_TYPE, null);\r\n                    addPropertyString(result, typeId, filter, PropertyIds.CONTENT_STREAM_FILE_NAME, null);\r\n\r\n                    objectInfo.setHasContent(false);\r\n                    objectInfo.setContentType(null);\r\n                    objectInfo.setFileName(null);\r\n                } else {\r\n                    addPropertyInteger(result, typeId, filter, PropertyIds.CONTENT_STREAM_LENGTH, file.getLength());\r\n                    addPropertyString(\r\n                        result,\r\n                        typeId,\r\n                        filter,\r\n                        PropertyIds.CONTENT_STREAM_MIME_TYPE,\r\n                        OpenCms.getResourceManager().getMimeType(\r\n                            file.getRootPath(),\r\n                            null,\r\n                            CmsResourceManager.MIMETYPE_TEXT));\r\n                    addPropertyString(result, typeId, filter, PropertyIds.CONTENT_STREAM_FILE_NAME, file.getName());\r\n\r\n                    objectInfo.setHasContent(true);\r\n                    objectInfo.setContentType(OpenCms.getResourceManager().getMimeType(\r\n                        file.getRootPath(),\r\n                        null,\r\n                        CmsResourceManager.MIMETYPE_TEXT));\r\n                    objectInfo.setFileName(file.getName());\r\n                }\r\n\r\n                addPropertyId(result, typeId, filter, PropertyIds.CONTENT_STREAM_ID, null);\r\n            }\r\n\r\n            List<CmsProperty> props = cms.readPropertyObjects(file, true);\r\n            Set<String> propertiesToAdd = new HashSet<String>(m_typeManager.getCmsPropertyNames());\r\n            for (CmsProperty prop : props) {\r\n                addPropertyString(\r\n                    result,\r\n                    typeId,\r\n                    filter,\r\n                    CmsCmisTypeManager.PROPERTY_PREFIX + prop.getName(),\r\n                    prop.getValue());\r\n                propertiesToAdd.remove(prop.getName());\r\n            }\r\n            for (String propName : propertiesToAdd) {\r\n                addPropertyString(result, typeId, filter, CmsCmisTypeManager.PROPERTY_PREFIX + propName, null);\r\n            }\r\n            I_CmsResourceType resType = OpenCms.getResourceManager().getResourceType(file);\r\n            addPropertyString(result, typeId, filter, CmsCmisTypeManager.PROPERTY_RESOURCE_TYPE, resType.getTypeName());\r\n            return result;\r\n        } catch (Exception e) {\r\n            if (e instanceof CmisBaseException) {\r\n                throw (CmisBaseException)e;\r\n            }\r\n            throw new CmisRuntimeException(e.getMessage(), e);\r\n        }\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private boolean checkAddProperty(Properties properties, String typeId, Set<String> filter, String id) {\r\n\r\n        if ((properties == null) || (properties.getProperties() == null)) {\r\n            throw new IllegalArgumentException(\"Properties must not be null!\");\r\n        }\r\n\r\n        if (id == null) {\r\n            throw new IllegalArgumentException(\"Id must not be null!\");\r\n        }\r\n\r\n        TypeDefinition type = m_typeManager.getType(typeId);\r\n        if (type == null) {\r\n            throw new IllegalArgumentException(\"Unknown type: \" + typeId);\r\n        }\r\n        if (!type.getPropertyDefinitions().containsKey(id)) {\r\n            throw new IllegalArgumentException(\"Unknown property: \" + id);\r\n        }\r\n\r\n        String queryName = type.getPropertyDefinitions().get(id).getQueryName();\r\n\r\n        if ((queryName != null) && (filter != null)) {\r\n            if (!filter.contains(queryName)) {\r\n                return false;\r\n            } else {\r\n                filter.remove(queryName);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }","id":47789,"modified_method":"/**\r\n     * Checks whether a property can be added to a Properties.\r\n     *  \r\n     * @param properties the properties object\r\n     * @param typeId the type id \r\n     * @param filter the property filter\r\n     * @param id the property id\r\n     *  \r\n     * @return true if the property should be added \r\n     */\r\n    private boolean checkAddProperty(Properties properties, String typeId, Set<String> filter, String id) {\r\n\r\n        if ((properties == null) || (properties.getProperties() == null)) {\r\n            throw new IllegalArgumentException(\"Properties must not be null!\");\r\n        }\r\n\r\n        if (id == null) {\r\n            throw new IllegalArgumentException(\"Id must not be null!\");\r\n        }\r\n\r\n        TypeDefinition type = m_typeManager.getType(typeId);\r\n        if (type == null) {\r\n            throw new IllegalArgumentException(\"Unknown type: \" + typeId);\r\n        }\r\n        if (!type.getPropertyDefinitions().containsKey(id)) {\r\n            throw new IllegalArgumentException(\"Unknown property: \" + id);\r\n        }\r\n\r\n        String queryName = type.getPropertyDefinitions().get(id).getQueryName();\r\n\r\n        if ((queryName != null) && (filter != null)) {\r\n            if (!filter.contains(queryName)) {\r\n                return false;\r\n            } else {\r\n                filter.remove(queryName);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected void handleCmsException(CmsException e) {\r\n\r\n        if (e instanceof CmsVfsResourceNotFoundException) {\r\n            throw new CmisObjectNotFoundException(e.getLocalizedMessage(), e);\r\n        } else if (e instanceof CmsSecurityException) {\r\n            throw new CmisUnauthorizedException(e.getLocalizedMessage(), e);\r\n        } else {\r\n            throw new CmisRuntimeException(e.getLocalizedMessage(), e);\r\n        }\r\n    }","id":47790,"modified_method":"/**\r\n     * Wrap OpenCms into OpenCMIS exceptions and rethrow them.<p>\r\n     * \r\n     * @param e the exception to handle\r\n     */\r\n    protected void handleCmsException(CmsException e) {\r\n\r\n        if (e instanceof CmsVfsResourceNotFoundException) {\r\n            throw new CmisObjectNotFoundException(e.getLocalizedMessage(), e);\r\n        } else if (e instanceof CmsSecurityException) {\r\n            throw new CmisUnauthorizedException(e.getLocalizedMessage(), e);\r\n        } else {\r\n            throw new CmisRuntimeException(e.getLocalizedMessage(), e);\r\n        }\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void addPropertyString(PropertiesImpl props, String typeId, Set<String> filter, String id, String value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyStringImpl(id, value));\r\n    }","id":47791,"modified_method":"/**\r\n     * Adds a string property to a PropertiesImpl.<p>\r\n     *  \r\n     * @param props the properties \r\n     * @param typeId the type id \r\n     * @param filter the property filter string \r\n     * @param id the property id \r\n     * @param value the property value \r\n     */\r\n    private void addPropertyString(PropertiesImpl props, String typeId, Set<String> filter, String id, String value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyStringImpl(id, value));\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void addPropertyInteger(PropertiesImpl props, String typeId, Set<String> filter, String id, long value) {\r\n\r\n        addPropertyBigInteger(props, typeId, filter, id, BigInteger.valueOf(value));\r\n    }","id":47792,"modified_method":"/**\r\n     * Adds an integer property to a PropertiesImpl.<p>\r\n     *  \r\n     * @param props the properties \r\n     * @param typeId the type id \r\n     * @param filter the property filter string \r\n     * @param id the property id \r\n     * @param value the property value \r\n     */\r\n    private void addPropertyInteger(PropertiesImpl props, String typeId, Set<String> filter, String id, long value) {\r\n\r\n        addPropertyBigInteger(props, typeId, filter, id, BigInteger.valueOf(value));\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Adds the default value of property if defined.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    private static boolean addPropertyDefault(PropertiesImpl props, PropertyDefinition<?> propDef) {\r\n\r\n        if ((props == null) || (props.getProperties() == null)) {\r\n            throw new IllegalArgumentException(\"Props must not be null!\");\r\n        }\r\n\r\n        if (propDef == null) {\r\n            return false;\r\n        }\r\n\r\n        List<?> defaultValue = propDef.getDefaultValue();\r\n        if ((defaultValue != null) && (!defaultValue.isEmpty())) {\r\n            switch (propDef.getPropertyType()) {\r\n                case BOOLEAN:\r\n                    props.addProperty(new PropertyBooleanImpl(propDef.getId(), (List<Boolean>)defaultValue));\r\n                    break;\r\n                case DATETIME:\r\n                    props.addProperty(new PropertyDateTimeImpl(propDef.getId(), (List<GregorianCalendar>)defaultValue));\r\n                    break;\r\n                case DECIMAL:\r\n                    props.addProperty(new PropertyDecimalImpl(propDef.getId(), (List<BigDecimal>)defaultValue));\r\n                    break;\r\n                case HTML:\r\n                    props.addProperty(new PropertyHtmlImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                case ID:\r\n                    props.addProperty(new PropertyIdImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                case INTEGER:\r\n                    props.addProperty(new PropertyIntegerImpl(propDef.getId(), (List<BigInteger>)defaultValue));\r\n                    break;\r\n                case STRING:\r\n                    props.addProperty(new PropertyStringImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                case URI:\r\n                    props.addProperty(new PropertyUriImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                default:\r\n                    throw new RuntimeException(\"Unknown datatype! Spec change?\");\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }","id":47793,"modified_method":"/**\r\n     * Adds the default value of property if defined.\r\n     *  \r\n     * @param props the Properties object\r\n     * @param propDef the property definition\r\n     *  \r\n     * @return\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    private static boolean addPropertyDefault(PropertiesImpl props, PropertyDefinition<?> propDef) {\r\n\r\n        if ((props == null) || (props.getProperties() == null)) {\r\n            throw new IllegalArgumentException(\"Props must not be null!\");\r\n        }\r\n\r\n        if (propDef == null) {\r\n            return false;\r\n        }\r\n\r\n        List<?> defaultValue = propDef.getDefaultValue();\r\n        if ((defaultValue != null) && (!defaultValue.isEmpty())) {\r\n            switch (propDef.getPropertyType()) {\r\n                case BOOLEAN:\r\n                    props.addProperty(new PropertyBooleanImpl(propDef.getId(), (List<Boolean>)defaultValue));\r\n                    break;\r\n                case DATETIME:\r\n                    props.addProperty(new PropertyDateTimeImpl(propDef.getId(), (List<GregorianCalendar>)defaultValue));\r\n                    break;\r\n                case DECIMAL:\r\n                    props.addProperty(new PropertyDecimalImpl(propDef.getId(), (List<BigDecimal>)defaultValue));\r\n                    break;\r\n                case HTML:\r\n                    props.addProperty(new PropertyHtmlImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                case ID:\r\n                    props.addProperty(new PropertyIdImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                case INTEGER:\r\n                    props.addProperty(new PropertyIntegerImpl(propDef.getId(), (List<BigInteger>)defaultValue));\r\n                    break;\r\n                case STRING:\r\n                    props.addProperty(new PropertyStringImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                case URI:\r\n                    props.addProperty(new PropertyUriImpl(propDef.getId(), (List<String>)defaultValue));\r\n                    break;\r\n                default:\r\n                    throw new RuntimeException(\"Unknown datatype! Spec change?\");\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Compiles the allowable actions for a file or folder.\r\n     */\r\n    private AllowableActions compileAllowableActions(CallContext context, CmsResource file) {\r\n\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n\r\n            if (file == null) {\r\n                throw new IllegalArgumentException(\"File must not be null!\");\r\n            }\r\n            boolean isReadOnly = !(cms.hasPermissions(file, CmsPermissionSet.ACCESS_WRITE));\r\n            boolean isFolder = file.isFolder();\r\n            boolean isRoot = m_root.equals(file);\r\n\r\n            Set<Action> aas = new HashSet<Action>();\r\n\r\n            addAction(aas, Action.CAN_GET_OBJECT_PARENTS, !isRoot);\r\n            addAction(aas, Action.CAN_GET_PROPERTIES, true);\r\n            addAction(aas, Action.CAN_UPDATE_PROPERTIES, !isReadOnly);\r\n            addAction(aas, Action.CAN_MOVE_OBJECT, !isReadOnly);\r\n            addAction(aas, Action.CAN_DELETE_OBJECT, !isReadOnly && !isRoot);\r\n            addAction(aas, Action.CAN_GET_ACL, true);\r\n\r\n            if (isFolder) {\r\n                addAction(aas, Action.CAN_GET_DESCENDANTS, true);\r\n                addAction(aas, Action.CAN_GET_CHILDREN, true);\r\n                addAction(aas, Action.CAN_GET_FOLDER_PARENT, !isRoot);\r\n                addAction(aas, Action.CAN_GET_FOLDER_TREE, true);\r\n                addAction(aas, Action.CAN_CREATE_DOCUMENT, !isReadOnly);\r\n                addAction(aas, Action.CAN_CREATE_FOLDER, !isReadOnly);\r\n                addAction(aas, Action.CAN_DELETE_TREE, !isReadOnly);\r\n            } else {\r\n                addAction(aas, Action.CAN_GET_CONTENT_STREAM, true);\r\n                addAction(aas, Action.CAN_SET_CONTENT_STREAM, !isReadOnly);\r\n                addAction(aas, Action.CAN_DELETE_CONTENT_STREAM, !isReadOnly);\r\n                addAction(aas, Action.CAN_GET_ALL_VERSIONS, true);\r\n            }\r\n\r\n            AllowableActionsImpl result = new AllowableActionsImpl();\r\n            result.setAllowableActions(aas);\r\n\r\n            return result;\r\n        } catch (CmsException e) {\r\n            handleCmsException(e);\r\n            return null;\r\n        }\r\n    }","id":47794,"modified_method":"/**\r\n     * Compiles the allowable actions for a file or folder.\r\n     */\r\n    private AllowableActions compileAllowableActions(CallContext context, CmsResource file) {\r\n\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n\r\n            if (file == null) {\r\n                throw new IllegalArgumentException(\"File must not be null!\");\r\n            }\r\n            CmsLock lock = cms.getLock(file);\r\n            CmsUser user = cms.getRequestContext().getCurrentUser();\r\n            boolean canWrite = !cms.getRequestContext().getCurrentProject().isOnlineProject()\r\n                && (lock.isOwnedBy(user) || lock.isLockableBy(user))\r\n                && cms.hasPermissions(file, CmsPermissionSet.ACCESS_WRITE, false, CmsResourceFilter.DEFAULT);\r\n            boolean isReadOnly = !canWrite;\r\n            boolean isFolder = file.isFolder();\r\n            boolean isRoot = m_root.equals(file);\r\n\r\n            Set<Action> aas = new HashSet<Action>();\r\n\r\n            addAction(aas, Action.CAN_GET_OBJECT_PARENTS, !isRoot);\r\n            addAction(aas, Action.CAN_GET_PROPERTIES, true);\r\n            addAction(aas, Action.CAN_UPDATE_PROPERTIES, !isReadOnly);\r\n            addAction(aas, Action.CAN_MOVE_OBJECT, !isReadOnly);\r\n            addAction(aas, Action.CAN_DELETE_OBJECT, !isReadOnly && !isRoot);\r\n            addAction(aas, Action.CAN_GET_ACL, true);\r\n\r\n            if (isFolder) {\r\n                addAction(aas, Action.CAN_GET_DESCENDANTS, true);\r\n                addAction(aas, Action.CAN_GET_CHILDREN, true);\r\n                addAction(aas, Action.CAN_GET_FOLDER_PARENT, !isRoot);\r\n                addAction(aas, Action.CAN_GET_FOLDER_TREE, true);\r\n                addAction(aas, Action.CAN_CREATE_DOCUMENT, !isReadOnly);\r\n                addAction(aas, Action.CAN_CREATE_FOLDER, !isReadOnly);\r\n                addAction(aas, Action.CAN_DELETE_TREE, !isReadOnly);\r\n            } else {\r\n                addAction(aas, Action.CAN_GET_CONTENT_STREAM, true);\r\n                addAction(aas, Action.CAN_SET_CONTENT_STREAM, !isReadOnly);\r\n                addAction(aas, Action.CAN_GET_ALL_VERSIONS, true);\r\n            }\r\n\r\n            AllowableActionsImpl result = new AllowableActionsImpl();\r\n            result.setAllowableActions(aas);\r\n\r\n            return result;\r\n        } catch (CmsException e) {\r\n            handleCmsException(e);\r\n            return null;\r\n        }\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.apache.chemistry.opencmis.commons.spi.ObjectService#setContentStream(java.lang.String, org.apache.chemistry.opencmis.commons.spi.Holder, java.lang.Boolean, org.apache.chemistry.opencmis.commons.spi.Holder, org.apache.chemistry.opencmis.commons.data.ContentStream, org.apache.chemistry.opencmis.commons.data.ExtensionsData)\r\n     */\r\n    public void setContentStream(\r\n        CallContext context,\r\n        Holder<String> objectId,\r\n        Boolean overwriteFlag,\r\n        Holder<String> changeToken,\r\n        ContentStream contentStream,\r\n        ExtensionsData extension) {\r\n\r\n        // TODO: Auto-generated method stub\r\n        throw new CmisNotSupportedException(\"Not supported!\");\r\n\r\n    }","id":47795,"modified_method":"/**\r\n     * @see org.apache.chemistry.opencmis.commons.spi.ObjectService#setContentStream(java.lang.String, org.apache.chemistry.opencmis.commons.spi.Holder, java.lang.Boolean, org.apache.chemistry.opencmis.commons.spi.Holder, org.apache.chemistry.opencmis.commons.data.ContentStream, org.apache.chemistry.opencmis.commons.data.ExtensionsData)\r\n     */\r\n    public void setContentStream(\r\n        CallContext context,\r\n        Holder<String> objectId,\r\n        Boolean overwriteFlag,\r\n        Holder<String> changeToken,\r\n        ContentStream contentStream,\r\n        ExtensionsData extension) {\r\n\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n            CmsUUID structureId = new CmsUUID(objectId.getValue());\r\n            boolean overwrite = (overwriteFlag == null) || overwriteFlag.booleanValue();\r\n            if (!overwrite) {\r\n                throw new CmisContentAlreadyExistsException();\r\n            }\r\n            CmsResource resource = cms.readResource(structureId);\r\n            if (resource.isFolder()) {\r\n                throw new CmisStreamNotSupportedException(\"Folders may not have content streams.\");\r\n            }\r\n            CmsFile file = cms.readFile(resource);\r\n            InputStream contentInput = contentStream.getStream();\r\n            byte[] newContent = CmsFileUtil.readFully(contentInput);\r\n            file.setContents(newContent);\r\n            boolean wasLocked = ensureLock(cms, resource);\r\n            CmsFile newFile = cms.writeFile(file);\r\n            if (wasLocked) {\r\n                cms.unlockResource(newFile);\r\n            }\r\n        } catch (CmsException e) {\r\n            handleCmsException(e);\r\n        } catch (IOException e) {\r\n            throw new CmisRuntimeException(e.getLocalizedMessage(), e);\r\n        }\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Gather the children of a folder.\r\n     */\r\n    private void gatherDescendants(\r\n        CallContext context,\r\n        CmsResource folder,\r\n        List<ObjectInFolderContainer> list,\r\n        boolean foldersOnly,\r\n        int depth,\r\n        Set<String> filter,\r\n        boolean includeAllowableActions,\r\n        boolean includePathSegments,\r\n        ObjectInfoHandler objectInfos) {\r\n\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n            List<CmsResource> children = getChildren(cms, folder);\r\n            // iterate through children\r\n            for (CmsResource child : children) {\r\n\r\n                // folders only?\r\n                if (foldersOnly && !child.isFolder()) {\r\n                    continue;\r\n                }\r\n\r\n                // add to list\r\n                ObjectInFolderDataImpl objectInFolder = new ObjectInFolderDataImpl();\r\n                objectInFolder.setObject(compileObjectType(\r\n                    context,\r\n                    child,\r\n                    filter,\r\n                    includeAllowableActions,\r\n                    false,\r\n                    objectInfos));\r\n                if (includePathSegments) {\r\n                    objectInFolder.setPathSegment(child.getName());\r\n                }\r\n\r\n                ObjectInFolderContainerImpl container = new ObjectInFolderContainerImpl();\r\n                container.setObject(objectInFolder);\r\n\r\n                list.add(container);\r\n\r\n                // move to next level\r\n                if ((depth != 1) && child.isFolder()) {\r\n                    container.setChildren(new ArrayList<ObjectInFolderContainer>());\r\n                    gatherDescendants(\r\n                        context,\r\n                        child,\r\n                        container.getChildren(),\r\n                        foldersOnly,\r\n                        depth - 1,\r\n                        filter,\r\n                        includeAllowableActions,\r\n                        includePathSegments,\r\n                        objectInfos);\r\n                }\r\n            }\r\n        } catch (CmsException e) {\r\n            handleCmsException(e);\r\n        }\r\n    }","id":47796,"modified_method":"/**\r\n     * Gather the children of a folder.\r\n     */\r\n    private void gatherDescendants(\r\n        CallContext context,\r\n        CmsResource folder,\r\n        List<ObjectInFolderContainer> list,\r\n        boolean foldersOnly,\r\n        int depth,\r\n        Set<String> filter,\r\n        boolean includeAllowableActions,\r\n        boolean includePathSegments,\r\n        ObjectInfoHandler objectInfos) {\r\n\r\n        try {\r\n            CmsObject cms = getCmsObject(context);\r\n            List<CmsResource> children = getChildren(cms, folder);\r\n            Collections.sort(children, new Comparator<CmsResource>() {\r\n\r\n                public int compare(CmsResource a, CmsResource b) {\r\n\r\n                    return a.getName().compareTo(b.getName());\r\n                }\r\n            });\r\n            // iterate through children\r\n            for (CmsResource child : children) {\r\n\r\n                // folders only?\r\n                if (foldersOnly && !child.isFolder()) {\r\n                    continue;\r\n                }\r\n\r\n                // add to list\r\n                ObjectInFolderDataImpl objectInFolder = new ObjectInFolderDataImpl();\r\n                objectInFolder.setObject(compileObjectType(\r\n                    context,\r\n                    child,\r\n                    filter,\r\n                    includeAllowableActions,\r\n                    false,\r\n                    objectInfos));\r\n                if (includePathSegments) {\r\n                    objectInFolder.setPathSegment(child.getName());\r\n                }\r\n\r\n                ObjectInFolderContainerImpl container = new ObjectInFolderContainerImpl();\r\n                container.setObject(objectInFolder);\r\n\r\n                list.add(container);\r\n\r\n                // move to next level\r\n                if ((depth != 1) && child.isFolder()) {\r\n                    container.setChildren(new ArrayList<ObjectInFolderContainer>());\r\n                    gatherDescendants(\r\n                        context,\r\n                        child,\r\n                        container.getChildren(),\r\n                        foldersOnly,\r\n                        depth - 1,\r\n                        filter,\r\n                        includeAllowableActions,\r\n                        includePathSegments,\r\n                        objectInfos);\r\n                }\r\n            }\r\n        } catch (CmsException e) {\r\n            handleCmsException(e);\r\n        }\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void addPropertyBoolean(PropertiesImpl props, String typeId, Set<String> filter, String id, boolean value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyBooleanImpl(id, value));\r\n    }","id":47797,"modified_method":"/**\r\n     * Adds a boolean property to a PropertiesImpl.<p>\r\n     *  \r\n     * @param props the properties \r\n     * @param typeId the type id \r\n     * @param filter the property filter string \r\n     * @param id the property id \r\n     * @param value the property value \r\n     */\r\n    private void addPropertyBoolean(PropertiesImpl props, String typeId, Set<String> filter, String id, boolean value) {\r\n\r\n        if (!checkAddProperty(props, typeId, filter, id)) {\r\n            return;\r\n        }\r\n\r\n        props.addProperty(new PropertyBooleanImpl(id, value));\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.apache.chemistry.opencmis.commons.spi.RepositoryService#getRepositoryInfo(java.lang.String, org.apache.chemistry.opencmis.commons.data.ExtensionsData)\r\n     */\r\n    public RepositoryInfo getRepositoryInfo(ExtensionsData extension) {\r\n\r\n        // compile repository info\r\n        RepositoryInfoImpl repositoryInfo = new RepositoryInfoImpl();\r\n\r\n        repositoryInfo.setId(m_id);\r\n        repositoryInfo.setName(m_id);\r\n        repositoryInfo.setDescription(m_id);\r\n\r\n        repositoryInfo.setCmisVersionSupported(\"1.0\");\r\n\r\n        repositoryInfo.setProductName(\"OpenCms CMIS service\");\r\n        repositoryInfo.setProductVersion(\"0.1\");\r\n        repositoryInfo.setVendorName(\"Alkacon Software GmbH\");\r\n\r\n        repositoryInfo.setRootFolder(m_root.getStructureId().toString());\r\n\r\n        repositoryInfo.setThinClientUri(\"\");\r\n\r\n        RepositoryCapabilitiesImpl capabilities = new RepositoryCapabilitiesImpl();\r\n        capabilities.setCapabilityAcl(CapabilityAcl.DISCOVER);\r\n        capabilities.setAllVersionsSearchable(false);\r\n        capabilities.setCapabilityJoin(CapabilityJoin.NONE);\r\n        capabilities.setSupportsMultifiling(false);\r\n        capabilities.setSupportsUnfiling(false);\r\n        capabilities.setSupportsVersionSpecificFiling(false);\r\n        capabilities.setIsPwcSearchable(false);\r\n        capabilities.setIsPwcUpdatable(false);\r\n        capabilities.setCapabilityQuery(CapabilityQuery.NONE);\r\n        capabilities.setCapabilityChanges(CapabilityChanges.NONE);\r\n        //capabilities.setCapabilityContentStreamUpdates(CapabilityContentStreamUpdates.ANYTIME);\r\n        capabilities.setCapabilityContentStreamUpdates(CapabilityContentStreamUpdates.NONE);\r\n\r\n        capabilities.setSupportsGetDescendants(true);\r\n        capabilities.setSupportsGetFolderTree(true);\r\n        capabilities.setCapabilityRendition(CapabilityRenditions.NONE);\r\n\r\n        repositoryInfo.setCapabilities(capabilities);\r\n\r\n        AclCapabilitiesDataImpl aclCapability = new AclCapabilitiesDataImpl();\r\n        aclCapability.setSupportedPermissions(SupportedPermissions.BASIC);\r\n        aclCapability.setAclPropagation(AclPropagation.OBJECTONLY);\r\n\r\n        // permissions\r\n        List<PermissionDefinition> permissions = new ArrayList<PermissionDefinition>();\r\n        permissions.add(createPermission(CMIS_READ, \"Read\"));\r\n        permissions.add(createPermission(CMIS_WRITE, \"Write\"));\r\n        permissions.add(createPermission(CMIS_ALL, \"All\"));\r\n        aclCapability.setPermissionDefinitionData(permissions);\r\n\r\n        // mapping\r\n        List<PermissionMapping> list = new ArrayList<PermissionMapping>();\r\n        list.add(createMapping(PermissionMapping.CAN_CREATE_DOCUMENT_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_CREATE_FOLDER_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_DELETE_CONTENT_DOCUMENT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_DELETE_OBJECT, CMIS_ALL));\r\n        list.add(createMapping(PermissionMapping.CAN_DELETE_TREE_FOLDER, CMIS_ALL));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_ACL_OBJECT, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_ALL_VERSIONS_VERSION_SERIES, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_CHILDREN_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_DESCENDENTS_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_FOLDER_PARENT_OBJECT, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_PARENTS_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_PROPERTIES_OBJECT, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_MOVE_OBJECT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_MOVE_SOURCE, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_MOVE_TARGET, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_SET_CONTENT_DOCUMENT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_UPDATE_PROPERTIES_OBJECT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_VIEW_CONTENT_OBJECT, CMIS_READ));\r\n        Map<String, PermissionMapping> map = new LinkedHashMap<String, PermissionMapping>();\r\n        for (PermissionMapping pm : list) {\r\n            map.put(pm.getKey(), pm);\r\n        }\r\n        aclCapability.setPermissionMappingData(map);\r\n\r\n        repositoryInfo.setAclCapabilities(aclCapability);\r\n        return repositoryInfo;\r\n    }","id":47798,"modified_method":"/**\r\n     * @see org.apache.chemistry.opencmis.commons.spi.RepositoryService#getRepositoryInfo(java.lang.String, org.apache.chemistry.opencmis.commons.data.ExtensionsData)\r\n     */\r\n    public RepositoryInfo getRepositoryInfo(ExtensionsData extension) {\r\n\r\n        // compile repository info\r\n        RepositoryInfoImpl repositoryInfo = new RepositoryInfoImpl();\r\n\r\n        repositoryInfo.setId(m_id);\r\n        repositoryInfo.setName(m_id);\r\n        repositoryInfo.setDescription(m_id);\r\n\r\n        repositoryInfo.setCmisVersionSupported(\"1.0\");\r\n\r\n        repositoryInfo.setProductName(\"OpenCms\");\r\n        repositoryInfo.setProductVersion(OpenCms.getSystemInfo().getVersion());\r\n        repositoryInfo.setVendorName(\"Alkacon Software GmbH\");\r\n\r\n        repositoryInfo.setRootFolder(m_root.getStructureId().toString());\r\n\r\n        repositoryInfo.setThinClientUri(\"\");\r\n\r\n        RepositoryCapabilitiesImpl capabilities = new RepositoryCapabilitiesImpl();\r\n        capabilities.setCapabilityAcl(CapabilityAcl.NONE);\r\n        capabilities.setAllVersionsSearchable(Boolean.FALSE);\r\n        capabilities.setCapabilityJoin(CapabilityJoin.NONE);\r\n        capabilities.setSupportsMultifiling(Boolean.FALSE);\r\n        capabilities.setSupportsUnfiling(Boolean.FALSE);\r\n        capabilities.setSupportsVersionSpecificFiling(Boolean.FALSE);\r\n        capabilities.setIsPwcSearchable(Boolean.FALSE);\r\n        capabilities.setIsPwcUpdatable(Boolean.FALSE);\r\n        capabilities.setCapabilityQuery(CapabilityQuery.NONE);\r\n        capabilities.setCapabilityChanges(CapabilityChanges.NONE);\r\n        //capabilities.setCapabilityContentStreamUpdates(CapabilityContentStreamUpdates.ANYTIME);\r\n        capabilities.setCapabilityContentStreamUpdates(CapabilityContentStreamUpdates.ANYTIME);\r\n\r\n        capabilities.setSupportsGetDescendants(Boolean.TRUE);\r\n        capabilities.setSupportsGetFolderTree(Boolean.TRUE);\r\n        capabilities.setCapabilityRendition(CapabilityRenditions.NONE);\r\n\r\n        repositoryInfo.setCapabilities(capabilities);\r\n\r\n        AclCapabilitiesDataImpl aclCapability = new AclCapabilitiesDataImpl();\r\n        aclCapability.setSupportedPermissions(SupportedPermissions.BASIC);\r\n        aclCapability.setAclPropagation(AclPropagation.OBJECTONLY);\r\n\r\n        // permissions\r\n        List<PermissionDefinition> permissions = new ArrayList<PermissionDefinition>();\r\n        permissions.add(createPermission(CMIS_READ, \"Read\"));\r\n        permissions.add(createPermission(CMIS_WRITE, \"Write\"));\r\n        permissions.add(createPermission(CMIS_ALL, \"All\"));\r\n        aclCapability.setPermissionDefinitionData(permissions);\r\n\r\n        // mapping\r\n        List<PermissionMapping> list = new ArrayList<PermissionMapping>();\r\n        list.add(createMapping(PermissionMapping.CAN_CREATE_DOCUMENT_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_CREATE_FOLDER_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_DELETE_CONTENT_DOCUMENT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_DELETE_OBJECT, CMIS_ALL));\r\n        list.add(createMapping(PermissionMapping.CAN_DELETE_TREE_FOLDER, CMIS_ALL));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_ACL_OBJECT, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_ALL_VERSIONS_VERSION_SERIES, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_CHILDREN_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_DESCENDENTS_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_FOLDER_PARENT_OBJECT, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_PARENTS_FOLDER, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_GET_PROPERTIES_OBJECT, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_MOVE_OBJECT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_MOVE_SOURCE, CMIS_READ));\r\n        list.add(createMapping(PermissionMapping.CAN_MOVE_TARGET, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_SET_CONTENT_DOCUMENT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_UPDATE_PROPERTIES_OBJECT, CMIS_WRITE));\r\n        list.add(createMapping(PermissionMapping.CAN_VIEW_CONTENT_OBJECT, CMIS_READ));\r\n        Map<String, PermissionMapping> map = new LinkedHashMap<String, PermissionMapping>();\r\n        for (PermissionMapping pm : list) {\r\n            map.put(pm.getKey(), pm);\r\n        }\r\n        aclCapability.setPermissionMappingData(map);\r\n\r\n        //repositoryInfo.setAclCapabilities(aclCapability);\r\n        return repositoryInfo;\r\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private static void addBasePropertyDefinitions(AbstractTypeDefinition type) {\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.BASE_TYPE_ID,\n            \"Base Type Id\",\n            \"Base Type Id\",\n            PropertyType.ID,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.OBJECT_ID,\n            \"Object Id\",\n            \"Object Id\",\n            PropertyType.ID,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.OBJECT_TYPE_ID,\n            \"Type Id\",\n            \"Type Id\",\n            PropertyType.ID,\n            Cardinality.SINGLE,\n            Updatability.ONCREATE,\n            false,\n            true));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.NAME,\n            \"Name\",\n            \"Name\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READWRITE,\n            false,\n            true));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.CREATED_BY,\n            \"Created By\",\n            \"Created By\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.CREATION_DATE,\n            \"Creation Date\",\n            \"Creation Date\",\n            PropertyType.DATETIME,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.LAST_MODIFIED_BY,\n            \"Last Modified By\",\n            \"Last Modified By\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.LAST_MODIFICATION_DATE,\n            \"Last Modification Date\",\n            \"Last Modification Date\",\n            PropertyType.DATETIME,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.CHANGE_TOKEN,\n            \"Change Token\",\n            \"Change Token\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n    }","id":47799,"modified_method":"private static void addBasePropertyDefinitions(AbstractTypeDefinition type) {\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.BASE_TYPE_ID,\n            \"Base Type Id\",\n            \"Base Type Id\",\n            PropertyType.ID,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.OBJECT_ID,\n            \"Object Id\",\n            \"Object Id\",\n            PropertyType.ID,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.OBJECT_TYPE_ID,\n            \"Type Id\",\n            \"Type Id\",\n            PropertyType.ID,\n            Cardinality.SINGLE,\n            Updatability.ONCREATE,\n            false,\n            true));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.NAME,\n            \"Name\",\n            \"Name\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.ONCREATE,\n            false,\n            true));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.CREATED_BY,\n            \"Created By\",\n            \"Created By\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.CREATION_DATE,\n            \"Creation Date\",\n            \"Creation Date\",\n            PropertyType.DATETIME,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.LAST_MODIFIED_BY,\n            \"Last Modified By\",\n            \"Last Modified By\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.LAST_MODIFICATION_DATE,\n            \"Last Modification Date\",\n            \"Last Modification Date\",\n            PropertyType.DATETIME,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n        type.addPropertyDefinition(createPropDef(\n            PropertyIds.CHANGE_TOKEN,\n            \"Change Token\",\n            \"Change Token\",\n            PropertyType.STRING,\n            Cardinality.SINGLE,\n            Updatability.READONLY,\n            false,\n            false));\n\n    }","commit_id":"cc78fd9e0b03c093ed0f652703337944b0b142da","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns a html select box filled with the current users accessible sites.<p>\n     * \n     * @param htmlAttributes attributes that will be inserted into the generated html \n     * @return a html select box filled with the current users accessible sites\n     */\n    public String getSiteSelect(String htmlAttributes) {\n\n        List options = new ArrayList();\n        List values = new ArrayList();    \n        int selectedIndex = 0;                   \n\n        List sites = CmsSiteManager.getAvailableSites(getCms());\n\n        Iterator i = sites.iterator();\n        int pos = 0;\n        while (i.hasNext()) {\n            CmsSite site = (CmsSite)i.next();\n            values.add(site.getSiteRoot());\n            options.add(site.getTitle());\n            if (site.getSiteRoot().equals(getSettings().getSite())) { \n                // this is the user's current site\n                selectedIndex = pos;\n            }\n            pos++;\n        }\n        \n        return buildSelect(htmlAttributes, options, values, selectedIndex);\n    }","id":47800,"modified_method":"/**\n     * Returns a html select box filled with the current users accessible sites.<p>\n     * \n     * @param htmlAttributes attributes that will be inserted into the generated html \n     * @return a html select box filled with the current users accessible sites\n     */\n    public String getSiteSelect(String htmlAttributes) {\n\n        List options = new ArrayList();\n        List values = new ArrayList();    \n        int selectedIndex = 0;                   \n\n        List sites = CmsSiteManager.getAvailableSites(getCms(), true);\n\n        Iterator i = sites.iterator();\n        int pos = 0;\n        while (i.hasNext()) {\n            CmsSite site = (CmsSite)i.next();\n            values.add(site.getSiteRoot());\n            options.add(site.getTitle());\n            if (site.getSiteRoot().equals(getSettings().getSite())) { \n                // this is the user's current site\n                selectedIndex = pos;\n            }\n            pos++;\n        }\n        \n        return buildSelect(htmlAttributes, options, values, selectedIndex);\n    }","commit_id":"3caf19fcb3b75e25538d0439216ecbed62c9b90d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the current users workplace settings by reading the values \n     * from the users preferences.<p>\n     * \n     * This method is synchronized to ensure that the settings are\n     * initialized only once for a user.\n     * \n     * @param cms the cms object for the current user\n     * @param settings the current workplace settings\n     * @return initialized object with the current users workplace settings \n     */    \n    static synchronized CmsWorkplaceSettings initWorkplaceSettings(CmsObject cms, CmsWorkplaceSettings settings) {                \n        // initialize the current user language\n        String language = null;               \n        Hashtable startSettings =\n            (Hashtable)cms.getRequestContext().currentUser().getAdditionalInfo(I_CmsConstants.C_ADDITIONAL_INFO_STARTSETTINGS);  \n        // try to read it form the user additional info\n        if (startSettings != null) {\n            language = (String)startSettings.get(I_CmsConstants.C_START_LANGUAGE);\n        }    \n        // no startup language in user settings found, so check the users browser locale settings\n        if (language == null) {\n            Vector languages = cms.getRequestContext().getAcceptedLanguages();\n            int numlangs = languages.size();\n            for (int i = 0; i < numlangs; i++) {\n                String lang = (String)languages.elementAt(i);\n                try {\n                    cms.readFolder(I_CmsWpConstants.C_VFS_PATH_LOCALES + lang);\n                    // if we get past that readFolder() the language is supported\n                    language = lang;\n                    break;\n                } catch (CmsException e) {\n                    // browser language is not supported in OpenCms, continue looking\n                }\n            }\n        }\n        // if no language was found so far, use the default language\n        if (language == null) {\n            language = I_CmsWpConstants.C_DEFAULT_LANGUAGE;\n        }\n        \n        // save language in settings\n        settings.setLanguage(language);        \n        \n        // initialize messages and also store them in settings\n        CmsWorkplaceMessages messages = new CmsWorkplaceMessages(cms, language);\n        settings.setMessages(messages);        \n        \n        // save current workplace user\n        settings.setUser(cms.getRequestContext().currentUser());\n\n        // save current project\n        settings.setProject(cms.getRequestContext().currentProject().getId());\n        \n        // save current site\n        String siteRoot = cms.getRequestContext().getSiteRoot();\n        try {\n            CmsResource res = cms.readFileHeader(\"/\");\n            if(! cms.hasPermissions(res, I_CmsConstants.C_VIEW_ACCESS)) {\n                List sites = CmsSiteManager.getAvailableSites(cms);\n                if (sites.size() > 0) {\n                    siteRoot = ((CmsSite)sites.get(0)).getSiteRoot();\n                }\n            }            \n        } catch (CmsException e) {\n            // error reading site root, proceed with current site root \n        }\n        settings.setSite(siteRoot);\n        \n        // check out the user information for a default view that might be stored there\n        if (startSettings != null) {\n            settings.setCurrentView(LinkSubstitution.getLinkSubstitution(cms, (String)startSettings.get(I_CmsConstants.C_START_VIEW)));\n        }\n                  \n        return settings;   \n    }","id":47801,"modified_method":"/**\n     * Initializes the current users workplace settings by reading the values \n     * from the users preferences.<p>\n     * \n     * This method is synchronized to ensure that the settings are\n     * initialized only once for a user.\n     * \n     * @param cms the cms object for the current user\n     * @param settings the current workplace settings\n     * @return initialized object with the current users workplace settings \n     */    \n    static synchronized CmsWorkplaceSettings initWorkplaceSettings(CmsObject cms, CmsWorkplaceSettings settings) {                \n        // initialize the current user language\n        String language = null;               \n        Hashtable startSettings =\n            (Hashtable)cms.getRequestContext().currentUser().getAdditionalInfo(I_CmsConstants.C_ADDITIONAL_INFO_STARTSETTINGS);  \n        // try to read it form the user additional info\n        if (startSettings != null) {\n            language = (String)startSettings.get(I_CmsConstants.C_START_LANGUAGE);\n        }    \n        // no startup language in user settings found, so check the users browser locale settings\n        if (language == null) {\n            Vector languages = cms.getRequestContext().getAcceptedLanguages();\n            int numlangs = languages.size();\n            for (int i = 0; i < numlangs; i++) {\n                String lang = (String)languages.elementAt(i);\n                try {\n                    cms.readFolder(I_CmsWpConstants.C_VFS_PATH_LOCALES + lang);\n                    // if we get past that readFolder() the language is supported\n                    language = lang;\n                    break;\n                } catch (CmsException e) {\n                    // browser language is not supported in OpenCms, continue looking\n                }\n            }\n        }\n        // if no language was found so far, use the default language\n        if (language == null) {\n            language = I_CmsWpConstants.C_DEFAULT_LANGUAGE;\n        }\n        \n        // save language in settings\n        settings.setLanguage(language);        \n        \n        // initialize messages and also store them in settings\n        CmsWorkplaceMessages messages = new CmsWorkplaceMessages(cms, language);\n        settings.setMessages(messages);        \n        \n        // save current workplace user\n        settings.setUser(cms.getRequestContext().currentUser());\n\n        // save current project\n        settings.setProject(cms.getRequestContext().currentProject().getId());\n        \n        // save current site\n        String siteRoot = cms.getRequestContext().getSiteRoot();\n        boolean access = false;\n        CmsResource res = null;\n        try {\n            res = cms.readFileHeader(\"/\");   \n            access = cms.hasPermissions(res, I_CmsConstants.C_VIEW_ACCESS);\n        } catch (CmsException e) {\n            // error reading site root, in this case we will use a readable default\n        }\n        if((res == null) || !access) {\n            List sites = CmsSiteManager.getAvailableSites(cms, true);\n            if (sites.size() > 0) {\n                siteRoot = ((CmsSite)sites.get(0)).getSiteRoot();\n                cms.getRequestContext().setSiteRoot(siteRoot);\n            }\n        }            \n        settings.setSite(siteRoot);\n        \n        // check out the user information for a default view that might be stored there\n        if (startSettings != null) {\n            settings.setCurrentView(LinkSubstitution.getLinkSubstitution(cms, (String)startSettings.get(I_CmsConstants.C_START_VIEW)));\n        }\n                  \n        return settings;   \n    }","commit_id":"3caf19fcb3b75e25538d0439216ecbed62c9b90d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the resource types configured to be used within the given gallery mode.<p>\n     * \n     * @return the resource types\n     * \n     * @throws CmsRpcException if something goes wrong reading the configuration\n     */\n    private List<CmsResourceTypeBean> getResourceTypeBeans() throws CmsRpcException {\n\n        List<I_CmsResourceType> resourceTypes = null;\n        List<String> creatableTypes = null;\n        switch (m_galleryMode) {\n            case editor:\n            case view:\n            case widget:\n                resourceTypes = readResourceTypesFromRequest();\n                creatableTypes = Collections.<String> emptyList();\n                break;\n            case ade:\n                resourceTypes = new ArrayList<I_CmsResourceType>();\n                creatableTypes = new ArrayList<String>();\n                try {\n                    CmsADEConfigData config = OpenCms.getADEManager().lookupConfiguration(\n                        getCmsObject(),\n                        getCmsObject().getRequestContext().addSiteRoot(getCmsObject().getRequestContext().getUri()));\n                    for (CmsResourceTypeConfig typeConfig : config.getResourceTypes()) {\n                        String typeName = typeConfig.getTypeName();\n                        resourceTypes.add(getResourceManager().getResourceType(typeName));\n                    }\n                    for (CmsResourceTypeConfig typeConfig : config.getCreatableTypes(getCmsObject())) {\n                        String typeName = typeConfig.getTypeName();\n                        creatableTypes.add(typeName);\n                    }\n                } catch (CmsException e) {\n                    error(e);\n                }\n                break;\n            default:\n                resourceTypes = Collections.<I_CmsResourceType> emptyList();\n                creatableTypes = Collections.<String> emptyList();\n        }\n        return buildTypesList(resourceTypes, creatableTypes);\n    }","id":47802,"modified_method":"/**\n     * Returns the resource types configured to be used within the given gallery mode.<p>\n     * \n     * @return the resource types\n     * \n     * @throws CmsRpcException if something goes wrong reading the configuration\n     */\n    private List<CmsResourceTypeBean> getResourceTypeBeans() throws CmsRpcException {\n\n        List<I_CmsResourceType> resourceTypes = null;\n        List<String> creatableTypes = null;\n        switch (m_galleryMode) {\n            case editor:\n            case view:\n            case widget:\n                resourceTypes = readResourceTypesFromRequest();\n                creatableTypes = Collections.<String> emptyList();\n                break;\n            case ade:\n                resourceTypes = new ArrayList<I_CmsResourceType>();\n                creatableTypes = new ArrayList<String>();\n                try {\n                    CmsADEConfigData config = OpenCms.getADEManager().lookupConfiguration(\n                        getCmsObject(),\n                        getCmsObject().getRequestContext().addSiteRoot(getCmsObject().getRequestContext().getUri()));\n                    for (CmsResourceTypeConfig typeConfig : config.getResourceTypes()) {\n                        if (typeConfig.checkViewable(getCmsObject())) {\n                            String typeName = typeConfig.getTypeName();\n                            resourceTypes.add(getResourceManager().getResourceType(typeName));\n                        }\n                    }\n                    for (CmsResourceTypeConfig typeConfig : config.getCreatableTypes(getCmsObject())) {\n                        String typeName = typeConfig.getTypeName();\n                        creatableTypes.add(typeName);\n                    }\n                } catch (CmsException e) {\n                    error(e);\n                }\n                break;\n            default:\n                resourceTypes = Collections.<I_CmsResourceType> emptyList();\n                creatableTypes = Collections.<String> emptyList();\n        }\n        return buildTypesList(resourceTypes, creatableTypes);\n    }","commit_id":"545589c3bff08cba75c85c1be47f802db097ae02","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the opening wrapper tag for elements in the offline project. The wrapper tag is needed by the container-page editor\n     * to identify elements within a container.<p>\n     * \n     * @param cms the cms object\n     * @param elementBean the element\n     * @param isGroupcontainer <code>true<\/code> if element is a group-container\n     * \n     * @return the opening tag\n     * \n     * @throws CmsException if something goes wrong reading permissions and lock state\n     */\n    protected String getElementWrapperTagStart(\n        CmsObject cms,\n        CmsContainerElementBean elementBean,\n        boolean isGroupcontainer) throws CmsException {\n\n        StringBuffer result = new StringBuffer(\"<div class='\");\n        if (isGroupcontainer) {\n            result.append(CLASS_GROUP_CONTAINER_ELEMENT_MARKER);\n        } else {\n            result.append(CLASS_CONTAINER_ELEMENT_START_MARKER);\n        }\n        result.append(\"'\");\n        Locale wpLocale = OpenCms.getWorkplaceManager().getWorkplaceLocale(cms);\n        String noEditReason = \"\";\n        // reinitializing resource to avoid caching issues\n        elementBean.initResource(cms);\n        if (CmsResourceTypeXmlContent.isXmlContent(elementBean.getResource())) {\n            noEditReason = new CmsResourceUtil(cms, elementBean.getResource()).getNoEditReason(wpLocale);\n        } else {\n            noEditReason = Messages.get().getBundle().key(Messages.GUI_ELEMENT_RESOURCE_CAN_NOT_BE_EDITED_0);\n        }\n        result.append(\" clientId='\").append(elementBean.editorHash()).append(\"'\");\n        result.append(\" alt='\").append(elementBean.getSitePath()).append(\"'\");\n        if (elementBean.isCreateNew()) {\n            String typeName = OpenCms.getResourceManager().getResourceType(elementBean.getResource().getTypeId()).getTypeName();\n            result.append(\" newType='\").append(typeName).append(\"'\");\n            CmsResourceTypeConfig typeConfig = OpenCms.getADEManager().lookupConfiguration(\n                cms,\n                cms.getRequestContext().getRootUri()).getResourceType(typeName);\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(noEditReason)\n                && ((typeConfig == null) || !typeConfig.checkCreatable(cms))) {\n                String niceName = CmsWorkplaceMessages.getResourceTypeName(wpLocale, typeName);\n                noEditReason = Messages.get().getBundle().key(Messages.GUI_CONTAINERPAGE_TYPE_NOT_CREATABLE_1, niceName);\n            }\n        }\n        result.append(\" hasprops='\").append(hasProperties(cms, elementBean.getResource())).append(\"'\");\n        boolean viewPermission = cms.hasPermissions(\n            elementBean.getResource(),\n            CmsPermissionSet.ACCESS_VIEW,\n            false,\n            CmsResourceFilter.DEFAULT_ONLY_VISIBLE);\n        result.append(\" hasviewpermission='\").append(viewPermission).append(\"'\");\n        result.append(\" rel='\").append(CmsStringUtil.escapeHtml(noEditReason));\n        if (isGroupcontainer) {\n            result.append(\"'>\");\n        } else {\n            result.append(\"' style='display:none;'><\/div>\");\n        }\n        return result.toString();\n    }","id":47803,"modified_method":"/**\n     * Returns the opening wrapper tag for elements in the offline project. The wrapper tag is needed by the container-page editor\n     * to identify elements within a container.<p>\n     * \n     * @param cms the cms object\n     * @param elementBean the element\n     * @param isGroupcontainer <code>true<\/code> if element is a group-container\n     * \n     * @return the opening tag\n     * \n     * @throws CmsException if something goes wrong reading permissions and lock state\n     */\n    protected String getElementWrapperTagStart(\n        CmsObject cms,\n        CmsContainerElementBean elementBean,\n        boolean isGroupcontainer) throws CmsException {\n\n        StringBuffer result = new StringBuffer(\"<div class='\");\n        if (isGroupcontainer) {\n            result.append(CLASS_GROUP_CONTAINER_ELEMENT_MARKER);\n        } else {\n            result.append(CLASS_CONTAINER_ELEMENT_START_MARKER);\n        }\n        result.append(\"'\");\n        Locale wpLocale = OpenCms.getWorkplaceManager().getWorkplaceLocale(cms);\n        String noEditReason = \"\";\n        // reinitializing resource to avoid caching issues\n        elementBean.initResource(cms);\n        if (CmsResourceTypeXmlContent.isXmlContent(elementBean.getResource())) {\n            noEditReason = new CmsResourceUtil(cms, elementBean.getResource()).getNoEditReason(wpLocale);\n        } else {\n            noEditReason = Messages.get().getBundle().key(Messages.GUI_ELEMENT_RESOURCE_CAN_NOT_BE_EDITED_0);\n        }\n        result.append(\" clientId='\").append(elementBean.editorHash()).append(\"'\");\n        result.append(\" alt='\").append(elementBean.getSitePath()).append(\"'\");\n        String typeName = OpenCms.getResourceManager().getResourceType(elementBean.getResource().getTypeId()).getTypeName();\n        if (elementBean.isCreateNew()) {\n            result.append(\" newType='\").append(typeName).append(\"'\");\n            CmsResourceTypeConfig typeConfig = OpenCms.getADEManager().lookupConfiguration(\n                cms,\n                cms.getRequestContext().getRootUri()).getResourceType(typeName);\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(noEditReason)\n                && ((typeConfig == null) || !typeConfig.checkCreatable(cms))) {\n                String niceName = CmsWorkplaceMessages.getResourceTypeName(wpLocale, typeName);\n                noEditReason = Messages.get().getBundle().key(Messages.GUI_CONTAINERPAGE_TYPE_NOT_CREATABLE_1, niceName);\n            }\n        }\n        result.append(\" hasprops='\").append(hasProperties(cms, elementBean.getResource())).append(\"'\");\n        CmsExplorerTypeSettings settings = OpenCms.getWorkplaceManager().getExplorerTypeSetting(typeName);\n        boolean viewPermission = cms.hasPermissions(\n            elementBean.getResource(),\n            CmsPermissionSet.ACCESS_VIEW,\n            false,\n            CmsResourceFilter.DEFAULT_ONLY_VISIBLE)\n            && settings.getAccess().getPermissions(cms, elementBean.getResource()).requiresViewPermission();\n        result.append(\" hasviewpermission='\").append(viewPermission).append(\"'\");\n        result.append(\" rel='\").append(CmsStringUtil.escapeHtml(noEditReason));\n        if (isGroupcontainer) {\n            result.append(\"'>\");\n        } else {\n            result.append(\"' style='display:none;'><\/div>\");\n        }\n        return result.toString();\n    }","commit_id":"545589c3bff08cba75c85c1be47f802db097ae02","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private Optional<BlockMeta> createBlockNoLock(long userId, long blockId,\n      BlockStoreLocation location, long initialSize) throws IOException {\n    if (!mLockManager.addBlockLock(blockId)) {\n      LOG.error(\"Cannot add block lock of {}\", blockId);\n      return false;\n    }\n\n    BlockMeta block = mAllocator.allocateBlock(userId, blockId, initialSize, location).orNull();\n    if (block == null) {\n      // Not enough space in this block store, let's try to free some space.\n      if (requestSpace(userId, initialSize, tierHint)) {\n        LOG.error(\"Cannot free space of {} bytes\", blockSize);\n        return false;\n      }\n      // Try again\n      block = mAllocator.allocateBlock(userId, blockId, blockSize, tierHint).orNull();\n      Preconditions.checkState(block != null, \"Cannot allocate block {}:\", blockId);\n    }\n    if (!addBlockMetaNoLock(userId, block, tierHint)) {\n      return false;\n    }\n    BlockFileOperator operator = new BlockFileOperator(block);\n    long bytes = operator.write(0, buf);\n    return bytes == buf.limit();\n  }","id":47804,"modified_method":"private Optional<TempBlockMeta> createBlockMetaNoLock(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    Optional<TempBlockMeta> optTempBlock =\n        mAllocator.allocateBlock(userId, blockId, initialBlockSize, location);\n    if (!optTempBlock.isPresent()) {\n      // Not enough space in this block store, let's try to free some space.\n      if (freeSpaceNoLock(userId, initialBlockSize, location)) {\n        LOG.error(\"Cannot free {} bytes space in {}\", initialBlockSize, location);\n        return Optional.absent();\n      }\n      optTempBlock = mAllocator.allocateBlock(userId, blockId, initialBlockSize, location);\n      Preconditions.checkState(optTempBlock.isPresent(), \"Cannot allocate block {}:\", blockId);\n    }\n    // Add allocated temp block to metadata manager\n    mMetaManager.addTempBlockMeta(optTempBlock.get());\n    return optTempBlock;\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"private Optional<ByteBuffer> readBlockNoLock(long userId, long blockId, long offset, long length)\n      throws IOException {\n    BlockMeta block = mMetaManager.getBlockMeta(blockId).orNull();\n    if (block == null) {\n      return Optional.absent();\n    }\n    BlockFileOperator operator = new BlockFileOperator(block);\n    return Optional.of(operator.read(offset, length));\n  }","id":47805,"modified_method":"private boolean abortBlockNoLock(long userId, long blockId) throws IOException {\n    // TODO: check the userId is the owner of this temp block?\n    Optional<TempBlockMeta> optTempBlock = mMetaManager.getTempBlockMeta(blockId);\n    if (!optTempBlock.isPresent()) {\n      return false;\n    }\n    TempBlockMeta tempBlock = optTempBlock.get();\n    String path = tempBlock.getPath();\n    boolean deleted = new File(path).delete();\n    if (!deleted) {\n      return false;\n    }\n    return mMetaManager.abortTempBlockMeta(tempBlock);\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"public TieredBlockStore() {\n    mTachyonConf = new TachyonConf();\n    mMetaManager = new BlockMetadataManager(mTachyonConf);\n    mLockManager = new BlockLockManager();\n\n    // TODO: create Allocator according to tachyonConf.\n    mAllocator = new NaiveAllocator(mMetaManager);\n    // TODO: create Evictor according to tachyonConf\n    mEvictor = new NaiveEvictor(mMetaManager);\n  }","id":47806,"modified_method":"public TieredBlockStore(TachyonConf tachyonConf) {\n    mTachyonConf = Preconditions.checkNotNull(tachyonConf);\n    mMetaManager = new BlockMetadataManager(mTachyonConf);\n    mLockManager = new BlockLockManager();\n\n    // TODO: create Allocator according to tachyonConf.\n    mAllocator = new NaiveAllocator(mMetaManager);\n    // TODO: create Evictor according to tachyonConf\n    mEvictor = new NaiveEvictor(mMetaManager);\n\n    // TODO: implement initialization\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean freeSpaceNoLock(long userId, long bytes, int tierHint) throws IOException {\n    EvictionPlan plan = mEvictor.freeSpace(bytes, tierHint);\n    // Step1: remove blocks to make room.\n    for (long blockId : plan.toEvict()) {\n      if (!removeBlockNoLock(userId, blockId)) {\n        return false;\n      }\n    }\n    // Step2: transfer blocks among tiers.\n    for (Pair<Long, Integer> entry : plan.toTransfer()) {\n      long blockId = entry.getFirst();\n      int tierAlias = entry.getSecond();\n      if (!relocateBlockNoLock(userId, blockId, tierAlias)) {\n        return false;\n      }\n    }\n    return true;\n  }","id":47807,"modified_method":"private boolean freeSpaceNoLock(long userId, long size, BlockStoreLocation location)\n      throws IOException {\n    EvictionPlan plan = mEvictor.freeSpace(size, location);\n    // Step1: remove blocks to make room.\n    for (long blockId : plan.toEvict()) {\n      if (!removeBlockNoLock(userId, blockId)) {\n        return false;\n      }\n    }\n    // Step2: transfer blocks among tiers.\n    for (Pair<Long, Integer> entry : plan.toTransfer()) {\n      long blockId = entry.getFirst();\n      int tierAlias = entry.getSecond();\n      if (!moveBlockNoLock(userId, blockId, tierAlias)) {\n        return false;\n      }\n    }\n    return true;\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean removeBlockNoLock(long userId, long blockId) throws FileNotFoundException {\n    BlockMeta block = mMetaManager.getBlockMeta(blockId).orNull();\n    if (block == null) {\n      return false;\n    }\n    if (!block.isCheckpointed()) {\n      LOG.error(\"Cannot free block {}: not checkpointed\", blockId);\n      return false;\n    }\n\n    // Step1: delete metadata of the block\n    if (!mMetaManager.removeBlockMeta(blockId)) {\n      return false;\n    }\n    // Step2: delete the data file of the block\n    BlockFileOperator operator = new BlockFileOperator(block);\n    return operator.delete();\n  }","id":47808,"modified_method":"private boolean removeBlockNoLock(long userId, long blockId) throws IOException {\n    Optional<BlockMeta> optBlock = mMetaManager.getBlockMeta(blockId);\n    if (!optBlock.isPresent()) {\n      return false;\n    }\n\n    // Delete metadata of the block\n    if (!mMetaManager.removeBlockMeta(blockId)) {\n      return false;\n    }\n    // Delete the data file of the block\n    return new File(optBlock.get().getPath()).delete();\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Read data from an existing block at a specific offset and length.\n   *\n   * @param userId the user ID\n   * @param blockId the block ID\n   * @param offset offset of the data to read in bytes\n   * @param length length of the data to read in bytes\n   * @return a ByteBuffer containing data read or absent\n   * @throws IOException\n   */\n  @Override\n  public Optional<ByteBuffer> readBlock(long userId, long blockId, long offset, long length,\n      Integer tierHint) throws IOException {\n    mEvictor.preReadBlock(userId, blockId, offset, length);\n    Lock blockReadLock = mLockManager.getBlockReadLock(blockId);\n\n    mEvictionLock.readLock().lock();\n    blockReadLock.lock();\n    Optional<ByteBuffer> result = readBlockNoLock(userId, blockId, offset, length);\n    blockReadLock.unlock();\n    mEvictionLock.readLock().unlock();\n\n    mEvictor.postReadBlock(userId, blockId, offset, length);\n    return result;\n  }","id":47809,"modified_method":"@Override\n  public Optional<BlockReader> getBlockReader(long userId, long blockId, long lockId)\n      throws IOException {\n    Preconditions.checkState(mLockManager.validateLockId(userId, blockId, lockId));\n\n    Optional<BlockMeta> optBlock = mMetaManager.getBlockMeta(blockId);\n    if (!optBlock.isPresent()) {\n      return Optional.absent();\n    }\n    BlockReader reader = new LocalFileBlockReader(optBlock.get());\n    return Optional.of(reader);\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"private boolean relocateBlockNoLock(long userId, long blockId, int newTierHint)\n      throws IOException {\n    BlockMeta srcBlock = mMetaManager.getBlockMeta(userId).orNull();\n    if (srcBlock == null) {\n      return false;\n    }\n    BlockMeta dstBlock = mMetaManager.moveBlockMeta(userId, blockId, newTierHint).orNull();\n    if (dstBlock == null) {\n      return false;\n    }\n    BlockFileOperator operator = new BlockFileOperator(srcBlock);\n    return operator.move(dstBlock.getPath());\n  }","id":47810,"modified_method":"private boolean moveBlockNoLock(long userId, long blockId, BlockStoreLocation newLocation)\n      throws IOException {\n    Optional<BlockMeta> optSrcBlock = mMetaManager.getBlockMeta(blockId);\n    if (!optSrcBlock.isPresent()) {\n      return false;\n    }\n    String srcPath = optSrcBlock.get().getPath();\n\n    Optional<BlockMeta> optDestBlock = mMetaManager.moveBlockMeta(userId, blockId, newLocation);\n    if (!optDestBlock.isPresent()) {\n      return false;\n    }\n    String destPath = optDestBlock.get().getPath();\n\n    return new File(srcPath).renameTo(new File(destPath));\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Remove a block.\n   *\n   * @param userId the user ID\n   * @param blockId the block ID\n   * @return true if successful, false otherwise.\n   * @throws FileNotFoundException\n   */\n  @Override\n  public boolean removeBlock(long userId, long blockId, Integer tierAlias)\n      throws FileNotFoundException {\n    mEvictor.preRemoveBlock(userId, blockId);\n    Lock blockWriteLock = mLockManager.getBlockWriteLock(blockId);\n\n    mEvictionLock.readLock().lock();\n    blockWriteLock.lock();\n    boolean result = removeBlockNoLock(userId, blockId);\n    blockWriteLock.unlock();\n    mEvictionLock.readLock().unlock();\n\n    Preconditions.checkState(mLockManager.removeBlockLock(blockId));\n    mEvictor.postRemoveBlock(userId, blockId);\n    return result;\n  }","id":47811,"modified_method":"@Override\n  public boolean removeBlock(long userId, long blockId, long lockId) throws IOException {\n    Preconditions.checkState(mLockManager.validateLockId(userId, blockId, lockId));\n    return removeBlockNoLock(userId, blockId);\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<BlockMeta> createBlock(long userId, long blockId, BlockStoreLocation location,\n      long initialSize) throws IOException {\n    // TODO: implement me\n    // Preconditions.checkNotNull(location);\n    // mEvictionLock.writeLock().lock();\n    // boolean result = createBlockNoLock(userId, blockId, location, initialSize);\n    // mEvictionLock.writeLock().unlock();\n\n    return Optional.absent();\n  }","id":47812,"modified_method":"@Override\n  public Optional<TempBlockMeta> createBlockMeta(long userId, long blockId,\n      BlockStoreLocation location, long initialBlockSize) throws IOException {\n    mEvictionLock.writeLock().lock();\n    Optional<TempBlockMeta> optTempBlock = createBlockMetaNoLock(userId, blockId, location,\n        initialBlockSize);\n    mEvictionLock.writeLock().unlock();\n    return optTempBlock;\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public Optional<Long> lockBlock(long userId, long blockId, BlockLock.BlockLockType blockLockType) {\n    Preconditions.checkArgument(blockLockType == BlockLock.BlockLockType.READ\n        || blockLockType == BlockLock.BlockLockType.WRITE);\n\n    mEvictionLock.readLock().lock();\n    return mLockManager.lockBlock(userId, blockId, blockLockType);\n  }","id":47813,"modified_method":"@Override\n  public Optional<Long> lockBlock(long userId, long blockId, BlockLock.BlockLockType blockLockType) {\n    mEvictionLock.readLock().lock();\n    return mLockManager.lockBlock(userId, blockId, blockLockType);\n  }","commit_id":"2bb6e33076a939cd76d3cd9d3bbad4c9911d7a68","url":"https://github.com/amplab/tachyon"},{"original_method":"private int packTree(Element[] elmts, RTree rtree, String newFile)\n  {\n    try{\n      //long t = System.currentTimeMillis();\n      //rtree.flush();\n      File tmpPckFile = File.createTempFile(\"pack\",null);\n      RandomAccessFile rFile = new RandomAccessFile(tmpPckFile.getAbsolutePath(),\"rw\");\n\n      if(newFile.equalsIgnoreCase(rtree.getFileName())){//we need a write lock\n        rtree.getFileHdr().lockWrite();\n      }\n      /*the following is required as we may pack an existing tree.. until we find a way to remove nodes of\n        a particular rtree*/\n      RTree.chdNodes.removeAll();\n      //rtree.getFileHdr().getFile().getFD().sync();\n      if(elmts.length <= Node.MAX)//change this for the first method\n        return(1);\n      System.out.println(\"Pack.packTree : Size of elmts: \"+ elmts.length);\n\n      packRec(rFile,tmpPckFile,elmts,elmts.length);\n\n      //craete the new file\n      File fo = new File(newFile); \n      //delete the new file if it exists !!\n      if(fo.exists()){\n        fo.delete();\n        fo.createNewFile();\n      }\n      //overwrite the old rtree file with the temp file\n      FileInputStream fis=new FileInputStream(tmpPckFile);\n      FileOutputStream fos=new FileOutputStream(fo);\n      byte b[]=new byte[BUFFER_SIZE];\n      int i;\n      while((i=fis.read(b))!=-1){\n        fos.write(b, 0, i);\n      }\n      fos.close();\n      fis.close();\n      rFile.close();\n      tmpPckFile.deleteOnExit();\n      //System.out.println(\"Pack.packTree : packing took \" + (System.currentTimeMillis() - t));\n      return(0);\n    }\n    catch(Exception e){\n      e.printStackTrace();\n      System.out.println(\"rtree.RTree.pack: Could not pack rtree, the destination file may be corrupted.\");\n      return(2);\n    }\n    finally{//delete the source file header\n      synchronized(rtree){\n        //Here we have the old and the new file as same.. so we update the header\n        try{\n          rtree.updateHdr();\n          if(newFile.equalsIgnoreCase(rtree.getFileName())){//we need a write lock\n            rtree.getFileHdr().unlock();//relaese this lock as this header will be lost for ever\n          }\n        }catch(Exception e){\n          System.out.println(\"Pack.packTree : The pack tree is made but some other error hs occured. \"\n                             +\"It is recomended to restart the application\");\n          if(newFile.equalsIgnoreCase(rtree.getFileName()))//we need a write lock\n            rtree.getFileHdr().unlock();//relaese this lock as this header will be lost for ever\n        }\n      }//synchronized\n    }\n  }","id":47814,"modified_method":"private int packTree(Element[] elmts, RTree rtree, String newFile)\n  {\n    try{\n      //long t = System.currentTimeMillis();\n      //rtree.flush();\n      File tmpPckFile = File.createTempFile(\"pack\",null);\n      RandomAccessFile rFile = new RandomAccessFile(tmpPckFile.getAbsolutePath(),\"rw\");\n\n      if(newFile.equalsIgnoreCase(rtree.getFileName())){//we need a write lock\n        rtree.getFileHdr().lockWrite();\n      }\n      /*the following is required as we may pack an existing tree.. until we find a way to remove nodes of\n        a particular rtree*/\n      RTree.chdNodes.removeAll();\n      //rtree.getFileHdr().getFile().getFD().sync();\n      if(elmts.length <= Node.MAX)//change this for the first method\n        return(1);\n      System.out.println(\"Pack.packTree : Size of elmts: \"+ elmts.length);\n\n      packRec(rFile,tmpPckFile,elmts,elmts.length);\n\n      //craete the new file\n      File fo = new File(newFile); \n      //delete the new file if it exists !!\n      if(fo.exists()){\n        fo.delete();\n        fo.createNewFile();\n      }\n      //overwrite the old rtree file with the temp file\n      FileInputStream fis=new FileInputStream(tmpPckFile);\n      FileOutputStream fos=new FileOutputStream(fo);\n      byte b[]=new byte[BUFFER_SIZE];\n      int i;\n      while((i=fis.read(b))!=-1){\n        fos.write(b, 0, i);\n      }\n      fos.close();\n      fis.close();\n      rFile.close();\n      if (!tmpPckFile.delete()) {\n    \t  tmpPckFile.deleteOnExit();\n      }\n      //System.out.println(\"Pack.packTree : packing took \" + (System.currentTimeMillis() - t));\n      return(0);\n    }\n    catch(Exception e){\n      e.printStackTrace();\n      System.out.println(\"rtree.RTree.pack: Could not pack rtree, the destination file may be corrupted.\");\n      return(2);\n    }\n    finally{//delete the source file header\n      synchronized(rtree){\n        //Here we have the old and the new file as same.. so we update the header\n        try{\n          rtree.updateHdr();\n          if(newFile.equalsIgnoreCase(rtree.getFileName())){//we need a write lock\n            rtree.getFileHdr().unlock();//relaese this lock as this header will be lost for ever\n          }\n        }catch(Exception e){\n          System.out.println(\"Pack.packTree : The pack tree is made but some other error hs occured. \"\n                             +\"It is recomended to restart the application\");\n          if(newFile.equalsIgnoreCase(rtree.getFileName()))//we need a write lock\n            rtree.getFileHdr().unlock();//relaese this lock as this header will be lost for ever\n        }\n      }//synchronized\n    }\n  }","commit_id":"990baaa2ec0ed970628891872d535aa65059a849","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\r\n     * <p>Tries to free a specified amount of bytes.<\/p>\r\n     * <p>\r\n     *   If the currently available memory is enough, the method returns <code>true<\/code> without\r\n     *   performing additional steps. If not, the behaviour depends on the parameter <code>force<\/code>.\r\n     *   If <code>false<\/code>, a Full GC is only performed if former GCs indicated that a GC should\r\n     *   provide enough free memory. If former GCs didn't but <code>force<\/code> is set to <code>true<\/code>\r\n     *   a Full GC is performed nevertheless.\r\n     * <\/p>\r\n     * <p>\r\n     *   Setting the <code>force<\/code> parameter to false doesn't necessarily mean, that no GC may be\r\n     *   performed by this method, if the currently available memory doesn't suffice!\r\n     * <\/p>\r\n     * <p><em>Be careful with this method as GCs should always be the last measure to take<\/em><\/p>\r\n     * \r\n     * @param size the requested amount of free memory in bytes\r\n     * @param specifies whether a GC should be run even in case former GCs didn't provide enough memory\r\n     * @return whether enough memory could be freed (or is free) or not\r\n     */\r\n    public static boolean request(long size, boolean force) {\r\n        long avail = available();\r\n        if (avail >= size) return true;\r\n        long avg;\r\n        if (force || ((avg = getAverageGCFree()) == 0 || avg + avail >= size)) {\r\n            long freed = runGC();\r\n            avail = available();\r\n            serverLog.logInfo(\"MEMORY\", \"performed explicit GC, freed \" + (freed / 1024) + \" KB (requested/available: \" + size + \" / \" + avail + \" KB)\");\r\n            return avail >= size;\r\n        } else {\r\n            serverLog.logInfo(\"MEMORY\", \"couldn't free enough memory (requested/available \" + size + \"/\" + avail + \" KB)\");\r\n            return false;\r\n        }\r\n    }","id":47815,"modified_method":"/**\r\n     * <p>Tries to free a specified amount of bytes.<\/p>\r\n     * <p>\r\n     *   If the currently available memory is enough, the method returns <code>true<\/code> without\r\n     *   performing additional steps. If not, the behaviour depends on the parameter <code>force<\/code>.\r\n     *   If <code>false<\/code>, a Full GC is only performed if former GCs indicated that a GC should\r\n     *   provide enough free memory. If former GCs didn't but <code>force<\/code> is set to <code>true<\/code>\r\n     *   a Full GC is performed nevertheless.\r\n     * <\/p>\r\n     * <p>\r\n     *   Setting the <code>force<\/code> parameter to false doesn't necessarily mean, that no GC may be\r\n     *   performed by this method, if the currently available memory doesn't suffice!\r\n     * <\/p>\r\n     * <p><em>Be careful with this method as GCs should always be the last measure to take<\/em><\/p>\r\n     * \r\n     * @param size the requested amount of free memory in bytes\r\n     * @param specifies whether a GC should be run even in case former GCs didn't provide enough memory\r\n     * @return whether enough memory could be freed (or is free) or not\r\n     */\r\n    public static boolean request(long size, boolean force) {\r\n        long avail = available();\r\n        if (avail >= size) return true;\r\n        long avg = getAverageGCFree();\r\n        if (force || avg == 0 || avg + avail >= size) {\r\n            long freed = runGC();\r\n            avail = available();\r\n            serverLog.logInfo(\"MEMORY\", \"performed explicit GC, freed \" + (freed / 1024)\r\n                    + \" KB (requested/available/average: \" + (size / 1024) + \" / \"\r\n                    + (avail / 1024) + \"/\" + (avg / 1024) + \" KB)\");\r\n            return avail >= size;\r\n        } else {\r\n            serverLog.logInfo(\"MEMORY\", \"former GCs indicate to not be able to free enough memory (requested/available/average: \"\r\n                    + (size / 1024) + \"/\" + (avail / 1024) + \"/\" + (avg / 1024) + \" KB)\");\r\n            return false;\r\n        }\r\n    }","commit_id":"8bff810d1920ada442d71254f70b8b9caaa3548d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n    * Starts up the whole application. Sets up all datastructures and starts\r\n    * the main threads.\r\n    *\r\n    * @param homePath Root-path where all information is to be found.\r\n    * @param startupFree free memory at startup time, to be used later for statistics\r\n    */\r\n    private static void startup(String homePath, long startupMemFree, long startupMemTotal) {\r\n        long startup = System.currentTimeMillis();\r\n\r\n        int oldRev=0;\r\n        int newRev=0;\r\n\r\n        try {\r\n            // start up\r\n            System.out.println(copyright);\r\n            System.out.println(hline);\r\n\r\n            // check java version\r\n            try {\r\n                /*String[] check =*/ \"a,b\".split(\",\"); // split needs java 1.4\r\n            } catch (NoSuchMethodError e) {\r\n                System.err.println(\"STARTUP: Java Version too low. You need at least Java 1.4.2 to run YaCy\");\r\n                Thread.sleep(3000);\r\n                System.exit(-1);\r\n            }\r\n            \r\n            // ensure that there is a DATA directory, if not, create one and if that fails warn and die\r\n            File f = new File(homePath); if (!(f.exists())) f.mkdirs();\r\n            f = new File(homePath, \"DATA/\"); if (!(f.exists())) f.mkdirs();\r\n\t\t\tif (!(f.exists())) { \r\n\t\t\t\tSystem.err.println(\"Error creating DATA-directory in \" + homePath.toString() + \" . Please check your write-permission for this folder. YaCy will now terminate.\"); \r\n\t\t\t\tSystem.exit(-1); \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tf = new File(homePath, \"DATA/yacy.running\");\r\n\t\t\tif (!f.exists()) f.createNewFile(); f.deleteOnExit();\r\n            \r\n            // setting up logging\r\n            f = new File(homePath, \"DATA/LOG/\"); if (!(f.exists())) f.mkdirs();\r\n            if (!((new File(homePath, \"DATA/LOG/yacy.logging\")).exists())) try {\r\n                serverFileUtils.copy(new File(homePath, \"yacy.logging\"), new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            }catch (IOException e){\r\n                System.out.println(\"could not copy yacy.logging\");\r\n            }\r\n            try{\r\n                serverLog.configureLogging(homePath,new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            } catch (IOException e) {\r\n                System.out.println(\"could not find logging properties in homePath=\" + homePath);\r\n                e.printStackTrace();\r\n            }\r\n            serverLog.logConfig(\"STARTUP\", \"java version \" + System.getProperty(\"java.version\", \"no-java-version\"));\r\n            serverLog.logConfig(\"STARTUP\", \"Application Root Path: \" + homePath);\r\n            serverLog.logConfig(\"STARTUP\", \"Time Zone: UTC\" + serverDate.UTCDiffString() + \"; UTC+0000 is \" + System.currentTimeMillis());\r\n            serverLog.logConfig(\"STARTUP\", \"Maximum file system path length: \" + serverSystem.maxPathLength);\r\n\r\n            /*\r\n                // Testing if the yacy archive file were unzipped correctly.\r\n                // This test is needed because of classfile-names longer than 100 chars\r\n                // which could cause problems with incompatible unzip software.\r\n                // See:\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1763\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=715\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1674\r\n                File unzipTest = new File(homePath,\"doc/This_is_a_test_if_the_archive_file_containing_YaCy_was_unpacked_correctly_If_not_please_use_gnu_tar_instead.txt\");\r\n                if (!unzipTest.exists()) {\r\n                    String errorMsg = \"The archive file containing YaCy was not unpacked correctly. \" +\r\n                                      \"Please use 'GNU-Tar' or upgrade to a newer version of your unzip software.\\n\" +\r\n                                      \"For detailed information on this bug see: \" + \r\n                                      \"http://www.yacy-forum.de/viewtopic.php?t=715\";\r\n                    System.err.println(errorMsg);\r\n                    serverLog.logSevere(\"STARTUP\", errorMsg);\r\n                    System.exit(1); \r\n                }\r\n            */                    \r\n            \r\n            sb = new plasmaSwitchboard(homePath, \"yacy.init\", \"DATA/SETTINGS/httpProxy.conf\");\r\n            sbSync.V(); // signal that the sb reference was set\r\n            \r\n            // save information about available memory at startup time\r\n            sb.setConfig(\"memoryFreeAfterStartup\", startupMemFree);\r\n            sb.setConfig(\"memoryTotalAfterStartup\", startupMemTotal);\r\n            \r\n            // hardcoded, forced, temporary value-migration\r\n            sb.setConfig(\"htTemplatePath\", \"htroot/env/templates\");\r\n            sb.setConfig(\"parseableExt\", \"html,htm,txt,php,shtml,asp\");\r\n\r\n            // if we are running an SVN version, we try to detect the used svn revision now ...\r\n            final Properties buildProp = new Properties();\r\n            File buildPropFile = null;\r\n            try {\r\n                buildPropFile = new File(homePath,\"build.properties\");\r\n                buildProp.load(new FileInputStream(buildPropFile));\r\n            } catch (Exception e) {\r\n                serverLog.logWarning(\"STARTUP\", buildPropFile.toString() + \" not found in settings path\");\r\n            }\r\n            \r\n            oldRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            try {\r\n                if (buildProp.containsKey(\"releaseNr\")) {\r\n                    // this normally looks like this: $Revision$\r\n                    final String svnReleaseNrStr = buildProp.getProperty(\"releaseNr\");\r\n                    final Pattern pattern = Pattern.compile(\"\\\\$Revision:\\\\s(.*)\\\\s\\\\$\",Pattern.DOTALL+Pattern.CASE_INSENSITIVE);\r\n                    final Matcher matcher = pattern.matcher(svnReleaseNrStr);\r\n                    if (matcher.find()) {\r\n                        final String svrReleaseNr = matcher.group(1);\r\n                        try {\r\n                            try {version = Double.parseDouble(vString);} catch (NumberFormatException e) {version = (float) 0.1;}\r\n                            version = versvn2combinedVersion(version, Integer.parseInt(svrReleaseNr));\r\n                        } catch (NumberFormatException e) {}\r\n                        sb.setConfig(\"svnRevision\", svrReleaseNr);\r\n                    }\r\n                }\r\n                newRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            } catch (Exception e) {\r\n                System.err.println(\"Unable to determine the currently used SVN revision number.\");\r\n            }\r\n\r\n            sb.setConfig(\"version\", Double.toString(version));\r\n            sb.setConfig(\"vString\", combined2prettyVersion(Double.toString(version)));\r\n            sb.setConfig(\"vdate\", vDATE);\r\n            sb.setConfig(\"applicationRoot\", homePath);\r\n            sb.startupTime = startup;\r\n            serverLog.logConfig(\"STARTUP\", \"YACY Version: \" + version + \", Built \" + vDATE);\r\n            yacyVersion.latestRelease = version;\r\n\r\n            // read environment\r\n            int timeout = Math.max(20000, Integer.parseInt(sb.getConfig(\"httpdTimeout\", \"20000\")));\r\n\r\n            // create some directories\r\n            final File htRootPath = new File(homePath, sb.getConfig(\"htRootPath\", \"htroot\"));\r\n            final File htDocsPath = new File(homePath, sb.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\r\n            if (!(htDocsPath.exists())) htDocsPath.mkdir();\r\n            //final File htTemplatePath = new File(homePath, sb.getConfig(\"htTemplatePath\",\"htdocs\"));\r\n\r\n            // create default notifier picture\r\n            //TODO: Use templates instead of copying images ...\r\n            if (!((new File(htDocsPath, \"notifier.gif\")).exists())) try {\r\n                serverFileUtils.copy(new File(htRootPath, \"env/grafics/empty.gif\"),\r\n                                     new File(htDocsPath, \"notifier.gif\"));\r\n            } catch (IOException e) {}\r\n\r\n            final File htdocsDefaultReadme = new File(htDocsPath, \"readme.txt\");\r\n            if (!(htdocsDefaultReadme.exists())) try {serverFileUtils.write((\r\n                    \"This is your root directory for individual Web Content\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Please place your html files into the www subdirectory.\\r\\n\" +\r\n                    \"The URL of that path is either\\r\\n\" +\r\n                    \"http://www.<your-peer-name>.yacy    or\\r\\n\" +\r\n                    \"http://<your-ip>:<your-port>/www\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Other subdirectories may be created; they map to corresponding sub-domains.\\r\\n\" +\r\n                    \"This directory shares it's content with the applications htroot path, so you\\r\\n\" +\r\n                    \"may access your yacy search page with\\r\\n\" +\r\n                    \"http://<your-peer-name>.yacy/\\r\\n\" +\r\n                    \"\\r\\n\").getBytes(), htdocsDefaultReadme);} catch (IOException e) {\r\n                        System.out.println(\"Error creating htdocs readme: \" + e.getMessage());\r\n                    }\r\n\r\n            final File wwwDefaultPath = new File(htDocsPath, \"www\");\r\n            if (!(wwwDefaultPath.exists())) wwwDefaultPath.mkdir();\r\n\r\n\r\n            final File shareDefaultPath = new File(htDocsPath, \"share\");\r\n            if (!(shareDefaultPath.exists())) shareDefaultPath.mkdir();\r\n\r\n            migration.migrate(sb, oldRev, newRev);\r\n            \r\n            // start main threads\r\n            final String port = sb.getConfig(\"port\", \"8080\");\r\n            try {\r\n                final httpd protocolHandler = new httpd(sb, new httpdFileHandler(sb), new httpdProxyHandler(sb));\r\n                final serverCore server = new serverCore(\r\n                        timeout /*control socket timeout in milliseconds*/,\r\n                        true /* block attacks (wrong protocol) */,\r\n                        protocolHandler /*command class*/,\r\n                        sb,\r\n                        30000 /*command max length incl. GET args*/);\r\n                server.setName(\"httpd:\"+port);\r\n                server.setPriority(Thread.MAX_PRIORITY);\r\n                server.setObeyIntermission(false);\r\n                if (server == null) {\r\n                    serverLog.logSevere(\"STARTUP\", \"Failed to start server. Probably port \" + port + \" already in use.\");\r\n                } else {\r\n                    // first start the server\r\n                    sb.deployThread(\"10_httpd\", \"HTTPD Server/Proxy\", \"the HTTPD, used as web server and proxy\", null, server, 0, 0, 0, 0);\r\n                    //server.start();\r\n\r\n                    // open the browser window\r\n                    final boolean browserPopUpTrigger = sb.getConfig(\"browserPopUpTrigger\", \"true\").equals(\"true\");\r\n                    if (browserPopUpTrigger) {\r\n                        String  browserPopUpPage        = sb.getConfig(\"browserPopUpPage\", \"ConfigBasic.html\");\r\n                        boolean properPW = (sb.getConfig(\"adminAccount\", \"\").length() == 0) && (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0);\r\n                        if (!properPW) browserPopUpPage = \"ConfigBasic.html\";\r\n                        final String  browserPopUpApplication = sb.getConfig(\"browserPopUpApplication\", \"netscape\");\r\n                        serverSystem.openBrowser((server.withSSL()?\"https\":\"http\") + \"://localhost:\" + serverCore.getPortNr(port) + \"/\" + browserPopUpPage, browserPopUpApplication);\r\n                    }\r\n\r\n                    //Copy the shipped locales into DATA\r\n                    final File localesPath = new File(homePath, sb.getConfig(\"localesPath\", \"DATA/LOCALE\"));\r\n                    final File defaultLocalesPath = new File(homePath, \"locales\");\r\n                    \r\n\r\n                    try{\r\n                        final File[] defaultLocales = defaultLocalesPath.listFiles();\r\n                        localesPath.mkdirs();\r\n                        for(int i=0;i < defaultLocales.length; i++){\r\n                            if(defaultLocales[i].getName().endsWith(\".lng\"))\r\n                                serverFileUtils.copy(defaultLocales[i], new File(localesPath, defaultLocales[i].getName()));\r\n                        }\r\n                        serverLog.logInfo(\"STARTUP\", \"Copied the default locales to DATA/LOCALE\");\r\n                    }catch(NullPointerException e){\r\n                        serverLog.logSevere(\"STARTUP\", \"Nullpointer Exception while copying the default Locales\");\r\n                    }\r\n\r\n                    //regenerate Locales from Translationlist, if needed\r\n                    final String lang = sb.getConfig(\"htLocaleSelection\", \"\");\r\n                    if(! lang.equals(\"\") && ! lang.equals(\"default\") ){ //locale is used\r\n                        String currentRev = \"\";\r\n                        try{\r\n                            final BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File( sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang+\"/version\" ))));\r\n                            currentRev = br.readLine();\r\n                            br.close();\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n\r\n                        try{ //seperate try, because we want this, even if the file \"version\" does not exist.\r\n                            if(! currentRev.equals(sb.getConfig(\"svnRevision\", \"\")) ){ //is this another version?!\r\n                                final File sourceDir = new File(sb.getConfig(\"htRootPath\", \"htroot\"));\r\n                                final File destDir = new File(sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang);\r\n                                \r\n                              if(translator.translateFilesRecursive(sourceDir, destDir, new File(\"DATA/LOCALE/\"+lang+\".lng\"), \"html,template,inc\", \"locale\")){ //translate it\r\n                                    //write the new Versionnumber\r\n                                    final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(new File(destDir, \"version\"))));\r\n                                    bw.write(sb.getConfig(\"svnRevision\", \"Error getting Version\"));\r\n                                    bw.close();\r\n                                }\r\n                            }\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n                    }\r\n\r\n                    // registering shutdown hook\r\n                    serverLog.logConfig(\"STARTUP\", \"Registering Shutdown Hook\");\r\n                    final Runtime run = Runtime.getRuntime();\r\n                    run.addShutdownHook(new shutdownHookThread(Thread.currentThread(), sb));\r\n\r\n                    // save information about available memory after all initializations\r\n                    //try {\r\n                        sb.setConfig(\"memoryFreeAfterInitBGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitBGC\", Runtime.getRuntime().totalMemory());\r\n                        System.gc();\r\n                        sb.setConfig(\"memoryFreeAfterInitAGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitAGC\", Runtime.getRuntime().totalMemory());\r\n                    //} catch (ConcurrentModificationException e) {}\r\n                    \r\n                    // signal finished startup\r\n                    startupFinishedSync.V();\r\n                        \r\n                    // wait for server shutdown\r\n                    try {\r\n                        sb.waitForShutdown();\r\n                    } catch (Exception e) {\r\n                        serverLog.logSevere(\"MAIN CONTROL LOOP\", \"PANIC: \" + e.getMessage(),e);\r\n                    }\r\n                    // shut down\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"caught termination signal\");\r\n                    server.terminate(false);\r\n                    server.interrupt();\r\n                    if (server.isAlive()) try {\r\n                        URL u = new URL((server.withSSL()?\"https\":\"http\")+\"://localhost:\" + serverCore.getPortNr(port));\r\n                        httpc.wget(u, u.getHost(), 1000, null, null, null); // kick server\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"sent termination signal to server socket\");\r\n                    } catch (IOException ee) {\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"termination signal to server socket missed (server shutdown, ok)\");\r\n                    }\r\n\r\n                    // idle until the processes are down\r\n                    while (server.isAlive()) {\r\n                        Thread.sleep(2000); // wait a while\r\n                    }\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"server has terminated\");\r\n                    sb.close();\r\n                }\r\n            } catch (Exception e) {\r\n                serverLog.logSevere(\"STARTUP\", \"Unexpected Error: \" + e.getClass().getName(),e);\r\n                //System.exit(1);\r\n            }\r\n        } catch (Exception ee) {\r\n            serverLog.logSevere(\"STARTUP\", \"FATAL ERROR: \" + ee.getMessage(),ee);\r\n        } finally {\r\n        \tstartupFinishedSync.V();\r\n        }\r\n        serverLog.logConfig(\"SHUTDOWN\", \"goodbye. (this is the last line)\");\r\n        //try {\r\n        //    System.exit(0);\r\n        //} catch (Exception e) {} // was once stopped by de.anomic.net.ftpc$sm.checkExit(ftpc.java:1790)\r\n    }","id":47816,"modified_method":"/**\r\n    * Starts up the whole application. Sets up all datastructures and starts\r\n    * the main threads.\r\n    *\r\n    * @param homePath Root-path where all information is to be found.\r\n    * @param startupFree free memory at startup time, to be used later for statistics\r\n    */\r\n    private static void startup(String homePath, long startupMemFree, long startupMemTotal) {\r\n        long startup = System.currentTimeMillis();\r\n\r\n        int oldRev=0;\r\n        int newRev=0;\r\n\r\n        try {\r\n            // start up\r\n            System.out.println(copyright);\r\n            System.out.println(hline);\r\n\r\n            // check java version\r\n            try {\r\n                /*String[] check =*/ \"a,b\".split(\",\"); // split needs java 1.4\r\n            } catch (NoSuchMethodError e) {\r\n                System.err.println(\"STARTUP: Java Version too low. You need at least Java 1.4.2 to run YaCy\");\r\n                Thread.sleep(3000);\r\n                System.exit(-1);\r\n            }\r\n            \r\n            // ensure that there is a DATA directory, if not, create one and if that fails warn and die\r\n            File f = new File(homePath); if (!(f.exists())) f.mkdirs();\r\n            f = new File(homePath, \"DATA/\"); if (!(f.exists())) f.mkdirs();\r\n\t\t\tif (!(f.exists())) { \r\n\t\t\t\tSystem.err.println(\"Error creating DATA-directory in \" + homePath.toString() + \" . Please check your write-permission for this folder. YaCy will now terminate.\"); \r\n\t\t\t\tSystem.exit(-1); \r\n\t\t\t}\r\n            \r\n            // setting up logging\r\n            f = new File(homePath, \"DATA/LOG/\"); if (!(f.exists())) f.mkdirs();\r\n            if (!((new File(homePath, \"DATA/LOG/yacy.logging\")).exists())) try {\r\n                serverFileUtils.copy(new File(homePath, \"yacy.logging\"), new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            }catch (IOException e){\r\n                System.out.println(\"could not copy yacy.logging\");\r\n            }\r\n            try{\r\n                serverLog.configureLogging(homePath,new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            } catch (IOException e) {\r\n                System.out.println(\"could not find logging properties in homePath=\" + homePath);\r\n                e.printStackTrace();\r\n            }\r\n            serverLog.logConfig(\"STARTUP\", \"java version \" + System.getProperty(\"java.version\", \"no-java-version\"));\r\n            serverLog.logConfig(\"STARTUP\", \"Application Root Path: \" + homePath);\r\n            serverLog.logConfig(\"STARTUP\", \"Time Zone: UTC\" + serverDate.UTCDiffString() + \"; UTC+0000 is \" + System.currentTimeMillis());\r\n            serverLog.logConfig(\"STARTUP\", \"Maximum file system path length: \" + serverSystem.maxPathLength);\r\n            \r\n            f = new File(homePath, \"DATA/yacy.running\");\r\n            if (f.exists()) {                // another instance running? VM crash? User will have to care about this\r\n                serverLog.logSevere(\"STARTUP\", \"the file \" + f + \" exists, this usually means that another instance of YaCy is using this DATA-folder.\");\r\n                serverLog.logSevere(\"STARTUP\", \"please make sure that DATA can be used exclusively by one YaCy. Quitting...\");\r\n                System.exit(-1);\r\n            } else {\r\n                f.createNewFile();\r\n                f.deleteOnExit();\r\n            }\r\n\r\n            /*\r\n                // Testing if the yacy archive file were unzipped correctly.\r\n                // This test is needed because of classfile-names longer than 100 chars\r\n                // which could cause problems with incompatible unzip software.\r\n                // See:\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1763\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=715\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1674\r\n                File unzipTest = new File(homePath,\"doc/This_is_a_test_if_the_archive_file_containing_YaCy_was_unpacked_correctly_If_not_please_use_gnu_tar_instead.txt\");\r\n                if (!unzipTest.exists()) {\r\n                    String errorMsg = \"The archive file containing YaCy was not unpacked correctly. \" +\r\n                                      \"Please use 'GNU-Tar' or upgrade to a newer version of your unzip software.\\n\" +\r\n                                      \"For detailed information on this bug see: \" + \r\n                                      \"http://www.yacy-forum.de/viewtopic.php?t=715\";\r\n                    System.err.println(errorMsg);\r\n                    serverLog.logSevere(\"STARTUP\", errorMsg);\r\n                    System.exit(1); \r\n                }\r\n            */                    \r\n            \r\n            sb = new plasmaSwitchboard(homePath, \"yacy.init\", \"DATA/SETTINGS/httpProxy.conf\");\r\n            sbSync.V(); // signal that the sb reference was set\r\n            \r\n            // save information about available memory at startup time\r\n            sb.setConfig(\"memoryFreeAfterStartup\", startupMemFree);\r\n            sb.setConfig(\"memoryTotalAfterStartup\", startupMemTotal);\r\n            \r\n            // hardcoded, forced, temporary value-migration\r\n            sb.setConfig(\"htTemplatePath\", \"htroot/env/templates\");\r\n            sb.setConfig(\"parseableExt\", \"html,htm,txt,php,shtml,asp\");\r\n\r\n            // if we are running an SVN version, we try to detect the used svn revision now ...\r\n            final Properties buildProp = new Properties();\r\n            File buildPropFile = null;\r\n            try {\r\n                buildPropFile = new File(homePath,\"build.properties\");\r\n                buildProp.load(new FileInputStream(buildPropFile));\r\n            } catch (Exception e) {\r\n                serverLog.logWarning(\"STARTUP\", buildPropFile.toString() + \" not found in settings path\");\r\n            }\r\n            \r\n            oldRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            try {\r\n                if (buildProp.containsKey(\"releaseNr\")) {\r\n                    // this normally looks like this: $Revision$\r\n                    final String svnReleaseNrStr = buildProp.getProperty(\"releaseNr\");\r\n                    final Pattern pattern = Pattern.compile(\"\\\\$Revision:\\\\s(.*)\\\\s\\\\$\",Pattern.DOTALL+Pattern.CASE_INSENSITIVE);\r\n                    final Matcher matcher = pattern.matcher(svnReleaseNrStr);\r\n                    if (matcher.find()) {\r\n                        final String svrReleaseNr = matcher.group(1);\r\n                        try {\r\n                            try {version = Double.parseDouble(vString);} catch (NumberFormatException e) {version = (float) 0.1;}\r\n                            version = versvn2combinedVersion(version, Integer.parseInt(svrReleaseNr));\r\n                        } catch (NumberFormatException e) {}\r\n                        sb.setConfig(\"svnRevision\", svrReleaseNr);\r\n                    }\r\n                }\r\n                newRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            } catch (Exception e) {\r\n                System.err.println(\"Unable to determine the currently used SVN revision number.\");\r\n            }\r\n\r\n            sb.setConfig(\"version\", Double.toString(version));\r\n            sb.setConfig(\"vString\", combined2prettyVersion(Double.toString(version)));\r\n            sb.setConfig(\"vdate\", vDATE);\r\n            sb.setConfig(\"applicationRoot\", homePath);\r\n            sb.startupTime = startup;\r\n            serverLog.logConfig(\"STARTUP\", \"YACY Version: \" + version + \", Built \" + vDATE);\r\n            yacyVersion.latestRelease = version;\r\n\r\n            // read environment\r\n            int timeout = Math.max(20000, Integer.parseInt(sb.getConfig(\"httpdTimeout\", \"20000\")));\r\n\r\n            // create some directories\r\n            final File htRootPath = new File(homePath, sb.getConfig(\"htRootPath\", \"htroot\"));\r\n            final File htDocsPath = new File(homePath, sb.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\r\n            if (!(htDocsPath.exists())) htDocsPath.mkdir();\r\n            //final File htTemplatePath = new File(homePath, sb.getConfig(\"htTemplatePath\",\"htdocs\"));\r\n\r\n            // create default notifier picture\r\n            //TODO: Use templates instead of copying images ...\r\n            if (!((new File(htDocsPath, \"notifier.gif\")).exists())) try {\r\n                serverFileUtils.copy(new File(htRootPath, \"env/grafics/empty.gif\"),\r\n                                     new File(htDocsPath, \"notifier.gif\"));\r\n            } catch (IOException e) {}\r\n\r\n            final File htdocsDefaultReadme = new File(htDocsPath, \"readme.txt\");\r\n            if (!(htdocsDefaultReadme.exists())) try {serverFileUtils.write((\r\n                    \"This is your root directory for individual Web Content\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Please place your html files into the www subdirectory.\\r\\n\" +\r\n                    \"The URL of that path is either\\r\\n\" +\r\n                    \"http://www.<your-peer-name>.yacy    or\\r\\n\" +\r\n                    \"http://<your-ip>:<your-port>/www\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Other subdirectories may be created; they map to corresponding sub-domains.\\r\\n\" +\r\n                    \"This directory shares it's content with the applications htroot path, so you\\r\\n\" +\r\n                    \"may access your yacy search page with\\r\\n\" +\r\n                    \"http://<your-peer-name>.yacy/\\r\\n\" +\r\n                    \"\\r\\n\").getBytes(), htdocsDefaultReadme);} catch (IOException e) {\r\n                        System.out.println(\"Error creating htdocs readme: \" + e.getMessage());\r\n                    }\r\n\r\n            final File wwwDefaultPath = new File(htDocsPath, \"www\");\r\n            if (!(wwwDefaultPath.exists())) wwwDefaultPath.mkdir();\r\n\r\n\r\n            final File shareDefaultPath = new File(htDocsPath, \"share\");\r\n            if (!(shareDefaultPath.exists())) shareDefaultPath.mkdir();\r\n\r\n            migration.migrate(sb, oldRev, newRev);\r\n            \r\n            // start main threads\r\n            final String port = sb.getConfig(\"port\", \"8080\");\r\n            try {\r\n                final httpd protocolHandler = new httpd(sb, new httpdFileHandler(sb), new httpdProxyHandler(sb));\r\n                final serverCore server = new serverCore(\r\n                        timeout /*control socket timeout in milliseconds*/,\r\n                        true /* block attacks (wrong protocol) */,\r\n                        protocolHandler /*command class*/,\r\n                        sb,\r\n                        30000 /*command max length incl. GET args*/);\r\n                server.setName(\"httpd:\"+port);\r\n                server.setPriority(Thread.MAX_PRIORITY);\r\n                server.setObeyIntermission(false);\r\n                if (server == null) {\r\n                    serverLog.logSevere(\"STARTUP\", \"Failed to start server. Probably port \" + port + \" already in use.\");\r\n                } else {\r\n                    // first start the server\r\n                    sb.deployThread(\"10_httpd\", \"HTTPD Server/Proxy\", \"the HTTPD, used as web server and proxy\", null, server, 0, 0, 0, 0);\r\n                    //server.start();\r\n\r\n                    // open the browser window\r\n                    final boolean browserPopUpTrigger = sb.getConfig(\"browserPopUpTrigger\", \"true\").equals(\"true\");\r\n                    if (browserPopUpTrigger) {\r\n                        String  browserPopUpPage        = sb.getConfig(\"browserPopUpPage\", \"ConfigBasic.html\");\r\n                        boolean properPW = (sb.getConfig(\"adminAccount\", \"\").length() == 0) && (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0);\r\n                        if (!properPW) browserPopUpPage = \"ConfigBasic.html\";\r\n                        final String  browserPopUpApplication = sb.getConfig(\"browserPopUpApplication\", \"netscape\");\r\n                        serverSystem.openBrowser((server.withSSL()?\"https\":\"http\") + \"://localhost:\" + serverCore.getPortNr(port) + \"/\" + browserPopUpPage, browserPopUpApplication);\r\n                    }\r\n\r\n                    //Copy the shipped locales into DATA\r\n                    final File localesPath = new File(homePath, sb.getConfig(\"localesPath\", \"DATA/LOCALE\"));\r\n                    final File defaultLocalesPath = new File(homePath, \"locales\");\r\n                    \r\n\r\n                    try{\r\n                        final File[] defaultLocales = defaultLocalesPath.listFiles();\r\n                        localesPath.mkdirs();\r\n                        for(int i=0;i < defaultLocales.length; i++){\r\n                            if(defaultLocales[i].getName().endsWith(\".lng\"))\r\n                                serverFileUtils.copy(defaultLocales[i], new File(localesPath, defaultLocales[i].getName()));\r\n                        }\r\n                        serverLog.logInfo(\"STARTUP\", \"Copied the default locales to DATA/LOCALE\");\r\n                    }catch(NullPointerException e){\r\n                        serverLog.logSevere(\"STARTUP\", \"Nullpointer Exception while copying the default Locales\");\r\n                    }\r\n\r\n                    //regenerate Locales from Translationlist, if needed\r\n                    final String lang = sb.getConfig(\"htLocaleSelection\", \"\");\r\n                    if(! lang.equals(\"\") && ! lang.equals(\"default\") ){ //locale is used\r\n                        String currentRev = \"\";\r\n                        try{\r\n                            final BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File( sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang+\"/version\" ))));\r\n                            currentRev = br.readLine();\r\n                            br.close();\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n\r\n                        try{ //seperate try, because we want this, even if the file \"version\" does not exist.\r\n                            if(! currentRev.equals(sb.getConfig(\"svnRevision\", \"\")) ){ //is this another version?!\r\n                                final File sourceDir = new File(sb.getConfig(\"htRootPath\", \"htroot\"));\r\n                                final File destDir = new File(sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang);\r\n                                \r\n                              if(translator.translateFilesRecursive(sourceDir, destDir, new File(\"DATA/LOCALE/\"+lang+\".lng\"), \"html,template,inc\", \"locale\")){ //translate it\r\n                                    //write the new Versionnumber\r\n                                    final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(new File(destDir, \"version\"))));\r\n                                    bw.write(sb.getConfig(\"svnRevision\", \"Error getting Version\"));\r\n                                    bw.close();\r\n                                }\r\n                            }\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n                    }\r\n\r\n                    // registering shutdown hook\r\n                    serverLog.logConfig(\"STARTUP\", \"Registering Shutdown Hook\");\r\n                    final Runtime run = Runtime.getRuntime();\r\n                    run.addShutdownHook(new shutdownHookThread(Thread.currentThread(), sb));\r\n\r\n                    // save information about available memory after all initializations\r\n                    //try {\r\n                        sb.setConfig(\"memoryFreeAfterInitBGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitBGC\", Runtime.getRuntime().totalMemory());\r\n                        System.gc();\r\n                        sb.setConfig(\"memoryFreeAfterInitAGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitAGC\", Runtime.getRuntime().totalMemory());\r\n                    //} catch (ConcurrentModificationException e) {}\r\n                    \r\n                    // signal finished startup\r\n                    startupFinishedSync.V();\r\n                        \r\n                    // wait for server shutdown\r\n                    try {\r\n                        sb.waitForShutdown();\r\n                    } catch (Exception e) {\r\n                        serverLog.logSevere(\"MAIN CONTROL LOOP\", \"PANIC: \" + e.getMessage(),e);\r\n                    }\r\n                    // shut down\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"caught termination signal\");\r\n                    server.terminate(false);\r\n                    server.interrupt();\r\n                    if (server.isAlive()) try {\r\n                        URL u = new URL((server.withSSL()?\"https\":\"http\")+\"://localhost:\" + serverCore.getPortNr(port));\r\n                        httpc.wget(u, u.getHost(), 1000, null, null, null); // kick server\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"sent termination signal to server socket\");\r\n                    } catch (IOException ee) {\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"termination signal to server socket missed (server shutdown, ok)\");\r\n                    }\r\n\r\n                    // idle until the processes are down\r\n                    while (server.isAlive()) {\r\n                        Thread.sleep(2000); // wait a while\r\n                    }\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"server has terminated\");\r\n                    sb.close();\r\n                }\r\n            } catch (Exception e) {\r\n                serverLog.logSevere(\"STARTUP\", \"Unexpected Error: \" + e.getClass().getName(),e);\r\n                //System.exit(1);\r\n            }\r\n        } catch (Exception ee) {\r\n            serverLog.logSevere(\"STARTUP\", \"FATAL ERROR: \" + ee.getMessage(),ee);\r\n        } finally {\r\n        \tstartupFinishedSync.V();\r\n        }\r\n        serverLog.logConfig(\"SHUTDOWN\", \"goodbye. (this is the last line)\");\r\n        //try {\r\n        //    System.exit(0);\r\n        //} catch (Exception e) {} // was once stopped by de.anomic.net.ftpc$sm.checkExit(ftpc.java:1790)\r\n    }","commit_id":"8bff810d1920ada442d71254f70b8b9caaa3548d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n    * Starts up the whole application. Sets up all datastructures and starts\r\n    * the main threads.\r\n    *\r\n    * @param homePath Root-path where all information is to be found.\r\n    * @param startupFree free memory at startup time, to be used later for statistics\r\n    */\r\n    private static void startup(String homePath, long startupMemFree, long startupMemTotal) {\r\n        long startup = System.currentTimeMillis();\r\n\r\n        int oldRev=0;\r\n        int newRev=0;\r\n\r\n        try {\r\n            // start up\r\n            System.out.println(copyright);\r\n            System.out.println(hline);\r\n\r\n            // check java version\r\n            try {\r\n                /*String[] check =*/ \"a,b\".split(\",\"); // split needs java 1.4\r\n            } catch (NoSuchMethodError e) {\r\n                System.err.println(\"STARTUP: Java Version too low. You need at least Java 1.4.2 to run YaCy\");\r\n                Thread.sleep(3000);\r\n                System.exit(-1);\r\n            }\r\n            \r\n            // ensure that there is a DATA directory, if not, create one and if that fails warn and die\r\n            File f = new File(homePath); if (!(f.exists())) f.mkdirs();\r\n            f = new File(homePath, \"DATA/\"); if (!(f.exists())) f.mkdirs();\r\n\t\t\tif (!(f.exists())) { \r\n\t\t\t\tSystem.err.println(\"Error creating DATA-directory in \" + homePath.toString() + \" . Please check your write-permission for this folder. YaCy will now terminate.\"); \r\n\t\t\t\tSystem.exit(-1); \r\n\t\t\t}\r\n            \r\n            // setting up logging\r\n            f = new File(homePath, \"DATA/LOG/\"); if (!(f.exists())) f.mkdirs();\r\n            if (!((new File(homePath, \"DATA/LOG/yacy.logging\")).exists())) try {\r\n                serverFileUtils.copy(new File(homePath, \"yacy.logging\"), new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            }catch (IOException e){\r\n                System.out.println(\"could not copy yacy.logging\");\r\n            }\r\n            try{\r\n                serverLog.configureLogging(homePath,new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            } catch (IOException e) {\r\n                System.out.println(\"could not find logging properties in homePath=\" + homePath);\r\n                e.printStackTrace();\r\n            }\r\n            serverLog.logConfig(\"STARTUP\", \"java version \" + System.getProperty(\"java.version\", \"no-java-version\"));\r\n            serverLog.logConfig(\"STARTUP\", \"Application Root Path: \" + homePath);\r\n            serverLog.logConfig(\"STARTUP\", \"Time Zone: UTC\" + serverDate.UTCDiffString() + \"; UTC+0000 is \" + System.currentTimeMillis());\r\n            serverLog.logConfig(\"STARTUP\", \"Maximum file system path length: \" + serverSystem.maxPathLength);\r\n            \r\n            f = new File(homePath, \"DATA/yacy.running\");\r\n            if (f.exists()) {                // another instance running? VM crash? User will have to care about this\r\n                serverLog.logSevere(\"STARTUP\", \"the file \" + f + \" exists, this usually means that another instance of YaCy is using this DATA-folder.\");\r\n                serverLog.logSevere(\"STARTUP\", \"please make sure that DATA can be used exclusively by one YaCy. Quitting...\");\r\n                System.exit(-1);\r\n            } else {\r\n                f.createNewFile();\r\n                f.deleteOnExit();\r\n            }\r\n\r\n            /*\r\n                // Testing if the yacy archive file were unzipped correctly.\r\n                // This test is needed because of classfile-names longer than 100 chars\r\n                // which could cause problems with incompatible unzip software.\r\n                // See:\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1763\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=715\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1674\r\n                File unzipTest = new File(homePath,\"doc/This_is_a_test_if_the_archive_file_containing_YaCy_was_unpacked_correctly_If_not_please_use_gnu_tar_instead.txt\");\r\n                if (!unzipTest.exists()) {\r\n                    String errorMsg = \"The archive file containing YaCy was not unpacked correctly. \" +\r\n                                      \"Please use 'GNU-Tar' or upgrade to a newer version of your unzip software.\\n\" +\r\n                                      \"For detailed information on this bug see: \" + \r\n                                      \"http://www.yacy-forum.de/viewtopic.php?t=715\";\r\n                    System.err.println(errorMsg);\r\n                    serverLog.logSevere(\"STARTUP\", errorMsg);\r\n                    System.exit(1); \r\n                }\r\n            */                    \r\n            \r\n            sb = new plasmaSwitchboard(homePath, \"yacy.init\", \"DATA/SETTINGS/httpProxy.conf\");\r\n            sbSync.V(); // signal that the sb reference was set\r\n            \r\n            // save information about available memory at startup time\r\n            sb.setConfig(\"memoryFreeAfterStartup\", startupMemFree);\r\n            sb.setConfig(\"memoryTotalAfterStartup\", startupMemTotal);\r\n            \r\n            // hardcoded, forced, temporary value-migration\r\n            sb.setConfig(\"htTemplatePath\", \"htroot/env/templates\");\r\n            sb.setConfig(\"parseableExt\", \"html,htm,txt,php,shtml,asp\");\r\n\r\n            // if we are running an SVN version, we try to detect the used svn revision now ...\r\n            final Properties buildProp = new Properties();\r\n            File buildPropFile = null;\r\n            try {\r\n                buildPropFile = new File(homePath,\"build.properties\");\r\n                buildProp.load(new FileInputStream(buildPropFile));\r\n            } catch (Exception e) {\r\n                serverLog.logWarning(\"STARTUP\", buildPropFile.toString() + \" not found in settings path\");\r\n            }\r\n            \r\n            oldRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            try {\r\n                if (buildProp.containsKey(\"releaseNr\")) {\r\n                    // this normally looks like this: $Revision$\r\n                    final String svnReleaseNrStr = buildProp.getProperty(\"releaseNr\");\r\n                    final Pattern pattern = Pattern.compile(\"\\\\$Revision:\\\\s(.*)\\\\s\\\\$\",Pattern.DOTALL+Pattern.CASE_INSENSITIVE);\r\n                    final Matcher matcher = pattern.matcher(svnReleaseNrStr);\r\n                    if (matcher.find()) {\r\n                        final String svrReleaseNr = matcher.group(1);\r\n                        try {\r\n                            try {version = Double.parseDouble(vString);} catch (NumberFormatException e) {version = (float) 0.1;}\r\n                            version = versvn2combinedVersion(version, Integer.parseInt(svrReleaseNr));\r\n                        } catch (NumberFormatException e) {}\r\n                        sb.setConfig(\"svnRevision\", svrReleaseNr);\r\n                    }\r\n                }\r\n                newRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            } catch (Exception e) {\r\n                System.err.println(\"Unable to determine the currently used SVN revision number.\");\r\n            }\r\n\r\n            sb.setConfig(\"version\", Double.toString(version));\r\n            sb.setConfig(\"vString\", combined2prettyVersion(Double.toString(version)));\r\n            sb.setConfig(\"vdate\", vDATE);\r\n            sb.setConfig(\"applicationRoot\", homePath);\r\n            sb.startupTime = startup;\r\n            serverLog.logConfig(\"STARTUP\", \"YACY Version: \" + version + \", Built \" + vDATE);\r\n            yacyVersion.latestRelease = version;\r\n\r\n            // read environment\r\n            int timeout = Math.max(20000, Integer.parseInt(sb.getConfig(\"httpdTimeout\", \"20000\")));\r\n\r\n            // create some directories\r\n            final File htRootPath = new File(homePath, sb.getConfig(\"htRootPath\", \"htroot\"));\r\n            final File htDocsPath = new File(homePath, sb.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\r\n            if (!(htDocsPath.exists())) htDocsPath.mkdir();\r\n            //final File htTemplatePath = new File(homePath, sb.getConfig(\"htTemplatePath\",\"htdocs\"));\r\n\r\n            // create default notifier picture\r\n            //TODO: Use templates instead of copying images ...\r\n            if (!((new File(htDocsPath, \"notifier.gif\")).exists())) try {\r\n                serverFileUtils.copy(new File(htRootPath, \"env/grafics/empty.gif\"),\r\n                                     new File(htDocsPath, \"notifier.gif\"));\r\n            } catch (IOException e) {}\r\n\r\n            final File htdocsDefaultReadme = new File(htDocsPath, \"readme.txt\");\r\n            if (!(htdocsDefaultReadme.exists())) try {serverFileUtils.write((\r\n                    \"This is your root directory for individual Web Content\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Please place your html files into the www subdirectory.\\r\\n\" +\r\n                    \"The URL of that path is either\\r\\n\" +\r\n                    \"http://www.<your-peer-name>.yacy    or\\r\\n\" +\r\n                    \"http://<your-ip>:<your-port>/www\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Other subdirectories may be created; they map to corresponding sub-domains.\\r\\n\" +\r\n                    \"This directory shares it's content with the applications htroot path, so you\\r\\n\" +\r\n                    \"may access your yacy search page with\\r\\n\" +\r\n                    \"http://<your-peer-name>.yacy/\\r\\n\" +\r\n                    \"\\r\\n\").getBytes(), htdocsDefaultReadme);} catch (IOException e) {\r\n                        System.out.println(\"Error creating htdocs readme: \" + e.getMessage());\r\n                    }\r\n\r\n            final File wwwDefaultPath = new File(htDocsPath, \"www\");\r\n            if (!(wwwDefaultPath.exists())) wwwDefaultPath.mkdir();\r\n\r\n\r\n            final File shareDefaultPath = new File(htDocsPath, \"share\");\r\n            if (!(shareDefaultPath.exists())) shareDefaultPath.mkdir();\r\n\r\n            migration.migrate(sb, oldRev, newRev);\r\n            \r\n            // start main threads\r\n            final String port = sb.getConfig(\"port\", \"8080\");\r\n            try {\r\n                final httpd protocolHandler = new httpd(sb, new httpdFileHandler(sb), new httpdProxyHandler(sb));\r\n                final serverCore server = new serverCore(\r\n                        timeout /*control socket timeout in milliseconds*/,\r\n                        true /* block attacks (wrong protocol) */,\r\n                        protocolHandler /*command class*/,\r\n                        sb,\r\n                        30000 /*command max length incl. GET args*/);\r\n                server.setName(\"httpd:\"+port);\r\n                server.setPriority(Thread.MAX_PRIORITY);\r\n                server.setObeyIntermission(false);\r\n                if (server == null) {\r\n                    serverLog.logSevere(\"STARTUP\", \"Failed to start server. Probably port \" + port + \" already in use.\");\r\n                } else {\r\n                    // first start the server\r\n                    sb.deployThread(\"10_httpd\", \"HTTPD Server/Proxy\", \"the HTTPD, used as web server and proxy\", null, server, 0, 0, 0, 0);\r\n                    //server.start();\r\n\r\n                    // open the browser window\r\n                    final boolean browserPopUpTrigger = sb.getConfig(\"browserPopUpTrigger\", \"true\").equals(\"true\");\r\n                    if (browserPopUpTrigger) {\r\n                        String  browserPopUpPage        = sb.getConfig(\"browserPopUpPage\", \"ConfigBasic.html\");\r\n                        boolean properPW = (sb.getConfig(\"adminAccount\", \"\").length() == 0) && (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0);\r\n                        if (!properPW) browserPopUpPage = \"ConfigBasic.html\";\r\n                        final String  browserPopUpApplication = sb.getConfig(\"browserPopUpApplication\", \"netscape\");\r\n                        serverSystem.openBrowser((server.withSSL()?\"https\":\"http\") + \"://localhost:\" + serverCore.getPortNr(port) + \"/\" + browserPopUpPage, browserPopUpApplication);\r\n                    }\r\n\r\n                    //Copy the shipped locales into DATA\r\n                    final File localesPath = new File(homePath, sb.getConfig(\"localesPath\", \"DATA/LOCALE\"));\r\n                    final File defaultLocalesPath = new File(homePath, \"locales\");\r\n                    \r\n\r\n                    try{\r\n                        final File[] defaultLocales = defaultLocalesPath.listFiles();\r\n                        localesPath.mkdirs();\r\n                        for(int i=0;i < defaultLocales.length; i++){\r\n                            if(defaultLocales[i].getName().endsWith(\".lng\"))\r\n                                serverFileUtils.copy(defaultLocales[i], new File(localesPath, defaultLocales[i].getName()));\r\n                        }\r\n                        serverLog.logInfo(\"STARTUP\", \"Copied the default locales to DATA/LOCALE\");\r\n                    }catch(NullPointerException e){\r\n                        serverLog.logSevere(\"STARTUP\", \"Nullpointer Exception while copying the default Locales\");\r\n                    }\r\n\r\n                    //regenerate Locales from Translationlist, if needed\r\n                    final String lang = sb.getConfig(\"htLocaleSelection\", \"\");\r\n                    if(! lang.equals(\"\") && ! lang.equals(\"default\") ){ //locale is used\r\n                        String currentRev = \"\";\r\n                        try{\r\n                            final BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File( sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang+\"/version\" ))));\r\n                            currentRev = br.readLine();\r\n                            br.close();\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n\r\n                        try{ //seperate try, because we want this, even if the file \"version\" does not exist.\r\n                            if(! currentRev.equals(sb.getConfig(\"svnRevision\", \"\")) ){ //is this another version?!\r\n                                final File sourceDir = new File(sb.getConfig(\"htRootPath\", \"htroot\"));\r\n                                final File destDir = new File(sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang);\r\n                                \r\n                              if(translator.translateFilesRecursive(sourceDir, destDir, new File(\"DATA/LOCALE/\"+lang+\".lng\"), \"html,template,inc\", \"locale\")){ //translate it\r\n                                    //write the new Versionnumber\r\n                                    final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(new File(destDir, \"version\"))));\r\n                                    bw.write(sb.getConfig(\"svnRevision\", \"Error getting Version\"));\r\n                                    bw.close();\r\n                                }\r\n                            }\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n                    }\r\n\r\n                    // registering shutdown hook\r\n                    serverLog.logConfig(\"STARTUP\", \"Registering Shutdown Hook\");\r\n                    final Runtime run = Runtime.getRuntime();\r\n                    run.addShutdownHook(new shutdownHookThread(Thread.currentThread(), sb));\r\n\r\n                    // save information about available memory after all initializations\r\n                    //try {\r\n                        sb.setConfig(\"memoryFreeAfterInitBGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitBGC\", Runtime.getRuntime().totalMemory());\r\n                        System.gc();\r\n                        sb.setConfig(\"memoryFreeAfterInitAGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitAGC\", Runtime.getRuntime().totalMemory());\r\n                    //} catch (ConcurrentModificationException e) {}\r\n                    \r\n                    // signal finished startup\r\n                    startupFinishedSync.V();\r\n                        \r\n                    // wait for server shutdown\r\n                    try {\r\n                        sb.waitForShutdown();\r\n                    } catch (Exception e) {\r\n                        serverLog.logSevere(\"MAIN CONTROL LOOP\", \"PANIC: \" + e.getMessage(),e);\r\n                    }\r\n                    // shut down\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"caught termination signal\");\r\n                    server.terminate(false);\r\n                    server.interrupt();\r\n                    if (server.isAlive()) try {\r\n                        URL u = new URL((server.withSSL()?\"https\":\"http\")+\"://localhost:\" + serverCore.getPortNr(port));\r\n                        httpc.wget(u, u.getHost(), 1000, null, null, null); // kick server\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"sent termination signal to server socket\");\r\n                    } catch (IOException ee) {\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"termination signal to server socket missed (server shutdown, ok)\");\r\n                    }\r\n\r\n                    // idle until the processes are down\r\n                    while (server.isAlive()) {\r\n                        Thread.sleep(2000); // wait a while\r\n                    }\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"server has terminated\");\r\n                    sb.close();\r\n                }\r\n            } catch (Exception e) {\r\n                serverLog.logSevere(\"STARTUP\", \"Unexpected Error: \" + e.getClass().getName(),e);\r\n                //System.exit(1);\r\n            }\r\n        } catch (Exception ee) {\r\n            serverLog.logSevere(\"STARTUP\", \"FATAL ERROR: \" + ee.getMessage(),ee);\r\n        } finally {\r\n        \tstartupFinishedSync.V();\r\n        }\r\n        serverLog.logConfig(\"SHUTDOWN\", \"goodbye. (this is the last line)\");\r\n        //try {\r\n        //    System.exit(0);\r\n        //} catch (Exception e) {} // was once stopped by de.anomic.net.ftpc$sm.checkExit(ftpc.java:1790)\r\n    }","id":47817,"modified_method":"/**\r\n    * Starts up the whole application. Sets up all datastructures and starts\r\n    * the main threads.\r\n    *\r\n    * @param homePath Root-path where all information is to be found.\r\n    * @param startupFree free memory at startup time, to be used later for statistics\r\n    */\r\n    private static void startup(String homePath, long startupMemFree, long startupMemTotal) {\r\n        long startup = System.currentTimeMillis();\r\n\r\n        int oldRev=0;\r\n        int newRev=0;\r\n\r\n        try {\r\n            // start up\r\n            System.out.println(copyright);\r\n            System.out.println(hline);\r\n\r\n            // check java version\r\n            try {\r\n                /*String[] check =*/ \"a,b\".split(\",\"); // split needs java 1.4\r\n            } catch (NoSuchMethodError e) {\r\n                System.err.println(\"STARTUP: Java Version too low. You need at least Java 1.4.2 to run YaCy\");\r\n                Thread.sleep(3000);\r\n                System.exit(-1);\r\n            }\r\n            \r\n            // ensure that there is a DATA directory, if not, create one and if that fails warn and die\r\n            File f = new File(homePath); if (!(f.exists())) f.mkdirs();\r\n            f = new File(homePath, \"DATA/\"); if (!(f.exists())) f.mkdirs();\r\n\t\t\tif (!(f.exists())) { \r\n\t\t\t\tSystem.err.println(\"Error creating DATA-directory in \" + homePath.toString() + \" . Please check your write-permission for this folder. YaCy will now terminate.\"); \r\n\t\t\t\tSystem.exit(-1); \r\n\t\t\t}\r\n            \r\n            // setting up logging\r\n            f = new File(homePath, \"DATA/LOG/\"); if (!(f.exists())) f.mkdirs();\r\n            if (!((new File(homePath, \"DATA/LOG/yacy.logging\")).exists())) try {\r\n                serverFileUtils.copy(new File(homePath, \"yacy.logging\"), new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            }catch (IOException e){\r\n                System.out.println(\"could not copy yacy.logging\");\r\n            }\r\n            try{\r\n                serverLog.configureLogging(homePath,new File(homePath, \"DATA/LOG/yacy.logging\"));\r\n            } catch (IOException e) {\r\n                System.out.println(\"could not find logging properties in homePath=\" + homePath);\r\n                e.printStackTrace();\r\n            }\r\n            serverLog.logConfig(\"STARTUP\", \"java version \" + System.getProperty(\"java.version\", \"no-java-version\"));\r\n            serverLog.logConfig(\"STARTUP\", \"Application Root Path: \" + homePath);\r\n            serverLog.logConfig(\"STARTUP\", \"Time Zone: UTC\" + serverDate.UTCDiffString() + \"; UTC+0000 is \" + System.currentTimeMillis());\r\n            serverLog.logConfig(\"STARTUP\", \"Maximum file system path length: \" + serverSystem.maxPathLength);\r\n            \r\n            f = new File(homePath, \"DATA/yacy.running\");\r\n            if (f.exists()) {                // another instance running? VM crash? User will have to care about this\r\n                serverLog.logSevere(\"STARTUP\", \"the file \" + f + \" exists, this usually means that another instance of YaCy is using this DATA-folder.\");\r\n                serverLog.logSevere(\"STARTUP\", \"please make sure that DATA can be used exclusively by one YaCy. Quitting...\");\r\n                f.delete();\r\n            }\r\n            f.createNewFile();\r\n            f.deleteOnExit();\r\n\r\n            /*\r\n                // Testing if the yacy archive file were unzipped correctly.\r\n                // This test is needed because of classfile-names longer than 100 chars\r\n                // which could cause problems with incompatible unzip software.\r\n                // See:\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1763\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=715\r\n                // - http://www.yacy-forum.de/viewtopic.php?t=1674\r\n                File unzipTest = new File(homePath,\"doc/This_is_a_test_if_the_archive_file_containing_YaCy_was_unpacked_correctly_If_not_please_use_gnu_tar_instead.txt\");\r\n                if (!unzipTest.exists()) {\r\n                    String errorMsg = \"The archive file containing YaCy was not unpacked correctly. \" +\r\n                                      \"Please use 'GNU-Tar' or upgrade to a newer version of your unzip software.\\n\" +\r\n                                      \"For detailed information on this bug see: \" + \r\n                                      \"http://www.yacy-forum.de/viewtopic.php?t=715\";\r\n                    System.err.println(errorMsg);\r\n                    serverLog.logSevere(\"STARTUP\", errorMsg);\r\n                    System.exit(1); \r\n                }\r\n            */                    \r\n            \r\n            sb = new plasmaSwitchboard(homePath, \"yacy.init\", \"DATA/SETTINGS/httpProxy.conf\");\r\n            sbSync.V(); // signal that the sb reference was set\r\n            \r\n            // save information about available memory at startup time\r\n            sb.setConfig(\"memoryFreeAfterStartup\", startupMemFree);\r\n            sb.setConfig(\"memoryTotalAfterStartup\", startupMemTotal);\r\n            \r\n            // hardcoded, forced, temporary value-migration\r\n            sb.setConfig(\"htTemplatePath\", \"htroot/env/templates\");\r\n            sb.setConfig(\"parseableExt\", \"html,htm,txt,php,shtml,asp\");\r\n\r\n            // if we are running an SVN version, we try to detect the used svn revision now ...\r\n            final Properties buildProp = new Properties();\r\n            File buildPropFile = null;\r\n            try {\r\n                buildPropFile = new File(homePath,\"build.properties\");\r\n                buildProp.load(new FileInputStream(buildPropFile));\r\n            } catch (Exception e) {\r\n                serverLog.logWarning(\"STARTUP\", buildPropFile.toString() + \" not found in settings path\");\r\n            }\r\n            \r\n            oldRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            try {\r\n                if (buildProp.containsKey(\"releaseNr\")) {\r\n                    // this normally looks like this: $Revision$\r\n                    final String svnReleaseNrStr = buildProp.getProperty(\"releaseNr\");\r\n                    final Pattern pattern = Pattern.compile(\"\\\\$Revision:\\\\s(.*)\\\\s\\\\$\",Pattern.DOTALL+Pattern.CASE_INSENSITIVE);\r\n                    final Matcher matcher = pattern.matcher(svnReleaseNrStr);\r\n                    if (matcher.find()) {\r\n                        final String svrReleaseNr = matcher.group(1);\r\n                        try {\r\n                            try {version = Double.parseDouble(vString);} catch (NumberFormatException e) {version = (float) 0.1;}\r\n                            version = versvn2combinedVersion(version, Integer.parseInt(svrReleaseNr));\r\n                        } catch (NumberFormatException e) {}\r\n                        sb.setConfig(\"svnRevision\", svrReleaseNr);\r\n                    }\r\n                }\r\n                newRev=Integer.parseInt(sb.getConfig(\"svnRevision\", \"0\"));\r\n            } catch (Exception e) {\r\n                System.err.println(\"Unable to determine the currently used SVN revision number.\");\r\n            }\r\n\r\n            sb.setConfig(\"version\", Double.toString(version));\r\n            sb.setConfig(\"vString\", combined2prettyVersion(Double.toString(version)));\r\n            sb.setConfig(\"vdate\", vDATE);\r\n            sb.setConfig(\"applicationRoot\", homePath);\r\n            sb.startupTime = startup;\r\n            serverLog.logConfig(\"STARTUP\", \"YACY Version: \" + version + \", Built \" + vDATE);\r\n            yacyVersion.latestRelease = version;\r\n\r\n            // read environment\r\n            int timeout = Math.max(20000, Integer.parseInt(sb.getConfig(\"httpdTimeout\", \"20000\")));\r\n\r\n            // create some directories\r\n            final File htRootPath = new File(homePath, sb.getConfig(\"htRootPath\", \"htroot\"));\r\n            final File htDocsPath = new File(homePath, sb.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\r\n            if (!(htDocsPath.exists())) htDocsPath.mkdir();\r\n            //final File htTemplatePath = new File(homePath, sb.getConfig(\"htTemplatePath\",\"htdocs\"));\r\n\r\n            // create default notifier picture\r\n            //TODO: Use templates instead of copying images ...\r\n            if (!((new File(htDocsPath, \"notifier.gif\")).exists())) try {\r\n                serverFileUtils.copy(new File(htRootPath, \"env/grafics/empty.gif\"),\r\n                                     new File(htDocsPath, \"notifier.gif\"));\r\n            } catch (IOException e) {}\r\n\r\n            final File htdocsDefaultReadme = new File(htDocsPath, \"readme.txt\");\r\n            if (!(htdocsDefaultReadme.exists())) try {serverFileUtils.write((\r\n                    \"This is your root directory for individual Web Content\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Please place your html files into the www subdirectory.\\r\\n\" +\r\n                    \"The URL of that path is either\\r\\n\" +\r\n                    \"http://www.<your-peer-name>.yacy    or\\r\\n\" +\r\n                    \"http://<your-ip>:<your-port>/www\\r\\n\" +\r\n                    \"\\r\\n\" +\r\n                    \"Other subdirectories may be created; they map to corresponding sub-domains.\\r\\n\" +\r\n                    \"This directory shares it's content with the applications htroot path, so you\\r\\n\" +\r\n                    \"may access your yacy search page with\\r\\n\" +\r\n                    \"http://<your-peer-name>.yacy/\\r\\n\" +\r\n                    \"\\r\\n\").getBytes(), htdocsDefaultReadme);} catch (IOException e) {\r\n                        System.out.println(\"Error creating htdocs readme: \" + e.getMessage());\r\n                    }\r\n\r\n            final File wwwDefaultPath = new File(htDocsPath, \"www\");\r\n            if (!(wwwDefaultPath.exists())) wwwDefaultPath.mkdir();\r\n\r\n\r\n            final File shareDefaultPath = new File(htDocsPath, \"share\");\r\n            if (!(shareDefaultPath.exists())) shareDefaultPath.mkdir();\r\n\r\n            migration.migrate(sb, oldRev, newRev);\r\n            \r\n            // start main threads\r\n            final String port = sb.getConfig(\"port\", \"8080\");\r\n            try {\r\n                final httpd protocolHandler = new httpd(sb, new httpdFileHandler(sb), new httpdProxyHandler(sb));\r\n                final serverCore server = new serverCore(\r\n                        timeout /*control socket timeout in milliseconds*/,\r\n                        true /* block attacks (wrong protocol) */,\r\n                        protocolHandler /*command class*/,\r\n                        sb,\r\n                        30000 /*command max length incl. GET args*/);\r\n                server.setName(\"httpd:\"+port);\r\n                server.setPriority(Thread.MAX_PRIORITY);\r\n                server.setObeyIntermission(false);\r\n                if (server == null) {\r\n                    serverLog.logSevere(\"STARTUP\", \"Failed to start server. Probably port \" + port + \" already in use.\");\r\n                } else {\r\n                    // first start the server\r\n                    sb.deployThread(\"10_httpd\", \"HTTPD Server/Proxy\", \"the HTTPD, used as web server and proxy\", null, server, 0, 0, 0, 0);\r\n                    //server.start();\r\n\r\n                    // open the browser window\r\n                    final boolean browserPopUpTrigger = sb.getConfig(\"browserPopUpTrigger\", \"true\").equals(\"true\");\r\n                    if (browserPopUpTrigger) {\r\n                        String  browserPopUpPage        = sb.getConfig(\"browserPopUpPage\", \"ConfigBasic.html\");\r\n                        boolean properPW = (sb.getConfig(\"adminAccount\", \"\").length() == 0) && (sb.getConfig(httpd.ADMIN_ACCOUNT_B64MD5, \"\").length() > 0);\r\n                        if (!properPW) browserPopUpPage = \"ConfigBasic.html\";\r\n                        final String  browserPopUpApplication = sb.getConfig(\"browserPopUpApplication\", \"netscape\");\r\n                        serverSystem.openBrowser((server.withSSL()?\"https\":\"http\") + \"://localhost:\" + serverCore.getPortNr(port) + \"/\" + browserPopUpPage, browserPopUpApplication);\r\n                    }\r\n\r\n                    //Copy the shipped locales into DATA\r\n                    final File localesPath = new File(homePath, sb.getConfig(\"localesPath\", \"DATA/LOCALE\"));\r\n                    final File defaultLocalesPath = new File(homePath, \"locales\");\r\n                    \r\n\r\n                    try{\r\n                        final File[] defaultLocales = defaultLocalesPath.listFiles();\r\n                        localesPath.mkdirs();\r\n                        for(int i=0;i < defaultLocales.length; i++){\r\n                            if(defaultLocales[i].getName().endsWith(\".lng\"))\r\n                                serverFileUtils.copy(defaultLocales[i], new File(localesPath, defaultLocales[i].getName()));\r\n                        }\r\n                        serverLog.logInfo(\"STARTUP\", \"Copied the default locales to DATA/LOCALE\");\r\n                    }catch(NullPointerException e){\r\n                        serverLog.logSevere(\"STARTUP\", \"Nullpointer Exception while copying the default Locales\");\r\n                    }\r\n\r\n                    //regenerate Locales from Translationlist, if needed\r\n                    final String lang = sb.getConfig(\"htLocaleSelection\", \"\");\r\n                    if(! lang.equals(\"\") && ! lang.equals(\"default\") ){ //locale is used\r\n                        String currentRev = \"\";\r\n                        try{\r\n                            final BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File( sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang+\"/version\" ))));\r\n                            currentRev = br.readLine();\r\n                            br.close();\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n\r\n                        try{ //seperate try, because we want this, even if the file \"version\" does not exist.\r\n                            if(! currentRev.equals(sb.getConfig(\"svnRevision\", \"\")) ){ //is this another version?!\r\n                                final File sourceDir = new File(sb.getConfig(\"htRootPath\", \"htroot\"));\r\n                                final File destDir = new File(sb.getConfig(\"htLocalePath\", \"DATA/HTDOCS/locale\"), lang);\r\n                                \r\n                              if(translator.translateFilesRecursive(sourceDir, destDir, new File(\"DATA/LOCALE/\"+lang+\".lng\"), \"html,template,inc\", \"locale\")){ //translate it\r\n                                    //write the new Versionnumber\r\n                                    final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(new File(destDir, \"version\"))));\r\n                                    bw.write(sb.getConfig(\"svnRevision\", \"Error getting Version\"));\r\n                                    bw.close();\r\n                                }\r\n                            }\r\n                        }catch(IOException e){\r\n                            //Error\r\n                        }\r\n                    }\r\n\r\n                    // registering shutdown hook\r\n                    serverLog.logConfig(\"STARTUP\", \"Registering Shutdown Hook\");\r\n                    final Runtime run = Runtime.getRuntime();\r\n                    run.addShutdownHook(new shutdownHookThread(Thread.currentThread(), sb));\r\n\r\n                    // save information about available memory after all initializations\r\n                    //try {\r\n                        sb.setConfig(\"memoryFreeAfterInitBGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitBGC\", Runtime.getRuntime().totalMemory());\r\n                        System.gc();\r\n                        sb.setConfig(\"memoryFreeAfterInitAGC\", Runtime.getRuntime().freeMemory());\r\n                        sb.setConfig(\"memoryTotalAfterInitAGC\", Runtime.getRuntime().totalMemory());\r\n                    //} catch (ConcurrentModificationException e) {}\r\n                    \r\n                    // signal finished startup\r\n                    startupFinishedSync.V();\r\n                        \r\n                    // wait for server shutdown\r\n                    try {\r\n                        sb.waitForShutdown();\r\n                    } catch (Exception e) {\r\n                        serverLog.logSevere(\"MAIN CONTROL LOOP\", \"PANIC: \" + e.getMessage(),e);\r\n                    }\r\n                    // shut down\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"caught termination signal\");\r\n                    server.terminate(false);\r\n                    server.interrupt();\r\n                    if (server.isAlive()) try {\r\n                        URL u = new URL((server.withSSL()?\"https\":\"http\")+\"://localhost:\" + serverCore.getPortNr(port));\r\n                        httpc.wget(u, u.getHost(), 1000, null, null, null); // kick server\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"sent termination signal to server socket\");\r\n                    } catch (IOException ee) {\r\n                        serverLog.logConfig(\"SHUTDOWN\", \"termination signal to server socket missed (server shutdown, ok)\");\r\n                    }\r\n\r\n                    // idle until the processes are down\r\n                    while (server.isAlive()) {\r\n                        Thread.sleep(2000); // wait a while\r\n                    }\r\n                    serverLog.logConfig(\"SHUTDOWN\", \"server has terminated\");\r\n                    sb.close();\r\n                }\r\n            } catch (Exception e) {\r\n                serverLog.logSevere(\"STARTUP\", \"Unexpected Error: \" + e.getClass().getName(),e);\r\n                //System.exit(1);\r\n            }\r\n        } catch (Exception ee) {\r\n            serverLog.logSevere(\"STARTUP\", \"FATAL ERROR: \" + ee.getMessage(),ee);\r\n        } finally {\r\n        \tstartupFinishedSync.V();\r\n        }\r\n        serverLog.logConfig(\"SHUTDOWN\", \"goodbye. (this is the last line)\");\r\n        //try {\r\n        //    System.exit(0);\r\n        //} catch (Exception e) {} // was once stopped by de.anomic.net.ftpc$sm.checkExit(ftpc.java:1790)\r\n    }","commit_id":"f64d9f1c6c7043989f1df5e4542fbdfbb930adbd","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * If you do have an init script that's a resource, this will extract it based on the name and write it to a temporary file and delete it on exit.\n     *\n     * @param resourceClass the class associated with the resource\n     * @param resourceName the name (minus extension or '.') of the resource\n     */\n    protected File extractInitScriptFile(Class resourceClass, String resourceName) {\n        File file = null;\n        try {\n            file = File.createTempFile(resourceName, INIT_SCRIPT_EXTENSION);\n        } catch (IOException e) {\n            logger.error(\"Creating init script file temp file\", e);\n            return null;\n        }\n        file.deleteOnExit();\n\n        if (extractResourceAsFile(resourceClass, resourceName + INIT_SCRIPT_EXTENSION, file)) {\n            return file;\n        }\n\n        logger.error(\"Internal error! Failed to extract init script for executing commands!\");\n\n        return null;\n    }","id":47818,"modified_method":"/**\n     * If you do have an init script that's a resource, this will extract it based on the name and write it to a temporary file and delete it on exit.\n     *\n     * @param resourceClass the class associated with the resource\n     * @param resourceName the name (minus extension or '.') of the resource\n     */\n    protected File extractInitScriptFile(Class resourceClass, String resourceName) {\n        File file = null;\n        try {\n            file = temporaryFileProvider.createTemporaryFile(resourceName, INIT_SCRIPT_EXTENSION);\n        } catch (UncheckedIOException e) {\n            logger.error(\"Creating init script file temp file\", e);\n            return null;\n        }\n        file.deleteOnExit();\n\n        if (extractResourceAsFile(resourceClass, resourceName + INIT_SCRIPT_EXTENSION, file)) {\n            return file;\n        }\n\n        logger.error(\"Internal error! Failed to extract init script for executing commands!\");\n\n        return null;\n    }","commit_id":"c1c1df2c8fa6c368187591a56f53668735e923b1","url":"https://github.com/gradle/gradle"},{"original_method":"private File createClasspathJarFile(WorkerProcessBuilder processBuilder) {\n        try {\n            File classpathJarFile = File.createTempFile(\"GradleWorkerProcess\", \"classpath.jar\");\n            new ClasspathJarFactory().createClasspathJarFile(classpathJarFile, processBuilder.getApplicationClasspath());\n            classpathJarFile.deleteOnExit();\n            return classpathJarFile;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }","id":47819,"modified_method":"private File createClasspathJarFile(WorkerProcessBuilder processBuilder) {\n        try {\n            File classpathJarFile = temporaryFileProvider.createTemporaryFile(\"GradleWorkerProcess\", \"classpath.jar\");\n            new ClasspathJarFactory().createClasspathJarFile(classpathJarFile, processBuilder.getApplicationClasspath());\n            classpathJarFile.deleteOnExit();\n            return classpathJarFile;\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }","commit_id":"c1c1df2c8fa6c368187591a56f53668735e923b1","url":"https://github.com/gradle/gradle"},{"original_method":"public void supply(InstallDeployTaskSupport installDeployTaskSupport) {\n        try {\n            settingsXml = File.createTempFile(\"gradle_empty_settings\", \".xml\");\n            FileUtils.writeStringToFile(settingsXml, \"<settings/>\");\n            settingsXml.deleteOnExit();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        installDeployTaskSupport.setSettingsFile(settingsXml);\n    }","id":47820,"modified_method":"public void supply(InstallDeployTaskSupport installDeployTaskSupport) {\n        try {\n            settingsXml = temporaryFileProvider.createTemporaryFile(\"gradle_empty_settings\", \".xml\");\n            FileUtils.writeStringToFile(settingsXml, \"<settings/>\");\n            settingsXml.deleteOnExit();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        installDeployTaskSupport.setSettingsFile(settingsXml);\n    }","commit_id":"c1c1df2c8fa6c368187591a56f53668735e923b1","url":"https://github.com/gradle/gradle"},{"original_method":"public File prepareProjectDir(File projectDir) {\n        if (projectDir == null) {\n            try {\n                projectDir = GFileUtils.canonicalise(File.createTempFile(\"gradle\", \"projectDir\"));\n                projectDir.delete();\n                projectDir.mkdir();\n                projectDir.deleteOnExit();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        } else {\n            projectDir = GFileUtils.canonicalise(projectDir);\n        }\n        return projectDir;\n    }","id":47821,"modified_method":"public File prepareProjectDir(File projectDir) {\n        if (projectDir == null) {\n            TemporaryFileProvider temporaryFileProvider = new TmpDirTemporaryFileProvider();\n            projectDir = temporaryFileProvider.createTemporaryDirectory(\"gradle\", \"projectDir\");\n            // TODO deleteOnExit won't clean up non-empty directories (and it leaks memory for long-running processes).\n            projectDir.deleteOnExit();\n        } else {\n            projectDir = GFileUtils.canonicalise(projectDir);\n        }\n        return projectDir;\n    }","commit_id":"c1c1df2c8fa6c368187591a56f53668735e923b1","url":"https://github.com/gradle/gradle"},{"original_method":"private void putChecksum(Artifact artifact, File src, String destination, boolean overwrite,\n                               String algorithm) throws IOException {\n        File csFile = File.createTempFile(\"ivytemp\", algorithm);\n        try {\n            FileUtil.copy(new ByteArrayInputStream(ChecksumHelper.computeAsString(src, algorithm)\n                    .getBytes()), csFile, null);\n            repository.put(DefaultArtifact.cloneWithAnotherTypeAndExt(artifact, algorithm,\n                    artifact.getExt() + \".\" + algorithm), csFile, destination + \".\" + algorithm, overwrite);\n        } finally {\n            csFile.delete();\n        }\n    }","id":47822,"modified_method":"private void putChecksum(Artifact artifact, File src, String destination, boolean overwrite,\n                               String algorithm) throws IOException {\n        File csFile = temporaryFileProvider.createTemporaryFile(\"ivytemp\", algorithm);\n        try {\n            FileUtil.copy(new ByteArrayInputStream(ChecksumHelper.computeAsString(src, algorithm)\n                    .getBytes()), csFile, null);\n            repository.put(DefaultArtifact.cloneWithAnotherTypeAndExt(artifact, algorithm,\n                    artifact.getExt() + \".\" + algorithm), csFile, destination + \".\" + algorithm, overwrite);\n        } finally {\n            csFile.delete();\n        }\n    }","commit_id":"c1c1df2c8fa6c368187591a56f53668735e923b1","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n\tpublic void testUploadTimeout() throws Exception {\n\t\tFile file = new File(TEST_FILE_PATH);\n\t\tString uploadKey = uploadFile(file);\n\t\tFile uploadedFile = assertUploadedFileExists(file, uploadKey);\n\t\tString parentPath = uploadedFile.getParentFile().getAbsolutePath();\n\t\t\n\t\tThread.sleep(CLEANUP_TIMOUT_SECONDS * 2000);\n\t\t\n\t\tFile expectedToBeDeletedFolder = new File(parentPath);\n\t\tAssert.assertFalse(expectedToBeDeletedFolder.exists());\n\t}","id":47823,"modified_method":"@Test\n    public void testUploadTimeout() throws Exception {\n        File file = new File(TEST_FILE_PATH);\n        UploadResponse uploadResponse = uploadFile(file);\n        String uploadKey = uploadResponse.getUploadKey();\n        Assert.assertNotNull(uploadKey);\n        File uploadedFile = assertUploadedFileExists(file, uploadKey);\n        String parentPath = uploadedFile.getParentFile().getAbsolutePath();\n\n        Thread.sleep(TEST_CLEANUP_TIMOUT_MILLIS * 3);\n\n        File expectedToBeDeletedFolder = new File(parentPath);\n        Assert.assertFalse(expectedToBeDeletedFolder.exists());\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Before\n\tpublic void init() throws NoSuchMethodException, IOException {\n\t\tcontroller = applicationContext.getBean(UploadController.class);\n\t\tuploadRepo = applicationContext.getBean(UploadRepo.class);\n\t\tuploadRepo.resetTimeout(CLEANUP_TIMOUT_SECONDS);\n\t\tcontrollerMapping = new HashMap<String, HashMap<RequestMethod, HandlerMethod>>();\n\t\tHashMap<RequestMethod, HandlerMethod> map = new HashMap<RequestMethod, HandlerMethod>();\n\t\tHandlerMethod method = new HandlerMethod(controller, \"upload\", String.class, MultipartFile.class);\n\t\tmap.put(RequestMethod.POST, method);\n\t\tcontrollerMapping.put(UPLOAD_URI, map);\n\t}","id":47824,"modified_method":"@Before\n    public void init() throws NoSuchMethodException, IOException {\n        String version = PlatformVersion.getVersion();\n        versionedUploadUri = \"/\" + version + UPLOAD_URI;\n        controller = applicationContext.getBean(UploadController.class);\n        uploadRepo = applicationContext.getBean(UploadRepo.class);\n        uploadRepo.resetTimeout(TEST_CLEANUP_TIMOUT_MILLIS);\n        controllerMapping = new HashMap<String, HashMap<RequestMethod, HandlerMethod>>();\n        HashMap<RequestMethod, HandlerMethod> map = new HashMap<RequestMethod, HandlerMethod>();\n        HandlerMethod method = new HandlerMethod(controller, \"upload\", String.class, MultipartFile.class);\n        map.put(RequestMethod.POST, method);\n        controllerMapping.put(versionedUploadUri, map);\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testUploadExceededSizeLimitFile() throws Exception {\n\t\tcontroller.setUploadSizeLimitBytes(UPLOAD_SIZE_LIMIT_BYTES);\n\t\tFile uploadFile = new File(TEST_FILE_PATH);\n\t\tMockHttpServletResponse response = null;\n\t\tlong fileSize = uploadFile.length();\n\t\ttry {\n\t\t\tresponse = testPostFile(UPLOAD_URI, uploadFile);\n\t\t\tAssert.fail(\"Tring to upload a file of zise \" + fileSize + \"expected to failed. response \" \n\t\t\t+ response.getContentAsString());\n\t\t} catch (RestErrorException e) {\n\t\t\tMap<String, Object> errorDescription = e.getErrorDescription();\n\t\t\tString status = (String) errorDescription.get(\"status\");\n\t\t\tAssert.assertEquals(\"error\", status);\n\t\t\tString errorMsg = (String) errorDescription.get(\"error\");\n\t\t\tAssert.assertEquals(CloudifyMessageKeys.FILE_SIZE_LIMIT_EXCEEDED.getName(), errorMsg);\n\t\t\tObject[] args = (Object[]) errorDescription.get(\"error_args\");\n\t\t\tObject[] expectedArgs = {UPLOADED_FILE_NAME, controller.getUploadSizeLimitBytes(), fileSize};\n\t\t\tAssert.assertArrayEquals(expectedArgs, args);\n\t\t}  finally {\n\t\t\tcontroller.setUploadSizeLimitBytes(CloudifyConstants.DEFAULT_UPLOAD_SIZE_LIMIT_BYTES);\n\t\t}\n\t}","id":47825,"modified_method":"@Test\n    public void testUploadExceededSizeLimitFile() throws Exception {\n        uploadRepo.setUploadSizeLimitBytes(TEST_UPLOAD_SIZE_LIMIT_BYTES);\n        File uploadFile = new File(TEST_FILE_PATH);\n        MockHttpServletResponse response = null;\n        long fileSize = uploadFile.length();\n        try {\n            response = testPostFile(versionedUploadUri, uploadFile);\n            Assert.fail(\"Tring to upload a file of zise \" + fileSize + \"expected to failed. response \"\n                    + response.getContentAsString());\n        } catch (RestErrorException e) {\n            Map<String, Object> errorDescription = e.getErrorDescription();\n            String status = (String) errorDescription.get(\"status\");\n            Assert.assertEquals(\"error\", status);\n            String errorMsg = (String) errorDescription.get(\"error\");\n            Assert.assertEquals(CloudifyMessageKeys.UPLOAD_FILE_SIZE_LIMIT_EXCEEDED.getName(), errorMsg);\n            Object[] args = (Object[]) errorDescription.get(\"error_args\");\n            Object[] expectedArgs = {UPLOADED_FILE_NAME, fileSize, uploadRepo.getUploadSizeLimitBytes()};\n            Assert.assertArrayEquals(expectedArgs, args);\n        }  finally {\n            uploadRepo.setUploadSizeLimitBytes(CloudifyConstants.DEFAULT_UPLOAD_SIZE_LIMIT_BYTES);\n        }\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private String uploadFile(final File file) throws Exception {\n\t\tMockHttpServletResponse response = testPostFile(UPLOAD_URI, file);\n\t\tMap<String, Object> responseMap = GSRestClient.jsonToMap(response.getContentAsString());\n\t\tString uploadKey = (String) responseMap.get(\"uploadKey\");\n\t\tAssert.assertNotNull(uploadKey);\n\t\treturn uploadKey;\n\t}","id":47826,"modified_method":"private UploadResponse uploadFile(final File file) throws Exception {\n        MockHttpServletResponse response = testPostFile(versionedUploadUri, file);\n        ObjectMapper objectMapper = new ObjectMapper();\n        Response<UploadResponse> readValue = objectMapper.readValue(response.getContentAsString(),\n                new TypeReference<Response<UploadResponse>>() { });\n        UploadResponse uploadResponse = readValue.getResponse();\n        return uploadResponse;\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testUpload() throws Exception {\n\t\tFile file = new File(TEST_FILE_PATH);\n\t\tString uploadKey = uploadFile(file);\n\t\tassertUploadedFileExists(file, uploadKey);\n\t}","id":47827,"modified_method":"@Test\n    public void testUpload() throws Exception {\n        File file = new File(TEST_FILE_PATH);\n        UploadResponse uploadResponse = uploadFile(file);\n        String uploadKey = uploadResponse.getUploadKey();\n        Assert.assertNotNull(uploadKey);\n        assertUploadedFileExists(file, uploadKey);\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public int getCleanupTimeoutSeconds() {\n\t\treturn cleanupTimeoutSeconds;\n\t}","id":47828,"modified_method":"public int getCleanupTimeoutMillis() {\n        return cleanupTimeoutMillis;\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Sets the cleanup timeout and reset the scheduled thread.\n\t * @param cleanupTimeoutSeconds .\n\t */\n\tpublic void resetTimeout(final int cleanupTimeoutSeconds) {\n\t\tthis.setCleanupTimeoutSeconds(cleanupTimeoutSeconds);\n\t\treset();\n\t}","id":47829,"modified_method":"/**\n     * Sets the cleanup timeout and reset the scheduled thread.\n     * @param cleanupTimeoutMillis .\n     */\n    public void resetTimeout(final int cleanupTimeoutMillis) {\n        logger.finer(\"reset timeout to \" + cleanupTimeoutMillis + \" milliseconds.\");\n        this.setCleanupTimeoutMillis(cleanupTimeoutMillis);\n        reset();\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Gets the file stored in a directory with the given name (uploadDirName).\n\t * \n\t * @param key\n\t *            - the name of the upload file's directory.\n\t * @return the suitable file or null if a file with that name doesn't exist.\n\t */\n\tpublic File get(final String key) {\n\t\tif (key == null || restUploadDir == null || !restUploadDir.exists()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal File[] files = restUploadDir.listFiles(new FilenameFilter() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(final File dir, final String name) {\n\t\t\t\treturn name.equals(key);\n\t\t\t}\n\t\t});\n\t\tif (files != null && files.length > 0) {\n\t\t\tfinal File dir = files[0];\n\t\t\treturn dir.listFiles()[0];\n\t\t}\n\t\treturn null;\n\t}","id":47830,"modified_method":"/**\n     * Gets the file stored in a directory with the given name (uploadDirName).\n     *\n     * @param key\n     *            - the name of the upload file's directory.\n     * @return the suitable file or null if a file with that name doesn't exist.\n     */\n    public File get(final String key) {\n        if (key == null) {\n            logger.finer(\"failed to get uploaded file, key is null.\");\n            return null;\n        }\n        if (restUploadDir == null) {\n            logger.finer(\"failed to get uploaded file, key is \" + key + \", upload directory is null.\");\n            return null;\n        }\n        if (!restUploadDir.exists()) {\n            logger.finer(\"failed to get uploaded file. key is \" + key\n                    + \", upload directory [\" + restUploadDir.getAbsolutePath() + \"] does not exist.\");\n            return null;\n        }\n\n        logger.finer(\"Trying to get the uploaded file stored in a directory named - \" + key\n                + \" (under \" + restUploadDir.getAbsolutePath() + \").\");\n        final File dir = new File(restUploadDir, key);\n        if (dir.exists()) {\n            if (!dir.isDirectory()) {\n                logger.finer(\"The file found is not a directory [\" + dir.getAbsolutePath() + \"].\");\n                return null;\n            }\n            File[] listFiles = dir.listFiles();\n            if (listFiles.length > 0) {\n                File uploadedFile = listFiles[0];\n                logger.finer(\"Returning the found uploaded file [\" + uploadedFile.getAbsolutePath() + \"].\");\n                return uploadedFile;\n            } else {\n                logger.finer(\"The directory [\" + dir.getAbsolutePath() + \"] does not contain an uploaded file.\");\n            }\n        } else {\n            logger.finer(\"No directory with name \" + key + \" was found at \" + restUploadDir.getAbsolutePath());\n        }\n        return null;\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Creates a new folder with a randomly generated name (using the UUID class) which holds the uploaded file.\n\t * The folder located at the main upload folder in {@link #baseDir}.\n\t * This uploaded file and its folder will be deleted after {@link #cleanupTimeoutSeconds} seconds.\n\t * \n\t * @param fileName\n\t * \t\t\tThe name of the uploaded file.\n\t * \t\t\tIf null, the multipartFile's original file name will be used as the file's name.\n\t * @param multipartFile\n\t *          The file to upload.\n\t * @return the uploaded key.\n\t * @throws RestErrorException if the file doesn't end with zip.\n\t * @throws IOException .\n\t */\n\tpublic String put(final String fileName, final MultipartFile multipartFile) throws IOException, RestErrorException {\n\t\tfinal String dirName = UUID.randomUUID().toString();\n\t\tfinal File srcDir = new File(restUploadDir, dirName);\n\t\tsrcDir.mkdirs();\n\t\tString name = fileName == null ? multipartFile.getOriginalFilename() : fileName;\n\t\tfinal File storedFile = new File(srcDir, name);\n\t\tcopyMultipartFileToLocalFile(multipartFile, storedFile);\n\t\tif (!storedFile.getName().endsWith(CloudifyConstants.PERMITTED_EXTENSION)) {\n\t\t\tthrow new RestErrorException(\"Uploaded file's extension must be \" \n\t\t\t\t\t+ CloudifyConstants.PERMITTED_EXTENSION, storedFile.getAbsolutePath());\n\t\t}\n\t\treturn dirName;\n\t}","id":47831,"modified_method":"/**\n     * Creates a new folder with a randomly generated name (using the UUID class) which holds the uploaded file.\n     * The folder located at the main upload folder in {@link #baseDir}.\n     * This uploaded file and its folder will be deleted after {@link #cleanupTimeoutMillis} millis.\n     *\n     * @param fileName\n     * \t\t\tThe name of the uploaded file.\n     * \t\t\tIf null, the multipartFile's original file name will be used as the file's name.\n     * @param multipartFile\n     *          The file to upload.\n     * @return the uploaded key.\n     * @throws RestErrorException if the file doesn't end with zip.\n     * @throws IOException .\n     */\n    public String put(final String fileName, final MultipartFile multipartFile) throws IOException, RestErrorException {\n        String name = fileName == null ? multipartFile.getOriginalFilename() : fileName;\n        // enforce size limit\n        long fileSize = multipartFile.getSize();\n        if (fileSize > getUploadSizeLimitBytes()) {\n            logger.warning(\"Upload file [\" + name + \"] size (\"\n                    + fileSize + \") exceeded the permitted size limit (\" + getUploadSizeLimitBytes() + \").\");\n            throw new RestErrorException(\n                    CloudifyMessageKeys.UPLOAD_FILE_SIZE_LIMIT_EXCEEDED.getName(),\n                    name, fileSize, getUploadSizeLimitBytes());\n        }\n        final String dirName = UUID.randomUUID().toString();\n        final File srcDir = new File(restUploadDir, dirName);\n        srcDir.mkdirs();\n        final File storedFile = new File(srcDir, name);\n        copyMultipartFileToLocalFile(multipartFile, storedFile);\n\n\n        logger.finer(\"File [\" + storedFile.getAbsolutePath() + \"] uploaded.\");\n        return dirName;\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void setCleanupTimeoutSeconds(final int cleanupTimeoutSeconds) {\n\t\tthis.cleanupTimeoutSeconds = cleanupTimeoutSeconds;\n\t}","id":47832,"modified_method":"public void setCleanupTimeoutMillis(final int cleanupTimeoutMillis) {\n        this.cleanupTimeoutMillis = cleanupTimeoutMillis;\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void createScheduledExecutor() {\n\t\tfinal CleanUploadDirThread cleanupThread =\n\t\t\t\tnew CleanUploadDirThread(restUploadDir, cleanupTimeoutSeconds * 1000);\n\t\texecutor = Executors.newSingleThreadScheduledExecutor();\n\t\texecutor.scheduleAtFixedRate(cleanupThread, 0, cleanupTimeoutSeconds, TimeUnit.SECONDS);\n\t\t\n\t}","id":47833,"modified_method":"private void createScheduledExecutor() {\n        final CleanUploadDirRunnable cleanupThread =\n                new CleanUploadDirRunnable(restUploadDir, cleanupTimeoutMillis);\n        executor = Executors.newSingleThreadScheduledExecutor();\n        executor.scheduleAtFixedRate(cleanupThread, 0, cleanupTimeoutMillis, TimeUnit.MILLISECONDS);\n\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void assertUploadedFile(final File expectedFile, final File uploadedFile) throws IOException {\n\t\tAssert.assertNotNull(uploadedFile);\n\t\t// file expected to be a file and not a directory.\n\t\tAssert.assertTrue(uploadedFile.isFile());\n\t\t// unzip file\n\t\tAssert.assertTrue(uploadedFile.getName().endsWith(CloudifyConstants.PERMITTED_EXTENSION));\n\t\tFile tempDir = new File(new File(CloudifyConstants.TEMP_FOLDER), \"tempDir\");\n\t\ttempDir.mkdirs();\n\t\ttempDir.deleteOnExit();\n\t\tFile zipCopyFile = File.createTempFile(\"test\", \".zip\", tempDir);\n\t\tzipCopyFile.deleteOnExit();\n\t\tFileUtils.copyFile(uploadedFile, zipCopyFile);\n\t\tZipUtils.unzip(zipCopyFile, tempDir);\n\t\tFile unzippedFile = new File(tempDir, TEST_FILE_NAME);\n\t\tunzippedFile.deleteOnExit();\n\t\t// check file name and content\n\t\tAssert.assertEquals(expectedFile.getName(), unzippedFile.getName());\n\t\tFileUtils.contentEquals(expectedFile, unzippedFile);\n\t\tZipFile zipFile = new ZipFile(zipCopyFile);\n\t\tzipFile.close();\n\t\tzipCopyFile.delete();\n\t}","id":47834,"modified_method":"private void assertUploadedFile(final File uploadedFile) throws IOException {\n        Assert.assertNotNull(uploadedFile);\n        // file expected to be a file and not a directory.\n        Assert.assertTrue(uploadedFile.isFile());\n        // unzip file if needed\n        File unzippedFile = uploadedFile;\n        String name = uploadedFile.getName();\n        if (name.endsWith(\"zip\")) {\n            File tempDir = new File(new File(CloudifyConstants.TEMP_FOLDER), \"tempDir\");\n            tempDir.mkdirs();\n            tempDir.deleteOnExit();\n            ZipUtils.unzip(uploadedFile, tempDir);\n            unzippedFile = new File(tempDir, TEST_FILE_NAME);\n            Assert.assertTrue(unzippedFile.exists());\n            unzippedFile.deleteOnExit();\n        }\n        // check file name and content\n        Assert.assertEquals(TEST_FILE_NAME, unzippedFile.getName());\n        FileUtils.contentEquals(new File(TXT_FILE_PATH), unzippedFile);\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void putAndGetTest() throws IOException {\n\t\tFile file = new File(TEST_FILE_PATH);\n\t\tString dirName = null;\n\t\ttry {\n\t\t\tdirName = putTest(file);\n\t\t} catch (RestErrorException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\t\tAssert.assertNotNull(dirName);\n\t\tfinal File uploadedFile = repo.get(dirName);\n\t\tassertUploadedFile(new File(TXT_EXTENSION_TEST_FILE_PATH), uploadedFile);\n\t}","id":47835,"modified_method":"public void putAndGetTest(final File file) throws IOException {\n        String uploadKey = null;\n        try {\n            uploadKey = putTest(file);\n        } catch (RestErrorException e) {\n            fail(e.getMessage());\n        }\n        Assert.assertNotNull(uploadKey);\n        final File uploadedFile = repo.get(uploadKey);\n        assertUploadedFile(uploadedFile);\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void getTimoutedFile() throws InterruptedException, IOException {\n\t\trepo.resetTimeout(CLEANUP_TIMEOUT_SECONDS);\n\t\tFile file = new File(TEST_FILE_PATH);\n\t\tString dirName = null;\n\t\ttry {\n\t\t\tdirName = putTest(file);\n\t\t} catch (RestErrorException e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\t\tFile uploadedFile = repo.get(dirName);\n\t\tassertUploadedFile(new File(TXT_EXTENSION_TEST_FILE_PATH), uploadedFile);\n\t\t\n\t\t// wait until the file is deleted.\n\t\tThread.sleep(repo.getCleanupTimeoutSeconds() * 2000);\n\n\t\tfinal File restUploadDir = repo.getRestUploadDir();\n\t\tAssert.assertNotNull(restUploadDir);\n\t\tAssert.assertTrue(restUploadDir.isDirectory());\n\t\tfile = repo.get(dirName);\n\t\tAssert.assertNull(file);\n\t}","id":47836,"modified_method":"@Test\n    public void getTimoutedFile() throws InterruptedException, IOException {\n        repo.resetTimeout(CLEANUP_TIMEOUT_MILLIS);\n        File file = new File(ZIP_FILE_PATH);\n        String dirName = null;\n        try {\n            dirName = putTest(file);\n        } catch (RestErrorException e) {\n            fail(e.getMessage());\n        }\n        File uploadedFile = repo.get(dirName);\n        assertUploadedFile(uploadedFile);\n\n        // wait until the file is deleted.\n        Thread.sleep(repo.getCleanupTimeoutMillis() * 3);\n\n        final File restUploadDir = repo.getRestUploadDir();\n        Assert.assertNotNull(restUploadDir);\n        Assert.assertTrue(restUploadDir.isDirectory());\n        file = repo.get(dirName);\n        Assert.assertNull(file);\n    }","commit_id":"e38fa65f8b3d98390de94cc2a1f2ec57a82bb709","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n     * create a file system, given a base file to which a lock string gets appended.\n     * @param baseLocation the base file location\n     */\n    public FSLock(File baseLocation) {\n        lockFile = new File(baseLocation.getAbsoluteFile() + lockString);\n        lockFile.deleteOnExit();\n    }","id":47837,"modified_method":"/**\n     * create a file system, given a base file to which a lock string gets appended.\n     * @param baseLocation the base file location\n     */\n    public FSLock(File baseLocation) {\n        lockFile = new File(baseLocation.getAbsoluteFile() + lockString);\n        if (lockFile != null) lockFile.deleteOnExit();\n    }","commit_id":"cded9ec98598652d1297e6bea33e5e503c39f752","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * test equality between two arg collections.  This function defines the statement:\n     * \"not fun to write\"\n     *\n     * @param other the other collection\n     *\n     * @return true if they're equal\n     */\n    public boolean equals(GATKArgumentCollection other) {\n        if (other == null) return false;\n        if (other.samFiles.size() != samFiles.size()) {\n            return false;\n        }\n        for (int x = 0; x < samFiles.size(); x++) {\n            if (!samFiles.get(x).equals(other.samFiles.get(x))) {\n                return false;\n            }\n        }\n        if (other.walkerArgs.size() != walkerArgs.size()) {\n            return false;\n        }\n        for (String s : walkerArgs.keySet()) {\n            if (!other.walkerArgs.containsKey(s)) {\n                return false;\n            }\n        }\n        if (other.RODBindings.size() != RODBindings.size()) {\n            return false;\n        }\n        for (int x = 0; x < RODBindings.size(); x++) {\n            if (!RODBindings.get(x).equals(other.RODBindings.get(x))) {\n                return false;\n            }\n        }\n        if (!other.samFiles.equals(this.samFiles)) {\n            return false;\n        }\n        if (!other.maximumEngineIterations.equals(this.maximumEngineIterations)) {\n            return false;\n        }\n        if (!other.strictnessLevel.equals(this.strictnessLevel)) {\n            return false;\n        }\n        if (!other.referenceFile.equals(this.referenceFile)) {\n            return false;\n        }\n        if (!other.intervals.equals(this.intervals)) {\n            return false;\n        }\n        if (!other.excludeIntervals.equals(this.excludeIntervals)) {\n            return false;\n        }\n        if (!other.DBSNPFile.equals(this.DBSNPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPFile.equals(this.HAPMAPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPChipFile.equals(this.HAPMAPChipFile)) {\n            return false;\n        }\n        if (!other.unsafe.equals(this.unsafe)) {\n            return false;\n        }\n        if (other.readMaxPileup != this.readMaxPileup) {\n            return false;\n        }\n        if ((other.filterZeroMappingQualityReads == null && this.filterZeroMappingQualityReads != null) ||\n                (other.filterZeroMappingQualityReads != null && !other.filterZeroMappingQualityReads.equals(this.filterZeroMappingQualityReads))) {\n            return false;\n        }\n        if ((other.downsampleFraction == null && this.downsampleFraction != null) ||\n                (other.downsampleFraction != null && !other.downsampleFraction.equals(this.downsampleFraction))) {\n            return false;\n        }\n        if ((other.downsampleCoverage == null && this.downsampleCoverage != null) ||\n                (other.downsampleCoverage != null && !other.downsampleCoverage.equals(this.downsampleCoverage))) {\n            return false;\n        }\n        if (!other.outFileName.equals(this.outFileName)) {\n            return false;\n        }\n        if (!other.errFileName.equals(this.errFileName)) {\n            return false;\n        }\n        if (!other.outErrFileName.equals(this.outErrFileName)) {\n            return false;\n        }\n        if (other.numberOfThreads != this.numberOfThreads) {\n            return false;\n        }\n        if (other.intervalMerging != this.intervalMerging) {\n            return false;\n        }\n        if ((other.RODToInterval == null && RODToInterval != null) ||\n            (other.RODToInterval != null && !other.RODToInterval.equals(RODToInterval))) {\n            return false;\n        }\n//        if (other.enableRodWalkers != this.enableRodWalkers) {\n//            return false;\n//        }\n\n        return true;\n    }","id":47838,"modified_method":"/**\n     * test equality between two arg collections.  This function defines the statement:\n     * \"not fun to write\"\n     *\n     * @param other the other collection\n     *\n     * @return true if they're equal\n     */\n    public boolean equals(GATKArgumentCollection other) {\n        if (other == null) return false;\n        if (other.samFiles.size() != samFiles.size()) {\n            return false;\n        }\n        for (int x = 0; x < samFiles.size(); x++) {\n            if (!samFiles.get(x).equals(other.samFiles.get(x))) {\n                return false;\n            }\n        }\n        if (other.walkerArgs.size() != walkerArgs.size()) {\n            return false;\n        }\n        for (String s : walkerArgs.keySet()) {\n            if (!other.walkerArgs.containsKey(s)) {\n                return false;\n            }\n        }\n        if (other.RODBindings.size() != RODBindings.size()) {\n            return false;\n        }\n        for (int x = 0; x < RODBindings.size(); x++) {\n            if (!RODBindings.get(x).equals(other.RODBindings.get(x))) {\n                return false;\n            }\n        }\n        if (!other.samFiles.equals(this.samFiles)) {\n            return false;\n        }\n        if (!other.maximumEngineIterations.equals(this.maximumEngineIterations)) {\n            return false;\n        }\n        if (!other.strictnessLevel.equals(this.strictnessLevel)) {\n            return false;\n        }\n        if (!other.referenceFile.equals(this.referenceFile)) {\n            return false;\n        }\n        if (!other.intervals.equals(this.intervals)) {\n            return false;\n        }\n        if (!other.excludeIntervals.equals(this.excludeIntervals)) {\n            return false;\n        }\n        if (!other.DBSNPFile.equals(this.DBSNPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPFile.equals(this.HAPMAPFile)) {\n            return false;\n        }\n        if (!other.HAPMAPChipFile.equals(this.HAPMAPChipFile)) {\n            return false;\n        }\n        if (!other.unsafe.equals(this.unsafe)) {\n            return false;\n        }\n        if (other.readMaxPileup != this.readMaxPileup) {\n            return false;\n        }\n        if ((other.filterZeroMappingQualityReads == null && this.filterZeroMappingQualityReads != null) ||\n                (other.filterZeroMappingQualityReads != null && !other.filterZeroMappingQualityReads.equals(this.filterZeroMappingQualityReads))) {\n            return false;\n        }\n        if ((other.downsampleFraction == null && this.downsampleFraction != null) ||\n                (other.downsampleFraction != null && !other.downsampleFraction.equals(this.downsampleFraction))) {\n            return false;\n        }\n        if ((other.downsampleCoverage == null && this.downsampleCoverage != null) ||\n                (other.downsampleCoverage != null && !other.downsampleCoverage.equals(this.downsampleCoverage))) {\n            return false;\n        }\n        if (!other.outFileName.equals(this.outFileName)) {\n            return false;\n        }\n        if (!other.errFileName.equals(this.errFileName)) {\n            return false;\n        }\n        if (!other.outErrFileName.equals(this.outErrFileName)) {\n            return false;\n        }\n        if (other.numberOfThreads != this.numberOfThreads) {\n            return false;\n        }\n        if (other.intervalMerging != this.intervalMerging) {\n            return false;\n        }\n        if (enableThreadedDebugging != other.enableThreadedDebugging) {\n            return false;\n        }\n        if ((other.RODToInterval == null && RODToInterval != null) ||\n            (other.RODToInterval != null && !other.RODToInterval.equals(RODToInterval))) {\n            return false;\n        }\n//        if (other.enableRodWalkers != this.enableRodWalkers) {\n//            return false;\n//        }\n\n        return true;\n    }","commit_id":"cded9ec98598652d1297e6bea33e5e503c39f752","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new hierarchical microscheduler to process the given reads and reference.\n     *\n     * @param walker        the walker used to process the dataset.\n     * @param reads         Reads file(s) to process.\n     * @param reference     Reference for driving the traversal.\n     * @param nThreadsToUse maximum number of threads to use to do the work\n     */\n    protected HierarchicalMicroScheduler(GenomeAnalysisEngine engine, Walker walker, SAMDataSource reads, IndexedFastaSequenceFile reference, Collection<ReferenceOrderedDataSource> rods, int nThreadsToUse ) {\n        super(engine, walker, reads, reference, rods);\n        this.threadPool = Executors.newFixedThreadPool(nThreadsToUse);\n\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"org.broadinstitute.sting.gatk.executive:type=HierarchicalMicroScheduler\");\n            mbs.registerMBean(this, name);\n        }\n        catch (JMException ex) {\n            throw new StingException(\"Unable to register microscheduler with JMX\", ex);\n        }\n    }","id":47839,"modified_method":"/**\n     * Create a new hierarchical microscheduler to process the given reads and reference.\n     *\n     * @param walker        the walker used to process the dataset.\n     * @param reads         Reads file(s) to process.\n     * @param reference     Reference for driving the traversal.\n     * @param nThreadsToUse maximum number of threads to use to do the work\n     */\n    protected HierarchicalMicroScheduler(GenomeAnalysisEngine engine, Walker walker, SAMDataSource reads, IndexedFastaSequenceFile reference, Collection<ReferenceOrderedDataSource> rods, int nThreadsToUse ) {\n        super(engine, walker, reads, reference, rods);\n\n        if (GenomeAnalysisEngine.instance.getArguments().enableThreadedDebugging)\n            this.threadPool = new ExceptionAwareThreadPool(nThreadsToUse);\n        else\n            this.threadPool = Executors.newFixedThreadPool(nThreadsToUse);\n\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"org.broadinstitute.sting.gatk.executive:type=HierarchicalMicroScheduler\");\n            mbs.registerMBean(this, name);\n        }\n        catch (JMException ex) {\n            throw new StingException(\"Unable to register microscheduler with JMX\", ex);\n        }\n    }","commit_id":"cded9ec98598652d1297e6bea33e5e503c39f752","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Object call() {\n        long startTime = System.currentTimeMillis(); \n\n        Object accumulator = walker.reduceInit();\n        WindowMaker windowMaker = new WindowMaker(microScheduler.getReadIterator(shard),shard.getGenomeLocs());\n        try {\n            for(WindowMaker.WindowMakerIterator iterator: windowMaker) {\n                ShardDataProvider dataProvider = new LocusShardDataProvider(shard,iterator.getSourceInfo(),iterator.getLocus(),iterator,microScheduler.reference,microScheduler.rods);\n                accumulator = traversalEngine.traverse( walker, dataProvider, accumulator );\n                dataProvider.close();\n            }\n        }\n        finally {\n            windowMaker.close();\n            outputMergeTask = outputTracker.closeStorage();\n\n            synchronized(this) {\n                complete = true;\n                notifyAll();\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n\n        microScheduler.reportShardTraverseTime(endTime-startTime);\n\n        return accumulator;\n    }","id":47840,"modified_method":"public Object call() {\n        long startTime = System.currentTimeMillis(); \n\n        Object accumulator = walker.reduceInit();\n        WindowMaker windowMaker = new WindowMaker(microScheduler.getReadIterator(shard),shard.getGenomeLocs());\n        ShardDataProvider dataProvider = null;\n        try {\n            for(WindowMaker.WindowMakerIterator iterator: windowMaker) {\n                dataProvider = new LocusShardDataProvider(shard,iterator.getSourceInfo(),iterator.getLocus(),iterator,microScheduler.reference,microScheduler.rods);\n                accumulator = traversalEngine.traverse( walker, dataProvider, accumulator );\n                dataProvider.close();\n            }\n        }\n        finally {\n            if (dataProvider != null) dataProvider.close();\n            windowMaker.close();\n            outputMergeTask = outputTracker.closeStorage();\n\n            synchronized(this) {\n                complete = true;\n                notifyAll();\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n\n        microScheduler.reportShardTraverseTime(endTime-startTime);\n\n        return accumulator;\n    }","commit_id":"cded9ec98598652d1297e6bea33e5e503c39f752","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void establishDirectory(File dir) {\n        if (!dir.exists()) {\n            if (!MkdirsFileAction.mkdirs(dir)) {\n                throw EjbMessages.MESSAGES.passivationDirectoryCreationFailed(dir.getPath());\n            }\n            dir.deleteOnExit();\n        }\n\n        if (!dir.isDirectory()) {\n            throw EjbMessages.MESSAGES.passivationPathNotADirectory(dir.getPath());\n        }\n    }","id":47841,"modified_method":"private void establishDirectory(File dir) {\n        if (!dir.exists()) {\n            if (MkdirsFileAction.mkdirs(dir)) {\n                dir.deleteOnExit();\n            } else if (!dir.exists()) { // this method can be called concurrently, so another thread may have created the dir\n                throw EjbMessages.MESSAGES.passivationDirectoryCreationFailed(dir.getPath());\n            }\n        }\n\n        if (!dir.isDirectory()) {\n            throw EjbMessages.MESSAGES.passivationPathNotADirectory(dir.getPath());\n        }\n    }","commit_id":"b8427f89b76428aad98d407863b6ffb0313021db","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Attempts to acquire an exclusive lock on the storage.\n     * \n     * @return A lock object representing the newly-acquired lock or\n     * <code>null<\/code> if storage is already locked.\n     * @throws IOException if locking fails.\n     */\n    FileLock tryLock() throws IOException {\n      File lockF = new File(root, STORAGE_FILE_LOCK);\n      lockF.deleteOnExit();\n      RandomAccessFile file = new RandomAccessFile(lockF, \"rws\");\n      FileLock res = null;\n      try {\n        res = file.getChannel().tryLock();\n      } catch(OverlappingFileLockException oe) {\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Cannot create lock on \" + lockF, e);\n        file.close();\n        throw e;\n      }\n      return res;\n    }","id":47842,"modified_method":"/**\n     * Attempts to acquire an exclusive lock on the storage.\n     * \n     * @return A lock object representing the newly-acquired lock or\n     * <code>null<\/code> if storage is already locked.\n     * @throws IOException if locking fails.\n     */\n    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded = false;\n      File lockF = new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded = true;\n      }\n      RandomAccessFile file = new RandomAccessFile(lockF, \"rws\");\n      FileLock res = null;\n      try {\n        res = file.getChannel().tryLock();\n      } catch(OverlappingFileLockException oe) {\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Cannot create lock on \" + lockF, e);\n        file.close();\n        throw e;\n      }\n      if (res != null && !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn't\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }","commit_id":"6d5510dfb8bdd1cce577dc713b1d5849dc572d91","url":"https://github.com/apache/hadoop"},{"original_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!serviceFile.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", serviceFile.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tint plannedNumberOfInstances = 1;\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (serviceFile.getName().endsWith(\".jar\") || serviceFile.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = serviceFile;\r\n\t\t\t} else if (serviceFile.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\r\n\t\t\t\tpackedFile = Packager.pack(serviceFile);\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t\tservice = ServiceReader.readService(serviceFile);\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = serviceFile;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\r\n\t\t\tplannedNumberOfInstances = service.getNumInstances();\r\n\t\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\tserviceName = serviceFile.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.length() == 0) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName = null;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service != null && service.getCompute() != null) {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttemplateName = \"\";\r\n\t\t}\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile, currentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\tif (lifecycleEventContainerPollingID != null){\n\t\t\tthis.adminFacade.waitForLifecycleEvents(lifecycleEventContainerPollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\"Check logs for more details.\");\n\t\t}\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (serviceFile.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","id":47843,"modified_method":"/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tprotected Object doExecute() throws Exception {\r\n\t\tif (!recipe.exists()) {\r\n\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", recipe.getPath());\r\n\t\t}\r\n\r\n\t\tFile packedFile;\r\n\r\n\t\t// TODO: this logics should not be done twice. should be done directly in the rest server.\r\n\t\t// also figure out how to treat war/jar files that have no .groovy file. create default?\r\n\t\tint plannedNumberOfInstances = 1;\r\n\t\tService service = null;\r\n\t\ttry {\r\n\t\t\tif (recipe.getName().endsWith(\".jar\") || recipe.getName().endsWith(\".war\")) {\r\n\t\t\t\t// legacy XAP Processing Unit\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t} else if (recipe.isDirectory()) {\r\n\t\t\t\t// Assume that a folder will contain a DSL file?\n\t\t\t\t\n\t\t\t\tif (serviceFileName != null) {\n\t\t\t\t\tFile fullPathToRecipe = new File(recipe.getAbsolutePath() + \"/\" + serviceFileName);\n\t\t\t\t\tif (!fullPathToRecipe.exists()) {\n\t\t\t\t\t\tthrow new CLIStatusException(\"service_file_doesnt_exist\", fullPathToRecipe.getPath());\n\t\t\t\t\t}\n\t\t\t\t\tpackedFile = Packager.pack(fullPathToRecipe);\n\t\t\t\t\tservice = ServiceReader.readService(fullPathToRecipe);\n\t\t\t\t}\n\t\t\t\telse {\r\n\t\t\t\t\tpackedFile = Packager.pack(recipe);\n\t\t\t\t\tservice = ServiceReader.readService(recipe);\r\n\t\t\t\t}\r\n\t\t\t\tpackedFile.deleteOnExit();\r\n\t\t\t} else {\r\n\t\t\t\t// serviceFile is a zip file\r\n\t\t\t\tpackedFile = recipe;\r\n\t\t\t\tservice = ServiceReader.readServiceFromZip(packedFile, CloudifyConstants.DEFAULT_APPLICATION_NAME);\r\n\t\t\t}\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t} catch (final PackagingException e) {\r\n\t\t\tthrow new CLIException(e);\r\n\t\t}\r\n\t\tfinal String currentApplicationName = getCurrentApplicationName();\r\n\r\n\t\t// TODO: All packaging logic should be moved to the REST server\r\n\t\tProperties props = null;\r\n\t\tif (service != null) {\r\n\t\t\tprops = createServiceContextProperties(service);\n\t\t\tif (serviceFileName != null) {\n\t\t\t\tprops.setProperty(CloudifyConstants.CONTEXT_PROPERTY_SERVICE_FILE_NAME, serviceFileName);\n\t\t\t}\r\n\t\t\tplannedNumberOfInstances = service.getNumInstances();\r\n\t\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\t\tserviceName = service.getName();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (serviceName == null || serviceName.length() == 0) {\r\n\t\t\tserviceName = recipe.getName();\r\n\t\t\tfinal int endIndex = serviceName.lastIndexOf('.');\r\n\t\t\tif (endIndex > 0) {\r\n\t\t\t\tserviceName = serviceName.substring(0, endIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (zone == null || zone.length() == 0) {\r\n\t\t\tzone = serviceName;\r\n\t\t}\r\n\r\n\t\tString templateName = null;\r\n\t\t// service is null when a simple deploying war for example\r\n\t\tif (service != null && service.getCompute() != null) {\r\n\t\t\ttemplateName = service.getCompute().getTemplate();\r\n\t\t\tif (templateName == null) {\r\n\t\t\t\ttemplateName = \"\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttemplateName = \"\";\r\n\t\t}\r\n\t\tString lifecycleEventContainerPollingID = adminFacade.installElastic(packedFile, currentApplicationName, serviceName, zone, props, templateName, timeoutInMinutes);\n\n\t\tif (lifecycleEventContainerPollingID != null){\n\t\t\tthis.adminFacade.waitForLifecycleEvents(lifecycleEventContainerPollingID, timeoutInMinutes, TIMEOUT_ERROR_MESSAGE);\n\t\t} else {\n\t\t\tthrow new CLIException(\"Failed to retrieve lifecycle logs from rest. \" +\n\t\t\t\"Check logs for more details.\");\n\t\t}\n\r\n\t\t// if a zip file was created, delete it at the end of use.\r\n\t\tif (recipe.isDirectory()) {\r\n\t\t\tFileUtils.deleteQuietly(packedFile.getParentFile());\r\n\t\t}\r\n\r\n\t\treturn getFormattedMessage(\"service_install_ended\", Color.GREEN, serviceName);\r\n\t}","commit_id":"d06e43caf197026405bd2f8d9b7e517788d3f86b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public String deployElasticProcessingUnit(final String serviceName, final String applicationName,\n\t\t\tfinal String zone, final File srcFile, final Properties propsFile, final String originalTemplateName,\n\t\t\tboolean isApplicationInstall, int timeout, TimeUnit timeUnit)\n\t\t\tthrows TimeoutException, PackagingException, IOException, AdminException, DSLException {\n\n\t\tString templateName;\n\t\tif (originalTemplateName == null) {\n\t\t\ttemplateName = this.defaultTemplateName;\n\t\t} else {\n\t\t\ttemplateName = originalTemplateName;\n\t\t}\n\n\t\tif (templateName != null) {\n\t\t\tpropsFile.put(\n\t\t\t\t\tCloudifyConstants.CONTEXT_PROPERTY_TEMPLATE, templateName);\n\t\t}\n\n\t\tService service = null;\n\t\tFile projectDir = null;\n\t\t// Cloud cloud = null;\n\t\tif (srcFile.getName().endsWith(\n\t\t\t\t\".zip\")) {\n\t\t\tprojectDir = ServiceReader.extractProjectFile(srcFile);\n\t\t\tfinal DSLServiceCompilationResult result = ServiceReader.getServiceFromDirectory(\n\t\t\t\t\tnew File(projectDir, \"ext\"), applicationName);\n\t\t\tservice = result.getService();\n\t\t\t// cloud = ServiceReader.getCloudFromDirectory(new File(projectDir,\n\t\t\t// \"ext\"));\n\n\t\t}\n\n\t\tif (service == null) {\n\t\t\tdoDeploy(\n\t\t\t\t\tapplicationName, serviceName, templateName, zone, srcFile, propsFile);\n\t\t} else if (service.getLifecycle() != null) {\n\t\t\tdoDeploy(\n\t\t\t\t\tapplicationName, serviceName, templateName, zone, srcFile, propsFile, service);\n\t\t} else if (service.getDataGrid() != null) {\n\t\t\tdeployDataGrid(\n\t\t\t\t\tapplicationName, serviceName, zone, srcFile, propsFile, service.getDataGrid(), templateName);\n\t\t} else if (service.getStatelessProcessingUnit() != null) {\n\t\t\tdeployStatelessProcessingUnitAndWait(\n\t\t\t\t\tapplicationName, serviceName, zone, new File(projectDir, \"ext\"), propsFile,\n\t\t\t\t\tservice.getStatelessProcessingUnit(), templateName, service.getNumInstances());\n\t\t} else if (service.getMirrorProcessingUnit() != null) {\n\t\t\tdeployStatelessProcessingUnitAndWait(\n\t\t\t\t\tapplicationName, serviceName, zone, new File(projectDir, \"ext\"), propsFile,\n\t\t\t\t\tservice.getMirrorProcessingUnit(), templateName, service.getNumInstances());\n\t\t} else if (service.getStatefulProcessingUnit() != null) {\n\t\t\tdeployStatefulProcessingUnit(\n\t\t\t\t\tapplicationName, serviceName, zone, new File(projectDir, \"ext\"), propsFile,\n\t\t\t\t\tservice.getStatefulProcessingUnit(), templateName);\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unsupported service type\");\n\t\t}\n\t\tif (projectDir != null) {\n\t\t\ttry {\n\t\t\t\tFileUtils.deleteDirectory(projectDir);\n\t\t\t} catch (final IOException e) {\n\t\t\t\t// this may happen if a classloader is holding unto a jar file in the usmlib directory\n\t\t\t\t// the files are temp files, so it should be ok if they remain on the disk\n\t\t\t\tlogger.log(\n\t\t\t\t\t\tLevel.WARNING, \"Failed to delete project files: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tsrcFile.delete();\n\n\t\tString lifecycleEventContainerID = \"\";\n\t\tif (!isApplicationInstall) {\n\t\t    logger.log(Level.INFO, \"Starting to poll for installation lifecycle events.\");\n\t\t\tif (service == null) {\n\t\t\t\tlifecycleEventContainerID = startPollingForLifecycleEvents(\n\t\t\t\t\t\tServiceUtils.getApplicationServiceName(\n\t\t\t\t\t\t\t\tserviceName, applicationName), applicationName, 1, true, timeout, timeUnit).toString();\n\t\t\t} else {\n\t\t\t\tlifecycleEventContainerID =\n\t\t\t\t\t\tstartPollingForLifecycleEvents(\n\t\t\t\t\t\t\t\tservice.getName(), applicationName, service.getNumInstances(), true, timeout, timeUnit)\n\t\t\t\t\t\t\t\t.toString();\n\t\t\t}\n\t\t}\n\t\treturn lifecycleEventContainerID;\n\t}","id":47844,"modified_method":"public String deployElasticProcessingUnit(final String serviceName, final String applicationName,\n\t\t\tfinal String zone, final File srcFile, final Properties propsFile, final String originalTemplateName,\n\t\t\tboolean isApplicationInstall, int timeout, TimeUnit timeUnit)\n\t\t\tthrows TimeoutException, PackagingException, IOException, AdminException, DSLException {\n\n\t\tString templateName;\n\t\tif (originalTemplateName == null) {\n\t\t\ttemplateName = this.defaultTemplateName;\n\t\t} else {\n\t\t\ttemplateName = originalTemplateName;\n\t\t}\n\n\t\tif (templateName != null) {\n\t\t\tpropsFile.put(\n\t\t\t\t\tCloudifyConstants.CONTEXT_PROPERTY_TEMPLATE, templateName);\n\t\t}\n\n\t\tService service = null;\n\t\tFile projectDir = null;\n\t\t// Cloud cloud = null;\n\t\tif (srcFile.getName().endsWith(\n\t\t\t\t\".zip\")) {\n\t\t\tprojectDir = ServiceReader.extractProjectFile(srcFile);\n\t\t\tFile workingProjectDir = new File(projectDir, \"ext\");\n\t\t\tString serviceFileName = propsFile.getProperty(CloudifyConstants.CONTEXT_PROPERTY_SERVICE_FILE_NAME);\n\t\t\tDSLServiceCompilationResult result;\n\t\t\tif (serviceFileName != null) {\n\t\t\t\tresult = ServiceReader.getServiceFromFile(new File(workingProjectDir, serviceFileName), workingProjectDir);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = ServiceReader.getServiceFromDirectory(\n\t\t\t\t\t\tworkingProjectDir, applicationName);\t\n\t\t\t}\n\t\t\tservice = result.getService();\n\t\t\t// cloud = ServiceReader.getCloudFromDirectory(new File(projectDir,\n\t\t\t// \"ext\"));\n\n\t\t}\n\n\t\tif (service == null) {\n\t\t\tdoDeploy(\n\t\t\t\t\tapplicationName, serviceName, templateName, zone, srcFile, propsFile);\n\t\t} else if (service.getLifecycle() != null) {\n\t\t\tdoDeploy(\n\t\t\t\t\tapplicationName, serviceName, templateName, zone, srcFile, propsFile, service);\n\t\t} else if (service.getDataGrid() != null) {\n\t\t\tdeployDataGrid(\n\t\t\t\t\tapplicationName, serviceName, zone, srcFile, propsFile, service.getDataGrid(), templateName);\n\t\t} else if (service.getStatelessProcessingUnit() != null) {\n\t\t\tdeployStatelessProcessingUnitAndWait(\n\t\t\t\t\tapplicationName, serviceName, zone, new File(projectDir, \"ext\"), propsFile,\n\t\t\t\t\tservice.getStatelessProcessingUnit(), templateName, service.getNumInstances());\n\t\t} else if (service.getMirrorProcessingUnit() != null) {\n\t\t\tdeployStatelessProcessingUnitAndWait(\n\t\t\t\t\tapplicationName, serviceName, zone, new File(projectDir, \"ext\"), propsFile,\n\t\t\t\t\tservice.getMirrorProcessingUnit(), templateName, service.getNumInstances());\n\t\t} else if (service.getStatefulProcessingUnit() != null) {\n\t\t\tdeployStatefulProcessingUnit(\n\t\t\t\t\tapplicationName, serviceName, zone, new File(projectDir, \"ext\"), propsFile,\n\t\t\t\t\tservice.getStatefulProcessingUnit(), templateName);\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unsupported service type\");\n\t\t}\n\t\tif (projectDir != null) {\n\t\t\ttry {\n\t\t\t\tFileUtils.deleteDirectory(projectDir);\n\t\t\t} catch (final IOException e) {\n\t\t\t\t// this may happen if a classloader is holding unto a jar file in the usmlib directory\n\t\t\t\t// the files are temp files, so it should be ok if they remain on the disk\n\t\t\t\tlogger.log(\n\t\t\t\t\t\tLevel.WARNING, \"Failed to delete project files: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tsrcFile.delete();\n\n\t\tString lifecycleEventContainerID = \"\";\n\t\tif (!isApplicationInstall) {\n\t\t    logger.log(Level.INFO, \"Starting to poll for installation lifecycle events.\");\n\t\t\tif (service == null) {\n\t\t\t\tlifecycleEventContainerID = startPollingForLifecycleEvents(\n\t\t\t\t\t\tServiceUtils.getApplicationServiceName(\n\t\t\t\t\t\t\t\tserviceName, applicationName), applicationName, 1, true, timeout, timeUnit).toString();\n\t\t\t} else {\n\t\t\t\tlifecycleEventContainerID =\n\t\t\t\t\t\tstartPollingForLifecycleEvents(\n\t\t\t\t\t\t\t\tservice.getName(), applicationName, service.getNumInstances(), true, timeout, timeUnit)\n\t\t\t\t\t\t\t\t.toString();\n\t\t\t}\n\t\t}\n\t\treturn lifecycleEventContainerID;\n\t}","commit_id":"d06e43caf197026405bd2f8d9b7e517788d3f86b","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n   * Optimizes for/let clauses. Avoids repeated calls to static let clauses.\r\n   * @param ctx query context\r\n   */\r\n  private void compForLet(final QueryContext ctx) {\r\n    // check if all clauses are simple, and if variables are removable\r\n    boolean m = false;\r\n    // loop through all clauses\r\n    for(int f = fl.length - 1; f >= 0; --f) {\r\n      ForLet t = fl[f];\r\n      // ignore for clauses and constructors\r\n      // [LW] why is the CTX check needed (it actually is), can it be replaced?\r\n      if(t instanceof For || t.uses(Use.CTX) || t.uses(Use.CNS)) continue;\r\n      // loop through all outer clauses\r\n      for(int g = f - 1; g >= 0; --g) {\r\n        // stop if variable used by the current clause\r\n        if(t.count(fl[g].var) != 0) break;\r\n        // ignore let clauses\r\n        if(fl[g] instanceof Let) continue;\r\n        // stop if variable is used as position or score\r\n        final For fr = (For) fl[g];\r\n        if(fr.pos != null && t.count(fr.pos) != 0 ||\r\n           fr.score != null && t.count(fr.score) != 0) break;\r\n\r\n        // move let clause to outer position\r\n        System.arraycopy(fl, g, fl, g + 1, f - g);\r\n        fl[g] = t;\r\n        t = fl[f];\r\n        if(!m) ctx.compInfo(OPTFORLET);\r\n        m = true;\r\n      }\r\n    }\r\n  }","id":47845,"modified_method":"/**\r\n   * Optimizes for/let clauses. Avoids repeated calls to static let clauses.\r\n   * @param ctx query context\r\n   */\r\n  private void compForLet(final QueryContext ctx) {\r\n    // modification flag\r\n    boolean m = false;\r\n\r\n    for(int i = 1; i < fl.length; i++) {\r\n      final ForLet cls = fl[i];\r\n      // move let clauses upwards if possible\r\n      // expressions that depend on the current context (e.g. math:random())\r\n      // or fragment constructors creating unique nodes are left alone\r\n      if(cls instanceof Let && !cls.uses(Use.CTX) && !cls.uses(Use.CNS)) {\r\n        final Let let = (Let) cls;\r\n\r\n        // find highest for clause that can be skipped\r\n        int fpos = -1;\r\n        for(int j = i; j-- != 0;) {\r\n          final ForLet o = fl[j];\r\n          if(let.count(o.var) != 0) break;\r\n          if(o instanceof For) {\r\n            final For fr = (For) o;\r\n            if(fr.pos != null && let.count(fr.pos) != 0 ||\r\n                fr.score != null && let.count(fr.score) != 0) break;\r\n            fpos = j;\r\n          }\r\n        }\r\n        if(fpos != -1) {\r\n          Array.move(fl, fpos, 1, i - fpos);\r\n          fl[fpos] = let;\r\n          m = true;\r\n        }\r\n      }\r\n    }\r\n    if(m) ctx.compInfo(OPTFORLET);\r\n  }","commit_id":"92f8f6451482f10ad7f9bfc3387e370a9f932f61","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public boolean uses(final Use u) {\r\n    return u == Use.FRG || super.uses(u);\r\n  }","id":47846,"modified_method":"@Override\r\n  public boolean uses(final Use u) {\r\n    return u == Use.CNS || super.uses(u);\r\n  }","commit_id":"166ae22911ddaf21e68561f18c6225259fed3273","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * If possible, binds the variable at compile time.\r\n   * @param ctx query context\r\n   * @return result of check\r\n   * @throws QueryException query exception\r\n   */\r\n  protected boolean bind(final QueryContext ctx) throws QueryException {\r\n    // don't bind variable if expression uses variables, context, or fragments\r\n    if(expr.uses(Use.VAR) || expr.uses(Use.CTX) || expr.uses(Use.FRG) ||\r\n        ctx.grouping) return false;\r\n\r\n    ctx.compInfo(OPTBIND, var);\r\n    var.bind(expr, ctx);\r\n    return true;\r\n  }","id":47847,"modified_method":"/**\r\n   * If possible, binds the variable at compile time.\r\n   * @param ctx query context\r\n   * @return true if expression was bound to variable\r\n   * @throws QueryException query exception\r\n   */\r\n  protected boolean bind(final QueryContext ctx) throws QueryException {\r\n    // don't bind variable if expression uses variables, context, or fragments\r\n    if(expr.uses(Use.VAR) || expr.uses(Use.CTX) || expr.uses(Use.CNS) ||\r\n        ctx.grouping) return false;\r\n\r\n    ctx.compInfo(OPTBIND, var);\r\n    var.bind(expr, ctx);\r\n    return true;\r\n  }","commit_id":"166ae22911ddaf21e68561f18c6225259fed3273","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Optimizes for/let clauses. Avoids repeated calls to static let clauses.\r\n   * @param ctx query context\r\n   */\r\n  private void compForLet(final QueryContext ctx) {\r\n    // check if all clauses are simple, and if variables are removable\r\n    boolean m = false;\r\n    // loop through all clauses\r\n    for(int f = fl.length - 1; f >= 0; --f) {\r\n      ForLet t = fl[f];\r\n      // ignore for clauses\r\n      if(t instanceof For) continue;\r\n      // loop through all outer clauses\r\n      for(int g = f - 1; g >= 0; --g) {\r\n        // stop if variable is shadowed or used by the current clause\r\n        if(fl[g].shadows(t.var) || t.uses(fl[g].var)) break;\r\n        // ignore let clauses and fragment constructors\r\n        if(fl[g] instanceof Let || t.uses(Use.FRG)) continue;\r\n        // stop if variable is used by as position or score\r\n        final For fr = (For) fl[g];\r\n        if(fr.pos != null && t.uses(fr.pos) ||\r\n           fr.score != null && t.uses(fr.score)) break;\r\n\r\n        // move let clause to outer position\r\n        System.arraycopy(fl, g, fl, g + 1, f - g);\r\n        fl[g] = t;\r\n        t = fl[f];\r\n        if(!m) ctx.compInfo(OPTFORLET);\r\n        m = true;\r\n      }\r\n    }\r\n  }","id":47848,"modified_method":"/**\r\n   * Optimizes for/let clauses. Avoids repeated calls to static let clauses.\r\n   * @param ctx query context\r\n   */\r\n  private void compForLet(final QueryContext ctx) {\r\n    // check if all clauses are simple, and if variables are removable\r\n    boolean m = false;\r\n    // loop through all clauses\r\n    for(int f = fl.length - 1; f >= 0; --f) {\r\n      ForLet t = fl[f];\r\n      // ignore for clauses, context expressions and constructors\r\n      if(t instanceof For || t.uses(Use.CTX) || t.uses(Use.CNS)) continue;\r\n      // loop through all outer clauses\r\n      for(int g = f - 1; g >= 0; --g) {\r\n        // stop if variable is shadowed or used by the current clause\r\n        if(fl[g].shadows(t.var) || t.uses(fl[g].var)) break;\r\n        // ignore let clauses and fragment constructors\r\n        if(fl[g] instanceof Let) continue;\r\n        // stop if variable is used by as position or score\r\n        final For fr = (For) fl[g];\r\n        if(fr.pos != null && t.uses(fr.pos) ||\r\n           fr.score != null && t.uses(fr.score)) break;\r\n\r\n        // move let clause to outer position\r\n        System.arraycopy(fl, g, fl, g + 1, f - g);\r\n        fl[g] = t;\r\n        t = fl[f];\r\n        if(!m) ctx.compInfo(OPTFORLET);\r\n        m = true;\r\n      }\r\n    }\r\n  }","commit_id":"166ae22911ddaf21e68561f18c6225259fed3273","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Expr comp(final QueryContext ctx) throws QueryException {\r\n    var = ctx.vars.get(var);\r\n    type = var.type();\r\n\r\n    // return if variable expression has not yet been assigned\r\n    Expr e = var.expr();\r\n    if(e == null) return this;\r\n\r\n    // pre-assign static variables\r\n    final Namespaces ns = ctx.ns;\r\n    ctx.ns = ns.copy();\r\n    if(ctx.nsElem.length != 0) ctx.ns.add(new QNm(EMPTY, ctx.nsElem), input);\r\n\r\n    /* Choose variables to be pre-evaluated.\r\n     * If a variable is pre-evaluated, it may not be available for further\r\n     * optimizations (index access, count, ...). On the other hand, repeated\r\n     * evaluation of the same expression is avoided. */\r\n    if(var.global || ctx.nsElem.length != 0 || ns.size() != 0 ||\r\n        var.type != null || e.uses(Use.FRG) || e instanceof FuncCall) {\r\n      e = var.value(ctx);\r\n    }\r\n\r\n    ctx.ns = ns;\r\n    return e;\r\n  }","id":47849,"modified_method":"@Override\r\n  public Expr comp(final QueryContext ctx) throws QueryException {\r\n    var = ctx.vars.get(var);\r\n    type = var.type();\r\n\r\n    // return if variable expression has not yet been assigned\r\n    Expr e = var.expr();\r\n    if(e == null) return this;\r\n\r\n    // pre-assign static variables\r\n    final Namespaces ns = ctx.ns;\r\n    ctx.ns = ns.copy();\r\n    if(ctx.nsElem.length != 0) ctx.ns.add(new QNm(EMPTY, ctx.nsElem), input);\r\n\r\n    /* Choose variables to be pre-evaluated.\r\n     * If a variable is pre-evaluated, it may not be available for further\r\n     * optimizations (index access, count, ...). On the other hand, repeated\r\n     * evaluation of the same expression is avoided. */\r\n    if(var.global || ctx.nsElem.length != 0 || ns.size() != 0 ||\r\n        var.type != null || e.uses(Use.CNS) || e instanceof FuncCall) {\r\n      e = var.value(ctx);\r\n    }\r\n\r\n    ctx.ns = ns;\r\n    return e;\r\n  }","commit_id":"166ae22911ddaf21e68561f18c6225259fed3273","url":"https://github.com/BaseXdb/basex"},{"original_method":"private void updateTags(RuleUpdate update, Context context) {\n    if (update.getTags() == null || update.getTags().isEmpty()) {\n      context.rule.setTags(Collections.<String>emptySet());\n    } else {\n      RuleTagHelper.applyTags(context.rule, update.getTags());\n    }\n  }","id":47850,"modified_method":"private void updateTags(RuleUpdate update, Context context) {\n    Set<String> tags = update.getTags();\n    if (tags == null || tags.isEmpty()) {\n      context.rule.setTags(Collections.<String>emptySet());\n    } else {\n      RuleTagHelper.applyTags(context.rule, tags);\n    }\n  }","commit_id":"5fd4c736d8e95d1bc98caeffa1891c04e9a7878b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void updateDebtRemediationFunction(RuleUpdate update, Context context) {\n    boolean noChar =\n      (context.rule.getDefaultSubCharacteristicId() == null && context.rule.getSubCharacteristicId() == null) ||\n        (context.rule.getSubCharacteristicId() != null && context.rule.getSubCharacteristicId().intValue() == RuleDto.DISABLED_CHARACTERISTIC_ID);\n\n    if (noChar || update.getDebtRemediationFunction() == null) {\n      context.rule.setRemediationFunction(null);\n      context.rule.setRemediationCoefficient(null);\n      context.rule.setRemediationOffset(null);\n    } else {\n      if (isSameAsDefaultFunction(update.getDebtRemediationFunction(), context.rule)) {\n        // reset to default\n        context.rule.setRemediationFunction(null);\n        context.rule.setRemediationCoefficient(null);\n        context.rule.setRemediationOffset(null);\n      } else {\n        context.rule.setRemediationFunction(update.getDebtRemediationFunction().type().name());\n        context.rule.setRemediationCoefficient(update.getDebtRemediationFunction().coefficient());\n        context.rule.setRemediationOffset(update.getDebtRemediationFunction().offset());\n      }\n    }\n  }","id":47851,"modified_method":"private void updateDebtRemediationFunction(RuleUpdate update, Context context) {\n    boolean noChar =\n      (context.rule.getDefaultSubCharacteristicId() == null && context.rule.getSubCharacteristicId() == null) ||\n        (context.rule.getSubCharacteristicId() != null && context.rule.getSubCharacteristicId().intValue() == RuleDto.DISABLED_CHARACTERISTIC_ID);\n\n    DebtRemediationFunction function = update.getDebtRemediationFunction();\n    if (noChar || function == null) {\n      context.rule.setRemediationFunction(null);\n      context.rule.setRemediationCoefficient(null);\n      context.rule.setRemediationOffset(null);\n    } else {\n      if (isSameAsDefaultFunction(function, context.rule)) {\n        // reset to default\n        context.rule.setRemediationFunction(null);\n        context.rule.setRemediationCoefficient(null);\n        context.rule.setRemediationOffset(null);\n      } else {\n        context.rule.setRemediationFunction(function.type().name());\n        context.rule.setRemediationCoefficient(function.coefficient());\n        context.rule.setRemediationOffset(function.offset());\n      }\n    }\n  }","commit_id":"5fd4c736d8e95d1bc98caeffa1891c04e9a7878b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Builds a default tooltip text for an HistoryOsmPrimitive <code>primitive<\/code>.\n     *\n     * @param primitive the primitmive\n     * @return the tooltip text\n     */\n    public String buildDefaultToolTip(HistoryOsmPrimitive primitive) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<html>\");\n        sb.append(\"<strong>id<\/strong>=\")\n        .append(primitive.getId())\n        .append(\"<br>\");\n        List<String> keyList = new ArrayList<>(primitive.getTags().keySet());\n        Collections.sort(keyList);\n        for (int i = 0; i < keyList.size(); i++) {\n            if (i > 0) {\n                sb.append(\"<br>\");\n            }\n            String key = keyList.get(i);\n            sb.append(\"<strong>\")\n            .append(key)\n            .append(\"<\/strong>\")\n            .append(\"=\");\n            String value = primitive.get(key);\n            while(value.length() != 0) {\n                sb.append(value.substring(0,Math.min(50, value.length())));\n                if (value.length() > 50) {\n                    sb.append(\"<br>\");\n                    value = value.substring(50);\n                } else {\n                    value = \"\";\n                }\n            }\n        }\n        sb.append(\"<\/html>\");\n        return sb.toString();\n    }","id":47852,"modified_method":"/**\n     * Builds a default tooltip text for an HistoryOsmPrimitive <code>primitive<\/code>.\n     *\n     * @param primitive the primitmive\n     * @return the tooltip text\n     */\n    public String buildDefaultToolTip(HistoryOsmPrimitive primitive) {\n        return buildDefaultToolTip(primitive.getId(), primitive.getTags());\n    }","commit_id":"34d28b511927edef64b62c5c21b54dc55e95223f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Builds a default tooltip text for the primitive <code>primitive<\/code>.\n     *\n     * @param primitive the primitmive\n     * @return the tooltip text\n     */\n    public String buildDefaultToolTip(IPrimitive primitive) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<html>\");\n        sb.append(\"<strong>id<\/strong>=\")\n        .append(primitive.getId())\n        .append(\"<br>\");\n        List<String> keyList = new ArrayList<>(primitive.keySet());\n        Collections.sort(keyList);\n        for (int i = 0; i < keyList.size(); i++) {\n            if (i > 0) {\n                sb.append(\"<br>\");\n            }\n            String key = keyList.get(i);\n            sb.append(\"<strong>\")\n            .append(key)\n            .append(\"<\/strong>\")\n            .append(\"=\");\n            String value = primitive.get(key);\n            while(value.length() != 0) {\n                sb.append(value.substring(0,Math.min(50, value.length())));\n                if (value.length() > 50) {\n                    sb.append(\"<br>\");\n                    value = value.substring(50);\n                } else {\n                    value = \"\";\n                }\n            }\n        }\n        sb.append(\"<\/html>\");\n        return sb.toString();\n    }","id":47853,"modified_method":"/**\n     * Builds a default tooltip text for the primitive <code>primitive<\/code>.\n     *\n     * @param primitive the primitmive\n     * @return the tooltip text\n     */\n    public String buildDefaultToolTip(IPrimitive primitive) {\n        return buildDefaultToolTip(primitive.getId(), primitive.getKeys());\n    }","commit_id":"34d28b511927edef64b62c5c21b54dc55e95223f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * render a node\n     * @param model  the model\n     * @param node the node\n     * @param isSelected true, if the current row is selected\n     */\n    protected  void renderNode(ListMergeModel<Node>.EntriesTableModel model, Node node, int row, boolean isSelected) {\n        setIcon(icon);\n        setBorder(null);\n        if (model.getListMergeModel().isFrozen()) {\n            setBackground(ConflictColors.BGCOLOR_FROZEN.get());\n        } else if (isSelected) {\n            setBackground(ConflictColors.BGCOLOR_SELECTED.get());\n        } else if (model.isParticipatingInCurrentComparePair()) {\n            if (model.isSamePositionInOppositeList(row)) {\n                setBackground(ConflictColors.BGCOLOR_SAME_POSITION_IN_OPPOSITE.get());\n            } else if (model.isIncludedInOppositeList(row)) {\n                setBackground(ConflictColors.BGCOLOR_IN_OPPOSITE.get());\n            } else {\n                setBackground(ConflictColors.BGCOLOR_NOT_IN_OPPOSITE.get());\n            }\n        }\n        setText(node.getDisplayName(DefaultNameFormatter.getInstance()));\n        setToolTipText(buildToolTipText(node));\n    }","id":47854,"modified_method":"/**\n     * render a node\n     * @param model  the model\n     * @param node the node\n     * @param isSelected true, if the current row is selected\n     */\n    protected  void renderNode(ListMergeModel<Node>.EntriesTableModel model, Node node, int row, boolean isSelected) {\n        setIcon(icon);\n        setBorder(null);\n        if (model.getListMergeModel().isFrozen()) {\n            setBackground(ConflictColors.BGCOLOR_FROZEN.get());\n        } else if (isSelected) {\n            setBackground(ConflictColors.BGCOLOR_SELECTED.get());\n        } else if (model.isParticipatingInCurrentComparePair()) {\n            if (model.isSamePositionInOppositeList(row)) {\n                setBackground(ConflictColors.BGCOLOR_SAME_POSITION_IN_OPPOSITE.get());\n            } else if (model.isIncludedInOppositeList(row)) {\n                setBackground(ConflictColors.BGCOLOR_IN_OPPOSITE.get());\n            } else {\n                setBackground(ConflictColors.BGCOLOR_NOT_IN_OPPOSITE.get());\n            }\n        }\n        setText(node.getDisplayName(DefaultNameFormatter.getInstance()));\n        setToolTipText(DefaultNameFormatter.getInstance().buildDefaultToolTip(node));\n    }","commit_id":"34d28b511927edef64b62c5c21b54dc55e95223f","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void renderPrimitive(RelationMember member) {\n        String displayName = member.getMember().getDisplayName(DefaultNameFormatter.getInstance());\n        setText(displayName);\n        setToolTipText(buildToolTipText(member.getMember()));\n        setIcon(ImageProvider.get(member.getDisplayType()));\n    }","id":47855,"modified_method":"protected void renderPrimitive(RelationMember member) {\n        String displayName = member.getMember().getDisplayName(DefaultNameFormatter.getInstance());\n        setText(displayName);\n        setToolTipText(DefaultNameFormatter.getInstance().buildDefaultToolTip(member.getMember()));\n        setIcon(ImageProvider.get(member.getDisplayType()));\n    }","commit_id":"34d28b511927edef64b62c5c21b54dc55e95223f","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        \r\n        // initialize the list manager\r\n        ListManager.switchboard = (Switchboard) env;\r\n        ListManager.listsPath = new File(ListManager.switchboard.getDataPath(),ListManager.switchboard.getConfig(\"listManager.listsPath\", \"DATA/LISTS\"));\r\n        \r\n        // get the list of supported blacklist types\r\n        final String supportedBlacklistTypesStr = Blacklist.BLACKLIST_TYPES_STRING;\r\n        final String[] supportedBlacklistTypes = supportedBlacklistTypesStr.split(\",\");\r\n        \r\n        // load all blacklist files located in the directory\r\n        List<String> dirlist = FileUtils.getDirListing(ListManager.listsPath, Blacklist.BLACKLIST_FILENAME_FILTER);\r\n        \r\n        String blacklistToUse = null;\r\n        final serverObjects prop = new serverObjects();\r\n        prop.putHTML(\"blacklistEngine\", Switchboard.urlBlacklist.getEngineInfo());\r\n\r\n        // do all post operations\r\n        if (post != null) {\r\n           \r\n            final String action = post.get(\"action\", \"\");\r\n            \r\n            if(post.containsKey(\"testList\")) {\r\n            \tprop.put(\"testlist\", \"1\");\r\n            \tString urlstring = post.get(\"testurl\", \"\");\r\n            \tif(!urlstring.startsWith(\"http://\") &&\r\n                        !urlstring.startsWith(\"https://\") &&\r\n                        !urlstring.startsWith(\"ftp://\") &&\r\n                        !urlstring.startsWith(\"smb://\") &&\r\n                        !urlstring.startsWith(\"file://\")) urlstring = \"http://\"+urlstring;\r\n                DigestURI testurl = null;\r\n\t\t\t\ttry {\r\n\t\t\t\t\ttesturl = new DigestURI(urlstring);\r\n\t\t\t\t} catch (final MalformedURLException e) { testurl = null; }\r\n\t\t\t\tif(testurl != null) {\r\n\t\t\t\t\tprop.putHTML(\"testlist_url\",testurl.toString());\r\n\t\t\t\t\tif(Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_CRAWLER, testurl))\r\n\t\t\t\t\t\tprop.put(\"testlist_listedincrawler\", \"1\");\r\n\t\t\t\t\tif(Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_DHT, testurl))\r\n\t\t\t\t\t\tprop.put(\"testlist_listedindht\", \"1\");\r\n\t\t\t\t\tif(Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_NEWS, testurl))\r\n\t\t\t\t\t\tprop.put(\"testlist_listedinnews\", \"1\");\r\n\t\t\t\t\tif(Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, testurl))\r\n\t\t\t\t\t\tprop.put(\"testlist_listedinproxy\", \"1\");\r\n\t\t\t\t\tif(Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_SEARCH, testurl))\r\n\t\t\t\t\t\tprop.put(\"testlist_listedinsearch\", \"1\");\r\n\t\t\t\t\tif(Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_SURFTIPS, testurl))\r\n\t\t\t\t\t\tprop.put(\"testlist_listedinsurftips\", \"1\");\r\n\t\t\t\t}\r\n\t\t\t\telse prop.put(\"testlist_url\",\"not valid\");\r\n            }\r\n        \tif (post.containsKey(\"selectList\")) {\r\n                blacklistToUse = post.get(\"selectedListName\"); \r\n                if (blacklistToUse != null && blacklistToUse.length() == 0) blacklistToUse = null;\r\n            }\r\n            if (post.containsKey(\"createNewList\")) {\r\n                /* ===========================================================\r\n                 * Creation of a new blacklist\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"newListName\", \"\").trim();\r\n                if (blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\",\"\");\r\n                    return prop;\r\n                }   \r\n                   \r\n                // Check if blacklist name only consists of \"legal\" characters.\r\n                // This is mainly done to prevent files from being written to other directories\r\n                // than the LISTS directory.\r\n                if (!blacklistToUse.matches(\"^[\\\\p{L}\\\\d\\\\+\\\\-_]+[\\\\p{L}\\\\d\\\\+\\\\-_.]*(\\\\.black){0,1}$\")) {\r\n                    prop.put(\"error\", 1);\r\n                    prop.putHTML(\"error_name\", blacklistToUse);\r\n                    blacklistToUse = null;\r\n                } else {\r\n                \r\n                    if (!blacklistToUse.endsWith(\".black\")) blacklistToUse += \".black\";\r\n\r\n                    if (!dirlist.contains(blacklistToUse)) {\r\n                        try {\r\n                            final File newFile = new File(ListManager.listsPath, blacklistToUse);\r\n                            newFile.createNewFile();\r\n\r\n                            // share the newly created blacklist\r\n                            ListManager.updateListSet(BLACKLIST_SHARED, blacklistToUse);\r\n\r\n                            // activate it for all known blacklist types\r\n                            for (int blTypes = 0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                                ListManager.updateListSet(supportedBlacklistTypes[blTypes] + \".BlackLists\", blacklistToUse);\r\n                            }                            \r\n                        } catch (final IOException e) {/* */}\r\n                    } else {\r\n                        prop.put(\"error\", 2);\r\n                        prop.putHTML(\"error_name\", blacklistToUse);\r\n                        blacklistToUse = null;\r\n                    }\r\n                    \r\n                    // reload Blacklists\r\n                    dirlist = FileUtils.getDirListing(ListManager.listsPath, Blacklist.BLACKLIST_FILENAME_FILTER);\r\n                }\r\n                \r\n            } else if (post.containsKey(\"deleteList\")) {\r\n                /* ===========================================================\r\n                 * Delete a blacklist\r\n                 * =========================================================== */                \r\n                \r\n                blacklistToUse = post.get(\"selectedListName\");\r\n                if (blacklistToUse == null || blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\",\"\");\r\n                    return prop;\r\n                }                   \r\n                \r\n                final File blackListFile = new File(ListManager.listsPath, blacklistToUse);\r\n                if(!blackListFile.delete()) {\r\n                    Log.logWarning(\"Blacklist\", \"file \"+ blackListFile +\" could not be deleted!\");\r\n                }\r\n\r\n                for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                    ListManager.removeFromListSet(supportedBlacklistTypes[blTypes] + \".BlackLists\",blacklistToUse);\r\n                }                \r\n                \r\n                // remove it from the shared list\r\n                ListManager.removeFromListSet(BLACKLIST_SHARED, blacklistToUse);\r\n                blacklistToUse = null;\r\n                \r\n                // reload Blacklists\r\n                dirlist = FileUtils.getDirListing(ListManager.listsPath, Blacklist.BLACKLIST_FILENAME_FILTER);\r\n\r\n            } else if (post.containsKey(\"activateList\")) {\r\n\r\n                /* ===========================================================\r\n                 * Activate/Deactivate a blacklist\r\n                 * =========================================================== */                   \r\n                \r\n                blacklistToUse = post.get(\"selectedListName\", \"\").trim();\r\n                if (blacklistToUse == null || blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\", \"\");\r\n                    return prop;\r\n                }                   \r\n                \r\n                for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {                    \r\n                    if (post.containsKey(\"activateList4\" + supportedBlacklistTypes[blTypes])) {\r\n                        ListManager.updateListSet(supportedBlacklistTypes[blTypes] + \".BlackLists\",blacklistToUse);\r\n                    } else {\r\n                        ListManager.removeFromListSet(supportedBlacklistTypes[blTypes] + \".BlackLists\",blacklistToUse);\r\n                    }                    \r\n                }                     \r\n\r\n                ListManager.reloadBlacklists();\r\n                \r\n            } else if (post.containsKey(\"shareList\")) {\r\n\r\n                /* ===========================================================\r\n                 * Share a blacklist\r\n                 * =========================================================== */                   \r\n                \r\n                blacklistToUse = post.get(\"selectedListName\", \"\").trim();\r\n                if (blacklistToUse == null || blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\", \"\");\r\n                    return prop;\r\n                }                   \r\n                \r\n                if (ListManager.listSetContains(BLACKLIST_SHARED, blacklistToUse)) {\r\n                    // Remove from shared BlackLists\r\n                    ListManager.removeFromListSet(BLACKLIST_SHARED, blacklistToUse);\r\n                } else { // inactive list -> enable\r\n                    ListManager.updateListSet(BLACKLIST_SHARED, blacklistToUse);\r\n                }\r\n            } else if (action.equals(\"deleteBlacklistEntry\")) {\r\n                \r\n                /* ===========================================================\r\n                 * Delete an entry from a blacklist\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                String temp = null;\r\n                \r\n                final String[] selectedBlacklistEntries = post.getAll(\"selectedEntry.*\");\r\n                \r\n                if (selectedBlacklistEntries.length > 0) {\r\n                    for (int i = 0; i < selectedBlacklistEntries.length; i++) {\r\n                        temp = deleteBlacklistEntry(blacklistToUse, selectedBlacklistEntries[i], header, supportedBlacklistTypes);\r\n                        if (temp != null) {\r\n                            prop.put(\"LOCATION\", temp);\r\n                            return prop;\r\n                        }\r\n                    }\r\n                }\r\n                ListManager.reloadBlacklists();\r\n\r\n            } else if (post.containsKey(\"addBlacklistEntry\")) {\r\n                \r\n                /* ===========================================================\r\n                 * Add new entry to blacklist\r\n                 * =========================================================== */\r\n\r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                String blentry = post.get(\"newEntry\", \"\").trim();\r\n                \r\n                // store this call as api call\r\n                ListManager.switchboard.tables.recordAPICall(post, \"Blacklist_p.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"add to blacklist: \" + blentry);\r\n                \r\n                final String temp = addBlacklistEntry(blacklistToUse, blentry, header, supportedBlacklistTypes);\r\n                if (temp != null) {\r\n                    prop.put(\"LOCATION\", temp);\r\n                    return prop;\r\n                }\r\n                ListManager.reloadBlacklists();\r\n                \r\n            } else if (action.equals(\"moveBlacklistEntry\")) {\r\n                \r\n                /* ===========================================================\r\n                 * Move an entry from one blacklist to another\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                String targetBlacklist = post.get(\"targetBlacklist\");\r\n                String temp = null;\r\n                \r\n                final String[] selectedBlacklistEntries = post.getAll(\"selectedEntry.*\");\r\n                \r\n                if (selectedBlacklistEntries != null &&\r\n                        selectedBlacklistEntries.length > 0 &&\r\n                        targetBlacklist != null &&\r\n                        blacklistToUse != null &&\r\n                        !targetBlacklist.equals(blacklistToUse)) {\r\n                    for (int i = 0; i < selectedBlacklistEntries.length; i++) {\r\n\r\n                        temp = addBlacklistEntry(targetBlacklist, selectedBlacklistEntries[i], header, supportedBlacklistTypes);\r\n                        if (temp != null) {\r\n                            prop.put(\"LOCATION\", temp);\r\n                            return prop;\r\n                        }\r\n\r\n                        temp = deleteBlacklistEntry(blacklistToUse, selectedBlacklistEntries[i], header, supportedBlacklistTypes);\r\n                        if (temp != null) {\r\n                            prop.put(\"LOCATION\", temp);\r\n                            return prop;\r\n                            \r\n                        }\r\n                    }\r\n                }\r\n                ListManager.reloadBlacklists();\r\n\r\n            } else if (action.equals(\"editBlacklistEntry\")) {\r\n                \r\n                /* ===========================================================\r\n                 * Edit entry of a blacklist\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                \r\n                final String[] editedBlacklistEntries = post.getAll(\"editedBlacklistEntry.*\");\r\n        \r\n                // if edited entry has been posted, save changes\r\n                if (editedBlacklistEntries.length > 0) {\r\n      \r\n                    final String[] selectedBlacklistEntries = post.getAll(\"selectedBlacklistEntry.*\");\r\n                    \r\n                    if (selectedBlacklistEntries.length != editedBlacklistEntries.length) {\r\n                        prop.put(\"LOCATION\", \"\");\r\n                        return prop;\r\n                    }\r\n                    \r\n                    String temp = null;\r\n\r\n                    for (int i = 0; i < selectedBlacklistEntries.length; i++) {\r\n\r\n                        if (!selectedBlacklistEntries[i].equals(editedBlacklistEntries[i])) {\r\n                            temp = deleteBlacklistEntry(blacklistToUse, selectedBlacklistEntries[i], header, supportedBlacklistTypes);\r\n                            if (temp != null) {\r\n                                prop.put(\"LOCATION\", temp);\r\n                                return prop;\r\n                            }\r\n\r\n                            temp = addBlacklistEntry(blacklistToUse, editedBlacklistEntries[i], header, supportedBlacklistTypes);\r\n                            if (temp != null) {\r\n                                prop.put(\"LOCATION\", temp);\r\n                                return prop;\r\n                            }\r\n                        }\r\n                    }\r\n                    ListManager.reloadBlacklists();\r\n                    prop.putHTML(DISABLED + EDIT + \"currentBlacklist\", blacklistToUse);\r\n                    \r\n                // else return entry to be edited\r\n                } else {\r\n                    final String[] selectedEntries = post.getAll(\"selectedEntry.*\");\r\n                    if (selectedEntries != null && selectedEntries.length > 0 && blacklistToUse != null) {\r\n                        for (int i = 0; i < selectedEntries.length; i++) {\r\n                            prop.putHTML(DISABLED + EDIT + \"editList_\" + i + \"_item\", selectedEntries[i]);\r\n                            prop.put(DISABLED + EDIT + \"editList_\" + i + \"_count\", i);\r\n                        }\r\n                        prop.putHTML(DISABLED + EDIT + \"currentBlacklist\", blacklistToUse);\r\n                        prop.put(DISABLED + \"edit\", \"1\");   \r\n                        prop.put(DISABLED + EDIT + \"editList\", selectedEntries.length);\r\n                    }\r\n                }\r\n            } else if (action.equals(\"selectRange\")) {\r\n                blacklistToUse = post.get(\"currentBlacklist\");\r\n            }\r\n\r\n        }\r\n\r\n        // if we have not chosen a blacklist until yet we use the first file\r\n        if (blacklistToUse == null && dirlist != null && !dirlist.isEmpty()) {\r\n            blacklistToUse = dirlist.get(0);\r\n        }\r\n\r\n        // Read the blacklist items from file\r\n        if (blacklistToUse != null) {\r\n            int entryCount = 0;\r\n            final List<String> list = FileUtils.getListArray(new File(ListManager.listsPath, blacklistToUse));\r\n            \r\n            // sort them\r\n            final String[] sortedlist = new String[list.size()];\r\n            Arrays.sort(list.toArray(sortedlist));\r\n            \r\n            // display them\r\n            boolean dark = true;\r\n            int offset = 0;\r\n            int size = 50;\r\n            int to = 50;\r\n            if (post != null) {\r\n                offset = post.getInt(\"offset\", 0);\r\n                size = post.getInt(\"size\", 50);\r\n                to = offset + size;\r\n            }\r\n            if (offset > sortedlist.length || offset < 0) {\r\n                offset = 0;\r\n            }\r\n            if (to > sortedlist.length || size < 1) {\r\n                to = sortedlist.length;\r\n            }\r\n\r\n            for (int j = offset; j < to; ++j){\r\n                final String nextEntry = sortedlist[j];\r\n                \r\n                if (nextEntry.length() == 0) continue;\r\n                if (nextEntry.charAt(0) == '#') continue;\r\n                prop.put(DISABLED + EDIT + \"Itemlist_\" + entryCount + \"_dark\", dark ? \"1\" : \"0\");\r\n                dark = !dark;\r\n                prop.putHTML(DISABLED + EDIT + \"Itemlist_\" + entryCount + \"_item\", nextEntry);\r\n                prop.put(DISABLED + EDIT + \"Itemlist_\" + entryCount + \"_count\", entryCount);\r\n                entryCount++;\r\n            }\r\n            prop.put(DISABLED + EDIT + \"Itemlist\", entryCount);\r\n\r\n            // create selection of sublist\r\n            entryCount = 0;\r\n            int end = -1;\r\n            int start = -1;\r\n            if (sortedlist.length > 0) {\r\n                while (end < sortedlist.length) {\r\n                    if (size > 0) {\r\n                        start = entryCount * size;\r\n                        end = (entryCount + 1) * size;\r\n                    } else {\r\n                        start = 0;\r\n                        end = sortedlist.length;\r\n                    }\r\n                    prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_value\", start);\r\n                    prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_fvalue\", start + 1);\r\n                    if (end > sortedlist.length) {\r\n                        end = sortedlist.length;\r\n                    }\r\n                    prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_tvalue\", end);\r\n                    if (start == offset) {\r\n                        prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_selected\", 1);\r\n                    }\r\n                    entryCount++;\r\n                }\r\n            } else {\r\n                prop.put(DISABLED + EDIT + \"subListOffset_0_value\", 0);\r\n                prop.put(DISABLED + EDIT + \"subListOffset_0_fvalue\", 0);\r\n                prop.put(DISABLED + EDIT + \"subListOffset_0_tvalue\", 0);\r\n                entryCount++;\r\n            }\r\n            prop.put(DISABLED + EDIT + \"subListOffset\", entryCount);\r\n\r\n            // create selection of list size\r\n            int[] sizes = {10,25,50,100,250,-1};\r\n            for (int i = 0; i < sizes.length; i++) {\r\n                prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_value\", sizes[i]);\r\n                if (sizes[i] == -1) {\r\n                    prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_text\", \"all\");\r\n                } else {\r\n                    prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_text\", sizes[i]);\r\n                }\r\n                if (sizes[i] == size) {\r\n                    prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_selected\", 1);\r\n                }\r\n            }\r\n            prop.put(DISABLED + EDIT + \"subListSize\", sizes.length);\r\n        }\r\n        \r\n        // List BlackLists\r\n        int blacklistCount = 0;\r\n        int blacklistMoveCount = 0;\r\n        if (dirlist != null) {\r\n\r\n            for (String element : dirlist) {\r\n                prop.putXML(DISABLED + BLACKLIST + blacklistCount + \"_name\", element);\r\n                prop.put(DISABLED + BLACKLIST + blacklistCount + \"_selected\", \"0\");\r\n\r\n                if (element.equals(blacklistToUse)) { //current List\r\n                    prop.put(DISABLED + BLACKLIST + blacklistCount + \"_selected\", \"1\");\r\n\r\n                    for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                        prop.putXML(DISABLED + \"currentActiveFor_\" + blTypes + \"_blTypeName\",supportedBlacklistTypes[blTypes]);\r\n                        prop.put(DISABLED + \"currentActiveFor_\" + blTypes + \"_checked\",\r\n                                ListManager.listSetContains(supportedBlacklistTypes[blTypes] + \".BlackLists\", element) ? \"0\" : \"1\");\r\n                    }\r\n                    prop.put(DISABLED + \"currentActiveFor\", supportedBlacklistTypes.length);\r\n\r\n                } else {\r\n                    prop.putXML(DISABLED + EDIT + BLACKLIST_MOVE + blacklistMoveCount + \"_name\", element);\r\n                    blacklistMoveCount++;\r\n                }\r\n                \r\n                if (ListManager.listSetContains(BLACKLIST_SHARED, element)) {\r\n                    prop.put(DISABLED + BLACKLIST + blacklistCount + \"_shared\", \"1\");\r\n                } else {\r\n                    prop.put(DISABLED + BLACKLIST + blacklistCount + \"_shared\", \"0\");\r\n                }\r\n\r\n                int activeCount = 0;\r\n                for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                    if (ListManager.listSetContains(supportedBlacklistTypes[blTypes] + \".BlackLists\", element)) {\r\n                        prop.putHTML(DISABLED + BLACKLIST + blacklistCount + \"_active_\" + activeCount + \"_blTypeName\", supportedBlacklistTypes[blTypes]);\r\n                        activeCount++;\r\n                    }                \r\n                }          \r\n                prop.put(DISABLED + BLACKLIST + blacklistCount + \"_active\", activeCount);\r\n                blacklistCount++;\r\n            }\r\n        }\r\n        prop.put(DISABLED + \"blackLists\", blacklistCount);\r\n        prop.put(DISABLED + EDIT + \"blackListsMove\", blacklistMoveCount);\r\n        \r\n        prop.putXML(DISABLED + \"currentBlacklist\", (blacklistToUse==null) ? \"\" : blacklistToUse);\r\n        prop.putXML(DISABLED + EDIT + \"currentBlacklist\", (blacklistToUse==null) ? \"\" : blacklistToUse);\r\n        prop.put(\"disabled\", (blacklistToUse == null) ? \"1\" : \"0\");\r\n        return prop;\r\n    }","id":47856,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        \r\n        // initialize the list manager\r\n        ListManager.switchboard = (Switchboard) env;\r\n        ListManager.listsPath = new File(ListManager.switchboard.getDataPath(),ListManager.switchboard.getConfig(\"listManager.listsPath\", \"DATA/LISTS\"));\r\n        \r\n        // get the list of supported blacklist types\r\n        final String supportedBlacklistTypesStr = Blacklist.BLACKLIST_TYPES_STRING;\r\n        final String[] supportedBlacklistTypes = supportedBlacklistTypesStr.split(\",\");\r\n        \r\n        // load all blacklist files located in the directory\r\n        List<String> dirlist = FileUtils.getDirListing(ListManager.listsPath, Blacklist.BLACKLIST_FILENAME_FILTER);\r\n        \r\n        String blacklistToUse = null;\r\n        final serverObjects prop = new serverObjects();\r\n        prop.putHTML(\"blacklistEngine\", Switchboard.urlBlacklist.getEngineInfo());\r\n\r\n        // do all post operations\r\n        if (post != null) {\r\n           \r\n            final String action = post.get(\"action\", \"\");\r\n            \r\n            if(post.containsKey(\"testList\")) {\r\n            \tprop.put(\"testlist\", \"1\");\r\n            \tString urlstring = post.get(\"testurl\", \"\");\r\n            \tif (!urlstring.startsWith(\"http://\") &&\r\n                        !urlstring.startsWith(\"https://\") &&\r\n                        !urlstring.startsWith(\"ftp://\") &&\r\n                        !urlstring.startsWith(\"smb://\") &&\r\n                        !urlstring.startsWith(\"file://\")) {\r\n                    urlstring = \"http://\"+urlstring;\r\n                }\r\n                DigestURI testurl;\r\n                try {\r\n                    testurl = new DigestURI(urlstring);\r\n                } catch (final MalformedURLException e) {\r\n                    testurl = null;\r\n                }\r\n                if(testurl != null) {\r\n                    prop.putHTML(\"testlist_url\",testurl.toString());\r\n                    if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_CRAWLER, testurl)) {\r\n                            prop.put(\"testlist_listedincrawler\", \"1\");\r\n                    }\r\n                    if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_DHT, testurl)) {\r\n                            prop.put(\"testlist_listedindht\", \"1\");\r\n                    }\r\n                    if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_NEWS, testurl)) {\r\n                            prop.put(\"testlist_listedinnews\", \"1\");\r\n                    }\r\n                    if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_PROXY, testurl)) {\r\n                            prop.put(\"testlist_listedinproxy\", \"1\");\r\n                    }\r\n                    if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_SEARCH, testurl)) {\r\n                            prop.put(\"testlist_listedinsearch\", \"1\");\r\n                    }\r\n                    if (Switchboard.urlBlacklist.isListed(Blacklist.BLACKLIST_SURFTIPS, testurl)) {\r\n                            prop.put(\"testlist_listedinsurftips\", \"1\");\r\n                    }\r\n                } else {\r\n                    prop.put(\"testlist_url\",\"not valid\");\r\n                }\r\n            }\r\n            if (post.containsKey(\"selectList\")) {\r\n                blacklistToUse = post.get(\"selectedListName\");\r\n                if (blacklistToUse != null && blacklistToUse.length() == 0) {\r\n                    blacklistToUse = null;\r\n                }\r\n            }\r\n            if (post.containsKey(\"createNewList\")) {\r\n                /* ===========================================================\r\n                 * Creation of a new blacklist\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"newListName\", \"\").trim();\r\n                if (blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\",\"\");\r\n                    return prop;\r\n                }   \r\n                   \r\n                // Check if blacklist name only consists of \"legal\" characters.\r\n                // This is mainly done to prevent files from being written to other directories\r\n                // than the LISTS directory.\r\n                if (!blacklistToUse.matches(\"^[\\\\p{L}\\\\d\\\\+\\\\-_]+[\\\\p{L}\\\\d\\\\+\\\\-_.]*(\\\\.black){0,1}$\")) {\r\n                    prop.put(\"error\", 1);\r\n                    prop.putHTML(\"error_name\", blacklistToUse);\r\n                    blacklistToUse = null;\r\n                } else {\r\n                \r\n                    if (!blacklistToUse.endsWith(\".black\")) {\r\n                        blacklistToUse += \".black\";\r\n                    }\r\n\r\n                    if (!dirlist.contains(blacklistToUse)) {\r\n                        try {\r\n                            final File newFile = new File(ListManager.listsPath, blacklistToUse);\r\n                            newFile.createNewFile();\r\n\r\n                            // share the newly created blacklist\r\n                            ListManager.updateListSet(BLACKLIST_SHARED, blacklistToUse);\r\n\r\n                            // activate it for all known blacklist types\r\n                            for (final String supportedBlacklistType : supportedBlacklistTypes) {\r\n                                ListManager.updateListSet(supportedBlacklistType + \".BlackLists\", blacklistToUse);\r\n                            }                            \r\n                        } catch (final IOException e) {/* */}\r\n                    } else {\r\n                        prop.put(\"error\", 2);\r\n                        prop.putHTML(\"error_name\", blacklistToUse);\r\n                        blacklistToUse = null;\r\n                    }\r\n                    \r\n                    // reload Blacklists\r\n                    dirlist = FileUtils.getDirListing(ListManager.listsPath, Blacklist.BLACKLIST_FILENAME_FILTER);\r\n                }\r\n                \r\n            } else if (post.containsKey(\"deleteList\")) {\r\n                /* ===========================================================\r\n                 * Delete a blacklist\r\n                 * =========================================================== */                \r\n                \r\n                blacklistToUse = post.get(\"selectedListName\");\r\n                if (blacklistToUse == null || blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\",\"\");\r\n                    return prop;\r\n                }                   \r\n                \r\n                final File blackListFile = new File(ListManager.listsPath, blacklistToUse);\r\n                if(!blackListFile.delete()) {\r\n                    Log.logWarning(\"Blacklist\", \"file \"+ blackListFile +\" could not be deleted!\");\r\n                }\r\n\r\n                for (final String supportedBlacklistType : supportedBlacklistTypes) {\r\n                    ListManager.removeFromListSet(supportedBlacklistType + \".BlackLists\",blacklistToUse);\r\n                }                \r\n                \r\n                // remove it from the shared list\r\n                ListManager.removeFromListSet(BLACKLIST_SHARED, blacklistToUse);\r\n                blacklistToUse = null;\r\n                \r\n                // reload Blacklists\r\n                dirlist = FileUtils.getDirListing(ListManager.listsPath, Blacklist.BLACKLIST_FILENAME_FILTER);\r\n\r\n            } else if (post.containsKey(\"activateList\")) {\r\n\r\n                /* ===========================================================\r\n                 * Activate/Deactivate a blacklist\r\n                 * =========================================================== */                   \r\n                \r\n                blacklistToUse = post.get(\"selectedListName\", \"\").trim();\r\n                if (blacklistToUse == null || blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\", \"\");\r\n                    return prop;\r\n                }                   \r\n                \r\n                for (final String supportedBlacklistType : supportedBlacklistTypes) {\r\n                    if (post.containsKey(\"activateList4\" + supportedBlacklistType)) {\r\n                        ListManager.updateListSet(supportedBlacklistType + \".BlackLists\",blacklistToUse);\r\n                    } else {\r\n                        ListManager.removeFromListSet(supportedBlacklistType + \".BlackLists\",blacklistToUse);\r\n                    }                    \r\n                }                     \r\n\r\n                ListManager.reloadBlacklists();\r\n                \r\n            } else if (post.containsKey(\"shareList\")) {\r\n\r\n                /* ===========================================================\r\n                 * Share a blacklist\r\n                 * =========================================================== */                   \r\n                \r\n                blacklistToUse = post.get(\"selectedListName\", \"\").trim();\r\n                if (blacklistToUse == null || blacklistToUse.length() == 0) {\r\n                    prop.put(\"LOCATION\", \"\");\r\n                    return prop;\r\n                }                   \r\n                \r\n                if (ListManager.listSetContains(BLACKLIST_SHARED, blacklistToUse)) {\r\n                    // Remove from shared BlackLists\r\n                    ListManager.removeFromListSet(BLACKLIST_SHARED, blacklistToUse);\r\n                } else { // inactive list -> enable\r\n                    ListManager.updateListSet(BLACKLIST_SHARED, blacklistToUse);\r\n                }\r\n            } else if (action.equals(\"deleteBlacklistEntry\")) {\r\n                \r\n                /* ===========================================================\r\n                 * Delete an entry from a blacklist\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                \r\n                final String[] selectedBlacklistEntries = post.getAll(\"selectedEntry.*\");\r\n                \r\n                if (selectedBlacklistEntries.length > 0) {\r\n                    String temp = null;\r\n                    for (final String selectedBlacklistEntry : selectedBlacklistEntries) {\r\n                        if ((temp = deleteBlacklistEntry(blacklistToUse, selectedBlacklistEntry, header, supportedBlacklistTypes)) != null) {\r\n                            prop.put(\"LOCATION\", temp);\r\n                            return prop;\r\n                        }\r\n                    }\r\n                }\r\n                ListManager.reloadBlacklists();\r\n\r\n            } else if (post.containsKey(\"addBlacklistEntry\")) {\r\n                \r\n                /* ===========================================================\r\n                 * Add new entry to blacklist\r\n                 * =========================================================== */\r\n\r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                final String blentry = post.get(\"newEntry\", \"\").trim();\r\n                \r\n                // store this call as api call\r\n                ListManager.switchboard.tables.recordAPICall(post, \"Blacklist_p.html\", WorkTables.TABLE_API_TYPE_CONFIGURATION, \"add to blacklist: \" + blentry);\r\n                \r\n                final String temp = addBlacklistEntry(blacklistToUse, blentry, header, supportedBlacklistTypes);\r\n                if (temp != null) {\r\n                    prop.put(\"LOCATION\", temp);\r\n                    return prop;\r\n                }\r\n                ListManager.reloadBlacklists();\r\n                \r\n            } else if (\"moveBlacklistEntry\".equals(action)) {\r\n                \r\n                /* ===========================================================\r\n                 * Move an entry from one blacklist to another\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                final String targetBlacklist = post.get(\"targetBlacklist\");\r\n                \r\n                final String[] selectedBlacklistEntries = post.getAll(\"selectedEntry.*\");\r\n                \r\n                if (selectedBlacklistEntries != null &&\r\n                        selectedBlacklistEntries.length > 0 &&\r\n                        targetBlacklist != null &&\r\n                        blacklistToUse != null &&\r\n                        !targetBlacklist.equals(blacklistToUse)) {\r\n                    String temp;\r\n                    for (final String selectedBlacklistEntry : selectedBlacklistEntries) {\r\n                        if ((temp = addBlacklistEntry(targetBlacklist, selectedBlacklistEntry, header, supportedBlacklistTypes)) != null) {\r\n                            prop.put(\"LOCATION\", temp);\r\n                            return prop;\r\n                        }\r\n\r\n                        if ((temp = deleteBlacklistEntry(blacklistToUse, selectedBlacklistEntry, header, supportedBlacklistTypes)) != null) {\r\n                            prop.put(\"LOCATION\", temp);\r\n                            return prop;\r\n                            \r\n                        }\r\n                    }\r\n                }\r\n                ListManager.reloadBlacklists();\r\n\r\n            } else if (\"editBlacklistEntry\".equals(action)) {\r\n                \r\n                /* ===========================================================\r\n                 * Edit entry of a blacklist\r\n                 * =========================================================== */\r\n                \r\n                blacklistToUse = post.get(\"currentBlacklist\", \"\").trim();\r\n                \r\n                final String[] editedBlacklistEntries = post.getAll(\"editedBlacklistEntry.*\");\r\n        \r\n                // if edited entry has been posted, save changes\r\n                if (editedBlacklistEntries.length > 0) {\r\n      \r\n                    final String[] selectedBlacklistEntries = post.getAll(\"selectedBlacklistEntry.*\");\r\n                    \r\n                    if (selectedBlacklistEntries.length != editedBlacklistEntries.length) {\r\n                        prop.put(\"LOCATION\", \"\");\r\n                        return prop;\r\n                    }\r\n                    \r\n                    String temp = null;\r\n\r\n                    for (int i = 0; i < selectedBlacklistEntries.length; i++) {\r\n\r\n                        if (!selectedBlacklistEntries[i].equals(editedBlacklistEntries[i])) {\r\n\r\n                            if ((temp = deleteBlacklistEntry(blacklistToUse, selectedBlacklistEntries[i], header, supportedBlacklistTypes)) != null) {\r\n                                prop.put(\"LOCATION\", temp);\r\n                                return prop;\r\n                            }\r\n\r\n                            if ((temp = addBlacklistEntry(blacklistToUse, editedBlacklistEntries[i], header, supportedBlacklistTypes)) != null) {\r\n                                prop.put(\"LOCATION\", temp);\r\n                                return prop;\r\n                            }\r\n                        }\r\n                    }\r\n                    ListManager.reloadBlacklists();\r\n                    prop.putHTML(DISABLED + EDIT + \"currentBlacklist\", blacklistToUse);\r\n                    \r\n                // else return entry to be edited\r\n                } else {\r\n                    final String[] selectedEntries = post.getAll(\"selectedEntry.*\");\r\n                    if (selectedEntries != null && selectedEntries.length > 0 && blacklistToUse != null) {\r\n                        for (int i = 0; i < selectedEntries.length; i++) {\r\n                            prop.putHTML(DISABLED + EDIT + \"editList_\" + i + \"_item\", selectedEntries[i]);\r\n                            prop.put(DISABLED + EDIT + \"editList_\" + i + \"_count\", i);\r\n                        }\r\n                        prop.putHTML(DISABLED + EDIT + \"currentBlacklist\", blacklistToUse);\r\n                        prop.put(DISABLED + \"edit\", \"1\");   \r\n                        prop.put(DISABLED + EDIT + \"editList\", selectedEntries.length);\r\n                    }\r\n                }\r\n            } else if (\"selectRange\".equals(action)) {\r\n                blacklistToUse = post.get(\"currentBlacklist\");\r\n            }\r\n\r\n        }\r\n\r\n        // if we have not chosen a blacklist until yet we use the first file\r\n        if (blacklistToUse == null && dirlist != null && !dirlist.isEmpty()) {\r\n            blacklistToUse = dirlist.get(0);\r\n        }\r\n\r\n        // Read the blacklist items from file\r\n        if (blacklistToUse != null) {\r\n            int entryCount = 0;\r\n            final List<String> list = FileUtils.getListArray(new File(ListManager.listsPath, blacklistToUse));\r\n            \r\n            // sort them\r\n            final String[] sortedlist = new String[list.size()];\r\n            Arrays.sort(list.toArray(sortedlist));\r\n            \r\n            // display them\r\n            boolean dark = true;\r\n            int offset = 0;\r\n            int size = 50;\r\n            int to = 50;\r\n            if (post != null) {\r\n                offset = post.getInt(\"offset\", 0);\r\n                size = post.getInt(\"size\", 50);\r\n                to = offset + size;\r\n            }\r\n            if (offset > sortedlist.length || offset < 0) {\r\n                offset = 0;\r\n            }\r\n            if (to > sortedlist.length || size < 1) {\r\n                to = sortedlist.length;\r\n            }\r\n\r\n            for (int j = offset; j < to; ++j){\r\n                final String nextEntry = sortedlist[j];\r\n                \r\n                if (nextEntry.length() == 0) continue;\r\n                if (nextEntry.charAt(0) == '#') continue;\r\n                prop.put(DISABLED + EDIT + \"Itemlist_\" + entryCount + \"_dark\", dark ? \"1\" : \"0\");\r\n                dark = !dark;\r\n                prop.putHTML(DISABLED + EDIT + \"Itemlist_\" + entryCount + \"_item\", nextEntry);\r\n                prop.put(DISABLED + EDIT + \"Itemlist_\" + entryCount + \"_count\", entryCount);\r\n                entryCount++;\r\n            }\r\n            prop.put(DISABLED + EDIT + \"Itemlist\", entryCount);\r\n\r\n            // create selection of sublist\r\n            entryCount = 0;\r\n            int end = -1;\r\n            int start = -1;\r\n            if (sortedlist.length > 0) {\r\n                while (end < sortedlist.length) {\r\n                    if (size > 0) {\r\n                        start = entryCount * size;\r\n                        end = (entryCount + 1) * size;\r\n                    } else {\r\n                        start = 0;\r\n                        end = sortedlist.length;\r\n                    }\r\n                    prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_value\", start);\r\n                    prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_fvalue\", start + 1);\r\n                    if (end > sortedlist.length) {\r\n                        end = sortedlist.length;\r\n                    }\r\n                    prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_tvalue\", end);\r\n                    if (start == offset) {\r\n                        prop.put(DISABLED + EDIT + \"subListOffset_\" + entryCount + \"_selected\", 1);\r\n                    }\r\n                    entryCount++;\r\n                }\r\n            } else {\r\n                prop.put(DISABLED + EDIT + \"subListOffset_0_value\", 0);\r\n                prop.put(DISABLED + EDIT + \"subListOffset_0_fvalue\", 0);\r\n                prop.put(DISABLED + EDIT + \"subListOffset_0_tvalue\", 0);\r\n                entryCount++;\r\n            }\r\n            prop.put(DISABLED + EDIT + \"subListOffset\", entryCount);\r\n\r\n            // create selection of list size\r\n            int[] sizes = {10,25,50,100,250,-1};\r\n            for (int i = 0; i < sizes.length; i++) {\r\n                prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_value\", sizes[i]);\r\n                if (sizes[i] == -1) {\r\n                    prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_text\", \"all\");\r\n                } else {\r\n                    prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_text\", sizes[i]);\r\n                }\r\n                if (sizes[i] == size) {\r\n                    prop.put(DISABLED + EDIT + \"subListSize_\" + i + \"_selected\", 1);\r\n                }\r\n            }\r\n            prop.put(DISABLED + EDIT + \"subListSize\", sizes.length);\r\n        }\r\n        \r\n        // List BlackLists\r\n        int blacklistCount = 0;\r\n        int blacklistMoveCount = 0;\r\n        if (dirlist != null) {\r\n\r\n            for (String element : dirlist) {\r\n                prop.putXML(DISABLED + BLACKLIST + blacklistCount + \"_name\", element);\r\n                prop.put(DISABLED + BLACKLIST + blacklistCount + \"_selected\", \"0\");\r\n\r\n                if (element.equals(blacklistToUse)) { //current List\r\n                    prop.put(DISABLED + BLACKLIST + blacklistCount + \"_selected\", \"1\");\r\n\r\n                    for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                        prop.putXML(DISABLED + \"currentActiveFor_\" + blTypes + \"_blTypeName\",supportedBlacklistTypes[blTypes]);\r\n                        prop.put(DISABLED + \"currentActiveFor_\" + blTypes + \"_checked\",\r\n                                ListManager.listSetContains(supportedBlacklistTypes[blTypes] + \".BlackLists\", element) ? \"0\" : \"1\");\r\n                    }\r\n                    prop.put(DISABLED + \"currentActiveFor\", supportedBlacklistTypes.length);\r\n\r\n                } else {\r\n                    prop.putXML(DISABLED + EDIT + BLACKLIST_MOVE + blacklistMoveCount + \"_name\", element);\r\n                    blacklistMoveCount++;\r\n                }\r\n                \r\n                if (ListManager.listSetContains(BLACKLIST_SHARED, element)) {\r\n                    prop.put(DISABLED + BLACKLIST + blacklistCount + \"_shared\", \"1\");\r\n                } else {\r\n                    prop.put(DISABLED + BLACKLIST + blacklistCount + \"_shared\", \"0\");\r\n                }\r\n\r\n                int activeCount = 0;\r\n                for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                    if (ListManager.listSetContains(supportedBlacklistTypes[blTypes] + \".BlackLists\", element)) {\r\n                        prop.putHTML(DISABLED + BLACKLIST + blacklistCount + \"_active_\" + activeCount + \"_blTypeName\", supportedBlacklistTypes[blTypes]);\r\n                        activeCount++;\r\n                    }                \r\n                }          \r\n                prop.put(DISABLED + BLACKLIST + blacklistCount + \"_active\", activeCount);\r\n                blacklistCount++;\r\n            }\r\n        }\r\n        prop.put(DISABLED + \"blackLists\", blacklistCount);\r\n        prop.put(DISABLED + EDIT + \"blackListsMove\", blacklistMoveCount);\r\n        \r\n        prop.putXML(DISABLED + \"currentBlacklist\", (blacklistToUse==null) ? \"\" : blacklistToUse);\r\n        prop.putXML(DISABLED + EDIT + \"currentBlacklist\", (blacklistToUse==null) ? \"\" : blacklistToUse);\r\n        prop.put(\"disabled\", (blacklistToUse == null) ? \"1\" : \"0\");\r\n        return prop;\r\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * This method deletes a blacklist entry.\r\n     * @param blacklistToUse the name of the blacklist the entry is to be deleted from\r\n     * @param oldEntry the entry that is to be deleted\r\n     * @param supportedBlacklistTypes\r\n     */\r\n    public static void deleteBlacklistEntry(\r\n            final File listsPath,\r\n            final String blacklistToUse,\r\n            String oldEntry, \r\n            final String[] supportedBlacklistTypes) {\r\n\r\n        // load blacklist data from file\r\n        final ArrayList<String> list = FileUtils.getListArray(new File(listsPath, blacklistToUse));\r\n\r\n        // delete the old entry from file\r\n        if (list != null) {\r\n            for (int i=0; i < list.size(); i++) {\r\n                if ((list.get(i)).equals(oldEntry)) {\r\n                    list.remove(i);\r\n                    break;\r\n                }\r\n            }\r\n            FileUtils.writeList(new File(listsPath, blacklistToUse), list.toArray(new String[list.size()]));\r\n        }\r\n\r\n        // remove the entry from the running blacklist engine\r\n        int pos = oldEntry.indexOf('/');\r\n        if (pos < 0) {\r\n            // add default empty path pattern\r\n            pos = oldEntry.length();\r\n            oldEntry = oldEntry + \"/.*\";\r\n        }\r\n        for (int blTypes=0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n            if (ListManager.listSetContains(supportedBlacklistTypes[blTypes] + \".BlackLists\",blacklistToUse)) {\r\n                Switchboard.urlBlacklist.remove(supportedBlacklistTypes[blTypes],oldEntry.substring(0, pos), oldEntry.substring(pos + 1));\r\n            }\r\n        }\r\n    }","id":47857,"modified_method":"/**\r\n     * This method deletes a blacklist entry.\r\n     * @param blacklistToUse the name of the blacklist the entry is to be deleted from\r\n     * @param oldEntry the entry that is to be deleted\r\n     * @param supportedBlacklistTypes\r\n     */\r\n    private static void deleteBlacklistEntry(\r\n            final File listsPath,\r\n            final String blacklistToUse,\r\n            String oldEntry, \r\n            final String[] supportedBlacklistTypes) {\r\n\r\n        // load blacklist data from file\r\n        final List<String> list = FileUtils.getListArray(new File(listsPath, blacklistToUse));\r\n\r\n        // delete the old entry from file\r\n        if (list != null) {\r\n            for (final String entry : list) {\r\n                if (entry.equals(oldEntry)) {\r\n                    list.remove(entry);\r\n                    break;\r\n                }\r\n            }\r\n            FileUtils.writeList(new File(listsPath, blacklistToUse), list.toArray(new String[list.size()]));\r\n        }\r\n\r\n        // remove the entry from the running blacklist engine\r\n        int pos = oldEntry.indexOf('/');\r\n        if (pos < 0) {\r\n            // add default empty path pattern\r\n            pos = oldEntry.length();\r\n            oldEntry = oldEntry + \"/.*\";\r\n        }\r\n        for (final String supportedBlacklistType : supportedBlacklistTypes) {\r\n            if (ListManager.listSetContains(supportedBlacklistType + \".BlackLists\",blacklistToUse)) {\r\n                Switchboard.urlBlacklist.remove(supportedBlacklistType,oldEntry.substring(0, pos), oldEntry.substring(pos + 1));\r\n            }\r\n        }\r\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * This method adds a new entry to the chosen blacklist.\r\n     * @param blacklistToUse the name of the blacklist the entry is to be added to\r\n     * @param newEntry the entry that is to be added\r\n     * @param supportedBlacklistTypes\r\n     */\r\n    public static void addBlacklistEntry(\r\n            final File listsPath,\r\n            final String blacklistToUse,\r\n            String newEntry,\r\n            final String[] supportedBlacklistTypes) {\r\n\r\n        // TODO: ignore empty entries\r\n\r\n        if (newEntry.startsWith(\"http://\") ){\r\n            newEntry = newEntry.substring(7);\r\n        } else if (newEntry.startsWith(\"https://\")) {\r\n            newEntry = newEntry.substring(8);\r\n        }\r\n\r\n        int pos = newEntry.indexOf('/');\r\n        if (pos < 0) {\r\n            // add default empty path pattern\r\n            pos = newEntry.length();\r\n            newEntry = newEntry + \"/.*\";\r\n        }\r\n\r\n        if (!Blacklist.blacklistFileContains(listsPath, blacklistToUse, newEntry)) {\r\n            // append the line to the file\r\n            PrintWriter pw = null;\r\n            try {\r\n                pw = new PrintWriter(new FileWriter(new File(listsPath, blacklistToUse), true));\r\n                pw.println(newEntry);\r\n                pw.close();\r\n            } catch (final IOException e) {\r\n                Log.logException(e);\r\n            } finally {\r\n                if (pw != null) {\r\n                    try {\r\n                        pw.close();\r\n                    } catch (final Exception e) {\r\n                        Log.logWarning(\"Blacklist\", \"could not close stream to \" + blacklistToUse + \"! \" + e.getMessage());\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            // add to blacklist\r\n            for (int blTypes = 0; blTypes < supportedBlacklistTypes.length; blTypes++) {\r\n                if (ListManager.listSetContains(supportedBlacklistTypes[blTypes] + \".BlackLists\", blacklistToUse)) {\r\n                    Switchboard.urlBlacklist.add(supportedBlacklistTypes[blTypes], newEntry.substring(0, pos), newEntry.substring(pos + 1));\r\n                }\r\n            }\r\n        }\r\n    }","id":47858,"modified_method":"/**\r\n     * This method adds a new entry to the chosen blacklist.\r\n     * @param blacklistToUse the name of the blacklist the entry is to be added to\r\n     * @param newEntry the entry that is to be added\r\n     * @param supportedBlacklistTypes\r\n     */\r\n    private static void addBlacklistEntry(\r\n            final File listsPath,\r\n            final String blacklistToUse,\r\n            String newEntry,\r\n            final String[] supportedBlacklistTypes) {\r\n\r\n        // TODO: ignore empty entries\r\n\r\n        if (newEntry.startsWith(\"http://\") ){\r\n            newEntry = newEntry.substring(7);\r\n        } else if (newEntry.startsWith(\"https://\")) {\r\n            newEntry = newEntry.substring(8);\r\n        }\r\n\r\n        int pos = newEntry.indexOf('/');\r\n        if (pos < 0) {\r\n            // add default empty path pattern\r\n            pos = newEntry.length();\r\n            newEntry = newEntry + \"/.*\";\r\n        }\r\n\r\n        if (!Blacklist.blacklistFileContains(listsPath, blacklistToUse, newEntry)) {\r\n            // append the line to the file\r\n            PrintWriter pw = null;\r\n            try {\r\n                pw = new PrintWriter(new FileWriter(new File(listsPath, blacklistToUse), true));\r\n                pw.println(newEntry);\r\n                pw.close();\r\n            } catch (final IOException e) {\r\n                Log.logException(e);\r\n            } finally {\r\n                if (pw != null) {\r\n                    try {\r\n                        pw.close();\r\n                    } catch (final Exception e) {\r\n                        Log.logWarning(\"Blacklist\", \"could not close stream to \" + blacklistToUse + \"! \" + e.getMessage());\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            // add to blacklist\r\n            for (final String supportedBlacklistType : supportedBlacklistTypes) {\r\n                if (ListManager.listSetContains(supportedBlacklistType + \".BlackLists\", blacklistToUse)) {\r\n                    Switchboard.urlBlacklist.add(supportedBlacklistType, newEntry.substring(0, pos), newEntry.substring(pos + 1));\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static serverObjects putBlogDefault(\n            final serverObjects prop,\n            final Switchboard switchboard,\n            final String address,\n            int start,\n            int num,\n            final boolean hasRights,\n            final boolean xml) \n    {\n            final Iterator<String> i = switchboard.blogDB.getBlogIterator(false);\n            String pageid;\n            int count = 0;                        //counts how many entries are shown to the user\n            if(xml) num = 0;\n            final int nextstart = start+num;      //indicates the starting offset for next results\n            int prevstart = start-num;            //indicates the starting offset for previous results\n            boolean prev = false;                 //indicates if there were previous comments to the ones that are dispalyed\n            if (start > 0) prev = true;\n            while(i.hasNext() && (num == 0 || num > count)) {\n                pageid = i.next();\n                if(0 < start--) continue;\n                putBlogEntry(\n                        prop,\n                        switchboard.blogDB.readBlogEntry(pageid),\n                        address,\n                        count++,\n                        hasRights,\n                        xml);\n            }\n            prop.put(\"mode_entries\", count);\n\n            if(i.hasNext()) {\n                prop.put(\"mode_moreentries\", \"1\"); //more entries are availible\n                prop.put(\"mode_moreentries_start\", nextstart);\n                prop.put(\"mode_moreentries_num\", num);\n            } else {\n                prop.put(\"moreentries\", \"0\");\n            }\n            \n            if(prev) {\n                prop.put(\"mode_preventries\", \"1\");\n                if (prevstart < 0) prevstart = 0;\n                prop.put(\"mode_preventries_start\", prevstart);\n                prop.put(\"mode_preventries_num\", num);\n            } else prop.put(\"mode_preventries\", \"0\");\n            \n            \n        return prop;\n    }","id":47859,"modified_method":"private static serverObjects putBlogDefault(\n            final serverObjects prop,\n            final Switchboard switchboard,\n            final String address,\n            int start,\n            int num,\n            final boolean hasRights,\n            final boolean xml) \n    {\n        final Iterator<String> i = switchboard.blogDB.getBlogIterator(false);\n\n        int count = 0;                        //counts how many entries are shown to the user\n        if (xml) {\n            num = 0;\n        }\n        final int nextstart = start+num;      //indicates the starting offset for next results\n        int prevstart = start-num;            //indicates the starting offset for previous results\n\n        while (i.hasNext() && (num == 0 || num > count)) {\n            if(0 < start--) continue;\n            putBlogEntry(\n                    prop,\n                    switchboard.blogDB.readBlogEntry(i.next()),\n                    address,\n                    count++,\n                    hasRights,\n                    xml);\n        }\n        prop.put(\"mode_entries\", count);\n\n        if (i.hasNext()) {\n            prop.put(\"mode_moreentries\", \"1\"); //more entries are availible\n            prop.put(\"mode_moreentries_start\", nextstart);\n            prop.put(\"mode_moreentries_num\", num);\n        } else {\n            prop.put(\"moreentries\", \"0\");\n        }\n\n        if (start > 0) {\n            prop.put(\"mode_preventries\", \"1\");\n            if (prevstart < 0) {\n                prevstart = 0;\n            }\n            prop.put(\"mode_preventries_start\", prevstart);\n            prop.put(\"mode_preventries_num\", num);\n        } else prop.put(\"mode_preventries\", \"0\");\n                \n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        BlogBoard.BlogEntry page = null;\n\n        boolean hasRights = sb.verifyAuthentication(header, true);\n        \n        //final int display = (hasRights || post == null) ? 1 : post.getInt(\"display\", 0);\n        //prop.put(\"display\", display);   \n        prop.put(\"display\", 1); // Fixed to 1\n\n        \n        final boolean xml = (header.get(HeaderFramework.CONNECTION_PROP_PATH)).endsWith(\".xml\");\n        final String address = sb.peers.mySeed().getPublicAddress();\n\n        if(hasRights) {\n            prop.put(\"mode_admin\", \"1\");\n        } else {\n            prop.put(\"mode_admin\", \"0\");\n        }\n\n        if (post == null) {\n            prop.putHTML(\"peername\", sb.peers.mySeed().getName());\n            prop.put(\"address\", address);\n            return putBlogDefault(prop, sb, address, 0, 10, hasRights, xml);\n        }\n\n        final int start = post.getInt(\"start\",0); //indicates from where entries should be shown\n        final int num   = post.getInt(\"num\",10);  //indicates how many entries should be shown\n\n        if(!hasRights){\n            final UserDB.Entry userentry = sb.userDB.proxyAuth(header.get(RequestHeader.AUTHORIZATION, \"xxxxxx\"));\n            if(userentry != null && userentry.hasRight(UserDB.Entry.BLOG_RIGHT)){\n                hasRights=true;\n            } else if(post.containsKey(\"login\")) {\n                //opens login window if login link is clicked - contrib [MN]\n                prop.put(\"AUTHENTICATE\",\"admin log-in\");\n            }\n        }\n\n        String pagename = post.get(\"page\", DEFAULT_PAGE);\n        final String ip = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"127.0.0.1\");\n\n        String StrAuthor = post.get(\"author\", \"\");\n\n        if (StrAuthor.equals(\"anonymous\")) {\n            StrAuthor = sb.blogDB.guessAuthor(ip);\n\n            if (StrAuthor == null || StrAuthor.length() == 0) {\n                if (sb.peers.mySeed() == null) {\n                    StrAuthor = \"anonymous\";\n                } else {\n                    StrAuthor = sb.peers.mySeed().get(\"Name\", \"anonymous\");\n                }\n            }\n        }\n\n        byte[] author;\n        try {\n            author = StrAuthor.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            author = StrAuthor.getBytes();\n        }\n\n        if(hasRights && post.containsKey(\"delete\") && post.get(\"delete\").equals(\"sure\")) {\n            page = sb.blogDB.readBlogEntry(pagename);\n            for (final String comment : page.getComments()) {\n                sb.blogCommentDB.delete(comment);\n            }\n            sb.blogDB.deleteBlogEntry(pagename);\n            pagename = DEFAULT_PAGE;\n        }\n\n        if (post.containsKey(\"discard\")) {\n            pagename = DEFAULT_PAGE;\n        }\n\n        if (post.containsKey(\"submit\") && (hasRights)) {\n            // store a new/edited blog-entry\n            byte[] content;\n            try {\n                content = post.get(\"content\", \"\").getBytes(\"UTF-8\");\n            } catch (final UnsupportedEncodingException e) {\n                content = post.get(\"content\", \"\").getBytes();\n            }\n\n            Date date = null;\n            List<String> comments = null;\n\n            //set name for new entry or date for old entry\n            if(pagename.equals(DEFAULT_PAGE)) {\n                pagename = String.valueOf(System.currentTimeMillis());\n            } else {\n                page = sb.blogDB.readBlogEntry(pagename);\n                comments = page.getComments();\n                date = page.getDate();\n            }\n            final String commentMode = post.get(\"commentMode\", \"2\");\n            final String StrSubject = post.get(\"subject\", \"\");\n            byte[] subject;\n            try {\n                subject = StrSubject.getBytes(\"UTF-8\");\n            } catch (final UnsupportedEncodingException e) {\n                subject = StrSubject.getBytes();\n            }\n\n            sb.blogDB.writeBlogEntry(sb.blogDB.newEntry(pagename, subject, author, ip, date, content, comments, commentMode));\n\n            // create a news message\n            final Map<String, String> map = new HashMap<String, String>();\n            map.put(\"page\", pagename);\n            map.put(\"subject\", StrSubject.replace(',', ' '));\n            map.put(\"author\", StrAuthor.replace(',', ' '));\n            sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_BLOG_ADD, map);\n        }\n\n        page = sb.blogDB.readBlogEntry(pagename); //maybe \"if(page == null)\"\n\n        if (post.containsKey(\"edit\")) {\n            //edit an entry\n            if(hasRights) {\n                try {\n                    prop.put(\"mode\", \"1\"); //edit\n                    prop.put(\"mode_commentMode\", page.getCommentMode());\n                    prop.putHTML(\"mode_author\", new String(page.getAuthor(),\"UTF-8\"));\n                    prop.put(\"mode_pageid\", page.getKey());\n                    prop.putHTML(\"mode_subject\", new String(page.getSubject(), \"UTF-8\"));\n                    prop.put(\"mode_page-code\", new String(page.getPage(), \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {}\n            }\n            else {\n                prop.put(\"mode\", \"3\"); //access denied (no rights)\n            }\n        } else if(post.containsKey(\"preview\")) {\n            //preview the page\n            if(hasRights) {\n                prop.put(\"mode\", \"2\");//preview\n                prop.put(\"mode_commentMode\", post.getInt(\"commentMode\", 2));\n                prop.putHTML(\"mode_pageid\", pagename);\n                try {\n                    prop.putHTML(\"mode_author\", new String(author, \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_author\", new String(author));\n                }\n                prop.putHTML(\"mode_subject\", post.get(\"subject\",\"\"));\n                prop.put(\"mode_date\", dateString(new Date()));\n                prop.putWiki(\"mode_page\", post.get(\"content\", \"\"));\n                prop.putHTML(\"mode_page-code\", post.get(\"content\", \"\"));\n            }\n            else {\n                prop.put(\"mode\", \"3\"); //access denied (no rights)\n            }\n        }\n        else if(post.get(\"delete\", \"\").equals(\"try\")) {\n            if(hasRights) {\n                prop.put(\"mode\", \"4\");\n                prop.putHTML(\"mode_pageid\", pagename);\n                try {\n                    prop.putHTML(\"mode_author\",new String(page.getAuthor(), \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_author\",new String(page.getAuthor()));\n                }\n                try {\n                    prop.putHTML(\"mode_subject\",new String(page.getSubject(),\"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_subject\",new String(page.getSubject()));\n                }\n            }\n            else prop.put(\"mode\", \"3\"); //access denied (no rights)\n        }\n        else if (post.containsKey(\"import\")) {\n            prop.put(\"mode\", \"5\");\n            prop.put(\"mode_state\", \"0\");\n        }\n        else if (post.containsKey(\"xmlfile\")) {\n            prop.put(\"mode\", \"5\");\n            if(sb.blogDB.importXML(post.get(\"xmlfile$file\"))) {\n                prop.put(\"mode_state\", \"1\");\n            }\n            else {\n                prop.put(\"mode_state\", \"2\");\n            }\n        }\n        else {\n            // show blog-entry/entries\n            prop.put(\"mode\", \"0\"); //viewing\n            if(pagename.equals(DEFAULT_PAGE)) {\n                // XXX: where are \"peername\" and \"address\" used in the template?\n                // XXX: \"clientname\" is already set to the peername, no need for a new setting\n                prop.putHTML(\"peername\", sb.peers.mySeed().getName());\n                prop.put(\"address\", address);\n                //index all entries\n                putBlogDefault(prop, sb, address, start, num, hasRights, xml);\n            }\n            else {\n                //only show 1 entry\n                prop.put(\"mode_entries\", \"1\");\n                putBlogEntry(prop, page, address, 0, hasRights, xml);\n            }\n        }\n\n        // return rewrite properties\n        return prop;\n    }","id":47860,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        BlogBoard.BlogEntry page = null;\n\n        boolean hasRights = sb.verifyAuthentication(header, true);\n        \n        //final int display = (hasRights || post == null) ? 1 : post.getInt(\"display\", 0);\n        //prop.put(\"display\", display);   \n        prop.put(\"display\", 1); // Fixed to 1\n\n        \n        final boolean xml = (header.get(HeaderFramework.CONNECTION_PROP_PATH)).endsWith(\".xml\");\n        final String address = sb.peers.mySeed().getPublicAddress();\n\n        if(hasRights) {\n            prop.put(\"mode_admin\", \"1\");\n        } else {\n            prop.put(\"mode_admin\", \"0\");\n        }\n\n        if (post == null) {\n            prop.putHTML(\"peername\", sb.peers.mySeed().getName());\n            prop.put(\"address\", address);\n            return putBlogDefault(prop, sb, address, 0, 10, hasRights, xml);\n        }\n\n        final int start = post.getInt(\"start\",0); //indicates from where entries should be shown\n        final int num   = post.getInt(\"num\",10);  //indicates how many entries should be shown\n\n        if (!hasRights) {\n            final UserDB.Entry userentry = sb.userDB.proxyAuth(header.get(RequestHeader.AUTHORIZATION, \"xxxxxx\"));\n            if (userentry != null && userentry.hasRight(UserDB.Entry.BLOG_RIGHT)) {\n                hasRights=true;\n            } else if (post.containsKey(\"login\")) {\n                //opens login window if login link is clicked\n                prop.put(\"AUTHENTICATE\",\"admin log-in\");\n            }\n        }\n\n        String pagename = post.get(\"page\", DEFAULT_PAGE);\n        final String ip = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"127.0.0.1\");\n\n        String StrAuthor = post.get(\"author\", \"\");\n\n        if (\"anonymous\".equals(StrAuthor)) {\n            StrAuthor = sb.blogDB.guessAuthor(ip);\n\n            if (StrAuthor == null || StrAuthor.length() == 0) {\n                if (sb.peers.mySeed() == null) {\n                    StrAuthor = \"anonymous\";\n                } else {\n                    StrAuthor = sb.peers.mySeed().get(\"Name\", \"anonymous\");\n                }\n            }\n        }\n\n        byte[] author;\n        try {\n            author = StrAuthor.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            author = StrAuthor.getBytes();\n        }\n\n        if (hasRights && post.containsKey(\"delete\") && \"sure\".equals(post.get(\"delete\"))) {\n            page = sb.blogDB.readBlogEntry(pagename);\n            for (final String comment : page.getComments()) {\n                sb.blogCommentDB.delete(comment);\n            }\n            sb.blogDB.deleteBlogEntry(pagename);\n            pagename = DEFAULT_PAGE;\n        }\n\n        if (post.containsKey(\"discard\")) {\n            pagename = DEFAULT_PAGE;\n        }\n\n        if (post.containsKey(\"submit\") && hasRights) {\n            // store a new/edited blog-entry\n            byte[] content;\n            try {\n                content = post.get(\"content\", \"\").getBytes(\"UTF-8\");\n            } catch (final UnsupportedEncodingException e) {\n                content = post.get(\"content\", \"\").getBytes();\n            }\n\n            final Date date;\n            List<String> comments = null;\n\n            //set name for new entry or date for old entry\n            if (DEFAULT_PAGE.equals(pagename)) {\n                pagename = String.valueOf(System.currentTimeMillis());\n                date = null;\n            } else {\n                page = sb.blogDB.readBlogEntry(pagename);\n                comments = page.getComments();\n                date = page.getDate();\n            }\n            final String commentMode = post.get(\"commentMode\", \"2\");\n            final String StrSubject = post.get(\"subject\", \"\");\n            byte[] subject;\n            try {\n                subject = StrSubject.getBytes(\"UTF-8\");\n            } catch (final UnsupportedEncodingException e) {\n                subject = StrSubject.getBytes();\n            }\n\n            sb.blogDB.writeBlogEntry(sb.blogDB.newEntry(pagename, subject, author, ip, date, content, comments, commentMode));\n\n            // create a news message\n            final Map<String, String> map = new HashMap<String, String>();\n            map.put(\"page\", pagename);\n            map.put(\"subject\", StrSubject.replace(',', ' '));\n            map.put(\"author\", StrAuthor.replace(',', ' '));\n            sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_BLOG_ADD, map);\n        }\n\n        page = sb.blogDB.readBlogEntry(pagename); //maybe \"if(page == null)\"\n\n        if (post.containsKey(\"edit\")) {\n            //edit an entry\n            if(hasRights) {\n                try {\n                    prop.put(\"mode\", \"1\"); //edit\n                    prop.put(\"mode_commentMode\", page.getCommentMode());\n                    prop.putHTML(\"mode_author\", new String(page.getAuthor(),\"UTF-8\"));\n                    prop.put(\"mode_pageid\", page.getKey());\n                    prop.putHTML(\"mode_subject\", new String(page.getSubject(), \"UTF-8\"));\n                    prop.put(\"mode_page-code\", new String(page.getPage(), \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {}\n            }\n            else {\n                prop.put(\"mode\", \"3\"); //access denied (no rights)\n            }\n        } else if(post.containsKey(\"preview\")) {\n            //preview the page\n            if(hasRights) {\n                prop.put(\"mode\", \"2\");//preview\n                prop.put(\"mode_commentMode\", post.getInt(\"commentMode\", 2));\n                prop.putHTML(\"mode_pageid\", pagename);\n                try {\n                    prop.putHTML(\"mode_author\", new String(author, \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_author\", new String(author));\n                }\n                prop.putHTML(\"mode_subject\", post.get(\"subject\",\"\"));\n                prop.put(\"mode_date\", dateString(new Date()));\n                prop.putWiki(\"mode_page\", post.get(\"content\", \"\"));\n                prop.putHTML(\"mode_page-code\", post.get(\"content\", \"\"));\n            }\n            else {\n                prop.put(\"mode\", \"3\"); //access denied (no rights)\n            }\n        }\n        else if(\"try\".equals(post.get(\"delete\", \"\"))) {\n            if(hasRights) {\n                prop.put(\"mode\", \"4\");\n                prop.putHTML(\"mode_pageid\", pagename);\n                try {\n                    prop.putHTML(\"mode_author\",new String(page.getAuthor(), \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_author\",new String(page.getAuthor()));\n                }\n                try {\n                    prop.putHTML(\"mode_subject\",new String(page.getSubject(),\"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_subject\",new String(page.getSubject()));\n                }\n            }\n            else prop.put(\"mode\", \"3\"); //access denied (no rights)\n        }\n        else if (post.containsKey(\"import\")) {\n            prop.put(\"mode\", \"5\");\n            prop.put(\"mode_state\", \"0\");\n        }\n        else if (post.containsKey(\"xmlfile\")) {\n            prop.put(\"mode\", \"5\");\n            if(sb.blogDB.importXML(post.get(\"xmlfile$file\"))) {\n                prop.put(\"mode_state\", \"1\");\n            }\n            else {\n                prop.put(\"mode_state\", \"2\");\n            }\n        }\n        else {\n            // show blog-entry/entries\n            prop.put(\"mode\", \"0\"); //viewing\n            if(DEFAULT_PAGE.equals(pagename)) {\n                // XXX: where are \"peername\" and \"address\" used in the template?\n                // XXX: \"clientname\" is already set to the peername, no need for a new setting\n                prop.putHTML(\"peername\", sb.peers.mySeed().getName());\n                prop.put(\"address\", address);\n                //index all entries\n                putBlogDefault(prop, sb, address, start, num, hasRights, xml);\n            }\n            else {\n                //only show 1 entry\n                prop.put(\"mode_entries\", \"1\");\n                putBlogEntry(prop, page, address, 0, hasRights, xml);\n            }\n        }\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        BlogBoard.BlogEntry page = null;\n        boolean hasRights = sb.verifyAuthentication(header, true);\n\n        if (hasRights) prop.put(\"mode_admin\", \"1\");\n        else prop.put(\"mode_admin\", \"0\");\n\n        if (post == null) {\n            post = new serverObjects();\n            post.put(\"page\", \"blog_default\");\n        }\n\n        if(!hasRights){\n            final UserDB.Entry userentry = sb.userDB.proxyAuth(header.get(RequestHeader.AUTHORIZATION, \"xxxxxx\"));\n            if(userentry != null && userentry.hasRight(UserDB.Entry.BLOG_RIGHT)){\n                hasRights=true;\n            }\n            //opens login window if login link is clicked - contrib [MN]\n            else if(post.containsKey(\"login\")){\n                prop.put(\"AUTHENTICATE\",\"admin log-in\");\n            }\n        }\n\n        final String pagename = post.get(\"page\", \"blog_default\");\n        final String ip = post.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"127.0.0.1\");\n\n        String StrAuthor = post.get(\"author\", \"anonymous\");\n\n        if (StrAuthor.equals(\"anonymous\")) {\n            StrAuthor = sb.blogDB.guessAuthor(ip);\n\n            if (StrAuthor == null || StrAuthor.length() == 0) {\n                if (sb.peers.mySeed() == null) {\n                    StrAuthor = \"anonymous\";\n                }\n                else {\n                    StrAuthor = sb.peers.mySeed().get(\"Name\", \"anonymous\");\n                }\n            }\n        }\n\n        byte[] author;\n        try {\n            author = StrAuthor.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            author = StrAuthor.getBytes();\n        }\n\n        page = sb.blogDB.readBlogEntry(pagename); //maybe \"if(page == null)\"\n        final boolean pageExists = sb.blogDB.contains(pagename); // [MN]\n        \n        // comments not allowed\n        if (page.getCommentMode() == 0) {\n            prop.put(\"mode_allow\", 0);\n        } else {\n            prop.put(\"mode_allow\", 1);\n        } \n\n        if (post.containsKey(\"submit\") && page.getCommentMode() != 0 && pageExists) {\n            // store a new/edited blog-entry\n            byte[] content;\n            if(!post.get(\"content\", \"\").equals(\"\"))\n            {\n                if(post.get(\"subject\", \"\").equals(\"\")) post.putHTML(\"subject\", \"no title\");\n                try {\n                    content = post.get(\"content\", \"\").getBytes(\"UTF-8\");\n                } catch (final UnsupportedEncodingException e) {\n                    content = post.get(\"content\", \"\").getBytes();\n                }\n\n                final Date date = null;\n\n                //set name for new entry or date for old entry\n                final String StrSubject = post.get(\"subject\", \"\");\n                byte[] subject;\n                try {\n                    subject = StrSubject.getBytes(\"UTF-8\");\n                } catch (final UnsupportedEncodingException e) {\n                    subject = StrSubject.getBytes();\n                }\n                final String commentID = String.valueOf(System.currentTimeMillis());\n                final BlogEntry blogEntry = sb.blogDB.readBlogEntry(pagename);\n                blogEntry.addComment(commentID);\n                sb.blogDB.writeBlogEntry(blogEntry);\n                sb.blogCommentDB.write(sb.blogCommentDB.newEntry(commentID, subject, author, ip, date, content));\n                prop.putHTML(\"LOCATION\",\"BlogComments.html?page=\" + pagename);\n\n                MessageBoard.entry msgEntry = null;\n                try {\n                    sb.messageDB.write(msgEntry = sb.messageDB.newEntry(\n                            \"blogComment\",\n                            StrAuthor,\n                            sb.peers.mySeed().hash,\n                            sb.peers.mySeed().getName(), sb.peers.mySeed().hash,\n                            \"new blog comment: \" + new String(blogEntry.getSubject(),\"UTF-8\"), content));\n                } catch (final UnsupportedEncodingException e1) {\n                    sb.messageDB.write(msgEntry = sb.messageDB.newEntry(\n                            \"blogComment\",\n                            StrAuthor,\n                            sb.peers.mySeed().hash,\n                            sb.peers.mySeed().getName(), sb.peers.mySeed().hash,\n                            \"new blog comment: \" + new String(blogEntry.getSubject()), content));\n                }\n\n                messageForwardingViaEmail(sb, msgEntry);\n\n                // finally write notification\n                final File notifierSource = new File(sb.getAppPath(), sb.getConfig(\"htRootPath\",\"htroot\") + \"/env/grafics/message.gif\");\n                final File notifierDest   = new File(sb.getDataPath(\"htDocsPath\", \"DATA/HTDOCS\"), \"notifier.gif\");\n                try {\n                    FileUtils.copy(notifierSource, notifierDest);\n                } catch (final IOException e) {\n                    Log.logSevere(\"MESSAGE\", \"NEW MESSAGE ARRIVED! (error: \" + e.getMessage() + \")\");\n\n                }\n            }\n        }\n\n        if(hasRights && post.containsKey(\"delete\") && post.containsKey(\"page\") && post.containsKey(\"comment\")) {\n            if(page.removeComment(post.get(\"comment\"))) {\n                sb.blogCommentDB.delete(post.get(\"comment\"));\n            }\n        }\n\n        if(hasRights && post.containsKey(\"allow\") && post.containsKey(\"page\") && post.containsKey(\"comment\")) {\n            final BlogBoardComments.CommentEntry entry = sb.blogCommentDB.read(post.get(\"comment\"));\n            entry.allow();\n            sb.blogCommentDB.write(entry);\n        }\n\n        if(post.containsKey(\"preview\") && page.getCommentMode() != 0) {\n            //preview the page\n            prop.put(\"mode\", \"1\");//preview\n            prop.putHTML(\"mode_pageid\", pagename);\n            prop.putHTML(\"mode_allow_pageid\", pagename);\n            try {\n                prop.putHTML(\"mode_author\", new String(author, \"UTF-8\"));\n                prop.putHTML(\"mode_allow_author\", new String(author, \"UTF-8\"));\n            } catch (final UnsupportedEncodingException e) {\n                prop.putHTML(\"mode_author\", new String(author));\n                prop.putHTML(\"mode_allow_author\", new String(author));\n            }\n            prop.putHTML(\"mode_subject\", post.get(\"subject\",\"\"));\n            prop.put(\"mode_date\", dateString(new Date()));\n            prop.putWiki(\"mode_page\", post.get(\"content\", \"\"));\n            prop.put(\"mode_page-code\", post.get(\"content\", \"\"));\n        } else {\n            // show blog-entry/entries\n            prop.put(\"mode\", \"0\"); //viewing\n            if(pagename.equals(\"blog_default\")) {\n                prop.put(\"LOCATION\",\"Blog.html\");\n            } else {\n                //show 1 blog entry\n                prop.put(\"mode_pageid\", page.getKey());\n                prop.putHTML(\"mode_allow_pageid\", pagename);\n                try {\n                    prop.putHTML(\"mode_subject\", new String(page.getSubject(),\"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_subject\", new String(page.getSubject()));\n                }\n                try {\n                    prop.putHTML(\"mode_author\", new String(page.getAuthor(),\"UTF-8\"));\n                    prop.putHTML(\"mode_allow_author\", new String(author, \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_author\", new String(page.getAuthor()));\n                    prop.putHTML(\"mode_allow_author\", new String(author));\n                }\n                prop.put(\"mode_comments\", page.getCommentsSize());\n                prop.put(\"mode_date\", dateString(page.getDate()));\n                prop.putWiki(\"mode_page\", page.getPage());\n                if(hasRights) {\n                    prop.put(\"mode_admin\", \"1\");\n                    prop.put(\"mode_admin_pageid\", page.getKey());\n                }\n                //show all commments\n                try {\n                    final Iterator<String> i = page.getComments().iterator();\n                    final int commentMode = page.getCommentMode();\n                    String pageid;\n                    BlogBoardComments.CommentEntry entry;\n                    boolean xml = false;\n                    if(post.containsKey(\"xml\")) {\n                        xml = true;\n                    }\n                    int count = 0; //counts how many entries are shown to the user\n                    int start = post.getInt(\"start\",0); //indicates from where entries should be shown\n                    int num   = post.getInt(\"num\",10);  //indicates how many entries should be shown\n                    boolean prev = false;               //indicates if there were previous comments to the ones that are dispalyed\n                    if(xml) num = 0;\n                    if (start < 0) start = 0;       \n                    if (start > 1) prev = true;\n                    final int nextstart = start+num;      //indicates the starting offset for next results\n                    int prevstart = start-num;      //indicates the starting offset for previous results\n                    while(i.hasNext() && count < num) {\n\n                        pageid = i.next();\n                        \n                        if(start > 0) {\n                            start--;\n                            continue;\n                        }\n                            \n                        entry = sb.blogCommentDB.read(pageid);\n\n                        if (commentMode == 2 && !hasRights && !entry.isAllowed())\n                            continue;\n\n                        prop.put(\"mode\", \"0\");\n                        prop.put(\"mode_entries_\"+count+\"_pageid\", entry.getKey());\n                        if(!xml) {\n                            prop.putHTML(\"mode_entries_\"+count+\"_subject\", new String(entry.getSubject(),\"UTF-8\"));\n                            prop.putHTML(\"mode_entries_\"+count+\"_author\", new String(entry.getAuthor(),\"UTF-8\"));\n                            prop.putWiki(\"mode_entries_\"+count+\"_page\", entry.getPage());\n                        }\n                        else {\n                            prop.putHTML(\"mode_entries_\"+count+\"_subject\", new String(entry.getSubject(),\"UTF-8\"));\n                            prop.putHTML(\"mode_entries_\"+count+\"_author\", new String(entry.getAuthor(),\"UTF-8\"));\n                            prop.put(\"mode_entries_\"+count+\"_page\", entry.getPage());\n                            prop.put(\"mode_entries_\"+count+\"_timestamp\", entry.getTimestamp());\n                        }\n                        prop.put(\"mode_entries_\"+count+\"_date\", dateString(entry.getDate()));\n                        prop.put(\"mode_entries_\"+count+\"_ip\", entry.getIp());\n                        if(hasRights) {\n                            prop.put(\"mode_entries_\"+count+\"_admin\", \"1\");\n                            prop.put(\"mode_entries_\"+count+\"_admin_pageid\", page.getKey());\n                            prop.put(\"mode_entries_\"+count+\"_admin_commentid\", pageid);\n                            if(page.getCommentMode() == 2 && !entry.isAllowed()) {\n                                prop.put(\"mode_entries_\"+count+\"_admin_moderate\", \"1\");\n                                prop.put(\"mode_entries_\"+count+\"_admin_moderate_pageid\", page.getKey());\n                                prop.put(\"mode_entries_\"+count+\"_admin_moderate_commentid\", pageid);\n\n                            }\n                        }\n                        else prop.put(\"mode_entries_\"+count+\"_admin\", 0);\n                        ++count;\n                    }\n                    prop.put(\"mode_entries\", count);\n                    if(i.hasNext()) {\n                        prop.put(\"mode_moreentries\", \"1\"); //more entries are availible\n                        prop.put(\"mode_moreentries_start\", nextstart);\n                        prop.put(\"mode_moreentries_num\", num);\n                        prop.put(\"mode_moreentries_pageid\", page.getKey());\n                    }\n                    else prop.put(\"mode_moreentries\", \"0\");\n                    if(prev) {\n                        prop.put(\"mode_preventries\", \"1\");\n                        if (prevstart < 0) prevstart = 0;\n                        prop.put(\"mode_preventries_start\", prevstart);\n                        prop.put(\"mode_preventries_num\", num);\n                        prop.put(\"mode_preventries_pageid\", page.getKey());\n                    } else prop.put(\"mode_preventries\", \"0\");\n                } catch (final IOException e) {\n\n                }\n            }\n        }\n\n        // return rewrite properties\n        return prop;\n    }","id":47861,"modified_method":"public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        BlogBoard.BlogEntry page = null;\n        boolean hasRights = sb.verifyAuthentication(header, true);\n\n        if (hasRights) prop.put(\"mode_admin\", \"1\");\n        else prop.put(\"mode_admin\", \"0\");\n\n        if (post == null) {\n            post = new serverObjects();\n            post.put(\"page\", \"blog_default\");\n        }\n\n        if(!hasRights){\n            final UserDB.Entry userentry = sb.userDB.proxyAuth(header.get(RequestHeader.AUTHORIZATION, \"xxxxxx\"));\n            if(userentry != null && userentry.hasRight(UserDB.Entry.BLOG_RIGHT)){\n                hasRights=true;\n            }\n            //opens login window if login link is clicked - contrib [MN]\n            else if(post.containsKey(\"login\")){\n                prop.put(\"AUTHENTICATE\",\"admin log-in\");\n            }\n        }\n\n        final String pagename = post.get(\"page\", \"blog_default\");\n        final String ip = post.get(HeaderFramework.CONNECTION_PROP_CLIENTIP, \"127.0.0.1\");\n\n        String StrAuthor = post.get(\"author\", \"anonymous\");\n\n        if (\"anonymous\".equals(StrAuthor)) {\n            StrAuthor = sb.blogDB.guessAuthor(ip);\n\n            if (StrAuthor == null || StrAuthor.length() == 0) {\n                if (sb.peers.mySeed() == null) {\n                    StrAuthor = \"anonymous\";\n                }\n                else {\n                    StrAuthor = sb.peers.mySeed().get(\"Name\", \"anonymous\");\n                }\n            }\n        }\n\n        byte[] author;\n        try {\n            author = StrAuthor.getBytes(\"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            author = StrAuthor.getBytes();\n        }\n\n        page = sb.blogDB.readBlogEntry(pagename); //maybe \"if(page == null)\"\n        final boolean pageExists = sb.blogDB.contains(pagename); // [MN]\n        \n        // comments not allowed\n        if (page.getCommentMode() == 0) {\n            prop.put(\"mode_allow\", 0);\n        } else {\n            prop.put(\"mode_allow\", 1);\n        } \n\n        if (post.containsKey(\"submit\") && page.getCommentMode() != 0 && pageExists) {\n            // store a new/edited blog-entry\n            byte[] content;\n            if (!\"\".equals(post.get(\"content\", \"\"))) {\n                if (\"\".equals(post.get(\"subject\", \"\"))) {\n                    post.putHTML(\"subject\", \"no title\");\n                }\n                try {\n                    content = post.get(\"content\", \"\").getBytes(\"UTF-8\");\n                } catch (final UnsupportedEncodingException e) {\n                    content = post.get(\"content\", \"\").getBytes();\n                }\n\n                final Date date = null;\n\n                //set name for new entry or date for old entry\n                final String StrSubject = post.get(\"subject\", \"\");\n                byte[] subject;\n                try {\n                    subject = StrSubject.getBytes(\"UTF-8\");\n                } catch (final UnsupportedEncodingException e) {\n                    subject = StrSubject.getBytes();\n                }\n                final String commentID = String.valueOf(System.currentTimeMillis());\n                final BlogEntry blogEntry = sb.blogDB.readBlogEntry(pagename);\n                blogEntry.addComment(commentID);\n                sb.blogDB.writeBlogEntry(blogEntry);\n                sb.blogCommentDB.write(sb.blogCommentDB.newEntry(commentID, subject, author, ip, date, content));\n                prop.putHTML(\"LOCATION\",\"BlogComments.html?page=\" + pagename);\n\n                MessageBoard.entry msgEntry = null;\n                try {\n                    sb.messageDB.write(msgEntry = sb.messageDB.newEntry(\n                            \"blogComment\",\n                            StrAuthor,\n                            sb.peers.mySeed().hash,\n                            sb.peers.mySeed().getName(), sb.peers.mySeed().hash,\n                            \"new blog comment: \" + new String(blogEntry.getSubject(),\"UTF-8\"), content));\n                } catch (final UnsupportedEncodingException e1) {\n                    sb.messageDB.write(msgEntry = sb.messageDB.newEntry(\n                            \"blogComment\",\n                            StrAuthor,\n                            sb.peers.mySeed().hash,\n                            sb.peers.mySeed().getName(), sb.peers.mySeed().hash,\n                            \"new blog comment: \" + new String(blogEntry.getSubject()), content));\n                }\n\n                messageForwardingViaEmail(sb, msgEntry);\n\n                // finally write notification\n                final File notifierSource = new File(sb.getAppPath(), sb.getConfig(\"htRootPath\",\"htroot\") + \"/env/grafics/message.gif\");\n                final File notifierDest   = new File(sb.getDataPath(\"htDocsPath\", \"DATA/HTDOCS\"), \"notifier.gif\");\n                try {\n                    FileUtils.copy(notifierSource, notifierDest);\n                } catch (final IOException e) {\n                    Log.logSevere(\"MESSAGE\", \"NEW MESSAGE ARRIVED! (error: \" + e.getMessage() + \")\");\n\n                }\n            }\n        }\n\n        if (hasRights && post.containsKey(\"delete\") && post.containsKey(\"page\") &&\n                post.containsKey(\"comment\") && page.removeComment(post.get(\"comment\"))) {\n            sb.blogCommentDB.delete(post.get(\"comment\"));\n        }\n\n        if (hasRights && post.containsKey(\"allow\") && post.containsKey(\"page\") && post.containsKey(\"comment\")) {\n            final BlogBoardComments.CommentEntry entry = sb.blogCommentDB.read(post.get(\"comment\"));\n            entry.allow();\n            sb.blogCommentDB.write(entry);\n        }\n\n        if (post.containsKey(\"preview\") && page.getCommentMode() != 0) {\n            //preview the page\n            prop.put(\"mode\", \"1\");//preview\n            prop.putHTML(\"mode_pageid\", pagename);\n            prop.putHTML(\"mode_allow_pageid\", pagename);\n            try {\n                prop.putHTML(\"mode_author\", new String(author, \"UTF-8\"));\n                prop.putHTML(\"mode_allow_author\", new String(author, \"UTF-8\"));\n            } catch (final UnsupportedEncodingException e) {\n                prop.putHTML(\"mode_author\", new String(author));\n                prop.putHTML(\"mode_allow_author\", new String(author));\n            }\n            prop.putHTML(\"mode_subject\", post.get(\"subject\",\"\"));\n            prop.put(\"mode_date\", dateString(new Date()));\n            prop.putWiki(\"mode_page\", post.get(\"content\", \"\"));\n            prop.put(\"mode_page-code\", post.get(\"content\", \"\"));\n        } else {\n            // show blog-entry/entries\n            prop.put(\"mode\", \"0\"); //viewing\n            if(\"blog_default\".equals(pagename)) {\n                prop.put(\"LOCATION\",\"Blog.html\");\n            } else {\n                //show 1 blog entry\n                prop.put(\"mode_pageid\", page.getKey());\n                prop.putHTML(\"mode_allow_pageid\", pagename);\n                try {\n                    prop.putHTML(\"mode_subject\", new String(page.getSubject(),\"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_subject\", new String(page.getSubject()));\n                }\n                try {\n                    prop.putHTML(\"mode_author\", new String(page.getAuthor(),\"UTF-8\"));\n                    prop.putHTML(\"mode_allow_author\", new String(author, \"UTF-8\"));\n                } catch (final UnsupportedEncodingException e) {\n                    prop.putHTML(\"mode_author\", new String(page.getAuthor()));\n                    prop.putHTML(\"mode_allow_author\", new String(author));\n                }\n                prop.put(\"mode_comments\", page.getCommentsSize());\n                prop.put(\"mode_date\", dateString(page.getDate()));\n                prop.putWiki(\"mode_page\", page.getPage());\n                if (hasRights) {\n                    prop.put(\"mode_admin\", \"1\");\n                    prop.put(\"mode_admin_pageid\", page.getKey());\n                }\n                //show all commments\n                try {\n                    final Iterator<String> i = page.getComments().iterator();\n                    final int commentMode = page.getCommentMode();\n                    String pageid;\n                    BlogBoardComments.CommentEntry entry;\n                    boolean xml = false;\n                    if (post.containsKey(\"xml\")) {\n                        xml = true;\n                    }\n                    int count = 0; //counts how many entries are shown to the user\n                    int start = post.getInt(\"start\",0); //indicates from where entries should be shown\n                    int num   = post.getInt(\"num\",10);  //indicates how many entries should be shown\n\n                    if (xml) {\n                        num = 0;\n                    }\n                    if (start < 0) {\n                        start = 0;\n                    }\n\n                    final int nextstart = start + num;  //indicates the starting offset for next results\n                    int prevstart = start - num;        //indicates the starting offset for previous results\n                    while (i.hasNext() && count < num) {\n\n                        pageid = i.next();\n                        \n                        if(start > 0) {\n                            start--;\n                            continue;\n                        }\n                            \n                        entry = sb.blogCommentDB.read(pageid);\n\n                        if (commentMode == 2 && !hasRights && !entry.isAllowed()) {\n                            continue;\n                        }\n\n                        prop.put(\"mode\", \"0\");\n                        prop.put(\"mode_entries_\"+count+\"_pageid\", entry.getKey());\n                        if (!xml) {\n                            prop.putHTML(\"mode_entries_\"+count+\"_subject\", new String(entry.getSubject(),\"UTF-8\"));\n                            prop.putHTML(\"mode_entries_\"+count+\"_author\", new String(entry.getAuthor(),\"UTF-8\"));\n                            prop.putWiki(\"mode_entries_\"+count+\"_page\", entry.getPage());\n                        } else {\n                            prop.putHTML(\"mode_entries_\"+count+\"_subject\", new String(entry.getSubject(),\"UTF-8\"));\n                            prop.putHTML(\"mode_entries_\"+count+\"_author\", new String(entry.getAuthor(),\"UTF-8\"));\n                            prop.put(\"mode_entries_\"+count+\"_page\", entry.getPage());\n                            prop.put(\"mode_entries_\"+count+\"_timestamp\", entry.getTimestamp());\n                        }\n                        prop.put(\"mode_entries_\"+count+\"_date\", dateString(entry.getDate()));\n                        prop.put(\"mode_entries_\"+count+\"_ip\", entry.getIp());\n                        if(hasRights) {\n                            prop.put(\"mode_entries_\"+count+\"_admin\", \"1\");\n                            prop.put(\"mode_entries_\"+count+\"_admin_pageid\", page.getKey());\n                            prop.put(\"mode_entries_\"+count+\"_admin_commentid\", pageid);\n                            if(page.getCommentMode() == 2 && !entry.isAllowed()) {\n                                prop.put(\"mode_entries_\"+count+\"_admin_moderate\", \"1\");\n                                prop.put(\"mode_entries_\"+count+\"_admin_moderate_pageid\", page.getKey());\n                                prop.put(\"mode_entries_\"+count+\"_admin_moderate_commentid\", pageid);\n\n                            }\n                        }\n                        else prop.put(\"mode_entries_\"+count+\"_admin\", 0);\n                        ++count;\n                    }\n                    prop.put (\"mode_entries\", count);\n                    if (i.hasNext()) {\n                        prop.put(\"mode_moreentries\", \"1\"); //more entries are availible\n                        prop.put(\"mode_moreentries_start\", nextstart);\n                        prop.put(\"mode_moreentries_num\", num);\n                        prop.put(\"mode_moreentries_pageid\", page.getKey());\n                    }\n                    else prop.put(\"mode_moreentries\", \"0\");\n                    if (start > 1) {\n                        prop.put(\"mode_preventries\", \"1\");\n                        if (prevstart < 0) prevstart = 0;\n                        prop.put(\"mode_preventries_start\", prevstart);\n                        prop.put(\"mode_preventries_num\", num);\n                        prop.put(\"mode_preventries_pageid\", page.getKey());\n                    } else prop.put(\"mode_preventries\", \"0\");\n                } catch (final IOException e) {\n\n                }\n            }\n        }\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static int recurseFolders(final Iterator<String> it, String root, int count, final boolean next, final String prev){\n    \tString fn=\"\";    \t\n    \tBookmarksDB.Bookmark bookmark;\n    \t\n    \tif (next) fn = it.next();    \t\t\n    \telse fn = prev;\n\n    \tif(fn.equals(\"\\uffff\")) {    \t\t\n    \t\tint i = prev.replaceAll(\"[^/]\",\"\").length();\n    \t\twhile(i>0){\n    \t\t\tprop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n    \t\t\tcount++;\n    \t\t\ti--;\n    \t\t}    \t\t\n    \t\treturn count;\n    \t}\n   \n    \tif(fn.startsWith((root.equals(\"/\") ? root : root+\"/\"))){\n    \t\tprop.put(\"display_folderlist_\"+count+\"_folder\", \"<li>\"+fn.replaceFirst(root+\"/*\",\"\")+\"<ul class=\\\"folder\\\">\");\n    \t\tcount++;    \n    \t\tfinal Iterator<String> bit=sb.bookmarksDB.getBookmarksIterator(fn, isAdmin);\n    \t\twhile(bit.hasNext()){\n    \t\t\tbookmark=sb.bookmarksDB.getBookmark(bit.next());\n    \t\t\tif(bookmark == null) break;\n    \t\t\tprop.put(\"display_folderlist_\"+count+\"_folder\", \"<li><a href=\\\"\"+bookmark.getUrl()+\"\\\" title=\\\"\"+bookmark.getDescription()+\"\\\">\"+ bookmark.getTitle()+\"<\/a><\/li>\");\n    \t\t\tcount++;\n    \t\t}    \t\n    \t\tif(it.hasNext()){\n    \t\t\tcount = recurseFolders(it, fn, count, true, fn);\n    \t\t}\n    \t} else {\t\t\n    \t\tprop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");        \t\t\n    \t\tcount++;\n    \t\troot = root.replaceAll(\"(/.[^/]*$)\", \"\"); \t\t\n    \t\tif(root.equals(\"\")) root = \"/\";    \t\t\n    \t\tcount = recurseFolders(it, root, count, false, fn);\n    \t} \n    \treturn count;\n    }","id":47862,"modified_method":"private static int recurseFolders(final Iterator<String> it, String root, int count, final boolean next, final String prev) {\n    \t\n        final String fn = (next) ? it.next() : prev;\n\n    \tif(\"\\uffff\".equals(fn)) {\n            int i = prev.replaceAll(\"[^/]\",\"\").length();\n            while( i>0 ){\n                prop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n                count++;\n                i--;\n            }\n            return count;\n    \t}\n   \n    \tif (fn.startsWith((root.equals(\"/\") ? root : root+\"/\"))) {\n            prop.put(\"display_folderlist_\"+count+\"_folder\", \"<li>\"+fn.replaceFirst(root+\"/*\",\"\")+\"<ul class=\\\"folder\\\">\");\n            count++;\n            final Iterator<String> bit = sb.bookmarksDB.getBookmarksIterator(fn, isAdmin);\n\n            while (bit.hasNext()) {\n                Bookmark bookmark=sb.bookmarksDB.getBookmark(bit.next());\n    \t\tif(bookmark == null) {\n                    break;\n                }\n                prop.put(\"display_folderlist_\" + count + \"_folder\", \"<li><a href=\\\"\" + bookmark.getUrl() + \"\\\" title=\\\"\" + bookmark.getDescription() + \"\\\">\" + bookmark.getTitle() + \"<\/a><\/li>\");\n                count++;\n            }\n\n            if (it.hasNext()) {\n                count = recurseFolders(it, fn, count, true, fn);\n            }\n\n    \t} else {\t\t\n            prop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n            count++;\n            root = root.replaceAll(\"(/.[^/]*$)\", \"\");\n            if (\"\".equals(root)) {\n                root = \"/\";\n            }\n            count = recurseFolders(it, root, count, false, fn);\n    \t} \n    \treturn count;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n    \tint max_count = 10;\n    \tint start=0;\n    \tint display = 0;\n    \tString tagName = \"\";\n    \tString username=\"\";\n    \t\n    \tprop.clear();\n    \tsb = (Switchboard) env;\n    \tuser = sb.userDB.getUser(header);   \n    \tisAdmin=(sb.verifyAuthentication(header, true) || user!= null && user.hasRight(UserDB.Entry.BOOKMARK_RIGHT));\n    \n    \t// set user name\n    \tif(user != null) username=user.getUserName();\n    \telse if(isAdmin) username=\"admin\";\n    \tprop.putHTML(\"user\", username);\n    \t\n    \t//redirect to userpage\n    \t/*\n    \tif(username!=\"\" &&(post == null || !post.containsKey(\"user\") && !post.containsKey(\"mode\")))\n        prop.put(\"LOCATION\", \"/Bookmarks.html?user=\"+username);\n    \t*/\n    \n    \t// set peer address\n    \tfinal String address = sb.peers.mySeed().getPublicAddress();\n    \tprop.put(\"address\", address);\n    \n    \t//defaultvalues\n    \tif(isAdmin) {\n    \t\tprop.put(\"mode\", \"1\");\n            prop.put(\"admin\", \"1\");\n            prop.put(\"display\", \"0\");\n            \n        } else {\n    \t\tprop.put(\"mode\", \"0\");\n            prop.put(\"admin\", \"0\");\n            prop.put(\"display\", \"0\");\n        }\n    \tprop.put(\"mode_edit\", \"0\");\n    \tprop.put(\"mode_title\", \"\");\n    \tprop.put(\"mode_description\", \"\");\n    \tprop.put(\"mode_url\", \"\");\n    \tprop.put(\"mode_tags\", \"\");\n    \tprop.put(\"mode_path\", \"\");\n    \tprop.put(\"mode_public\", \"1\"); //1=is public\n    \tprop.put(\"mode_feed\", \"0\"); //no newsfeed\n    \t\n    \tif(post != null){        \n    \t\tif(!isAdmin){\n    \t\t\tif(post.containsKey(\"login\")){\n    \t\t\t\tprop.put(\"AUTHENTICATE\",\"admin log-in\");\n    \t\t\t}\n    \t\t}else if(post.containsKey(\"mode\")){\n    \t\t\tfinal String mode=post.get(\"mode\");            \n    \t\t\tif(mode.equals(\"add\")){\n    \t\t\t\tprop.put(\"mode\", \"2\");\n    \t\t\t\tprop.put(\"display\", \"1\");\n    \t\t\t\tdisplay = 1;\n    \t\t\t}else if(mode.equals(\"importxml\")){\n    \t\t\t\tprop.put(\"mode\", \"3\");\n    \t\t\t\tprop.put(\"display\", \"1\");\n    \t\t\t\tdisplay = 1;\n    \t\t\t}\n    \t\t}else if(post.containsKey(\"add\")){ //add an Entry\n    \t\t\tfinal String url=post.get(\"url\");\n    \t\t\tfinal String title=post.get(\"title\");\n    \t\t\tfinal String description=post.get(\"description\");\n    \t\t\tString tagsString = post.get(\"tags\");\n    \t\t\tString pathString = post.get(\"path\");    \t\t\t\n    \t\t\tif(pathString.equals(\"\")){\n    \t\t\t\tpathString=\"/unsorted\"; //default folder\n    \t\t\t}\n    \t\t\ttagsString=tagsString+\",\"+pathString;\n    \t\t\tfinal Set<String> tags=ListManager.string2set(BookmarkHelper.cleanTagsString(tagsString));\n    \t\t\tfinal BookmarksDB.Bookmark bookmark = sb.bookmarksDB.createBookmark(url, username);\n    \t\t\tif(bookmark != null){\n    \t\t\t\tbookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n    \t\t\t\tbookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n    \t\t\t\tif(user!=null){ \n    \t\t\t\t\tbookmark.setOwner(user.getUserName());\n    \t\t\t\t}\n    \t\t\t\tif((post.get(\"public\")).equals(\"public\")){\n    \t\t\t\t\tbookmark.setPublic(true);\n    \t\t\t\t\tpublishNews(url, title, description, tagsString);\n    \t\t\t\t}else{\n    \t\t\t\t\tbookmark.setPublic(false);\n    \t\t\t\t}\n    \t\t\t\tif(post.containsKey(\"feed\") && (post.get(\"feed\")).equals(\"feed\")){\n    \t\t\t\t\tbookmark.setFeed(true);\n    \t\t\t\t}else{\n    \t\t\t\t\tbookmark.setFeed(false);\n    \t\t\t\t}\n    \t\t\t\tbookmark.setTags(tags, true);\n    \t\t\t\tsb.bookmarksDB.saveBookmark(bookmark);\n    \t\t\t//}else{\n    \t                    //ERROR\n    \t\t\t}\n    \t\t}else if(post.containsKey(\"edit\")){\n    \t\t\tfinal String urlHash=post.get(\"edit\");\n    \t\t\tprop.put(\"mode\", \"2\");\n    \t\t\tprop.put(\"display\", \"1\");\n    \t\t\tdisplay = 1;\n    \t\t\tif (urlHash.length() == 0) {\n    \t\t\t\tprop.put(\"mode_edit\", \"0\"); // create mode\n    \t\t\t\tprop.putHTML(\"mode_title\", post.get(\"title\"));\n    \t\t\t\tprop.putHTML(\"mode_description\", post.get(\"description\"));\n    \t\t\t\tprop.putHTML(\"mode_url\", post.get(\"url\"));\n    \t\t\t\tprop.putHTML(\"mode_tags\", post.get(\"tags\"));\n    \t\t\t\tprop.putHTML(\"mode_path\", post.get(\"path\"));\n    \t\t\t\tprop.put(\"mode_public\", \"0\");\n    \t\t\t\tprop.put(\"mode_feed\", \"0\");\n    \t\t\t} else {\n                    final BookmarksDB.Bookmark bookmark = sb.bookmarksDB.getBookmark(urlHash);\n                    if (bookmark == null) {\n                        // try to get the bookmark from the LURL database\n                        final URIMetadataRow urlentry = sb.indexSegments.urlMetadata(Segments.Process.PUBLIC).load(urlHash.getBytes(), null, 0);\n                        Document[] documents = null;\n                        if (urlentry != null) try {\n                            final URIMetadataRow.Components metadata = urlentry.metadata();\n                            documents = sb.loader.loadDocuments(sb.loader.request(metadata.url(), true, false), CrawlProfile.CacheStrategy.IFEXIST, 5000, Long.MAX_VALUE);\n                            Document document = Document.mergeDocuments(metadata.url(), null, documents);\n                            prop.put(\"mode_edit\", \"0\"); // create mode\n                            prop.put(\"mode_url\", metadata.url().toNormalform(false, true));\n                            prop.putHTML(\"mode_title\", metadata.dc_title());\n                            prop.putHTML(\"mode_description\", (document == null) ? metadata.dc_title(): document.dc_title());\n                            prop.putHTML(\"mode_author\", metadata.dc_creator());\n                            prop.putHTML(\"mode_tags\", (document == null) ? metadata.dc_subject() : document.dc_subject(','));\n                            prop.putHTML(\"mode_path\",\"\");\n                            prop.put(\"mode_public\", \"0\");\n                            prop.put(\"mode_feed\", \"0\"); //TODO: check if it IS a feed\n                        } catch (IOException e) {Log.logException(e);} catch (Parser.Failure e) {Log.logException(e);}\n                    } else {\n                        // get from the bookmark database\n                        prop.put(\"mode_edit\", \"1\"); // edit mode\n                        prop.putHTML(\"mode_title\", bookmark.getTitle());\n                        prop.putHTML(\"mode_description\", bookmark.getDescription());\n                        prop.put(\"mode_url\", bookmark.getUrl()); //TODO: XSS protection - how is this stored?\n                        prop.putHTML(\"mode_tags\", bookmark.getTagsString());\n                        prop.putHTML(\"mode_path\",bookmark.getFoldersString());\n                        if (bookmark.getPublic()) {\n                            prop.put(\"mode_public\", \"1\");\n                        } else {\n                            prop.put(\"mode_public\", \"0\");\n                        }\n                        if (bookmark.getFeed()) {\n                            prop.put(\"mode_feed\", \"1\");\n                        } else {\n                            prop.put(\"mode_feed\", \"0\");\n                        }\n                    }\n                }\n    \t\t} else if(post.containsKey(\"htmlfile\")){\n    \t\t\tboolean isPublic=false;\n    \t\t\tif((post.get(\"public\")).equals(\"public\")){\n    \t\t\t\tisPublic=true;\n    \t\t\t}\n    \t\t\tString tags=post.get(\"tags\");\n    \t\t\tif(tags.equals(\"\")){\n    \t\t\t\ttags=\"unsorted\";\n    \t\t\t}\n    \t\t\tLog.logInfo(\"BOOKMARKS\", \"I try to import bookmarks from HTML-file\");\n    \t\t\ttry {\n    \t\t\t\tfinal File file=new File(post.get(\"htmlfile\"));    \t\t\t\n    \t\t\t\tBookmarkHelper.importFromBookmarks(sb.bookmarksDB, new DigestURI(file), post.get(\"htmlfile$file\"), tags, isPublic);\n    \t\t\t} catch (final MalformedURLException e) {}\n    \t\t\tLog.logInfo(\"BOOKMARKS\", \"success!!\");\n    \t\t}else if(post.containsKey(\"xmlfile\")){\n    \t\t\tboolean isPublic=false;\n    \t\t\tif((post.get(\"public\")).equals(\"public\")){\n    \t\t\t\tisPublic=true;\n    \t\t\t}\n    \t\t\tBookmarkHelper.importFromXML(sb.bookmarksDB, post.get(\"xmlfile$file\"), isPublic);\n    \t\t}else if(post.containsKey(\"delete\")){\n    \t\t\tfinal String urlHash=post.get(\"delete\");\n    \t\t\tsb.bookmarksDB.removeBookmark(urlHash);\n    \t\t}\n    \t\tif(post.containsKey(\"tag\")){\n    \t\t\ttagName=post.get(\"tag\");\n    \t\t}\n    \t\tif(post.containsKey(\"start\")){\n    \t\t\tstart=Integer.parseInt(post.get(\"start\"));\n    \t\t}\n    \t\tif(post.containsKey(\"num\")){\n    \t\t\tmax_count=Integer.parseInt(post.get(\"num\"));\n    \t\t}\n    \t} // END if(post != null)\n    \t\n    \tif (display == 0) {\n    \t    \t\n\t    \t//-----------------------\n\t    \t// create tag list\n\t    \t//-----------------------\n\t    \tprintTagList(\"taglist\", tagName, SORT_SIZE, 25, false);\n\t    \tprintTagList(\"optlist\", tagName, SORT_ALPHA, SHOW_ALL, true);\n\t    \t       \t\n\t    \t//-----------------------\n\t    \t// create bookmark list\n\t    \t//-----------------------\n\t    \tint count=0;\n\t        Iterator<String> it = null;    \t\n\t       \tBookmarksDB.Bookmark bookmark;\n\t       \tSet<String> tags;\n\t       \tIterator<String> tagsIt;\n\t       \tint tagCount;\n\t       \t\n\t       \tprop.put(\"display_num-bookmarks\", sb.bookmarksDB.bookmarksSize());\n\t       \t\n\t       \tcount=0;\n\t       \tif(!tagName.equals(\"\")){\n\t       \t\tprop.put(\"display_selected\", \"\");\n\t       \t\tit=sb.bookmarksDB.getBookmarksIterator(tagName, isAdmin);\n\t       \t}else{\n\t       \t\tprop.put(\"display_selected\", \" selected=\\\"selected\\\"\");\n\t       \t\tit=sb.bookmarksDB.getBookmarksIterator(isAdmin);\n\t       \t}\n\t       \t\n\t       \t//skip the first entries (display next page)\n\t       \tcount=0;\n\t       \twhile(count < start && it.hasNext()){\n\t       \t\tit.next();\n\t       \t\tcount++;\n\t       \t}\n\t       \t\n\t       \tcount=0;\n\t       \twhile(count<max_count && it.hasNext()){\n\t       \t\tbookmark=sb.bookmarksDB.getBookmark(it.next());\n\t       \t\tif(bookmark!=null){\n\t       \t\t\tif(bookmark.getFeed() && isAdmin)\n\t       \t\t\t\tprop.put(\"display_bookmarks_\"+count+\"_link\", \"/FeedReader_p.html?url=\"+bookmark.getUrl());\n\t       \t\t\telse\n\t       \t\t\t\tprop.put(\"display_bookmarks_\"+count+\"_link\",bookmark.getUrl());\n\t       \t\t\tprop.putHTML(\"display_bookmarks_\"+count+\"_title\", bookmark.getTitle());\n\t       \t\t\tprop.putHTML(\"display_bookmarks_\"+count+\"_description\", bookmark.getDescription());\n\t       \t\t\tprop.put(\"display_bookmarks_\"+count+\"_date\", DateFormatter.formatISO8601(new Date(bookmark.getTimeStamp())));\n\t       \t\t\tprop.put(\"display_bookmarks_\"+count+\"_rfc822date\", HeaderFramework.formatRFC1123(new Date(bookmark.getTimeStamp())));\n\t       \t\t\tprop.put(\"display_bookmarks_\"+count+\"_public\", (bookmark.getPublic() ? \"1\" : \"0\"));\n\t            \n\t       \t\t\t//List Tags.\n\t       \t\t\ttags=bookmark.getTags();\n\t       \t\t\ttagsIt=tags.iterator();\n\t       \t\t\ttagCount=0;\n\t       \t\t\twhile (tagsIt.hasNext()) {            \t\n\t       \t\t\t\tfinal String tname = tagsIt.next();\n\t       \t\t\t\tif (tname.length() > 0 && tname.charAt(0) != '/') {\n\t       \t\t\t\t\tprop.putHTML(\"display_bookmarks_\"+count+\"_tags_\"+tagCount+\"_tag\", tname);\n\t       \t\t\t\t\ttagCount++;\n\t       \t\t\t\t}\n\t       \t\t\t}\n\t       \t\t\tprop.put(\"display_bookmarks_\"+count+\"_tags\", tagCount);\n\t       \t\t\tprop.put(\"display_bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n\t       \t\t\tcount++;\n\t       \t\t}\n\t       \t}\n\t       \tprop.putHTML(\"display_tag\", tagName);\n\t       \tprop.put(\"display_start\", start);\n\t       \tif(it.hasNext()){\n\t       \t\tprop.put(\"display_next-page\", \"1\");\n\t       \t\tprop.put(\"display_next-page_start\", start+max_count);\n\t       \t\tprop.putHTML(\"display_next-page_tag\", tagName);\n\t       \t\tprop.put(\"display_next-page_num\", max_count);\n\t       \t}\n\t       \tif(start >= max_count){\n\t       \t\tstart=start-max_count;\n\t       \t\tif(start <0){\n\t       \t\t\tstart=0;\n\t       \t\t}\n\t       \t\tprop.put(\"display_prev-page\", \"1\");\n\t       \t\tprop.put(\"display_prev-page_start\", start);\n\t       \t\tprop.putHTML(\"display_prev-page_tag\", tagName);\n\t       \t\tprop.put(\"display_prev-page_num\", max_count);\n\t       \t}\n\t       \tprop.put(\"display_bookmarks\", count);\n\t    \n\t    \n\t    \t//-----------------------\n\t    \t// create folder list\n\t    \t//-----------------------\n\t       \t\n\t       \tcount = 0;\n\t       \tcount = recurseFolders(BookmarkHelper.getFolderList(\"/\", sb.bookmarksDB.getTagIterator(isAdmin)), \"/\", 0, true, \"\");\n\t       \tprop.put(\"display_folderlist\", count);\n    \t}\n       \treturn prop;    // return from serverObjects respond()\n    }","id":47863,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n    \tint max_count = 10;\n    \tint start=0;\n    \tint display = 0;\n    \tString tagName = \"\";\n    \tString username=\"\";\n    \t\n    \tprop.clear();\n    \tsb = (Switchboard) env;\n    \tuser = sb.userDB.getUser(header);   \n    \tisAdmin = (sb.verifyAuthentication(header, true) || user!= null && user.hasRight(UserDB.Entry.BOOKMARK_RIGHT));\n    \n    \t// set user name\n    \tif (user != null) {\n            username=user.getUserName();\n        } else if(isAdmin) {\n            username=\"admin\";\n        }\n    \tprop.putHTML(\"user\", username);\n    \t\n    \t//redirect to userpage\n    \t/*\n    \tif(username!=\"\" &&(post == null || !post.containsKey(\"user\") && !post.containsKey(\"mode\")))\n        prop.put(\"LOCATION\", \"/Bookmarks.html?user=\"+username);\n    \t*/\n    \n    \t// set peer address\n    \tprop.put(\"address\", sb.peers.mySeed().getPublicAddress());\n    \n    \t//defaultvalues\n    \tif(isAdmin) {\n            prop.put(\"mode\", \"1\");\n            prop.put(\"admin\", \"1\");\n            prop.put(\"display\", \"0\");\n        } else {\n            prop.put(\"mode\", \"0\");\n            prop.put(\"admin\", \"0\");\n            prop.put(\"display\", \"0\");\n        }\n    \tprop.put(\"mode_edit\", \"0\");\n    \tprop.put(\"mode_title\", \"\");\n    \tprop.put(\"mode_description\", \"\");\n    \tprop.put(\"mode_url\", \"\");\n    \tprop.put(\"mode_tags\", \"\");\n    \tprop.put(\"mode_path\", \"\");\n    \tprop.put(\"mode_public\", \"1\"); //1=is public\n    \tprop.put(\"mode_feed\", \"0\"); //no newsfeed\n    \t\n    \tif (post != null) {\n            if (!isAdmin) {\n                if(post.containsKey(\"login\")){\n                    prop.put(\"AUTHENTICATE\",\"admin log-in\");\n                }\n            } else if (post.containsKey(\"mode\")) {\n                final String mode=post.get(\"mode\");\n                if (\"add\".equals(mode)) {\n                    prop.put(\"mode\", \"2\");\n                    prop.put(\"display\", \"1\");\n                    display = 1;\n                } else if (\"importxml\".equals(mode)){\n                    prop.put(\"mode\", \"3\");\n                    prop.put(\"display\", \"1\");\n                    display = 1;\n                }\n            } else if(post.containsKey(\"add\")) { //add an Entry\n                final String url=post.get(\"url\");\n                final String title=post.get(\"title\");\n                final String description=post.get(\"description\");\n                String tagsString = post.get(\"tags\");\n                String pathString = post.get(\"path\");\n                if(pathString == null || \"\".equals(pathString)){\n                    pathString=\"/unsorted\"; //default folder\n                }\n                tagsString = tagsString + \",\" + pathString;\n                final Set<String> tags=ListManager.string2set(BookmarkHelper.cleanTagsString(tagsString));\n                final BookmarksDB.Bookmark bookmark = sb.bookmarksDB.createBookmark(url, username);\n\n                if (bookmark != null) {\n                    bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n                    bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n\n                    if (user!=null) {\n                        bookmark.setOwner(user.getUserName());\n                    }\n\n                    if ((post.get(\"public\")).equals(\"public\")) {\n                        bookmark.setPublic(true);\n                        publishNews(url, title, description, tagsString);\n                    } else {\n                        bookmark.setPublic(false);\n                    }\n\n                    if(post.containsKey(\"feed\") && (\"feed\".equals(post.get(\"feed\")))){\n                        bookmark.setFeed(true);\n                    } else {\n                        bookmark.setFeed(false);\n                    }\n                    \n                    bookmark.setTags(tags, true);\n                    sb.bookmarksDB.saveBookmark(bookmark);\n                }\n\n            } else if (post.containsKey(\"edit\")) {\n                final String urlHash = post.get(\"edit\");\n                prop.put(\"mode\", \"2\");\n                prop.put(\"display\", \"1\");\n                display = 1;\n                if (urlHash.length() == 0) {\n                    prop.put(\"mode_edit\", \"0\"); // create mode\n                    prop.putHTML(\"mode_title\", post.get(\"title\"));\n                    prop.putHTML(\"mode_description\", post.get(\"description\"));\n                    prop.putHTML(\"mode_url\", post.get(\"url\"));\n                    prop.putHTML(\"mode_tags\", post.get(\"tags\"));\n                    prop.putHTML(\"mode_path\", post.get(\"path\"));\n                    prop.put(\"mode_public\", \"0\");\n                    prop.put(\"mode_feed\", \"0\");\n                } else {\n                    final BookmarksDB.Bookmark bookmark = sb.bookmarksDB.getBookmark(urlHash);\n                    if (bookmark == null) {\n                        // try to get the bookmark from the LURL database\n                        final URIMetadataRow urlentry = sb.indexSegments.urlMetadata(Segments.Process.PUBLIC).load(urlHash.getBytes(), null, 0);\n                        if (urlentry != null) try {\n                            final URIMetadataRow.Components metadata = urlentry.metadata();\n                            final Document document = Document.mergeDocuments(metadata.url(), null, sb.loader.loadDocuments(sb.loader.request(metadata.url(), true, false), CrawlProfile.CacheStrategy.IFEXIST, 5000, Long.MAX_VALUE));\n                            prop.put(\"mode_edit\", \"0\"); // create mode\n                            prop.put(\"mode_url\", metadata.url().toNormalform(false, true));\n                            prop.putHTML(\"mode_title\", metadata.dc_title());\n                            prop.putHTML(\"mode_description\", (document == null) ? metadata.dc_title(): document.dc_title());\n                            prop.putHTML(\"mode_author\", metadata.dc_creator());\n                            prop.putHTML(\"mode_tags\", (document == null) ? metadata.dc_subject() : document.dc_subject(','));\n                            prop.putHTML(\"mode_path\",\"\");\n                            prop.put(\"mode_public\", \"0\");\n                            prop.put(\"mode_feed\", \"0\"); //TODO: check if it IS a feed\n                        } catch (IOException e) {Log.logException(e);} catch (Parser.Failure e) {Log.logException(e);}\n                    } else {\n                        // get from the bookmark database\n                        prop.put(\"mode_edit\", \"1\"); // edit mode\n                        prop.putHTML(\"mode_title\", bookmark.getTitle());\n                        prop.putHTML(\"mode_description\", bookmark.getDescription());\n                        prop.put(\"mode_url\", bookmark.getUrl()); //TODO: XSS protection - how is this stored?\n                        prop.putHTML(\"mode_tags\", bookmark.getTagsString());\n                        prop.putHTML(\"mode_path\",bookmark.getFoldersString());\n\n                        if (bookmark.getPublic()) {\n                            prop.put(\"mode_public\", \"1\");\n                        } else {\n                            prop.put(\"mode_public\", \"0\");\n                        }\n                        \n                        if (bookmark.getFeed()) {\n                            prop.put(\"mode_feed\", \"1\");\n                        } else {\n                            prop.put(\"mode_feed\", \"0\");\n                        }\n                    }\n                }\n            } else if(post.containsKey(\"htmlfile\")){\n                final boolean isPublic = \"public\".equals(post.get(\"public\"));\n\n                String tags = post.get(\"tags\");\n                if(\"\".equals(tags)){\n                    tags=\"unsorted\";\n                }\n    \t\t\t\n                Log.logInfo(\"BOOKMARKS\", \"Trying to import bookmarks from HTML-file\");\n\n                try {\n                    final File file=new File(post.get(\"htmlfile\"));\n                    BookmarkHelper.importFromBookmarks(sb.bookmarksDB, new DigestURI(file), post.get(\"htmlfile$file\"), tags, isPublic);\n                } catch (final MalformedURLException e) {}\n\n                Log.logInfo(\"BOOKMARKS\", \"success!!\");\n\n            } else if (post.containsKey(\"xmlfile\")) {\n\n                final boolean isPublic = \"public\".equals(post.get(\"public\"));\n                BookmarkHelper.importFromXML(sb.bookmarksDB, post.get(\"xmlfile$file\"), isPublic);\n\n            } else if (post.containsKey(\"delete\")) {\n\n                final String urlHash=post.get(\"delete\");\n                sb.bookmarksDB.removeBookmark(urlHash);\n\n            }\n\n            if (post.containsKey(\"tag\")) {\n                tagName = post.get(\"tag\");\n            }\n\n            if (post.containsKey(\"start\")) {\n                start = Integer.parseInt(post.get(\"start\"));\n            }\n\n            if (post.containsKey(\"num\")) {\n                max_count = Integer.parseInt(post.get(\"num\"));\n            }\n    \t} // END if(post != null)\n    \t\n    \tif (display == 0) {\n    \t    \t\n\t    \t//-----------------------\n\t    \t// create tag list\n\t    \t//-----------------------\n\t    \tprintTagList(\"taglist\", tagName, SORT_SIZE, 25, false);\n\t    \tprintTagList(\"optlist\", tagName, SORT_ALPHA, SHOW_ALL, true);\n\t    \t       \t\n\t    \t//-----------------------\n\t    \t// create bookmark list\n\t    \t//-----------------------\n\t    \tint count = 0;\n\t        Iterator<String> it = null;    \t\n\n                prop.put(\"display_num-bookmarks\", sb.bookmarksDB.bookmarksSize());\n\t       \t\n\t       \tif(!\"\".equals(tagName)){\n                    prop.put(\"display_selected\", \"\");\n                    it = sb.bookmarksDB.getBookmarksIterator(tagName, isAdmin);\n\t       \t} else {\n                    prop.put(\"display_selected\", \" selected=\\\"selected\\\"\");\n                    it = sb.bookmarksDB.getBookmarksIterator(isAdmin);\n\t       \t}\n\t       \t\n\t       \t//skip the first entries (display next page)\n\t       \tcount = 0;\n\t       \twhile(count < start && it.hasNext()){\n                    it.next();\n                    count++;\n\t       \t}\n\t       \t\n\t       \tcount = 0;\n\t       \twhile(count < max_count && it.hasNext()) {\n                    final Bookmark bookmark = sb.bookmarksDB.getBookmark(it.next());\n\t       \t\t\n                    if (bookmark != null){\n                        if (bookmark.getFeed() && isAdmin) {\n                            prop.put(\"display_bookmarks_\"+count+\"_link\", \"/FeedReader_p.html?url=\"+bookmark.getUrl());\n                        } else {\n                            prop.put(\"display_bookmarks_\"+count+\"_link\",bookmark.getUrl());\n                        }\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_title\", bookmark.getTitle());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_description\", bookmark.getDescription());\n                        prop.put(\"display_bookmarks_\"+count+\"_date\", DateFormatter.formatISO8601(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_rfc822date\", HeaderFramework.formatRFC1123(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_public\", (bookmark.getPublic() ? \"1\" : \"0\"));\n\t            \n                        //List Tags.\n                        final Set<String> tags = bookmark.getTags();\n                        int tagCount=0;\n                        for (final String tag : tags) {\n                            if (tag.length() > 0 && tag.charAt(0) != '/') {\n                                prop.putHTML(\"display_bookmarks_\" + count + \"_tags_\" + tagCount + \"_tag\", tag);\n                                tagCount++;\n                            }\n                        }\n                        prop.put(\"display_bookmarks_\"+count+\"_tags\", tagCount);\n                        prop.put(\"display_bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n                        count++;\n                    }\n\t       \t}\n\n\t       \tprop.putHTML(\"display_tag\", tagName);\n\t       \tprop.put(\"display_start\", start);\n\n\t       \tif (it.hasNext()) {\n                    prop.put(\"display_next-page\", \"1\");\n                    prop.put(\"display_next-page_start\", start+max_count);\n                    prop.putHTML(\"display_next-page_tag\", tagName);\n                    prop.put(\"display_next-page_num\", max_count);\n\t       \t}\n\t       \tif (start >= max_count) {\n                    start = start-max_count;\n                    if (start <0){\n                        start = 0;\n                    }\n                    prop.put(\"display_prev-page\", \"1\");\n                    prop.put(\"display_prev-page_start\", start);\n                    prop.putHTML(\"display_prev-page_tag\", tagName);\n                    prop.put(\"display_prev-page_num\", max_count);\n\t       \t}\n\t       \tprop.put(\"display_bookmarks\", count);\n\t    \n\t    \n\t    \t//-----------------------\n\t    \t// create folder list\n\t    \t//-----------------------\n\t       \t\n\t       \tcount = 0;\n\t       \tcount = recurseFolders(BookmarkHelper.getFolderList(\"/\", sb.bookmarksDB.getTagIterator(isAdmin)), \"/\", 0, true, \"\");\n\t       \tprop.put(\"display_folderlist\", count);\n    \t}\n       \treturn prop;    // return from serverObjects respond()\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void printTagList(final String id, final String tagName, final int comp, final int max, final boolean opt){    \t\n    \tint count=0;\n    \tBookmarksDB.Tag tag;\n    \tIterator<BookmarksDB.Tag> it = null;\n    \t\n        if (tagName.equals(\"\")) {\n        \tit = sb.bookmarksDB.getTagIterator(isAdmin, comp, max);\n        } else {\n        \tit = sb.bookmarksDB.getTagIterator(tagName, isAdmin, comp, max);\n        }\n       \twhile(it.hasNext()){\n       \t\ttag=it.next();\n       \t\tif ((!tag.getTagName().startsWith(\"/\")) && (!tag.getTagName().equals(\"\"))) {\n       \t\t\tprop.putHTML(\"display_\"+id+\"_\"+count+\"_name\", tag.getFriendlyName());\n       \t\t\tprop.putHTML(\"display_\"+id+\"_\"+count+\"_tag\", tag.getTagName());\n       \t\t\tprop.put(\"display_\"+id+\"_\"+count+\"_num\", tag.size());\n       \t\t\tif (opt){\n       \t\t\t\tif(tagName.equals(tag.getFriendlyName())){\n       \t\t\t\t\tprop.put(\"display_\"+id+\"_\"+count+\"_selected\", \" selected=\\\"selected\\\"\");\n       \t\t\t\t} else {\n       \t\t\t\t\tprop.put(\"display_\"+id+\"_\"+count+\"_selected\", \"\");\n       \t\t\t\t}\n       \t\t\t} else {\n       \t\t\t\t// font-size is pseudo-rounded to 2 decimals\n       \t\t\t\tprop.put(\"display_\"+id+\"_\"+count+\"_size\", Math.round((1.1+Math.log(tag.size())/4)*100)/100.);\n       \t\t\t}\n       \t\t\tcount++;\n       \t\t}\n       \t}\n       \tprop.put(\"display_\"+id, count);    \t\n    }","id":47864,"modified_method":"private static void printTagList(final String id, final String tagName, final int comp, final int max, final boolean opt){    \t\n    \tint count=0;\n\n    \tfinal Iterator<BookmarksDB.Tag> it;\n    \t\n        if (\"\".equals(tagName)) {\n            it = sb.bookmarksDB.getTagIterator(isAdmin, comp, max);\n        } else {\n            it = sb.bookmarksDB.getTagIterator(tagName, isAdmin, comp, max);\n        }\n\n       \twhile(it.hasNext()){\n            final Tag tag = it.next();\n            if (!tag.getTagName().startsWith(\"/\") && !\"\".equals(tag.getTagName())) {\n                prop.putHTML(\"display_\"+id+\"_\"+count+\"_name\", tag.getFriendlyName());\n                prop.putHTML(\"display_\"+id+\"_\"+count+\"_tag\", tag.getTagName());\n                prop.put(\"display_\"+id+\"_\"+count+\"_num\", tag.size());\n                if (opt) {\n                    if (tag.getFriendlyName().equals(tagName)){\n                        prop.put(\"display_\"+id+\"_\"+count+\"_selected\", \" selected=\\\"selected\\\"\");\n                    } else {\n                        prop.put(\"display_\"+id+\"_\"+count+\"_selected\", \"\");\n                    }\n                } else {\n                    // font-size is pseudo-rounded to 2 decimals\n                    prop.put(\"display_\"+id+\"_\"+count+\"_size\", Math.round((1.1+Math.log(tag.size())/4)*100)/100.);\n                }\n                count++;\n            }\n       \t}\n       \tprop.put(\"display_\"+id, count);    \t\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void publishNews(final String url, final String title, final String description, final String tagsString) {\n    \t// create a news message\n    \tfinal HashMap<String, String> map = new HashMap<String, String>();\n    \tmap.put(\"url\", url.replace(',', '|'));\n    \tmap.put(\"title\", title.replace(',', ' '));\n    \tmap.put(\"description\", description.replace(',', ' '));\n    \tmap.put(\"tags\", tagsString.replace(',', ' '));\n    \tsb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_BOOKMARK_ADD, map);\n    }","id":47865,"modified_method":"private static void publishNews(final String url, final String title, final String description, final String tagsString) {\n    \t// create a news message\n    \tfinal Map<String, String> map = new HashMap<String, String>();\n    \tmap.put(\"url\", url.replace(',', '|'));\n    \tmap.put(\"title\", title.replace(',', ' '));\n    \tmap.put(\"description\", description.replace(',', ' '));\n    \tmap.put(\"tags\", tagsString.replace(',', ' '));\n    \tsb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_BOOKMARK_ADD, map);\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = Switchboard.getSwitchboard();\r\n        UserDB.Entry entry=null;\r\n\r\n        // admin password\r\n        boolean localhostAccess = sb.getConfigBool(\"adminAccountForLocalhost\", false);\r\n        if ((post != null) && (post.containsKey(\"setAdmin\"))) {\r\n            localhostAccess = post.get(\"access\", \"\").equals(\"localhost\");\r\n            final String user   = (post == null) ? \"\" : post.get(\"adminuser\", \"\");\r\n            final String pw1    = (post == null) ? \"\" : post.get(\"adminpw1\", \"\");\r\n            final String pw2    = (post == null) ? \"\" : post.get(\"adminpw2\", \"\");\r\n\r\n            // may be overwritten if new password is given\r\n            if ((user.length() > 0) && (pw1.length() > 3) && (pw1.equals(pw2))) {\r\n                // check passed. set account:\r\n                env.setConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, Digest.encodeMD5Hex(Base64Order.standardCoder.encodeString(user + \":\" + pw1)));\r\n                env.setConfig(\"adminAccount\", \"\");\r\n            }\r\n            \r\n            if (localhostAccess) {\r\n                if (sb.crawlStacker.acceptLocalURLs()) {\r\n                    // in this case it is not allowed to use a localhostAccess option\r\n                    prop.put(\"commitIntranetWarning\", 1);\r\n                    localhostAccess = false;\r\n                    sb.setConfig(\"adminAccountForLocalhost\", false);\r\n                } else {\r\n                    sb.setConfig(\"adminAccountForLocalhost\", true);\r\n                    // if an localhost access is configured, check if a local password is given\r\n                    // if not, set a random password\r\n                    if (post != null && env.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").length() == 0) {\r\n                        // make a 'random' password\r\n                        env.setConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"0000\" + Digest.encodeMD5Hex(System.getProperties().toString() + System.currentTimeMillis()));\r\n                        env.setConfig(\"adminAccount\", \"\");\r\n                    }\r\n                }\r\n            } else {\r\n                sb.setConfig(\"adminAccountForLocalhost\", false);\r\n                if (env.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").startsWith(\"0000\")) {\r\n                    // make shure that the user can still use the interface after a random password was set\r\n                    env.setConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\");\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (env.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").length() == 0 && !env.getConfigBool(\"adminAccountForLocalhost\", false)) {\r\n            prop.put(\"passwordNotSetWarning\", 1);\r\n        }\r\n        \r\n        prop.put(\"localhost.checked\", (localhostAccess) ? 1 : 0);\r\n        prop.put(\"account.checked\", (localhostAccess) ? 0 : 1);\r\n        prop.put(\"statusPassword\", localhostAccess ? \"0\" : \"1\");\r\n        prop.put(\"defaultUser\", \"admin\");\r\n        \r\n        //default values\r\n        prop.put(\"current_user\", \"newuser\");\r\n        prop.put(\"username\", \"\");\r\n        prop.put(\"firstname\", \"\");\r\n        prop.put(\"lastname\", \"\");\r\n        prop.put(\"address\", \"\");\r\n        prop.put(\"timelimit\", \"\");\r\n        prop.put(\"timeused\", \"\");\r\n        final String[] rightNames=UserDB.Entry.RIGHT_NAMES.split(\",\");\r\n        final String[] rights=UserDB.Entry.RIGHT_TYPES.split(\",\");\r\n        int i;\r\n        for(i=0;i<rights.length;i++){\r\n        \t\tprop.put(\"rights_\"+i+\"_name\", rights[i]);\r\n        \t\tprop.put(\"rights_\"+i+\"_friendlyName\", rightNames[i]);\r\n        \t\tprop.put(\"rights_\"+i+\"_set\", \"0\");\r\n        }\r\n        prop.put(\"rights\", i);\r\n        \r\n        prop.put(\"users\", \"0\");\r\n        \r\n        if (sb.userDB == null)\r\n            return prop;\r\n        \r\n        if(post == null){\r\n            //do nothing\r\n\r\n            //user != current_user\r\n            //user=from userlist\r\n            //current_user = edited user\r\n        } else if(post.containsKey(\"user\") && !(post.get(\"user\")).equals(\"newuser\")){\r\n            if(post.containsKey(\"change_user\")){\r\n                //defaults for newuser are set above                \r\n                entry=sb.userDB.getEntry(post.get(\"user\"));\r\n                // program crashes if a submit with emty username was made on previous mask and the user clicked on the \r\n                // link: \"If you want to manage more Users, return to the user page.\" (parameter \"user\" is empty)\r\n                if (entry != null) {\r\n                    //TODO: set username read-only in html\r\n                    prop.putHTML(\"current_user\", post.get(\"user\"));\r\n                    prop.putHTML(\"username\", post.get(\"user\"));\r\n                    prop.putHTML(\"firstname\", entry.getFirstName());\r\n                    prop.putHTML(\"lastname\", entry.getLastName());\r\n                    prop.putHTML(\"address\", entry.getAddress());\r\n                    prop.put(\"timelimit\", entry.getTimeLimit());\r\n                    prop.put(\"timeused\", entry.getTimeUsed());\r\n                    for(i=0;i<rights.length;i++){\r\n                        prop.put(\"rights_\"+i+\"_set\", entry.hasRight(rights[i]) ? \"1\" : \"0\");\r\n                    }\r\n                    prop.put(\"rights\", i);\r\n                }\r\n            }else if( post.containsKey(\"delete_user\") && !(post.get(\"user\")).equals(\"newuser\") ){\r\n                sb.userDB.removeEntry(post.get(\"user\"));\r\n            }\r\n        } else if(post.containsKey(\"change\")) { //New User / edit User\r\n            prop.put(\"text\", \"0\");\r\n            prop.put(\"error\", \"0\");\r\n\r\n            final String username=post.get(\"username\");\r\n            final String pw1=post.get(\"password\");\r\n            final String pw2=post.get(\"password2\");\r\n            if(! pw1.equals(pw2)){\r\n                prop.put(\"error\", \"2\"); //PW does not match\r\n                return prop;\r\n            }\r\n            final String firstName=post.get(\"firstname\");\r\n            final String lastName=post.get(\"lastname\");\r\n            final String address=post.get(\"address\");\r\n            final String timeLimit=post.get(\"timelimit\");\r\n            final String timeUsed=post.get(\"timeused\");\r\n            final HashMap<String, String> rightsSet=new HashMap<String, String>();\r\n            for(i=0;i<rights.length;i++){\r\n        \t    \t\trightsSet.put(rights[i], post.containsKey(rights[i])&&(post.get(rights[i])).equals(\"on\") ? \"true\" : \"false\");\r\n            }\r\n            final HashMap<String, String> mem=new HashMap<String, String>();\r\n            if( post.get(\"current_user\").equals(\"newuser\")){ //new user\r\n                \r\n\t\t\t\tif(!pw1.equals(\"\")){ //change only if set\r\n\t                mem.put(UserDB.Entry.MD5ENCODED_USERPWD_STRING, Digest.encodeMD5Hex(username+\":\"+pw1));\r\n\t\t\t\t}\r\n\t\t\t\tmem.put(UserDB.Entry.USER_FIRSTNAME, firstName);\r\n\t\t\t\tmem.put(UserDB.Entry.USER_LASTNAME, lastName);\r\n\t\t\t\tmem.put(UserDB.Entry.USER_ADDRESS, address);\r\n\t\t\t\tmem.put(UserDB.Entry.TIME_LIMIT, timeLimit);\r\n\t\t\t\tmem.put(UserDB.Entry.TIME_USED, timeUsed);\r\n\t\t\t\tfor(i=0;i<rights.length;i++)\r\n\t\t\t\t\tmem.put(rights[i], rightsSet.get(rights[i]));\r\n\r\n                try{\r\n                    entry=sb.userDB.createEntry(username, mem);\r\n                    sb.userDB.addEntry(entry);\r\n                    prop.putHTML(\"text_username\", username);\r\n                    prop.put(\"text\", \"1\");\r\n                }catch(final IllegalArgumentException e){\r\n                    prop.put(\"error\", \"3\");\r\n                }\r\n                \r\n            } else { //edit user\r\n\r\n                entry = sb.userDB.getEntry(username);\r\n\t\t\t\tif(entry != null){\r\n\t                try{\r\n\t\t\t\t\t\tif(! pw1.equals(\"\")){\r\n\t\t\t                entry.setProperty(UserDB.Entry.MD5ENCODED_USERPWD_STRING, Digest.encodeMD5Hex(username+\":\"+pw1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tentry.setProperty(UserDB.Entry.USER_FIRSTNAME, firstName);\r\n\t\t\t\t\t\tentry.setProperty(UserDB.Entry.USER_LASTNAME, lastName);\r\n\t\t\t\t\t\tentry.setProperty(UserDB.Entry.USER_ADDRESS, address);\r\n\t\t\t\t\t\tentry.setProperty(UserDB.Entry.TIME_LIMIT, timeLimit);\r\n\t\t\t\t\t\tentry.setProperty(UserDB.Entry.TIME_USED, timeUsed);\r\n\t\t\t\t\t\tfor(i=0;i<rights.length;i++)\r\n\t\t\t\t\t\t\tentry.setProperty(rights[i], rightsSet.get(rights[i]));\r\n\t\t            } catch (final Exception e) {\r\n\t\t                Log.logException(e);\r\n\t\t\t\t\t}\r\n                }else{\r\n\t\t\t\t\tprop.put(\"error\", \"1\");\r\n\t\t\t\t}\r\n\t\t\t\tprop.putHTML(\"text_username\", username);\r\n\t\t\t\tprop.put(\"text\", \"2\");\r\n            }//edit user\r\n\t\t\tprop.putHTML(\"username\", username);\r\n        }\r\n\t\t\r\n\t\t//Generate Userlist\r\n        final Iterator<UserDB.Entry> it = sb.userDB.iterator(true);\r\n        int numUsers=0;\r\n        while(it.hasNext()){\r\n            entry = it.next();\r\n            if (entry == null) continue;\r\n            prop.putHTML(\"users_\"+numUsers+\"_user\", entry.getUserName());\r\n            numUsers++;\r\n        }\r\n        prop.put(\"users\", numUsers);\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":47866,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = Switchboard.getSwitchboard();\r\n        UserDB.Entry entry = null;\r\n\r\n        // admin password\r\n        boolean localhostAccess = sb.getConfigBool(\"adminAccountForLocalhost\", false);\r\n        if (post != null && post.containsKey(\"setAdmin\")) {\r\n            localhostAccess = \"localhost\".equals(post.get(\"access\", \"\"));\r\n            final String user = (post == null) ? \"\" : post.get(\"adminuser\", \"\");\r\n            final String pw1  = (post == null) ? \"\" : post.get(\"adminpw1\", \"\");\r\n            final String pw2  = (post == null) ? \"\" : post.get(\"adminpw2\", \"\");\r\n\r\n            // may be overwritten if new password is given\r\n            if (user.length() > 0 && pw1.length() > 3 && pw1.equals(pw2)) {\r\n                // check passed. set account:\r\n                env.setConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, Digest.encodeMD5Hex(Base64Order.standardCoder.encodeString(user + \":\" + pw1)));\r\n                env.setConfig(\"adminAccount\", \"\");\r\n            }\r\n            \r\n            if (localhostAccess) {\r\n                if (sb.crawlStacker.acceptLocalURLs()) {\r\n                    // in this case it is not allowed to use a localhostAccess option\r\n                    prop.put(\"commitIntranetWarning\", 1);\r\n                    localhostAccess = false;\r\n                    sb.setConfig(\"adminAccountForLocalhost\", false);\r\n                } else {\r\n                    sb.setConfig(\"adminAccountForLocalhost\", true);\r\n                    // if an localhost access is configured, check if a local password is given\r\n                    // if not, set a random password\r\n                    if (post != null && env.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").length() == 0) {\r\n                        // make a 'random' password\r\n                        env.setConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"0000\" + Digest.encodeMD5Hex(System.getProperties().toString() + System.currentTimeMillis()));\r\n                        env.setConfig(\"adminAccount\", \"\");\r\n                    }\r\n                }\r\n            } else {\r\n                sb.setConfig(\"adminAccountForLocalhost\", false);\r\n                if (env.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").startsWith(\"0000\")) {\r\n                    // make shure that the user can still use the interface after a random password was set\r\n                    env.setConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\");\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (env.getConfig(HTTPDemon.ADMIN_ACCOUNT_B64MD5, \"\").length() == 0 && !env.getConfigBool(\"adminAccountForLocalhost\", false)) {\r\n            prop.put(\"passwordNotSetWarning\", 1);\r\n        }\r\n        \r\n        prop.put(\"localhost.checked\", (localhostAccess) ? 1 : 0);\r\n        prop.put(\"account.checked\", (localhostAccess) ? 0 : 1);\r\n        prop.put(\"statusPassword\", localhostAccess ? \"0\" : \"1\");\r\n        prop.put(\"defaultUser\", \"admin\");\r\n        \r\n        //default values\r\n        prop.put(\"current_user\", \"newuser\");\r\n        prop.put(\"username\", \"\");\r\n        prop.put(\"firstname\", \"\");\r\n        prop.put(\"lastname\", \"\");\r\n        prop.put(\"address\", \"\");\r\n        prop.put(\"timelimit\", \"\");\r\n        prop.put(\"timeused\", \"\");\r\n        final String[] rightNames = UserDB.Entry.RIGHT_NAMES.split(\",\");\r\n        final String[] rights = UserDB.Entry.RIGHT_TYPES.split(\",\");\r\n        int c = 0;\r\n        for (final String right : rights) {\r\n            prop.put(\"rights_\" + c + \"_name\", right);\r\n            prop.put(\"rights_\" + c +\"_friendlyName\", rightNames[c]);\r\n            prop.put(\"rights_\" + c + \"_set\", \"0\");\r\n            c++;\r\n        }\r\n        prop.put(\"rights\", c);\r\n        \r\n        prop.put(\"users\", \"0\");\r\n        \r\n        if (sb.userDB == null) {\r\n            return prop;\r\n        }\r\n        \r\n        if (post == null) {\r\n            //do nothing\r\n\r\n            //user != current_user\r\n            //user=from userlist\r\n            //current_user = edited user\r\n        } else if (post.containsKey(\"user\") && !\"newuser\".equals(post.get(\"user\"))){\r\n            if (post.containsKey(\"change_user\")) {\r\n                //defaults for newuser are set above                \r\n                entry = sb.userDB.getEntry(post.get(\"user\"));\r\n                // program crashes if a submit with empty username was made on previous mask and the user clicked on the\r\n                // link: \"If you want to manage more Users, return to the user page.\" (parameter \"user\" is empty)\r\n                if (entry != null) {\r\n                    //TODO: set username read-only in html\r\n                    prop.putHTML(\"current_user\", post.get(\"user\"));\r\n                    prop.putHTML(\"username\", post.get(\"user\"));\r\n                    prop.putHTML(\"firstname\", entry.getFirstName());\r\n                    prop.putHTML(\"lastname\", entry.getLastName());\r\n                    prop.putHTML(\"address\", entry.getAddress());\r\n                    prop.put(\"timelimit\", entry.getTimeLimit());\r\n                    prop.put(\"timeused\", entry.getTimeUsed());\r\n                    int count = 0;\r\n                    for (final String right : rights){\r\n                        prop.put(\"rights_\" + count + \"_set\", entry.hasRight(right) ? \"1\" : \"0\");\r\n                        count++;\r\n                    }\r\n                    prop.put(\"rights\", count);\r\n                }\r\n            } else if (post.containsKey(\"delete_user\") && !post.get(\"user\").equals(\"newuser\")){\r\n                sb.userDB.removeEntry(post.get(\"user\"));\r\n            }\r\n        } else if (post.containsKey(\"change\")) { //New User / edit User\r\n            prop.put(\"text\", \"0\");\r\n            prop.put(\"error\", \"0\");\r\n\r\n            final String username = post.get(\"username\");\r\n            final String pw1 = post.get(\"password\");\r\n            final String pw2 = post.get(\"password2\");\r\n\r\n            if (pw1 == null || !pw1.equals(pw2)) {\r\n                prop.put(\"error\", \"2\"); //PW does not match\r\n                return prop;\r\n            }\r\n\r\n            final String firstName = post.get(\"firstname\");\r\n            final String lastName = post.get(\"lastname\");\r\n            final String address = post.get(\"address\");\r\n            final String timeLimit = post.get(\"timelimit\");\r\n            final String timeUsed = post.get(\"timeused\");\r\n            final Map<String, String> rightsSet = new HashMap<String, String>();\r\n\r\n            for(final String right : rights) {\r\n                rightsSet.put(right, post.containsKey(right)&&(post.get(right)).equals(\"on\") ? \"true\" : \"false\");\r\n            }\r\n            \r\n            final Map<String, String> mem = new HashMap<String, String>();\r\n            if( post.get(\"current_user\").equals(\"newuser\")){ //new user\r\n                \r\n                if(!\"\".equals(pw1)){ //change only if set\r\n                    mem.put(UserDB.Entry.MD5ENCODED_USERPWD_STRING, Digest.encodeMD5Hex(username + \":\" + pw1));\r\n                }\r\n\r\n                mem.put(UserDB.Entry.USER_FIRSTNAME, firstName);\r\n                mem.put(UserDB.Entry.USER_LASTNAME, lastName);\r\n                mem.put(UserDB.Entry.USER_ADDRESS, address);\r\n                mem.put(UserDB.Entry.TIME_LIMIT, timeLimit);\r\n                mem.put(UserDB.Entry.TIME_USED, timeUsed);\r\n\r\n                for (final String right : rights) {\r\n                    mem.put(right, rightsSet.get(right));\r\n                }\r\n\r\n                try {\r\n                    entry = sb.userDB.createEntry(username, mem);\r\n                    sb.userDB.addEntry(entry);\r\n                    prop.putHTML(\"text_username\", username);\r\n                    prop.put(\"text\", \"1\");\r\n                } catch (final IllegalArgumentException e) {\r\n                    prop.put(\"error\", \"3\");\r\n                }\r\n                \r\n            } else { //edit user\r\n\r\n                entry = sb.userDB.getEntry(username);\r\n\r\n                if (entry != null) {\r\n                    try{\r\n                        if (!\"\".equals(pw1)) {\r\n                            entry.setProperty(UserDB.Entry.MD5ENCODED_USERPWD_STRING, Digest.encodeMD5Hex(username+\":\"+pw1));\r\n                        }\r\n\r\n                        entry.setProperty(UserDB.Entry.USER_FIRSTNAME, firstName);\r\n                        entry.setProperty(UserDB.Entry.USER_LASTNAME, lastName);\r\n                        entry.setProperty(UserDB.Entry.USER_ADDRESS, address);\r\n                        entry.setProperty(UserDB.Entry.TIME_LIMIT, timeLimit);\r\n                        entry.setProperty(UserDB.Entry.TIME_USED, timeUsed);\r\n\r\n                        for(final String right : rights) {\r\n                            entry.setProperty(right, rightsSet.get(right));\r\n                        }\r\n\r\n                    } catch (final Exception e) {\r\n                        Log.logException(e);\r\n                    }\r\n\r\n                } else {\r\n                    prop.put(\"error\", \"1\");\r\n                }\r\n                prop.putHTML(\"text_username\", username);\r\n                prop.put(\"text\", \"2\");\r\n            }//edit user\r\n            prop.putHTML(\"username\", username);\r\n        }\r\n\t\t\r\n        //Generate Userlist\r\n        final Iterator<UserDB.Entry> it = sb.userDB.iterator(true);\r\n        int numUsers=0;\r\n        while (it.hasNext()) {\r\n            entry = it.next();\r\n            if (entry == null) {\r\n                continue;\r\n            }\r\n            prop.putHTML(\"users_\"+numUsers+\"_user\", entry.getUserName());\r\n            numUsers++;\r\n        }\r\n        prop.put(\"users\", numUsers);\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n        final String skinPath = new File(env.getDataPath(), env.getConfig(\"skinPath\", \"DATA/SKINS\")).toString();\r\n\r\n        // Fallback\r\n        prop.put(\"currentskin\", \"\");\r\n        prop.put(\"status\", \"0\"); // nothing\r\n\r\n        List<String> skinFiles = FileUtils.getDirListing(skinPath, SKIN_FILENAME_FILTER);\r\n        if (skinFiles == null) {\r\n            return prop;\r\n        }\r\n\r\n        if (post != null) {\r\n            String selectedSkin = post.get(\"skin\");\r\n\r\n            if (post.containsKey(\"use_button\") && selectedSkin != null) {\r\n                /* Only change skin if filename is contained in list of filesnames\r\n                 * read from the skin directory. This is very important to prevent\r\n                 * directory traversal attacks!\r\n                 */\r\n                if (skinFiles.contains(selectedSkin)) {\r\n                    changeSkin(sb, skinPath, selectedSkin);\r\n                }\r\n                \r\n            }\r\n\r\n            if (post.containsKey(\"delete_button\")) {\r\n\r\n                /* Only delete file if filename is contained in list of filesname\r\n                 * read from the skin directory. This is very important to prevent\r\n                 * directory traversal attacks!\r\n                 */\r\n                if (skinFiles.contains(selectedSkin)) {\r\n                    final File skinfile = new File(skinPath, selectedSkin);\r\n                    FileUtils.deletedelete(skinfile);\r\n                }\r\n            }\r\n            \r\n            if (post.containsKey(\"install_button\")) {\r\n                // load skin from URL\r\n                final String url = post.get(\"url\");\r\n\r\n                Iterator<String> it;\r\n                try {\r\n                    final DigestURI u = new DigestURI(url);\r\n                    it = FileUtils.strings(u.get(MultiProtocolURI.yacybotUserAgent, 10000));\r\n                } catch (final IOException e) {\r\n                    prop.put(\"status\", \"1\");// unable to get URL\r\n                    prop.put(\"status_url\", url);\r\n                    return prop;\r\n                }\r\n                try {\r\n                    final File skinFile = new File(skinPath, url.substring(url.lastIndexOf('/'), url.length()));\r\n                    final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(skinFile)));\r\n\r\n                    while (it.hasNext()) {\r\n                        bw.write(it.next() + \"\\n\");\r\n                    }\r\n                    bw.close();\r\n                } catch (final IOException e) {\r\n                    prop.put(\"status\", \"2\");// error saving the skin\r\n                    return prop;\r\n                }\r\n                if (post.containsKey(\"use_skin\") && (post.get(\"use_skin\", \"\")).equals(\"on\")) {\r\n                    changeSkin(sb, skinPath, url.substring(url.lastIndexOf('/'), url.length()));\r\n                }\r\n            }\r\n\r\n            if (post.containsKey(\"set_colors\")) {\r\n                if (skinFiles.contains(selectedSkin)) {\r\n                    changeSkin(sb, skinPath, selectedSkin);\r\n                }\r\n                for (Map.Entry<String, String> entry: post.entrySet()) {\r\n                    if (entry.getKey().startsWith(\"color_\")) env.setConfig(entry.getKey(), \"#\" + entry.getValue());\r\n                }\r\n            }\r\n        }\r\n\r\n        // reread skins\r\n        skinFiles = FileUtils.getDirListing(skinPath, SKIN_FILENAME_FILTER);\r\n        Collections.sort(skinFiles);\r\n        int count = 0;\r\n        for (String skinFile : skinFiles) {\r\n            if (skinFile.endsWith(\".css\")) {\r\n                prop.put(\"skinlist_\" + count + \"_file\", skinFile);\r\n                prop.put(\"skinlist_\" + count + \"_name\", skinFile.substring(0, skinFile.length() - 4));\r\n                count++;\r\n            }\r\n        }\r\n        prop.put(\"skinlist\", count);\r\n        prop.putHTML(\"currentskin\", env.getConfig(\"currentSkin\", \"default\"));\r\n        \r\n        // write colors from generic skin\r\n        Iterator<String> i = env.configKeys();\r\n        String key;\r\n        while (i.hasNext()) {\r\n            key = i.next();\r\n            if (key.startsWith(\"color_\")) prop.put(key, env.getConfig(key, \"#000000\").substring(1));\r\n        }\r\n        return prop;\r\n    }","id":47867,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final serverObjects prop = new serverObjects();\r\n        final Switchboard sb = (Switchboard) env;\r\n        final String skinPath = new File(env.getDataPath(), env.getConfig(\"skinPath\", \"DATA/SKINS\")).toString();\r\n\r\n        // Fallback\r\n        prop.put(\"currentskin\", \"\");\r\n        prop.put(\"status\", \"0\"); // nothing\r\n\r\n        List<String> skinFiles = FileUtils.getDirListing(skinPath, SKIN_FILENAME_FILTER);\r\n        if (skinFiles == null) {\r\n            return prop;\r\n        }\r\n\r\n        if (post != null) {\r\n            String selectedSkin = post.get(\"skin\");\r\n\r\n            if (post.containsKey(\"use_button\") && selectedSkin != null) {\r\n                /* Only change skin if filename is contained in list of filesnames\r\n                 * read from the skin directory. This is very important to prevent\r\n                 * directory traversal attacks!\r\n                 */\r\n                if (skinFiles.contains(selectedSkin)) {\r\n                    changeSkin(sb, skinPath, selectedSkin);\r\n                }\r\n                \r\n            }\r\n\r\n            if (post.containsKey(\"delete_button\")) {\r\n\r\n                /* Only delete file if filename is contained in list of filesname\r\n                 * read from the skin directory. This is very important to prevent\r\n                 * directory traversal attacks!\r\n                 */\r\n                if (skinFiles.contains(selectedSkin)) {\r\n                    final File skinfile = new File(skinPath, selectedSkin);\r\n                    FileUtils.deletedelete(skinfile);\r\n                }\r\n            }\r\n            \r\n            if (post.containsKey(\"install_button\")) {\r\n                // load skin from URL\r\n                final String url = post.get(\"url\");\r\n\r\n                final Iterator<String> it;\r\n                try {\r\n                    final DigestURI u = new DigestURI(url);\r\n                    it = FileUtils.strings(u.get(MultiProtocolURI.yacybotUserAgent, 10000));\r\n                } catch (final IOException e) {\r\n                    prop.put(\"status\", \"1\");// unable to get URL\r\n                    prop.put(\"status_url\", url);\r\n                    return prop;\r\n                }\r\n                try {\r\n                    final File skinFile = new File(skinPath, url.substring(url.lastIndexOf('/'), url.length()));\r\n                    final BufferedWriter bw = new BufferedWriter(new PrintWriter(new FileWriter(skinFile)));\r\n\r\n                    while (it.hasNext()) {\r\n                        bw.write(it.next() + \"\\n\");\r\n                    }\r\n                    \r\n                    bw.close();\r\n                } catch (final IOException e) {\r\n                    prop.put(\"status\", \"2\");// error saving the skin\r\n                    return prop;\r\n                }\r\n                if (post.containsKey(\"use_skin\") && \"on\".equals(post.get(\"use_skin\", \"\"))) {\r\n                    changeSkin(sb, skinPath, url.substring(url.lastIndexOf('/'), url.length()));\r\n                }\r\n            }\r\n\r\n            if (post.containsKey(\"set_colors\")) {\r\n                if (skinFiles.contains(selectedSkin)) {\r\n                    changeSkin(sb, skinPath, selectedSkin);\r\n                }\r\n                for (final Map.Entry<String, String> entry: post.entrySet()) {\r\n                    if (entry.getKey().startsWith(\"color_\")) {\r\n                        env.setConfig(entry.getKey(), \"#\" + entry.getValue());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // reread skins\r\n        skinFiles = FileUtils.getDirListing(skinPath, SKIN_FILENAME_FILTER);\r\n        Collections.sort(skinFiles);\r\n        int count = 0;\r\n        for (final String skinFile : skinFiles) {\r\n            if (skinFile.endsWith(\".css\")) {\r\n                prop.put(\"skinlist_\" + count + \"_file\", skinFile);\r\n                prop.put(\"skinlist_\" + count + \"_name\", skinFile.substring(0, skinFile.length() - 4));\r\n                count++;\r\n            }\r\n        }\r\n        prop.put(\"skinlist\", count);\r\n        prop.putHTML(\"currentskin\", env.getConfig(\"currentSkin\", \"default\"));\r\n        \r\n        // write colors from generic skin\r\n        Iterator<String> i = env.configKeys();\r\n        while (i.hasNext()) {\r\n            final String key = i.next();\r\n            if (key.startsWith(\"color_\")) prop.put(key, env.getConfig(key, \"#000000\").substring(1));\r\n        }\r\n        return prop;\r\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static void publishNews(final String url, final String title, final String description, final String tagsString) {\n    \t// create a news message\n    \tfinal HashMap<String, String> map = new HashMap<String, String>(8);\n    \tmap.put(\"url\", url.replace(',', '|'));\n    \tmap.put(\"title\", title.replace(',', ' '));\n    \tmap.put(\"description\", description.replace(',', ' '));\n    \tmap.put(\"tags\", tagsString.replace(',', ' '));\n    \tsb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_BOOKMARK_ADD, map);\n    }","id":47868,"modified_method":"private static void publishNews(final String url, final String title, final String description, final String tagsString) {\n    \t// create a news message\n    \tfinal Map<String, String> map = new HashMap<String, String>(8);\n    \tmap.put(\"url\", url.replace(',', '|'));\n    \tmap.put(\"title\", title.replace(',', ' '));\n    \tmap.put(\"description\", description.replace(',', ' '));\n    \tmap.put(\"tags\", tagsString.replace(',', ' '));\n    \tsb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_BOOKMARK_ADD, map);\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        \n        sb = (Switchboard) env;       \n        isAdmin=sb.verifyAuthentication(header, true);\n        user = sb.userDB.getUser(header);\n        \n        // set user name\n        String username=\"\";        \n        if(user != null) username=user.getUserName();\n    \telse if(isAdmin) username=\"admin\";\n        \n        if(post!= null){\n    \t\tif(!isAdmin){\n    \t\t\t// force authentication if desired\n        \t\t\tif(post.containsKey(\"login\")){\n        \t\t\t\tprop.put(\"AUTHENTICATE\",\"admin log-in\");\n        \t\t\t}\n        \t\t\treturn prop;\n    \t\t} \n    \t\tfinal String url=post.get(\"url\",\"\");\n\t\t\tfinal String title=post.get(\"title\",url);\n\t\t\tfinal String description=post.get(\"description\",\"\");\n\t\t\tString tagsString = post.get(\"tags\",\"\");\n\t\t\tString pathString = post.get(\"path\",\"/unsorted\");\n\t\t\ttagsString=tagsString+\",\"+pathString;\n\t\t\tfinal Set<String> tags=ListManager.string2set(BookmarkHelper.cleanTagsString(tagsString));\n\t\t\tfinal BookmarksDB.Bookmark bookmark = sb.bookmarksDB.createBookmark(url, username);\n\t\t\tif(bookmark != null){\n\t\t\t\tbookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n\t\t\t\tbookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n\t\t\t\tif(user!=null){ \n\t\t\t\t\tbookmark.setOwner(user.getUserName());\n\t\t\t\t}\n\t\t\t\tif((post.get(\"public\")).equals(\"public\")){\n\t\t\t\t\tbookmark.setPublic(true);\n\t\t\t\t\tpublishNews(url, title, description, tagsString);\n\t\t\t\t}else{\n\t\t\t\t\tbookmark.setPublic(false);\n\t\t\t\t}\n\t\t\t\tif(post.containsKey(\"feed\") && (post.get(\"feed\")).equals(\"feed\")){\n\t\t\t\t\tbookmark.setFeed(true);\n\t\t\t\t}else{\n\t\t\t\t\tbookmark.setFeed(false);\n\t\t\t\t}\n\t\t\t\tbookmark.setTags(tags, true);\n\t\t\t\tsb.bookmarksDB.saveBookmark(bookmark);\n\t\t\t\tprop.put(\"result\", \"1\");\n\t\t\t} else {\n\t\t\t\t// ERROR\n\t\t\t\tprop.put(\"result\", \"0\");\n\t\t\t}\n        }\n        // return rewrite properties\n        return prop;\n    }","id":47869,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        \n        sb = (Switchboard) env;       \n        isAdmin=sb.verifyAuthentication(header, true);\n        user = sb.userDB.getUser(header);\n        \n        // set user name\n        String username=\"\";        \n        if(user != null) username=user.getUserName();\n    \telse if(isAdmin) username=\"admin\";\n        \n        if (post != null) {\n            if (!isAdmin) {\n            // force authentication if desired\n                if(post.containsKey(\"login\")){\n                    prop.put(\"AUTHENTICATE\",\"admin log-in\");\n                }\n                return prop;\n            }\n            final String url=post.get(\"url\",\"\");\n            final String title=post.get(\"title\",url);\n            final String description=post.get(\"description\",\"\");\n            String tagsString = post.get(\"tags\",\"\");\n            String pathString = post.get(\"path\",\"/unsorted\");\n            tagsString= tagsString + \",\" + pathString;\n            final Set<String> tags = ListManager.string2set(BookmarkHelper.cleanTagsString(tagsString));\n            final BookmarksDB.Bookmark bookmark = sb.bookmarksDB.createBookmark(url, username);\n            if(bookmark != null){\n                bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n                bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n                if(user!=null){\n                    bookmark.setOwner(user.getUserName());\n                }\n                if(\"public\".equals(post.get(\"public\"))){\n                    bookmark.setPublic(true);\n                    publishNews(url, title, description, tagsString);\n                }else{\n                    bookmark.setPublic(false);\n                }\n                if(post.containsKey(\"feed\") && \"feed\".equals(post.get(\"feed\"))){\n                    bookmark.setFeed(true);\n                }else{\n                    bookmark.setFeed(false);\n                }\n                bookmark.setTags(tags, true);\n                sb.bookmarksDB.saveBookmark(bookmark);\n                prop.put(\"result\", \"1\");\n            } else {\n                // ERROR\n                prop.put(\"result\", \"0\");\n            }\n        }\n        // return rewrite properties\n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final serverObjects prop = new serverObjects();\n\n        ListManager.listsPath = new File(ListManager.switchboard.getDataPath(),ListManager.switchboard.getConfig(\"listManager.listsPath\", \"DATA/LISTS\"));\n        final List<String> dirlist = FileUtils.getDirListing(ListManager.listsPath);\n        int blacklistCount=0;\n\n        final String blackListName = (post == null) ? \"\" : post.get(\"listname\", \"\");\n        \n        List<String> list;\n        int count;\n        if (dirlist != null) {\n            for (String element : dirlist) {\n                if (blackListName.equals(\"\") || element.equals(blackListName)) {\n                    prop.putXML(\"lists_\" + blacklistCount + \"_name\", element);\n\n                    if (ListManager.listSetContains(\"BlackLists.Shared\", element)) {\n\n                        list = FileUtils.getListArray(new File(ListManager.listsPath, element));\n\n                        count=0;\n                        for (int j=0;j<list.size();++j){\n                            final String nextEntry = list.get(j);\n\n                            if (nextEntry.length() == 0) continue;\n                            if (nextEntry.charAt(0) == '#') continue;\n\n                            prop.putXML(\"lists_\" + blacklistCount + \"_items_\" + count + \"_item\", nextEntry);\n                            count++;\n                        }\n                        prop.put(\"lists_\" + blacklistCount + \"_items\", count);\n                        blacklistCount++;\n                    }\n                }\n            }\n        }\n        prop.put(\"lists\", blacklistCount);\n\n        // return rewrite properties\n        return prop;\n    }","id":47870,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final serverObjects prop = new serverObjects();\n\n        ListManager.listsPath = new File(ListManager.switchboard.getDataPath(),ListManager.switchboard.getConfig(\"listManager.listsPath\", \"DATA/LISTS\"));\n        final List<String> dirlist = FileUtils.getDirListing(ListManager.listsPath);\n        int blacklistCount = 0;\n\n        final String blackListName = (post == null) ? \"\" : post.get(\"listname\", \"\");\n        \n        if (dirlist != null) {\n            for (final String element : dirlist) {\n                if (\"\".equals(blackListName) || element.equals(blackListName)) {\n                    prop.putXML(\"lists_\" + blacklistCount + \"_name\", element);\n\n                    if (ListManager.listSetContains(\"BlackLists.Shared\", element)) {\n\n                        final List<String> list = FileUtils.getListArray(new File(ListManager.listsPath, element));\n\n                        int count=0;\n                        for (final String entry : list){\n\n                            if (entry.length() == 0) {\n                                continue;\n                            }\n                            if (entry.charAt(0) == '#') {\n                                continue;\n                            }\n\n                            prop.putXML(\"lists_\" + blacklistCount + \"_items_\" + count + \"_item\", entry);\n                            count++;\n                        }\n                        prop.put(\"lists_\" + blacklistCount + \"_items\", count);\n                        blacklistCount++;\n                    }\n                }\n            }\n        }\n        prop.put(\"lists\", blacklistCount);\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final serverObjects prop = new serverObjects();\n        \n        ListManager.listsPath = new File(ListManager.switchboard.getDataPath(),ListManager.switchboard.getConfig(\"listManager.listsPath\", \"DATA/LISTS\"));\n        final List<String> dirlist = FileUtils.getDirListing(ListManager.listsPath);\n        int blacklistCount=0;\n\n        final String blackListName = (post == null) ? \"\" : post.get(\"listname\", \"\");\n        final String attrOnly = (post == null) ? \"\" : post.get(\"attrOnly\", \"\");\n\n        List<String> list;\n        int count;\n        if (dirlist != null) {\n            for (String element : dirlist) {\n                if (blackListName.equals(\"\") || element.equals(blackListName)) {\n                    prop.putXML(\"lists_\" + blacklistCount + \"_name\", element);\n\n                    if (ListManager.listSetContains(\"BlackLists.Shared\", element)) {\n                        prop.put(\"lists_\" + blacklistCount + \"_shared\", \"1\");\n                    } else {\n                        prop.put(\"lists_\" + blacklistCount + \"_shared\", \"0\");\n                    }\n\n                    final String[] types = Blacklist.BLACKLIST_TYPES_STRING.split(\",\");\n                    for (int j=0; j<types.length; j++) {\n                        prop.putXML(\"lists_\" + blacklistCount + \"_types_\" + j + \"_name\", types[j]);\n                        prop.put(\"lists_\" + blacklistCount + \"_types_\" + j + \"_value\",\n                                ListManager.listSetContains(types[j] + \".BlackLists\", element) ? 1 : 0);\n                    }\n                    prop.put(\"lists_\" + blacklistCount + \"_types\", types.length);\n\n                    if ( ! (attrOnly.equals(\"1\") || attrOnly.equals(\"true\"))) {\n                \tlist = FileUtils.getListArray(new File(ListManager.listsPath, element));\n\n                \tcount=0;\n                \tfor (int j=0;j<list.size();++j){\n                \t    final String nextEntry = list.get(j);\n\n                \t    if (nextEntry.length() == 0) continue;\n                \t    if (nextEntry.charAt(0) == '#') continue;\n\n                \t    prop.putXML(\"lists_\" + blacklistCount + \"_items_\" + count + \"_item\", nextEntry);\n                \t    count++;\n                \t}\n                \tprop.put(\"lists_\" + blacklistCount + \"_items\", count);\n                    }\n                    blacklistCount++;\n                }\n            }\n        }\n        prop.put(\"lists\", blacklistCount);\n        \n        \n        // return rewrite properties\n        return prop;\n    }","id":47871,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final serverObjects prop = new serverObjects();\n        \n        ListManager.listsPath = new File(ListManager.switchboard.getDataPath(),ListManager.switchboard.getConfig(\"listManager.listsPath\", \"DATA/LISTS\"));\n        final List<String> dirlist = FileUtils.getDirListing(ListManager.listsPath);\n        int blacklistCount=0;\n\n        final String blackListName = (post == null) ? \"\" : post.get(\"listname\", \"\");\n        final String attrOnly = (post == null) ? \"\" : post.get(\"attrOnly\", \"\");\n\n        int count;\n        if (dirlist != null) {\n            for (final String element : dirlist) {\n                if (\"\".equals(blackListName) || element.equals(blackListName)) {\n                    prop.putXML(\"lists_\" + blacklistCount + \"_name\", element);\n\n                    if (ListManager.listSetContains(\"BlackLists.Shared\", element)) {\n                        prop.put(\"lists_\" + blacklistCount + \"_shared\", \"1\");\n                    } else {\n                        prop.put(\"lists_\" + blacklistCount + \"_shared\", \"0\");\n                    }\n\n                    final String[] types = Blacklist.BLACKLIST_TYPES_STRING.split(\",\");\n                    int j = 0;\n                    for (final String type : types) {\n                        prop.putXML(\"lists_\" + blacklistCount + \"_types_\" + j + \"_name\", type);\n                        prop.put(\"lists_\" + blacklistCount + \"_types_\" + j + \"_value\",\n                                ListManager.listSetContains(type + \".BlackLists\", element) ? 1 : 0);\n                        j++;\n                    }\n                    prop.put(\"lists_\" + blacklistCount + \"_types\", types.length);\n\n                    if (!\"1\".equals(attrOnly) && !\"true\".equals(attrOnly)) {\n                \tfinal List<String> list = FileUtils.getListArray(new File(ListManager.listsPath, element));\n\n                \tcount=0;\n                \tfor (final String entry : list){\n                \t    if (entry.length() == 0) continue;\n                \t    if (entry.charAt(0) == '#') continue;\n\n                \t    prop.putXML(\"lists_\" + blacklistCount + \"_items_\" + count + \"_item\", entry);\n                \t    count++;\n                \t}\n                \tprop.put(\"lists_\" + blacklistCount + \"_items\", count);\n                    }\n                    blacklistCount++;\n                }\n            }\n        }\n        prop.put(\"lists\", blacklistCount);\n        \n        \n        // return rewrite properties\n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        //plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\n        final serverObjects prop = new serverObjects();\n        String key; \n        \n        //change a Key\n        if(post != null && post.containsKey(\"key\") && post.containsKey(\"value\")){\n            key=post.get(\"key\");\n            final String value=post.get(\"value\");\n            if(!key.equals(\"\")){\n                env.setConfig(key, value);\n            }\n        }\n        \n        Iterator<String> keys = env.configKeys();\n        \n        final List<String> list = new ArrayList<String>(250);\n        while(keys.hasNext()){\n            list.add(keys.next());\n        }\n        Collections.sort(list);\n        keys = list.iterator();\n        \n        int count=0;\n        while(keys.hasNext()){\n            key = keys.next();\n            prop.putHTML(\"options_\"+count+\"_key\", key);\n            prop.putHTML(\"options_\"+count+\"_value\", env.getConfig(key, \"ERROR\"));\n            count++;        \n        }\n        prop.put(\"options\", count);\n        \n        // return rewrite properties\n        return prop;\n    }","id":47872,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        //plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\n        final serverObjects prop = new serverObjects();\n        \n        //change a Key\n        if(post != null && post.containsKey(\"key\") && post.containsKey(\"value\")) {\n            final String key = post.get(\"key\");\n            final String value = post.get(\"value\");\n            if(!\"\".equals(key)) {\n                env.setConfig(key, value);\n            }\n        }\n        \n        final Iterator<String> keys = env.configKeys();\n        \n        final List<String> list = new ArrayList<String>(250);\n\n        while (keys.hasNext()) {\n            list.add(keys.next());\n        }\n\n        Collections.sort(list);\n        \n        int count=0;\n        \n        for (final String key : list) {\n            prop.putHTML(\"options_\" + count + \"_key\", key);\n            prop.putHTML(\"options_\" + count + \"_value\", env.getConfig(key, \"ERROR\"));\n            count++;        \n        }\n        prop.put(\"options\", count);\n        \n        // return rewrite properties\n        return prop;\n    }","commit_id":"dad5818b40393a3c6c81759a3ff58df9021376b1","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected Map<String, AggregationBuilder> getFacets(RuleQuery query, QueryContext options, QueryBuilder queryBuilder, Map<String, FilterBuilder> filters) {\n    Map<String, AggregationBuilder> aggregations = new HashMap<String, AggregationBuilder>();\n\n    StickyFacetBuilder stickyFacetBuilder = stickyFacetBuilder(queryBuilder, filters);\n    if (options.facets().contains(\"languages\") || options.facets().contains(\"true\")) {\n      aggregations.put(FACET_LANGUAGES, // + \"global\",\n        stickyFacetBuilder.buildStickyFacet(RuleNormalizer.RuleField.LANGUAGE.field(), FACET_LANGUAGES, query.getLanguages() == null ? new String[0] : query.getLanguages().toArray()));\n    }\n    if (options.facets().contains(\"tags\") || options.facets().contains(\"true\")) {\n      aggregations.put(FACET_TAGS, // + \"global\",\n        stickyFacetBuilder.buildStickyFacet(RuleNormalizer.RuleField.ALL_TAGS.field(), FACET_TAGS, query.getTags() == null ? new String[0] : query.getTags().toArray()));\n    }\n    if (options.facets().contains(\"repositories\") || options.facets().contains(\"true\")) {\n      aggregations.put(FACET_REPOSITORIES, // + \"global\",\n        stickyFacetBuilder.buildStickyFacet(RuleNormalizer.RuleField.REPOSITORY.field(), FACET_REPOSITORIES, query.getRepositories() == null ? new String[0] : query.getRepositories().toArray()));\n    }\n\n    return aggregations;\n\n  }","id":47873,"modified_method":"protected Map<String, AggregationBuilder> getFacets(RuleQuery query, QueryContext options, QueryBuilder queryBuilder, Map<String, FilterBuilder> filters) {\n    Map<String, AggregationBuilder> aggregations = new HashMap<String, AggregationBuilder>();\n\n    StickyFacetBuilder stickyFacetBuilder = stickyFacetBuilder(queryBuilder, filters);\n    if (options.facets().contains(\"languages\") || options.facets().contains(\"true\")) {\n      Collection<String> languages = query.getLanguages();\n      aggregations.put(FACET_LANGUAGES,\n        stickyFacetBuilder.buildStickyFacet(RuleNormalizer.RuleField.LANGUAGE.field(), FACET_LANGUAGES,\n          languages == null ? new String[0] : languages.toArray()));\n    }\n    if (options.facets().contains(\"tags\") || options.facets().contains(\"true\")) {\n      Collection<String> tags = query.getTags();\n      aggregations.put(FACET_TAGS,\n        stickyFacetBuilder.buildStickyFacet(RuleNormalizer.RuleField.ALL_TAGS.field(), FACET_TAGS,\n          tags == null ? new String[0] : tags.toArray()));\n    }\n    if (options.facets().contains(\"repositories\") || options.facets().contains(\"true\")) {\n      Collection<String> repositories = query.getRepositories();\n      aggregations.put(FACET_REPOSITORIES,\n        stickyFacetBuilder.buildStickyFacet(RuleNormalizer.RuleField.REPOSITORY.field(), FACET_REPOSITORIES,\n          repositories == null ? new String[0] : repositories.toArray()));\n    }\n\n\n    return aggregations;\n\n  }","commit_id":"59e044daf2c6427b225f91444c34a7a0d6ef8702","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  @CheckForNull\n  protected Collection<String> possibleFacets() {\n    return Arrays.asList(new String[] {\n      \"languages\",\n      \"repositories\",\n      \"tags\",\n      \"characteristics\",\n      \"severities\",\n      \"statuses\",\n      \"true\"\n    });\n  }","id":47874,"modified_method":"@Override\n  @CheckForNull\n  protected Collection<String> possibleFacets() {\n    return Arrays.asList(new String[] {\n      PARAM_LANGUAGES,\n      PARAM_REPOSITORIES,\n      \"tags\",\n      \"characteristics\",\n      \"severities\",\n      \"statuses\",\n      \"true\"\n    });\n  }","commit_id":"59e044daf2c6427b225f91444c34a7a0d6ef8702","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void updateDefinition(Bus bus,\n                                    Definition def,\n                                    Map<String, Definition> done,\n                                    Map<String, SchemaReference> doneSchemas,\n                                    String base,\n                                    String docBase) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n\n        Collection<List<?>> imports = CastUtils.cast((Collection<?>)def.getImports().values());\n        for (List<?> lst : imports) {\n            List<Import> impLst = CastUtils.cast(lst);\n            for (Import imp : impLst) {\n                String start = imp.getLocationURI();\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        try {\n                            start = getLocationURI(start, docBase);\n                            decodedStart = URLDecoder.decode(start, \"utf-8\");\n                        } catch (Exception e1) {\n                            //ignore\n                        }\n                        if (done.put(decodedStart, imp.getDefinition()) == null) {\n                            updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                        }\n                    }\n                } else {\n                    if (done.put(decodedStart, imp.getDefinition()) == null) {\n                        done.put(resolvedSchemaLocation, imp.getDefinition());\n                        updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                    }\n                }\n            }\n        }\n\n\n        /* This doesn't actually work.   Setting setSchemaLocationURI on the import\n        * for some reason doesn't actually result in the new URI being written\n        * */\n        Types types = def.getTypes();\n        if (types != null) {\n            for (ExtensibilityElement el\n                : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {\n                if (el instanceof Schema) {\n                    Schema see = (Schema)el;\n                    updateSchemaImports(bus, see, see.getDocumentBaseURI(), doneSchemas, base, null);\n                }\n            }\n        }\n    }","id":47875,"modified_method":"protected void updateDefinition(Bus bus,\n                                    Definition def,\n                                    Map<String, Definition> done,\n                                    Map<String, SchemaReference> doneSchemas,\n                                    String base,\n                                    String docBase) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n\n        Collection<List<?>> imports = CastUtils.cast((Collection<?>)def.getImports().values());\n        for (List<?> lst : imports) {\n            List<Import> impLst = CastUtils.cast(lst);\n            for (Import imp : impLst) {\n                String start = imp.getLocationURI();\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        try {\n                            start = getLocationURI(start, docBase);\n                            decodedStart = URLDecoder.decode(start, \"utf-8\");\n                        } catch (Exception e1) {\n                            //ignore\n                        }\n                        if (done.put(decodedStart, imp.getDefinition()) == null) {\n                            updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                        }\n                    }\n                } else {\n                    if (done.put(decodedStart, imp.getDefinition()) == null) {\n                        done.put(resolvedSchemaLocation, imp.getDefinition());\n                        updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                    }\n                }\n            }\n        }\n\n\n        /* This doesn't actually work.   Setting setSchemaLocationURI on the import\n        * for some reason doesn't actually result in the new URI being written\n        * */\n        Types types = def.getTypes();\n        if (types != null) {\n            for (ExtensibilityElement el\n                : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {\n                if (el instanceof Schema) {\n                    Schema see = (Schema)el;\n                    updateSchemaImports(bus, see, see.getDocumentBaseURI(), doneSchemas, base);\n                }\n            }\n        }\n    }","commit_id":"36b432c8a47b411d9a408d0adffeb780ebe3116a","url":"https://github.com/apache/cxf"},{"original_method":"protected String mapUri(String base, Map<String, SchemaReference> smp, String loc, String xsd)\n        throws UnsupportedEncodingException {\n        String key = loc;\n        try {\n            boolean absoluteLocUri = new URI(loc).isAbsolute();\n            if (!absoluteLocUri && xsd != null) {\n                key = new URI(xsd).resolve(loc).toString();\n            }\n            if (!absoluteLocUri && xsd == null) {\n                key = new URI(\".\").resolve(loc).toString();\n            }\n        } catch (URISyntaxException e) {\n           //ignore\n        }\n        SchemaReference ref = smp.get(URLDecoder.decode(key, \"utf-8\"));\n        if (ref != null) {\n            return base + \"?xsd=\" + key.replace(\" \", \"%20\");\n        }\n        return null;\n    }","id":47876,"modified_method":"protected String mapUri(Bus bus, String base, Map<String, SchemaReference> smp, String loc, String xsd)\n        throws UnsupportedEncodingException {\n        String key = loc;\n        try {\n            boolean absoluteLocUri = new URI(loc).isAbsolute();\n            if (!absoluteLocUri && xsd != null) { // XSD request\n                // resolve requested location with relative import path\n                key = new URI(xsd).resolve(loc).toString();\n\n                if (!smp.containsKey(URLDecoder.decode(key, \"utf-8\"))) {\n                    // if the result is not known, check if we can resolve it into something known\n                    String resolved = resolveWithCatalogs(OASISCatalogManager.getCatalogManager(bus), key, base);\n                    if (smp.containsKey(URLDecoder.decode(resolved, \"utf-8\"))) {\n                        // if it is resolvable, we can use it\n                        return base + \"?xsd=\" + key.replace(\" \", \"%20\");\n                    }\n                }\n            } else if (!absoluteLocUri && xsd == null) { // WSDL request\n                key = new URI(\".\").resolve(loc).toString();\n            }\n        } catch (URISyntaxException e) {\n           //ignore\n        }\n        SchemaReference ref = smp.get(URLDecoder.decode(key, \"utf-8\"));\n        if (ref != null) {\n            return base + \"?xsd=\" + key.replace(\" \", \"%20\");\n        }\n        return null;\n    }","commit_id":"36b432c8a47b411d9a408d0adffeb780ebe3116a","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateDoc(Document doc,\n                             String base,\n                             Map<String, Definition> mp,\n                             Map<String, SchemaReference> smp,\n                             Message message,\n                             String xsd,\n                             String wsdl) {\n        List<Element> elementList = null;\n\n        try {\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://www.w3.org/2001/XMLSchema\", \"import\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"schemaLocation\");\n                sl = mapUri(base, smp, sl, xsd);\n                if (sl != null) {\n                    el.setAttribute(\"schemaLocation\", sl);\n                }\n            }\n\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://www.w3.org/2001/XMLSchema\",\n                                                              \"include\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"schemaLocation\");\n                sl = mapUri(base, smp, sl, xsd);\n                if (sl != null) {\n                    el.setAttribute(\"schemaLocation\", sl);\n                }\n            }\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://www.w3.org/2001/XMLSchema\",\n                                                              \"redefine\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"schemaLocation\");\n                sl = mapUri(base, smp, sl, xsd);\n                if (sl != null) {\n                    el.setAttribute(\"schemaLocation\", sl);\n                }\n            }\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://schemas.xmlsoap.org/wsdl/\",\n                                                              \"import\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"location\");\n                try {\n                    sl = getLocationURI(sl, wsdl);\n                } catch (URISyntaxException e) {\n                    //ignore\n                }\n                if (mp.containsKey(URLDecoder.decode(sl, \"utf-8\"))) {\n                    el.setAttribute(\"location\", base + \"?wsdl=\" + sl.replace(\" \", \"%20\"));\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new WSDLQueryException(new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                    LOG,\n                    base), e);\n        }\n\n        boolean rewriteAllSoapAddress = MessageUtils.isTrue(message.getContextualProperty(AUTO_REWRITE_ADDRESS_ALL));\n        if (rewriteAllSoapAddress) {\n            List<Element> portList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                                         \"http://schemas.xmlsoap.org/wsdl/\",\n                                                                         \"port\");\n            String basePath = (String) message.get(\"http.base.path\");\n            for (Element el : portList) {\n                rewriteAddressProtocolHostPort(base, el, basePath, \"http://schemas.xmlsoap.org/wsdl/soap/\");\n                rewriteAddressProtocolHostPort(base, el, basePath, \"http://schemas.xmlsoap.org/wsdl/soap12/\");\n            }\n        }\n        Object rewriteSoapAddress = message.getContextualProperty(AUTO_REWRITE_ADDRESS);\n        if (rewriteSoapAddress == null || MessageUtils.isTrue(rewriteSoapAddress) || rewriteAllSoapAddress) {\n            List<Element> serviceList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://schemas.xmlsoap.org/wsdl/\",\n                                                              \"service\");\n            for (Element serviceEl : serviceList) {\n                String serviceName = serviceEl.getAttribute(\"name\");\n                if (serviceName.equals(message.getExchange().getService().getName().getLocalPart())) {\n                    elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                                      \"http://schemas.xmlsoap.org/wsdl/\",\n                                                                      \"port\");\n                    for (Element el : elementList) {\n                        String name = el.getAttribute(\"name\");\n                        if (name.equals(message.getExchange().getEndpoint().getEndpointInfo()\n                                            .getName().getLocalPart())) {\n                            rewriteAddress(base, el, \"http://schemas.xmlsoap.org/wsdl/soap/\");\n                            rewriteAddress(base, el, \"http://schemas.xmlsoap.org/wsdl/soap12/\");\n                        }\n                    }\n                }\n            }\n        }\n        try {\n            doc.setXmlStandalone(true);\n        } catch (Exception ex) {\n            //likely not DOM level 3\n        }\n    }","id":47877,"modified_method":"protected void updateDoc(Document doc,\n                             String base,\n                             Map<String, Definition> mp,\n                             Map<String, SchemaReference> smp,\n                             Message message,\n                             String xsd,\n                             String wsdl) {\n        Bus bus = message.getExchange().getBus();\n        List<Element> elementList = null;\n\n        try {\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://www.w3.org/2001/XMLSchema\", \"import\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"schemaLocation\");\n                sl = mapUri(bus, base, smp, sl, xsd);\n                if (sl != null) {\n                    el.setAttribute(\"schemaLocation\", sl);\n                }\n            }\n\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://www.w3.org/2001/XMLSchema\",\n                                                              \"include\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"schemaLocation\");\n                sl = mapUri(bus, base, smp, sl, xsd);\n                if (sl != null) {\n                    el.setAttribute(\"schemaLocation\", sl);\n                }\n            }\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://www.w3.org/2001/XMLSchema\",\n                                                              \"redefine\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"schemaLocation\");\n                sl = mapUri(bus, base, smp, sl, xsd);\n                if (sl != null) {\n                    el.setAttribute(\"schemaLocation\", sl);\n                }\n            }\n            elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://schemas.xmlsoap.org/wsdl/\",\n                                                              \"import\");\n            for (Element el : elementList) {\n                String sl = el.getAttribute(\"location\");\n                try {\n                    sl = getLocationURI(sl, wsdl);\n                } catch (URISyntaxException e) {\n                    //ignore\n                }\n                if (mp.containsKey(URLDecoder.decode(sl, \"utf-8\"))) {\n                    el.setAttribute(\"location\", base + \"?wsdl=\" + sl.replace(\" \", \"%20\"));\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new WSDLQueryException(new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                    LOG,\n                    base), e);\n        }\n\n        boolean rewriteAllSoapAddress = MessageUtils.isTrue(message.getContextualProperty(AUTO_REWRITE_ADDRESS_ALL));\n        if (rewriteAllSoapAddress) {\n            List<Element> portList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                                         \"http://schemas.xmlsoap.org/wsdl/\",\n                                                                         \"port\");\n            String basePath = (String) message.get(\"http.base.path\");\n            for (Element el : portList) {\n                rewriteAddressProtocolHostPort(base, el, basePath, \"http://schemas.xmlsoap.org/wsdl/soap/\");\n                rewriteAddressProtocolHostPort(base, el, basePath, \"http://schemas.xmlsoap.org/wsdl/soap12/\");\n            }\n        }\n        Object rewriteSoapAddress = message.getContextualProperty(AUTO_REWRITE_ADDRESS);\n        if (rewriteSoapAddress == null || MessageUtils.isTrue(rewriteSoapAddress) || rewriteAllSoapAddress) {\n            List<Element> serviceList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                              \"http://schemas.xmlsoap.org/wsdl/\",\n                                                              \"service\");\n            for (Element serviceEl : serviceList) {\n                String serviceName = serviceEl.getAttribute(\"name\");\n                if (serviceName.equals(message.getExchange().getService().getName().getLocalPart())) {\n                    elementList = DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n                                                                      \"http://schemas.xmlsoap.org/wsdl/\",\n                                                                      \"port\");\n                    for (Element el : elementList) {\n                        String name = el.getAttribute(\"name\");\n                        if (name.equals(message.getExchange().getEndpoint().getEndpointInfo()\n                                            .getName().getLocalPart())) {\n                            rewriteAddress(base, el, \"http://schemas.xmlsoap.org/wsdl/soap/\");\n                            rewriteAddress(base, el, \"http://schemas.xmlsoap.org/wsdl/soap12/\");\n                        }\n                    }\n                }\n            }\n        }\n        try {\n            doc.setXmlStandalone(true);\n        } catch (Exception ex) {\n            //likely not DOM level 3\n        }\n    }","commit_id":"36b432c8a47b411d9a408d0adffeb780ebe3116a","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateSchemaImports(Bus bus,\n                                       Schema schema,\n                                       String docBase,\n                                       Map<String, SchemaReference> doneSchemas,\n                                       String base,\n                                       String parent) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n        Collection<List<?>>  imports = CastUtils.cast((Collection<?>)schema.getImports().values());\n        for (List<?> lst : imports) {\n            List<SchemaImport> impLst = CastUtils.cast(lst);\n            for (SchemaImport imp : impLst) {\n                String start = findSchemaLocation(doneSchemas, imp, docBase);\n\n                if (start != null) {\n                    String decodedStart = null;\n                    // Always use the URL decoded version to ensure that we have a\n                    // canonical representation of the import URL for lookup.\n                    try {\n                        decodedStart = URLDecoder.decode(start, \"utf-8\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new WSDLQueryException(\n                            new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                                LOG,\n                                start), e);\n                    }\n\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                        if (resolvedSchemaLocation == null) {\n                            resolvedSchemaLocation = resolveWithCatalogs(catalogs, imp.getSchemaLocationURI(), base);\n                        }                        \n                        if (resolvedSchemaLocation == null) {\n                            try {\n                                //check to see if it's already in a URL format.  If so, leave it.\n                                new URL(start);\n                            } catch (MalformedURLException e) {\n                                if (doneSchemas.put(decodedStart, imp) == null) {\n                                    try {\n                                        //CHECKSTYLE:OFF:NestedIfDepth\n                                        if (!(new URI(decodedStart).isAbsolute()) && parent != null) {\n                                            resolvedSchemaLocation = new URI(parent).resolve(decodedStart).toString();\n                                            decodedStart = URLDecoder.decode(resolvedSchemaLocation, \"utf-8\");\n                                            doneSchemas.put(resolvedSchemaLocation, imp);\n                                        }\n                                        //CHECKSTYLE:ON:NestedIfDepth \n                                    } catch (URISyntaxException ex) {\n                                        // ignore\n                                    } catch (UnsupportedEncodingException ex) {\n                                        // ignore\n                                    }\n                                    updateSchemaImports(bus, imp.getReferencedSchema(), docBase,\n                                                        doneSchemas, base, decodedStart);\n                                }\n                            }\n                        } else {\n                            if (doneSchemas.put(decodedStart, imp) == null) {\n                                doneSchemas.put(resolvedSchemaLocation, imp);\n                                doneSchemas.put(imp.getSchemaLocationURI(), imp);\n                                updateSchemaImports(bus, imp.getReferencedSchema(), docBase,\n                                                    doneSchemas, base, decodedStart);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        List<SchemaReference> includes = CastUtils.cast(schema.getIncludes());\n        for (SchemaReference included : includes) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                updateSchemaImports(bus, included.getReferencedSchema(), \n                                                    docBase, doneSchemas, base, decodedStart);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base, decodedStart);\n                }\n            }\n        }\n        List<SchemaReference> redefines = CastUtils.cast(schema.getRedefines());\n        for (SchemaReference included : redefines) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                try {\n                                    //CHECKSTYLE:OFF:NestedIfDepth\n                                    if (!(new URI(decodedStart).isAbsolute()) && parent != null) {\n                                        resolvedSchemaLocation = new URI(parent).resolve(decodedStart).toString();\n                                        decodedStart = URLDecoder.decode(resolvedSchemaLocation, \"utf-8\");\n                                        doneSchemas.put(resolvedSchemaLocation, included);\n                                    }\n                                    //CHECKSTYLE:ON:NestedIfDepth\n                                } catch (URISyntaxException ex) {\n                                    // ignore\n                                } catch (UnsupportedEncodingException ex) {\n                                    // ignore\n                                }\n                                updateSchemaImports(bus, included.getReferencedSchema(),\n                                                    docBase, doneSchemas, base, decodedStart);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base, decodedStart);\n                }\n            }\n        }\n    }","id":47878,"modified_method":"protected void updateSchemaImports(Bus bus,\n                                       Schema schema,\n                                       String docBase,\n                                       Map<String, SchemaReference> doneSchemas,\n                                       String base) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n        Collection<List<?>>  imports = CastUtils.cast((Collection<?>)schema.getImports().values());\n        for (List<?> lst : imports) {\n            List<SchemaImport> impLst = CastUtils.cast(lst);\n            for (SchemaImport imp : impLst) {\n                String start = findSchemaLocation(doneSchemas, imp, docBase);\n\n                if (start != null) {\n                    String decodedStart = null;\n                    // Always use the URL decoded version to ensure that we have a\n                    // canonical representation of the import URL for lookup.\n                    try {\n                        decodedStart = URLDecoder.decode(start, \"utf-8\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new WSDLQueryException(\n                            new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                                LOG,\n                                start), e);\n                    }\n\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                        if (resolvedSchemaLocation == null) {\n                            resolvedSchemaLocation = resolveWithCatalogs(catalogs, imp.getSchemaLocationURI(), base);\n                        }\n                        if (resolvedSchemaLocation == null) {\n                            try {\n                                //check to see if it's already in a URL format.  If so, leave it.\n                                new URL(start);\n                            } catch (MalformedURLException e) {\n                                if (doneSchemas.put(decodedStart, imp) == null) {\n                                    putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, imp);\n                                    updateSchemaImports(bus, imp.getReferencedSchema(), docBase,\n                                                        doneSchemas, base);\n                                }\n                            }\n                        } else {\n                            if (doneSchemas.put(decodedStart, imp) == null) {\n                                doneSchemas.put(resolvedSchemaLocation, imp);\n                                doneSchemas.put(imp.getSchemaLocationURI(), imp);\n                                updateSchemaImports(bus, imp.getReferencedSchema(), docBase, doneSchemas, base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        List<SchemaReference> includes = CastUtils.cast(schema.getIncludes());\n        for (SchemaReference included : includes) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, included);\n                                updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                }\n            }\n        }\n        List<SchemaReference> redefines = CastUtils.cast(schema.getRedefines());\n        for (SchemaReference included : redefines) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                putResolvedSchemaLocationIfRelative(doneSchemas, decodedStart, included);\n                                updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                }\n            }\n        }\n    }","commit_id":"36b432c8a47b411d9a408d0adffeb780ebe3116a","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateSchemaImports(Bus bus,\n                                       Schema schema,\n                                       String docBase,\n                                       Map<String, SchemaReference> doneSchemas,\n                                       String base) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n        Collection<List<?>>  imports = CastUtils.cast((Collection<?>)schema.getImports().values());\n        for (List<?> lst : imports) {\n            List<SchemaImport> impLst = CastUtils.cast(lst);\n            for (SchemaImport imp : impLst) {\n                String start = findSchemaLocation(doneSchemas, imp, docBase);\n\n                if (start != null) {\n                    String decodedStart = null;\n                    // Always use the URL decoded version to ensure that we have a\n                    // canonical representation of the import URL for lookup.\n                    try {\n                        decodedStart = URLDecoder.decode(start, \"utf-8\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new WSDLQueryException(\n                            new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                                LOG,\n                                start), e);\n                    }\n\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                        if (resolvedSchemaLocation == null) {\n                            resolvedSchemaLocation = resolveWithCatalogs(catalogs, imp.getSchemaLocationURI(), base);\n                        }                        \n                        if (resolvedSchemaLocation == null) {\n                            try {\n                                //check to see if it's already in a URL format.  If so, leave it.\n                                new URL(start);\n                            } catch (MalformedURLException e) {\n                                if (doneSchemas.put(decodedStart, imp) == null) {\n                                    updateSchemaImports(bus, imp.getReferencedSchema(), docBase, doneSchemas, base);\n                                }\n                            }\n                        } else {\n                            if (doneSchemas.put(decodedStart, imp) == null) {\n                                doneSchemas.put(resolvedSchemaLocation, imp);\n                                doneSchemas.put(imp.getSchemaLocationURI(), imp);\n                                updateSchemaImports(bus, imp.getReferencedSchema(), docBase, doneSchemas, base);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        List<SchemaReference> includes = CastUtils.cast(schema.getIncludes());\n        for (SchemaReference included : includes) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                }\n            }\n        }\n        List<SchemaReference> redefines = CastUtils.cast(schema.getRedefines());\n        for (SchemaReference included : redefines) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base);\n                }\n            }\n        }\n    }","id":47879,"modified_method":"protected void updateSchemaImports(Bus bus,\n                                       Schema schema,\n                                       String docBase,\n                                       Map<String, SchemaReference> doneSchemas,\n                                       String base,\n                                       String parent) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n        Collection<List<?>>  imports = CastUtils.cast((Collection<?>)schema.getImports().values());\n        for (List<?> lst : imports) {\n            List<SchemaImport> impLst = CastUtils.cast(lst);\n            for (SchemaImport imp : impLst) {\n                String start = findSchemaLocation(doneSchemas, imp, docBase);\n\n                if (start != null) {\n                    String decodedStart = null;\n                    // Always use the URL decoded version to ensure that we have a\n                    // canonical representation of the import URL for lookup.\n                    try {\n                        decodedStart = URLDecoder.decode(start, \"utf-8\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new WSDLQueryException(\n                            new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                                LOG,\n                                start), e);\n                    }\n\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                        if (resolvedSchemaLocation == null) {\n                            resolvedSchemaLocation = resolveWithCatalogs(catalogs, imp.getSchemaLocationURI(), base);\n                        }                        \n                        if (resolvedSchemaLocation == null) {\n                            try {\n                                //check to see if it's already in a URL format.  If so, leave it.\n                                new URL(start);\n                            } catch (MalformedURLException e) {\n                                if (doneSchemas.put(decodedStart, imp) == null) {\n                                    try {\n                                        //CHECKSTYLE:OFF:NestedIfDepth\n                                        if (!(new URI(decodedStart).isAbsolute()) && parent != null) {\n                                            resolvedSchemaLocation = new URI(parent).resolve(decodedStart).toString();\n                                            decodedStart = URLDecoder.decode(resolvedSchemaLocation, \"utf-8\");\n                                            doneSchemas.put(resolvedSchemaLocation, imp);\n                                        }\n                                        //CHECKSTYLE:ON:NestedIfDepth \n                                    } catch (URISyntaxException ex) {\n                                        // ignore\n                                    } catch (UnsupportedEncodingException ex) {\n                                        // ignore\n                                    }\n                                    updateSchemaImports(bus, imp.getReferencedSchema(), docBase,\n                                                        doneSchemas, base, decodedStart);\n                                }\n                            }\n                        } else {\n                            if (doneSchemas.put(decodedStart, imp) == null) {\n                                doneSchemas.put(resolvedSchemaLocation, imp);\n                                doneSchemas.put(imp.getSchemaLocationURI(), imp);\n                                updateSchemaImports(bus, imp.getReferencedSchema(), docBase,\n                                                    doneSchemas, base, decodedStart);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        List<SchemaReference> includes = CastUtils.cast(schema.getIncludes());\n        for (SchemaReference included : includes) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                updateSchemaImports(bus, included.getReferencedSchema(), \n                                                    docBase, doneSchemas, base, decodedStart);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base, decodedStart);\n                }\n            }\n        }\n        List<SchemaReference> redefines = CastUtils.cast(schema.getRedefines());\n        for (SchemaReference included : redefines) {\n            String start = findSchemaLocation(doneSchemas, included, docBase);\n\n            if (start != null) {\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n                if (resolvedSchemaLocation == null) {\n                    if (!doneSchemas.containsKey(decodedStart)) {\n                        try {\n                            //check to see if it's aleady in a URL format.  If so, leave it.\n                            new URL(start);\n                        } catch (MalformedURLException e) {\n                            if (doneSchemas.put(decodedStart, included) == null) {\n                                try {\n                                    //CHECKSTYLE:OFF:NestedIfDepth\n                                    if (!(new URI(decodedStart).isAbsolute()) && parent != null) {\n                                        resolvedSchemaLocation = new URI(parent).resolve(decodedStart).toString();\n                                        decodedStart = URLDecoder.decode(resolvedSchemaLocation, \"utf-8\");\n                                        doneSchemas.put(resolvedSchemaLocation, included);\n                                    }\n                                    //CHECKSTYLE:ON:NestedIfDepth\n                                } catch (URISyntaxException ex) {\n                                    // ignore\n                                } catch (UnsupportedEncodingException ex) {\n                                    // ignore\n                                }\n                                updateSchemaImports(bus, included.getReferencedSchema(),\n                                                    docBase, doneSchemas, base, decodedStart);\n                            }\n                        }\n                    }\n                } else if (!doneSchemas.containsKey(decodedStart)\n                    || !doneSchemas.containsKey(resolvedSchemaLocation)) {\n                    doneSchemas.put(decodedStart, included);\n                    doneSchemas.put(resolvedSchemaLocation, included);\n                    updateSchemaImports(bus, included.getReferencedSchema(), docBase, doneSchemas, base, decodedStart);\n                }\n            }\n        }\n    }","commit_id":"2fdf389be5cf4d92dc4ec7e696d83ea48994a6a4","url":"https://github.com/apache/cxf"},{"original_method":"protected void updateDefinition(Bus bus,\n                                    Definition def,\n                                    Map<String, Definition> done,\n                                    Map<String, SchemaReference> doneSchemas,\n                                    String base,\n                                    String docBase) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n\n        Collection<List<?>> imports = CastUtils.cast((Collection<?>)def.getImports().values());\n        for (List<?> lst : imports) {\n            List<Import> impLst = CastUtils.cast(lst);\n            for (Import imp : impLst) {\n                String start = imp.getLocationURI();\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        try {\n                            start = getLocationURI(start, docBase);\n                            decodedStart = URLDecoder.decode(start, \"utf-8\");\n                        } catch (Exception e1) {\n                            //ignore\n                        }\n                        if (done.put(decodedStart, imp.getDefinition()) == null) {\n                            updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                        }\n                    }\n                } else {\n                    if (done.put(decodedStart, imp.getDefinition()) == null) {\n                        done.put(resolvedSchemaLocation, imp.getDefinition());\n                        updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                    }\n                }\n            }\n        }\n\n\n        /* This doesn't actually work.   Setting setSchemaLocationURI on the import\n        * for some reason doesn't actually result in the new URI being written\n        * */\n        Types types = def.getTypes();\n        if (types != null) {\n            for (ExtensibilityElement el\n                : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {\n                if (el instanceof Schema) {\n                    Schema see = (Schema)el;\n                    updateSchemaImports(bus, see, see.getDocumentBaseURI(), doneSchemas, base);\n                }\n            }\n        }\n    }","id":47880,"modified_method":"protected void updateDefinition(Bus bus,\n                                    Definition def,\n                                    Map<String, Definition> done,\n                                    Map<String, SchemaReference> doneSchemas,\n                                    String base,\n                                    String docBase) {\n        OASISCatalogManager catalogs = OASISCatalogManager.getCatalogManager(bus);\n\n        Collection<List<?>> imports = CastUtils.cast((Collection<?>)def.getImports().values());\n        for (List<?> lst : imports) {\n            List<Import> impLst = CastUtils.cast(lst);\n            for (Import imp : impLst) {\n                String start = imp.getLocationURI();\n                String decodedStart = null;\n                // Always use the URL decoded version to ensure that we have a\n                // canonical representation of the import URL for lookup.\n\n                try {\n                    decodedStart = URLDecoder.decode(start, \"utf-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new WSDLQueryException(\n                        new org.apache.cxf.common.i18n.Message(\"COULD_NOT_PROVIDE_WSDL\",\n                            LOG,\n                            start), e);\n                }\n\n                String resolvedSchemaLocation = resolveWithCatalogs(catalogs, start, base);\n\n                if (resolvedSchemaLocation == null) {\n                    try {\n                        //check to see if it's already in a URL format.  If so, leave it.\n                        new URL(start);\n                    } catch (MalformedURLException e) {\n                        try {\n                            start = getLocationURI(start, docBase);\n                            decodedStart = URLDecoder.decode(start, \"utf-8\");\n                        } catch (Exception e1) {\n                            //ignore\n                        }\n                        if (done.put(decodedStart, imp.getDefinition()) == null) {\n                            updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                        }\n                    }\n                } else {\n                    if (done.put(decodedStart, imp.getDefinition()) == null) {\n                        done.put(resolvedSchemaLocation, imp.getDefinition());\n                        updateDefinition(bus, imp.getDefinition(), done, doneSchemas, base, start);\n                    }\n                }\n            }\n        }\n\n\n        /* This doesn't actually work.   Setting setSchemaLocationURI on the import\n        * for some reason doesn't actually result in the new URI being written\n        * */\n        Types types = def.getTypes();\n        if (types != null) {\n            for (ExtensibilityElement el\n                : CastUtils.cast(types.getExtensibilityElements(), ExtensibilityElement.class)) {\n                if (el instanceof Schema) {\n                    Schema see = (Schema)el;\n                    updateSchemaImports(bus, see, see.getDocumentBaseURI(), doneSchemas, base, null);\n                }\n            }\n        }\n    }","commit_id":"2fdf389be5cf4d92dc4ec7e696d83ea48994a6a4","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * For internal use and testing only.  The rest of the system should go through the submit* methods,\n     * which are properly serialized.\n     * Caller is in charge of marking/unmarking the sstables as compacting.\n     */\n    public int execute(CompactionExecutorStatsCollector collector) throws IOException\n    {\n        // The collection of sstables passed may be empty (but not null); even if\n        // it is not empty, it may compact down to nothing if all rows are deleted.\n        assert sstables != null;\n\n        Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);\n        if (!isUserDefined)\n        {\n            if ( !allowSingletonCompaction() && toCompact.size() < 2)\n            {\n                logger.info(\"Nothing to compact in \" + cfs.getColumnFamilyName() + \".\" +\n                            \"Use forceUserDefinedCompaction if you wish to force compaction of single sstables \" +\n                            \"(e.g. for tombstone collection)\");\n                return 0;\n            }\n\n            if (compactionFileLocation == null)\n                compactionFileLocation = cfs.table.getDataFileLocation(cfs.getExpectedCompactedFileSize(toCompact));\n\n            // If the compaction file path is null that means we have no space left for this compaction.\n            // Try again w/o the largest one.\n            if (compactionFileLocation == null)\n            {\n                while (compactionFileLocation == null && toCompact.size() > 1)\n                {\n                    logger.warn(\"insufficient space to compact all requested files \" + StringUtils.join(toCompact, \", \"));\n                    // Note that we have removed files that are still marked as compacting. This suboptimal but ok since the caller will unmark all\n                    // the sstables at the end.\n                    toCompact.remove(cfs.getMaxSizeFile(toCompact));\n                    compactionFileLocation = cfs.table.getDataFileLocation(cfs.getExpectedCompactedFileSize(toCompact));\n                }\n            }\n\n            if (compactionFileLocation == null)\n            {\n                logger.warn(\"insufficient space to compact even the two smallest files, aborting\");\n                return 0;\n            }\n        }\n\n        if (DatabaseDescriptor.isSnapshotBeforeCompaction())\n            cfs.table.snapshot(System.currentTimeMillis() + \"-\" + \"compact-\" + cfs.columnFamily);\n\n        // sanity check: all sstables must belong to the same cfs\n        for (SSTableReader sstable : toCompact)\n            assert sstable.descriptor.cfname.equals(cfs.columnFamily);\n\n        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);\n        // new sstables from flush can be added during a compaction, but only the compaction can remove them,\n        // so in our single-threaded compaction world this is a valid way of determining if we're compacting\n        // all the sstables (that existed when we started)\n        logger.info(\"Compacting {}\", toCompact);\n\n        long startTime = System.currentTimeMillis();\n        long totalkeysWritten = 0;\n\n        // TODO the int cast here is potentially buggy\n        int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(), (int)SSTableReader.getApproximateKeyCount(toCompact));\n        if (logger.isDebugEnabled())\n            logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()\n                                      ? new ParallelCompactionIterable(OperationType.COMPACTION, toCompact, controller)\n                                      : new CompactionIterable(OperationType.COMPACTION, toCompact, controller);\n        CloseableIterator<AbstractCompactedRow> iter = ci.iterator();\n        Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());\n        Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();\n\n        // we can't preheat until the tracker has been set. This doesn't happen until we tell the cfs to\n        // replace the old entries.  Track entries to preheat here until then.\n        Map<SSTableReader, Map<DecoratedKey, Long>> cachedKeyMap =  new HashMap<SSTableReader, Map<DecoratedKey, Long>>();\n\n        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();\n        Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();\n\n        if (collector != null)\n            collector.beginCompaction(ci);\n        try\n        {\n            if (!nni.hasNext())\n            {\n                // don't mark compacted in the finally block, since if there _is_ nondeleted data,\n                // we need to sync it (via closeAndOpen) first, so there is no period during which\n                // a crash could cause data loss.\n                cfs.markCompacted(toCompact);\n                return 0;\n            }\n\n            SSTableWriter writer = cfs.createCompactionWriter(expectedBloomFilterSize, compactionFileLocation, toCompact);\n            writers.add(writer);\n            while (nni.hasNext())\n            {\n                AbstractCompactedRow row = nni.next();\n                if (row.isEmpty())\n                    continue;\n\n                long position = writer.append(row);\n                totalkeysWritten++;\n\n                if (DatabaseDescriptor.getPreheatKeyCache())\n                {\n                    for (SSTableReader sstable : toCompact)\n                    {\n                        if (sstable.getCachedPosition(row.key) != null)\n                        {\n                            cachedKeys.put(row.key, position);\n                            break;\n                        }\n                    }\n                }\n                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer, position))\n                {\n                    SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));\n                    cachedKeyMap.put(toIndex, cachedKeys);\n                    sstables.add(toIndex);\n                    writer = cfs.createCompactionWriter(expectedBloomFilterSize, compactionFileLocation, toCompact);\n                    writers.add(writer);\n                    cachedKeys = new HashMap<DecoratedKey, Long>();\n                }\n            }\n        }\n        finally\n        {\n            iter.close();\n            if (collector != null)\n                collector.finishCompaction(ci);\n            for (SSTableWriter writer : writers)\n                writer.cleanupIfNecessary();\n        }\n\n        cfs.replaceCompactedSSTables(toCompact, sstables);\n        // TODO: this doesn't belong here, it should be part of the reader to load when the tracker is wired up\n        for (Entry<SSTableReader, Map<DecoratedKey, Long>> ssTableReaderMapEntry : cachedKeyMap.entrySet())\n        {\n            SSTableReader key = ssTableReaderMapEntry.getKey();\n            for (Entry<DecoratedKey, Long> entry : ssTableReaderMapEntry.getValue().entrySet())\n               key.cacheKey(entry.getKey(), entry.getValue());\n        }\n\n        CompactionManager.instance.submitBackground(cfs);\n\n        long dTime = System.currentTimeMillis() - startTime;\n        long startsize = SSTable.getTotalBytes(toCompact);\n        long endsize = SSTable.getTotalBytes(sstables);\n        double ratio = (double)endsize / (double)startsize;\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"[\");\n        for (SSTableReader reader : sstables)\n            builder.append(reader.getFilename()).append(\",\");\n        builder.append(\"]\");\n\n        double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;\n        logger.info(String.format(\"Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys at %fMBPS.  Time: %,dms.\",\n                                  builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));\n        logger.info(String.format(\"CF Total Bytes Compacted: %,d\", CompactionTask.addToTotalBytesCompacted(endsize)));\n        return toCompact.size();\n    }","id":47881,"modified_method":"/**\n     * For internal use and testing only.  The rest of the system should go through the submit* methods,\n     * which are properly serialized.\n     * Caller is in charge of marking/unmarking the sstables as compacting.\n     */\n    public int execute(CompactionExecutorStatsCollector collector) throws IOException\n    {\n        // The collection of sstables passed may be empty (but not null); even if\n        // it is not empty, it may compact down to nothing if all rows are deleted.\n        assert sstables != null;\n\n        Set<SSTableReader> toCompact = new HashSet<SSTableReader>(sstables);\n        if (!isUserDefined)\n        {\n            if ( !allowSingletonCompaction() && toCompact.size() < 2)\n            {\n                logger.info(\"Nothing to compact in \" + cfs.getColumnFamilyName() + \".\" +\n                            \"Use forceUserDefinedCompaction if you wish to force compaction of single sstables \" +\n                            \"(e.g. for tombstone collection)\");\n                return 0;\n            }\n\n            if (compactionFileLocation == null)\n                compactionFileLocation = cfs.table.getDataFileLocation(cfs.getExpectedCompactedFileSize(toCompact));\n\n            // If the compaction file path is null that means we have no space left for this compaction.\n            // Try again w/o the largest one.\n            if (compactionFileLocation == null)\n            {\n                while (compactionFileLocation == null && toCompact.size() > 1)\n                {\n                    logger.warn(\"insufficient space to compact all requested files \" + StringUtils.join(toCompact, \", \"));\n                    // Note that we have removed files that are still marked as compacting. This suboptimal but ok since the caller will unmark all\n                    // the sstables at the end.\n                    toCompact.remove(cfs.getMaxSizeFile(toCompact));\n                    compactionFileLocation = cfs.table.getDataFileLocation(cfs.getExpectedCompactedFileSize(toCompact));\n                }\n            }\n\n            if (compactionFileLocation == null)\n            {\n                logger.warn(\"insufficient space to compact even the two smallest files, aborting\");\n                return 0;\n            }\n        }\n\n        if (DatabaseDescriptor.isSnapshotBeforeCompaction())\n            cfs.table.snapshot(System.currentTimeMillis() + \"-\" + \"compact-\" + cfs.columnFamily);\n\n        // sanity check: all sstables must belong to the same cfs\n        for (SSTableReader sstable : toCompact)\n            assert sstable.descriptor.cfname.equals(cfs.columnFamily);\n\n        CompactionController controller = new CompactionController(cfs, toCompact, gcBefore, isUserDefined);\n        // new sstables from flush can be added during a compaction, but only the compaction can remove them,\n        // so in our single-threaded compaction world this is a valid way of determining if we're compacting\n        // all the sstables (that existed when we started)\n        logger.info(\"Compacting {}\", toCompact);\n\n        long startTime = System.currentTimeMillis();\n        long totalkeysWritten = 0;\n\n        long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toCompact));\n        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(toCompact) / cfs.getCompactionStrategy().getMaxSSTableSize());\n        long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);\n        if (logger.isDebugEnabled())\n            logger.debug(\"Expected bloom filter size : \" + keysPerSSTable);\n\n        AbstractCompactionIterable ci = DatabaseDescriptor.isMultithreadedCompaction()\n                                      ? new ParallelCompactionIterable(OperationType.COMPACTION, toCompact, controller)\n                                      : new CompactionIterable(OperationType.COMPACTION, toCompact, controller);\n        CloseableIterator<AbstractCompactedRow> iter = ci.iterator();\n        Iterator<AbstractCompactedRow> nni = Iterators.filter(iter, Predicates.notNull());\n        Map<DecoratedKey, Long> cachedKeys = new HashMap<DecoratedKey, Long>();\n\n        // we can't preheat until the tracker has been set. This doesn't happen until we tell the cfs to\n        // replace the old entries.  Track entries to preheat here until then.\n        Map<SSTableReader, Map<DecoratedKey, Long>> cachedKeyMap =  new HashMap<SSTableReader, Map<DecoratedKey, Long>>();\n\n        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();\n        Collection<SSTableWriter> writers = new ArrayList<SSTableWriter>();\n\n        if (collector != null)\n            collector.beginCompaction(ci);\n        try\n        {\n            if (!nni.hasNext())\n            {\n                // don't mark compacted in the finally block, since if there _is_ nondeleted data,\n                // we need to sync it (via closeAndOpen) first, so there is no period during which\n                // a crash could cause data loss.\n                cfs.markCompacted(toCompact);\n                return 0;\n            }\n\n            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);\n            writers.add(writer);\n            while (nni.hasNext())\n            {\n                AbstractCompactedRow row = nni.next();\n                if (row.isEmpty())\n                    continue;\n\n                long position = writer.append(row);\n                totalkeysWritten++;\n\n                if (DatabaseDescriptor.getPreheatKeyCache())\n                {\n                    for (SSTableReader sstable : toCompact)\n                    {\n                        if (sstable.getCachedPosition(row.key) != null)\n                        {\n                            cachedKeys.put(row.key, position);\n                            break;\n                        }\n                    }\n                }\n                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer, position))\n                {\n                    SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));\n                    cachedKeyMap.put(toIndex, cachedKeys);\n                    sstables.add(toIndex);\n                    writer = cfs.createCompactionWriter(keysPerSSTable, compactionFileLocation, toCompact);\n                    writers.add(writer);\n                    cachedKeys = new HashMap<DecoratedKey, Long>();\n                }\n            }\n        }\n        finally\n        {\n            iter.close();\n            if (collector != null)\n                collector.finishCompaction(ci);\n            for (SSTableWriter writer : writers)\n                writer.cleanupIfNecessary();\n        }\n\n        cfs.replaceCompactedSSTables(toCompact, sstables);\n        // TODO: this doesn't belong here, it should be part of the reader to load when the tracker is wired up\n        for (Entry<SSTableReader, Map<DecoratedKey, Long>> ssTableReaderMapEntry : cachedKeyMap.entrySet())\n        {\n            SSTableReader key = ssTableReaderMapEntry.getKey();\n            for (Entry<DecoratedKey, Long> entry : ssTableReaderMapEntry.getValue().entrySet())\n               key.cacheKey(entry.getKey(), entry.getValue());\n        }\n\n        CompactionManager.instance.submitBackground(cfs);\n\n        long dTime = System.currentTimeMillis() - startTime;\n        long startsize = SSTable.getTotalBytes(toCompact);\n        long endsize = SSTable.getTotalBytes(sstables);\n        double ratio = (double)endsize / (double)startsize;\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"[\");\n        for (SSTableReader reader : sstables)\n            builder.append(reader.getFilename()).append(\",\");\n        builder.append(\"]\");\n\n        double mbps = dTime > 0 ? (double)endsize/(1024*1024)/((double)dTime/1000) : 0;\n        logger.info(String.format(\"Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys at %fMBPS.  Time: %,dms.\",\n                                  builder.toString(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, mbps, dTime));\n        logger.info(String.format(\"CF Total Bytes Compacted: %,d\", CompactionTask.addToTotalBytesCompacted(endsize)));\n        return toCompact.size();\n    }","commit_id":"84a461acf9dff96ace30b54c788e4211f80e8b91","url":"https://github.com/apache/cassandra"},{"original_method":"public List<AbstractCompactionTask> getBackgroundTasks(int gcBefore)\n    {\n        LeveledCompactionTask currentTask = task.get();\n        if (currentTask != null && !currentTask.isDone())\n        {\n            logger.debug(\"Compaction still in progress for {}\", this);\n            return Collections.emptyList();\n        }\n\n        Collection<SSTableReader> sstables = manifest.getCompactionCandidates();\n        if (sstables.isEmpty())\n        {\n            logger.debug(\"No compaction necessary for {}\", this);\n            return Collections.emptyList();\n        }\n\n        LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, gcBefore, this.maxSSTableSize);\n        return task.compareAndSet(currentTask, newTask)\n               ? Collections.<AbstractCompactionTask>singletonList(newTask)\n               : Collections.<AbstractCompactionTask>emptyList();\n    }","id":47882,"modified_method":"public List<AbstractCompactionTask> getBackgroundTasks(int gcBefore)\n    {\n        LeveledCompactionTask currentTask = task.get();\n        if (currentTask != null && !currentTask.isDone())\n        {\n            logger.debug(\"Compaction still in progress for {}\", this);\n            return Collections.emptyList();\n        }\n\n        Collection<SSTableReader> sstables = manifest.getCompactionCandidates();\n        if (sstables.isEmpty())\n        {\n            logger.debug(\"No compaction necessary for {}\", this);\n            return Collections.emptyList();\n        }\n\n        LeveledCompactionTask newTask = new LeveledCompactionTask(cfs, sstables, gcBefore, this.maxSSTableSizeInMB);\n        return task.compareAndSet(currentTask, newTask)\n               ? Collections.<AbstractCompactionTask>singletonList(newTask)\n               : Collections.<AbstractCompactionTask>emptyList();\n    }","commit_id":"84a461acf9dff96ace30b54c788e4211f80e8b91","url":"https://github.com/apache/cassandra"},{"original_method":"public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> options)\n    {\n        super(cfs, options);\n        int configuredMaxSSTableSize = 5;\n        if (options != null)\n        {\n            String value = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : null;\n            if (null != value)\n            {\n                try\n                {\n                    configuredMaxSSTableSize = Integer.parseInt(value);\n                }\n                catch (NumberFormatException ex)\n                {\n                    logger.warn(String.format(\"%s is not a parsable int (base10) for %s using default value\",\n                                              value, SSTABLE_SIZE_OPTION));\n                }\n            }\n        }\n        maxSSTableSize = configuredMaxSSTableSize;\n\n        cfs.getDataTracker().subscribe(this);\n        logger.info(this + \" subscribed to the data tracker.\");\n\n        manifest = LeveledManifest.create(cfs, this.maxSSTableSize);\n        logger.debug(\"Created {}\", manifest);\n        // override min/max for this strategy\n        cfs.setMaximumCompactionThreshold(Integer.MAX_VALUE);\n        cfs.setMinimumCompactionThreshold(1);\n\n        // TODO this is redundant wrt the kickoff in AbstractCompactionStrategy, once CASSANDRA-X is done\n        Runnable runnable = new Runnable()\n        {\n            public void run()\n            {\n                CompactionManager.instance.submitBackground(LeveledCompactionStrategy.this.cfs);\n            }\n        };\n        StorageService.optionalTasks.scheduleAtFixedRate(runnable, 5 * 60, 5, TimeUnit.SECONDS);\n    }","id":47883,"modified_method":"public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> options)\n    {\n        super(cfs, options);\n        int configuredMaxSSTableSize = 5;\n        if (options != null)\n        {\n            String value = options.containsKey(SSTABLE_SIZE_OPTION) ? options.get(SSTABLE_SIZE_OPTION) : null;\n            if (null != value)\n            {\n                try\n                {\n                    configuredMaxSSTableSize = Integer.parseInt(value);\n                }\n                catch (NumberFormatException ex)\n                {\n                    logger.warn(String.format(\"%s is not a parsable int (base10) for %s using default value\",\n                                              value, SSTABLE_SIZE_OPTION));\n                }\n            }\n        }\n        maxSSTableSizeInMB = configuredMaxSSTableSize;\n\n        cfs.getDataTracker().subscribe(this);\n        logger.info(this + \" subscribed to the data tracker.\");\n\n        manifest = LeveledManifest.create(cfs, this.maxSSTableSizeInMB);\n        logger.debug(\"Created {}\", manifest);\n        // override min/max for this strategy\n        cfs.setMaximumCompactionThreshold(Integer.MAX_VALUE);\n        cfs.setMinimumCompactionThreshold(1);\n\n        // TODO this is redundant wrt the kickoff in AbstractCompactionStrategy, once CASSANDRA-X is done\n        Runnable runnable = new Runnable()\n        {\n            public void run()\n            {\n                CompactionManager.instance.submitBackground(LeveledCompactionStrategy.this.cfs);\n            }\n        };\n        StorageService.optionalTasks.scheduleAtFixedRate(runnable, 5 * 60, 5, TimeUnit.SECONDS);\n    }","commit_id":"84a461acf9dff96ace30b54c788e4211f80e8b91","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * This function goes over each file and removes the keys that the node is not responsible for\n     * and only keeps keys that this node is responsible for.\n     *\n     * @throws IOException\n     */\n    private void doCleanupCompaction(final ColumnFamilyStore cfs, Collection<SSTableReader> sstables, CounterId.OneShotRenewer renewer) throws IOException\n    {\n        assert !cfs.isIndex();\n        Keyspace keyspace = cfs.keyspace;\n        Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName());\n        if (ranges.isEmpty())\n        {\n            logger.info(\"Cleanup cannot run before a node has joined the ring\");\n            return;\n        }\n\n        boolean hasIndexes = cfs.indexManager.hasIndexes();\n        CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, renewer);\n\n        for (SSTableReader sstable : sstables)\n        {\n            Set<SSTableReader> sstableAsSet = Collections.singleton(sstable);\n            if (!hasIndexes && !new Bounds<Token>(sstable.first.token, sstable.last.token).intersects(ranges))\n            {\n                cfs.replaceCompactedSSTables(sstableAsSet, Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);\n                continue;\n            }\n            if (!needsCleanup(sstable, ranges))\n            {\n                logger.debug(\"Skipping {} for cleanup; all rows should be kept\", sstable);\n                continue;\n            }\n\n            CompactionController controller = new CompactionController(cfs, sstableAsSet, getDefaultGcBefore(cfs));\n            long start = System.nanoTime();\n\n            long totalkeysWritten = 0;\n\n            int expectedBloomFilterSize = Math.max(cfs.metadata.getIndexInterval(),\n                                                   (int) (SSTableReader.getApproximateKeyCount(sstableAsSet, cfs.metadata)));\n            if (logger.isDebugEnabled())\n                logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n            logger.info(\"Cleaning up \" + sstable);\n            File compactionFileLocation = cfs.directories.getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(sstableAsSet, OperationType.CLEANUP));\n            if (compactionFileLocation == null)\n                throw new IOException(\"disk full\");\n\n            ICompactionScanner scanner = cleanupStrategy.getScanner(sstable, getRateLimiter());\n            CleanupInfo ci = new CleanupInfo(sstable, scanner);\n\n            metrics.beginCompaction(ci);\n            SSTableWriter writer = createWriter(cfs,\n                                                compactionFileLocation,\n                                                expectedBloomFilterSize,\n                                                sstable);\n            SSTableReader newSstable = null;\n            try\n            {\n                while (scanner.hasNext())\n                {\n                    if (ci.isStopRequested())\n                        throw new CompactionInterruptedException(ci.getCompactionInfo());\n                    SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n\n                    row = cleanupStrategy.cleanup(row);\n                    if (row == null)\n                        continue;\n                    AbstractCompactedRow compactedRow = controller.getCompactedRow(row);\n                    if (writer.append(compactedRow) != null)\n                        totalkeysWritten++;\n                }\n                if (totalkeysWritten > 0)\n                    newSstable = writer.closeAndOpenReader(sstable.maxDataAge);\n                else\n                    writer.abort();\n            }\n            catch (Throwable e)\n            {\n                writer.abort();\n                throw Throwables.propagate(e);\n            }\n            finally\n            {\n                controller.close();\n                scanner.close();\n                metrics.finishCompaction(ci);\n            }\n\n            List<SSTableReader> results = new ArrayList<SSTableReader>(1);\n            if (newSstable != null)\n            {\n                results.add(newSstable);\n\n                String format = \"Cleaned up to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys.  Time: %,dms.\";\n                long dTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                long startsize = sstable.onDiskLength();\n                long endsize = newSstable.onDiskLength();\n                double ratio = (double) endsize / (double) startsize;\n                logger.info(String.format(format, writer.getFilename(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, dTime));\n            }\n\n            // flush to ensure we don't lose the tombstones on a restart, since they are not commitlog'd\n            cfs.indexManager.flushIndexesBlocking();\n\n            cfs.replaceCompactedSSTables(Arrays.asList(sstable), results, OperationType.CLEANUP);\n        }\n    }","id":47884,"modified_method":"/**\n     * This function goes over each file and removes the keys that the node is not responsible for\n     * and only keeps keys that this node is responsible for.\n     *\n     * @throws IOException\n     */\n    private void doCleanupCompaction(final ColumnFamilyStore cfs, Collection<SSTableReader> sstables, CounterId.OneShotRenewer renewer) throws IOException\n    {\n        assert !cfs.isIndex();\n        Keyspace keyspace = cfs.keyspace;\n        Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName());\n        if (ranges.isEmpty())\n        {\n            logger.info(\"Cleanup cannot run before a node has joined the ring\");\n            return;\n        }\n\n        boolean hasIndexes = cfs.indexManager.hasIndexes();\n        CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, renewer);\n\n        for (SSTableReader sstable : sstables)\n        {\n            Set<SSTableReader> sstableAsSet = Collections.singleton(sstable);\n            if (!hasIndexes && !new Bounds<Token>(sstable.first.token, sstable.last.token).intersects(ranges))\n            {\n                cfs.replaceCompactedSSTables(sstableAsSet, Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);\n                continue;\n            }\n            if (!needsCleanup(sstable, ranges))\n            {\n                logger.debug(\"Skipping {} for cleanup; all rows should be kept\", sstable);\n                continue;\n            }\n\n            CompactionController controller = new CompactionController(cfs, sstableAsSet, getDefaultGcBefore(cfs));\n            long start = System.nanoTime();\n\n            long totalkeysWritten = 0;\n\n            long expectedBloomFilterSize = Math.max(cfs.metadata.getIndexInterval(),\n                                                    SSTableReader.getApproximateKeyCount(sstableAsSet, cfs.metadata));\n            if (logger.isDebugEnabled())\n                logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n            logger.info(\"Cleaning up \" + sstable);\n            File compactionFileLocation = cfs.directories.getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(sstableAsSet, OperationType.CLEANUP));\n            if (compactionFileLocation == null)\n                throw new IOException(\"disk full\");\n\n            ICompactionScanner scanner = cleanupStrategy.getScanner(sstable, getRateLimiter());\n            CleanupInfo ci = new CleanupInfo(sstable, scanner);\n\n            metrics.beginCompaction(ci);\n            SSTableWriter writer = createWriter(cfs,\n                                                compactionFileLocation,\n                                                expectedBloomFilterSize,\n                                                sstable);\n            SSTableReader newSstable = null;\n            try\n            {\n                while (scanner.hasNext())\n                {\n                    if (ci.isStopRequested())\n                        throw new CompactionInterruptedException(ci.getCompactionInfo());\n                    SSTableIdentityIterator row = (SSTableIdentityIterator) scanner.next();\n\n                    row = cleanupStrategy.cleanup(row);\n                    if (row == null)\n                        continue;\n                    AbstractCompactedRow compactedRow = controller.getCompactedRow(row);\n                    if (writer.append(compactedRow) != null)\n                        totalkeysWritten++;\n                }\n                if (totalkeysWritten > 0)\n                    newSstable = writer.closeAndOpenReader(sstable.maxDataAge);\n                else\n                    writer.abort();\n            }\n            catch (Throwable e)\n            {\n                writer.abort();\n                throw Throwables.propagate(e);\n            }\n            finally\n            {\n                controller.close();\n                scanner.close();\n                metrics.finishCompaction(ci);\n            }\n\n            List<SSTableReader> results = new ArrayList<SSTableReader>(1);\n            if (newSstable != null)\n            {\n                results.add(newSstable);\n\n                String format = \"Cleaned up to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys.  Time: %,dms.\";\n                long dTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                long startsize = sstable.onDiskLength();\n                long endsize = newSstable.onDiskLength();\n                double ratio = (double) endsize / (double) startsize;\n                logger.info(String.format(format, writer.getFilename(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, dTime));\n            }\n\n            // flush to ensure we don't lose the tombstones on a restart, since they are not commitlog'd\n            cfs.indexManager.flushIndexesBlocking();\n\n            cfs.replaceCompactedSSTables(Arrays.asList(sstable), results, OperationType.CLEANUP);\n        }\n    }","commit_id":"45bd07f6fe2269a8bc68f1c11524b3a3f80f4f23","url":"https://github.com/apache/cassandra"},{"original_method":"public static SSTableWriter createWriter(ColumnFamilyStore cfs,\n                                             File compactionFileLocation,\n                                             int expectedBloomFilterSize,\n                                             SSTableReader sstable)\n    {\n        FileUtils.createDirectory(compactionFileLocation);\n        return new SSTableWriter(cfs.getTempSSTablePath(compactionFileLocation),\n                                 expectedBloomFilterSize,\n                                 cfs.metadata,\n                                 cfs.partitioner,\n                                 SSTableMetadata.createCollector(Collections.singleton(sstable), cfs.metadata.comparator, sstable.getSSTableLevel()));\n    }","id":47885,"modified_method":"public static SSTableWriter createWriter(ColumnFamilyStore cfs,\n                                             File compactionFileLocation,\n                                             long expectedBloomFilterSize,\n                                             SSTableReader sstable)\n    {\n        FileUtils.createDirectory(compactionFileLocation);\n        return new SSTableWriter(cfs.getTempSSTablePath(compactionFileLocation),\n                                 expectedBloomFilterSize,\n                                 cfs.metadata,\n                                 cfs.partitioner,\n                                 SSTableMetadata.createCollector(Collections.singleton(sstable), cfs.metadata.comparator, sstable.getSSTableLevel()));\n    }","commit_id":"45bd07f6fe2269a8bc68f1c11524b3a3f80f4f23","url":"https://github.com/apache/cassandra"},{"original_method":"public Scrubber(ColumnFamilyStore cfs, SSTableReader sstable, boolean skipCorrupted, boolean checkData, OutputHandler outputHandler, boolean isOffline) throws IOException\n    {\n        this.cfs = cfs;\n        this.sstable = sstable;\n        this.outputHandler = outputHandler;\n        this.skipCorrupted = skipCorrupted;\n        this.validateColumns = checkData;\n\n        List<SSTableReader> toScrub = Collections.singletonList(sstable);\n\n        // Calculate the expected compacted filesize\n        this.destination = cfs.directories.getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(toScrub, OperationType.SCRUB));\n        if (destination == null)\n            throw new IOException(\"disk full\");\n\n        // If we run scrub offline, we should never purge tombstone, as we cannot know if other sstable have data that the tombstone deletes.\n        this.controller = isOffline\n                        ? new ScrubController(cfs)\n                        : new CompactionController(cfs, Collections.singleton(sstable), CompactionManager.getDefaultGcBefore(cfs));\n        this.isCommutative = cfs.metadata.getDefaultValidator().isCommutative();\n\n        boolean hasIndexFile = (new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX))).exists();\n        if (!hasIndexFile)\n        {\n            // if there's any corruption in the -Data.db then rows can't be skipped over. but it's worth a shot.\n            outputHandler.warn(\"Missing component: \" + sstable.descriptor.filenameFor(Component.PRIMARY_INDEX));\n        }\n\n        this.expectedBloomFilterSize = Math.max(cfs.metadata.getIndexInterval(),\n                hasIndexFile ? (int)(SSTableReader.getApproximateKeyCount(toScrub,cfs.metadata)) : 0);\n\n        // loop through each row, deserializing to check for damage.\n        // we'll also loop through the index at the same time, using the position from the index to recover if the\n        // row header (key or data size) is corrupt. (This means our position in the index file will be one row\n        // \"ahead\" of the data file.)\n        this.dataFile = isOffline\n                        ? sstable.openDataReader()\n                        : sstable.openDataReader(CompactionManager.instance.getRateLimiter());\n\n        this.indexFile = hasIndexFile\n                ? RandomAccessReader.open(new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX)))\n                : null;\n\n        this.scrubInfo = new ScrubInfo(dataFile, sstable);\n\n        this.currentRowPositionFromIndex = 0;\n        this.nextRowPositionFromIndex = 0;\n    }","id":47886,"modified_method":"public Scrubber(ColumnFamilyStore cfs, SSTableReader sstable, boolean skipCorrupted, boolean checkData, OutputHandler outputHandler, boolean isOffline) throws IOException\n    {\n        this.cfs = cfs;\n        this.sstable = sstable;\n        this.outputHandler = outputHandler;\n        this.skipCorrupted = skipCorrupted;\n        this.validateColumns = checkData;\n\n        List<SSTableReader> toScrub = Collections.singletonList(sstable);\n\n        // Calculate the expected compacted filesize\n        this.destination = cfs.directories.getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(toScrub, OperationType.SCRUB));\n        if (destination == null)\n            throw new IOException(\"disk full\");\n\n        // If we run scrub offline, we should never purge tombstone, as we cannot know if other sstable have data that the tombstone deletes.\n        this.controller = isOffline\n                        ? new ScrubController(cfs)\n                        : new CompactionController(cfs, Collections.singleton(sstable), CompactionManager.getDefaultGcBefore(cfs));\n        this.isCommutative = cfs.metadata.getDefaultValidator().isCommutative();\n\n        boolean hasIndexFile = (new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX))).exists();\n        if (!hasIndexFile)\n        {\n            // if there's any corruption in the -Data.db then rows can't be skipped over. but it's worth a shot.\n            outputHandler.warn(\"Missing component: \" + sstable.descriptor.filenameFor(Component.PRIMARY_INDEX));\n        }\n\n        this.expectedBloomFilterSize = Math.max(cfs.metadata.getIndexInterval(),\n                hasIndexFile ? SSTableReader.getApproximateKeyCount(toScrub, cfs.metadata) : 0);\n\n        // loop through each row, deserializing to check for damage.\n        // we'll also loop through the index at the same time, using the position from the index to recover if the\n        // row header (key or data size) is corrupt. (This means our position in the index file will be one row\n        // \"ahead\" of the data file.)\n        this.dataFile = isOffline\n                        ? sstable.openDataReader()\n                        : sstable.openDataReader(CompactionManager.instance.getRateLimiter());\n\n        this.indexFile = hasIndexFile\n                ? RandomAccessReader.open(new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX)))\n                : null;\n\n        this.scrubInfo = new ScrubInfo(dataFile, sstable);\n\n        this.currentRowPositionFromIndex = 0;\n        this.nextRowPositionFromIndex = 0;\n    }","commit_id":"45bd07f6fe2269a8bc68f1c11524b3a3f80f4f23","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n    public void visit(Relation r) {\n        nonClosedWays.clear();\n        if (r.isMultipolygon()) {\n            checkMembersAndRoles(r);\n\n            Multipolygon polygon = MultipolygonCache.getInstance().get(Main.map.mapView, r);\n\n            boolean hasOuterWay = false;\n            for (RelationMember m : r.getMembers()) {\n                if (\"outer\".equals(m.getRole())) {\n                    hasOuterWay = true;\n                    break;\n                }\n            }\n            if (!hasOuterWay) {\n                addError(r, new TestError(this, Severity.WARNING, tr(\"No outer way for multipolygon\"), MISSING_OUTER_WAY, r));\n            }\n\n            if (r.hasIncompleteMembers()) {\n                return; // Rest of checks is only for complete multipolygons\n            }\n\n            // Create new multipolygon using the logics from CreateMultipolygonAction and see if roles match.\n            final Pair<Relation, Relation> newMP = CreateMultipolygonAction.createMultipolygonRelation(r.getMemberPrimitives(Way.class), false);\n            if (newMP != null) {\n                for (RelationMember member : r.getMembers()) {\n                    final Collection<RelationMember> memberInNewMP = newMP.b.getMembersFor(Collections.singleton(member.getMember()));\n                    if (memberInNewMP != null && !memberInNewMP.isEmpty()) {\n                        final String roleInNewMP = memberInNewMP.iterator().next().getRole();\n                        if (!member.getRole().equals(roleInNewMP)) {\n                            addError(r, new TestError(this, Severity.WARNING, RelationChecker.ROLE_VERIF_PROBLEM_MSG,\n                                    tr(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    MessageFormat.format(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    WRONG_MEMBER_ROLE, Collections.singleton(r), Collections.singleton(member.getMember())));\n                        }\n                    }\n                }\n            }\n\n            List<List<Node>> innerWays = joinWays(polygon.getInnerWays()); // Side effect - sets nonClosedWays\n            List<List<Node>> outerWays = joinWays(polygon.getOuterWays());\n            if (styles != null) {\n\n                AreaElemStyle area = ElemStyles.getAreaElemStyle(r, false);\n                boolean areaStyle = area != null;\n                // If area style was not found for relation then use style of ways\n                if (area == null) {\n                    for (Way w : polygon.getOuterWays()) {\n                        area = ElemStyles.getAreaElemStyle(w, true);\n                        if (area != null) {\n                            break;\n                        }\n                    }\n                    if(area == null)\n                        addError(r, new TestError(this, Severity.OTHER, tr(\"No style for multipolygon\"), NO_STYLE, r));\n                    else\n                        addError(r, new TestError(this, Severity.OTHER, tr(\"No style in multipolygon relation\"),\n                            NO_STYLE_POLYGON, r));\n                }\n\n                if (area != null) {\n                    for (Way wInner : polygon.getInnerWays()) {\n                        AreaElemStyle areaInner = ElemStyles.getAreaElemStyle(wInner, false);\n\n                        if (areaInner != null && area.equals(areaInner)) {\n                            List<OsmPrimitive> l = new ArrayList<>();\n                            l.add(r);\n                            l.add(wInner);\n                            addError(r, new TestError(this, Severity.WARNING, tr(\"Style for inner way equals multipolygon\"),\n                                    INNER_STYLE_MISMATCH, l, Collections.singletonList(wInner)));\n                        }\n                    }\n                    if(!areaStyle) {\n                        for (Way wOuter : polygon.getOuterWays()) {\n                            AreaElemStyle areaOuter = ElemStyles.getAreaElemStyle(wOuter, false);\n                            if (areaOuter != null && !area.equals(areaOuter)) {\n                                List<OsmPrimitive> l = new ArrayList<>();\n                                l.add(r);\n                                l.add(wOuter);\n                                addError(r, new TestError(this, Severity.WARNING, tr(\"Style for outer way mismatches\"),\n                                OUTER_STYLE_MISMATCH, l, Collections.singletonList(wOuter)));\n                            }\n                        }\n                    }\n                }\n            }\n\n            List<Node> openNodes = new LinkedList<>();\n            for (List<Node> w : nonClosedWays) {\n                if (w.size()<1) continue;\n                openNodes.add(w.get(0));\n                openNodes.add(w.get(w.size() - 1));\n            }\n            if (!openNodes.isEmpty()) {\n                List<OsmPrimitive> primitives = new LinkedList<>();\n                primitives.add(r);\n                primitives.addAll(openNodes);\n                Arrays.asList(openNodes, r);\n                addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon is not closed\"), NON_CLOSED_WAY,\n                        primitives, openNodes));\n            }\n\n            // For painting is used Polygon class which works with ints only. For validation we need more precision\n            List<GeneralPath> outerPolygons = createPolygons(outerWays);\n            for (List<Node> pdInner : innerWays) {\n                boolean outside = true;\n                boolean crossing = false;\n                List<Node> outerWay = null;\n                for (int i=0; i<outerWays.size(); i++) {\n                    GeneralPath outer = outerPolygons.get(i);\n                    Intersection intersection = getPolygonIntersection(outer, pdInner);\n                    outside = outside & intersection == Intersection.OUTSIDE;\n                    if (intersection == Intersection.CROSSING) {\n                        crossing = true;\n                        outerWay = outerWays.get(i);\n                    }\n                }\n                if (outside || crossing) {\n                    List<List<Node>> highlights = new ArrayList<>();\n                    highlights.add(pdInner);\n                    if (outside) {\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon inner way is outside\"), INNER_WAY_OUTSIDE, Collections.singletonList(r), highlights));\n                    } else if (crossing) {\n                        highlights.add(outerWay);\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Intersection between multipolygon ways\"), CROSSING_WAYS, Collections.singletonList(r), highlights));\n                    }\n                }\n            }\n        }\n    }","id":47887,"modified_method":"@Override\n    public void visit(Relation r) {\n        nonClosedWays.clear();\n        if (r.isMultipolygon()) {\n            checkMembersAndRoles(r);\n\n            Multipolygon polygon = MultipolygonCache.getInstance().get(Main.map.mapView, r);\n\n            boolean hasOuterWay = false;\n            for (RelationMember m : r.getMembers()) {\n                if (\"outer\".equals(m.getRole())) {\n                    hasOuterWay = true;\n                    break;\n                }\n            }\n            if (!hasOuterWay) {\n                addError(r, new TestError(this, Severity.WARNING, tr(\"No outer way for multipolygon\"), MISSING_OUTER_WAY, r));\n            }\n\n            if (r.hasIncompleteMembers()) {\n                return; // Rest of checks is only for complete multipolygons\n            }\n\n            // Create new multipolygon using the logics from CreateMultipolygonAction and see if roles match.\n            final Pair<Relation, Relation> newMP = CreateMultipolygonAction.createMultipolygonRelation(r.getMemberPrimitives(Way.class), false);\n            if (newMP != null) {\n                for (RelationMember member : r.getMembers()) {\n                    final Collection<RelationMember> memberInNewMP = newMP.b.getMembersFor(Collections.singleton(member.getMember()));\n                    if (memberInNewMP != null && !memberInNewMP.isEmpty()) {\n                        final String roleInNewMP = memberInNewMP.iterator().next().getRole();\n                        if (!member.getRole().equals(roleInNewMP)) {\n                            addError(r, new TestError(this, Severity.WARNING, RelationChecker.ROLE_VERIF_PROBLEM_MSG,\n                                    tr(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    MessageFormat.format(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    WRONG_MEMBER_ROLE, Collections.singleton(r), Collections.singleton(member.getMember())));\n                        }\n                    }\n                }\n            }\n\n            List<List<Node>> innerWays = joinWays(polygon.getInnerWays()); // Side effect - sets nonClosedWays\n            List<List<Node>> outerWays = joinWays(polygon.getOuterWays());\n            if (styles != null) {\n\n                AreaElemStyle area = ElemStyles.getAreaElemStyle(r, false);\n                boolean areaStyle = area != null;\n                // If area style was not found for relation then use style of ways\n                if (area == null) {\n                    for (Way w : polygon.getOuterWays()) {\n                        area = ElemStyles.getAreaElemStyle(w, true);\n                        if (area != null) {\n                            break;\n                        }\n                    }\n                    if (!\"boundary\".equals(r.get(\"type\"))) {\n                        if (area == null) {\n                            addError(r, new TestError(this, Severity.OTHER, tr(\"No style for multipolygon\"), NO_STYLE, r));\n                        } else {\n                            addError(r, new TestError(this, Severity.OTHER, tr(\"No style in multipolygon relation\"),\n                                NO_STYLE_POLYGON, r));\n                        }\n                    }\n                }\n\n                if (area != null) {\n                    for (Way wInner : polygon.getInnerWays()) {\n                        AreaElemStyle areaInner = ElemStyles.getAreaElemStyle(wInner, false);\n\n                        if (areaInner != null && area.equals(areaInner)) {\n                            List<OsmPrimitive> l = new ArrayList<>();\n                            l.add(r);\n                            l.add(wInner);\n                            addError(r, new TestError(this, Severity.WARNING, tr(\"Style for inner way equals multipolygon\"),\n                                    INNER_STYLE_MISMATCH, l, Collections.singletonList(wInner)));\n                        }\n                    }\n                    if(!areaStyle) {\n                        for (Way wOuter : polygon.getOuterWays()) {\n                            AreaElemStyle areaOuter = ElemStyles.getAreaElemStyle(wOuter, false);\n                            if (areaOuter != null && !area.equals(areaOuter)) {\n                                List<OsmPrimitive> l = new ArrayList<>();\n                                l.add(r);\n                                l.add(wOuter);\n                                addError(r, new TestError(this, Severity.WARNING, tr(\"Style for outer way mismatches\"),\n                                OUTER_STYLE_MISMATCH, l, Collections.singletonList(wOuter)));\n                            }\n                        }\n                    }\n                }\n            }\n\n            List<Node> openNodes = new LinkedList<>();\n            for (List<Node> w : nonClosedWays) {\n                if (w.size()<1) continue;\n                openNodes.add(w.get(0));\n                openNodes.add(w.get(w.size() - 1));\n            }\n            if (!openNodes.isEmpty()) {\n                List<OsmPrimitive> primitives = new LinkedList<>();\n                primitives.add(r);\n                primitives.addAll(openNodes);\n                Arrays.asList(openNodes, r);\n                addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon is not closed\"), NON_CLOSED_WAY,\n                        primitives, openNodes));\n            }\n\n            // For painting is used Polygon class which works with ints only. For validation we need more precision\n            List<GeneralPath> outerPolygons = createPolygons(outerWays);\n            for (List<Node> pdInner : innerWays) {\n                boolean outside = true;\n                boolean crossing = false;\n                List<Node> outerWay = null;\n                for (int i=0; i<outerWays.size(); i++) {\n                    GeneralPath outer = outerPolygons.get(i);\n                    Intersection intersection = getPolygonIntersection(outer, pdInner);\n                    outside = outside & intersection == Intersection.OUTSIDE;\n                    if (intersection == Intersection.CROSSING) {\n                        crossing = true;\n                        outerWay = outerWays.get(i);\n                    }\n                }\n                if (outside || crossing) {\n                    List<List<Node>> highlights = new ArrayList<>();\n                    highlights.add(pdInner);\n                    if (outside) {\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon inner way is outside\"), INNER_WAY_OUTSIDE, Collections.singletonList(r), highlights));\n                    } else if (crossing) {\n                        highlights.add(outerWay);\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Intersection between multipolygon ways\"), CROSSING_WAYS, Collections.singletonList(r), highlights));\n                    }\n                }\n            }\n        }\n    }","commit_id":"5d612098770c4ada67c90ac2abdf485db56bc708","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void visit(Relation r) {\n        nonClosedWays.clear();\n        if (r.isMultipolygon()) {\n            checkMembersAndRoles(r);\n\n            Multipolygon polygon = MultipolygonCache.getInstance().get(Main.map.mapView, r);\n\n            boolean hasOuterWay = false;\n            for (RelationMember m : r.getMembers()) {\n                if (\"outer\".equals(m.getRole())) {\n                    hasOuterWay = true;\n                    break;\n                }\n            }\n            if (!hasOuterWay) {\n                addError(r, new TestError(this, Severity.WARNING, tr(\"No outer way for multipolygon\"), MISSING_OUTER_WAY, r));\n            }\n\n            if (r.hasIncompleteMembers()) {\n                return; // Rest of checks is only for complete multipolygons\n            }\n\n            // Create new multipolygon using the logics from CreateMultipolygonAction and see if roles match.\n            final Pair<Relation, Relation> newMP = CreateMultipolygonAction.createMultipolygonRelation(r.getMemberPrimitives(Way.class), false);\n            if (newMP != null) {\n                for (RelationMember member : r.getMembers()) {\n                    final Collection<RelationMember> memberInNewMP = newMP.b.getMembersFor(Collections.singleton(member.getMember()));\n                    if (memberInNewMP != null && !memberInNewMP.isEmpty()) {\n                        final String roleInNewMP = memberInNewMP.iterator().next().getRole();\n                        if (!member.getRole().equals(roleInNewMP)) {\n                            addError(r, new TestError(this, Severity.WARNING, RelationChecker.ROLE_VERIF_PROBLEM_MSG,\n                                    tr(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    MessageFormat.format(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    WRONG_MEMBER_ROLE, Collections.singleton(r), Collections.singleton(member.getMember())));\n                        }\n                    }\n                }\n            }\n\n            List<List<Node>> innerWays = joinWays(polygon.getInnerWays()); // Side effect - sets nonClosedWays\n            List<List<Node>> outerWays = joinWays(polygon.getOuterWays());\n            if (styles != null) {\n\n                AreaElemStyle area = ElemStyles.getAreaElemStyle(r, false);\n                boolean areaStyle = area != null;\n                // If area style was not found for relation then use style of ways\n                if (area == null) {\n                    for (Way w : polygon.getOuterWays()) {\n                        area = ElemStyles.getAreaElemStyle(w, true);\n                        if (area != null) {\n                            break;\n                        }\n                    }\n                    if (!\"boundary\".equals(r.get(\"type\"))) {\n                        if (area == null) {\n                            addError(r, new TestError(this, Severity.OTHER, tr(\"No style for multipolygon\"), NO_STYLE, r));\n                        } else {\n                            addError(r, new TestError(this, Severity.OTHER, tr(\"No style in multipolygon relation\"),\n                                NO_STYLE_POLYGON, r));\n                        }\n                    }\n                }\n\n                if (area != null) {\n                    for (Way wInner : polygon.getInnerWays()) {\n                        AreaElemStyle areaInner = ElemStyles.getAreaElemStyle(wInner, false);\n\n                        if (areaInner != null && area.equals(areaInner)) {\n                            List<OsmPrimitive> l = new ArrayList<>();\n                            l.add(r);\n                            l.add(wInner);\n                            addError(r, new TestError(this, Severity.WARNING, tr(\"Style for inner way equals multipolygon\"),\n                                    INNER_STYLE_MISMATCH, l, Collections.singletonList(wInner)));\n                        }\n                    }\n                    for (Way wOuter : polygon.getOuterWays()) {\n                        AreaElemStyle areaOuter = ElemStyles.getAreaElemStyle(wOuter, false);\n                        if (areaOuter != null && !area.equals(areaOuter)) {\n                            List<OsmPrimitive> l = new ArrayList<>();\n                            l.add(r);\n                            l.add(wOuter);\n                            addError(r, new TestError(this, Severity.WARNING, !areaStyle ? tr(\"Style for outer way mismatches\")\n                            : tr(\"Style for outer way mismatches polygon\"),\n                            OUTER_STYLE_MISMATCH, l, Collections.singletonList(wOuter)));\n                        }\n                    }\n                }\n            }\n\n            List<Node> openNodes = new LinkedList<>();\n            for (List<Node> w : nonClosedWays) {\n                if (w.size()<1) continue;\n                openNodes.add(w.get(0));\n                openNodes.add(w.get(w.size() - 1));\n            }\n            if (!openNodes.isEmpty()) {\n                List<OsmPrimitive> primitives = new LinkedList<>();\n                primitives.add(r);\n                primitives.addAll(openNodes);\n                Arrays.asList(openNodes, r);\n                addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon is not closed\"), NON_CLOSED_WAY,\n                        primitives, openNodes));\n            }\n\n            // For painting is used Polygon class which works with ints only. For validation we need more precision\n            List<GeneralPath> outerPolygons = createPolygons(outerWays);\n            for (List<Node> pdInner : innerWays) {\n                boolean outside = true;\n                boolean crossing = false;\n                List<Node> outerWay = null;\n                for (int i=0; i<outerWays.size(); i++) {\n                    GeneralPath outer = outerPolygons.get(i);\n                    Intersection intersection = getPolygonIntersection(outer, pdInner);\n                    outside = outside & intersection == Intersection.OUTSIDE;\n                    if (intersection == Intersection.CROSSING) {\n                        crossing = true;\n                        outerWay = outerWays.get(i);\n                    }\n                }\n                if (outside || crossing) {\n                    List<List<Node>> highlights = new ArrayList<>();\n                    highlights.add(pdInner);\n                    if (outside) {\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon inner way is outside\"), INNER_WAY_OUTSIDE, Collections.singletonList(r), highlights));\n                    } else if (crossing) {\n                        highlights.add(outerWay);\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Intersection between multipolygon ways\"), CROSSING_WAYS, Collections.singletonList(r), highlights));\n                    }\n                }\n            }\n        }\n    }","id":47888,"modified_method":"@Override\n    public void visit(Relation r) {\n        nonClosedWays.clear();\n        if (r.isMultipolygon()) {\n            checkMembersAndRoles(r);\n\n            Multipolygon polygon = MultipolygonCache.getInstance().get(Main.map.mapView, r);\n\n            boolean hasOuterWay = false;\n            for (RelationMember m : r.getMembers()) {\n                if (\"outer\".equals(m.getRole())) {\n                    hasOuterWay = true;\n                    break;\n                }\n            }\n            if (!hasOuterWay) {\n                addError(r, new TestError(this, Severity.WARNING, tr(\"No outer way for multipolygon\"), MISSING_OUTER_WAY, r));\n            }\n\n            if (r.hasIncompleteMembers()) {\n                return; // Rest of checks is only for complete multipolygons\n            }\n\n            // Create new multipolygon using the logics from CreateMultipolygonAction and see if roles match.\n            final Pair<Relation, Relation> newMP = CreateMultipolygonAction.createMultipolygonRelation(r.getMemberPrimitives(Way.class), false);\n            if (newMP != null) {\n                for (RelationMember member : r.getMembers()) {\n                    final Collection<RelationMember> memberInNewMP = newMP.b.getMembersFor(Collections.singleton(member.getMember()));\n                    if (memberInNewMP != null && !memberInNewMP.isEmpty()) {\n                        final String roleInNewMP = memberInNewMP.iterator().next().getRole();\n                        if (!member.getRole().equals(roleInNewMP)) {\n                            addError(r, new TestError(this, Severity.WARNING, RelationChecker.ROLE_VERIF_PROBLEM_MSG,\n                                    tr(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    MessageFormat.format(\"Role for ''{0}'' should be ''{1}''\",\n                                            member.getMember().getDisplayName(DefaultNameFormatter.getInstance()), roleInNewMP),\n                                    WRONG_MEMBER_ROLE, Collections.singleton(r), Collections.singleton(member.getMember())));\n                        }\n                    }\n                }\n            }\n\n            List<List<Node>> innerWays = joinWays(polygon.getInnerWays()); // Side effect - sets nonClosedWays\n            List<List<Node>> outerWays = joinWays(polygon.getOuterWays());\n            if (styles != null) {\n\n                AreaElemStyle area = ElemStyles.getAreaElemStyle(r, false);\n                boolean areaStyle = area != null;\n                // If area style was not found for relation then use style of ways\n                if (area == null) {\n                    for (Way w : polygon.getOuterWays()) {\n                        area = ElemStyles.getAreaElemStyle(w, true);\n                        if (area != null) {\n                            break;\n                        }\n                    }\n                    if (!\"boundary\".equals(r.get(\"type\"))) {\n                        if (area == null) {\n                            addError(r, new TestError(this, Severity.OTHER, tr(\"No style for multipolygon\"), NO_STYLE, r));\n                        } else {\n                            addError(r, new TestError(this, Severity.OTHER, tr(\"No style in multipolygon relation\"),\n                                NO_STYLE_POLYGON, r));\n                        }\n                    }\n                }\n\n                if (area != null) {\n                    for (Way wInner : polygon.getInnerWays()) {\n                        AreaElemStyle areaInner = ElemStyles.getAreaElemStyle(wInner, false);\n\n                        if (areaInner != null && area.equals(areaInner)) {\n                            List<OsmPrimitive> l = new ArrayList<>();\n                            l.add(r);\n                            l.add(wInner);\n                            addError(r, new TestError(this, Severity.WARNING, tr(\"Style for inner way equals multipolygon\"),\n                                    INNER_STYLE_MISMATCH, l, Collections.singletonList(wInner)));\n                        }\n                    }\n                    for (Way wOuter : polygon.getOuterWays()) {\n                        AreaElemStyle areaOuter = ElemStyles.getAreaElemStyle(wOuter, false);\n                        if (areaOuter != null) {\n                            List<OsmPrimitive> l = new ArrayList<>();\n                            l.add(r);\n                            l.add(wOuter);\n                            if (!area.equals(areaOuter)) {\n                                addError(r, new TestError(this, Severity.WARNING, !areaStyle ? tr(\"Style for outer way mismatches\")\n                                : tr(\"Style for outer way mismatches polygon\"),\n                                OUTER_STYLE_MISMATCH, l, Collections.singletonList(wOuter)));\n                            } else if (areaStyle) { /* style on outer way of multipolygon, but equal to polygon */\n                                addError(r, new TestError(this, Severity.WARNING, tr(\"Style on outer way\"), OUTER_STYLE,\n                                l, Collections.singletonList(wOuter)));\n                            }\n                        }\n                    }\n                    if(!areaStyle) { /* old style multipolygon - solve: copy tags from outer way to multipolygon */\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Style is on way and not on multipolygon\"), STYLE_ON_WAY, r));\n                    }\n                }\n            }\n\n            List<Node> openNodes = new LinkedList<>();\n            for (List<Node> w : nonClosedWays) {\n                if (w.size()<1) continue;\n                openNodes.add(w.get(0));\n                openNodes.add(w.get(w.size() - 1));\n            }\n            if (!openNodes.isEmpty()) {\n                List<OsmPrimitive> primitives = new LinkedList<>();\n                primitives.add(r);\n                primitives.addAll(openNodes);\n                Arrays.asList(openNodes, r);\n                addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon is not closed\"), NON_CLOSED_WAY,\n                        primitives, openNodes));\n            }\n\n            // For painting is used Polygon class which works with ints only. For validation we need more precision\n            List<GeneralPath> outerPolygons = createPolygons(outerWays);\n            for (List<Node> pdInner : innerWays) {\n                boolean outside = true;\n                boolean crossing = false;\n                List<Node> outerWay = null;\n                for (int i=0; i<outerWays.size(); i++) {\n                    GeneralPath outer = outerPolygons.get(i);\n                    Intersection intersection = getPolygonIntersection(outer, pdInner);\n                    outside = outside & intersection == Intersection.OUTSIDE;\n                    if (intersection == Intersection.CROSSING) {\n                        crossing = true;\n                        outerWay = outerWays.get(i);\n                    }\n                }\n                if (outside || crossing) {\n                    List<List<Node>> highlights = new ArrayList<>();\n                    highlights.add(pdInner);\n                    if (outside) {\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon inner way is outside\"), INNER_WAY_OUTSIDE, Collections.singletonList(r), highlights));\n                    } else if (crossing) {\n                        highlights.add(outerWay);\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Intersection between multipolygon ways\"), CROSSING_WAYS, Collections.singletonList(r), highlights));\n                    }\n                }\n            }\n        }\n    }","commit_id":"cbced4485f0cdc9735b7d2cf66c4ac6235af0835","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void checkComponentProperties(Module module, IComponent component, FormErrorCollector collector) {\n    if (FormInspectionUtil.isComponentClass(module, component, JRadioButton.class)) {\n      final IRootContainer root = FormEditingUtil.getRoot(component);\n      if (root == null) return;\n      if (root.getButtonGroupName(component) == null) {\n        IContainer parent = component.getParentContainer();\n        for(int i=0; i<parent.getComponentCount(); i++) {\n          IComponent child = parent.getComponent(i);\n          if (child != component &&\n              FormInspectionUtil.isComponentClass(module, child, JRadioButton.class) &&\n              root.getButtonGroupName(child) == null) {\n            final GridConstraints c1 = component.getConstraints();\n            final GridConstraints c2 = child.getConstraints();\n            if ((c1.getRow() == c2.getRow() && Math.abs(c1.getColumn() - c2.getColumn()) == 1) ||\n                (c1.getColumn() == c2.getColumn() && Math.abs(c1.getRow() - c2.getRow()) == 1)) {\n              collector.addError(getID(), null, UIDesignerBundle.message(\"inspection.no.button.group.error\"),\n                                 new EditorQuickFixProvider() {\n                                   public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n                                     return new MyQuickFix(editor, component, c1.getColumn() == c2.getColumn());\n                                   }\n                                 });\n              break;\n            }\n          }\n        }\n      }\n    }\n  }","id":47889,"modified_method":"protected void checkComponentProperties(Module module, IComponent component, FormErrorCollector collector) {\n    if (FormInspectionUtil.isComponentClass(module, component, JRadioButton.class)) {\n      final IRootContainer root = FormEditingUtil.getRoot(component);\n      if (root == null) return;\n      if (root.getButtonGroupName(component) == null) {\n        EditorQuickFixProvider quickFixProvider = null;\n        IContainer parent = component.getParentContainer();\n        for(int i=0; i<parent.getComponentCount(); i++) {\n          IComponent child = parent.getComponent(i);\n          if (child != component &&\n              FormInspectionUtil.isComponentClass(module, child, JRadioButton.class) &&\n              root.getButtonGroupName(child) == null) {\n            final GridConstraints c1 = component.getConstraints();\n            final GridConstraints c2 = child.getConstraints();\n            if ((c1.getRow() == c2.getRow() && Math.abs(c1.getColumn() - c2.getColumn()) == 1) ||\n                (c1.getColumn() == c2.getColumn() && Math.abs(c1.getRow() - c2.getRow()) == 1)) {\n              quickFixProvider = new EditorQuickFixProvider() {\n                                   public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n                                     return new MyQuickFix(editor, component, c1.getColumn() == c2.getColumn());\n                                   }\n                                 };\n              break;\n            }\n          }\n        }\n        collector.addError(getID(), null, UIDesignerBundle.message(\"inspection.no.button.group.error\"), quickFixProvider);\n      }\n    }\n  }","commit_id":"3303e4ce6383e66d21ed4c7f05c4269c7aa86fd5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkClassForAbstractAndFinal(ClassNode node) {\n        if (!Modifier.isAbstract(node.getModifiers())) return;\n        if (!Modifier.isFinal(node.getModifiers())) return;\n        addError(\"The class '\" + node.getName() + \"' must not be both final and abstract.\", node);\n    }","id":47890,"modified_method":"private void checkClassForAbstractAndFinal(ClassNode node) {\n        if (!Modifier.isAbstract(node.getModifiers())) return;\n        if (!Modifier.isFinal(node.getModifiers())) return;\n        if (node.isInterface()) {\n            addError(\"The interface '\" + node.getName() + \"' must not be final. It is by definition abstract.\", node);\n        } else {\n            addError(\"The class '\" + node.getName() + \"' must not be both final and abstract.\", node);\n\n        }\n    }","commit_id":"a0c6c27a055715a9387313e672f4965a449046a8","url":"https://github.com/apache/groovy"},{"original_method":"public void testDetectsFinalAbstract() throws Exception {\n        checkVisitErrors(\"FinalClass\", ACC_FINAL, false);\n        checkVisitErrors(\"AbstractClass\", ACC_ABSTRACT, false);\n        checkVisitErrors(ABSTRACT_FINAL_CLASS, ACC_ABSTRACT | ACC_FINAL, true);\n        checkErrorMessage(EXPECTED_ERROR_MESSAGE);\n    }","id":47891,"modified_method":"public void testDetectsFinalAbstractClass() throws Exception {\n        checkVisitErrors(\"FinalClass\", ACC_FINAL, false);\n        checkVisitErrors(\"AbstractClass\", ACC_ABSTRACT, false);\n        checkVisitErrors(ABSTRACT_FINAL_CLASS, ACC_ABSTRACT | ACC_FINAL, true);\n        checkErrorMessage(EXPECTED_ERROR_MESSAGE_FOR_CLASS);\n    }","commit_id":"a0c6c27a055715a9387313e672f4965a449046a8","url":"https://github.com/apache/groovy"},{"original_method":"public void addRoots(final VirtualFile... files) {\n    if (files.length == 0) return;\n\n    ModifiableRootModel rootModel = myContext.getModifiableRootModel();\n    final Project project = myContext.getProject();\n    if (rootModel == null || project == null) {\n      myAddedRoots.addAll(Arrays.asList(files));\n    }\n    else {\n      Library library = new WriteAction<Library>() {\n        protected void run(final Result<Library> result) {\n          result.setResult(createLibrary(files));\n        }\n      }.execute().getResultObject();\n      rootModel.addLibraryEntry(library);\n    }\n    onChange();\n  }","id":47892,"modified_method":"public void addRoots(final VirtualFile... files) {\n    if (files.length == 0) return;\n\n    ModifiableRootModel rootModel = myContext.getModifiableRootModel();\n    final Project project = myContext.getProject();\n    if (rootModel == null || project == null) {\n      myAddedRoots.addAll(Arrays.asList(files));\n    }\n    else {\n      Library library = new WriteAction<Library>() {\n        protected void run(final Result<Library> result) {\n          result.setResult(createLibrary(files));\n        }\n      }.execute().getResultObject();\n      if (library != null) {\n        rootModel.addLibraryEntry(library);\n      }\n    }\n    onChange();\n  }","commit_id":"a7d8f9b55ab50e5439518ba66d91f45253012bf0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected ClasspathTableItem<?> createTableItem(final Library item) {\n    // clear invalid order entry corresponding to added library if any\n    final ModifiableRootModel rootModel = myClasspathPanel.getRootModel();\n    final OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        if (item.getName().equals(((LibraryOrderEntry)orderEntry).getLibraryName())) {\n          if (orderEntry.isValid()) {\n            Messages.showErrorDialog(ProjectBundle.message(\"classpath.message.library.already.added\",item.getName()),\n                                     ProjectBundle.message(\"classpath.title.adding.dependency\"));\n            return null;\n          } else {\n            rootModel.removeOrderEntry(orderEntry);\n          }\n        }\n      }\n    }\n    return ClasspathTableItem.createLibItem(rootModel.addLibraryEntry(item), myContext);\n  }","id":47893,"modified_method":"@Nullable\n  protected ClasspathTableItem<?> createTableItem(final Library item) {\n    // clear invalid order entry corresponding to added library if any\n    final ModifiableRootModel rootModel = myClasspathPanel.getRootModel();\n    final OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        if (item.getName().equals(((LibraryOrderEntry)orderEntry).getLibraryName())) {\n          if (orderEntry.isValid()) {\n            Messages.showErrorDialog(ProjectBundle.message(\"classpath.message.library.already.added\",item.getName()),\n                                     ProjectBundle.message(\"classpath.title.adding.dependency\"));\n            return null;\n          } else {\n            rootModel.removeOrderEntry(orderEntry);\n          }\n        }\n      }\n    }\n    final LibraryOrderEntry orderEntry = rootModel.addLibraryEntry(item);\n    final LibraryTable table = item.getTable();\n    if (table instanceof LibraryTableBase) {\n      orderEntry.setScope(((LibraryTableBase)table).getDefaultDependencyScope());\n    }\n    return ClasspathTableItem.createLibItem(orderEntry, myContext);\n  }","commit_id":"e2272243e2bdd3012824934e27ca100ccbe54f8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected ClasspathTableItem<?> createTableItem(final Library item) {\n    // clear invalid order entry corresponding to added library if any\n    final ModifiableRootModel rootModel = myClasspathPanel.getRootModel();\n    final OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)orderEntry;\n        if (item.equals(libraryOrderEntry.getLibrary())) {\n          return ClasspathTableItem.createLibItem(libraryOrderEntry, myContext);\n        }\n        String name = item.getName();\n        if (name != null && name.equals(libraryOrderEntry.getLibraryName())) {\n          if (orderEntry.isValid()) {\n            Messages.showErrorDialog(ProjectBundle.message(\"classpath.message.library.already.added\", item.getName()),\n                                     ProjectBundle.message(\"classpath.title.adding.dependency\"));\n            return null;\n          }\n          else {\n            rootModel.removeOrderEntry(orderEntry);\n          }\n        }\n      }\n    }\n    final LibraryOrderEntry orderEntry = rootModel.addLibraryEntry(item);\n    DependencyScope defaultScope = getDefaultScope(item);\n    if (defaultScope != null) {\n      orderEntry.setScope(defaultScope);\n    }\n    return ClasspathTableItem.createLibItem(orderEntry, myContext);\n  }","id":47894,"modified_method":"@Override\n  @Nullable\n  protected ClasspathTableItem<?> createTableItem(final Library item) {\n    // clear invalid order entry corresponding to added library if any\n    final ModifiableRootModel rootModel = myClasspathPanel.getRootModel();\n    final OrderEntry[] orderEntries = rootModel.getOrderEntries();\n    for (OrderEntry orderEntry : orderEntries) {\n      if (orderEntry instanceof LibraryOrderEntry) {\n        final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)orderEntry;\n        if (item.equals(libraryOrderEntry.getLibrary())) {\n          return ClasspathTableItem.createLibItem(libraryOrderEntry, myContext);\n        }\n        String name = item.getName();\n        if (name != null && name.equals(libraryOrderEntry.getLibraryName())) {\n          if (orderEntry.isValid()) {\n            Messages.showErrorDialog(ProjectBundle.message(\"classpath.message.library.already.added\", item.getName()),\n                                     ProjectBundle.message(\"classpath.title.adding.dependency\"));\n            return null;\n          }\n          else {\n            rootModel.removeOrderEntry(orderEntry);\n          }\n        }\n      }\n    }\n    final LibraryOrderEntry orderEntry = rootModel.addLibraryEntry(item);\n    orderEntry.setScope(LibraryDependencyScopeSuggester.getDefaultScope(item));\n    return ClasspathTableItem.createLibItem(orderEntry, myContext);\n  }","commit_id":"b5c1f0eaa841d181c1750e794ed3609eeb49243f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Library addLibraries(final @NotNull ModifiableRootModel rootModel, final @NotNull List<Library> addedLibraries,\n                              final @Nullable LibrariesContainer librariesContainer) {\n    Library library = createLibrary(rootModel, librariesContainer);\n\n    if (library != null) {\n      addedLibraries.add(library);\n      if (getLibraryLevel() != LibrariesContainer.LibraryLevel.MODULE) {\n        rootModel.addLibraryEntry(library);\n      }\n    }\n    if (mySelectedLibrary != null) {\n      addedLibraries.add(mySelectedLibrary);\n      rootModel.addLibraryEntry(mySelectedLibrary);\n    }\n    return library;\n  }","id":47895,"modified_method":"@Nullable\n  public Library addLibraries(final @NotNull ModifiableRootModel rootModel, final @NotNull List<Library> addedLibraries,\n                              final @Nullable LibrariesContainer librariesContainer) {\n    Library library = createLibrary(rootModel, librariesContainer);\n\n    if (library != null) {\n      addedLibraries.add(library);\n      DependencyScope scope = LibraryDependencyScopeSuggester.getDefaultScope(library);\n      if (getLibraryLevel() != LibrariesContainer.LibraryLevel.MODULE) {\n        rootModel.addLibraryEntry(library).setScope(scope);\n      }\n      else {\n        LibraryOrderEntry orderEntry = rootModel.findLibraryOrderEntry(library);\n        assert orderEntry != null;\n        orderEntry.setScope(scope);\n      }\n    }\n    if (mySelectedLibrary != null) {\n      addedLibraries.add(mySelectedLibrary);\n      rootModel.addLibraryEntry(mySelectedLibrary).setScope(LibraryDependencyScopeSuggester.getDefaultScope(mySelectedLibrary));\n    }\n    return library;\n  }","commit_id":"b5c1f0eaa841d181c1750e794ed3609eeb49243f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean expressionAssignsVariableOrFails(@Nullable PsiExpression expression, PsiVariable variable,\n                                                          @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiThisExpression ||\n        expression instanceof PsiLiteralExpression ||\n        expression instanceof PsiSuperExpression ||\n        expression instanceof PsiClassObjectAccessExpression ||\n        expression instanceof PsiReferenceExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression unparenthesizedExpression = parenthesizedExpression.getExpression();\n      return expressionAssignsVariableOrFails(unparenthesizedExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;\n      return methodCallAssignsVariableOrFails(methodCallExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)expression;\n      return newExpressionAssignsVariableOrFails(newExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayInitializerExpression) {\n      final PsiArrayInitializerExpression array = (PsiArrayInitializerExpression)expression;\n      final PsiExpression[] initializers = array.getInitializers();\n      for (final PsiExpression initializer : initializers) {\n        if (expressionAssignsVariableOrFails(initializer, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCast = (PsiTypeCastExpression)expression;\n      final PsiExpression operand = typeCast.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayAccessExpression) {\n      final PsiArrayAccessExpression accessExpression = (PsiArrayAccessExpression)expression;\n      final PsiExpression arrayExpression = accessExpression.getArrayExpression();\n      final PsiExpression indexExpression = accessExpression.getIndexExpression();\n      return expressionAssignsVariableOrFails(arrayExpression, variable, checkedMethods, strict) ||\n             expressionAssignsVariableOrFails(indexExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression = (PsiPrefixExpression)expression;\n      final PsiExpression operand = prefixExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression = (PsiPostfixExpression)expression;\n      final PsiExpression operand = postfixExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional = (PsiConditionalExpression)expression;\n      final PsiExpression condition = conditional.getCondition();\n      if (expressionAssignsVariableOrFails(condition, variable, checkedMethods, strict)) {\n        return true;\n      }\n      final PsiExpression thenExpression = conditional.getThenExpression();\n      final PsiExpression elseExpression = conditional.getElseExpression();\n      return expressionAssignsVariableOrFails(thenExpression, variable, checkedMethods, strict) &&\n             expressionAssignsVariableOrFails(elseExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment = (PsiAssignmentExpression)expression;\n      final PsiExpression lhs = assignment.getLExpression();\n      if (expressionAssignsVariableOrFails(lhs, variable, checkedMethods, strict)) {\n        return true;\n      }\n      final PsiExpression rhs = assignment.getRExpression();\n      if (expressionAssignsVariableOrFails(rhs, variable, checkedMethods, strict)) {\n        return true;\n      }\n      if (lhs instanceof PsiReferenceExpression) {\n        final PsiElement element = ((PsiReference)lhs).resolve();\n        if (element != null && element.equals(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression = (PsiInstanceOfExpression)expression;\n      final PsiExpression operand = instanceOfExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else {\n      return false;\n    }\n  }","id":47896,"modified_method":"private static boolean expressionAssignsVariableOrFails(@Nullable PsiExpression expression, PsiVariable variable,\n                                                          @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiThisExpression ||\n        expression instanceof PsiLiteralExpression ||\n        expression instanceof PsiSuperExpression ||\n        expression instanceof PsiClassObjectAccessExpression ||\n        expression instanceof PsiReferenceExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      return expressionAssignsVariableOrFails(parenthesizedExpression.getExpression(), variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;\n      return methodCallAssignsVariableOrFails(methodCallExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)expression;\n      return newExpressionAssignsVariableOrFails(newExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayInitializerExpression) {\n      final PsiArrayInitializerExpression array = (PsiArrayInitializerExpression)expression;\n      for (final PsiExpression initializer : array.getInitializers()) {\n        if (expressionAssignsVariableOrFails(initializer, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCast = (PsiTypeCastExpression)expression;\n      return expressionAssignsVariableOrFails(typeCast.getOperand(), variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayAccessExpression) {\n      final PsiArrayAccessExpression accessExpression = (PsiArrayAccessExpression)expression;\n      return expressionAssignsVariableOrFails(accessExpression.getArrayExpression(), variable, checkedMethods, strict) ||\n             expressionAssignsVariableOrFails(accessExpression.getIndexExpression(), variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression = (PsiPrefixExpression)expression;\n      return expressionAssignsVariableOrFails(prefixExpression.getOperand(), variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression = (PsiPostfixExpression)expression;\n      return expressionAssignsVariableOrFails(postfixExpression.getOperand(), variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      for (PsiExpression operand : polyadicExpression.getOperands()) {\n        if (expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional = (PsiConditionalExpression)expression;\n      if (expressionAssignsVariableOrFails(conditional.getCondition(), variable, checkedMethods, strict)) {\n        return true;\n      }\n      return expressionAssignsVariableOrFails(conditional.getThenExpression(), variable, checkedMethods, strict) &&\n             expressionAssignsVariableOrFails(conditional.getElseExpression(), variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment = (PsiAssignmentExpression)expression;\n      final PsiExpression lhs = assignment.getLExpression();\n      if (expressionAssignsVariableOrFails(lhs, variable, checkedMethods, strict)) {\n        return true;\n      }\n      if (expressionAssignsVariableOrFails(assignment.getRExpression(), variable, checkedMethods, strict)) {\n        return true;\n      }\n      if (lhs instanceof PsiReferenceExpression) {\n        final PsiElement element = ((PsiReference)lhs).resolve();\n        if (variable.equals(element)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression = (PsiInstanceOfExpression)expression;\n      return expressionAssignsVariableOrFails(instanceOfExpression.getOperand(), variable, checkedMethods, strict);\n    }\n    else {\n      return false;\n    }\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean forStatementAssignsVariableOrFails(\n    @NotNull PsiForStatement forStatement, PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiStatement initialization = forStatement.getInitialization();\n    if (statementAssignsVariableOrFails(initialization, variable,\n                                        checkedMethods, strict)) {\n      return true;\n    }\n    final PsiExpression test = forStatement.getCondition();\n    if (expressionAssignsVariableOrFails(test, variable, checkedMethods,\n                                         strict)) {\n      return true;\n    }\n    if (BoolUtils.isTrue(test)) {\n      final PsiStatement body = forStatement.getBody();\n      if (statementAssignsVariableOrFails(body, variable, checkedMethods,\n                                          strict)) {\n        return true;\n      }\n      final PsiStatement update = forStatement.getUpdate();\n      if (statementAssignsVariableOrFails(update, variable,\n                                          checkedMethods, strict)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":47897,"modified_method":"private static boolean forStatementAssignsVariableOrFails(@NotNull PsiForStatement forStatement, PsiVariable variable,\n                                                            @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (statementAssignsVariableOrFails(forStatement.getInitialization(), variable, checkedMethods, strict)) {\n      return true;\n    }\n    final PsiExpression condition = forStatement.getCondition();\n    if (expressionAssignsVariableOrFails(condition, variable, checkedMethods, strict)) {\n      return true;\n    }\n    if (BoolUtils.isTrue(condition)) {\n      if (statementAssignsVariableOrFails(forStatement.getBody(), variable, checkedMethods, strict)) {\n        return true;\n      }\n      if (statementAssignsVariableOrFails(forStatement.getUpdate(), variable, checkedMethods, strict)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean newExpressionAssignsVariableOrFails(\n    @NotNull PsiNewExpression newExpression, PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiExpressionList argumentList = newExpression.getArgumentList();\n    if (argumentList != null) {\n      final PsiExpression[] args = argumentList.getExpressions();\n      for (final PsiExpression arg : args) {\n        if (expressionAssignsVariableOrFails(arg, variable,\n                                             checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    final PsiArrayInitializerExpression arrayInitializer =\n      newExpression.getArrayInitializer();\n    if (expressionAssignsVariableOrFails(arrayInitializer, variable,\n                                         checkedMethods, strict)) {\n      return true;\n    }\n    final PsiExpression[] arrayDimensions =\n      newExpression.getArrayDimensions();\n    for (final PsiExpression dim : arrayDimensions) {\n      if (expressionAssignsVariableOrFails(dim, variable,\n                                           checkedMethods, strict)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":47898,"modified_method":"private static boolean newExpressionAssignsVariableOrFails(@NotNull PsiNewExpression newExpression, PsiVariable variable,\n                                                             @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiExpressionList argumentList = newExpression.getArgumentList();\n    if (argumentList != null) {\n      for (final PsiExpression argument : argumentList.getExpressions()) {\n        if (expressionAssignsVariableOrFails(argument, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    if (expressionAssignsVariableOrFails(newExpression.getArrayInitializer(), variable, checkedMethods, strict)) {\n      return true;\n    }\n    for (final PsiExpression dimension : newExpression.getArrayDimensions()) {\n      if (expressionAssignsVariableOrFails(dimension, variable, checkedMethods, strict)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean statementAssignsVariableOrFails(\n    @Nullable PsiStatement statement, PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (statement == null) {\n      return false;\n    }\n    if (ExceptionUtils.statementThrowsException(statement)) {\n      return true;\n    }\n    if (statement instanceof PsiBreakStatement ||\n        statement instanceof PsiContinueStatement ||\n        statement instanceof PsiAssertStatement ||\n        statement instanceof PsiEmptyStatement ||\n        statement instanceof PsiSwitchLabelStatement) {\n      return false;\n    }\n    else if (statement instanceof PsiReturnStatement) {\n      final PsiReturnStatement returnStatement =\n        (PsiReturnStatement)statement;\n      final PsiExpression returnValue = returnStatement.getReturnValue();\n      return expressionAssignsVariableOrFails(returnValue, variable,\n                                              checkedMethods, strict);\n    }\n    else if (statement instanceof PsiThrowStatement) {\n      final PsiThrowStatement throwStatement =\n        (PsiThrowStatement)statement;\n      final PsiExpression exception = throwStatement.getException();\n      return expressionAssignsVariableOrFails(exception, variable,\n                                              checkedMethods, strict);\n    }\n    else if (statement instanceof PsiExpressionListStatement) {\n      final PsiExpressionListStatement list =\n        (PsiExpressionListStatement)statement;\n      final PsiExpressionList expressionList = list.getExpressionList();\n      final PsiExpression[] expressions = expressionList.getExpressions();\n      for (final PsiExpression expression : expressions) {\n        if (expressionAssignsVariableOrFails(expression, variable,\n                                             checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (statement instanceof PsiExpressionStatement) {\n      final PsiExpressionStatement expressionStatement =\n        (PsiExpressionStatement)statement;\n      final PsiExpression expression =\n        expressionStatement.getExpression();\n      return expressionAssignsVariableOrFails(expression, variable,\n                                              checkedMethods, strict);\n    }\n    else if (statement instanceof PsiDeclarationStatement) {\n      final PsiDeclarationStatement declarationStatement =\n        (PsiDeclarationStatement)statement;\n      return declarationStatementAssignsVariableOrFails(\n        declarationStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiForStatement) {\n      final PsiForStatement forStatement = (PsiForStatement)statement;\n      return forStatementAssignsVariableOrFails(forStatement,\n                                                variable,\n                                                checkedMethods, strict);\n    }\n    else if (statement instanceof PsiForeachStatement) {\n      final PsiForeachStatement foreachStatement =\n        (PsiForeachStatement)statement;\n      return foreachStatementAssignsVariableOrFails(variable,\n                                                    foreachStatement);\n    }\n    else if (statement instanceof PsiWhileStatement) {\n      final PsiWhileStatement whileStatement =\n        (PsiWhileStatement)statement;\n      return whileStatementAssignsVariableOrFails(whileStatement,\n                                                  variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiDoWhileStatement) {\n      final PsiDoWhileStatement doWhileStatement =\n        (PsiDoWhileStatement)statement;\n      return doWhileAssignsVariableOrFails(doWhileStatement, variable,\n                                           checkedMethods, strict);\n    }\n    else if (statement instanceof PsiSynchronizedStatement) {\n      final PsiSynchronizedStatement synchronizedStatement =\n        (PsiSynchronizedStatement)statement;\n      final PsiCodeBlock body = synchronizedStatement.getBody();\n      return blockAssignsVariableOrFails(body, variable,\n                                         checkedMethods, strict);\n    }\n    else if (statement instanceof PsiBlockStatement) {\n      final PsiBlockStatement blockStatement =\n        (PsiBlockStatement)statement;\n      final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n      return blockAssignsVariableOrFails(codeBlock, variable,\n                                         checkedMethods, strict);\n    }\n    else if (statement instanceof PsiLabeledStatement) {\n      final PsiLabeledStatement labeledStatement =\n        (PsiLabeledStatement)statement;\n      final PsiStatement statementLabeled =\n        labeledStatement.getStatement();\n      return statementAssignsVariableOrFails(statementLabeled, variable,\n                                             checkedMethods, strict);\n    }\n    else if (statement instanceof PsiIfStatement) {\n      final PsiIfStatement ifStatement = (PsiIfStatement)statement;\n      return ifStatementAssignsVariableOrFails(ifStatement, variable,\n                                               checkedMethods, strict);\n    }\n    else if (statement instanceof PsiTryStatement) {\n      final PsiTryStatement tryStatement = (PsiTryStatement)statement;\n      return tryStatementAssignsVariableOrFails(tryStatement, variable,\n                                                checkedMethods, strict);\n    }\n    else if (statement instanceof PsiSwitchStatement) {\n      final PsiSwitchStatement switchStatement =\n        (PsiSwitchStatement)statement;\n      return switchStatementAssignsVariableOrFails(switchStatement,\n                                                   variable, checkedMethods, strict);\n    }\n    else {\n      // unknown statement type\n      return false;\n    }\n  }","id":47899,"modified_method":"private static boolean statementAssignsVariableOrFails(@Nullable PsiStatement statement, PsiVariable variable,\n                                                         @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (statement == null) {\n      return false;\n    }\n    if (ExceptionUtils.statementThrowsException(statement)) {\n      return true;\n    }\n    if (statement instanceof PsiBreakStatement ||\n        statement instanceof PsiContinueStatement ||\n        statement instanceof PsiAssertStatement ||\n        statement instanceof PsiEmptyStatement ||\n        statement instanceof PsiSwitchLabelStatement) {\n      return false;\n    }\n    else if (statement instanceof PsiReturnStatement) {\n      final PsiReturnStatement returnStatement = (PsiReturnStatement)statement;\n      return expressionAssignsVariableOrFails(returnStatement.getReturnValue(), variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiThrowStatement) {\n      final PsiThrowStatement throwStatement = (PsiThrowStatement)statement;\n      return expressionAssignsVariableOrFails(throwStatement.getException(), variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiExpressionListStatement) {\n      final PsiExpressionListStatement list = (PsiExpressionListStatement)statement;\n      final PsiExpressionList expressionList = list.getExpressionList();\n      for (final PsiExpression expression : expressionList.getExpressions()) {\n        if (expressionAssignsVariableOrFails(expression, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (statement instanceof PsiExpressionStatement) {\n      final PsiExpressionStatement expressionStatement = (PsiExpressionStatement)statement;\n      return expressionAssignsVariableOrFails(expressionStatement.getExpression(), variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiDeclarationStatement) {\n      final PsiDeclarationStatement declarationStatement = (PsiDeclarationStatement)statement;\n      return declarationStatementAssignsVariableOrFails(declarationStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiForStatement) {\n      final PsiForStatement forStatement = (PsiForStatement)statement;\n      return forStatementAssignsVariableOrFails(forStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiForeachStatement) {\n      final PsiForeachStatement foreachStatement = (PsiForeachStatement)statement;\n      return foreachStatementAssignsVariableOrFails(foreachStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiWhileStatement) {\n      final PsiWhileStatement whileStatement = (PsiWhileStatement)statement;\n      return whileStatementAssignsVariableOrFails(whileStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiDoWhileStatement) {\n      final PsiDoWhileStatement doWhileStatement = (PsiDoWhileStatement)statement;\n      return doWhileAssignsVariableOrFails(doWhileStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiSynchronizedStatement) {\n      final PsiSynchronizedStatement synchronizedStatement = (PsiSynchronizedStatement)statement;\n      return blockAssignsVariableOrFails(synchronizedStatement.getBody(), variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiBlockStatement) {\n      final PsiBlockStatement blockStatement = (PsiBlockStatement)statement;\n      return blockAssignsVariableOrFails(blockStatement.getCodeBlock(), variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiLabeledStatement) {\n      final PsiLabeledStatement labeledStatement = (PsiLabeledStatement)statement;\n      return statementAssignsVariableOrFails(labeledStatement.getStatement(), variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiIfStatement) {\n      final PsiIfStatement ifStatement = (PsiIfStatement)statement;\n      return ifStatementAssignsVariableOrFails(ifStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiTryStatement) {\n      final PsiTryStatement tryStatement = (PsiTryStatement)statement;\n      return tryStatementAssignsVariableOrFails(tryStatement, variable, checkedMethods, strict);\n    }\n    else if (statement instanceof PsiSwitchStatement) {\n      final PsiSwitchStatement switchStatement = (PsiSwitchStatement)statement;\n      return switchStatementAssignsVariableOrFails(switchStatement, variable, checkedMethods, strict);\n    }\n    else {\n      // unknown statement type\n      return false;\n    }\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean blockAssignsVariableOrFails(\n    @Nullable PsiCodeBlock block, @NotNull PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (block == null) {\n      return false;\n    }\n    final PsiStatement[] statements = block.getStatements();\n    int assignmentCount = 0;\n    for (final PsiStatement statement : statements) {\n      if (statementAssignsVariableOrFails(statement, variable,\n                                          checkedMethods, strict)) {\n        if (strict) {\n          assignmentCount++;\n        }\n        else {\n          return true;\n        }\n      }\n    }\n    return assignmentCount == 1;\n  }","id":47900,"modified_method":"private static boolean blockAssignsVariableOrFails(@Nullable PsiCodeBlock block, @NotNull PsiVariable variable,\n                                                     @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (block == null) {\n      return false;\n    }\n    int assignmentCount = 0;\n    for (final PsiStatement statement : block.getStatements()) {\n      if (statementAssignsVariableOrFails(statement, variable, checkedMethods, strict)) {\n        if (strict) {\n          assignmentCount++;\n        }\n        else {\n          return true;\n        }\n      }\n    }\n    return assignmentCount == 1;\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean foreachStatementAssignsVariableOrFails(PsiVariable field, PsiForeachStatement forStatement) {\n    return false;\n  }","id":47901,"modified_method":"private static boolean foreachStatementAssignsVariableOrFails(@NotNull PsiForeachStatement foreachStatement, PsiVariable field,\n                                                                @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    return expressionAssignsVariableOrFails(foreachStatement.getIteratedValue(), field, checkedMethods, strict);\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean methodAssignsVariableOrFails(\n    @Nullable PsiMethod method, @NotNull PsiVariable variable,\n    boolean strict) {\n    if (method == null) {\n      return false;\n    }\n    final PsiCodeBlock body = method.getBody();\n    return body != null && blockAssignsVariableOrFails(body, variable,\n                                                       strict);\n  }","id":47902,"modified_method":"public static boolean methodAssignsVariableOrFails(@Nullable PsiMethod method, @NotNull PsiVariable variable, boolean strict) {\n    if (method == null) {\n      return false;\n    }\n    return blockAssignsVariableOrFails(method.getBody(), variable, strict);\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean methodCallAssignsVariableOrFails(\n    @NotNull PsiMethodCallExpression callExpression,\n    PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiExpressionList argList = callExpression.getArgumentList();\n    final PsiExpression[] args = argList.getExpressions();\n    for (final PsiExpression arg : args) {\n      if (expressionAssignsVariableOrFails(arg, variable, checkedMethods,\n                                           strict)) {\n        return true;\n      }\n    }\n    final PsiReferenceExpression methodExpression =\n      callExpression.getMethodExpression();\n    if (expressionAssignsVariableOrFails(methodExpression, variable,\n                                         checkedMethods, strict)) {\n      return true;\n    }\n    final PsiMethod method = callExpression.resolveMethod();\n    if (method == null) {\n      return false;\n    }\n    final MethodSignature methodSignature =\n      method.getSignature(PsiSubstitutor.EMPTY);\n    if (!checkedMethods.add(methodSignature)) {\n      return false;\n    }\n    final PsiClass containingClass =\n      ClassUtils.getContainingClass(callExpression);\n    final PsiClass calledClass = method.getContainingClass();\n    if (calledClass == null || !calledClass.equals(containingClass)) {\n      return false;\n    }\n    if (method.hasModifierProperty(PsiModifier.STATIC)\n        || method.isConstructor()\n        || method.hasModifierProperty(PsiModifier.PRIVATE)\n        || method.hasModifierProperty(PsiModifier.FINAL)\n        || calledClass.hasModifierProperty(PsiModifier.FINAL)) {\n      final PsiCodeBlock body = method.getBody();\n      return blockAssignsVariableOrFails(body, variable,\n                                         checkedMethods, strict);\n    }\n    return false;\n  }","id":47903,"modified_method":"private static boolean methodCallAssignsVariableOrFails(@NotNull PsiMethodCallExpression callExpression, PsiVariable variable,\n                                                          @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiExpressionList argumentList = callExpression.getArgumentList();\n    for (final PsiExpression argument : argumentList.getExpressions()) {\n      if (expressionAssignsVariableOrFails(argument, variable, checkedMethods, strict)) {\n        return true;\n      }\n    }\n    if (expressionAssignsVariableOrFails(callExpression.getMethodExpression(), variable, checkedMethods, strict)) {\n      return true;\n    }\n    final PsiMethod method = callExpression.resolveMethod();\n    if (method == null) {\n      return false;\n    }\n    final MethodSignature methodSignature = method.getSignature(PsiSubstitutor.EMPTY);\n    if (!checkedMethods.add(methodSignature)) {\n      return false;\n    }\n    final PsiClass containingClass = ClassUtils.getContainingClass(callExpression);\n    final PsiClass calledClass = method.getContainingClass();\n    if (calledClass == null || !calledClass.equals(containingClass)) {\n      return false;\n    }\n    if (method.hasModifierProperty(PsiModifier.STATIC)\n        || method.hasModifierProperty(PsiModifier.PRIVATE)\n        || method.hasModifierProperty(PsiModifier.FINAL)\n        || method.isConstructor()\n        || calledClass.hasModifierProperty(PsiModifier.FINAL)) {\n      return blockAssignsVariableOrFails(method.getBody(), variable, checkedMethods, strict);\n    }\n    return false;\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean doWhileAssignsVariableOrFails(\n    @NotNull PsiDoWhileStatement doWhileStatement,\n    PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods,\n    boolean strict) {\n    final PsiExpression condition = doWhileStatement.getCondition();\n    final PsiStatement body = doWhileStatement.getBody();\n    return expressionAssignsVariableOrFails(condition, variable,\n                                            checkedMethods, strict) ||\n           statementAssignsVariableOrFails(body, variable, checkedMethods,\n                                           strict);\n  }","id":47904,"modified_method":"private static boolean doWhileAssignsVariableOrFails(@NotNull PsiDoWhileStatement doWhileStatement, PsiVariable variable,\n                                                       @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    return statementAssignsVariableOrFails(doWhileStatement.getBody(), variable, checkedMethods, strict) ||\n           expressionAssignsVariableOrFails(doWhileStatement.getCondition(), variable, checkedMethods, strict);\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean tryStatementAssignsVariableOrFails(@NotNull PsiTryStatement tryStatement, PsiVariable variable,\n                                                            @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiResourceList resourceList = tryStatement.getResourceList();\n    if (resourceList != null) {\n      final List<PsiResourceVariable> resourceVariables = resourceList.getResourceVariables();\n      for (PsiResourceVariable resourceVariable : resourceVariables) {\n        final PsiExpression initializer = resourceVariable.getInitializer();\n        if (expressionAssignsVariableOrFails(initializer, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n    boolean initializedInTryAndCatch = blockAssignsVariableOrFails(tryBlock, variable, checkedMethods, strict);\n    final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    for (final PsiCodeBlock catchBlock : catchBlocks) {\n      if (strict) {\n        initializedInTryAndCatch &= ExceptionUtils.blockThrowsException(catchBlock);\n      }\n      else {\n        initializedInTryAndCatch &= blockAssignsVariableOrFails(catchBlock, variable, checkedMethods, strict);\n      }\n    }\n    if (initializedInTryAndCatch) {\n      return true;\n    }\n    final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    return blockAssignsVariableOrFails(finallyBlock, variable, checkedMethods, strict);\n  }","id":47905,"modified_method":"private static boolean tryStatementAssignsVariableOrFails(@NotNull PsiTryStatement tryStatement, PsiVariable variable,\n                                                            @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiResourceList resourceList = tryStatement.getResourceList();\n    if (resourceList != null) {\n      for (PsiResourceVariable resourceVariable : resourceList.getResourceVariables()) {\n        final PsiExpression initializer = resourceVariable.getInitializer();\n        if (expressionAssignsVariableOrFails(initializer, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    boolean initializedInTryAndCatch = blockAssignsVariableOrFails(tryStatement.getTryBlock(), variable, checkedMethods, strict);\n    final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    for (final PsiCodeBlock catchBlock : catchBlocks) {\n      if (strict) {\n        initializedInTryAndCatch &= ExceptionUtils.blockThrowsException(catchBlock);\n      }\n      else {\n        initializedInTryAndCatch &= blockAssignsVariableOrFails(catchBlock, variable, checkedMethods, strict);\n      }\n    }\n    return initializedInTryAndCatch || blockAssignsVariableOrFails(tryStatement.getFinallyBlock(), variable, checkedMethods, strict);\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean ifStatementAssignsVariableOrFails(\n    @NotNull PsiIfStatement ifStatement,\n    PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods,\n    boolean strict) {\n    final PsiExpression condition = ifStatement.getCondition();\n    if (expressionAssignsVariableOrFails(condition, variable,\n                                         checkedMethods, strict)) {\n      return true;\n    }\n    final PsiStatement thenBranch = ifStatement.getThenBranch();\n    final PsiStatement elseBranch = ifStatement.getElseBranch();\n    if (BoolUtils.isTrue(condition)) {\n      return statementAssignsVariableOrFails(thenBranch, variable,\n                                             checkedMethods, strict);\n    }\n    else if (BoolUtils.isFalse(condition)) {\n      return statementAssignsVariableOrFails(elseBranch, variable,\n                                             checkedMethods, strict);\n    }\n    return statementAssignsVariableOrFails(thenBranch, variable,\n                                           checkedMethods, strict) &&\n           statementAssignsVariableOrFails(elseBranch, variable,\n                                           checkedMethods, strict);\n  }","id":47906,"modified_method":"private static boolean ifStatementAssignsVariableOrFails(@NotNull PsiIfStatement ifStatement, PsiVariable variable,\n                                                           @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiExpression condition = ifStatement.getCondition();\n    if (expressionAssignsVariableOrFails(condition, variable, checkedMethods, strict)) {\n      return true;\n    }\n    final PsiStatement thenBranch = ifStatement.getThenBranch();\n    if (BoolUtils.isTrue(condition)) {\n      return statementAssignsVariableOrFails(thenBranch, variable, checkedMethods, strict);\n    }\n    final PsiStatement elseBranch = ifStatement.getElseBranch();\n    if (BoolUtils.isFalse(condition)) {\n      return statementAssignsVariableOrFails(elseBranch, variable, checkedMethods, strict);\n    }\n    return statementAssignsVariableOrFails(thenBranch, variable, checkedMethods, strict) &&\n           statementAssignsVariableOrFails(elseBranch, variable, checkedMethods, strict);\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean declarationStatementAssignsVariableOrFails(\n    PsiDeclarationStatement declarationStatement, PsiVariable variable,\n    Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiElement[] elements =\n      declarationStatement.getDeclaredElements();\n    for (PsiElement element : elements) {\n      if (element instanceof PsiVariable) {\n        final PsiVariable declaredVariable = (PsiVariable)element;\n        final PsiExpression initializer =\n          declaredVariable.getInitializer();\n        if (expressionAssignsVariableOrFails(initializer, variable,\n                                             checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":47907,"modified_method":"private static boolean declarationStatementAssignsVariableOrFails(PsiDeclarationStatement declarationStatement, PsiVariable variable,\n                                                                    Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiElement[] elements = declarationStatement.getDeclaredElements();\n    for (PsiElement element : elements) {\n      if (element instanceof PsiVariable) {\n        final PsiVariable declaredVariable = (PsiVariable)element;\n        if (expressionAssignsVariableOrFails(declaredVariable.getInitializer(), variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"3146c0bc83eae65b50743cc1ef5ba84ca0696984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean tryStatementAssignsVariableOrFails(\n    @NotNull PsiTryStatement tryStatement, PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n    boolean initializedInTryAndCatch =\n      blockAssignsVariableOrFails(tryBlock, variable,\n                                  checkedMethods, strict);\n    final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    for (final PsiCodeBlock catchBlock : catchBlocks) {\n      if (strict) {\n        initializedInTryAndCatch &=\n          ExceptionUtils.blockThrowsException(catchBlock);\n      }\n      else {\n        initializedInTryAndCatch &= blockAssignsVariableOrFails(\n          catchBlock, variable,\n          checkedMethods, strict);\n      }\n    }\n    if (initializedInTryAndCatch) {\n      return true;\n    }\n    final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    return blockAssignsVariableOrFails(finallyBlock, variable,\n                                       checkedMethods, strict);\n  }","id":47908,"modified_method":"private static boolean tryStatementAssignsVariableOrFails(@NotNull PsiTryStatement tryStatement, PsiVariable variable,\n                                                            @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    final PsiResourceList resourceList = tryStatement.getResourceList();\n    if (resourceList != null) {\n      final List<PsiResourceVariable> resourceVariables = resourceList.getResourceVariables();\n      for (PsiResourceVariable resourceVariable : resourceVariables) {\n        final PsiExpression initializer = resourceVariable.getInitializer();\n        if (expressionAssignsVariableOrFails(initializer, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n    }\n    final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n    boolean initializedInTryAndCatch = blockAssignsVariableOrFails(tryBlock, variable, checkedMethods, strict);\n    final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    for (final PsiCodeBlock catchBlock : catchBlocks) {\n      if (strict) {\n        initializedInTryAndCatch &= ExceptionUtils.blockThrowsException(catchBlock);\n      }\n      else {\n        initializedInTryAndCatch &= blockAssignsVariableOrFails(catchBlock, variable, checkedMethods, strict);\n      }\n    }\n    if (initializedInTryAndCatch) {\n      return true;\n    }\n    final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    return blockAssignsVariableOrFails(finallyBlock, variable, checkedMethods, strict);\n  }","commit_id":"4aa841bd55f984737096de3d32fda16337ff6847","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean expressionAssignsVariableOrFails(\n    @Nullable PsiExpression expression,\n    PsiVariable variable,\n    @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiThisExpression ||\n        expression instanceof PsiLiteralExpression ||\n        expression instanceof PsiSuperExpression ||\n        expression instanceof PsiClassObjectAccessExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiReferenceExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression =\n        (PsiMethodCallExpression)expression;\n      return methodCallAssignsVariableOrFails(methodCallExpression,\n                                              variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)expression;\n      return newExpressionAssignsVariableOrFails(newExpression, variable,\n                                                 checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayInitializerExpression) {\n      final PsiArrayInitializerExpression array =\n        (PsiArrayInitializerExpression)expression;\n      final PsiExpression[] initializers = array.getInitializers();\n      for (final PsiExpression initializer : initializers) {\n        if (expressionAssignsVariableOrFails(initializer, variable,\n                                             checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCast =\n        (PsiTypeCastExpression)expression;\n      final PsiExpression operand = typeCast.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable,\n                                              checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayAccessExpression) {\n      final PsiArrayAccessExpression accessExpression =\n        (PsiArrayAccessExpression)expression;\n      final PsiExpression arrayExpression =\n        accessExpression.getArrayExpression();\n      final PsiExpression indexExpression =\n        accessExpression.getIndexExpression();\n      return expressionAssignsVariableOrFails(arrayExpression, variable,\n                                              checkedMethods, strict) ||\n             expressionAssignsVariableOrFails(indexExpression, variable,\n                                              checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression =\n        (PsiPrefixExpression)expression;\n      final PsiExpression operand = prefixExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable,\n                                              checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression =\n        (PsiPostfixExpression)expression;\n      final PsiExpression operand = postfixExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable,\n                                              checkedMethods, strict);\n    }\n    else if (expression instanceof PsiBinaryExpression) {\n      final PsiBinaryExpression binaryExpression =\n        (PsiBinaryExpression)expression;\n      final PsiExpression lhs = binaryExpression.getLOperand();\n      final PsiExpression rhs = binaryExpression.getROperand();\n      return expressionAssignsVariableOrFails(lhs, variable,\n                                              checkedMethods, strict) ||\n             expressionAssignsVariableOrFails(rhs, variable,\n                                              checkedMethods, strict);\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional =\n        (PsiConditionalExpression)expression;\n      final PsiExpression condition = conditional.getCondition();\n      if (expressionAssignsVariableOrFails(condition, variable,\n                                           checkedMethods, strict)) {\n        return true;\n      }\n      final PsiExpression thenExpression =\n        conditional.getThenExpression();\n      final PsiExpression elseExpression =\n        conditional.getElseExpression();\n      return expressionAssignsVariableOrFails(thenExpression, variable,\n                                              checkedMethods, strict) &&\n             expressionAssignsVariableOrFails(elseExpression, variable,\n                                              checkedMethods, strict);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment =\n        (PsiAssignmentExpression)expression;\n      final PsiExpression lhs = assignment.getLExpression();\n      if (expressionAssignsVariableOrFails(lhs, variable, checkedMethods,\n                                           strict)) {\n        return true;\n      }\n      final PsiExpression rhs = assignment.getRExpression();\n      if (expressionAssignsVariableOrFails(rhs, variable, checkedMethods,\n                                           strict)) {\n        return true;\n      }\n      if (lhs instanceof PsiReferenceExpression) {\n        final PsiElement element = ((PsiReference)lhs).resolve();\n        if (element != null && element.equals(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return false;\n    }\n  }","id":47909,"modified_method":"private static boolean expressionAssignsVariableOrFails(@Nullable PsiExpression expression, PsiVariable variable,\n                                                          @NotNull Set<MethodSignature> checkedMethods, boolean strict) {\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiThisExpression ||\n        expression instanceof PsiLiteralExpression ||\n        expression instanceof PsiSuperExpression ||\n        expression instanceof PsiClassObjectAccessExpression ||\n        expression instanceof PsiReferenceExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression unparenthesizedExpression = parenthesizedExpression.getExpression();\n      return expressionAssignsVariableOrFails(unparenthesizedExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;\n      return methodCallAssignsVariableOrFails(methodCallExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)expression;\n      return newExpressionAssignsVariableOrFails(newExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayInitializerExpression) {\n      final PsiArrayInitializerExpression array = (PsiArrayInitializerExpression)expression;\n      final PsiExpression[] initializers = array.getInitializers();\n      for (final PsiExpression initializer : initializers) {\n        if (expressionAssignsVariableOrFails(initializer, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCast = (PsiTypeCastExpression)expression;\n      final PsiExpression operand = typeCast.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiArrayAccessExpression) {\n      final PsiArrayAccessExpression accessExpression = (PsiArrayAccessExpression)expression;\n      final PsiExpression arrayExpression = accessExpression.getArrayExpression();\n      final PsiExpression indexExpression = accessExpression.getIndexExpression();\n      return expressionAssignsVariableOrFails(arrayExpression, variable, checkedMethods, strict) ||\n             expressionAssignsVariableOrFails(indexExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression = (PsiPrefixExpression)expression;\n      final PsiExpression operand = prefixExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression = (PsiPostfixExpression)expression;\n      final PsiExpression operand = postfixExpression.getOperand();\n      return expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (expressionAssignsVariableOrFails(operand, variable, checkedMethods, strict)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional = (PsiConditionalExpression)expression;\n      final PsiExpression condition = conditional.getCondition();\n      if (expressionAssignsVariableOrFails(condition, variable, checkedMethods, strict)) {\n        return true;\n      }\n      final PsiExpression thenExpression = conditional.getThenExpression();\n      final PsiExpression elseExpression = conditional.getElseExpression();\n      return expressionAssignsVariableOrFails(thenExpression, variable, checkedMethods, strict) &&\n             expressionAssignsVariableOrFails(elseExpression, variable, checkedMethods, strict);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment = (PsiAssignmentExpression)expression;\n      final PsiExpression lhs = assignment.getLExpression();\n      if (expressionAssignsVariableOrFails(lhs, variable, checkedMethods, strict)) {\n        return true;\n      }\n      final PsiExpression rhs = assignment.getRExpression();\n      if (expressionAssignsVariableOrFails(rhs, variable, checkedMethods, strict)) {\n        return true;\n      }\n      if (lhs instanceof PsiReferenceExpression) {\n        final PsiElement element = ((PsiReference)lhs).resolve();\n        if (element != null && element.equals(variable)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return false;\n    }\n  }","commit_id":"4aa841bd55f984737096de3d32fda16337ff6847","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @see org.opencms.gwt.shared.rpc.I_CmsCoreService#getCategories(java.lang.String, boolean, java.util.List)\n     */\n    public CmsCategoryTreeEntry getCategories(String fromPath, boolean includeSubCats, List<String> refPaths)\n    throws CmsRpcException {\n\n        CmsObject cms = getCmsObject();\n        CmsCategoryService catService = CmsCategoryService.getInstance();\n\n        List<String> repositories = new ArrayList<String>();\n        if ((refPaths != null) && !refPaths.isEmpty()) {\n            for (String refPath : refPaths) {\n                repositories.addAll(catService.getCategoryRepositories(getCmsObject(), refPath));\n            }\n        } else {\n            repositories.add(CmsCategoryService.CENTRALIZED_REPOSITORY);\n        }\n\n        CmsCategoryTreeEntry result = null;\n        String iconPath = \"\";\n        try {\n            result = new CmsCategoryTreeEntry(fromPath);\n\n            iconPath = CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES\n                + OpenCms.getWorkplaceManager().getExplorerTypeSetting(CmsResourceTypeFolder.RESOURCE_TYPE_NAME).getIcon());\n            result.setIconResource(iconPath);\n\n            // get the categories\n            List<CmsCategory> categories = catService.readCategoriesForRepositories(\n                cms,\n                fromPath,\n                includeSubCats,\n                repositories);\n            // convert them to a tree structure\n            CmsCategoryTreeEntry parent = result;\n            for (CmsCategory category : categories) {\n                CmsCategoryTreeEntry current = new CmsCategoryTreeEntry(category);\n\n                iconPath = CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES\n                    + OpenCms.getWorkplaceManager().getExplorerTypeSetting(CmsResourceTypeFolder.RESOURCE_TYPE_NAME).getIcon());\n                current.setIconResource(iconPath);\n                String parentPath = CmsResource.getParentFolder(current.getPath());\n                if (!parentPath.equals(parent.getPath())) {\n                    parent = findCategory(result, parentPath);\n                }\n                parent.addChild(current);\n            }\n        } catch (Throwable e) {\n            error(e);\n        }\n        return result;\n    }","id":47910,"modified_method":"/**\n     * @see org.opencms.gwt.shared.rpc.I_CmsCoreService#getCategories(java.lang.String, boolean, java.util.List)\n     */\n    public CmsCategoryTreeEntry getCategories(String fromPath, boolean includeSubCats, List<String> refPaths)\n    throws CmsRpcException {\n\n        CmsObject cms = getCmsObject();\n        CmsCategoryService catService = CmsCategoryService.getInstance();\n\n        String resourceIcon = getIcon(CmsResourceTypeFolder.RESOURCE_TYPE_NAME);\n\n        List<String> repositories = new ArrayList<String>();\n        if ((refPaths != null) && !refPaths.isEmpty()) {\n            for (String refPath : refPaths) {\n                repositories.addAll(catService.getCategoryRepositories(getCmsObject(), refPath));\n            }\n        } else {\n            repositories.add(CmsCategoryService.CENTRALIZED_REPOSITORY);\n        }\n\n        CmsCategoryTreeEntry result = null;\n        try {\n            result = new CmsCategoryTreeEntry(fromPath);\n            result.setIconResource(resourceIcon);\n\n            // get the categories\n            List<CmsCategory> categories = catService.readCategoriesForRepositories(\n                cms,\n                fromPath,\n                includeSubCats,\n                repositories);\n            // convert them to a tree structure\n            CmsCategoryTreeEntry parent = result;\n            for (CmsCategory category : categories) {\n                CmsCategoryTreeEntry current = new CmsCategoryTreeEntry(category);\n                current.setIconResource(resourceIcon);\n                String parentPath = CmsResource.getParentFolder(current.getPath());\n                if (!parentPath.equals(parent.getPath())) {\n                    parent = findCategory(result, parentPath);\n                }\n                parent.addChild(current);\n            }\n        } catch (Throwable e) {\n            error(e);\n        }\n        return result;\n    }","commit_id":"278e0e3f3f922dd228d5906a8ddb2cef5bcba8c6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Generates a map with all available content types.<p>\n     * \n     * The map uses resource type name as the key and stores the CmsTypesListInfoBean as the value.\n     * \n     * @param types the resource types\n     * \n     * @return the map containing the available resource types\n     */\n    private ArrayList<CmsTypesListInfoBean> buildTypesList(List<I_CmsResourceType> types) {\n\n        ArrayList<CmsTypesListInfoBean> list = new ArrayList<CmsTypesListInfoBean>();\n        if (types == null) {\n            return list;\n        }\n        Iterator<I_CmsResourceType> it = types.iterator();\n        while (it.hasNext()) {\n            I_CmsResourceType type = it.next();\n            CmsTypesListInfoBean bean = new CmsTypesListInfoBean();\n            // 1: unique id\n            bean.setId(type.getTypeName());\n            // 2: type nice name            \n            Locale wpLocale = getWorkplaceLocale();\n            // TODO: remove:  bean.setTypeNiceName(CmsWorkplaceMessages.getResourceTypeDescription(wpLocale, type.getTypeName()));\n            // 3: type title and subtitle\n            bean.setTitle(CmsWorkplaceMessages.getResourceTypeName(wpLocale, type.getTypeName()));\n            bean.setSubTitle(CmsWorkplaceMessages.getResourceTypeDescription(wpLocale, type.getTypeName()));\n            // 4: resouce type icon\n            String iconPath = CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES\n                + OpenCms.getWorkplaceManager().getExplorerTypeSetting(type.getTypeName()).getIcon());\n            bean.setIconResource(iconPath);\n            // 5: gallery id of corresponding galleries\n            ArrayList<String> galleryNames = new ArrayList<String>();\n            Iterator<I_CmsResourceType> galleryTypes = type.getGalleryTypes().iterator();\n            while (galleryTypes.hasNext()) {\n                I_CmsResourceType galleryType = galleryTypes.next();\n                galleryNames.add(galleryType.getTypeName());\n            }\n            bean.setGalleryTypeNames(galleryNames);\n            list.add(bean);\n\n        }\n        return list;\n    }","id":47911,"modified_method":"/**\n     * Generates a map with all available content types.<p>\n     * \n     * The map uses resource type name as the key and stores the CmsTypesListInfoBean as the value.\n     * \n     * @param types the resource types\n     * \n     * @return the map containing the available resource types\n     */\n    private ArrayList<CmsTypesListInfoBean> buildTypesList(List<I_CmsResourceType> types) throws CmsRpcException {\n\n        ArrayList<CmsTypesListInfoBean> list = new ArrayList<CmsTypesListInfoBean>();\n        if (types == null) {\n            return list;\n        }\n        Iterator<I_CmsResourceType> it = types.iterator();\n        while (it.hasNext()) {\n            I_CmsResourceType type = it.next();\n            CmsTypesListInfoBean bean = new CmsTypesListInfoBean();\n\n            // 1: unique id\n            bean.setId(type.getTypeName());\n            // 2: type nice name            \n            Locale wpLocale = getWorkplaceLocale();\n            // TODO: remove:  bean.setTypeNiceName(CmsWorkplaceMessages.getResourceTypeDescription(wpLocale, type.getTypeName()));\n            // 3: type title and subtitle\n            bean.setTitle(CmsWorkplaceMessages.getResourceTypeName(wpLocale, type.getTypeName()));\n            bean.setSubTitle(CmsWorkplaceMessages.getResourceTypeDescription(wpLocale, type.getTypeName()));\n            // 4: resouce type icon\n            String iconPath = getCoreService().getIcon(type.getTypeName());\n            //TODO: remove            String iconPath = CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES\n            //                + OpenCms.getWorkplaceManager().getExplorerTypeSetting(type.getTypeName()).getIcon());\n            bean.setIconResource(iconPath);\n            // 5: gallery id of corresponding galleries\n            ArrayList<String> galleryNames = new ArrayList<String>();\n            Iterator<I_CmsResourceType> galleryTypes = type.getGalleryTypes().iterator();\n            while (galleryTypes.hasNext()) {\n                I_CmsResourceType galleryType = galleryTypes.next();\n                galleryNames.add(galleryType.getTypeName());\n            }\n            bean.setGalleryTypeNames(galleryNames);\n            list.add(bean);\n\n        }\n        return list;\n    }","commit_id":"278e0e3f3f922dd228d5906a8ddb2cef5bcba8c6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the list of beans for the given search results.<p>\n     * \n     * @param searchResult the list of search results\n     * \n     * @return the list with the current search results\n     */\n    private ArrayList<CmsResultsListInfoBean> buildSearchResultList(List<CmsGallerySearchResult> searchResult) {\n\n        ArrayList<CmsResultsListInfoBean> list = new ArrayList<CmsResultsListInfoBean>();\n        if ((searchResult == null) || (searchResult.size() == 0)) {\n            return list;\n        }\n        Iterator<CmsGallerySearchResult> iSearchResult = searchResult.iterator();\n        while (iSearchResult.hasNext()) {\n            try {\n                Locale wpLocale = getWorkplaceLocale();\n                CmsGallerySearchResult sResult = iSearchResult.next();\n                CmsResultsListInfoBean bean = new CmsResultsListInfoBean();\n                String path = sResult.getPath();\n                path = getCmsObject().getRequestContext().removeSiteRoot(path);\n                String fileIcon = getFileIconName(path);\n                String iconPath = CmsWorkplace.RES_PATH_FILETYPES;\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(fileIcon)) {\n                    iconPath += OpenCms.getWorkplaceManager().getExplorerTypeSetting(sResult.getResourceType()).getIcon();\n                } else {\n                    iconPath += \"mimetype/\" + fileIcon;\n                }\n                iconPath = CmsWorkplace.getResourceUri(iconPath);\n\n                // 1: resource path as id\n                bean.setId(path);\n                // 2: title\n                bean.setTitle(sResult.getTitle());\n                // 3: resource type\n                bean.setResourceType(sResult.getResourceType());\n                // 4: icon path\n                bean.setIconResource(iconPath);\n                // 5: structured id\n                bean.setClientId(sResult.getStructureId());\n                // TODO: set following infos if required: date last modified, description, structured id\n\n                // set nice resource type name as subtitle\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(sResult.getResourceType());\n                bean.setSubTitle(CmsWorkplaceMessages.getResourceTypeName(wpLocale, type.getTypeName()));\n\n                // TODO: only add excerpt if not empty\n                // if (!CmsStringUtil.isEmptyOrWhitespaceOnly(sResult.getExcerpt())) {\n                //      formatterInfo.addAdditionalInfo(EXCERPT_FIELD_NAME, OpenCms.getWorkplaceManager().getMessages(\n                //      wpLocale).key(Messages.GUI_LABEL_EXCERPT), sResult.getExcerpt());\n                // }\n                list.add(bean);\n            } catch (Exception e) {\n                // TODO: Improve error handling\n                logError(e);\n            }\n        }\n        return list;\n    }","id":47912,"modified_method":"/**\n     * Returns the list of beans for the given search results.<p>\n     * \n     * @param searchResult the list of search results\n     * \n     * @return the list with the current search results\n     */\n    private ArrayList<CmsResultsListInfoBean> buildSearchResultList(List<CmsGallerySearchResult> searchResult) {\n\n        ArrayList<CmsResultsListInfoBean> list = new ArrayList<CmsResultsListInfoBean>();\n        if ((searchResult == null) || (searchResult.size() == 0)) {\n            return list;\n        }\n        Iterator<CmsGallerySearchResult> iSearchResult = searchResult.iterator();\n        while (iSearchResult.hasNext()) {\n            try {\n                Locale wpLocale = getWorkplaceLocale();\n                CmsGallerySearchResult sResult = iSearchResult.next();\n                CmsResultsListInfoBean bean = new CmsResultsListInfoBean();\n                String path = sResult.getPath();\n                path = getCmsObject().getRequestContext().removeSiteRoot(path);\n                String fileIcon = getFileIconName(path);\n                String iconPath = CmsWorkplace.RES_PATH_FILETYPES;\n                if (CmsStringUtil.isEmptyOrWhitespaceOnly(fileIcon)) {\n                    //TODO: remove iconPath += OpenCms.getWorkplaceManager().getExplorerTypeSetting(sResult.getResourceType()).getIcon();\n                    iconPath = getCoreService().getIcon(sResult.getResourceType());\n                } else {\n                    // TODO: refactor this part, this should be made in core service or even in core\n                    iconPath += \"mimetype/\" + fileIcon;\n                    iconPath = CmsWorkplace.getResourceUri(iconPath);\n                }\n\n                // 1: resource path as id\n                bean.setId(path);\n                // 2: title\n                bean.setTitle(sResult.getTitle());\n                // 3: resource type\n                bean.setResourceType(sResult.getResourceType());\n                // 4: icon path\n                bean.setIconResource(iconPath);\n                // 5: structured id\n                bean.setClientId(sResult.getStructureId());\n                // TODO: set following infos if required: date last modified, description, structured id\n\n                // set nice resource type name as subtitle\n                I_CmsResourceType type = OpenCms.getResourceManager().getResourceType(sResult.getResourceType());\n                bean.setSubTitle(CmsWorkplaceMessages.getResourceTypeName(wpLocale, type.getTypeName()));\n\n                // TODO: only add excerpt if not empty\n                // if (!CmsStringUtil.isEmptyOrWhitespaceOnly(sResult.getExcerpt())) {\n                //      formatterInfo.addAdditionalInfo(EXCERPT_FIELD_NAME, OpenCms.getWorkplaceManager().getMessages(\n                //      wpLocale).key(Messages.GUI_LABEL_EXCERPT), sResult.getExcerpt());\n                // }\n                list.add(bean);\n            } catch (Exception e) {\n                // TODO: Improve error handling\n                logError(e);\n            }\n        }\n        return list;\n    }","commit_id":"278e0e3f3f922dd228d5906a8ddb2cef5bcba8c6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the map with the available galleries.<p>\n     * \n     * The map uses gallery path as teh key and stores the CmsGalleriesListInfoBean as the value.\n     * \n     * @param galleryTypes the galleries\n     * @return the map with gallery info beans\n     */\n    private ArrayList<CmsGalleriesListInfoBean> buildGalleriesList(Map<String, CmsGalleryTypeInfo> galleryTypes) {\n\n        ArrayList<CmsGalleriesListInfoBean> list = new ArrayList<CmsGalleriesListInfoBean>();\n        if (galleryTypes == null) {\n            return list;\n        }\n        Iterator<Entry<String, CmsGalleryTypeInfo>> iGalleryTypes = galleryTypes.entrySet().iterator();\n        while (iGalleryTypes.hasNext()) {\n            Entry<String, CmsGalleryTypeInfo> ent = iGalleryTypes.next();\n            CmsGalleryTypeInfo tInfo = ent.getValue();\n            String iconPath = CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES\n                + OpenCms.getWorkplaceManager().getExplorerTypeSetting(tInfo.getResourceType().getTypeName()).getIcon());\n            ArrayList<String> contentTypes = new ArrayList<String>();\n            Iterator<I_CmsResourceType> it = tInfo.getContentTypes().iterator();\n            while (it.hasNext()) {\n                contentTypes.add(String.valueOf(it.next().getTypeName()));\n            }\n            Iterator<CmsResource> ir = tInfo.getGalleries().iterator();\n            while (ir.hasNext()) {\n                CmsResource res = ir.next();\n                CmsGalleriesListInfoBean bean = new CmsGalleriesListInfoBean();\n                String sitePath = getCmsObject().getSitePath(res);\n                String title = \"\";\n                try {\n                    // read the gallery title\n                    title = getCmsObject().readPropertyObject(sitePath, CmsPropertyDefinition.PROPERTY_TITLE, false).getValue(\n                        \"\");\n                } catch (CmsException e) {\n                    // error reading title property\n                    logError(e);\n                }\n                // 1: sitepath as gallery id \n                bean.setId(sitePath);\n                // TODO: set the resource\n                //CmsFormatterInfoBean formatterInfo = new CmsFormatterInfoBean(tInfo.getResourceType(), false);\n                //formatterInfo.setResource(res);\n                // 2: content types\n                bean.setContentTypes(contentTypes);\n                // 3: title\n                bean.setTitle(title);\n                // 4: gallery path as sub title            \n                bean.setSubTitle(sitePath);\n                // 5: gallery icon\n                bean.setIconResource(iconPath);\n                // 6: gallery type name\n                bean.setGalleryTypeName(tInfo.getResourceType().getTypeName());\n\n                // TODO:: active flag\n                //jsonObj.put(ItemKey.gallerytypeid.toString(), tInfo.getResourceType().getTypeId());\n\n                list.add(bean);\n            }\n        }\n        return list;\n    }","id":47913,"modified_method":"/**\n     * Returns the map with the available galleries.<p>\n     * \n     * The map uses gallery path as teh key and stores the CmsGalleriesListInfoBean as the value.\n     * \n     * @param galleryTypes the galleries\n     * @return the map with gallery info beans\n     */\n    private ArrayList<CmsGalleriesListInfoBean> buildGalleriesList(Map<String, CmsGalleryTypeInfo> galleryTypes)\n    throws CmsRpcException {\n\n        ArrayList<CmsGalleriesListInfoBean> list = new ArrayList<CmsGalleriesListInfoBean>();\n        if (galleryTypes == null) {\n            return list;\n        }\n        Iterator<Entry<String, CmsGalleryTypeInfo>> iGalleryTypes = galleryTypes.entrySet().iterator();\n        while (iGalleryTypes.hasNext()) {\n            Entry<String, CmsGalleryTypeInfo> ent = iGalleryTypes.next();\n            CmsGalleryTypeInfo tInfo = ent.getValue();\n\n            // set the icon\n            String iconPath = getCoreService().getIcon(tInfo.getResourceType().getTypeName());\n\n            //TODO: remove    String iconPath = CmsWorkplace.getResourceUri(CmsWorkplace.RES_PATH_FILETYPES\n            //                + OpenCms.getWorkplaceManager().getExplorerTypeSetting(tInfo.getResourceType().getTypeName()).getIcon());\n            ArrayList<String> contentTypes = new ArrayList<String>();\n            Iterator<I_CmsResourceType> it = tInfo.getContentTypes().iterator();\n            while (it.hasNext()) {\n                contentTypes.add(String.valueOf(it.next().getTypeName()));\n            }\n            Iterator<CmsResource> ir = tInfo.getGalleries().iterator();\n            while (ir.hasNext()) {\n                CmsResource res = ir.next();\n                CmsGalleriesListInfoBean bean = new CmsGalleriesListInfoBean();\n                String sitePath = getCmsObject().getSitePath(res);\n                String title = \"\";\n                try {\n                    // read the gallery title\n                    title = getCmsObject().readPropertyObject(sitePath, CmsPropertyDefinition.PROPERTY_TITLE, false).getValue(\n                        \"\");\n                } catch (CmsException e) {\n                    // error reading title property\n                    logError(e);\n                }\n                // 1: sitepath as gallery id \n                bean.setId(sitePath);\n                // TODO: set the resource\n                //CmsFormatterInfoBean formatterInfo = new CmsFormatterInfoBean(tInfo.getResourceType(), false);\n                //formatterInfo.setResource(res);\n                // 2: content types\n                bean.setContentTypes(contentTypes);\n                // 3: title\n                bean.setTitle(title);\n                // 4: gallery path as sub title            \n                bean.setSubTitle(sitePath);\n                // 5: gallery icon\n                bean.setIconResource(iconPath);\n                // 6: gallery type name\n                bean.setGalleryTypeName(tInfo.getResourceType().getTypeName());\n\n                // TODO:: active flag\n                //jsonObj.put(ItemKey.gallerytypeid.toString(), tInfo.getResourceType().getTypeId());\n\n                list.add(bean);\n            }\n        }\n        return list;\n    }","commit_id":"278e0e3f3f922dd228d5906a8ddb2cef5bcba8c6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n   * Opens the specified database.\n   * @param name name of database\n   * @param ctx database context\n   * @return data reference\n   * @throws IOException I/O exception\n   */\n  public static Data open(final String name, final Context ctx) throws IOException {\n    Data data = ctx.pin(name);\n    if(data == null) {\n      // check if document exists\n      if(!ctx.mprop.dbexists(name)) throw new BaseXException(DB_NOT_FOUND_X, name);\n\n      data = new DiskData(name, ctx);\n      ctx.pin(data);\n    }\n    // check permissions\n    if(ctx.perm(Perm.READ, data.meta)) return data;\n\n    Close.close(data, ctx);\n    throw new BaseXException(PERM_NEEDED_X, Perm.READ);\n  }","id":47914,"modified_method":"/**\n   * Opens the specified database.\n   * @param name name of database\n   * @param ctx database context\n   * @return data reference\n   * @throws IOException I/O exception\n   */\n  public static Data open(final String name, final Context ctx) throws IOException {\n    Data data;\n    synchronized(ctx.datas) { // pin should be atomic\n      data = ctx.pin(name);\n      if(data == null) {\n        // check if document exists\n        if(!ctx.mprop.dbexists(name)) throw new BaseXException(DB_NOT_FOUND_X, name);\n\n        data = new DiskData(name, ctx);\n        ctx.pin(data);\n      }\n    }\n    // check permissions\n    if(ctx.perm(Perm.READ, data.meta)) return data;\n\n    Close.close(data, ctx);\n    throw new BaseXException(PERM_NEEDED_X, Perm.READ);\n  }","commit_id":"f4200323d79eaf129d5e7cc2ba564199991d848c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Opens the specified database.\n   * @param name name of database\n   * @param ctx database context\n   * @return data reference\n   * @throws IOException I/O exception\n   */\n  public static Data open(final String name, final Context ctx) throws IOException {\n    Data data = ctx.pin(name);\n    if(data == null) {\n      // check if document exists\n      if(!ctx.mprop.dbexists(name)) throw new BaseXException(DB_NOT_FOUND_X, name);\n\n      data = new DiskData(name, ctx);\n      ctx.pin(data);\n    }\n    // check permissions\n    if(ctx.perm(Perm.READ, data.meta)) return data;\n\n    Close.close(data, ctx);\n    throw new BaseXException(PERM_NEEDED_X, Perm.READ);\n  }","id":47915,"modified_method":"/**\n   * Opens the specified database.\n   * @param name name of database\n   * @param ctx database context\n   * @return data reference\n   * @throws IOException I/O exception\n   */\n  public static Data open(final String name, final Context ctx) throws IOException {\n    Data data;\n    synchronized(ctx.datas) { // pin should be atomic\n      data = ctx.pin(name);\n      if(data == null) {\n        // check if document exists\n        if(!ctx.mprop.dbexists(name)) throw new BaseXException(DB_NOT_FOUND_X, name);\n\n        data = new DiskData(name, ctx);\n        ctx.pin(data);\n      }\n    }\n    // check permissions\n    if(ctx.perm(Perm.READ, data.meta)) return data;\n\n    Close.close(data, ctx);\n    throw new BaseXException(PERM_NEEDED_X, Perm.READ);\n  }","commit_id":"262f78489febc1984acfd194d10e5a1b6e153067","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public void flush( PageIO io ) throws IOException\n    {\n        for ( StandardPinnablePage page : pages )\n        {\n            if( page.isBackedBy( io ) ) // TODO this is racy with the eviction\n            {\n                page.lock( PageLock.SHARED );\n                try\n                {\n                    page.flush();\n                }\n                finally\n                {\n                    page.unlock( PageLock.SHARED );\n                }\n            }\n        }\n    }","id":47916,"modified_method":"@Override\n    public void flush( PageIO io ) throws IOException\n    {\n        for ( StandardPinnablePage page : pages )\n        {\n            page.lock( PageLock.SHARED );\n            try\n            {\n                if( page.isBackedBy( io ) )\n                {\n                    page.flush();\n                }\n            }\n            finally\n            {\n                page.unlock( PageLock.SHARED );\n            }\n        }\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void evict( StandardPinnablePage page ) throws IOException\n    {\n        long pageId = page.pageId();\n        PageIO io = page.io();\n\n        page.flush();\n        page.evicted();\n        page.reset( null, 0 );\n        page.loaded = false;\n        do {\n            page.next = freeList.get();\n        } while ( !freeList.compareAndSet( page.next, page ) );\n        monitor.evict( pageId, io );\n    }","id":47917,"modified_method":"private void evict( StandardPinnablePage page ) throws IOException\n    {\n        long pageId = page.pageId();\n        PageIO io = page.io();\n\n        page.flush();\n        page.evicted();\n        page.reset( null, UNBOUND_PAGE_ID );\n        page.loaded = false;\n        do {\n            page.next = freeList.get();\n        } while ( !freeList.compareAndSet( page.next, page ) );\n        monitor.evict( pageId, io );\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public PinnablePage load( PageIO io, long pageId, PageLock lock ) throws IOException\n    {\n        StandardPinnablePage page = nextFreePage();\n        page.reset( io, pageId );\n        page.pin( io, pageId, lock );\n        page.load();\n        monitor.pageFault( pageId, io );\n        return page;\n    }","id":47918,"modified_method":"@Override\n    public PinnablePage load( PageIO io, long pageId, PageLock lock ) throws IOException\n    {\n        StandardPinnablePage page = nextFreePage();\n        if ( page.pin( null, UNBOUND_PAGE_ID, lock ) )\n        {\n            page.reset( io, pageId );\n            page.load();\n            monitor.pageFault( pageId, io );\n        }\n        else\n        {\n            throw new IOException(\n                    \"Tried to load a page (page fault) but the page in the free-list \" +\n                    \"was already bound to a file and a pageId: \" + page );\n        }\n        return page;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test( timeout = 1000 )\n    public void readers_and_writers_must_block_on_evicting_page() throws Exception\n    {\n        // If we have a loaded page ...\n        PageIO io = new BufferPageIO( ByteBuffer.allocate( TEST_PAGE_SIZE ) );\n        long pageId = 12;\n        PinnablePage page = table.load( io, pageId, PageLock.EXCLUSIVE );\n        monitor.observeFault();\n\n        // ... a page that will take a long time to evict\n        CountDownLatch latch = monitor.trap( new Evict( io, pageId ) );\n\n        // ... and a page that is soon up for eviction\n        page.unpin( PageLock.EXCLUSIVE );\n\n        // ... then when we observe the eviction taking place\n        monitor.observeEvict();\n\n        // ... other threads should not be able to pin that page\n        Thread pinForShared = fork( $pinUnpin( page, io, pageId, PageLock.SHARED ) );\n        Thread pinForExclusive = fork( $pinUnpin( page, io, pageId, PageLock.EXCLUSIVE ) );\n        awaitThreadState( pinForShared, Thread.State.WAITING );\n        awaitThreadState( pinForExclusive, Thread.State.WAITING );\n\n        // ... until the eviction finishes\n        latch.countDown();\n        pinForShared.join();\n        pinForExclusive.join();\n    }","id":47919,"modified_method":"@Test( timeout = 1000 )\n    public void readers_and_writers_must_block_on_evicting_page() throws Exception\n    {\n        // If we have a loaded page ...\n        PageIO io = new BufferPageIO( ByteBuffer.allocate( TEST_PAGE_SIZE ) );\n        long pageId = 12;\n        PinnablePage page = table.load( io, pageId, PageLock.EXCLUSIVE );\n        monitor.observe( Fault.class );\n\n        // ... a page that will take a long time to evict\n        CountDownLatch latch = monitor.trap( new Evict( io, pageId ) );\n\n        // ... and a page that is soon up for eviction\n        page.unpin( PageLock.EXCLUSIVE );\n\n        // ... then when we observe the eviction taking place\n        monitor.observe( Evict.class );\n\n        // ... other threads should not be able to pin that page\n        Thread pinForShared = fork( $pinUnpin( page, io, pageId, PageLock.SHARED ) );\n        Thread pinForExclusive = fork( $pinUnpin( page, io, pageId, PageLock.EXCLUSIVE ) );\n        awaitThreadState( pinForShared, Thread.State.WAITING );\n        awaitThreadState( pinForExclusive, Thread.State.WAITING );\n\n        // ... until the eviction finishes\n        latch.countDown();\n        pinForShared.join();\n        pinForExclusive.join();\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void must_notify_monitor_of_evicted_pages() throws Exception\n    {\n        // If we load a page ...\n        PageIO io = new BufferPageIO( ByteBuffer.allocate( TEST_PAGE_SIZE ) );\n        long pageId = 12;\n        PinnablePage page = table.load( io, pageId, PageLock.EXCLUSIVE );\n        page.unpin( PageLock.EXCLUSIVE );\n\n        // ... then we should observe its page fault\n        assertThat( monitor.observeFault(), is( new Fault( io, pageId ) ) );\n\n        // ... and when it sits idle for long enough, we should observe its eviction\n        assertThat( monitor.observeEvict(), is( new Evict( io, pageId ) ) );\n    }","id":47920,"modified_method":"@Test\n    public void must_notify_monitor_of_evicted_pages() throws Exception\n    {\n        // If we load a page ...\n        PageIO io = new BufferPageIO( ByteBuffer.allocate( TEST_PAGE_SIZE ) );\n        long pageId = 12;\n        PinnablePage page = table.load( io, pageId, PageLock.EXCLUSIVE );\n        page.unpin( PageLock.EXCLUSIVE );\n\n        // ... then we should observe its page fault\n        assertThat( monitor.observe( Fault.class ), is( new Fault( io, pageId ) ) );\n\n        // ... and when it sits idle for long enough, we should observe its eviction\n        assertThat( monitor.observe( Evict.class ), is( new Evict( io, pageId ) ) );\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * @return true if this was the last reference to the file.\n     */\n    public boolean releaseReference()\n    {\n        return references.decrementAndGet() == 0;\n    }","id":47921,"modified_method":"/**\n     * @return true if this was the last reference to the file.\n     */\n    boolean releaseReference()\n    {\n        return references.decrementAndGet() == 0;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * @return true if this file is still open and we managed to claim a reference to it.\n     */\n    public boolean claimReference()\n    {\n        int refs;\n        do\n        {\n            refs = references.get();\n            if(refs <= 0)\n            {\n                return false;\n            }\n        } while( !references.compareAndSet( refs, refs + 1 ));\n        return true;\n    }","id":47922,"modified_method":"/**\n     * @return true if this file is still open and we managed to claim a reference to it.\n     */\n    boolean claimReference()\n    {\n        int refs;\n        do\n        {\n            refs = references.get();\n            if(refs <= 0)\n            {\n                return false;\n            }\n        } while( !references.compareAndSet( refs, refs + 1 ));\n        return true;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public PageIO io()\n    {\n        return io;\n    }","id":47923,"modified_method":"/**\n     * Must be call under lock\n     */\n    PageIO io()\n    {\n        assertLocked();\n        return io;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void evicted()\n    {\n        io.evicted( pageId );\n    }","id":47924,"modified_method":"/**\n     * Must be call under lock\n     */\n    void evicted()\n    {\n        assertLocked();\n        io.evicted( pageId );\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void load() throws IOException\n    {\n        buffer().position(0);\n        io.read( pageId, buffer );\n        loaded = true;\n    }","id":47925,"modified_method":"/**\n     * Must be call under lock\n     */\n    void load() throws IOException\n    {\n        assertLocked();\n        buffer().position(0);\n        io.read( pageId, buffer );\n        loaded = true;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean isBackedBy( PageIO io )\n    {\n        return this.io != null && this.io.equals( io );\n    }","id":47926,"modified_method":"/**\n     * Must be call under lock\n     */\n    boolean isBackedBy( PageIO io )\n    {\n        assertLocked();\n        return this.io != null && this.io.equals( io );\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void unlock( PageLock lockType )\n    {\n        if( lockType == PageLock.SHARED)\n        {\n            this.lock.readLock().unlock();\n        }\n        else if( lockType == PageLock.EXCLUSIVE )\n        {\n            this.lock.writeLock().unlock();\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Unknown lock type: \" + lockType );\n        }\n    }","id":47927,"modified_method":"void unlock( PageLock lockType )\n    {\n        if( lockType == PageLock.SHARED)\n        {\n            this.lock.readLock().unlock();\n        }\n        else if( lockType == PageLock.EXCLUSIVE )\n        {\n            this.lock.writeLock().unlock();\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Unknown lock type: \" + lockType );\n        }\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void reset( PageIO io, long pageId )\n    {\n        this.io = io;\n        this.pageId = pageId;\n    }","id":47928,"modified_method":"/**\n     * Must be call under lock\n     */\n    void reset( PageIO io, long pageId )\n    {\n        assertLocked();\n        this.io = io;\n        this.pageId = pageId;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ByteBuffer buffer()\n    {\n        if(buffer == null)\n        {\n            try\n            {\n                buffer = ByteBuffer.allocateDirect( pageSize );\n            } catch(OutOfMemoryError e)\n            {\n                buffer = ByteBuffer.allocate( pageSize );\n            }\n        }\n        return buffer;\n    }","id":47929,"modified_method":"/**\n     * Must be call under lock\n     */\n    private ByteBuffer buffer()\n    {\n        assertLocked();\n        if( buffer == null )\n        {\n            try\n            {\n                buffer = ByteBuffer.allocateDirect( pageSize );\n            }\n            catch( OutOfMemoryError e )\n            {\n                buffer = ByteBuffer.allocate( pageSize );\n            }\n        }\n        return buffer;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void releaseExclusiveLock()\n    {\n        lock.writeLock().unlock();\n    }","id":47930,"modified_method":"void releaseExclusiveLock()\n    {\n        lock.writeLock().unlock();\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"/** Attempt to lock this page exclusively, used by page table during house keeping. */\n    public boolean tryExclusiveLock()\n    {\n        return lock.getReadLockCount() == 0\n                && !lock.isWriteLocked()\n                && lock.writeLock().tryLock();\n    }","id":47931,"modified_method":"/** Attempt to lock this page exclusively, used by page table during house keeping. */\n    boolean tryExclusiveLock()\n    {\n        return lock.getReadLockCount() == 0\n                && !lock.isWriteLocked()\n                && lock.writeLock().tryLock();\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public boolean pin( PageIO assertIO, long assertPageId, PageLock lockType )\n    {\n        lock( lockType );\n        if( assertionsHold( assertIO, assertPageId ) )\n        {\n            byte stamp = usageStamp;\n            if ( stamp < MAX_USAGE_COUNT )\n            {\n                // Racy, but we don't care\n                usageStamp = (byte) (stamp + 1);\n            }\n            return true;\n        }\n        else\n        {\n            unpin( lockType );\n        }\n        return false;\n    }","id":47932,"modified_method":"@Override\n    public boolean pin( PageIO assertIO, long assertPageId, PageLock lockType )\n    {\n        lock( lockType );\n        if( verifyPageBindings( assertIO, assertPageId ) )\n        {\n            byte stamp = usageStamp;\n            if ( stamp < MAX_USAGE_COUNT )\n            {\n                // Racy, but we don't care\n                usageStamp = (byte) (stamp + 1);\n            }\n            return true;\n        }\n        else\n        {\n            unpin( lockType );\n        }\n        return false;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void flush() throws IOException\n    {\n        if ( dirty )\n        {\n            buffer().position(0);\n            io.write( pageId, buffer );\n            dirty = false;\n        }\n    }","id":47933,"modified_method":"/**\n     * Must be call under lock\n     */\n    void flush() throws IOException\n    {\n        assertLocked();\n        if ( dirty )\n        {\n            buffer().position(0);\n            io.write( pageId, buffer );\n            dirty = false;\n        }\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void lock( PageLock lockType )\n    {\n        if(lockType == PageLock.SHARED)\n        {\n            lock.readLock().lock();\n        }\n        else if( lockType == PageLock.EXCLUSIVE )\n        {\n            lock.writeLock().lock();\n            dirty = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Unknown lock type: \" + lockType );\n        }\n    }","id":47934,"modified_method":"void lock( PageLock lockType )\n    {\n        if(lockType == PageLock.SHARED)\n        {\n            lock.readLock().lock();\n        }\n        else if( lockType == PageLock.EXCLUSIVE )\n        {\n            lock.writeLock().lock();\n            dirty = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Unknown lock type: \" + lockType );\n        }\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long pageId()\n    {\n        return pageId;\n    }","id":47935,"modified_method":"/**\n     * Must be call under lock\n     */\n    long pageId()\n    {\n        assertLocked();\n        return pageId;\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public String toString()\n    {\n        return \"StandardPinnablePage{\" +\n                \"buffer=\" + buffer +\n                \", io=\" + io +\n                \", pageId=\" + pageId +\n                \", dirty=\" + dirty +\n                \", usageStamp=\" + usageStamp +\n                \", loaded=\" + loaded +\n                '}';\n    }","id":47936,"modified_method":"/**\n     * Should be call under lock\n     */\n    @Override\n    public String toString()\n    {\n        return \"StandardPinnablePage{\" +\n                \"buffer=\" + buffer +\n                \", io=\" + io +\n                \", pageId=\" + pageId +\n                \", dirty=\" + dirty +\n                \", usageStamp=\" + usageStamp +\n                \", loaded=\" + loaded +\n                '}';\n    }","commit_id":"54eac46eb58de6d10c06d950452d502ca51b2309","url":"https://github.com/neo4j/neo4j"},{"original_method":"/** Determines the CSV parser setup from the first few lines.  Also parses\n   *  the next few lines, tossing out comments and blank lines.\n   *\n   *  If the separator is AUTO_SEP, then it is guessed by looking at tokenization \n   *  and column count of the first few lines.\n   *\n   *  If ncols is -1, then it is guessed similarly to the separator.\n   *\n   *  singleQuotes is honored in all cases (and not guessed).\n   *\n   *  checkHeader== -1 ==> 1st line is data, not header\n   *  checkHeader== +1 ==> 1st line is header, not data.  Error if not compatible with prior header\n   *  checkHeader==  0 ==> Guess 1st line header, only if compatible with prior\n   */\n  static ParseSetup guessSetup(byte[] bits, byte sep, int ncols, boolean singleQuotes, int checkHeader, String[] columnNames) {\n\n    // Parse up to 10 lines (skipping hash-comments & ARFF comments)\n    String[] lines = new String[10]; // Parse 10 lines\n    int nlines = 0;\n    int offset = 0;\n    while( offset < bits.length && nlines < lines.length ) {\n      int lineStart = offset;\n      while( offset < bits.length && !CsvParser.isEOL(bits[offset]) ) ++offset;\n      int lineEnd = offset;\n      ++offset;\n      // For Windoze, skip a trailing LF after CR\n      if( (offset < bits.length) && (bits[offset] == CsvParser.CHAR_LF)) ++offset;\n      if( bits[lineStart] == '#') continue; // Ignore      comment lines\n      if( bits[lineStart] == '%') continue; // Ignore ARFF comment lines\n      if( bits[lineStart] == '@') continue; // Ignore ARFF lines\n      if( lineEnd > lineStart ) {\n        String str = new String(bits, lineStart,lineEnd-lineStart).trim();\n        if( !str.isEmpty() ) lines[nlines++] = str;\n      }\n    }\n    if( nlines==0 )\n      return new ParseSetup(false,0,0,new String[]{\"No data!\"},ParserType.AUTO,AUTO_SEP,0,false,null,null,null,checkHeader, null, FileVec.DFLT_CHUNK_SIZE);\n\n    // Guess the separator, columns, & header\n    ArrayList<String> errors = new ArrayList<>();\n    String[] labels;\n    final byte single_quote = singleQuotes ? CsvParser.CHAR_SINGLE_QUOTE : -1;\n    final String[][] data = new String[nlines][];\n    if( nlines == 1 ) {       // Ummm??? Only 1 line?\n      if( sep == AUTO_SEP ) {\n        if( lines[0].split(\",\").length > 2 ) sep = (byte)',';\n        else if( lines[0].split(\" \").length > 2 ) sep = ' ';\n        else \n          return new ParseSetup(false,1,0,new String[]{\"Failed to guess separator.\"},ParserType.CSV,AUTO_SEP,ncols,singleQuotes,null,null,data,checkHeader, null, FileVec.DFLT_CHUNK_SIZE);\n      }\n      data[0] = determineTokens(lines[0], sep, single_quote);\n      ncols = (ncols > 0) ? ncols : data[0].length;\n      if( checkHeader == 0 ) labels =  ParseSetup.allStrings(data[0]) ? data[0] : null;\n      else if( checkHeader == 1 ) labels = data[0];\n      else labels = null;\n    } else {                    // 2 or more lines\n\n      // First guess the field separator by counting occurrences in first few lines\n      if( sep == AUTO_SEP ) {   // first guess the separator\n        sep = guessSeparator(lines[0], lines[1], single_quote);\n        if( sep == AUTO_SEP && nlines > 2 ) {\n          if( sep == AUTO_SEP ) sep = guessSeparator(lines[1], lines[2], single_quote);\n          if( sep == AUTO_SEP ) sep = guessSeparator(lines[0], lines[2], single_quote);\n        }\n        if( sep == AUTO_SEP ) sep = (byte)' '; // Bail out, go for space\n      }\n\n      // Tokenize the first few lines using the separator\n      for( int i = 0; i < nlines; ++i )\n        data[i] = determineTokens(lines[i], sep, single_quote );\n      // guess columns from tokenization\n      ncols = guessNcols(columnNames,data);\n\n      // Asked to check for a header, so see if 1st line looks header-ish\n      if( checkHeader == 0 ) {  // Guess\n        labels = ParseSetup.hasHeader(data[0],data[1]) && (data[0].length == ncols) ? data[0] : null;\n      } else if( checkHeader == 1 ) { // Told: take 1st line\n        labels = data[0];\n      } else {                  // Told: no headers\n        labels = null;\n      }\n      if( checkHeader == 0 ) checkHeader = labels==null ? -1 : +1;\n      \n      // See if compatible headers\n      if( columnNames != null && labels != null ) {\n        if( labels.length != columnNames.length )\n          errors.add(\"Already have \"+columnNames.length+\" column labels, but found \"+labels.length+\" in this file\");\n        else {\n          for( int i = 0; i < labels.length; ++i )\n            if( !labels[i].equalsIgnoreCase(columnNames[i]) ) {\n              errors.add(\"Column \"+(i+1)+\" label '\"+labels[i]+\"' does not match '\"+columnNames[i]+\"'\");\n              break;\n            }\n          labels = columnNames; // Keep prior case & count in any case\n        }\n      }\n    }\n\n    // Count broken lines; gather error messages\n    int ilines = 0;\n    for( int i = 0; i < data.length; ++i ) {\n      if( data[i].length != ncols ) {\n        errors.add(\"error at line \" + i + \" : incompatible line length. Got \" + data[i].length + \" columns.\");\n        ++ilines;\n      }\n    }\n    String[] err = null;\n    if( !errors.isEmpty() )\n      errors.toArray(err = new String[errors.size()]);\n\n    // Assemble the setup understood so far\n    ParseSetup resSetup = new ParseSetup(true, ilines, labels != null ? 1 : 0, err, ParserType.CSV, sep, ncols, singleQuotes, labels, null /*domains*/, data, checkHeader, null);\n\n    // now guess the types\n    InputStream is = new ByteArrayInputStream(bits);\n    CsvParser p = new CsvParser(resSetup);\n    InspectDataOut dout = new InspectDataOut(resSetup._ncols);\n    try{\n      p.streamParse(is, dout);\n      resSetup._ctypes = dout.guessTypes();\n    }catch(Throwable e){\n      throw new RuntimeException(e);\n    }\n\n    // Return the final setup\n    return resSetup;\n  }","id":47937,"modified_method":"/** Determines the CSV parser setup from the first few lines.  Also parses\n   *  the next few lines, tossing out comments and blank lines.\n   *\n   *  If the separator is AUTO_SEP, then it is guessed by looking at tokenization \n   *  and column count of the first few lines.\n   *\n   *  If ncols is -1, then it is guessed similarly to the separator.\n   *\n   *  singleQuotes is honored in all cases (and not guessed).\n   *\n   *  checkHeader== -1 ==> 1st line is data, not header\n   *  checkHeader== +1 ==> 1st line is header, not data.  Error if not compatible with prior header\n   *  checkHeader==  0 ==> Guess 1st line header, only if compatible with prior\n   */\n  static ParseSetup guessSetup(byte[] bits, byte sep, int ncols, boolean singleQuotes, int checkHeader, String[] columnNames) {\n\n    // Parse up to 10 lines (skipping hash-comments & ARFF comments)\n    String[] lines = new String[10]; // Parse 10 lines\n    int nlines = 0;\n    int offset = 0;\n    while( offset < bits.length && nlines < lines.length ) {\n      int lineStart = offset;\n      while( offset < bits.length && !CsvParser.isEOL(bits[offset]) ) ++offset;\n      int lineEnd = offset;\n      ++offset;\n      // For Windoze, skip a trailing LF after CR\n      if( (offset < bits.length) && (bits[offset] == CsvParser.CHAR_LF)) ++offset;\n      if( bits[lineStart] == '#') continue; // Ignore      comment lines\n      if( bits[lineStart] == '%') continue; // Ignore ARFF comment lines\n      if( bits[lineStart] == '@') continue; // Ignore ARFF lines\n      if( lineEnd > lineStart ) {\n        String str = new String(bits, lineStart,lineEnd-lineStart).trim();\n        if( !str.isEmpty() ) lines[nlines++] = str;\n      }\n    }\n    if( nlines==0 )\n      return new ParseSetup(false,0,0,new String[]{\"No data!\"},ParserType.AUTO,AUTO_SEP,0,false,null,null,null,checkHeader, null, FileVec.DFLT_CHUNK_SIZE);\n\n    // Guess the separator, columns, & header\n    ArrayList<String> errors = new ArrayList<>();\n    String[] labels;\n    final byte single_quote = singleQuotes ? CsvParser.CHAR_SINGLE_QUOTE : -1;\n    final String[][] data = new String[nlines][];\n    if( nlines == 1 ) {       // Ummm??? Only 1 line?\n      if( sep == AUTO_SEP ) {\n        if (lines[0].split(\",\").length > 2) sep = (byte) ',';\n        else if (lines[0].split(\" \").length > 2) sep = ' ';\n        else { //one item, guess type\n          data[0] = new String[]{lines[0]};\n          ColTypeInfo[] ctypes = new ColTypeInfo[1];\n          String[][] domains = new String[1][];\n          if (NumberUtils.isNumber(data[0][0])) {\n            ctypes[0] = new ColTypeInfo(ColType.NUM);\n          } else { // non-numeric\n            ValueString str = new ValueString(data[0][0]);\n            if (ParseTime.isDateTime(str))\n              ctypes[0] = new ColTypeInfo(ColType.TIME);\n            else if (ParseTime.isUUID(str))\n                ctypes[0] = new ColTypeInfo(ColType.UUID);\n            else { // give up and guess enum\n                ctypes[0] = new ColTypeInfo(ColType.ENUM);\n                domains[0] = new String[]{data[0][0]};\n            }\n          }\n          return new ParseSetup(true, 0, 0, new String[]{\"Failed to guess separator.\"}, ParserType.CSV, AUTO_SEP, 1, singleQuotes, null, domains, data, checkHeader, ctypes, FileVec.DFLT_CHUNK_SIZE);\n        }\n      }\n      data[0] = determineTokens(lines[0], sep, single_quote);\n      ncols = (ncols > 0) ? ncols : data[0].length;\n      if( checkHeader == 0 ) labels =  ParseSetup.allStrings(data[0]) ? data[0] : null;\n      else if( checkHeader == 1 ) labels = data[0];\n      else labels = null;\n    } else {                    // 2 or more lines\n\n      // First guess the field separator by counting occurrences in first few lines\n      if( sep == AUTO_SEP ) {   // first guess the separator\n        sep = guessSeparator(lines[0], lines[1], single_quote);\n        if( sep == AUTO_SEP && nlines > 2 ) {\n          if( sep == AUTO_SEP ) sep = guessSeparator(lines[1], lines[2], single_quote);\n          if( sep == AUTO_SEP ) sep = guessSeparator(lines[0], lines[2], single_quote);\n        }\n        if( sep == AUTO_SEP ) sep = (byte)' '; // Bail out, go for space\n      }\n\n      // Tokenize the first few lines using the separator\n      for( int i = 0; i < nlines; ++i )\n        data[i] = determineTokens(lines[i], sep, single_quote );\n      // guess columns from tokenization\n      ncols = guessNcols(columnNames,data);\n\n      // Asked to check for a header, so see if 1st line looks header-ish\n      if( checkHeader == 0 ) {  // Guess\n        labels = ParseSetup.hasHeader(data[0],data[1]) && (data[0].length == ncols) ? data[0] : null;\n      } else if( checkHeader == 1 ) { // Told: take 1st line\n        labels = data[0];\n      } else {                  // Told: no headers\n        labels = null;\n      }\n      if( checkHeader == 0 ) checkHeader = labels==null ? -1 : +1;\n      \n      // See if compatible headers\n      if( columnNames != null && labels != null ) {\n        if( labels.length != columnNames.length )\n          errors.add(\"Already have \"+columnNames.length+\" column labels, but found \"+labels.length+\" in this file\");\n        else {\n          for( int i = 0; i < labels.length; ++i )\n            if( !labels[i].equalsIgnoreCase(columnNames[i]) ) {\n              errors.add(\"Column \"+(i+1)+\" label '\"+labels[i]+\"' does not match '\"+columnNames[i]+\"'\");\n              break;\n            }\n          labels = columnNames; // Keep prior case & count in any case\n        }\n      }\n    }\n\n    // Count broken lines; gather error messages\n    int ilines = 0;\n    for( int i = 0; i < data.length; ++i ) {\n      if( data[i].length != ncols ) {\n        errors.add(\"error at line \" + i + \" : incompatible line length. Got \" + data[i].length + \" columns.\");\n        ++ilines;\n      }\n    }\n    String[] err = null;\n    if( !errors.isEmpty() )\n      errors.toArray(err = new String[errors.size()]);\n\n    // Assemble the setup understood so far\n    ParseSetup resSetup = new ParseSetup(true, ilines, labels != null ? 1 : 0, err, ParserType.CSV, sep, ncols, singleQuotes, labels, null /*domains*/, data, checkHeader, null);\n\n    // now guess the types\n    InputStream is = new ByteArrayInputStream(bits);\n    CsvParser p = new CsvParser(resSetup);\n    InspectDataOut dout = new InspectDataOut(resSetup._ncols);\n    try{\n      p.streamParse(is, dout);\n      resSetup._ctypes = dout.guessTypes();\n    }catch(Throwable e){\n      throw new RuntimeException(e);\n    }\n\n    // Return the final setup\n    return resSetup;\n  }","commit_id":"02244b4e72126948cc4515dc0bd1d617930e6c60","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void addStrCol(int colIdx, ValueString str) {\n      if(colIdx < _ncols) {\n        // Check for time\n        if (ParseTime.attemptTimeParse(str) != Long.MIN_VALUE) {\n          ++_ndates[colIdx];\n          return;\n        }\n\n        //Check for UUID\n        int old = str.get_off();\n        ParseTime.attemptUUIDParse0(str);\n        ParseTime.attemptUUIDParse1(str);\n        if( str.get_off() != -1 ) {\n          ++_nUUID[colIdx];\n          return;\n        }\n        str.setOff(old);\n\n        //Add string to domains list for later determining string, NA, or enum\n        ++_nstrings[colIdx];\n        _domains[colIdx].add(str.toString());\n\n        if (_nlines < MAX_PREVIEW_LINES)\n            _data[_nlines][colIdx] = str.toString();\n      }\n    }","id":47938,"modified_method":"@Override public void addStrCol(int colIdx, ValueString str) {\n      if(colIdx < _ncols) {\n        // Check for time\n        if (ParseTime.isDateTime(str)) {\n          ++_ndates[colIdx];\n          return;\n        }\n\n        //Check for UUID\n        if(ParseTime.isUUID(str)) {\n          ++_nUUID[colIdx];\n          return;\n        }\n\n        //Add string to domains list for later determining string, NA, or enum\n        ++_nstrings[colIdx];\n        _domains[colIdx].add(str.toString());\n\n        if (_nlines < MAX_PREVIEW_LINES)\n            _data[_nlines][colIdx] = str.toString();\n      }\n    }","commit_id":"02244b4e72126948cc4515dc0bd1d617930e6c60","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public void addStrCol(int colIdx, ValueString str) {\n    if(colIdx < _nvs.length){\n      if(_ctypes[colIdx] == Vec.T_NUM){ // support enforced types\n        addInvalidCol(colIdx);\n        return;\n      }\n      if(_ctypes[colIdx] == Vec.T_BAD && ParseTime.attemptTimeParse(str) > 0)\n        _ctypes[colIdx] = Vec.T_TIME;\n      if( _ctypes[colIdx] == Vec.T_BAD ) { // Attempt UUID parse\n        int old = str.get_off();\n        ParseUUID.attemptUUIDParse0(str);\n        ParseUUID.attemptUUIDParse1(str);\n        if( str.get_off() != -1 ) _ctypes[colIdx] = Vec.T_UUID;\n        str.setOff(old);\n      }\n\n      if( _ctypes[colIdx] == Vec.T_TIME ) {\n        long l = ParseTime.attemptTimeParse(str);\n        if( l == Long.MIN_VALUE ) addInvalidCol(colIdx);\n        else {\n          int time_pat = ParseTime.decodePat(l); // Get time pattern\n          l = ParseTime.decodeTime(l);           // Get time\n          addNumCol(colIdx, l, 0);               // Record time in msec\n          _nvs[_col]._timCnt[time_pat]++; // Count histo of time parse patterns\n        }\n      } else if( _ctypes[colIdx] == Vec.T_UUID ) { // UUID column?  Only allow UUID parses\n        long lo = ParseUUID.attemptUUIDParse0(str);\n        long hi = ParseUUID.attemptUUIDParse1(str);\n        if( str.get_off() == -1 )  { lo = C16Chunk._LO_NA; hi = C16Chunk._HI_NA; }\n        if( colIdx < _nCols ) _nvs[_col = colIdx].addUUID(lo, hi);\n      } else if( _ctypes[colIdx] == Vec.T_STR ) {\n        _nvs[_col = colIdx].addStr(str);\n      } else { // Enums\n        if(!_enums[colIdx].isMapFull()) {\n          int id = _enums[_col = colIdx].addKey(str);\n          if (_ctypes[colIdx] == Vec.T_BAD && id > 1) _ctypes[colIdx] = Vec.T_ENUM;\n          _nvs[colIdx].addEnum(id);\n        } else { // maxed out enum map\n          throw new H2OParseException(\"Exceeded enumeration limit.  Consider reparsing this column as a string.\");\n        }\n      }\n    }\n  }","id":47939,"modified_method":"@Override public void addStrCol(int colIdx, ValueString str) {\n    if(colIdx < _nvs.length){\n      if(_ctypes[colIdx] == Vec.T_NUM){ // support enforced types\n        addInvalidCol(colIdx);\n        return;\n      }\n      if(_ctypes[colIdx] == Vec.T_BAD && ParseTime.isTime(str))\n        _ctypes[colIdx] = Vec.T_TIME;\n      if( _ctypes[colIdx] == Vec.T_BAD && ParseUUID.isUUID(str))\n        _ctypes[colIdx] = Vec.T_UUID;\n\n      if( _ctypes[colIdx] == Vec.T_TIME ) {\n        long l = ParseTime.attemptTimeParse(str);\n        if( l == Long.MIN_VALUE ) addInvalidCol(colIdx);\n        else {\n          int time_pat = ParseTime.decodePat(l); // Get time pattern\n          l = ParseTime.decodeTime(l);           // Get time\n          addNumCol(colIdx, l, 0);               // Record time in msec\n          _nvs[_col]._timCnt[time_pat]++; // Count histo of time parse patterns\n        }\n      } else if( _ctypes[colIdx] == Vec.T_UUID ) { // UUID column?  Only allow UUID parses\n        long lo = ParseUUID.attemptUUIDParse0(str);\n        long hi = ParseUUID.attemptUUIDParse1(str);\n        if( str.get_off() == -1 )  { lo = C16Chunk._LO_NA; hi = C16Chunk._HI_NA; }\n        if( colIdx < _nCols ) _nvs[_col = colIdx].addUUID(lo, hi);\n      } else if( _ctypes[colIdx] == Vec.T_STR ) {\n        _nvs[_col = colIdx].addStr(str);\n      } else { // Enums\n        if(!_enums[colIdx].isMapFull()) {\n          int id = _enums[_col = colIdx].addKey(str);\n          if (_ctypes[colIdx] == Vec.T_BAD && id > 1) _ctypes[colIdx] = Vec.T_ENUM;\n          _nvs[colIdx].addEnum(id);\n        } else { // maxed out enum map\n          throw new H2OParseException(\"Exceeded enumeration limit.  Consider reparsing this column as a string.\");\n        }\n      }\n    }\n  }","commit_id":"ac8e50ccf5d95a2ef16d94f0c5f19cd4690a4148","url":"https://github.com/h2oai/h2o-3"},{"original_method":"static boolean allStrings(String [] line){\n    ValueString str = new ValueString();\n    for( String s : line ) {\n      try {\n        Double.parseDouble(s);\n        return false;       // Number in 1st row guesses: No Column Header\n      } catch (NumberFormatException e) { /*Pass - determining if number is possible*/ }\n      if( ParseTime.attemptTimeParse(str.setTo(s)) != Long.MIN_VALUE ) return false;\n      ParseUUID.attemptUUIDParse0(str.setTo(s));\n      ParseUUID.attemptUUIDParse1(str);\n      if( str.get_off() != -1 ) return false; // Valid UUID parse\n    }\n    return true;\n  }","id":47940,"modified_method":"static boolean allStrings(String [] line){\n    ValueString str = new ValueString();\n    for( String s : line ) {\n      try {\n        Double.parseDouble(s);\n        return false;       // Number in 1st row guesses: No Column Header\n      } catch (NumberFormatException e) { /*Pass - determining if number is possible*/ }\n      str.setTo(s);\n      if(ParseTime.isTime(str)) return false;\n      if(ParseUUID.isUUID(str)) return false;\n    }\n    return true;\n  }","commit_id":"ac8e50ccf5d95a2ef16d94f0c5f19cd4690a4148","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Test\n     public void testPost() throws Exception\n     {\n         startClient(_realm);\n     \n         ContentExchange postExchange = new ContentExchange();\n         postExchange.setURL(getBaseUrl() + \"test\");\n         postExchange.setMethod(HttpMethods.POST);\n         postExchange.setRequestContent(new ByteArrayBuffer(_content.getBytes()));\n    \n         _client.send(postExchange);\n         int state = postExchange.waitForDone();\n     \n         int responseStatus = postExchange.getResponseStatus();\n  \n         stopClient();\n     \n         assertEquals(HttpStatus.OK_200,responseStatus);\n         assertEquals(_content,_requestContent);\n     }","id":47941,"modified_method":"@Test\n     public void testPost() throws Exception\n     {\n         try\n         {\n             startClient();\n\n             Request request = _client.newRequest(getBaseUrl() + \"test\");\n             request.method(HttpMethod.POST);\n             request.content(new BytesContentProvider(_content.getBytes()));\n             Future<ContentResponse> future = request.send();\n             ContentResponse response = future.get();\n             assertEquals(HttpStatus.OK_200,response.getStatus());\n             assertEquals(_content,_requestContent);\n         }\n         finally\n         {\n             stopClient();\n         }\n     }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n     public void testGet() throws Exception\n     {\n         startClient(_realm);\n     \n         ContentExchange getExchange = new ContentExchange();\n         getExchange.setURL(getBaseUrl() + \"input.txt\");\n         getExchange.setMethod(HttpMethods.GET);\n     \n         _client.send(getExchange);\n         int state = getExchange.waitForDone();\n     \n         String content = \"\";\n         int responseStatus = getExchange.getResponseStatus();\n         if (responseStatus == HttpStatus.OK_200)\n         {\n             content = getExchange.getResponseContent();\n         }\n     \n         stopClient();\n     \n         assertEquals(HttpStatus.OK_200,responseStatus);\n         assertEquals(_content,content);\n     }","id":47942,"modified_method":"@Test\n     public void testGet() throws Exception\n     {\n         try\n         {\n             startClient();\n\n             Future<ContentResponse> future = _client.GET(getBaseUrl() + \"input.txt\");\n             ContentResponse response = future.get();\n             assertEquals(HttpServletResponse.SC_OK,response.getStatus());\n             assertEquals(_content, response.getContentAsString());\n         }\n         finally \n         {\n             stopClient();\n         }\n     }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected static void configureServer(Server server)\n        throws Exception\n    {\n        setProtocol(\"http\");\n        setRealm(new Realm()\n                 {\n                     public String getId()\n                     {\n                         return \"JdbcRealm\";\n                     }\n                \n                     public String getPrincipal()\n                     {\n                         return \"jetty\";\n                     }\n                \n                     public String getCredentials()\n                     {\n                         return \"jetty\";\n                     }\n                 });\n                        \n        SelectChannelConnector connector = new SelectChannelConnector();\n        server.addConnector(connector);\n        \n        LoginService loginService = new JDBCLoginService(\"JdbcRealm\", \"./src/test/resources/jdbcrealm.properties\");\n        server.addBean(loginService); \n\n        ConstraintSecurityHandler security = new ConstraintSecurityHandler();\n        server.setHandler(security);\n\n        Constraint constraint = new Constraint();\n        constraint.setName(\"auth\");\n        constraint.setAuthenticate( true );\n        constraint.setRoles(new String[]{\"user\", \"admin\"});\n\n        ConstraintMapping mapping = new ConstraintMapping();\n        mapping.setPathSpec( \"/*\" );\n        mapping.setConstraint( constraint );\n\n        Set<String> knownRoles = new HashSet<String>();\n        knownRoles.add(\"user\");\n        knownRoles.add(\"admin\");\n        \n        security.setConstraintMappings(Collections.singletonList(mapping), knownRoles);\n        security.setAuthenticator(new BasicAuthenticator());\n        security.setLoginService(loginService);\n        security.setStrict(false);\n        \n        ServletContextHandler root = new ServletContextHandler();\n        root.setContextPath(\"/\");\n        root.setResourceBase(getBasePath());\n        ServletHolder servletHolder = new ServletHolder( new DefaultServlet() );\n        servletHolder.setInitParameter( \"gzip\", \"true\" );\n        root.addServlet( servletHolder, \"/*\" );    \n\n        Handler handler = new TestHandler(getBasePath());       \n        \n        HandlerCollection handlers = new HandlerCollection();\n        handlers.setHandlers(new Handler[]{handler, root});\n        security.setHandler(handlers);\n    }","id":47943,"modified_method":"protected static void configureServer(Server server)\n        throws Exception\n    {\n        setProtocol(\"http\");\n\n        LoginService loginService = new JDBCLoginService(__realm, \"./src/test/resources/jdbcrealm.properties\");\n        server.addBean(loginService); \n\n        ConstraintSecurityHandler security = new ConstraintSecurityHandler();\n        server.setHandler(security);\n\n        Constraint constraint = new Constraint();\n        constraint.setName(\"auth\");\n        constraint.setAuthenticate( true );\n        constraint.setRoles(new String[]{\"user\", \"admin\"});\n\n        ConstraintMapping mapping = new ConstraintMapping();\n        mapping.setPathSpec( \"/*\" );\n        mapping.setConstraint( constraint );\n\n        Set<String> knownRoles = new HashSet<String>();\n        knownRoles.add(\"user\");\n        knownRoles.add(\"admin\");\n        \n        security.setConstraintMappings(Collections.singletonList(mapping), knownRoles);\n        security.setAuthenticator(new BasicAuthenticator());\n        security.setLoginService(loginService);\n        security.setStrict(false);\n        \n        ServletContextHandler root = new ServletContextHandler();\n        root.setContextPath(\"/\");\n        root.setResourceBase(getBasePath());\n        ServletHolder servletHolder = new ServletHolder( new DefaultServlet() );\n        servletHolder.setInitParameter( \"gzip\", \"true\" );\n        root.addServlet( servletHolder, \"/*\" );    \n\n        Handler handler = new TestHandler(getBasePath());       \n        \n        HandlerCollection handlers = new HandlerCollection();\n        handlers.setHandlers(new Handler[]{handler, root});\n        security.setHandler(handlers);\n    }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(String target, Request baseRequest,\n                 HttpServletRequest request, HttpServletResponse response)\n             throws IOException, ServletException\n         {\n             if (baseRequest.isHandled())\n             {\n                 return;\n             }\n\n             OutputStream out = null;\n             \n             if (baseRequest.getMethod().equals(\"PUT\"))\n             {\n                 baseRequest.setHandled(true);\n\n                 File file = new File(resourcePath, URLDecoder.decode(request.getPathInfo()));\n                 file.getParentFile().mkdirs();\n                 file.deleteOnExit();\n             \n                 out = new FileOutputStream(file);\n\n                     response.setStatus(HttpServletResponse.SC_CREATED);\n             }\n             \n             if (baseRequest.getMethod().equals(\"POST\"))\n             {\n                 baseRequest.setHandled(true);\n                 out = new ByteArrayOutputStream();\n\n                 response.setStatus(HttpServletResponse.SC_OK);\n             }\n             \n             if (out != null)\n             {\n                 ServletInputStream in = request.getInputStream();\n                 try\n                 {\n                     copyStream( in, out );\n                 }\n                 finally\n                 {\n                     in.close();\n                     out.close();\n                 }\n                 \n                 if (!(out instanceof FileOutputStream))\n                     _requestContent = out.toString();\n             }\n             \n         }","id":47944,"modified_method":"public void handle(String target, org.eclipse.jetty.server.Request baseRequest,\n                 HttpServletRequest request, HttpServletResponse response)\n             throws IOException, ServletException\n         {\n             if (baseRequest.isHandled())\n             {\n                 return;\n             }\n\n             OutputStream out = null;\n             \n             if (baseRequest.getMethod().equals(\"PUT\"))\n             {\n                 baseRequest.setHandled(true);\n\n                 File file = new File(resourcePath, URLDecoder.decode(request.getPathInfo()));\n                 file.getParentFile().mkdirs();\n                 file.deleteOnExit();\n             \n                 out = new FileOutputStream(file);\n\n                     response.setStatus(HttpServletResponse.SC_CREATED);\n             }\n             \n             if (baseRequest.getMethod().equals(\"POST\"))\n             {\n                 baseRequest.setHandled(true);\n                 out = new ByteArrayOutputStream();\n\n                 response.setStatus(HttpServletResponse.SC_OK);\n             }\n             \n             if (out != null)\n             {\n                 ServletInputStream in = request.getInputStream();\n                 try\n                 {\n                     copyStream( in, out );\n                 }\n                 finally\n                 {\n                     in.close();\n                     out.close();\n                 }\n                 \n                 if (!(out instanceof FileOutputStream))\n                     _requestContent = out.toString();\n             }\n             \n         }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n     public void testPut() throws Exception\n     {\n         startClient(_realm);\n     \n         ContentExchange putExchange = new ContentExchange();\n         putExchange.setURL(getBaseUrl() + \"output.txt\");\n         putExchange.setMethod(HttpMethods.PUT);\n         putExchange.setRequestContent(new ByteArrayBuffer(_content.getBytes()));\n     \n         _client.send(putExchange);\n         int state = putExchange.waitForDone();\n     \n         int responseStatus = putExchange.getResponseStatus();\n     \n         stopClient();\n     \n         boolean statusOk = (responseStatus == 200 || responseStatus == 201);\n         assertTrue(statusOk);\n         \n         String content = IO.toString(new FileInputStream(new File(_docRoot,\"output.txt\")));\n         assertEquals(_content,content);\n     }","id":47945,"modified_method":"@Test\n     public void testPut() throws Exception\n     {\n         try\n         {\n             startClient();\n\n             Request request = _client.newRequest(getBaseUrl() + \"output.txt\");\n             request.method(HttpMethod.PUT);\n             request.content(new BytesContentProvider(_content.getBytes()));\n             Future<ContentResponse> future = request.send();\n             ContentResponse response = future.get();\n             int responseStatus = response.getStatus();\n             boolean statusOk = (responseStatus == 200 || responseStatus == 201);\n             assertTrue(statusOk);\n             String content = IO.toString(new FileInputStream(new File(_docRoot,\"output.txt\")));\n             assertEquals(_content,content);\n         }\n         finally\n         {\n             stopClient();\n         }\n     }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@BeforeClass\n     public static void setUp()\n         throws Exception\n     {\n         _docRoot = new File(\"target/test-output/docroot/\");\n         _docRoot.mkdirs();\n         _docRoot.deleteOnExit();\n         \n         File content = new File(_docRoot,\"input.txt\");\n         FileOutputStream out = new FileOutputStream(content);\n         out.write(_content.getBytes(\"utf-8\"));\n         out.close();\n\n         File dbRoot = new File(\"target/test-output/derby\");\n         String dbPath = dbRoot.getAbsolutePath();\n         System.setProperty(\"derby.system.home\", dbPath);\n         if (!dbRoot.exists())\n         {\n             dbRoot.mkdirs();\n             createDB(dbPath, \"src/test/resources/createdb.sql\", \"jdbc:derby:jdbcrealm;create=true\");\n         }\n         \n         _server = new Server();\n         configureServer(_server);\n         _server.start();\n\n         int port = _server.getConnectors()[0].getLocalPort();\n         _baseUrl = _protocol+\"://localhost:\"+port+ \"/\";\n     }","id":47946,"modified_method":"@BeforeClass\n     public static void setUp()\n         throws Exception\n     {\n         _docRoot = new File(\"target/test-output/docroot/\");\n         _docRoot.mkdirs();\n         _docRoot.deleteOnExit();\n         \n         File content = new File(_docRoot,\"input.txt\");\n         FileOutputStream out = new FileOutputStream(content);\n         out.write(_content.getBytes(\"utf-8\"));\n         out.close();\n\n         File dbRoot = new File(\"target/test-output/derby\");\n         String dbPath = dbRoot.getAbsolutePath();\n         System.setProperty(\"derby.system.home\", dbPath);\n         if (!dbRoot.exists())\n         {\n             dbRoot.mkdirs();\n             createDB(dbPath, \"src/test/resources/createdb.sql\", \"jdbc:derby:jdbcrealm;create=true\");\n         }\n         \n         _server = new Server(0);\n         configureServer(_server);\n         _server.start();\n\n         int port = ((NetworkConnector)_server.getConnectors()[0]).getLocalPort();\n         _baseUrl = _protocol+\"://localhost:\"+port+ \"/\";\n         \n     \n     }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n     public void testHead() throws Exception\n     {\n         startClient(_realm);\n     \n         ContentExchange getExchange = new ContentExchange();\n         getExchange.setURL(getBaseUrl() + \"input.txt\");\n         getExchange.setMethod(HttpMethods.HEAD);\n     \n         _client.send(getExchange);\n         int state = getExchange.waitForDone();\n     \n         int responseStatus = getExchange.getResponseStatus();\n\n         stopClient();\n     \n         assertEquals(HttpStatus.OK_200,responseStatus);\n     }","id":47947,"modified_method":"@Ignore\n     public void testHead() throws Exception\n     {\n         try\n         {\n             startClient();\n\n             Request request = _client.newRequest(getBaseUrl() + \"input.txt\");\n             request.method(HttpMethod.HEAD);\n             Future<ContentResponse> future = request.send();\n             ContentResponse response = future.get();\n             int responseStatus = response.getStatus();\n             assertEquals(HttpStatus.OK_200,responseStatus);\n         }\n         finally\n         {\n             stopClient();\n         }\n     }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void startClient(Realm realm)\n         throws Exception\n     {\n         _client = new HttpClient();\n         _client.setConnectorType(HttpClient.CONNECTOR_SELECT_CHANNEL);\n         if (realm != null)\n             _client.setRealmResolver(new SimpleRealmResolver(realm));\n         _client.start();\n     }","id":47948,"modified_method":"protected void startClient()\n         throws Exception\n     {\n         _client = new HttpClient();\n         QueuedThreadPool executor = new QueuedThreadPool();\n         executor.setName(executor.getName() + \"-client\");\n         _client.setExecutor(executor);\n         AuthenticationStore authStore = _client.getAuthenticationStore();\n         authStore.addAuthentication(new BasicAuthentication(_baseUrl, __realm, \"jetty\", \"jetty\"));\n         _client.start();\n     }","commit_id":"be816d853b165083291ba8c145fbf23b35a70071","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public TimelineMetric getTimelineMetric(String metricName, String hostname,\n      String applicationId, String instanceId, Long startTime,\n      Long endTime, Precision precision, Integer limit)\n      throws SQLException, IOException {\n\n    TimelineMetrics metrics = hBaseAccessor.getMetricRecords(\n      new LikeCondition(Collections.singletonList(metricName), hostname,\n        applicationId, instanceId, startTime, endTime, precision, limit, true)\n    );\n\n    TimelineMetric metric = new TimelineMetric();\n    List<TimelineMetric> metricList = metrics.getMetrics();\n\n    if (metricList != null && !metricList.isEmpty()) {\n      metric.setMetricName(metricList.get(0).getMetricName());\n      metric.setAppId(metricList.get(0).getAppId());\n      metric.setInstanceId(metricList.get(0).getInstanceId());\n      metric.setHostName(metricList.get(0).getHostName());\n      // Assumption that metrics are ordered by start time\n      metric.setStartTime(metricList.get(0).getStartTime());\n      Map<Long, Double> metricRecords = new TreeMap<Long, Double>();\n      for (TimelineMetric timelineMetric : metricList) {\n        metricRecords.putAll(timelineMetric.getMetricValues());\n      }\n      metric.setMetricValues(metricRecords);\n    }\n\n    return metric;\n  }","id":47949,"modified_method":"@Override\n  public TimelineMetric getTimelineMetric(String metricName, String hostname,\n      String applicationId, String instanceId, Long startTime,\n      Long endTime, Precision precision, Integer limit)\n      throws SQLException, IOException {\n\n    TimelineMetrics metrics = hBaseAccessor.getMetricRecords(\n      new DefaultCondition(Collections.singletonList(metricName), hostname,\n        applicationId, instanceId, startTime, endTime, precision, limit, true)\n    );\n\n    TimelineMetric metric = new TimelineMetric();\n    List<TimelineMetric> metricList = metrics.getMetrics();\n\n    if (metricList != null && !metricList.isEmpty()) {\n      metric.setMetricName(metricList.get(0).getMetricName());\n      metric.setAppId(metricList.get(0).getAppId());\n      metric.setInstanceId(metricList.get(0).getInstanceId());\n      metric.setHostName(metricList.get(0).getHostName());\n      // Assumption that metrics are ordered by start time\n      metric.setStartTime(metricList.get(0).getStartTime());\n      Map<Long, Double> metricRecords = new TreeMap<Long, Double>();\n      for (TimelineMetric timelineMetric : metricList) {\n        metricRecords.putAll(timelineMetric.getMetricValues());\n      }\n      metric.setMetricValues(metricRecords);\n    }\n\n    return metric;\n  }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public TimelineMetrics getTimelineMetrics(List<String> metricNames,\n      String hostname, String applicationId, String instanceId,\n      Long startTime, Long endTime, Precision precision, Integer limit,\n      boolean groupedByHosts) throws SQLException, IOException {\n\n    Condition condition = new LikeCondition(metricNames, hostname, applicationId,\n      instanceId, startTime, endTime, precision, limit, groupedByHosts);\n\n    if (hostname == null) {\n      return hBaseAccessor.getAggregateMetricRecords(condition);\n    }\n\n    return hBaseAccessor.getMetricRecords(condition);\n  }","id":47950,"modified_method":"@Override\n  public TimelineMetrics getTimelineMetrics(List<String> metricNames,\n      String hostname, String applicationId, String instanceId,\n      Long startTime, Long endTime, Precision precision, Integer limit,\n      boolean groupedByHosts) throws SQLException, IOException {\n\n    Condition condition = new DefaultCondition(metricNames, hostname, applicationId,\n      instanceId, startTime, endTime, precision, limit, groupedByHosts);\n\n    if (hostname == null) {\n      return hBaseAccessor.getAggregateMetricRecords(condition);\n    }\n\n    return hBaseAccessor.getMetricRecords(condition);\n  }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"String getConditionClause();","id":47951,"modified_method":"StringBuilder getConditionClause();","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"public String getConditionClause() {\n      StringBuilder sb = new StringBuilder();\n      boolean appendConjunction = false;\n\n      if (getMetricNames() != null) {\n        if (appendConjunction) {\n          sb.append(\" AND\");\n        }\n\n        sb.append(\"METRIC_NAME IN \");\n        sb.append(getMetricsClause());\n        appendConjunction = true;\n      }\n\n      appendConjunction = append(sb, appendConjunction, getHostname(), \" HOSTNAME = ?\");\n      appendConjunction = append(sb, appendConjunction, getAppId(), \" APP_ID = ?\");\n      appendConjunction = append(sb, appendConjunction, getInstanceId(), \" INSTANCE_ID = ?\");\n      appendConjunction = append(sb, appendConjunction, getStartTime(), \" SERVER_TIME >= ?\");\n      append(sb, appendConjunction, getEndTime(), \" SERVER_TIME < ?\");\n\n      return sb.toString();\n    }","id":47952,"modified_method":"public StringBuilder getConditionClause() {\n      StringBuilder sb = new StringBuilder();\n      boolean appendConjunction = false;\n      StringBuilder metricsLike = new StringBuilder();\n      StringBuilder metricsIn = new StringBuilder();\n\n      if (getMetricNames() != null) {\n        for (String name : getMetricNames()) {\n          if (name.contains(\"%\")) {\n            if (metricsLike.length() > 1) {\n              metricsLike.append(\" OR \");\n            }\n            metricsLike.append(\"METRIC_NAME LIKE ?\");\n          } else {\n            if (metricsIn.length() > 0) {\n              metricsIn.append(\", \");\n            }\n            metricsIn.append(\"?\");\n          }\n        }\n\n        if (metricsIn.length()>0) {\n          sb.append(\"(METRIC_NAME IN (\");\n          sb.append(metricsIn);\n          sb.append(\")\");\n          appendConjunction = true;\n        }\n\n        if (metricsLike.length() > 0) {\n          if (appendConjunction) {\n            sb.append(\" OR \");\n          } else {\n            sb.append(\"(\");\n          }\n          sb.append(metricsLike);\n          appendConjunction = true;\n        }\n\n        if (appendConjunction) {\n          sb.append(\")\");\n        }\n      }\n\n      appendConjunction = append(sb, appendConjunction, getHostname(), \" HOSTNAME = ?\");\n      appendConjunction = append(sb, appendConjunction, getAppId(), \" APP_ID = ?\");\n      appendConjunction = append(sb, appendConjunction, getInstanceId(), \" INSTANCE_ID = ?\");\n      appendConjunction = append(sb, appendConjunction, getStartTime(), \" SERVER_TIME >= ?\");\n      append(sb, appendConjunction, getEndTime(), \" SERVER_TIME < ?\");\n\n      return sb;\n    }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public String getConditionClause() {\n      StringBuilder sb = new StringBuilder();\n      boolean appendConjunction = false;\n\n      if (getMetricNames() != null) {\n        for (String name : getMetricNames()) {\n          if (sb.length() > 1) {\n            sb.append(\" OR \");\n          }\n          sb.append(\"METRIC_NAME = ?\");\n        }\n\n        appendConjunction = true;\n      }\n\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getHostname(), \" HOSTNAME = ?\");\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getAppId(), \" APP_ID = ?\");\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getInstanceId(), \" INSTANCE_ID = ?\");\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getStartTime(), \" SERVER_TIME >= ?\");\n      DefaultCondition.append(sb, appendConjunction, getEndTime(),\n        \" SERVER_TIME < ?\");\n\n      return sb.toString();\n    }","id":47953,"modified_method":"@Override\n    public StringBuilder getConditionClause() {\n      StringBuilder sb = new StringBuilder();\n      boolean appendConjunction = false;\n\n      if (getMetricNames() != null) {\n        for (String name : getMetricNames()) {\n          if (sb.length() > 1) {\n            sb.append(\" OR \");\n          }\n          sb.append(\"METRIC_NAME = ?\");\n        }\n\n        appendConjunction = true;\n      }\n\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getHostname(), \" HOSTNAME = ?\");\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getAppId(), \" APP_ID = ?\");\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getInstanceId(), \" INSTANCE_ID = ?\");\n      appendConjunction = DefaultCondition.append(sb, appendConjunction,\n        getStartTime(), \" SERVER_TIME >= ?\");\n      DefaultCondition.append(sb, appendConjunction, getEndTime(),\n        \" SERVER_TIME < ?\");\n\n      return sb;\n    }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testSplitByMetricNamesCondition() throws Exception {\n    Condition c = new DefaultCondition(\n      Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n      1407959718L, 1407959918L, null, null, false);\n\n    SplitByMetricNamesCondition condition = new SplitByMetricNamesCondition(c);\n    condition.setCurrentMetric(c.getMetricNames().get(0));\n\n    String preparedClause = condition.getConditionClause();\n    String expectedClause = \"METRIC_NAME = ? AND HOSTNAME = ? AND \" +\n      \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","id":47954,"modified_method":"@Test\n  public void testSplitByMetricNamesCondition() throws Exception {\n    Condition c = new DefaultCondition(\n      Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n      1407959718L, 1407959918L, null, null, false);\n\n    SplitByMetricNamesCondition condition = new SplitByMetricNamesCondition(c);\n    condition.setCurrentMetric(c.getMetricNames().get(0));\n\n    String preparedClause = condition.getConditionClause().toString();\n    String expectedClause = \"METRIC_NAME = ? AND HOSTNAME = ? AND \" +\n      \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testLikeConditionClause() throws Exception {\n    Condition condition = new LikeCondition(\n        Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    String preparedClause = condition.getConditionClause();\n    String expectedClause = \"(METRIC_NAME LIKE ? OR METRIC_NAME LIKE ?) AND HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new LikeCondition(\n        Collections.<String>emptyList(), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause();\n    expectedClause = \" HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new LikeCondition(\n        null, \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause();\n    expectedClause = \" HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new LikeCondition(\n        Arrays.asList(\"cpu_user\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause();\n    expectedClause = \"(METRIC_NAME LIKE ?) AND HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new LikeCondition(\n        Arrays.asList(\"cpu_user\", \"mem_free\", \"cpu_aidle\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause();\n    expectedClause = \"(METRIC_NAME LIKE ? OR METRIC_NAME LIKE ? OR METRIC_NAME LIKE ?) AND HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","id":47955,"modified_method":"@Test\n  public void testLikeConditionClause() throws Exception {\n    Condition condition = new DefaultCondition(\n        Arrays.asList(\"cpu_user\", \"some=%.metric\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    String preparedClause = condition.getConditionClause().toString();\n    String expectedClause = \"(METRIC_NAME IN (?) OR METRIC_NAME LIKE ?) AND HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new DefaultCondition(\n        Collections.<String>emptyList(), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause().toString();\n    expectedClause = \" HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new DefaultCondition(\n        null, \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause().toString();\n    expectedClause = \" HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new DefaultCondition(\n        Arrays.asList(\"some=%.metric\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause().toString();\n    expectedClause = \"(METRIC_NAME LIKE ?) AND HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n\n\n    condition = new DefaultCondition(\n        Arrays.asList(\"some=%.metric1\", \"some=%.metric2\", \"some=%.metric3\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    preparedClause = condition.getConditionClause().toString();\n    expectedClause = \"(METRIC_NAME LIKE ? OR METRIC_NAME LIKE ? OR METRIC_NAME LIKE ?) AND HOSTNAME = ? AND \" +\n        \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testConditionClause() throws Exception {\n    Condition condition = new DefaultCondition(\n      Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    String preparedClause = condition.getConditionClause();\n    String expectedClause = \"METRIC_NAME IN (?, ?) AND HOSTNAME = ? AND \" +\n      \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","id":47956,"modified_method":"@Test\n  public void testConditionClause() throws Exception {\n    Condition condition = new DefaultCondition(\n      Arrays.asList(\"cpu_user\", \"mem_free\"), \"h1\", \"a1\", \"i1\",\n        1407959718L, 1407959918L, null, null, false);\n\n    String preparedClause = condition.getConditionClause().toString();\n    String expectedClause = \"(METRIC_NAME IN (?, ?)) AND HOSTNAME = ? AND \" +\n      \"APP_ID = ? AND INSTANCE_ID = ? AND SERVER_TIME >= ? AND SERVER_TIME < ?\";\n\n    Assert.assertNotNull(preparedClause);\n    Assert.assertEquals(expectedClause, preparedClause);\n  }","commit_id":"9bb3bc007c927bca9d85af645eebd027f2c633c8","url":"https://github.com/apache/ambari"},{"original_method":"public void onMessage(final Message message) {\n        RuntimeCamelException rce = null;\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(endpoint + \" consumer receiving JMS message: \" + message);\n            }\n            Destination replyDestination = getReplyToDestination(message);\n            final JmsExchange exchange = createExchange(message, replyDestination);\n            if (eagerLoadingOfProperties) {\n                exchange.getIn().getHeaders();\n            }\n\n            // process the exchange\n            processor.process(exchange);\n\n            // get the correct jms message to send as reply\n            JmsMessage body = null;\n            if (exchange.isFailed()) {\n                if (exchange.getException() != null) {\n                    // an exception occurred while processing\n                    // TODO: Camel-585 somekind of flag to determine if we should send the exchange back to the client\n                    // or do as now where we wrap as runtime exception to be thrown back to spring so it can do rollback\n                    rce = wrapRuntimeCamelException(exchange.getException());\n                } else if (exchange.getFault().getBody() != null) {\n                    // a fault occurred while processing\n                    body = exchange.getFault();\n                }\n            } else {\n                // process OK so get the reply\n                body = exchange.getOut(false);\n            }\n            // send the reply\n            if (rce == null && body != null && !disableReplyTo) {\n                sendReply(replyDestination, message, exchange, body);\n            }\n        } catch (Exception e) {\n            rce = wrapRuntimeCamelException(e);\n        }\n        if (rce != null) {\n            LOG.warn(endpoint + \" consumer caught an exception while processing JMS message: \" + message, rce);\n            throw rce;\n        }\n    }","id":47957,"modified_method":"public void onMessage(final Message message) {\n        RuntimeCamelException rce = null;\n        try {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(endpoint + \" consumer receiving JMS message: \" + message);\n            }\n            Destination replyDestination = getReplyToDestination(message);\n            final JmsExchange exchange = createExchange(message, replyDestination);\n            if (eagerLoadingOfProperties) {\n                exchange.getIn().getHeaders();\n            }\n\n            // process the exchange\n            processor.process(exchange);\n\n            // get the correct jms message to send as reply\n            JmsMessage body = null;\n            if (exchange.isFailed()) {\n                if (exchange.getException() != null) {\n                    // an exception occurred while processing\n                    // TODO: Camel-585 somekind of flag to determine if we should send the exchange back to the client\n                    // or do as now where we wrap as runtime exception to be thrown back to spring so it can do rollback\n                    rce = wrapRuntimeCamelException(exchange.getException());\n                } else if (exchange.getFault().getBody() != null) {\n                    // a fault occurred while processing\n                    body = exchange.getFault();\n                }\n            } else {\n                // process OK so get the reply\n                body = exchange.getOut(false);\n            }\n\n            // send the reply if we got a response and the exchange is out capable\n            if (rce == null && body != null && !disableReplyTo && exchange.getPattern().isOutCapable()) {\n                sendReply(replyDestination, message, exchange, body);\n            }\n        } catch (Exception e) {\n            rce = wrapRuntimeCamelException(e);\n        }\n        if (rce != null) {\n            LOG.warn(endpoint + \" consumer caught an exception while processing JMS message: \" + message, rce);\n            throw rce;\n        }\n    }","commit_id":"e3cd1de6ce9d69785bd038870aff44e8a70c1aa9","url":"https://github.com/apache/camel"},{"original_method":"public JmsExchange createExchange(Message message, Destination replyDestination) {\n        JmsExchange exchange = new JmsExchange(endpoint, endpoint.getExchangePattern(), getBinding(), message);\n        // lets set to an InOut if we have some kind of reply-to destination\n        if (replyDestination != null && !disableReplyTo) {\n            exchange.setProperty(JmsConstants.JMS_REPLY_DESTINATION, replyDestination);\n            exchange.setPattern(ExchangePattern.InOut);\n        }\n        return exchange;\n    }","id":47958,"modified_method":"public JmsExchange createExchange(Message message, Destination replyDestination) {\n        JmsExchange exchange = new JmsExchange(endpoint, endpoint.getExchangePattern(), getBinding(), message);\n        // lets set to an InOut if we have some kind of reply-to destination\n        if (replyDestination != null && !disableReplyTo) {\n            exchange.setProperty(JmsConstants.JMS_REPLY_DESTINATION, replyDestination);\n            // only change pattern if not already out capable\n            if (!exchange.getPattern().isOutCapable()) {\n                exchange.setPattern(ExchangePattern.InOut);\n            }\n        }\n        return exchange;\n    }","commit_id":"e3cd1de6ce9d69785bd038870aff44e8a70c1aa9","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public List<Parameter> extractParameters(\n            final List<Annotation> annotations,\n            final Type type,\n            final Set<Type> typesToSkip,\n            final Iterator<SwaggerExtension> chain) {\n\n        if (shouldIgnoreType(type, typesToSkip)) {\n            return new ArrayList<>();\n        }\n\n        List<Parameter> parameters = new ArrayList<>();\n        for (Annotation annotation : annotations) {\n            if (annotation instanceof MatrixParam) {\n                MatrixParam param = (MatrixParam) annotation;\n                MatrixParameter mp = new MatrixParameter().name(param.value());\n\n                Property schema = createProperty(type);\n                if (schema != null) {\n                    mp.setProperty(schema);\n                }\n                parameters.add(mp);\n            } else if (annotation instanceof BeanParam) {\n                // Use Jackson's logic for processing Beans\n                final BeanDescription beanDesc = mapper.getSerializationConfig().introspect(constructType(type));\n                final List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n\n                for (final BeanPropertyDefinition propDef : properties) {\n                    final AnnotatedField field = propDef.getField();\n                    final AnnotatedMethod setter = propDef.getSetter();\n                    final List<Annotation> paramAnnotations = new ArrayList<>();\n                    final Iterator<SwaggerExtension> extensions = SwaggerExtensions.chain();\n                    Type paramType = null;\n\n                    // Gather the field's details\n                    if (field != null) {\n                        paramType = field.getGenericType();\n\n                        for (final Annotation fieldAnnotation : field.annotations()) {\n                            if (!paramAnnotations.contains(fieldAnnotation)) {\n                                paramAnnotations.add(fieldAnnotation);\n                            }\n                        }\n                    }\n\n                    // Gather the setter's details but only the ones we need\n                    if (setter != null) {\n                        // Do not set the param class/type from the setter if the values are already identified\n                        if (paramType == null && setter.getGenericParameterTypes() != null) {\n                            paramType = setter.getGenericParameterTypes()[0];\n                        }\n\n                        for (final Annotation fieldAnnotation : setter.annotations()) {\n                            if (!paramAnnotations.contains(fieldAnnotation)) {\n                                paramAnnotations.add(fieldAnnotation);\n                            }\n                        }\n                    }\n\n                    // Re-process all Bean fields and let the default swagger-jaxrs processor do its thing\n                    List<Parameter> extracted =\n                            extensions.next().extractParameters(paramAnnotations, paramType, typesToSkip, extensions);\n\n                    // since downstream processors won't know how to introspect @BeanParam, process here\n                    for (Parameter param : extracted) {\n                        if (ParameterProcessor.applyAnnotations(null, param, paramType, paramAnnotations) != null) {\n                            applyBeanValidatorAnnotations(param, paramAnnotations);\n                            parameters.add(param);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Only call down to the other items in the chain if no parameters were produced\n        if (parameters.isEmpty()) {\n            parameters = super.extractParameters(annotations, type, typesToSkip, chain);\n        }\n\n        return parameters;\n    }","id":47959,"modified_method":"@Override\n    public List<Parameter> extractParameters(\n            final List<Annotation> annotations,\n            final Type type,\n            final Set<Type> typesToSkip,\n            final Iterator<SwaggerExtension> chain) {\n\n        if (shouldIgnoreType(type, typesToSkip)) {\n            return new ArrayList<>();\n        }\n\n        List<Parameter> parameters = new ArrayList<>();\n        for (Annotation annotation : annotations) {\n            if (annotation instanceof MatrixParam) {\n                MatrixParam param = (MatrixParam) annotation;\n                MatrixParameter mp = new MatrixParameter().name(param.value());\n\n                Property schema = createProperty(type);\n                if (schema != null) {\n                    mp.setProperty(schema);\n                }\n                applyBeanValidatorAnnotations(mp, annotations);\n                parameters.add(mp);\n            } else if (annotation instanceof BeanParam) {\n                // Use Jackson's logic for processing Beans\n                final BeanDescription beanDesc = mapper.getSerializationConfig().introspect(constructType(type));\n                final List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n\n                for (final BeanPropertyDefinition propDef : properties) {\n                    final AnnotatedField field = propDef.getField();\n                    final AnnotatedMethod setter = propDef.getSetter();\n                    final List<Annotation> paramAnnotations = new ArrayList<>();\n                    final Iterator<SwaggerExtension> extensions = SwaggerExtensions.chain();\n                    Type paramType = null;\n\n                    // Gather the field's details\n                    if (field != null) {\n                        paramType = field.getGenericType();\n\n                        for (final Annotation fieldAnnotation : field.annotations()) {\n                            if (!paramAnnotations.contains(fieldAnnotation)) {\n                                paramAnnotations.add(fieldAnnotation);\n                            }\n                        }\n                    }\n\n                    // Gather the setter's details but only the ones we need\n                    if (setter != null) {\n                        // Do not set the param class/type from the setter if the values are already identified\n                        if (paramType == null && setter.getGenericParameterTypes() != null) {\n                            paramType = setter.getGenericParameterTypes()[0];\n                        }\n\n                        for (final Annotation fieldAnnotation : setter.annotations()) {\n                            if (!paramAnnotations.contains(fieldAnnotation)) {\n                                paramAnnotations.add(fieldAnnotation);\n                            }\n                        }\n                    }\n\n                    // Re-process all Bean fields and let the default swagger-jaxrs processor do its thing\n                    List<Parameter> extracted =\n                            extensions.next().extractParameters(paramAnnotations, paramType, typesToSkip, extensions);\n\n                    // since downstream processors won't know how to introspect @BeanParam, process here\n                    for (Parameter param : extracted) {\n                        if (ParameterProcessor.applyAnnotations(null, param, paramType, paramAnnotations) != null) {\n                            applyBeanValidatorAnnotations(param, paramAnnotations);\n                            parameters.add(param);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Only call down to the other items in the chain if no parameters were produced\n        if (parameters.isEmpty()) {\n            parameters = super.extractParameters(annotations, type, typesToSkip, chain);\n        }\n\n        return parameters;\n    }","commit_id":"8a765e0b49200ccc5bab5a5290e826b15528899f","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This is essentially a duplicate of {@link io.swagger.jackson.ModelResolver.applyBeanValidatorAnnotations}.\n     *\n     * @param property\n     * @param annotations\n     */\n    private void applyBeanValidatorAnnotations(final Parameter property, final List<Annotation> annotations) {\n        Map<String, Annotation> annos = new HashMap<>();\n        if (annotations != null) {\n            for (Annotation annotation : annotations) {\n                annos.put(annotation.annotationType().getName(), annotation);\n            }\n        }\n        if (annos.containsKey(NotNull.class.getName())) {\n            property.setRequired(true);\n        }\n        if (annos.containsKey(Min.class.getName()) && property instanceof AbstractNumericProperty) {\n            Min min = (Min) annos.get(Min.class.getName());\n            AbstractNumericProperty ap = (AbstractNumericProperty) property;\n            ap.setMinimum(new Double(min.value()));\n        }\n        if (annos.containsKey(Max.class.getName()) && property instanceof AbstractNumericProperty) {\n            Max max = (Max) annos.get(Max.class.getName());\n            AbstractNumericProperty ap = (AbstractNumericProperty) property;\n            ap.setMaximum(new Double(max.value()));\n        }\n        if (annos.containsKey(Size.class.getName())) {\n            Size size = (Size) annos.get(Size.class.getName());\n            if (property instanceof AbstractNumericProperty) {\n                AbstractNumericProperty ap = (AbstractNumericProperty) property;\n                ap.setMinimum(new Double(size.min()));\n                ap.setMaximum(new Double(size.max()));\n            } else if (property instanceof StringProperty) {\n                StringProperty sp = (StringProperty) property;\n                sp.minLength(size.min());\n                sp.maxLength(size.max());\n            } else if (property instanceof ArrayProperty) {\n                ArrayProperty sp = (ArrayProperty) property;\n                sp.setMinItems(size.min());\n                sp.setMaxItems(size.max());\n            }\n        }\n        if (annos.containsKey(DecimalMin.class.getName())) {\n            DecimalMin min = (DecimalMin) annos.get(DecimalMin.class.getName());\n            if (property instanceof AbstractNumericProperty) {\n                AbstractNumericProperty ap = (AbstractNumericProperty) property;\n                if (min.inclusive()) {\n                    ap.setMinimum(new Double(min.value()));\n                } else {\n                    ap.setExclusiveMinimum(!min.inclusive());\n                }\n            }\n        }\n        if (annos.containsKey(DecimalMax.class.getName())) {\n            DecimalMax max = (DecimalMax) annos.get(DecimalMax.class.getName());\n            if (property instanceof AbstractNumericProperty) {\n                AbstractNumericProperty ap = (AbstractNumericProperty) property;\n                if (max.inclusive()) {\n                    ap.setMaximum(new Double(max.value()));\n                } else {\n                    ap.setExclusiveMaximum(!max.inclusive());\n                }\n            }\n        }\n        if (annos.containsKey(Pattern.class.getName())) {\n            Pattern pattern = (Pattern) annos.get(Pattern.class.getName());\n            if (property instanceof StringProperty) {\n                StringProperty ap = (StringProperty) property;\n                ap.setPattern(pattern.regexp());\n            }\n        }\n    }","id":47960,"modified_method":"/**\n     * This is essentially a duplicate of {@link io.swagger.jackson.ModelResolver.applyBeanValidatorAnnotations}.\n     *\n     * @param parameter\n     * @param annotations\n     */\n    private void applyBeanValidatorAnnotations(final Parameter parameter, final List<Annotation> annotations) {\n        Map<String, Annotation> annos = new HashMap<>();\n        if (annotations != null) {\n            for (Annotation annotation : annotations) {\n                annos.put(annotation.annotationType().getName(), annotation);\n            }\n        }\n\n        if (annos.containsKey(NotNull.class.getName())) {\n            parameter.setRequired(true);\n        }\n\n        if (parameter instanceof AbstractSerializableParameter) {\n            AbstractSerializableParameter<?> serializable = (AbstractSerializableParameter<?>) parameter;\n\n            if (annos.containsKey(Min.class.getName())) {\n                Min min = (Min) annos.get(Min.class.getName());\n                serializable.setMinimum(new Double(min.value()));\n            }\n            if (annos.containsKey(Max.class.getName())) {\n                Max max = (Max) annos.get(Max.class.getName());\n                serializable.setMaximum(new Double(max.value()));\n            }\n            if (annos.containsKey(Size.class.getName())) {\n                Size size = (Size) annos.get(Size.class.getName());\n\n                serializable.setMinimum(new Double(size.min()));\n                serializable.setMaximum(new Double(size.max()));\n\n                serializable.setMinItems(size.min());\n                serializable.setMaxItems(size.max());\n            }\n            if (annos.containsKey(DecimalMin.class.getName())) {\n                DecimalMin min = (DecimalMin) annos.get(DecimalMin.class.getName());\n                if (min.inclusive()) {\n                    serializable.setMinimum(new Double(min.value()));\n                } else {\n                    serializable.setExclusiveMinimum(!min.inclusive());\n                }\n            }\n            if (annos.containsKey(DecimalMax.class.getName())) {\n                DecimalMax max = (DecimalMax) annos.get(DecimalMax.class.getName());\n                if (max.inclusive()) {\n                    serializable.setMaximum(new Double(max.value()));\n                } else {\n                    serializable.setExclusiveMaximum(!max.inclusive());\n                }\n            }\n            if (annos.containsKey(Pattern.class.getName())) {\n                Pattern pattern = (Pattern) annos.get(Pattern.class.getName());\n                serializable.setPattern(pattern.regexp());\n            }\n        }\n    }","commit_id":"8a765e0b49200ccc5bab5a5290e826b15528899f","url":"https://github.com/apache/cxf"},{"original_method":"public List getSelection() {\n    final TreeTableTree tree = getTree();\n    if (tree == null) return Collections.emptyList();\n    final int[] rows = getSelectedRows();\n    final ArrayList result = new ArrayList();\n    for (int row : rows) {\n      result.add(tree.getPathForRow(row).getLastPathComponent());\n    }\n    return result;\n  }","id":47961,"modified_method":"public List getSelection() {\n    final TreeTableTree tree = getTree();\n    if (tree == null) return Collections.emptyList();\n    final int[] rows = getSelectedRows();\n    final ArrayList result = new ArrayList();\n    for (int row : rows) {\n      final TreePath pathForRow = tree.getPathForRow(row);\n      if (pathForRow != null) result.add(pathForRow.getLastPathComponent());\n    }\n    return result;\n  }","commit_id":"cb390dae096beb6e8053bb9fb261fc7a3c140f04","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintNodeContent(Graphics g) {\n    if (!(getUI() instanceof BasicTreeUI)) return;\n\n    final AbstractTreeBuilder builder = AbstractTreeBuilder.getBuilderFor(this);\n    if (builder == null || builder.isDisposed()) return;\n\n    GraphicsConfig config = new GraphicsConfig(g);\n    config.setAntialiasing(true);\n\n    final AbstractTreeStructure structure = builder.getTreeStructure();\n\n    for (int eachRow = 0; eachRow < getRowCount(); eachRow++) {\n      final TreePath path = getPathForRow(eachRow);\n      PresentableNodeDescriptor node = toPresentableNode(path.getLastPathComponent());\n      if (node == null) continue;\n\n      if (!node.isContentHighlighted()) continue;\n\n      if (highlightSingleNode()) {\n        if (node.isContentHighlighted()) {\n          final TreePath nodePath = getPath(node);\n\n          Rectangle rect;\n\n          final Rectangle parentRect = getPathBounds(nodePath);\n          if (isExpanded(nodePath)) {\n            final int[] max = getMax(node, structure);\n            rect = new Rectangle(parentRect.x, parentRect.y, Math.max((int) parentRect.getMaxX(), max[1]) - parentRect.x - 1,\n                                 Math.max((int) parentRect.getMaxY(), max[0]) - parentRect.y - 1);\n          }\n          else {\n            rect = parentRect;\n          }\n\n          if (rect != null) {\n            final Color highlightColor = node.getHighlightColor();\n            g.setColor(highlightColor);\n            g.fillRoundRect(rect.x, rect.y, rect.width, rect.height, 4, 4);\n            g.setColor(highlightColor.darker());\n            g.drawRoundRect(rect.x, rect.y, rect.width, rect.height, 4, 4);\n          }\n        }\n      }\n      else {\n//todo: to investigate why it might happen under 1.6: http://www.productiveme.net:8080/browse/PM-217\n        if (node.getParentDescriptor() == null) continue;\n\n        final Object[] kids = structure.getChildElements(node);\n        if (kids.length == 0) continue;\n\n        PresentableNodeDescriptor first = null;\n        PresentableNodeDescriptor last = null;\n        int lastIndex = -1;\n        for (int i = 0; i < kids.length; i++) {\n          final Object kid = kids[i];\n          if (kid instanceof PresentableNodeDescriptor) {\n          PresentableNodeDescriptor eachKid = (PresentableNodeDescriptor) kid;\n          if (!node.isHighlightableContentNode(eachKid)) continue;\n          if (first == null) {\n            first = eachKid;\n          }\n          last = eachKid;\n          lastIndex = i;\n          }\n        }\n\n        if (first == null || last == null) continue;\n        Rectangle firstBounds = getPathBounds(getPath(first));\n\n        if (isExpanded(getPath(last))) {\n          if (lastIndex + 1 < kids.length) {\n            final Object child = kids[lastIndex + 1];\n            if (child instanceof PresentableNodeDescriptor) {\n              PresentableNodeDescriptor nextKid = (PresentableNodeDescriptor) child;\n              int nextRow = getRowForPath(getPath(nextKid));\n              last = toPresentableNode(getPathForRow(nextRow - 1).getLastPathComponent());\n            }\n          }\n          else {\n            NodeDescriptor parentNode = node.getParentDescriptor();\n            if (parentNode instanceof PresentableNodeDescriptor) {\n              final PresentableNodeDescriptor ppd = (PresentableNodeDescriptor)parentNode;\n              int nodeIndex = node.getIndex();\n              if (nodeIndex + 1 < structure.getChildElements(ppd).length) {\n                PresentableNodeDescriptor nextChild = ppd.getChildToHighlightAt(nodeIndex + 1);\n                int nextRow = getRowForPath(getPath(nextChild));\n                last = toPresentableNode(getPathForRow(nextRow - 1).getLastPathComponent());\n              }\n              else {\n                int lastRow = getRowForPath(getPath(last));\n                PresentableNodeDescriptor lastParent = last;\n                boolean lastWasFound = false;\n                for (int i = lastRow + 1; i < getRowCount(); i++) {\n                  PresentableNodeDescriptor eachNode = toPresentableNode(getPathForRow(i).getLastPathComponent());\n                  if (!node.isParentOf(eachNode)) {\n                    last = lastParent;\n                    lastWasFound = true;\n                    break;\n                  }\n                  lastParent = eachNode;\n                }\n                if (!lastWasFound) {\n                  last = toPresentableNode(getPathForRow(getRowCount() - 1).getLastPathComponent());\n                }\n              }\n            }\n          }\n        }\n\n        Rectangle lastBounds = getPathBounds(getPath(last));\n\n        if (firstBounds == null || lastBounds == null) continue;\n\n        Rectangle toPaint = new Rectangle(firstBounds.x, firstBounds.y, 0, (int)lastBounds.getMaxY() - firstBounds.y - 1);\n\n        toPaint.width = getWidth() - toPaint.x - 4;\n\n        final Color highlightColor = first.getHighlightColor();\n        g.setColor(highlightColor);\n        g.fillRoundRect(toPaint.x, toPaint.y, toPaint.width, toPaint.height, 4, 4);\n        g.setColor(highlightColor.darker());\n        g.drawRoundRect(toPaint.x, toPaint.y, toPaint.width, toPaint.height, 4, 4);\n      }\n    }\n\n    config.restore();\n  }","id":47962,"modified_method":"private void paintNodeContent(Graphics g) {\n    if (!(getUI() instanceof BasicTreeUI)) return;\n\n    final AbstractTreeBuilder builder = AbstractTreeBuilder.getBuilderFor(this);\n    if (builder == null || builder.isDisposed()) return;\n\n    GraphicsConfig config = new GraphicsConfig(g);\n    config.setAntialiasing(true);\n\n    final AbstractTreeStructure structure = builder.getTreeStructure();\n\n    for (int eachRow = 0; eachRow < getRowCount(); eachRow++) {\n      final TreePath path = getPathForRow(eachRow);\n      PresentableNodeDescriptor node = toPresentableNode(path.getLastPathComponent());\n      if (node == null) continue;\n\n      if (!node.isContentHighlighted()) continue;\n\n      if (highlightSingleNode()) {\n        if (node.isContentHighlighted()) {\n          final TreePath nodePath = getPath(node);\n\n          Rectangle rect;\n\n          final Rectangle parentRect = getPathBounds(nodePath);\n          if (isExpanded(nodePath)) {\n            final int[] max = getMax(node, structure);\n            rect = new Rectangle(parentRect.x, parentRect.y, Math.max((int) parentRect.getMaxX(), max[1]) - parentRect.x - 1,\n                                 Math.max((int) parentRect.getMaxY(), max[0]) - parentRect.y - 1);\n          }\n          else {\n            rect = parentRect;\n          }\n\n          if (rect != null) {\n            final Color highlightColor = node.getHighlightColor();\n            g.setColor(highlightColor);\n            g.fillRoundRect(rect.x, rect.y, rect.width, rect.height, 4, 4);\n            g.setColor(highlightColor.darker());\n            g.drawRoundRect(rect.x, rect.y, rect.width, rect.height, 4, 4);\n          }\n        }\n      }\n      else {\n//todo: to investigate why it might happen under 1.6: http://www.productiveme.net:8080/browse/PM-217\n        if (node.getParentDescriptor() == null) continue;\n\n        final Object[] kids = structure.getChildElements(node);\n        if (kids.length == 0) continue;\n\n        PresentableNodeDescriptor first = null;\n        PresentableNodeDescriptor last = null;\n        int lastIndex = -1;\n        for (int i = 0; i < kids.length; i++) {\n          final Object kid = kids[i];\n          if (kid instanceof PresentableNodeDescriptor) {\n          PresentableNodeDescriptor eachKid = (PresentableNodeDescriptor) kid;\n          if (!node.isHighlightableContentNode(eachKid)) continue;\n          if (first == null) {\n            first = eachKid;\n          }\n          last = eachKid;\n          lastIndex = i;\n          }\n        }\n\n        if (first == null || last == null) continue;\n        Rectangle firstBounds = getPathBounds(getPath(first));\n\n        if (isExpanded(getPath(last))) {\n          if (lastIndex + 1 < kids.length) {\n            final Object child = kids[lastIndex + 1];\n            if (child instanceof PresentableNodeDescriptor) {\n              PresentableNodeDescriptor nextKid = (PresentableNodeDescriptor) child;\n              int nextRow = getRowForPath(getPath(nextKid));\n              last = toPresentableNode(getPathForRow(nextRow - 1).getLastPathComponent());\n            }\n          }\n          else {\n            NodeDescriptor parentNode = node.getParentDescriptor();\n            if (parentNode instanceof PresentableNodeDescriptor) {\n              final PresentableNodeDescriptor ppd = (PresentableNodeDescriptor)parentNode;\n              int nodeIndex = node.getIndex();\n              if (nodeIndex + 1 < structure.getChildElements(ppd).length) {\n                PresentableNodeDescriptor nextChild = ppd.getChildToHighlightAt(nodeIndex + 1);\n                int nextRow = getRowForPath(getPath(nextChild));\n                TreePath prevPath = getPathForRow(nextRow - 1);\n                if (prevPath != null) {\n                  last = toPresentableNode(prevPath.getLastPathComponent());\n                }\n              }\n              else {\n                int lastRow = getRowForPath(getPath(last));\n                PresentableNodeDescriptor lastParent = last;\n                boolean lastWasFound = false;\n                for (int i = lastRow + 1; i < getRowCount(); i++) {\n                  PresentableNodeDescriptor eachNode = toPresentableNode(getPathForRow(i).getLastPathComponent());\n                  if (!node.isParentOf(eachNode)) {\n                    last = lastParent;\n                    lastWasFound = true;\n                    break;\n                  }\n                  lastParent = eachNode;\n                }\n                if (!lastWasFound) {\n                  last = toPresentableNode(getPathForRow(getRowCount() - 1).getLastPathComponent());\n                }\n              }\n            }\n          }\n        }\n\n        Rectangle lastBounds = getPathBounds(getPath(last));\n\n        if (firstBounds == null || lastBounds == null) continue;\n\n        Rectangle toPaint = new Rectangle(firstBounds.x, firstBounds.y, 0, (int)lastBounds.getMaxY() - firstBounds.y - 1);\n\n        toPaint.width = getWidth() - toPaint.x - 4;\n\n        final Color highlightColor = first.getHighlightColor();\n        g.setColor(highlightColor);\n        g.fillRoundRect(toPaint.x, toPaint.y, toPaint.width, toPaint.height, 4, 4);\n        g.setColor(highlightColor.darker());\n        g.drawRoundRect(toPaint.x, toPaint.y, toPaint.width, toPaint.height, 4, 4);\n      }\n    }\n\n    config.restore();\n  }","commit_id":"fa757619fe5b33c3429b35cd6010d8c4052479f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JPanel createTable() {\n    myTreeRoot = new CheckedTreeNode(null);\n\n    myTree = new CheckboxTree(new CheckboxTree.CheckboxTreeCellRenderer(){\n      public void customizeRenderer(final JTree tree,\n                                        Object value,\n                                        final boolean selected,\n                                        final boolean expanded,\n                                        final boolean leaf,\n                                        final int row,\n                                        final boolean hasFocus) {\n        if (!(value instanceof DefaultMutableTreeNode)) return;\n        value = ((DefaultMutableTreeNode)value).getUserObject();\n\n        if (value instanceof TemplateImpl) {\n          getTextRenderer().append (((TemplateImpl)value).getKey(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          String description = ((TemplateImpl)value).getDescription();\n          if (description != null && description.length() > 0) {\n            getTextRenderer().append (\" (\" + description + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n          }\n        }\n        else if (value instanceof TemplateGroup) {\n          getTextRenderer().append (((TemplateGroup)value).getName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n        }\n\n      }\n    }, myTreeRoot) {\n      @Override\n      protected void onNodeStateChanged(final CheckedTreeNode node) {\n        Object obj = node.getUserObject();\n        if (obj instanceof TemplateImpl) {\n          ((TemplateImpl)obj).setDeactivated(!node.isChecked());\n        }\n      }\n\n      @Override\n      protected void installSpeedSearch() {\n        new TreeSpeedSearch(this, new Convertor<TreePath, String>() {\n          @Override\n          public String convert(TreePath o) {\n            Object object = ((DefaultMutableTreeNode)o.getLastPathComponent()).getUserObject();\n            if (object instanceof TemplateGroup) {\n              return ((TemplateGroup)object).getName();\n            }\n            if (object instanceof TemplateImpl) {\n              return ((TemplateImpl)object).getKey();\n            }\n            return \"\";\n          }\n        }, true);\n\n      }\n    };\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n\n    DefaultTreeSelectionModel selModel = new DefaultTreeSelectionModel();\n    myTree.setSelectionModel(selModel);\n    selModel.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    myTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){\n      public void valueChanged(final TreeSelectionEvent e) {\n        TemplateSettings templateSettings = TemplateSettings.getInstance();\n        TemplateImpl template = getTemplate(getSelectedIndex());\n        if (template != null) {\n          templateSettings.setLastSelectedTemplate(template.getGroupName(), template.getKey());\n        } else {\n          templateSettings.setLastSelectedTemplate(null, null);\n          ((CardLayout) myDetailsPanel.getLayout()).show(myDetailsPanel, NO_SELECTION);\n        }\n        if (myUpdateNeeded) {\n          myAlarm.cancelAllRequests();\n          myAlarm.addRequest(new Runnable() {\n            public void run() {\n              updateTemplateDetails(false);\n            }\n          }, 100);\n        }\n      }\n    });\n\n\n    myTree.registerKeyboardAction(\n      new ActionListener() {\n        public void actionPerformed(ActionEvent event) {\n          addRow();\n        }\n      },\n      KeyStroke.getKeyStroke(KeyEvent.VK_INSERT, 0),\n      JComponent.WHEN_FOCUSED\n    );\n\n    myTree.registerKeyboardAction(\n      new ActionListener() {\n        public void actionPerformed(ActionEvent event) {\n          removeRow();\n        }\n      },\n      KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\n      JComponent.WHEN_FOCUSED\n    );\n    \n    myTree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          renameGroup();\n        }\n      }\n    });\n\n    installPopup();\n\n\n    DnDSupport.createBuilder(myTree)\n      .setBeanProvider(new NullableFunction<DnDActionInfo, DnDDragStartBean>() {\n        @Override\n        public DnDDragStartBean fun(DnDActionInfo dnDActionInfo) {\n          int selectedIndex = getSelectedIndex();\n          TemplateImpl template = getTemplate(selectedIndex);\n          return template != null ? new DnDDragStartBean(Pair.create(template, getNode(selectedIndex))) : null;\n        }\n      }).\n      setDisposableParent(this)\n      .setTargetChecker(new DnDTargetChecker() {\n        @Override\n        public boolean update(DnDEvent event) {\n          @SuppressWarnings(\"unchecked\") Pair<TemplateImpl, DefaultMutableTreeNode> pair = (Pair<TemplateImpl, DefaultMutableTreeNode>)event.getAttachedObject();\n          TemplateImpl template = pair.first;\n          String oldGroupName = template.getGroupName();\n          TemplateGroup group = getDropGroup(event);\n          boolean differentGroup = group != null && !oldGroupName.equals(group.getName());\n          boolean possible = differentGroup && !getSchemesManager().isShared(group);\n          event.setDropPossible(possible, differentGroup && !possible ? \"Cannot modify a shared group\" : \"\");\n          return true;\n        }\n      })\n      .setDropHandler(new DnDDropHandler() {\n        @Override\n        public void drop(DnDEvent event) {\n          @SuppressWarnings(\"unchecked\") Pair<TemplateImpl, DefaultMutableTreeNode> pair = (Pair<TemplateImpl, DefaultMutableTreeNode>)event.getAttachedObject();\n          moveTemplate(pair.first, ObjectUtils.assertNotNull(getDropGroup(event)).getName(), pair.second);\n        }\n      })\n      .setImageProvider(new Function<DnDActionInfo, DnDImage>() {\n        @Override\n        public DnDImage fun(DnDActionInfo dnDActionInfo) {\n          Point point = dnDActionInfo.getPoint();\n          return new DnDImage(DnDAwareTree.getDragImage(myTree, myTree.getPathForLocation(point.x, point.y), point).first);\n        }\n      })\n      .install();\n    \n    if (myTemplateGroups.size() > 0) {\n      myTree.setSelectionInterval(0, 0);\n    }\n\n    return initToolbar().createPanel();\n\n  }","id":47963,"modified_method":"private JPanel createTable() {\n    myTreeRoot = new CheckedTreeNode(null);\n\n    myTree = new CheckboxTree(new CheckboxTree.CheckboxTreeCellRenderer(){\n      public void customizeRenderer(final JTree tree,\n                                        Object value,\n                                        final boolean selected,\n                                        final boolean expanded,\n                                        final boolean leaf,\n                                        final int row,\n                                        final boolean hasFocus) {\n        if (!(value instanceof DefaultMutableTreeNode)) return;\n        value = ((DefaultMutableTreeNode)value).getUserObject();\n\n        if (value instanceof TemplateImpl) {\n          getTextRenderer().append (((TemplateImpl)value).getKey(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          String description = ((TemplateImpl)value).getDescription();\n          if (description != null && description.length() > 0) {\n            getTextRenderer().append (\" (\" + description + \")\", SimpleTextAttributes.GRAY_ATTRIBUTES);\n          }\n        }\n        else if (value instanceof TemplateGroup) {\n          getTextRenderer().append (((TemplateGroup)value).getName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n        }\n\n      }\n    }, myTreeRoot) {\n      @Override\n      protected void onNodeStateChanged(final CheckedTreeNode node) {\n        Object obj = node.getUserObject();\n        if (obj instanceof TemplateImpl) {\n          ((TemplateImpl)obj).setDeactivated(!node.isChecked());\n        }\n      }\n\n      @Override\n      protected void installSpeedSearch() {\n        new TreeSpeedSearch(this, new Convertor<TreePath, String>() {\n          @Override\n          public String convert(TreePath o) {\n            Object object = ((DefaultMutableTreeNode)o.getLastPathComponent()).getUserObject();\n            if (object instanceof TemplateGroup) {\n              return ((TemplateGroup)object).getName();\n            }\n            if (object instanceof TemplateImpl) {\n              return ((TemplateImpl)object).getKey();\n            }\n            return \"\";\n          }\n        }, true);\n\n      }\n    };\n    myTree.setRootVisible(false);\n    myTree.setShowsRootHandles(true);\n\n    DefaultTreeSelectionModel selModel = new DefaultTreeSelectionModel();\n    myTree.setSelectionModel(selModel);\n    selModel.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n\n    myTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){\n      public void valueChanged(final TreeSelectionEvent e) {\n        TemplateSettings templateSettings = TemplateSettings.getInstance();\n        TemplateImpl template = getTemplate(getSelectedIndex());\n        if (template != null) {\n          templateSettings.setLastSelectedTemplate(template.getGroupName(), template.getKey());\n        } else {\n          templateSettings.setLastSelectedTemplate(null, null);\n          ((CardLayout) myDetailsPanel.getLayout()).show(myDetailsPanel, NO_SELECTION);\n        }\n        if (myUpdateNeeded) {\n          myAlarm.cancelAllRequests();\n          myAlarm.addRequest(new Runnable() {\n            public void run() {\n              updateTemplateDetails(false);\n            }\n          }, 100);\n        }\n      }\n    });\n\n    myTree.registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent event) {\n        myCurrentTemplateEditor.focusKey();\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_FOCUSED);\n\n    myTree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          renameGroup();\n        }\n      }\n    });\n\n    installPopup();\n\n\n    DnDSupport.createBuilder(myTree)\n      .setBeanProvider(new NullableFunction<DnDActionInfo, DnDDragStartBean>() {\n        @Override\n        public DnDDragStartBean fun(DnDActionInfo dnDActionInfo) {\n          int selectedIndex = getSelectedIndex();\n          TemplateImpl template = getTemplate(selectedIndex);\n          return template != null ? new DnDDragStartBean(Pair.create(template, getNode(selectedIndex))) : null;\n        }\n      }).\n      setDisposableParent(this)\n      .setTargetChecker(new DnDTargetChecker() {\n        @Override\n        public boolean update(DnDEvent event) {\n          @SuppressWarnings(\"unchecked\") Pair<TemplateImpl, DefaultMutableTreeNode> pair = (Pair<TemplateImpl, DefaultMutableTreeNode>)event.getAttachedObject();\n          TemplateImpl template = pair.first;\n          String oldGroupName = template.getGroupName();\n          TemplateGroup group = getDropGroup(event);\n          boolean differentGroup = group != null && !oldGroupName.equals(group.getName());\n          boolean possible = differentGroup && !getSchemesManager().isShared(group);\n          event.setDropPossible(possible, differentGroup && !possible ? \"Cannot modify a shared group\" : \"\");\n          return true;\n        }\n      })\n      .setDropHandler(new DnDDropHandler() {\n        @Override\n        public void drop(DnDEvent event) {\n          @SuppressWarnings(\"unchecked\") Pair<TemplateImpl, DefaultMutableTreeNode> pair = (Pair<TemplateImpl, DefaultMutableTreeNode>)event.getAttachedObject();\n          moveTemplate(pair.first, ObjectUtils.assertNotNull(getDropGroup(event)).getName(), pair.second);\n        }\n      })\n      .setImageProvider(new Function<DnDActionInfo, DnDImage>() {\n        @Override\n        public DnDImage fun(DnDActionInfo dnDActionInfo) {\n          Point point = dnDActionInfo.getPoint();\n          return new DnDImage(DnDAwareTree.getDragImage(myTree, myTree.getPathForLocation(point.x, point.y), point).first);\n        }\n      })\n      .install();\n    \n    if (myTemplateGroups.size() > 0) {\n      myTree.setSelectionInterval(0, 0);\n    }\n\n    return initToolbar().createPanel();\n\n  }","commit_id":"db093af1179b27c3c168c00415782a1716bf43dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeRow() {\n    int selected = getSelectedIndex(); // TODO\n    if (selected < 0) return;\n    TemplateKey templateKey = getTemplateKey(selected);\n    if (templateKey != null) {\n      int result = Messages.showOkCancelDialog(this, CodeInsightBundle.message(\"template.delete.confirmation.text\"),\n                                               CodeInsightBundle.message(\"template.delete.confirmation.title\"),\n                                               Messages.getQuestionIcon());\n      if (result != DialogWrapper.OK_EXIT_CODE) return;\n\n      removeTemplateAt(selected);\n    }\n    else {\n      TemplateGroup group = getGroup(selected);\n      if (group != null) {\n        int result = Messages.showOkCancelDialog(this, CodeInsightBundle.message(\"template.delete.group.confirmation.text\"),\n                                                 CodeInsightBundle.message(\"template.delete.confirmation.title\"),\n                                                 Messages.getQuestionIcon());\n        if (result != DialogWrapper.OK_EXIT_CODE) return;\n\n        JTree tree = myTree;\n        TreePath path = tree.getPathForRow(selected);\n\n        myTemplateGroups.remove(group);\n\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();\n        removeNodeFromParent(node);\n      }\n\n    }\n\n  }","id":47964,"modified_method":"private void removeRow() {\n    int selected = getSelectedIndex();\n    TemplateKey templateKey = getTemplateKey(selected);\n    if (templateKey != null) {\n      removeTemplateAt(selected);\n    }\n    else {\n      TemplateGroup group = getGroup(selected);\n      if (group != null) {\n        int result = Messages.showOkCancelDialog(this, CodeInsightBundle.message(\"template.delete.group.confirmation.text\"),\n                                                 CodeInsightBundle.message(\"template.delete.confirmation.title\"),\n                                                 Messages.getQuestionIcon());\n        if (result != DialogWrapper.OK_EXIT_CODE) return;\n\n        myTemplateGroups.remove(group);\n\n        removeNodeFromParent((DefaultMutableTreeNode)myTree.getPathForRow(selected).getLastPathComponent());\n      }\n\n    }\n\n  }","commit_id":"db093af1179b27c3c168c00415782a1716bf43dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void genConstructor(\n            @NotNull ScriptDescriptor scriptDescriptor,\n            @NotNull ClassBuilder classBuilder,\n            @NotNull MethodContext methodContext\n    ) {\n        JvmMethodSignature jvmSignature = typeMapper.mapScriptSignature(scriptDescriptor, context.getEarlierScripts());\n\n        if (state.getReplSpecific().getShouldGenerateScriptResultValue()) {\n            FieldInfo resultFieldInfo = context.getResultFieldInfo();\n            classBuilder.newField(\n                    JvmDeclarationOrigin.NO_ORIGIN,\n                    ACC_PUBLIC | ACC_FINAL,\n                    resultFieldInfo.getFieldName(),\n                    resultFieldInfo.getFieldType().getDescriptor(),\n                    null,\n                    null\n            );\n        }\n\n        MethodVisitor mv = classBuilder.newMethod(\n                JvmDeclarationOriginKt.OtherOrigin(scriptDeclaration, scriptDescriptor.getUnsubstitutedPrimaryConstructor()),\n                ACC_PUBLIC, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(),\n                null, null);\n\n        if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n            mv.visitCode();\n\n            InstructionAdapter iv = new InstructionAdapter(mv);\n\n            Type classType = typeMapper.mapType(scriptDescriptor);\n\n            iv.load(0, classType);\n            ClassDescriptor superclass = DescriptorUtilsKt.getSuperClassOrAny(scriptDescriptor);\n            assert hasDefaultConstructor(superclass);\n            iv.invokespecial(\n                    typeMapper.mapSupertype(superclass.getDefaultType(), null).getInternalName(),\n                    \"<init>\", \"()V\", false);\n\n            iv.load(0, classType);\n\n            FrameMap frameMap = new FrameMap();\n            frameMap.enterTemp(OBJECT_TYPE);\n\n            for (ScriptDescriptor importedScript : context.getEarlierScripts()) {\n                frameMap.enter(importedScript, OBJECT_TYPE);\n            }\n\n            Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n            int add = 0;\n\n            List<ValueParameterDescriptor> valueParameters = scriptDescriptor.getUnsubstitutedPrimaryConstructor().getValueParameters();\n            for (int i = 0; i < valueParameters.size(); i++) {\n                ValueParameterDescriptor parameter = valueParameters.get(i);\n                frameMap.enter(parameter, argTypes[i + add]);\n            }\n\n            int offset = 1;\n\n            for (ScriptDescriptor earlierScript : context.getEarlierScripts()) {\n                Type earlierClassType = typeMapper.mapClass(earlierScript);\n                iv.load(0, classType);\n                iv.load(offset, earlierClassType);\n                offset += earlierClassType.getSize();\n                iv.putfield(classType.getInternalName(), context.getScriptFieldName(earlierScript), earlierClassType.getDescriptor());\n            }\n\n            for (ValueParameterDescriptor parameter : valueParameters) {\n                Type parameterType = typeMapper.mapType(parameter.getType());\n                iv.load(0, classType);\n                iv.load(offset, parameterType);\n                offset += parameterType.getSize();\n                iv.putfield(classType.getInternalName(), parameter.getName().getIdentifier(), parameterType.getDescriptor());\n            }\n\n            final ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, methodContext, state, this);\n\n            generateInitializers(new Function0<ExpressionCodegen>() {\n                @Override\n                public ExpressionCodegen invoke() {\n                    return codegen;\n                }\n            });\n\n            iv.areturn(Type.VOID_TYPE);\n        }\n\n        mv.visitMaxs(-1, -1);\n        mv.visitEnd();\n    }","id":47965,"modified_method":"private void genConstructor(\n            @NotNull ScriptDescriptor scriptDescriptor,\n            @NotNull ClassBuilder classBuilder,\n            @NotNull MethodContext methodContext\n    ) {\n        JvmMethodSignature jvmSignature = typeMapper.mapScriptSignature(scriptDescriptor, context.getEarlierScripts());\n\n        if (state.getReplSpecific().getShouldGenerateScriptResultValue()) {\n            FieldInfo resultFieldInfo = context.getResultFieldInfo();\n            classBuilder.newField(\n                    JvmDeclarationOrigin.NO_ORIGIN,\n                    ACC_PUBLIC | ACC_FINAL,\n                    resultFieldInfo.getFieldName(),\n                    resultFieldInfo.getFieldType().getDescriptor(),\n                    null,\n                    null\n            );\n        }\n\n        MethodVisitor mv = classBuilder.newMethod(\n                JvmDeclarationOriginKt.OtherOrigin(scriptDeclaration, scriptDescriptor.getUnsubstitutedPrimaryConstructor()),\n                ACC_PUBLIC, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(),\n                null, null);\n\n        if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n            mv.visitCode();\n\n            InstructionAdapter iv = new InstructionAdapter(mv);\n\n            Type classType = typeMapper.mapType(scriptDescriptor);\n\n            ClassDescriptor superclass = DescriptorUtilsKt.getSuperClassNotAny(scriptDescriptor);\n\n            List<ValueParameterDescriptor> valueParameters = scriptDescriptor.getUnsubstitutedPrimaryConstructor().getValueParameters();\n\n            if (superclass == null) {\n                iv.load(0, classType);\n                iv.invokespecial(\"java/lang/Object\", \"<init>\", \"()V\", false);\n            }\n            else {\n                List<Pair<Name, KotlinType>> superclassParamsMap = scriptDescriptor.getScriptParametersToPassToSuperclass();\n                ConstructorDescriptor ctorDesc = DescriptorUtilsKt.getConstructorByParamsMap(superclass, superclassParamsMap);\n                assert ctorDesc != null;\n\n                iv.load(0, classType);\n\n                for (Pair<Name, KotlinType> superclassParam: superclassParamsMap) {\n                    ValueParameterDescriptor valueParam = null;\n                    for (ValueParameterDescriptor vpd: valueParameters) {\n                        if (vpd.getName().equals(superclassParam.getFirst())) {\n                            valueParam = vpd;\n                            break;\n                        }\n                    }\n                    assert valueParam != null;\n                    iv.load(valueParam.getIndex() + 1, typeMapper.mapType(valueParam.getType()));\n                }\n\n                CallableMethod ctorMethod = typeMapper.mapToCallableMethod(ctorDesc, false);\n                String sig = ctorMethod.getAsmMethod().getDescriptor();\n\n                iv.invokespecial(\n                        typeMapper.mapSupertype(superclass.getDefaultType(), null).getInternalName(),\n                        \"<init>\", sig, false);\n            }\n            iv.load(0, classType);\n\n            FrameMap frameMap = new FrameMap();\n            frameMap.enterTemp(OBJECT_TYPE);\n\n            for (ScriptDescriptor importedScript : context.getEarlierScripts()) {\n                frameMap.enter(importedScript, OBJECT_TYPE);\n            }\n\n            Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n            int add = 0;\n\n            for (int i = 0; i < valueParameters.size(); i++) {\n                ValueParameterDescriptor parameter = valueParameters.get(i);\n                frameMap.enter(parameter, argTypes[i + add]);\n            }\n\n            int offset = 1;\n\n            for (ScriptDescriptor earlierScript : context.getEarlierScripts()) {\n                Type earlierClassType = typeMapper.mapClass(earlierScript);\n                iv.load(0, classType);\n                iv.load(offset, earlierClassType);\n                offset += earlierClassType.getSize();\n                iv.putfield(classType.getInternalName(), context.getScriptFieldName(earlierScript), earlierClassType.getDescriptor());\n            }\n\n            for (ValueParameterDescriptor parameter : valueParameters) {\n                Type parameterType = typeMapper.mapType(parameter.getType());\n                iv.load(0, classType);\n                iv.load(offset, parameterType);\n                offset += parameterType.getSize();\n                iv.putfield(classType.getInternalName(), parameter.getName().getIdentifier(), parameterType.getDescriptor());\n            }\n\n            final ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, methodContext, state, this);\n\n            generateInitializers(new Function0<ExpressionCodegen>() {\n                @Override\n                public ExpressionCodegen invoke() {\n                    return codegen;\n                }\n            });\n\n            iv.areturn(Type.VOID_TYPE);\n        }\n\n        mv.visitMaxs(-1, -1);\n        mv.visitEnd();\n    }","commit_id":"e1ca45f3606be3dec678be0df79b29c69c9f36a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private Method generateConstructor(@NotNull Type superClassAsmType) {\n        List<FieldInfo> args = calculateConstructorParameters(typeMapper, closure, asmType);\n\n        Type[] argTypes = fieldListToTypeArray(args);\n\n        Method constructor = new Method(\"<init>\", Type.VOID_TYPE, argTypes);\n        MethodVisitor mv = v.newMethod(OtherOrigin(element, funDescriptor), visibilityFlag, \"<init>\", constructor.getDescriptor(), null,\n                                        ArrayUtil.EMPTY_STRING_ARRAY);\n        if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n            mv.visitCode();\n            InstructionAdapter iv = new InstructionAdapter(mv);\n\n            int k = 1;\n            for (FieldInfo fieldInfo : args) {\n                k = genAssignInstanceFieldFromParam(fieldInfo, k, iv);\n            }\n\n            iv.load(0, superClassAsmType);\n            iv.invokespecial(superClassAsmType.getInternalName(), \"<init>\", \"()V\", false);\n\n            iv.visitInsn(RETURN);\n\n            FunctionCodegen.endVisit(iv, \"constructor\", element);\n        }\n        return constructor;\n    }","id":47966,"modified_method":"@NotNull\n    private Method generateConstructor(@NotNull Type superClassAsmType) {\n        List<FieldInfo> args = calculateConstructorParameters(typeMapper, closure, asmType);\n\n        Type[] argTypes = fieldListToTypeArray(args);\n\n        Method constructor = new Method(\"<init>\", Type.VOID_TYPE, argTypes);\n        MethodVisitor mv = v.newMethod(OtherOrigin(element, funDescriptor), visibilityFlag, \"<init>\", constructor.getDescriptor(), null,\n                                        ArrayUtil.EMPTY_STRING_ARRAY);\n        if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n            mv.visitCode();\n            InstructionAdapter iv = new InstructionAdapter(mv);\n\n            int k = 1;\n            for (FieldInfo fieldInfo : args) {\n                k = genAssignInstanceFieldFromParam(fieldInfo, k, iv);\n            }\n\n            iv.load(0, superClassAsmType);\n\n            if (superClassAsmType.equals(AsmTypes.LAMBDA)) {\n                iv.iconst(funDescriptor.getValueParameters().size());\n                iv.invokespecial(superClassAsmType.getInternalName(), \"<init>\", \"(I)V\", false);\n            }\n            else {\n                iv.invokespecial(superClassAsmType.getInternalName(), \"<init>\", \"()V\", false);\n            }\n\n            iv.visitInsn(RETURN);\n\n            FunctionCodegen.endVisit(iv, \"constructor\", element);\n        }\n        return constructor;\n    }","commit_id":"27ed0984673e5341c0fdc91fbac6ef705dac9cdb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public Collection<JetType> getSupertypesForClosure(@NotNull FunctionDescriptor descriptor) {\n        ReceiverParameterDescriptor receiverParameter = descriptor.getExtensionReceiverParameter();\n\n        ClassDescriptor functionImplClass = receiverParameter != null ? extensionFunctionImpl : functionImpl;\n\n        //noinspection ConstantConditions\n        JetType functionType = getBuiltIns(descriptor).getFunctionType(\n                Annotations.EMPTY,\n                receiverParameter == null ? null : receiverParameter.getType(),\n                ExpressionTypingUtils.getValueParametersTypes(descriptor.getValueParameters()),\n                descriptor.getReturnType()\n        );\n\n        return Arrays.asList(functionImplClass.getDefaultType(), functionType);\n    }","id":47967,"modified_method":"@NotNull\n    public Collection<JetType> getSupertypesForClosure(@NotNull FunctionDescriptor descriptor) {\n        ReceiverParameterDescriptor receiverParameter = descriptor.getExtensionReceiverParameter();\n\n        //noinspection ConstantConditions\n        JetType functionType = getBuiltIns(descriptor).getFunctionType(\n                Annotations.EMPTY,\n                receiverParameter == null ? null : receiverParameter.getType(),\n                ExpressionTypingUtils.getValueParametersTypes(descriptor.getValueParameters()),\n                descriptor.getReturnType()\n        );\n\n        return Arrays.asList(lambda.getDefaultType(), functionType);\n    }","commit_id":"27ed0984673e5341c0fdc91fbac6ef705dac9cdb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JvmRuntimeTypes(@NotNull ReflectionTypes reflectionTypes) {\n        this.reflectionTypes = reflectionTypes;\n\n        ModuleDescriptorImpl module = new ModuleDescriptorImpl(\n                Name.special(\"<jvm functions impl>\"),\n                LockBasedStorageManager.NO_LOCKS,\n                TopDownAnalyzerFacadeForJVM.JVM_MODULE_PARAMETERS\n        );\n        PackageFragmentDescriptor kotlinJvmInternal = new MutablePackageFragmentDescriptor(module, new FqName(\"kotlin.jvm.internal\"));\n\n        this.functionImpl = createClass(kotlinJvmInternal, \"FunctionImpl\");\n        this.memberFunctionImpl = createClass(kotlinJvmInternal, \"MemberFunctionImpl\");\n        this.extensionFunctionImpl = createClass(kotlinJvmInternal, \"ExtensionFunctionImpl\");\n    }","id":47968,"modified_method":"public JvmRuntimeTypes(@NotNull ReflectionTypes reflectionTypes) {\n        this.reflectionTypes = reflectionTypes;\n\n        ModuleDescriptorImpl module = new ModuleDescriptorImpl(\n                Name.special(\"<jvm functions impl>\"),\n                LockBasedStorageManager.NO_LOCKS,\n                TopDownAnalyzerFacadeForJVM.JVM_MODULE_PARAMETERS\n        );\n        PackageFragmentDescriptor kotlinJvmInternal = new MutablePackageFragmentDescriptor(module, new FqName(\"kotlin.jvm.internal\"));\n\n        this.lambda = createClass(kotlinJvmInternal, \"Lambda\");\n        this.functionImpl = createClass(kotlinJvmInternal, \"FunctionImpl\");\n        this.memberFunctionImpl = createClass(kotlinJvmInternal, \"MemberFunctionImpl\");\n        this.extensionFunctionImpl = createClass(kotlinJvmInternal, \"ExtensionFunctionImpl\");\n    }","commit_id":"27ed0984673e5341c0fdc91fbac6ef705dac9cdb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testEnumClass() throws Exception {\n        loadText(\"enum class Direction { NORTH; SOUTH; EAST; WEST }\");\n        System.out.println(generateToText());\n        final Class direction = loadAllClasses(generateClassesInFile()).get(\"Direction\");\n        final Field north = direction.getField(\"NORTH\");\n        assertEquals(direction, north.getType());\n        assertInstanceOf(north.get(null), direction);\n    }","id":47969,"modified_method":"public void testEnumClass() throws Exception {\n        loadText(\"enum class Direction { NORTH; SOUTH; EAST; WEST }\");\n        final Class direction = loadAllClasses(generateClassesInFile()).get(\"Direction\");\n        final Field north = direction.getField(\"NORTH\");\n        assertEquals(direction, north.getType());\n        assertInstanceOf(north.get(null), direction);\n    }","commit_id":"ad2b15a5bc6d48653421cbde472060e677f62f24","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void generatePrimaryConstructor() {\n        ConstructorDescriptor constructorDescriptor = state.getBindingContext().getConstructorDescriptor((JetElement) myClass);\n        if (constructorDescriptor == null && !(myClass instanceof JetObjectDeclaration) && !isEnum(myClass)) return;\n\n        Method method;\n        CallableMethod callableMethod;\n        if (myClass instanceof JetObjectDeclaration || isEnum(myClass)) {\n            method = new Method(\"<init>\", Type.VOID_TYPE, new Type[0]);\n            callableMethod = new CallableMethod(\"\", method, Opcodes.INVOKESPECIAL, Collections.<Type>emptyList());\n        }\n        else {\n            callableMethod = state.getTypeMapper().mapToCallableMethod(constructorDescriptor, kind);\n            method = callableMethod.getSignature();\n        }\n        int flags = Opcodes.ACC_PUBLIC; // TODO\n        final MethodVisitor mv = v.visitMethod(flags, \"<init>\", method.getDescriptor(), null, null);\n        mv.visitCode();\n\n        Type[] argTypes = method.getArgumentTypes();\n        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null\n                ? constructorDescriptor.getValueParameters()\n                : Collections.<ValueParameterDescriptor>emptyList();\n\n        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, kind);\n\n        final InstructionAdapter iv = new InstructionAdapter(mv);\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, context, state);\n\n        String classname = state.getTypeMapper().jvmName(descriptor, kind);\n        final Type classType = Type.getType(\"L\" + classname + \";\");\n\n        List<JetDelegationSpecifier> specifiers = myClass.getDelegationSpecifiers();\n\n        if (specifiers.isEmpty() || !(specifiers.get(0) instanceof JetDelegatorToSuperCall)) {\n            // TODO correct calculation of super class\n            String superClass = \"java/lang/Object\";\n            if (!specifiers.isEmpty()) {\n                final JetType superType = state.getBindingContext().resolveTypeReference(specifiers.get(0).getTypeReference());\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                if (superClassDescriptor.hasConstructors()) {\n                    superClass = getSuperClass();\n                }\n            }\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            iv.invokespecial(superClass, \"<init>\", /* TODO super constructor descriptor */\"()V\");\n        }\n\n        final DeclarationDescriptor outerDescriptor = getOuterClassDescriptor();\n        if (outerDescriptor instanceof ClassDescriptor) {\n            final ClassDescriptor outerClassDescriptor = (ClassDescriptor) outerDescriptor;\n            final Type type = JetTypeMapper.jetImplementationType(outerClassDescriptor);\n            String interfaceDesc = type.getDescriptor();\n            final String fieldName = \"this$0\";\n            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, fieldName, interfaceDesc, null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getOuterThisIndex(), type);\n            iv.putfield(classname, fieldName, interfaceDesc);\n        }\n\n        if (kind == OwnerKind.DELEGATING_IMPLEMENTATION) {\n            String interfaceDesc = JetTypeMapper.jetInterfaceType(descriptor).getDescriptor();\n            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, \"$this\", interfaceDesc, /*TODO*/null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getDelegateThisIndex(), argTypes[0]);\n            iv.putfield(classname, \"$this\", interfaceDesc);\n        }\n\n        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();\n        for (JetDeclaration declaration : myClass.getDeclarations()) {\n            if (declaration instanceof JetFunction) {\n                overridden.addAll(state.getBindingContext().getFunctionDescriptor((JetNamedFunction) declaration).getOverriddenFunctions());\n            }\n        }\n\n        int n = 0;\n        for (JetDelegationSpecifier specifier : specifiers) {\n            boolean delegateOnStack = specifier instanceof JetDelegatorToSuperCall && n > 0 ||\n                                      specifier instanceof JetDelegatorByExpressionSpecifier;\n\n            if (delegateOnStack) {\n                iv.load(0, classType);\n            }\n\n            if (specifier instanceof JetDelegatorToSuperCall) {\n                ConstructorDescriptor constructorDescriptor1 = state.getBindingContext().resolveSuperConstructor((JetDelegatorToSuperCall) specifier);\n                generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) specifier, constructorDescriptor1, n == 0, frameMap);\n            }\n            else if (specifier instanceof JetDelegatorByExpressionSpecifier) {\n                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());\n            }\n\n            if (delegateOnStack) {\n                JetType superType = state.getBindingContext().resolveTypeReference(specifier.getTypeReference());\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                String delegateField = \"$delegate_\" + n;\n                Type fieldType = JetTypeMapper.jetInterfaceType(superClassDescriptor);\n                String fieldDesc = fieldType.getDescriptor();\n                v.visitField(Opcodes.ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);\n                iv.putfield(classname, delegateField, fieldDesc);\n\n                JetClass superClass = (JetClass) state.getBindingContext().getDeclarationPsiElement(superClassDescriptor);\n                final ClassContext delegateContext = context.intoClass(superClassDescriptor,\n                        new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),\n                        JetTypeMapper.jvmNameForInterface(superClassDescriptor)));\n                generateDelegates(superClass, delegateContext, overridden);\n            }\n\n            n++;\n        }\n\n        if (frameMap.getFirstTypeParameter() > 0 && kind == OwnerKind.IMPLEMENTATION) {\n            generateTypeInfoInitializer(frameMap.getFirstTypeParameter(), frameMap.getTypeParameterCount(), iv);\n        }\n\n        generateInitializers(codegen, iv);\n\n        int curParam = 0;\n        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();\n        for (JetParameter parameter : constructorParameters) {\n            if (parameter.getValOrVarNode() != null) {\n                VariableDescriptor descriptor = paramDescrs.get(curParam);\n                Type type = state.getTypeMapper().mapType(descriptor.getOutType());\n                iv.load(0, classType);\n                iv.load(frameMap.getIndex(descriptor), type);\n                iv.putfield(classname, descriptor.getName(), type.getDescriptor());\n            }\n            curParam++;\n        }\n\n        mv.visitInsn(Opcodes.RETURN);\n        mv.visitMaxs(0, 0);\n        mv.visitEnd();\n    }","id":47970,"modified_method":"protected void generatePrimaryConstructor() {\n        ConstructorDescriptor constructorDescriptor = state.getBindingContext().getConstructorDescriptor((JetElement) myClass);\n        if (constructorDescriptor == null && !(myClass instanceof JetObjectDeclaration) && !isEnum(myClass)) return;\n\n        Method method;\n        CallableMethod callableMethod;\n        if (constructorDescriptor == null) {\n            method = new Method(\"<init>\", Type.VOID_TYPE, new Type[0]);\n            callableMethod = new CallableMethod(\"\", method, Opcodes.INVOKESPECIAL, Collections.<Type>emptyList());\n        }\n        else {\n            callableMethod = state.getTypeMapper().mapToCallableMethod(constructorDescriptor, kind);\n            method = callableMethod.getSignature();\n        }\n        int flags = Opcodes.ACC_PUBLIC; // TODO\n        final MethodVisitor mv = v.visitMethod(flags, \"<init>\", method.getDescriptor(), null, null);\n        mv.visitCode();\n\n        Type[] argTypes = method.getArgumentTypes();\n        List<ValueParameterDescriptor> paramDescrs = constructorDescriptor != null\n                ? constructorDescriptor.getValueParameters()\n                : Collections.<ValueParameterDescriptor>emptyList();\n\n        ConstructorFrameMap frameMap = new ConstructorFrameMap(callableMethod, constructorDescriptor, kind);\n\n        final InstructionAdapter iv = new InstructionAdapter(mv);\n        ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, Type.VOID_TYPE, context, state);\n\n        String classname = state.getTypeMapper().jvmName(descriptor, kind);\n        final Type classType = Type.getType(\"L\" + classname + \";\");\n\n        List<JetDelegationSpecifier> specifiers = myClass.getDelegationSpecifiers();\n\n        if (specifiers.isEmpty() || !(specifiers.get(0) instanceof JetDelegatorToSuperCall)) {\n            // TODO correct calculation of super class\n            String superClass = \"java/lang/Object\";\n            if (!specifiers.isEmpty()) {\n                final JetType superType = state.getBindingContext().resolveTypeReference(specifiers.get(0).getTypeReference());\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                if (superClassDescriptor.hasConstructors()) {\n                    superClass = getSuperClass();\n                }\n            }\n            iv.load(0, Type.getType(\"L\" + superClass + \";\"));\n            iv.invokespecial(superClass, \"<init>\", /* TODO super constructor descriptor */\"()V\");\n        }\n\n        final DeclarationDescriptor outerDescriptor = getOuterClassDescriptor();\n        if (outerDescriptor instanceof ClassDescriptor) {\n            final ClassDescriptor outerClassDescriptor = (ClassDescriptor) outerDescriptor;\n            final Type type = JetTypeMapper.jetImplementationType(outerClassDescriptor);\n            String interfaceDesc = type.getDescriptor();\n            final String fieldName = \"this$0\";\n            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, fieldName, interfaceDesc, null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getOuterThisIndex(), type);\n            iv.putfield(classname, fieldName, interfaceDesc);\n        }\n\n        if (kind == OwnerKind.DELEGATING_IMPLEMENTATION) {\n            String interfaceDesc = JetTypeMapper.jetInterfaceType(descriptor).getDescriptor();\n            v.visitField(Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL, \"$this\", interfaceDesc, /*TODO*/null, null);\n            iv.load(0, classType);\n            iv.load(frameMap.getDelegateThisIndex(), argTypes[0]);\n            iv.putfield(classname, \"$this\", interfaceDesc);\n        }\n\n        HashSet<FunctionDescriptor> overridden = new HashSet<FunctionDescriptor>();\n        for (JetDeclaration declaration : myClass.getDeclarations()) {\n            if (declaration instanceof JetFunction) {\n                overridden.addAll(state.getBindingContext().getFunctionDescriptor((JetNamedFunction) declaration).getOverriddenFunctions());\n            }\n        }\n\n        int n = 0;\n        for (JetDelegationSpecifier specifier : specifiers) {\n            boolean delegateOnStack = specifier instanceof JetDelegatorToSuperCall && n > 0 ||\n                                      specifier instanceof JetDelegatorByExpressionSpecifier;\n\n            if (delegateOnStack) {\n                iv.load(0, classType);\n            }\n\n            if (specifier instanceof JetDelegatorToSuperCall) {\n                ConstructorDescriptor constructorDescriptor1 = state.getBindingContext().resolveSuperConstructor((JetDelegatorToSuperCall) specifier);\n                generateDelegatorToConstructorCall(iv, codegen, (JetDelegatorToSuperCall) specifier, constructorDescriptor1, n == 0, frameMap);\n            }\n            else if (specifier instanceof JetDelegatorByExpressionSpecifier) {\n                codegen.genToJVMStack(((JetDelegatorByExpressionSpecifier) specifier).getDelegateExpression());\n            }\n\n            if (delegateOnStack) {\n                JetType superType = state.getBindingContext().resolveTypeReference(specifier.getTypeReference());\n                ClassDescriptor superClassDescriptor = (ClassDescriptor) superType.getConstructor().getDeclarationDescriptor();\n                String delegateField = \"$delegate_\" + n;\n                Type fieldType = JetTypeMapper.jetInterfaceType(superClassDescriptor);\n                String fieldDesc = fieldType.getDescriptor();\n                v.visitField(Opcodes.ACC_PRIVATE, delegateField, fieldDesc, /*TODO*/null, null);\n                iv.putfield(classname, delegateField, fieldDesc);\n\n                JetClass superClass = (JetClass) state.getBindingContext().getDeclarationPsiElement(superClassDescriptor);\n                final ClassContext delegateContext = context.intoClass(superClassDescriptor,\n                        new OwnerKind.DelegateKind(StackValue.field(fieldType, classname, delegateField, false),\n                        JetTypeMapper.jvmNameForInterface(superClassDescriptor)));\n                generateDelegates(superClass, delegateContext, overridden);\n            }\n\n            n++;\n        }\n\n        if (frameMap.getFirstTypeParameter() > 0 && kind == OwnerKind.IMPLEMENTATION) {\n            generateTypeInfoInitializer(frameMap.getFirstTypeParameter(), frameMap.getTypeParameterCount(), iv);\n        }\n\n        generateInitializers(codegen, iv);\n\n        int curParam = 0;\n        List<JetParameter> constructorParameters = getPrimaryConstructorParameters();\n        for (JetParameter parameter : constructorParameters) {\n            if (parameter.getValOrVarNode() != null) {\n                VariableDescriptor descriptor = paramDescrs.get(curParam);\n                Type type = state.getTypeMapper().mapType(descriptor.getOutType());\n                iv.load(0, classType);\n                iv.load(frameMap.getIndex(descriptor), type);\n                iv.putfield(classname, descriptor.getName(), type.getDescriptor());\n            }\n            curParam++;\n        }\n\n        mv.visitInsn(Opcodes.RETURN);\n        mv.visitMaxs(0, 0);\n        mv.visitEnd();\n    }","commit_id":"ad2b15a5bc6d48653421cbde472060e677f62f24","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void initializeEnumConstants(InstructionAdapter v) {\n        for (JetEnumEntry enumConstant : myEnumConstants) {\n            // TODO type and constructor parameters\n            String intfClass = state.getTypeMapper().jvmName(descriptor, OwnerKind.INTERFACE);\n            String implClass = state.getTypeMapper().jvmName(descriptor, OwnerKind.IMPLEMENTATION);\n            v.anew(Type.getObjectType(implClass));\n            v.dup();\n            v.invokespecial(implClass, \"<init>\", \"()V\");\n            v.putstatic(intfClass, enumConstant.getName(), \"L\" + intfClass + \";\");\n        }\n    }","id":47971,"modified_method":"private void initializeEnumConstants(InstructionAdapter v) {\n        ExpressionCodegen codegen = new ExpressionCodegen(v, new FrameMap(), Type.VOID_TYPE, context, state);\n        for (JetEnumEntry enumConstant : myEnumConstants) {\n            // TODO type and constructor parameters\n            String intfClass = state.getTypeMapper().jvmName(descriptor, OwnerKind.INTERFACE);\n            String implClass = state.getTypeMapper().jvmName(descriptor, OwnerKind.IMPLEMENTATION);\n\n            final List<JetDelegationSpecifier> delegationSpecifiers = enumConstant.getDelegationSpecifiers();\n            if (delegationSpecifiers.size() > 1) {\n                throw new UnsupportedOperationException(\"multiple delegation specifiers for enum constant not supported\");\n            }\n\n            v.anew(Type.getObjectType(implClass));\n            v.dup();\n\n            if (delegationSpecifiers.size() == 1) {\n                final JetDelegationSpecifier specifier = delegationSpecifiers.get(0);\n                if (specifier instanceof JetDelegatorToSuperCall) {\n                    final JetDelegatorToSuperCall superCall = (JetDelegatorToSuperCall) specifier;\n                    ConstructorDescriptor constructorDescriptor = state.getBindingContext().resolveSuperConstructor(superCall);\n                    CallableMethod method = state.getTypeMapper().mapToCallableMethod(constructorDescriptor, OwnerKind.IMPLEMENTATION);\n                    codegen.invokeMethodWithArguments(method, superCall);\n                }\n                else {\n                    throw new UnsupportedOperationException(\"unsupported type of enum constant initializer: \" + specifier);\n                }\n            }\n            else {\n                v.invokespecial(implClass, \"<init>\", \"()V\");\n            }\n            v.putstatic(intfClass, enumConstant.getName(), \"L\" + intfClass + \";\");\n        }\n    }","commit_id":"ad2b15a5bc6d48653421cbde472060e677f62f24","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tpublic List<SyncDLObject> getAllFolderSyncDLObjects(\n\t\t\tlong companyId, long repositoryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_R_T(\n\t\t\t\t\tcompanyId, repositoryId, SyncConstants.TYPE_FOLDER);\n\n\t\t\treturn checkSyncDLObjects(syncDLObjects);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":47972,"modified_method":"@Override\n\tpublic List<SyncDLObject> getAllFolderSyncDLObjects(\n\t\t\tlong companyId, long repositoryId)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_R_T(\n\t\t\t\t\tcompanyId, repositoryId, SyncConstants.TYPE_FOLDER);\n\n\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = checkSyncDLObjects(\n\t\t\t\tsyncDLObjects);\n\n\t\t\treturn syncDLObjectUpdate.getSyncDLObjects();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"430983cae8660d3db978aa24ff4e53f75ba5ea39","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected List<SyncDLObject> checkSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects)\n\t\tthrows PortalException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tList<SyncDLObject> checkedSyncDLObjects = new ArrayList<>();\n\n\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\tString event = syncDLObject.getEvent();\n\n\t\t\tif (event.equals(SyncConstants.EVENT_DELETE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString type = syncDLObject.getType();\n\n\t\t\tif (type.equals(SyncConstants.TYPE_FILE)) {\n\t\t\t\tif (!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tif (!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFolderConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type.equals(SyncConstants.TYPE_PRIVATE_WORKING_COPY)) {\n\t\t\t\tif ((syncDLObject.getLockUserId() !=\n\t\t\t\t\t\tpermissionChecker.getUserId()) ||\n\t\t\t\t\t!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckedSyncDLObjects.add(syncDLObject);\n\t\t}\n\n\t\treturn checkedSyncDLObjects;\n\t}","id":47973,"modified_method":"protected SyncDLObjectUpdate checkSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects)\n\t\tthrows PortalException {\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tList<SyncDLObject> checkedSyncDLObjects = new ArrayList<>();\n\n\t\tlong lastAccessTime = 0;\n\n\t\tfor (SyncDLObject syncDLObject : syncDLObjects) {\n\t\t\tif (syncDLObject.getModifiedTime() > lastAccessTime) {\n\t\t\t\tlastAccessTime = syncDLObject.getModifiedTime();\n\t\t\t}\n\n\t\t\tString event = syncDLObject.getEvent();\n\n\t\t\tif (event.equals(SyncConstants.EVENT_DELETE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString type = syncDLObject.getType();\n\n\t\t\tif (type.equals(SyncConstants.TYPE_FILE)) {\n\t\t\t\tif (!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tif (!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFolderConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type.equals(SyncConstants.TYPE_PRIVATE_WORKING_COPY)) {\n\t\t\t\tif ((syncDLObject.getLockUserId() !=\n\t\t\t\t\t\tpermissionChecker.getUserId()) ||\n\t\t\t\t\t!permissionChecker.hasPermission(\n\t\t\t\t\t\tsyncDLObject.getRepositoryId(),\n\t\t\t\t\t\tDLFileEntryConstants.getClassName(),\n\t\t\t\t\t\tsyncDLObject.getTypePK(), ActionKeys.VIEW)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckedSyncDLObjects.add(syncDLObject);\n\t\t}\n\n\t\treturn new SyncDLObjectUpdate(checkedSyncDLObjects, lastAccessTime);\n\t}","commit_id":"430983cae8660d3db978aa24ff4e53f75ba5ea39","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected List<SyncDLObject> getSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects, long companyId, long repositoryId,\n\t\t\tlong parentFolderId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\tList<SyncDLObject> curSyncDLObjects =\n\t\t\tsyncDLObjectPersistence.findByC_M_R_P(\n\t\t\t\tcompanyId, lastAccessTime, repositoryId, parentFolderId);\n\n\t\tcurSyncDLObjects = checkSyncDLObjects(curSyncDLObjects);\n\n\t\tsyncDLObjects.addAll(curSyncDLObjects);\n\n\t\tfor (SyncDLObject curSyncDLObject : curSyncDLObjects) {\n\t\t\tString type = curSyncDLObject.getType();\n\n\t\t\tif (!type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgetSyncDLObjects(\n\t\t\t\tsyncDLObjects, companyId, repositoryId,\n\t\t\t\tcurSyncDLObject.getTypePK(), lastAccessTime);\n\t\t}\n\n\t\treturn syncDLObjects;\n\t}","id":47974,"modified_method":"protected List<SyncDLObject> getSyncDLObjects(\n\t\t\tList<SyncDLObject> syncDLObjects, long companyId, long repositoryId,\n\t\t\tlong parentFolderId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\tList<SyncDLObject> curSyncDLObjects =\n\t\t\tsyncDLObjectPersistence.findByC_M_R_P(\n\t\t\t\tcompanyId, lastAccessTime, repositoryId, parentFolderId);\n\n\t\tSyncDLObjectUpdate syncDLObjectUpdate = checkSyncDLObjects(\n\t\t\tcurSyncDLObjects);\n\n\t\tcurSyncDLObjects = syncDLObjectUpdate.getSyncDLObjects();\n\n\t\tsyncDLObjects.addAll(curSyncDLObjects);\n\n\t\tfor (SyncDLObject curSyncDLObject : curSyncDLObjects) {\n\t\t\tString type = curSyncDLObject.getType();\n\n\t\t\tif (!type.equals(SyncConstants.TYPE_FOLDER)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgetSyncDLObjects(\n\t\t\t\tsyncDLObjects, companyId, repositoryId,\n\t\t\t\tcurSyncDLObject.getTypePK(), lastAccessTime);\n\t\t}\n\n\t\treturn syncDLObjects;\n\t}","commit_id":"430983cae8660d3db978aa24ff4e53f75ba5ea39","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tString[] events = null;\n\n\t\t\tif (lastAccessTime == -1) {\n\t\t\t\tevents = new String[] {\n\t\t\t\t\tSyncConstants.EVENT_DELETE, SyncConstants.EVENT_TRASH\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents = new String[0];\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_M_R_NotE(\n\t\t\t\t\tcompanyId, lastAccessTime, repositoryId, events, 0,\n\t\t\t\t\tPortletPropsValues.SYNC_PAGINATION_DELTA,\n\t\t\t\t\tnew SyncDLObjectTypeComparator());\n\n\t\t\tif (syncDLObjects.isEmpty()) {\n\t\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t\t}\n\n\t\t\tSyncDLObject syncDLObject = syncDLObjects.get(\n\t\t\t\tsyncDLObjects.size() - 1);\n\n\t\t\tsyncDLObjects = checkSyncDLObjects(syncDLObjects);\n\n\t\t\treturn new SyncDLObjectUpdate(\n\t\t\t\tsyncDLObjects, syncDLObject.getModifiedTime());\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":47975,"modified_method":"@Override\n\tpublic SyncDLObjectUpdate getSyncDLObjectUpdate(\n\t\t\tlong companyId, long repositoryId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tString[] events = null;\n\n\t\t\tif (lastAccessTime == -1) {\n\t\t\t\tevents = new String[] {\n\t\t\t\t\tSyncConstants.EVENT_DELETE, SyncConstants.EVENT_TRASH\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents = new String[0];\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectPersistence.findByC_M_R_NotE(\n\t\t\t\t\tcompanyId, lastAccessTime, repositoryId, events, 0,\n\t\t\t\t\tPortletPropsValues.SYNC_PAGINATION_DELTA,\n\t\t\t\t\tnew SyncDLObjectTypeComparator());\n\n\t\t\tif (syncDLObjects.isEmpty()) {\n\t\t\t\treturn new SyncDLObjectUpdate(syncDLObjects, lastAccessTime);\n\t\t\t}\n\n\t\t\treturn checkSyncDLObjects(syncDLObjects);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"430983cae8660d3db978aa24ff4e53f75ba5ea39","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void doUpdatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tPortletPreferences portletPreferences = PrefsPropsUtil.getPreferences(\n\t\t\tCompanyThreadLocal.getCompanyId());\n\n\t\tboolean allowUserPersonalSites = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowUserPersonalSites\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_ALLOW_USER_PERSONAL_SITES,\n\t\t\tString.valueOf(allowUserPersonalSites));\n\n\t\tboolean enabled = ParamUtil.getBoolean(actionRequest, \"enabled\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_SERVICES_ENABLED,\n\t\t\tString.valueOf(enabled));\n\n\t\tint maxConnections = ParamUtil.getInteger(\n\t\t\tactionRequest, \"maxConnections\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_MAX_CONNECTIONS,\n\t\t\tString.valueOf(maxConnections));\n\n\t\tint maxDownloadRate = ParamUtil.getInteger(\n\t\t\tactionRequest, \"maxDownloadRate\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_MAX_DOWNLOAD_RATE,\n\t\t\tString.valueOf(maxDownloadRate));\n\n\t\tint maxUploadRate = ParamUtil.getInteger(\n\t\t\tactionRequest, \"maxUploadRate\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_MAX_UPLOAD_RATE,\n\t\t\tString.valueOf(maxUploadRate));\n\n\t\tboolean oAuthEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"oAuthEnabled\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncConstants.SYNC_OAUTH_ENABLED, String.valueOf(oAuthEnabled));\n\n\t\tint pollInterval = ParamUtil.getInteger(actionRequest, \"pollInterval\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_POLL_INTERVAL,\n\t\t\tString.valueOf(pollInterval));\n\n\t\tportletPreferences.store();\n\n\t\tif (oAuthEnabled) {\n\t\t\tif (!_syncOAuthHelperUtil.isDeployed()) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\tactionRequest, OAuthPortletUndeployedException.class);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tactionRequest);\n\n\t\t\t_syncOAuthHelperUtil.enableOAuth(\n\t\t\t\tCompanyThreadLocal.getCompanyId(), serviceContext);\n\t\t}\n\t}","id":47976,"modified_method":"protected void doUpdatePreferences(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tPortletPreferences portletPreferences = PrefsPropsUtil.getPreferences(\n\t\t\tCompanyThreadLocal.getCompanyId());\n\n\t\tboolean allowUserPersonalSites = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowUserPersonalSites\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_ALLOW_USER_PERSONAL_SITES,\n\t\t\tString.valueOf(allowUserPersonalSites));\n\n\t\tboolean enabled = ParamUtil.getBoolean(actionRequest, \"enabled\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_SERVICES_ENABLED,\n\t\t\tString.valueOf(enabled));\n\n\t\tint maxConnections = ParamUtil.getInteger(\n\t\t\tactionRequest, \"maxConnections\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_MAX_CONNECTIONS,\n\t\t\tString.valueOf(maxConnections));\n\n\t\tint maxDownloadRate = ParamUtil.getInteger(\n\t\t\tactionRequest, \"maxDownloadRate\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_MAX_DOWNLOAD_RATE,\n\t\t\tString.valueOf(maxDownloadRate));\n\n\t\tint maxUploadRate = ParamUtil.getInteger(\n\t\t\tactionRequest, \"maxUploadRate\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_MAX_UPLOAD_RATE,\n\t\t\tString.valueOf(maxUploadRate));\n\n\t\tboolean oAuthEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"oAuthEnabled\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncConstants.SYNC_OAUTH_ENABLED, String.valueOf(oAuthEnabled));\n\n\t\tint pollInterval = ParamUtil.getInteger(actionRequest, \"pollInterval\");\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncServiceConfigurationKeys.SYNC_CLIENT_POLL_INTERVAL,\n\t\t\tString.valueOf(pollInterval));\n\n\t\tportletPreferences.setValue(\n\t\t\tSyncConstants.SYNC_CONTEXT_MODIFIED_TIME,\n\t\t\tString.valueOf(System.currentTimeMillis()));\n\n\t\tportletPreferences.store();\n\n\t\tif (oAuthEnabled) {\n\t\t\tif (!_syncOAuthHelperUtil.isDeployed()) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\tactionRequest, OAuthPortletUndeployedException.class);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\t\tactionRequest);\n\n\t\t\t_syncOAuthHelperUtil.enableOAuth(\n\t\t\t\tCompanyThreadLocal.getCompanyId(), serviceContext);\n\t\t}\n\t}","commit_id":"d6a6eb01f0c0d101b7f9d141e69c1ddced0edff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getSyncDLObjectUpdate(\n\t\t\tlong repositoryId, long parentFolderId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectFinder.findByModifiedTime(\n\t\t\t\t\tlastAccessTime, repositoryId, parentFolderId, null,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tSyncDLObject syncDLObject = syncDLObjects.get(\n\t\t\t\tsyncDLObjects.size() - 1);\n\n\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = new SyncDLObjectUpdate(\n\t\t\t\tcheckSyncDLObjects(syncDLObjects, repositoryId, lastAccessTime),\n\t\t\t\tsyncDLObjects.size(), syncDLObject.getModifiedTime());\n\n\t\t\treturn syncDLObjectUpdate.toString();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":47977,"modified_method":"@Override\n\tpublic String getSyncDLObjectUpdate(\n\t\t\tlong repositoryId, long parentFolderId, long lastAccessTime)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tList<SyncDLObject> syncDLObjects =\n\t\t\t\tsyncDLObjectFinder.findByModifiedTime(\n\t\t\t\t\tlastAccessTime, repositoryId, parentFolderId, null,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\t\tSyncDLObject syncDLObject = syncDLObjects.get(\n\t\t\t\tsyncDLObjects.size() - 1);\n\n\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = getSyncDLObjectUpdate(\n\t\t\t\tcheckSyncDLObjects(syncDLObjects, repositoryId, lastAccessTime),\n\t\t\t\tsyncDLObjects.size(), syncDLObject.getModifiedTime(),\n\t\t\t\tlastAccessTime);\n\n\t\t\treturn syncDLObjectUpdate.toString();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"d6a6eb01f0c0d101b7f9d141e69c1ddced0edff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getSyncDLObjectUpdate(\n\t\t\tlong repositoryId, long lastAccessTime, int max,\n\t\t\tboolean retrieveFromCache)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tString[] events = null;\n\n\t\t\tif (retrieveFromCache) {\n\t\t\t\tevents = new String[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents = new String[] {\n\t\t\t\t\tSyncDLObjectConstants.EVENT_DELETE,\n\t\t\t\t\tSyncDLObjectConstants.EVENT_TRASH\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tint count = syncDLObjectPersistence.countByM_R_NotE(\n\t\t\t\tlastAccessTime, repositoryId, events);\n\n\t\t\tif (count == 0) {\n\t\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = new SyncDLObjectUpdate(\n\t\t\t\t\tCollections.<SyncDLObject>emptyList(), 0, lastAccessTime);\n\n\t\t\t\treturn syncDLObjectUpdate.toString();\n\t\t\t}\n\n\t\t\tint start = 0;\n\t\t\tint end = 0;\n\n\t\t\tif (max == QueryUtil.ALL_POS) {\n\t\t\t\tstart = QueryUtil.ALL_POS;\n\t\t\t\tend = QueryUtil.ALL_POS;\n\t\t\t}\n\t\t\telse if (max == 0) {\n\t\t\t\tend = SyncServiceConfigurationValues.SYNC_PAGINATION_DELTA;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = max;\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects = null;\n\n\t\t\tif (retrieveFromCache) {\n\t\t\t\tsyncDLObjects = syncDLObjectPersistence.findByM_R_NotE(\n\t\t\t\t\tlastAccessTime, repositoryId, events, start, end,\n\t\t\t\t\tnew SyncDLObjectModifiedTimeComparator());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncDLObjects = syncDLObjectFinder.findByModifiedTime(\n\t\t\t\t\tlastAccessTime, repositoryId, 0, null, start, end);\n\t\t\t}\n\n\t\t\tSyncDLObject syncDLObject = syncDLObjects.get(\n\t\t\t\tsyncDLObjects.size() - 1);\n\n\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = new SyncDLObjectUpdate(\n\t\t\t\tcheckSyncDLObjects(syncDLObjects, repositoryId, lastAccessTime),\n\t\t\t\tcount, syncDLObject.getModifiedTime());\n\n\t\t\treturn syncDLObjectUpdate.toString();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","id":47978,"modified_method":"@Override\n\tpublic String getSyncDLObjectUpdate(\n\t\t\tlong repositoryId, long lastAccessTime, int max,\n\t\t\tboolean retrieveFromCache)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tSyncUtil.checkSyncEnabled(repositoryId);\n\n\t\t\trepositoryService.checkRepository(repositoryId);\n\n\t\t\tString[] events = null;\n\n\t\t\tif (retrieveFromCache) {\n\t\t\t\tevents = new String[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents = new String[] {\n\t\t\t\t\tSyncDLObjectConstants.EVENT_DELETE,\n\t\t\t\t\tSyncDLObjectConstants.EVENT_TRASH\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tint count = syncDLObjectPersistence.countByM_R_NotE(\n\t\t\t\tlastAccessTime, repositoryId, events);\n\n\t\t\tif (count == 0) {\n\t\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = getSyncDLObjectUpdate(\n\t\t\t\t\tCollections.<SyncDLObject>emptyList(), 0, lastAccessTime,\n\t\t\t\t\tlastAccessTime);\n\n\t\t\t\treturn syncDLObjectUpdate.toString();\n\t\t\t}\n\n\t\t\tint start = 0;\n\t\t\tint end = 0;\n\n\t\t\tif (max == QueryUtil.ALL_POS) {\n\t\t\t\tstart = QueryUtil.ALL_POS;\n\t\t\t\tend = QueryUtil.ALL_POS;\n\t\t\t}\n\t\t\telse if (max == 0) {\n\t\t\t\tend = SyncServiceConfigurationValues.SYNC_PAGINATION_DELTA;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tend = max;\n\t\t\t}\n\n\t\t\tList<SyncDLObject> syncDLObjects = null;\n\n\t\t\tif (retrieveFromCache) {\n\t\t\t\tsyncDLObjects = syncDLObjectPersistence.findByM_R_NotE(\n\t\t\t\t\tlastAccessTime, repositoryId, events, start, end,\n\t\t\t\t\tnew SyncDLObjectModifiedTimeComparator());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsyncDLObjects = syncDLObjectFinder.findByModifiedTime(\n\t\t\t\t\tlastAccessTime, repositoryId, 0, null, start, end);\n\t\t\t}\n\n\t\t\tSyncDLObject syncDLObject = syncDLObjects.get(\n\t\t\t\tsyncDLObjects.size() - 1);\n\n\t\t\tSyncDLObjectUpdate syncDLObjectUpdate = getSyncDLObjectUpdate(\n\t\t\t\tcheckSyncDLObjects(syncDLObjects, repositoryId, lastAccessTime),\n\t\t\t\tcount, syncDLObject.getModifiedTime(), lastAccessTime);\n\n\t\t\treturn syncDLObjectUpdate.toString();\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow new PortalException(SyncUtil.buildExceptionMessage(pe), pe);\n\t\t}\n\t}","commit_id":"d6a6eb01f0c0d101b7f9d141e69c1ddced0edff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SyncDLObjectUpdate(\n\t\tList<SyncDLObject> syncDLObjects, int resultsTotal,\n\t\tlong lastAccessTime) {\n\n\t\t_syncDLObjects = syncDLObjects;\n\t\t_resultsTotal = resultsTotal;\n\t\t_lastAccessTime = lastAccessTime;\n\t}","id":47979,"modified_method":"public SyncDLObjectUpdate(\n\t\tList<SyncDLObject> syncDLObjects, int resultsTotal,\n\t\tlong lastAccessTime) {\n\n\t\t_syncDLObjects = syncDLObjects;\n\t\t_resultsTotal = resultsTotal;\n\t\t_lastAccessTime = lastAccessTime;\n\t\t_settingsModifiedTimes = Collections.emptyMap();\n\t}","commit_id":"d6a6eb01f0c0d101b7f9d141e69c1ddced0edff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler((_syncDLObjects.size() * 78) + 5);\n\n\t\tsb.append(\"{\\\"lastAccessTime\\\":\");\n\t\tappend(sb, _lastAccessTime, false);\n\t\tsb.append(\",\\\"resultsTotal\\\":\");\n\t\tsb.append(_resultsTotal);\n\t\tsb.append(\",\\\"syncDLObjects\\\":[\");\n\n\t\tfor (int i = 0; i < _syncDLObjects.size(); i++) {\n\t\t\tSyncDLObject syncDLObject = _syncDLObjects.get(i);\n\n\t\t\tsb.append(\"{\\\"changeLog\\\":\");\n\t\t\tappend(sb, syncDLObject.getChangeLog(), true);\n\t\t\tsb.append(\",\\\"checksum\\\":\");\n\t\t\tappend(sb, syncDLObject.getChecksum(), false);\n\t\t\tsb.append(\",\\\"companyId\\\":\");\n\t\t\tappend(sb, syncDLObject.getCompanyId(), false);\n\t\t\tsb.append(\",\\\"createTime\\\":\");\n\t\t\tappend(sb, syncDLObject.getCreateTime(), false);\n\t\t\tsb.append(\",\\\"description\\\":\");\n\t\t\tappend(sb, syncDLObject.getDescription(), true);\n\t\t\tsb.append(\",\\\"event\\\":\");\n\t\t\tappend(sb, syncDLObject.getEvent(), false);\n\t\t\tsb.append(\",\\\"extension\\\":\");\n\t\t\tappend(sb, syncDLObject.getExtension(), true);\n\t\t\tsb.append(\",\\\"extraSettings\\\":\");\n\t\t\tappend(sb, syncDLObject.getExtraSettings(), true);\n\t\t\tsb.append(\",\\\"lockExpirationDate\\\":\");\n\n\t\t\tDate lockExpirationDate = syncDLObject.getLockExpirationDate();\n\n\t\t\tif (lockExpirationDate != null) {\n\t\t\t\tsb.append(lockExpirationDate.getTime());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(StringPool.NULL);\n\t\t\t}\n\n\t\t\tsb.append(\",\\\"lockUserId\\\":\");\n\t\t\tappend(sb, syncDLObject.getLockUserId(), false);\n\t\t\tsb.append(\",\\\"lockUserName\\\":\");\n\t\t\tappend(sb, syncDLObject.getLockUserName(), true);\n\t\t\tsb.append(\",\\\"mimeType\\\":\");\n\t\t\tappend(sb, syncDLObject.getMimeType(), true);\n\t\t\tsb.append(\",\\\"modifiedTime\\\":\");\n\t\t\tappend(sb, syncDLObject.getModifiedTime(), false);\n\t\t\tsb.append(\",\\\"name\\\":\");\n\t\t\tappend(sb, syncDLObject.getName(), true);\n\t\t\tsb.append(\",\\\"parentFolderId\\\":\");\n\t\t\tappend(sb, syncDLObject.getParentFolderId(), false);\n\t\t\tsb.append(\",\\\"repositoryId\\\":\");\n\t\t\tappend(sb, syncDLObject.getRepositoryId(), false);\n\t\t\tsb.append(\",\\\"size\\\":\");\n\t\t\tappend(sb, syncDLObject.getSize(), false);\n\t\t\tsb.append(\",\\\"syncDLObjectId\\\":\");\n\t\t\tappend(sb, syncDLObject.getSyncDLObjectId(), false);\n\t\t\tsb.append(\",\\\"type\\\":\");\n\t\t\tappend(sb, syncDLObject.getType(), false);\n\t\t\tsb.append(\",\\\"typePK\\\":\");\n\t\t\tappend(sb, syncDLObject.getTypePK(), false);\n\t\t\tsb.append(\",\\\"typeUuid\\\":\");\n\t\t\tappend(sb, syncDLObject.getTypeUuid(), false);\n\t\t\tsb.append(\",\\\"userId\\\":\");\n\t\t\tappend(sb, syncDLObject.getUserId(), false);\n\t\t\tsb.append(\",\\\"userName\\\":\");\n\t\t\tappend(sb, syncDLObject.getUserName(), true);\n\t\t\tsb.append(\",\\\"version\\\":\");\n\t\t\tappend(sb, syncDLObject.getVersion(), false);\n\t\t\tsb.append(\",\\\"versionId\\\":\");\n\t\t\tappend(sb, syncDLObject.getVersionId(), false);\n\t\t\tsb.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tif (i != (_syncDLObjects.size() - 1)) {\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"]}\");\n\n\t\treturn sb.toString();\n\t}","id":47980,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler(\n\t\t\t(_settingsModifiedTimes.size() * 4) + (_syncDLObjects.size() * 78) +\n\t\t\t\t5);\n\n\t\tsb.append(\"{\\\"lastAccessTime\\\":\");\n\t\tappend(sb, _lastAccessTime, false);\n\t\tsb.append(\",\\\"resultsTotal\\\":\");\n\t\tsb.append(_resultsTotal);\n\t\tsb.append(\",\\\"settingsModifiedTimes\\\":{\");\n\n\t\tSet<Map.Entry<String, Long>> entries =\n\t\t\t_settingsModifiedTimes.entrySet();\n\n\t\tIterator<Map.Entry<String, Long>> iterator = entries.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tMap.Entry<String, Long> entry = iterator.next();\n\n\t\t\tString key = entry.getKey();\n\t\t\tlong value = entry.getValue();\n\n\t\t\tappend(sb, key, false);\n\t\t\tsb.append(StringPool.COLON);\n\t\t\tappend(sb, value, false);\n\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"},\\\"syncDLObjects\\\":[\");\n\n\t\tfor (int i = 0; i < _syncDLObjects.size(); i++) {\n\t\t\tSyncDLObject syncDLObject = _syncDLObjects.get(i);\n\n\t\t\tsb.append(\"{\\\"changeLog\\\":\");\n\t\t\tappend(sb, syncDLObject.getChangeLog(), true);\n\t\t\tsb.append(\",\\\"checksum\\\":\");\n\t\t\tappend(sb, syncDLObject.getChecksum(), false);\n\t\t\tsb.append(\",\\\"companyId\\\":\");\n\t\t\tappend(sb, syncDLObject.getCompanyId(), false);\n\t\t\tsb.append(\",\\\"createTime\\\":\");\n\t\t\tappend(sb, syncDLObject.getCreateTime(), false);\n\t\t\tsb.append(\",\\\"description\\\":\");\n\t\t\tappend(sb, syncDLObject.getDescription(), true);\n\t\t\tsb.append(\",\\\"event\\\":\");\n\t\t\tappend(sb, syncDLObject.getEvent(), false);\n\t\t\tsb.append(\",\\\"extension\\\":\");\n\t\t\tappend(sb, syncDLObject.getExtension(), true);\n\t\t\tsb.append(\",\\\"extraSettings\\\":\");\n\t\t\tappend(sb, syncDLObject.getExtraSettings(), true);\n\t\t\tsb.append(\",\\\"lockExpirationDate\\\":\");\n\n\t\t\tDate lockExpirationDate = syncDLObject.getLockExpirationDate();\n\n\t\t\tif (lockExpirationDate != null) {\n\t\t\t\tsb.append(lockExpirationDate.getTime());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(StringPool.NULL);\n\t\t\t}\n\n\t\t\tsb.append(\",\\\"lockUserId\\\":\");\n\t\t\tappend(sb, syncDLObject.getLockUserId(), false);\n\t\t\tsb.append(\",\\\"lockUserName\\\":\");\n\t\t\tappend(sb, syncDLObject.getLockUserName(), true);\n\t\t\tsb.append(\",\\\"mimeType\\\":\");\n\t\t\tappend(sb, syncDLObject.getMimeType(), true);\n\t\t\tsb.append(\",\\\"modifiedTime\\\":\");\n\t\t\tappend(sb, syncDLObject.getModifiedTime(), false);\n\t\t\tsb.append(\",\\\"name\\\":\");\n\t\t\tappend(sb, syncDLObject.getName(), true);\n\t\t\tsb.append(\",\\\"parentFolderId\\\":\");\n\t\t\tappend(sb, syncDLObject.getParentFolderId(), false);\n\t\t\tsb.append(\",\\\"repositoryId\\\":\");\n\t\t\tappend(sb, syncDLObject.getRepositoryId(), false);\n\t\t\tsb.append(\",\\\"size\\\":\");\n\t\t\tappend(sb, syncDLObject.getSize(), false);\n\t\t\tsb.append(\",\\\"syncDLObjectId\\\":\");\n\t\t\tappend(sb, syncDLObject.getSyncDLObjectId(), false);\n\t\t\tsb.append(\",\\\"type\\\":\");\n\t\t\tappend(sb, syncDLObject.getType(), false);\n\t\t\tsb.append(\",\\\"typePK\\\":\");\n\t\t\tappend(sb, syncDLObject.getTypePK(), false);\n\t\t\tsb.append(\",\\\"typeUuid\\\":\");\n\t\t\tappend(sb, syncDLObject.getTypeUuid(), false);\n\t\t\tsb.append(\",\\\"userId\\\":\");\n\t\t\tappend(sb, syncDLObject.getUserId(), false);\n\t\t\tsb.append(\",\\\"userName\\\":\");\n\t\t\tappend(sb, syncDLObject.getUserName(), true);\n\t\t\tsb.append(\",\\\"version\\\":\");\n\t\t\tappend(sb, syncDLObject.getVersion(), false);\n\t\t\tsb.append(\",\\\"versionId\\\":\");\n\t\t\tappend(sb, syncDLObject.getVersionId(), false);\n\t\t\tsb.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\t\tif (i != (_syncDLObjects.size() - 1)) {\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\"]}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"d6a6eb01f0c0d101b7f9d141e69c1ddced0edff6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public void visitPyWhileStatement(final PyWhileStatement node) {\n    final Instruction instruction = myBuilder.startNode(node);\n    final PyWhilePart whilePart = node.getWhilePart();\n    final PyExpression condition = whilePart.getCondition();\n    if (condition != null) {\n      condition.accept(this);\n    }\n    final Instruction head = myBuilder.prevInstruction;\n    final PyElsePart elsePart = node.getElsePart();\n    if (elsePart == null) {\n      myBuilder.addPendingEdge(node, myBuilder.prevInstruction);\n    }\n    final PyStatementList list = whilePart.getStatementList();\n    if (list != null) {\n      myBuilder.startConditionalNode(list,  condition, true);\n      list.accept(this);\n      // Loop edges\n      if (myBuilder.prevInstruction != null) {\n        myBuilder.addEdge(myBuilder.prevInstruction, instruction);\n      }\n      myBuilder.checkPending(instruction);\n    }\n    myBuilder.prevInstruction = head;\n    if (elsePart != null) {\n      elsePart.accept(this);\n      myBuilder.addPendingEdge(node, myBuilder.prevInstruction);\n    }\n    myBuilder.flowAbrupted();\n  }","id":47981,"modified_method":"@Override\n  public void visitPyWhileStatement(final PyWhileStatement node) {\n    final Instruction instruction = myBuilder.startNode(node);\n    final PyWhilePart whilePart = node.getWhilePart();\n    final PyExpression condition = whilePart.getCondition();\n    boolean isStaticallyTrue = false;\n    if (condition != null) {\n      condition.accept(this);\n      isStaticallyTrue = (PyConstantExpressionEvaluator.evaluate(condition) == Boolean.TRUE);\n    }\n    final Instruction head = myBuilder.prevInstruction;\n    final PyElsePart elsePart = node.getElsePart();\n    if (elsePart == null && !isStaticallyTrue) {\n      myBuilder.addPendingEdge(node, myBuilder.prevInstruction);\n    }\n    final PyStatementList list = whilePart.getStatementList();\n    myBuilder.startConditionalNode(list, condition, true);\n    list.accept(this);\n    // Loop edges\n    if (myBuilder.prevInstruction != null) {\n      myBuilder.addEdge(myBuilder.prevInstruction, instruction);\n    }\n    myBuilder.checkPending(instruction);\n    myBuilder.prevInstruction = head;\n    if (elsePart != null && !isStaticallyTrue) {\n      elsePart.accept(this);\n      myBuilder.addPendingEdge(node, myBuilder.prevInstruction);\n    }\n    myBuilder.flowAbrupted();\n  }","commit_id":"027fe9bb55f26dfdb6b609a5485c207051b7e739","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyListCompExpression(final PyListCompExpression node) {\n    myBuilder.startNode(node);\n    for (ComprhIfComponent component : node.getIfComponents()) {\n      final PyExpression condition = component.getTest();\n      condition.accept(this);\n      final Instruction head = myBuilder.prevInstruction;\n      final Instruction prevInstruction = myBuilder.startConditionalNode(condition, condition, true);\n      // restore head\n      myBuilder.prevInstruction = head;\n      myBuilder.addPendingEdge(node, myBuilder.startConditionalNode(condition, condition, false)); // false condition\n      myBuilder.prevInstruction = prevInstruction;\n    }\n\n    for (ComprhForComponent forComponent : node.getForComponents()) {\n      forComponent.getIteratedList().accept(this);\n      forComponent.getIteratorVariable().accept(this);\n    }\n\n    node.getResultExpression().accept(this);\n  }","id":47982,"modified_method":"@Override\n  public void visitPyListCompExpression(final PyListCompExpression node) {\n    myBuilder.startNode(node);\n    PyExpression prevCondition = null;\n    for (ComprhIfComponent component : node.getIfComponents()) {\n      final PyExpression condition = component.getTest();\n      condition.accept(this);\n      final Instruction head = myBuilder.prevInstruction;\n      final Instruction prevInstruction =  prevCondition != null\n                                           ? myBuilder.startConditionalNode(condition, prevCondition, true)\n                                           : myBuilder.startNode(condition);\n      prevCondition = condition;\n      // restore head\n      myBuilder.prevInstruction = head;\n      myBuilder.addPendingEdge(node, head); // false condition\n      myBuilder.prevInstruction = prevInstruction;\n    }\n\n    for (ComprhForComponent forComponent : node.getForComponents()) {\n      final PyExpression iteratedList = forComponent.getIteratedList();\n      if (prevCondition != null){\n        myBuilder.startConditionalNode(iteratedList, prevCondition, true);\n        prevCondition = null;\n      }\n      iteratedList.accept(this);\n      forComponent.getIteratorVariable().accept(this);\n    }\n\n    node.getResultExpression().accept(this);\n  }","commit_id":"c6c9be34cbd7a27382d75a791a8e7effde4b3305","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyComprehensionElement(final PyComprehensionElement node) {\n    myBuilder.startNode(node);\n    PyExpression prevCondition = null;\n    for (ComprhIfComponent component : node.getIfComponents()) {\n      final PyExpression condition = component.getTest();\n      if (condition != null) {\n        condition.accept(this);\n        final Instruction head = myBuilder.prevInstruction;\n        final Instruction prevInstruction =\n          prevCondition != null ? myBuilder.startConditionalNode(condition, prevCondition, true) : myBuilder.startNode(condition);\n        prevCondition = condition;\n        // restore head\n        myBuilder.prevInstruction = head;\n        myBuilder.addPendingEdge(node, head); // false condition\n        myBuilder.prevInstruction = prevInstruction;\n      }\n    }\n\n    for (ComprhForComponent forComponent : node.getForComponents()) {\n      final PyExpression iteratedList = forComponent.getIteratedList();\n      if (prevCondition != null) {\n        myBuilder.startConditionalNode(iteratedList, prevCondition, true);\n        prevCondition = null;\n      }\n      iteratedList.accept(this);\n      forComponent.getIteratorVariable().accept(this);\n    }\n\n    final PyExpression result = node.getResultExpression();\n    if (result != null) {\n      result.accept(this);\n    }\n  }","id":47983,"modified_method":"@Override\n  public void visitPyComprehensionElement(final PyComprehensionElement node) {\n    PyExpression prevCondition = null;\n    myBuilder.startNode(node);\n    List<Instruction> iterators = new ArrayList<Instruction>();\n\n    for (ComprehensionComponent component : node.getComponents()) {\n      if (component instanceof ComprhForComponent) {\n        final ComprhForComponent c = (ComprhForComponent) component;\n        final PyExpression iteratedList = c.getIteratedList();\n        final PyExpression iteratorVariable = c.getIteratorVariable();\n        if (prevCondition != null) {\n          myBuilder.startConditionalNode(iteratedList, prevCondition, true);\n          prevCondition = null;\n        }\n        else {\n          myBuilder.startNode(iteratedList);\n        }\n        iteratedList.accept(this);\n\n        // for-loop continue and exit\n        for (Instruction i : iterators) {\n          myBuilder.addEdge(myBuilder.prevInstruction, i);\n        }\n        myBuilder.addPendingEdge(node, myBuilder.prevInstruction);\n\n        final Instruction iterator = myBuilder.startNode(iteratorVariable);\n        iteratorVariable.accept(this);\n\n        // Inner \"for\" and \"if\" constructs will be linked to all outer iterators\n        iterators.add(iterator);\n      }\n      else if (component instanceof ComprhIfComponent) {\n        final ComprhIfComponent c = (ComprhIfComponent) component;\n        final PyExpression condition = c.getTest();\n        if (condition == null) {\n          continue;\n        }\n        if (prevCondition != null) {\n          myBuilder.startConditionalNode(condition, prevCondition, true);\n        }\n        else {\n          myBuilder.startNode(condition);\n        }\n        condition.accept(this);\n\n        // Condition is true for nested \"for\" and \"if\" constructs, next startNode() should create a conditional node\n        prevCondition = condition;\n\n        // for-loop continue and exit\n        for (Instruction i : iterators) {\n          myBuilder.addEdge(myBuilder.prevInstruction, i);\n        }\n        myBuilder.addPendingEdge(node, myBuilder.prevInstruction);\n      }\n    }\n\n    final PyExpression result = node.getResultExpression();\n    if (result != null) {\n      if (prevCondition != null) {\n        myBuilder.startConditionalNode(result, prevCondition, true);\n      }\n      else {\n        myBuilder.startNode(result);\n      }\n      result.accept(this);\n\n      // for-loop continue\n      for (Instruction i : iterators) {\n        myBuilder.addEdge(myBuilder.prevInstruction, i);\n      }\n    }\n  }","commit_id":"99941e03ffc4848f60ff0a47dd80b203e2e72449","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleInsert(final InsertionContext context, final T item) {\n    final Editor editor = context.getEditor();\n    final Document document = editor.getDocument();\n    PsiElement element = findNextToken(context);\n\n    final char completionChar = context.getCompletionChar();\n    final boolean putCaretInside = completionChar == '(' || placeCaretInsideParentheses(context, item);\n\n    if (completionChar == '(') {\n      context.setAddCompletionChar(false);\n    }\n\n    if (isToken(element, \"(\")) {\n      int lparenthOffset = element.getTextRange().getStartOffset();\n      if (mySpaceBeforeParentheses && lparenthOffset == context.getTailOffset()) {\n        document.insertString(context.getTailOffset(), \" \");\n        lparenthOffset++;\n      }\n\n      if (completionChar == '(' || completionChar == '\\t') {\n        editor.getCaretModel().moveToOffset(lparenthOffset + 1);\n      } else {\n        editor.getCaretModel().moveToOffset(context.getTailOffset());\n      }\n\n      context.setTailOffset(lparenthOffset + 1);\n\n      PsiElement list = element.getParent();\n      PsiElement last = list.getLastChild();\n      if (isToken(last, \")\")) {\n        int rparenthOffset = last.getTextRange().getStartOffset();\n        context.setTailOffset(rparenthOffset + 1);\n        if (!putCaretInside) {\n          for (int i = lparenthOffset + 1; i < rparenthOffset; i++) {\n            if (!Character.isWhitespace(document.getCharsSequence().charAt(i))) {\n              return;\n            }\n          }\n          editor.getCaretModel().moveToOffset(context.getTailOffset());\n        } else if (mySpaceBetweenParentheses && document.getCharsSequence().charAt(lparenthOffset) == ' ') {\n          editor.getCaretModel().moveToOffset(lparenthOffset + 2);\n        } else {\n          editor.getCaretModel().moveToOffset(lparenthOffset + 1);\n        }\n        return;\n      }\n    } else {\n      int tailOffset = context.getTailOffset();\n      if (mySpaceBeforeParentheses) {\n        tailOffset = TailType.insertChar(editor, tailOffset, ' ');\n      }\n      tailOffset = TailType.insertChar(editor, tailOffset, '(');\n      if (mySpaceBetweenParentheses) {\n        tailOffset = TailType.insertChar(editor, tailOffset, ' ');\n      }\n    }\n\n    if (!myInsertRightParenthesis) return;\n\n    int tailOffset = context.getTailOffset();\n    int caret = tailOffset;\n    if (mySpaceBetweenParentheses) {\n      tailOffset = TailType.insertChar(editor, tailOffset, ' ');\n    }\n    document.insertString(tailOffset, \")\");\n    editor.getCaretModel().moveToOffset(putCaretInside ? caret : context.getTailOffset());\n  }","id":47984,"modified_method":"public void handleInsert(final InsertionContext context, final T item) {\n    final Editor editor = context.getEditor();\n    final Document document = editor.getDocument();\n    PsiElement element = findNextToken(context);\n\n    final char completionChar = context.getCompletionChar();\n    final boolean putCaretInside = completionChar == '(' || placeCaretInsideParentheses(context, item);\n\n    if (completionChar == '(') {\n      context.setAddCompletionChar(false);\n    }\n\n    if (isToken(element, \"(\")) {\n      int lparenthOffset = element.getTextRange().getStartOffset();\n      if (mySpaceBeforeParentheses && lparenthOffset == context.getTailOffset()) {\n        document.insertString(context.getTailOffset(), \" \");\n        lparenthOffset++;\n      }\n\n      if (completionChar == '(' || completionChar == '\\t') {\n        editor.getCaretModel().moveToOffset(lparenthOffset + 1);\n      } else {\n        editor.getCaretModel().moveToOffset(context.getTailOffset());\n      }\n\n      context.setTailOffset(lparenthOffset + 1);\n\n      PsiElement list = element.getParent();\n      PsiElement last = list.getLastChild();\n      if (isToken(last, \")\")) {\n        int rparenthOffset = last.getTextRange().getStartOffset();\n        context.setTailOffset(rparenthOffset + 1);\n        if (!putCaretInside) {\n          for (int i = lparenthOffset + 1; i < rparenthOffset; i++) {\n            if (!Character.isWhitespace(document.getCharsSequence().charAt(i))) {\n              return;\n            }\n          }\n          editor.getCaretModel().moveToOffset(context.getTailOffset());\n        } else if (mySpaceBetweenParentheses && document.getCharsSequence().charAt(lparenthOffset) == ' ') {\n          editor.getCaretModel().moveToOffset(lparenthOffset + 2);\n        } else {\n          editor.getCaretModel().moveToOffset(lparenthOffset + 1);\n        }\n        return;\n      }\n    } else {\n      document.insertString(context.getTailOffset(), getSpace(mySpaceBeforeParentheses) + \"(\" + getSpace(mySpaceBetweenParentheses));\n      editor.getCaretModel().moveToOffset(context.getTailOffset());\n    }\n\n    if (!myInsertRightParenthesis) return;\n\n    document.insertString(context.getTailOffset(), getSpace(mySpaceBetweenParentheses) + \")\");\n    if (!putCaretInside) {\n      editor.getCaretModel().moveToOffset(context.getTailOffset());\n    }\n  }","commit_id":"23e571ef91e4240ac4b753d46bf3303f21678fae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void prepareUpdate(RowMetaInterface rowMeta) throws KettleDatabaseException\n    {\n        DatabaseMeta databaseMeta = meta.getDatabaseMeta();\n        data.updateParameterRowMeta = new RowMeta();\n        \n        String sql = \"UPDATE \" + data.schemaTable + Const.CR;\n        sql += \"SET \";\n        \r\n        boolean comma=false;\r\n        \n        for (int i=0;i<meta.getUpdateLookup().length;i++)\n        {\n    \t\tif ( meta.getUpdate()[i].booleanValue() ) {\n                if (comma) sql+= \",   \";\r\n                else comma=true;\r\n                \n                sql += databaseMeta.quoteField(meta.getUpdateLookup()[i]);\n                sql += \" = ?\" + Const.CR;\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getUpdateStream()[i]) );\n    \t\t}\n        }\n\n        sql += \"WHERE \";\n\n        for (int i=0;i<meta.getKeyLookup().length;i++)\n        {\n            if (i!=0) sql += \"AND   \";\n            sql += databaseMeta.quoteField(meta.getKeyLookup()[i]);\n            if (\"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n            {\n                sql += \" BETWEEN ? AND ? \";\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream2()[i]) );\n            }\n            else\n            if (\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) || \"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n            {\n                sql += \" \"+meta.getKeyCondition()[i]+\" \";\n            }\n            else\n            {\n                sql += \" \"+meta.getKeyCondition()[i]+\" ? \";\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n            }\n        }\n\n        try\n        {\n            log.logDetailed(toString(), \"Setting update preparedStatement to [\"+sql+\"]\");\n            data.prepStatementUpdate=data.db.getConnection().prepareStatement(databaseMeta.stripCR(sql));\n        }\n        catch(SQLException ex) \n        {\n            throw new KettleDatabaseException(\"Unable to prepare statement for SQL statement [\" + sql + \"]\", ex);\n        }\n    }","id":47985,"modified_method":"public void prepareUpdate(RowMetaInterface rowMeta) throws KettleDatabaseException\n    {\n        DatabaseMeta databaseMeta = meta.getDatabaseMeta();\n        data.updateParameterRowMeta = new RowMeta();\n        \n        String sql = \"UPDATE \" + data.schemaTable + Const.CR;\n        sql += \"SET \";\n        \r\n        boolean comma=false;\r\n        \n        for (int i=0;i<meta.getUpdateLookup().length;i++)\n        {\n    \t\tif ( meta.getUpdate()[i].booleanValue() ) {\n                if (comma) sql+= \",   \";\r\n                else comma=true;\r\n                \n                sql += databaseMeta.quoteField(meta.getUpdateLookup()[i]);\n                sql += \" = ?\" + Const.CR;\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getUpdateStream()[i]).clone() );\n    \t\t}\n        }\n\n        sql += \"WHERE \";\n\n        for (int i=0;i<meta.getKeyLookup().length;i++)\n        {\n            if (i!=0) sql += \"AND   \";\n            sql += databaseMeta.quoteField(meta.getKeyLookup()[i]);\n            if (\"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n            {\n                sql += \" BETWEEN ? AND ? \";\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream2()[i]) );\n            }\n            else\n            if (\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) || \"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n            {\n                sql += \" \"+meta.getKeyCondition()[i]+\" \";\n            }\n            else\n            {\n                sql += \" \"+meta.getKeyCondition()[i]+\" ? \";\n                data.updateParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]).clone() );\n            }\n        }\n\n        try\n        {\n            log.logDetailed(toString(), \"Setting update preparedStatement to [\"+sql+\"]\");\n            data.prepStatementUpdate=data.db.getConnection().prepareStatement(databaseMeta.stripCR(sql));\n        }\n        catch(SQLException ex) \n        {\n            throw new KettleDatabaseException(\"Unable to prepare statement for SQL statement [\" + sql + \"]\", ex);\n        }\n    }","commit_id":"de3cb4e9feb251742ad0252e0dd2b2e597cd8760","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setLookup(RowMetaInterface rowMeta) throws KettleDatabaseException\n    {\n        data.lookupParameterRowMeta = new RowMeta();\n        data.lookupReturnRowMeta = new RowMeta();\n        \n        DatabaseMeta databaseMeta = meta.getDatabaseMeta();\n        \n        String sql = \"SELECT \";\n\n        for (int i = 0; i < meta.getUpdateLookup().length; i++)\n        {\n            if (i != 0) sql += \", \";\n            sql += databaseMeta.quoteField(meta.getUpdateLookup()[i]);\n            data.lookupReturnRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getUpdateStream()[i]) );\n        }\n\n        sql += \" FROM \" + data.schemaTable + \" WHERE \";\n\n        for (int i = 0; i < meta.getKeyLookup().length; i++)\n        {\n            if (i != 0) sql += \" AND \";\n            sql += databaseMeta.quoteField(meta.getKeyLookup()[i]);\n            if (\"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n            {\n                sql += \" BETWEEN ? AND ? \";\n                data.lookupParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n                data.lookupParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream2()[i]) );\n            }\n            else\n            {\n                if (\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) || \"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n                {\n                    sql += \" \" + meta.getKeyCondition()[i] + \" \";\n                }\n                else\n                {\n                    sql += \" \" + meta.getKeyCondition()[i] + \" ? \";\n                    data.lookupParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n                }\n            }\n        }\n        \n        try\n        {\n            log.logDetailed(toString(), \"Setting preparedStatement to [\" + sql + \"]\");\n            data.prepStatementLookup = data.db.getConnection().prepareStatement(databaseMeta.stripCR(sql));\n        }\n        catch (SQLException ex)\n        {\n            throw new KettleDatabaseException(\"Unable to prepare statement for SQL statement [\" + sql + \"]\", ex);\n        }\n    }","id":47986,"modified_method":"public void setLookup(RowMetaInterface rowMeta) throws KettleDatabaseException\n    {\n        data.lookupParameterRowMeta = new RowMeta();\n        data.lookupReturnRowMeta = new RowMeta();\n        \n        DatabaseMeta databaseMeta = meta.getDatabaseMeta();\n        \n        String sql = \"SELECT \";\n\n        for (int i = 0; i < meta.getUpdateLookup().length; i++)\n        {\n            if (i != 0) sql += \", \";\n            sql += databaseMeta.quoteField(meta.getUpdateLookup()[i]);\n            data.lookupReturnRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getUpdateStream()[i]).clone() );\n        }\n\n        sql += \" FROM \" + data.schemaTable + \" WHERE \";\n\n        for (int i = 0; i < meta.getKeyLookup().length; i++)\n        {\n            if (i != 0) sql += \" AND \";\n            sql += databaseMeta.quoteField(meta.getKeyLookup()[i]);\n            if (\"BETWEEN\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n            {\n                sql += \" BETWEEN ? AND ? \";\n                data.lookupParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n                data.lookupParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream2()[i]) );\n            }\n            else\n            {\n                if (\"IS NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]) || \"IS NOT NULL\".equalsIgnoreCase(meta.getKeyCondition()[i]))\n                {\n                    sql += \" \" + meta.getKeyCondition()[i] + \" \";\n                }\n                else\n                {\n                    sql += \" \" + meta.getKeyCondition()[i] + \" ? \";\n                    data.lookupParameterRowMeta.addValueMeta( rowMeta.searchValueMeta(meta.getKeyStream()[i]) );\n                }\n            }\n        }\n        \n        try\n        {\n            log.logDetailed(toString(), \"Setting preparedStatement to [\" + sql + \"]\");\n            data.prepStatementLookup = data.db.getConnection().prepareStatement(databaseMeta.stripCR(sql));\n        }\n        catch (SQLException ex)\n        {\n            throw new KettleDatabaseException(\"Unable to prepare statement for SQL statement [\" + sql + \"]\", ex);\n        }\n    }","commit_id":"de3cb4e9feb251742ad0252e0dd2b2e597cd8760","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n\tpublic void getFields(RowMetaInterface row, String name, RowMetaInterface[] info, StepMeta nextStep,\n\t\t\tVariableSpace space) throws KettleStepException {\n\t\n\t\t// Get a unique list of the occurrences of the type\n\t\t//\n\t\tList<String> norm_occ = new ArrayList<String>();\n\t\tList<String> field_occ  = new ArrayList<String>();\n\t\tint maxlen=0;\n\t\tfor (int i=0;i<fieldNorm.length;i++)\n\t\t{\n\t\t\tif (norm_occ.contains(fieldNorm[i])) \n\t\t\t{\n\t\t\t\tnorm_occ.add(fieldNorm[i]);\n\t\t\t\tfield_occ.add(fieldName[i]);\n\t\t\t} \n\t\t\t\n\t\t\tif (fieldValue[i].length()>maxlen) maxlen=fieldValue[i].length();\n\t\t}\n\n\t\t// Then add the type field!\n\t\t//\n\t\tValueMetaInterface typefield_value = new ValueMeta(typeField, ValueMetaInterface.TYPE_STRING);\n\t\ttypefield_value.setOrigin(name);\n\t\ttypefield_value.setLength(maxlen);\n\t\trow.addValueMeta(typefield_value);\n\n\t\t// Loop over the distinct list of fieldNorm[i]\n\t\t// Add the new fields that need to be created. \n\t\t// Use the same data type as the original fieldname...\n\t\t//\n\t\tfor (int i=0;i<norm_occ.size();i++)\n\t\t{\n\t\t\tString normname = (String)norm_occ.get(i);\n\t\t\tString fieldname =(String)field_occ.get(i);\n\t\t\tValueMetaInterface v = row.searchValueMeta(fieldname);\n\t\t\tv.setName(normname);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValueMeta(v);\n\t\t}\n\t\t\n\t\t// Now remove all the normalized fields...\n\t\t//\n\t\tfor (int i=0;i<fieldName.length;i++) {\n\t\t\tint idx = row.indexOfValue(fieldName[i]);\n\t\t\tif (idx>=0) row.removeValueMeta(idx);\n\t\t}\n\t}","id":47987,"modified_method":"@Override\n\tpublic void getFields(RowMetaInterface row, String name, RowMetaInterface[] info, StepMeta nextStep,\n\t\t\tVariableSpace space) throws KettleStepException {\n\t\n\t\t// Get a unique list of the occurrences of the type\n\t\t//\n\t\tList<String> norm_occ = new ArrayList<String>();\n\t\tList<String> field_occ  = new ArrayList<String>();\n\t\tint maxlen=0;\n\t\tfor (int i=0;i<fieldNorm.length;i++)\n\t\t{\n\t\t\tif (!norm_occ.contains(fieldNorm[i])) \n\t\t\t{\n\t\t\t\tnorm_occ.add(fieldNorm[i]);\n\t\t\t\tfield_occ.add(fieldName[i]);\n\t\t\t} \n\t\t\t\n\t\t\tif (fieldValue[i].length()>maxlen) maxlen=fieldValue[i].length();\n\t\t}\n\n\t\t// Then add the type field!\n\t\t//\n\t\tValueMetaInterface typefield_value = new ValueMeta(typeField, ValueMetaInterface.TYPE_STRING);\n\t\ttypefield_value.setOrigin(name);\n\t\ttypefield_value.setLength(maxlen);\n\t\trow.addValueMeta(typefield_value);\n\n\t\t// Loop over the distinct list of fieldNorm[i]\n\t\t// Add the new fields that need to be created. \n\t\t// Use the same data type as the original fieldname...\n\t\t//\n\t\tfor (int i=0;i<norm_occ.size();i++)\n\t\t{\n\t\t\tString normname = (String)norm_occ.get(i);\n\t\t\tString fieldname =(String)field_occ.get(i);\n\t\t\tValueMetaInterface v = row.searchValueMeta(fieldname).clone();\n\t\t\tv.setName(normname);\n\t\t\tv.setOrigin(name);\n\t\t\trow.addValueMeta(v);\n\t\t}\n\t\t\n\t\t// Now remove all the normalized fields...\n\t\t//\n\t\tfor (int i=0;i<fieldName.length;i++) {\n\t\t\tint idx = row.indexOfValue(fieldName[i]);\n\t\t\tif (idx>=0) row.removeValueMeta(idx);\n\t\t}\n\t}","commit_id":"64c2d748ebc3a4de5fe715cdf71a186031778b4d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Copy information from the meta-data input to the dialog fields.\n     */\n    private void getData()\n    {\n        shell.getDisplay().asyncExec(new Runnable()\n        {\n            public void run()\n            {\n                for (int i = 0; i < buffer.size(); i++)\n                {\n                    TableItem item = wFields.table.getItem(i);\n                    Object[] row = (Object[]) buffer.get(i);\n\n                    for (int c = 0; c < rowMeta.size(); c++)\n                    {\n                        ValueMetaInterface v = rowMeta.getValueMeta(c);\n                        String show;\n                        try\n                        {\n                            show = v.getString(row[c]);\n                        }\n                        catch (KettleValueException e)\n                        {\n                            LogWriter.getInstance().logError(toString(), Const.getStackTracker(e));\n                            show=null;\n                        }\n                        catch (ArrayIndexOutOfBoundsException e)\n                        {\n                            LogWriter.getInstance().logError(toString(), Const.getStackTracker(e));\n                            show=null;\n                        }\n\n                        if (show != null)\n                        {\n                            item.setText(c + 1, show);\n                        }\n                    }\n                }\n                wFields.optWidth(true, 200);\n            }\n        });\n    }","id":47988,"modified_method":"/**\n     * Copy information from the meta-data input to the dialog fields.\n     */\n    private void getData()\n    {\n        shell.getDisplay().asyncExec(new Runnable()\n        {\n            public void run()\n            {\n                for (int i = 0; i < buffer.size(); i++)\n                {\n                    TableItem item = wFields.table.getItem(i);\n                    Object[] row = (Object[]) buffer.get(i);\n\n                    for (int c = 0; c < rowMeta.size(); c++)\n                    {\n                        ValueMetaInterface v = rowMeta.getValueMeta(c);\n                        String show;\n                        try\n                        {\n                            show = v.getString(row[c]);\n                        }\n                        catch (KettleValueException e)\n                        {\n                            LogWriter.getInstance().logError(toString(), Const.getStackTracker(e));\n                            show=null;\n                        }\n                        catch (ArrayIndexOutOfBoundsException e)\n                        {\n                            LogWriter.getInstance().logError(toString(), Const.getStackTracker(e));\n                            show=null;\n                        }\n\n                        if (show != null)\n                        {\n                            item.setText(c + 1, show);\n                        }\n                    }\n                }\n                if (!wFields.isDisposed()) wFields.optWidth(true, 200);\n            }\n        });\n    }","commit_id":"64c2d748ebc3a4de5fe715cdf71a186031778b4d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n        if ( data.hasLookupRows )  \n        {\n\t\t    try\n\t\t    {\n  \t\t\t    if (meta.getKeystream().length>0)\n\t\t\t    {\n\t\t\t\t    Object lookupData[] = new Object[data.lookupColumnIndex.length];\n\t\t\t\t    for (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n\t\t\t\t    add=getFromCache(data.lookupMeta, lookupData);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    // Just take the first element in the hashtable...\n\t\t\t\t    throw new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t    }\n\t\t    }\n\t\t    catch(Exception e)\n\t\t    {\n\t\t\t    throw new KettleStepException(e);\n\t\t    }\n        }\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}","id":47989,"modified_method":"private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertData(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}","commit_id":"64c2d748ebc3a4de5fe715cdf71a186031778b4d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        if (hostname == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(hostname);\n        }\n        out.writeVInt(serviceAttributes.size());\n        for (Map.Entry<String, String> entry : serviceAttributes.entrySet()) {\n            out.writeUTF(entry.getKey());\n            out.writeUTF(entry.getValue());\n        }\n        ImmutableSettings.writeSettingsToStream(settings, out);\n        if (os == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            os.writeTo(out);\n        }\n        if (process == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            process.writeTo(out);\n        }\n        if (jvm == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            jvm.writeTo(out);\n        }\n        if (network == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            network.writeTo(out);\n        }\n        if (transport == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            transport.writeTo(out);\n        }\n        if (http == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            http.writeTo(out);\n        }\n    }","id":47990,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        if (hostname == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(hostname);\n        }\n        if (serviceAttributes() == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeVInt(serviceAttributes.size());\n            for (Map.Entry<String, String> entry : serviceAttributes.entrySet()) {\n                out.writeUTF(entry.getKey());\n                out.writeUTF(entry.getValue());\n            }\n        }\n        if (settings == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            ImmutableSettings.writeSettingsToStream(settings, out);\n        }\n        if (os == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            os.writeTo(out);\n        }\n        if (process == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            process.writeTo(out);\n        }\n        if (jvm == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            jvm.writeTo(out);\n        }\n        if (network == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            network.writeTo(out);\n        }\n        if (transport == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            transport.writeTo(out);\n        }\n        if (http == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            http.writeTo(out);\n        }\n    }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        if (in.readBoolean()) {\n            hostname = in.readUTF();\n        }\n        ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n        int size = in.readVInt();\n        for (int i = 0; i < size; i++) {\n            builder.put(in.readUTF(), in.readUTF());\n        }\n        serviceAttributes = builder.build();\n        settings = ImmutableSettings.readSettingsFromStream(in);\n        if (in.readBoolean()) {\n            os = OsInfo.readOsInfo(in);\n        }\n        if (in.readBoolean()) {\n            process = ProcessInfo.readProcessInfo(in);\n        }\n        if (in.readBoolean()) {\n            jvm = JvmInfo.readJvmInfo(in);\n        }\n        if (in.readBoolean()) {\n            network = NetworkInfo.readNetworkInfo(in);\n        }\n        if (in.readBoolean()) {\n            transport = TransportInfo.readTransportInfo(in);\n        }\n        if (in.readBoolean()) {\n            http = HttpInfo.readHttpInfo(in);\n        }\n    }","id":47991,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        if (in.readBoolean()) {\n            hostname = in.readUTF();\n        }\n        if (in.readBoolean()) {\n            ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n            int size = in.readVInt();\n            for (int i = 0; i < size; i++) {\n                builder.put(in.readUTF(), in.readUTF());\n            }\n            serviceAttributes = builder.build();\n        }\n        if (in.readBoolean()) {\n            settings = ImmutableSettings.readSettingsFromStream(in);\n        }\n        if (in.readBoolean()) {\n            os = OsInfo.readOsInfo(in);\n        }\n        if (in.readBoolean()) {\n            process = ProcessInfo.readProcessInfo(in);\n        }\n        if (in.readBoolean()) {\n            jvm = JvmInfo.readJvmInfo(in);\n        }\n        if (in.readBoolean()) {\n            network = NetworkInfo.readNetworkInfo(in);\n        }\n        if (in.readBoolean()) {\n            transport = TransportInfo.readTransportInfo(in);\n        }\n        if (in.readBoolean()) {\n            http = HttpInfo.readHttpInfo(in);\n        }\n    }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject\n    public RestNodesInfoAction(Settings settings, Client client, RestController controller,\n                               SettingsFilter settingsFilter) {\n        super(settings, client);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes/{nodeId}\", this);\n\n        this.settingsFilter = settingsFilter;\n    }","id":47992,"modified_method":"@Inject\n    public RestNodesInfoAction(Settings settings, Client client, RestController controller,\n                               SettingsFilter settingsFilter) {\n        super(settings, client);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_cluster/nodes/{nodeId}\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes\", this);\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}\", this);\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/settings\", new RestSettingsHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/settings\", new RestSettingsHandler());\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/os\", new RestOsHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/os\", new RestOsHandler());\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/process\", new RestProcessHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/process\", new RestProcessHandler());\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/jvm\", new RestJvmHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/jvm\", new RestJvmHandler());\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/network\", new RestNetworkHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/network\", new RestNetworkHandler());\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/transport\", new RestTransportHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/transport\", new RestTransportHandler());\n\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/http\", new RestHttpHandler());\n        controller.registerHandler(RestRequest.Method.GET, \"/_nodes/{nodeId}/http\", new RestHttpHandler());\n\n        this.settingsFilter = settingsFilter;\n    }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        String[] nodesIds = RestActions.splitNodes(request.param(\"nodeId\"));\n        final boolean includeSettings = request.paramAsBoolean(\"settings\", false);\n        NodesInfoRequest nodesInfoRequest = new NodesInfoRequest(nodesIds);\n        nodesInfoRequest.listenerThreaded(false);\n        client.admin().cluster().nodesInfo(nodesInfoRequest, new ActionListener<NodesInfoResponse>() {\n            @Override\n            public void onResponse(NodesInfoResponse result) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject();\n                    builder.field(\"cluster_name\", result.clusterName().value());\n\n                    builder.startObject(\"nodes\");\n                    for (NodeInfo nodeInfo : result) {\n                        builder.startObject(nodeInfo.node().id(), XContentBuilder.FieldCaseConversion.NONE);\n\n                        builder.field(\"name\", nodeInfo.node().name(), XContentBuilder.FieldCaseConversion.NONE);\n                        builder.field(\"transport_address\", nodeInfo.node().address().toString());\n\n                        if (nodeInfo.hostname() != null) {\n                            builder.field(\"hostname\", nodeInfo.hostname(), XContentBuilder.FieldCaseConversion.NONE);\n                        }\n\n                        for (Map.Entry<String, String> nodeAttribute : nodeInfo.serviceAttributes().entrySet()) {\n                            builder.field(nodeAttribute.getKey(), nodeAttribute.getValue());\n                        }\n\n                        builder.startObject(\"attributes\");\n                        for (Map.Entry<String, String> attr : nodeInfo.node().attributes().entrySet()) {\n                            builder.field(attr.getKey(), attr.getValue());\n                        }\n                        builder.endObject();\n\n\n                        if (includeSettings) {\n                            builder.startObject(\"settings\");\n                            Settings settings = settingsFilter.filterSettings(nodeInfo.settings());\n                            for (Map.Entry<String, String> entry : settings.getAsMap().entrySet()) {\n                                builder.field(entry.getKey(), entry.getValue());\n                            }\n                            builder.endObject();\n                        }\n\n                        if (nodeInfo.os() != null) {\n                            nodeInfo.os().toXContent(builder, request);\n                        }\n                        if (nodeInfo.process() != null) {\n                            nodeInfo.process().toXContent(builder, request);\n                        }\n                        if (nodeInfo.jvm() != null) {\n                            nodeInfo.jvm().toXContent(builder, request);\n                        }\n                        if (nodeInfo.network() != null) {\n                            nodeInfo.network().toXContent(builder, request);\n                        }\n                        if (nodeInfo.transport() != null) {\n                            nodeInfo.transport().toXContent(builder, request);\n                        }\n                        if (nodeInfo.http() != null) {\n                            nodeInfo.http().toXContent(builder, request);\n                        }\n\n                        builder.endObject();\n                    }\n                    builder.endObject();\n\n                    builder.endObject();\n                    channel.sendResponse(new XContentRestResponse(request, RestStatus.OK, builder));\n                } catch (Exception e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":47993,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        String[] nodesIds = RestActions.splitNodes(request.param(\"nodeId\"));\n        final NodesInfoRequest nodesInfoRequest = new NodesInfoRequest(nodesIds);\n\n        boolean clear = request.paramAsBoolean(\"clear\", false);\n        if (clear) {\n            nodesInfoRequest.clear();\n        }\n        nodesInfoRequest.settings(request.paramAsBoolean(\"settings\", nodesInfoRequest.settings()));\n        nodesInfoRequest.os(request.paramAsBoolean(\"os\", nodesInfoRequest.os()));\n        nodesInfoRequest.process(request.paramAsBoolean(\"process\", nodesInfoRequest.process()));\n        nodesInfoRequest.jvm(request.paramAsBoolean(\"jvm\", nodesInfoRequest.jvm()));\n        nodesInfoRequest.network(request.paramAsBoolean(\"network\", nodesInfoRequest.network()));\n        nodesInfoRequest.transport(request.paramAsBoolean(\"transport\", nodesInfoRequest.transport()));\n        nodesInfoRequest.http(request.paramAsBoolean(\"http\", nodesInfoRequest.http()));\n\n        executeNodeRequest(request, channel, nodesInfoRequest);\n    }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private NodeInfoRequest(String nodeId) {\n            super(nodeId);\n        }","id":47994,"modified_method":"NodeInfoRequest(String nodeId, NodesInfoRequest request) {\n            super(nodeId);\n            this.request = request;\n        }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected NodeInfo nodeOperation(NodeInfoRequest nodeInfoRequest) throws ElasticSearchException {\n        return nodeService.info();\n    }","id":47995,"modified_method":"@Override\n    protected NodeInfo nodeOperation(NodeInfoRequest nodeRequest) throws ElasticSearchException {\n        NodesInfoRequest request = nodeRequest.request;\n        return nodeService.info(request.settings(), request.os(), request.process(), request.jvm(), request.network(), request.transport(), request.http());\n    }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private NodeInfoRequest() {\n        }","id":47996,"modified_method":"NodeInfoRequest() {\n        }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected NodeInfoRequest newNodeRequest(String nodeId, NodesInfoRequest request) {\n        return new NodeInfoRequest(nodeId);\n    }","id":47997,"modified_method":"@Override\n    protected NodeInfoRequest newNodeRequest(String nodeId, NodesInfoRequest request) {\n        return new NodeInfoRequest(nodeId, request);\n    }","commit_id":"f1f2fb2ba79b98200013b970cc0a5db721068e75","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        tookInMillis = in.readVLong();\n        count = in.readVLong();\n        int size = in.readVInt();\n        matches = new Match[size];\n        for (int i = 0; i < size; i++) {\n            matches[i] = new Match();\n            matches[i].readFrom(in);\n        }\n        facets = InternalFacets.readOptionalFacets(in);\n        aggregations = InternalAggregations.readOptionalAggregations(in);\n    }","id":47998,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        tookInMillis = in.readVLong();\n        count = in.readVLong();\n        int size = in.readVInt();\n        if (size != -1) {\n            matches = new Match[size];\n            for (int i = 0; i < size; i++) {\n                matches[i] = new Match();\n                matches[i].readFrom(in);\n            }\n        }\n        facets = InternalFacets.readOptionalFacets(in);\n        aggregations = InternalAggregations.readOptionalAggregations(in);\n    }","commit_id":"f38296da61ed21544ad45609c52d950adf913dca","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public InternalFacets getFacets() {\n        return facets;\n    }","id":47999,"modified_method":"/**\n     * @return Any facet that has been executed on the query metadata. This can return <code>null<\/code>.\n     */\n    public InternalFacets getFacets() {\n        return facets;\n    }","commit_id":"f38296da61ed21544ad45609c52d950adf913dca","url":"https://github.com/elastic/elasticsearch"}]