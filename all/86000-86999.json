[{"original_method":"/**\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return\n   * @throws AmbariException\n   * @throws InterruptedException\n   */\n  @Override\n  public CommandReport execute(ConcurrentMap<String, Object> requestSharedDataContext) throws AmbariException, InterruptedException {\n    String dataDirectoryPath = getCommandParameterValue(DATA_DIRECTORY);\n\n    // Set the ServiceComponentHost from a transitional state to the desired endpoint state\n    Map<String, Host> hosts = getClusters().getHostsForCluster(getClusterName());\n    if ((hosts != null) && !hosts.isEmpty()) {\n      Cluster cluster = getCluster();\n      for (String hostname : hosts.keySet()) {\n        List<ServiceComponentHost> serviceComponentHosts = cluster.getServiceComponentHosts(hostname);\n\n        for (ServiceComponentHost sch : serviceComponentHosts) {\n          SecurityState securityState = sch.getSecurityState();\n          if (securityState.isTransitional()) {\n            sch.setSecurityState(sch.getDesiredSecurityState());\n          }\n        }\n      }\n    }\n\n    // Make sure this is a relevant directory. We don't want to accidentally allow _ANY_ directory\n    // to be deleted.\n    if ((dataDirectoryPath != null) && dataDirectoryPath.contains(\"/\" + DATA_DIRECTORY_PREFIX)) {\n      File dataDirectory = new File(dataDirectoryPath);\n      File dataDirectoryParent = dataDirectory.getParentFile();\n\n      // Make sure this directory has a parent and it is writeable, else we wont be able to\n      // delete the directory\n      if ((dataDirectoryParent != null) && dataDirectory.isDirectory() &&\n          dataDirectoryParent.isDirectory() && dataDirectoryParent.canWrite()) {\n        try {\n          FileUtils.deleteDirectory(dataDirectory);\n        } catch (IOException e) {\n          // We should log this exception, but don't let it fail the process since if we got to this\n          // KerberosServerAction it is expected that the the overall process was a success.\n          LOG.warn(String.format(\"The data directory (%s) was not deleted due to an error condition - {%s}\",\n              dataDirectory.getAbsolutePath(), e.getMessage()), e);\n        }\n      }\n    }\n\n    return createCommandReport(0, HostRoleStatus.COMPLETED, \"{}\", null, null);\n  }","id":86000,"modified_method":"/**\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return\n   * @throws AmbariException\n   * @throws InterruptedException\n   */\n  @Override\n  public CommandReport execute(ConcurrentMap<String, Object> requestSharedDataContext) throws AmbariException, InterruptedException {\n    String dataDirectoryPath = getCommandParameterValue(DATA_DIRECTORY);\n\n    // Set the ServiceComponentHost from a transitional state to the desired endpoint state\n    Map<String, Host> hosts = getClusters().getHostsForCluster(getClusterName());\n    if ((hosts != null) && !hosts.isEmpty()) {\n      Cluster cluster = getCluster();\n      for (String hostname : hosts.keySet()) {\n        List<ServiceComponentHost> serviceComponentHosts = cluster.getServiceComponentHosts(hostname);\n\n        for (ServiceComponentHost sch : serviceComponentHosts) {\n          SecurityState securityState = sch.getSecurityState();\n          if (securityState.isTransitional()) {\n            String message = String.format(\"Setting securityState for %s/%s on host %s to state %s\",\n                sch.getServiceName(), sch.getServiceComponentName(), sch.getHostName(),\n                sch.getDesiredSecurityState().toString());\n            LOG.info(message);\n            actionLog.writeStdOut(message);\n\n            sch.setSecurityState(sch.getDesiredSecurityState());\n          }\n        }\n      }\n    }\n\n    // Make sure this is a relevant directory. We don't want to accidentally allow _ANY_ directory\n    // to be deleted.\n    if ((dataDirectoryPath != null) && dataDirectoryPath.contains(\"/\" + DATA_DIRECTORY_PREFIX)) {\n      File dataDirectory = new File(dataDirectoryPath);\n      File dataDirectoryParent = dataDirectory.getParentFile();\n\n      // Make sure this directory has a parent and it is writeable, else we wont be able to\n      // delete the directory\n      if ((dataDirectoryParent != null) && dataDirectory.isDirectory() &&\n          dataDirectoryParent.isDirectory() && dataDirectoryParent.canWrite()) {\n        try {\n          FileUtils.deleteDirectory(dataDirectory);\n        } catch (IOException e) {\n          // We should log this exception, but don't let it fail the process since if we got to this\n          // KerberosServerAction it is expected that the the overall process was a success.\n          String message = String.format(\"The data directory (%s) was not deleted due to an error condition - {%s}\",\n              dataDirectory.getAbsolutePath(), e.getMessage());\n          LOG.warn(message, e);\n        }\n      }\n    }\n\n    return createCommandReport(0, HostRoleStatus.COMPLETED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Process and prepares an identity record to be handled by the implementing class.\n   * <p/>\n   * Given the data from the record Map, attempts to replace variables in the principal pattern to\n   * generate a concrete principal value to further process. This \"evaluated principal\" is then passed to\n   * {@link #processIdentity(java.util.Map, String, KerberosOperationHandler, java.util.Map)}\n   * to be handled as needed.\n   *\n   * @param record                   a Map containing the data for the current identity record\n   * @param defaultRealm             a String declaring the default Kerberos realm\n   * @param operationHandler         a KerberosOperationHandler used to perform Kerberos-related\n   *                                 tasks for specific Kerberos implementations\n   *                                 (MIT, Active Directory, etc...)\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport, indicating an error condition; or null, indicating a success condition\n   * @throws AmbariException if an error occurs while processing the identity record\n   */\n  private CommandReport processRecord(Map<String, String> record, String defaultRealm,\n                                      KerberosOperationHandler operationHandler,\n                                      Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n\n    if (record != null) {\n      String principal = record.get(KerberosActionDataFile.PRINCIPAL);\n      String host = record.get(KerberosActionDataFile.HOSTNAME);\n\n      if (principal != null) {\n        // Evaluate the principal \"pattern\" found in the record to generate the \"evaluated p[rincipal\"\n        // by replacing the _HOST and _REALM variables.\n        String evaluatedPrincipal = principal.replace(\"_HOST\", host).replace(\"_REALM\", defaultRealm);\n        commandReport = processIdentity(record, evaluatedPrincipal, operationHandler, requestSharedDataContext);\n      }\n    }\n\n    return commandReport;\n  }","id":86001,"modified_method":"/**\n   * Process and prepares an identity record to be handled by the implementing class.\n   * <p/>\n   * Given the data from the record Map, attempts to replace variables in the principal pattern to\n   * generate a concrete principal value to further process. This \"evaluated principal\" is then passed to\n   * {@link #processIdentity(java.util.Map, String, KerberosOperationHandler, java.util.Map)}\n   * to be handled as needed.\n   *\n   * @param record                   a Map containing the data for the current identity record\n   * @param defaultRealm             a String declaring the default Kerberos realm\n   * @param operationHandler         a KerberosOperationHandler used to perform Kerberos-related\n   *                                 tasks for specific Kerberos implementations\n   *                                 (MIT, Active Directory, etc...)\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport, indicating an error condition; or null, indicating a success condition\n   * @throws AmbariException if an error occurs while processing the identity record\n   */\n  private CommandReport processRecord(Map<String, String> record, String defaultRealm,\n                                      KerberosOperationHandler operationHandler,\n                                      Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n\n    if (record != null) {\n      String principal = record.get(KerberosActionDataFile.PRINCIPAL);\n      String host = record.get(KerberosActionDataFile.HOSTNAME);\n\n      if (principal != null) {\n        // Evaluate the principal \"pattern\" found in the record to generate the \"evaluated principal\"\n        // by replacing the _HOST and _REALM variables.\n        String evaluatedPrincipal = principal.replace(\"_HOST\", host).replace(\"_REALM\", defaultRealm);\n\n        String message = String.format(\"Processing identity for %s\", evaluatedPrincipal);\n        actionLog.writeStdOut(message);\n        LOG.info(message);\n\n        commandReport = processIdentity(record, evaluatedPrincipal, operationHandler, requestSharedDataContext);\n      }\n    }\n\n    return commandReport;\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Iterates through the Kerberos identity metadata from the\n   * {@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFile} and calls the\n   * implementing class to handle each identity found.\n   * <p/>\n   * Using the \"data_directory\" value from this action's command parameters map, creates a\n   * {@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFileReader} to parse\n   * the relative index.dat file and iterate through its \"records\".  Each \"record\" is process using\n   * {@link #processRecord(java.util.Map, String, KerberosOperationHandler, java.util.Map)}.\n   *\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport indicating the result of this operation\n   * @throws AmbariException\n   */\n  protected CommandReport processIdentities(Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n    Map<String, String> commandParameters = getCommandParameters();\n\n    if (commandParameters != null) {\n      // Grab the relevant data from this action's command parameters map\n      KerberosCredential administratorCredential = getAdministratorCredential(commandParameters);\n      String defaultRealm = getDefaultRealm(commandParameters);\n      KDCType kdcType = getKDCType(commandParameters);\n      String dataDirectoryPath = getDataDirectoryPath(commandParameters);\n\n      if (dataDirectoryPath != null) {\n        File dataDirectory = new File(dataDirectoryPath);\n\n        // If the data directory exists, attempt to process further, else assume there is no work to do\n        if (dataDirectory.exists()) {\n          if (!dataDirectory.isDirectory() || !dataDirectory.canRead()) {\n            String message = String.format(\"Failed to process the identities, the data directory is not accessible: %s\",\n                dataDirectory.getAbsolutePath());\n            LOG.error(message);\n            throw new AmbariException(message);\n          }\n          // The \"index\" file may or may not exist in the data directory, depending on if there\n          // is work to do or not.\n          File indexFile = new File(dataDirectory, DATA_FILE_NAME);\n\n          if (indexFile.exists()) {\n            if (!indexFile.canRead()) {\n              String message = String.format(\"Failed to process the identities, cannot read the index file: %s\",\n                  indexFile.getAbsolutePath());\n              LOG.error(message);\n              throw new AmbariException(message);\n            }\n\n            KerberosOperationHandler handler = kerberosOperationHandlerFactory.getKerberosOperationHandler(kdcType);\n            if (handler == null) {\n              String message = String.format(\"Failed to process the identities, a KDC operation handler was not found for the KDC type of : %s\",\n                  kdcType.toString());\n              LOG.error(message);\n              throw new AmbariException(message);\n            }\n\n            try {\n              handler.open(administratorCredential, defaultRealm, getConfiguration(\"kerberos-env\"));\n            } catch (KerberosOperationException e) {\n              String message = String.format(\"Failed to process the identities, could not properly open the KDC operation handler: %s\",\n                  e.getMessage());\n              LOG.error(message);\n              throw new AmbariException(message, e);\n            }\n\n            // Create the data file reader to parse and iterate through the records\n            KerberosActionDataFileReader reader = null;\n            try {\n              reader = new KerberosActionDataFileReader(indexFile);\n              for (Map<String, String> record : reader) {\n                // Process the current record\n                commandReport = processRecord(record, defaultRealm, handler, requestSharedDataContext);\n\n                // If the principal processor returns a CommandReport, than it is time to stop since\n                // an error condition has probably occurred, else all is assumed to be well.\n                if (commandReport != null) {\n                  break;\n                }\n              }\n            } catch (AmbariException e) {\n              // Catch this separately from IOException since the reason it was thrown was not the same\n              // Note: AmbariException is an IOException, so there may be some confusion\n              throw new AmbariException(e.getMessage(), e);\n            } catch (IOException e) {\n              String message = String.format(\"Failed to process the identities, cannot read the index file: %s\",\n                  indexFile.getAbsolutePath());\n              LOG.error(message, e);\n              throw new AmbariException(message, e);\n            } finally {\n              if (reader != null) {\n                // The reader needs to be closed, if it fails to close ignore the exception since\n                // there is little we can or care to do about it now.\n                try {\n                  reader.close();\n                } catch (IOException e) {\n                  // Ignore this...\n                }\n              }\n\n              // The KerberosOperationHandler needs to be closed, if it fails to close ignore the\n              // exception since there is little we can or care to do about it now.\n              try {\n                handler.close();\n              } catch (KerberosOperationException e) {\n                // Ignore this...\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // If commandReport is null, we can assume this operation was a success, so return a successful\n    // CommandReport; else return the previously created CommandReport.\n    return (commandReport == null)\n        ? createCommandReport(0, HostRoleStatus.COMPLETED, \"{}\", null, null)\n        : commandReport;\n  }","id":86002,"modified_method":"/**\n   * Iterates through the Kerberos identity metadata from the\n   * {@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFile} and calls the\n   * implementing class to handle each identity found.\n   * <p/>\n   * Using the \"data_directory\" value from this action's command parameters map, creates a\n   * {@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFileReader} to parse\n   * the relative index.dat file and iterate through its \"records\".  Each \"record\" is process using\n   * {@link #processRecord(java.util.Map, String, KerberosOperationHandler, java.util.Map)}.\n   *\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport indicating the result of this operation\n   * @throws AmbariException\n   */\n  protected CommandReport processIdentities(Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n    Map<String, String> commandParameters = getCommandParameters();\n\n    actionLog.writeStdOut(\"Processing identities...\");\n    LOG.info(\"Processing identities...\");\n\n    if (commandParameters != null) {\n      // Grab the relevant data from this action's command parameters map\n      KerberosCredential administratorCredential = getAdministratorCredential(commandParameters);\n      String defaultRealm = getDefaultRealm(commandParameters);\n      KDCType kdcType = getKDCType(commandParameters);\n      String dataDirectoryPath = getDataDirectoryPath(commandParameters);\n\n      if (dataDirectoryPath != null) {\n        File dataDirectory = new File(dataDirectoryPath);\n\n        // If the data directory exists, attempt to process further, else assume there is no work to do\n        if (dataDirectory.exists()) {\n          if (!dataDirectory.isDirectory() || !dataDirectory.canRead()) {\n            String message = String.format(\"Failed to process the identities, the data directory is not accessible: %s\",\n                dataDirectory.getAbsolutePath());\n            actionLog.writeStdErr(message);\n            LOG.error(message);\n            throw new AmbariException(message);\n          }\n          // The \"index\" file may or may not exist in the data directory, depending on if there\n          // is work to do or not.\n          File indexFile = new File(dataDirectory, DATA_FILE_NAME);\n\n          if (indexFile.exists()) {\n            if (!indexFile.canRead()) {\n              String message = String.format(\"Failed to process the identities, cannot read the index file: %s\",\n                  indexFile.getAbsolutePath());\n              actionLog.writeStdErr(message);\n              LOG.error(message);\n              throw new AmbariException(message);\n            }\n\n            KerberosOperationHandler handler = kerberosOperationHandlerFactory.getKerberosOperationHandler(kdcType);\n            if (handler == null) {\n              String message = String.format(\"Failed to process the identities, a KDC operation handler was not found for the KDC type of : %s\",\n                  kdcType.toString());\n              actionLog.writeStdErr(message);\n              LOG.error(message);\n              throw new AmbariException(message);\n            }\n\n            try {\n              handler.open(administratorCredential, defaultRealm, getConfiguration(\"kerberos-env\"));\n            } catch (KerberosOperationException e) {\n              String message = String.format(\"Failed to process the identities, could not properly open the KDC operation handler: %s\",\n                  e.getMessage());\n              actionLog.writeStdErr(message);\n              LOG.error(message);\n              throw new AmbariException(message, e);\n            }\n\n            // Create the data file reader to parse and iterate through the records\n            KerberosActionDataFileReader reader = null;\n            try {\n              reader = new KerberosActionDataFileReader(indexFile);\n              for (Map<String, String> record : reader) {\n                // Process the current record\n                commandReport = processRecord(record, defaultRealm, handler, requestSharedDataContext);\n\n                // If the principal processor returns a CommandReport, than it is time to stop since\n                // an error condition has probably occurred, else all is assumed to be well.\n                if (commandReport != null) {\n                  break;\n                }\n              }\n            } catch (AmbariException e) {\n              // Catch this separately from IOException since the reason it was thrown was not the same\n              // Note: AmbariException is an IOException, so there may be some confusion\n              throw new AmbariException(e.getMessage(), e);\n            } catch (IOException e) {\n              String message = String.format(\"Failed to process the identities, cannot read the index file: %s\",\n                  indexFile.getAbsolutePath());\n              actionLog.writeStdErr(message);\n              LOG.error(message, e);\n              throw new AmbariException(message, e);\n            } finally {\n              if (reader != null) {\n                // The reader needs to be closed, if it fails to close ignore the exception since\n                // there is little we can or care to do about it now.\n                try {\n                  reader.close();\n                } catch (IOException e) {\n                  // Ignore this...\n                }\n              }\n\n              // The KerberosOperationHandler needs to be closed, if it fails to close ignore the\n              // exception since there is little we can or care to do about it now.\n              try {\n                handler.close();\n              } catch (KerberosOperationException e) {\n                // Ignore this...\n              }\n            }\n          }\n        }\n      }\n    }\n\n    actionLog.writeStdOut(\"Processing identities completed.\");\n    LOG.info(\"Processing identities completed.\");\n\n    // If commandReport is null, we can assume this operation was a success, so return a successful\n    // CommandReport; else return the previously created CommandReport.\n    return (commandReport == null)\n        ? createCommandReport(0, HostRoleStatus.COMPLETED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr())\n        : commandReport;\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Retrieves the current key number assigned to the identity identified by the specified principal\n   *\n   * @param principal a String declaring the principal to look up\n   * @return an Integer declaring the current key number\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  private Integer getKeyNumber(String principal) throws KerberosOperationException {\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to get key number for principal  - no principal specified\");\n    } else {\n      // Create the kdamin query:  get_principal <principal>\n      String query = String.format(\"get_principal %s\", principal);\n\n      ShellCommandUtil.Result result;\n      try {\n        result = invokeKAdmin(query);\n      } catch (KerberosOperationException e) {\n        LOG.error(String.format(\"Failed to get key number for %s\", principal), e);\n        throw e;\n      }\n\n      String stdOut = result.getStdout();\n      if (stdOut == null) {\n        String message = String.format(\"Failed to get key number for %s:\\n\\tExitCode: %s\\n\\tSTDOUT: NULL\\n\\tSTDERR: %s\",\n            principal, result.getExitCode(), result.getStderr());\n        LOG.warn(message);\n        throw new KerberosOperationException(message);\n      }\n\n      Matcher matcher = PATTERN_GET_KEY_NUMBER.matcher(stdOut);\n      if (matcher.matches()) {\n        NumberFormat numberFormat = NumberFormat.getIntegerInstance();\n        String keyNumber = matcher.group(1);\n\n        numberFormat.setGroupingUsed(false);\n        try {\n          Number number = numberFormat.parse(keyNumber);\n          return (number == null) ? 0 : number.intValue();\n        } catch (ParseException e) {\n          String message = String.format(\"Failed to get key number for %s - invalid key number value (%s):\\n\\tExitCode: %s\\n\\tSTDOUT: NULL\\n\\tSTDERR: %s\",\n              principal, keyNumber, result.getExitCode(), result.getStderr());\n          LOG.warn(message);\n          throw new KerberosOperationException(message);\n        }\n      } else {\n        String message = String.format(\"Failed to get key number for %s - unexpected STDOUT data:\\n\\tExitCode: %s\\n\\tSTDOUT: NULL\\n\\tSTDERR: %s\",\n            principal, result.getExitCode(), result.getStderr());\n        LOG.warn(message);\n        throw new KerberosOperationException(message);\n      }\n    }\n  }","id":86003,"modified_method":"/**\n   * Retrieves the current key number assigned to the identity identified by the specified principal\n   *\n   * @param principal a String declaring the principal to look up\n   * @return an Integer declaring the current key number\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  private Integer getKeyNumber(String principal) throws KerberosOperationException {\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to get key number for principal  - no principal specified\");\n    } else {\n      // Create the kdamin query:  get_principal <principal>\n      ShellCommandUtil.Result result = invokeKAdmin(String.format(\"get_principal %s\", principal));\n\n      String stdOut = result.getStdout();\n      if (stdOut == null) {\n        String message = String.format(\"Failed to get key number for %s:\\n\\tExitCode: %s\\n\\tSTDOUT: NULL\\n\\tSTDERR: %s\",\n            principal, result.getExitCode(), result.getStderr());\n        LOG.warn(message);\n        throw new KerberosOperationException(message);\n      }\n\n      Matcher matcher = PATTERN_GET_KEY_NUMBER.matcher(stdOut);\n      if (matcher.matches()) {\n        NumberFormat numberFormat = NumberFormat.getIntegerInstance();\n        String keyNumber = matcher.group(1);\n\n        numberFormat.setGroupingUsed(false);\n        try {\n          Number number = numberFormat.parse(keyNumber);\n          return (number == null) ? 0 : number.intValue();\n        } catch (ParseException e) {\n          String message = String.format(\"Failed to get key number for %s - invalid key number value (%s):\\n\\tExitCode: %s\\n\\tSTDOUT: NULL\\n\\tSTDERR: %s\",\n              principal, keyNumber, result.getExitCode(), result.getStderr());\n          LOG.warn(message);\n          throw new KerberosOperationException(message);\n        }\n      } else {\n        String message = String.format(\"Failed to get key number for %s - unexpected STDOUT data:\\n\\tExitCode: %s\\n\\tSTDOUT: NULL\\n\\tSTDERR: %s\",\n            principal, result.getExitCode(), result.getStderr());\n        LOG.warn(message);\n        throw new KerberosOperationException(message);\n      }\n    }\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Updates the password for an existing principal in a previously configured MIT KDC\n   * <p/>\n   * This implementation creates a query to send to the kadmin shell command and then interrogates\n   * the exit code to determine if the operation executed successfully.\n   *\n   * @param principal a String containing the principal to update\n   * @param password  a String containing the password to set\n   * @return an Integer declaring the new key number\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public Integer setPrincipalPassword(String principal, String password) throws KerberosOperationException {\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to set password - no principal specified\");\n    } else if ((password == null) || password.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to set password - no password specified\");\n    } else {\n      // Create the kdamin query:  change_password <-randkey|-pw <password>> <principal>\n      try {\n        invokeKAdmin(String.format(\"change_password -pw %s %s\", password, principal));\n      } catch (KerberosOperationException e) {\n        LOG.error(String.format(\"Failed to set password for %s\", principal), e);\n        throw e;\n      }\n\n      return getKeyNumber(principal);\n    }\n  }","id":86004,"modified_method":"/**\n   * Updates the password for an existing principal in a previously configured MIT KDC\n   * <p/>\n   * This implementation creates a query to send to the kadmin shell command and then interrogates\n   * the exit code to determine if the operation executed successfully.\n   *\n   * @param principal a String containing the principal to update\n   * @param password  a String containing the password to set\n   * @return an Integer declaring the new key number\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public Integer setPrincipalPassword(String principal, String password) throws KerberosOperationException {\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to set password - no principal specified\");\n    } else if ((password == null) || password.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to set password - no password specified\");\n    } else {\n      // Create the kdamin query:  change_password <-randkey|-pw <password>> <principal>\n      invokeKAdmin(String.format(\"change_password -pw %s %s\", password, principal));\n\n      return getKeyNumber(principal);\n    }\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Removes an existing principal in a previously configured KDC\n   * <p/>\n   * The implementation is specific to a particular type of KDC.\n   *\n   * @param principal a String containing the principal to remove\n   * @return true if the principal was successfully removed; otherwise false\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public boolean removePrincipal(String principal) throws KerberosOperationException {\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to remove new principal - no principal specified\");\n    } else {\n      ShellCommandUtil.Result result;\n\n      try {\n        result = invokeKAdmin(String.format(\"delete_principal -force %s\", principal));\n      } catch (KerberosOperationException e) {\n        LOG.error(String.format(\"Failed to remove new principal for %s\", principal), e);\n        throw e;\n      }\n\n      // If there is data from STDOUT, see if the following string exists:\n      //    Principal \"<principal>\" created\n      String stdOut = result.getStdout();\n      return (stdOut != null) && !stdOut.contains(\"Principal does not exist\");\n    }\n  }","id":86005,"modified_method":"/**\n   * Removes an existing principal in a previously configured KDC\n   * <p/>\n   * The implementation is specific to a particular type of KDC.\n   *\n   * @param principal a String containing the principal to remove\n   * @return true if the principal was successfully removed; otherwise false\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public boolean removePrincipal(String principal) throws KerberosOperationException {\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to remove new principal - no principal specified\");\n    } else {\n      ShellCommandUtil.Result result = invokeKAdmin(String.format(\"delete_principal -force %s\", principal));\n\n      // If there is data from STDOUT, see if the following string exists:\n      //    Principal \"<principal>\" created\n      String stdOut = result.getStdout();\n      return (stdOut != null) && !stdOut.contains(\"Principal does not exist\");\n    }\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Invokes the kadmin shell command to issue queries\n   *\n   * @param query a String containing the query to send to the kdamin command\n   * @return a ShellCommandUtil.Result containing the result of the operation\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  private ShellCommandUtil.Result invokeKAdmin(String query)\n      throws KerberosOperationException {\n    ShellCommandUtil.Result result = null;\n\n    if ((query == null) || query.isEmpty()) {\n      throw new KerberosOperationException(\"Missing kadmin query\");\n    }\n    KerberosCredential administratorCredentials = getAdministratorCredentials();\n    String defaultRealm = getDefaultRealm();\n\n    List<String> command = new ArrayList<String>();\n    File tempKeytabFile = null;\n\n    try {\n      String adminPrincipal = (administratorCredentials == null)\n          ? null\n          : administratorCredentials.getPrincipal();\n\n      if ((adminPrincipal == null) || adminPrincipal.isEmpty()) {\n        // Set the kdamin interface to be kadmin.local\n        command.add(\"kadmin.local\");\n      } else {\n        String adminPassword = administratorCredentials.getPassword();\n        String adminKeyTab = administratorCredentials.getKeytab();\n\n        // Set the kdamin interface to be kadmin\n        command.add(\"kadmin\");\n\n        // Add the administrative principal\n        command.add(\"-p\");\n        command.add(adminPrincipal);\n\n        if ((adminKeyTab != null) && !adminKeyTab.isEmpty()) {\n          tempKeytabFile = createKeytabFile(adminKeyTab);\n\n          if (tempKeytabFile != null) {\n            // Add keytab file administrative principal\n            command.add(\"-k\");\n            command.add(\"-t\");\n            command.add(tempKeytabFile.getAbsolutePath());\n          }\n        } else if (adminPassword != null) {\n          // Add password for administrative principal\n          command.add(\"-w\");\n          command.add(adminPassword);\n        }\n      }\n\n      if ((defaultRealm != null) && !defaultRealm.isEmpty()) {\n        // Add default realm clause\n        command.add(\"-r\");\n        command.add(defaultRealm);\n      }\n\n      // Add kadmin query\n      command.add(\"-q\");\n      command.add(query.replace(\"\\\"\", \"\\\\\\\"\"));\n\n      result = executeCommand(command.toArray(new String[command.size()]));\n\n      if (!result.isSuccessful()) {\n        // Build command string, replacing administrator password with \"********\"\n        StringBuilder cleanCommand = new StringBuilder();\n        Iterator<String> iterator = command.iterator();\n\n        if(iterator.hasNext())\n          cleanCommand.append(iterator.next());\n\n        while(iterator.hasNext()){\n          String part = iterator.next();\n\n          cleanCommand.append(' ');\n\n          if(part.contains(\" \")) {\n            cleanCommand.append('\"');\n            cleanCommand.append(part);\n            cleanCommand.append('\"');\n          }\n          else {\n            cleanCommand.append(part);\n          }\n\n          if(\"-w\".equals(part)) {\n            // Skip the password and use \"********\" instead\n            if(iterator.hasNext())\n              iterator.next();\n            cleanCommand.append(\" ********\");\n          }\n        }\n        String message = String.format(\"Failed to execute kadmin:\\n\\tCommand: %s\\n\\tExitCode: %s\\n\\tSTDOUT: %s\\n\\tSTDERR: %s\",\n            cleanCommand.toString(), result.getExitCode(), result.getStdout(), result.getStderr());\n        LOG.warn(message);\n\n        // Test STDERR to see of any \"expected\" error conditions were encountered...\n        String stdErr = result.getStderr();\n        // Did admin credentials fail?\n        if (stdErr.contains(\"Client not found in Kerberos database\")) {\n          throw new KerberosAdminAuthenticationException(stdErr);\n        } else if (stdErr.contains(\"Incorrect password while initializing\")) {\n          throw new KerberosAdminAuthenticationException(stdErr);\n        }\n        // Did we fail to connect to the KDC?\n        else if (stdErr.contains(\"Cannot contact any KDC\")) {\n          throw new KerberosKDCConnectionException(stdErr);\n        }\n        // Was the realm invalid?\n        else if (stdErr.contains(\"Missing parameters in krb5.conf required for kadmin client\")) {\n          throw new KerberosRealmException(stdErr);\n        } else {\n          throw new KerberosOperationException(\"Unexpected error condition executing the kadmin command\");\n        }\n      }\n    } finally {\n      // If a temporary keytab file was created, clean it up.\n      if (tempKeytabFile != null) {\n        if (!tempKeytabFile.delete()) {\n          tempKeytabFile.deleteOnExit();\n        }\n      }\n    }\n\n    return result;\n  }","id":86006,"modified_method":"/**\n   * Invokes the kadmin shell command to issue queries\n   *\n   * @param query a String containing the query to send to the kdamin command\n   * @return a ShellCommandUtil.Result containing the result of the operation\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  private ShellCommandUtil.Result invokeKAdmin(String query)\n      throws KerberosOperationException {\n    ShellCommandUtil.Result result = null;\n\n    if ((query == null) || query.isEmpty()) {\n      throw new KerberosOperationException(\"Missing kadmin query\");\n    }\n    KerberosCredential administratorCredentials = getAdministratorCredentials();\n    String defaultRealm = getDefaultRealm();\n\n    List<String> command = new ArrayList<String>();\n    File tempKeytabFile = null;\n\n    try {\n      String adminPrincipal = (administratorCredentials == null)\n          ? null\n          : administratorCredentials.getPrincipal();\n\n      if ((adminPrincipal == null) || adminPrincipal.isEmpty()) {\n        // Set the kdamin interface to be kadmin.local\n        command.add(\"kadmin.local\");\n      } else {\n        String adminPassword = administratorCredentials.getPassword();\n        String adminKeyTab = administratorCredentials.getKeytab();\n\n        // Set the kdamin interface to be kadmin\n        command.add(\"kadmin\");\n\n        // Add the administrative principal\n        command.add(\"-p\");\n        command.add(adminPrincipal);\n\n        if ((adminKeyTab != null) && !adminKeyTab.isEmpty()) {\n          tempKeytabFile = createKeytabFile(adminKeyTab);\n\n          if (tempKeytabFile != null) {\n            // Add keytab file administrative principal\n            command.add(\"-k\");\n            command.add(\"-t\");\n            command.add(tempKeytabFile.getAbsolutePath());\n          }\n        } else if (adminPassword != null) {\n          // Add password for administrative principal\n          command.add(\"-w\");\n          command.add(adminPassword);\n        }\n      }\n\n      if ((defaultRealm != null) && !defaultRealm.isEmpty()) {\n        // Add default realm clause\n        command.add(\"-r\");\n        command.add(defaultRealm);\n      }\n\n      // Add kadmin query\n      command.add(\"-q\");\n      command.add(query.replace(\"\\\"\", \"\\\\\\\"\"));\n\n      result = executeCommand(command.toArray(new String[command.size()]));\n\n      if (!result.isSuccessful()) {\n        // Build command string, replacing administrator password with \"********\"\n        StringBuilder cleanCommand = new StringBuilder();\n        Iterator<String> iterator = command.iterator();\n\n        if(iterator.hasNext())\n          cleanCommand.append(iterator.next());\n\n        while(iterator.hasNext()){\n          String part = iterator.next();\n\n          cleanCommand.append(' ');\n\n          if(part.contains(\" \")) {\n            cleanCommand.append('\"');\n            cleanCommand.append(part);\n            cleanCommand.append('\"');\n          }\n          else {\n            cleanCommand.append(part);\n          }\n\n          if(\"-w\".equals(part)) {\n            // Skip the password and use \"********\" instead\n            if(iterator.hasNext())\n              iterator.next();\n            cleanCommand.append(\" ********\");\n          }\n        }\n        String message = String.format(\"Failed to execute kadmin:\\n\\tCommand: %s\\n\\tExitCode: %s\\n\\tSTDOUT: %s\\n\\tSTDERR: %s\",\n            cleanCommand.toString(), result.getExitCode(), result.getStdout(), result.getStderr());\n        LOG.warn(message);\n\n        // Test STDERR to see of any \"expected\" error conditions were encountered...\n        String stdErr = result.getStderr();\n        // Did admin credentials fail?\n        if (stdErr.contains(\"Client not found in Kerberos database\")) {\n          throw new KerberosAdminAuthenticationException(stdErr);\n        } else if (stdErr.contains(\"Incorrect password while initializing\")) {\n          throw new KerberosAdminAuthenticationException(stdErr);\n        }\n        // Did we fail to connect to the KDC?\n        else if (stdErr.contains(\"Cannot contact any KDC\")) {\n          throw new KerberosKDCConnectionException(stdErr);\n        }\n        else if (stdErr.contains(\"Cannot resolve network address for admin server in requested realm while initializing kadmin interface\")) {\n          throw new KerberosKDCConnectionException(stdErr);\n        }\n        // Was the realm invalid?\n        else if (stdErr.contains(\"Missing parameters in krb5.conf required for kadmin client\")) {\n          throw new KerberosRealmException(stdErr);\n        } else {\n          throw new KerberosOperationException(\"Unexpected error condition executing the kadmin command\");\n        }\n      }\n    } finally {\n      // If a temporary keytab file was created, clean it up.\n      if (tempKeytabFile != null) {\n        if (!tempKeytabFile.delete()) {\n          tempKeytabFile.deleteOnExit();\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Creates a new principal in a previously configured MIT KDC\n   * <p/>\n   * This implementation creates a query to send to the kadmin shell command and then interrogates\n   * the result from STDOUT to determine if the operation executed successfully.\n   *\n   * @param principal a String containing the principal add\n   * @param password  a String containing the password to use when creating the principal\n   * @param service a boolean value indicating whether the principal is to be created as a service principal or not\n   * @return an Integer declaring the generated key number\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public Integer createPrincipal(String principal, String password, boolean service)\n      throws KerberosOperationException {\n\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to create new principal - no principal specified\");\n    } else if ((password == null) || password.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to create new principal - no password specified\");\n    } else {\n      // Create the kdamin query:  add_principal <-randkey|-pw <password>> <principal>\n      ShellCommandUtil.Result result;\n      try {\n        result = invokeKAdmin(String.format(\"add_principal -pw %s %s\", password, principal));\n      } catch (KerberosOperationException e) {\n        LOG.error(String.format(\"Failed to create new principal for %s\", principal), e);\n        throw e;\n      }\n\n      // If there is data from STDOUT, see if the following string exists:\n      //    Principal \"<principal>\" created\n      String stdOut = result.getStdout();\n      if ((stdOut != null) && stdOut.contains(String.format(\"Principal \\\"%s\\\" created\", principal))) {\n        return getKeyNumber(principal);\n      } else {\n        throw new KerberosOperationException(String.format(\"Failed to create service principal for %s\", principal));\n      }\n    }\n  }","id":86007,"modified_method":"/**\n   * Creates a new principal in a previously configured MIT KDC\n   * <p/>\n   * This implementation creates a query to send to the kadmin shell command and then interrogates\n   * the result from STDOUT to determine if the operation executed successfully.\n   *\n   * @param principal a String containing the principal add\n   * @param password  a String containing the password to use when creating the principal\n   * @param service a boolean value indicating whether the principal is to be created as a service principal or not\n   * @return an Integer declaring the generated key number\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public Integer createPrincipal(String principal, String password, boolean service)\n      throws KerberosOperationException {\n\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if ((principal == null) || principal.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to create new principal - no principal specified\");\n    } else if ((password == null) || password.isEmpty()) {\n      throw new KerberosOperationException(\"Failed to create new principal - no password specified\");\n    } else {\n      // Create the kdamin query:  add_principal <-randkey|-pw <password>> <principal>\n      ShellCommandUtil.Result result = invokeKAdmin(String.format(\"add_principal -pw %s %s\", password, principal));\n\n      // If there is data from STDOUT, see if the following string exists:\n      //    Principal \"<principal>\" created\n      String stdOut = result.getStdout();\n      if ((stdOut != null) && stdOut.contains(String.format(\"Principal \\\"%s\\\" created\", principal))) {\n        return getKeyNumber(principal);\n      } else {\n        throw new KerberosOperationException(String.format(\"Failed to create service principal for %s\", principal));\n      }\n    }\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Test to see if the specified principal exists in a previously configured MIT KDC\n   * <p/>\n   * This implementation creates a query to send to the kadmin shell command and then interrogates\n   * the result from STDOUT to determine if the presence of the specified principal.\n   *\n   * @param principal a String containing the principal to test\n   * @return true if the principal exists; false otherwise\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public boolean principalExists(String principal)\n      throws KerberosOperationException {\n\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if (principal == null) {\n      return false;\n    } else {\n      // Create the KAdmin query to execute:\n      String query = String.format(\"get_principal %s\", principal);\n\n      ShellCommandUtil.Result result;\n      try {\n        result = invokeKAdmin(query);\n      } catch (KerberosOperationException e) {\n        LOG.error(String.format(\"Failed to query for principal %s\", principal), e);\n        throw e;\n      }\n\n      // If there is data from STDOUT, see if the following string exists:\n      //    Principal: <principal>\n      String stdOut = result.getStdout();\n      return (stdOut != null) && stdOut.contains(String.format(\"Principal: %s\", principal));\n    }\n  }","id":86008,"modified_method":"/**\n   * Test to see if the specified principal exists in a previously configured MIT KDC\n   * <p/>\n   * This implementation creates a query to send to the kadmin shell command and then interrogates\n   * the result from STDOUT to determine if the presence of the specified principal.\n   *\n   * @param principal a String containing the principal to test\n   * @return true if the principal exists; false otherwise\n   * @throws KerberosKDCConnectionException       if a connection to the KDC cannot be made\n   * @throws KerberosAdminAuthenticationException if the administrator credentials fail to authenticate\n   * @throws KerberosRealmException               if the realm does not map to a KDC\n   * @throws KerberosOperationException           if an unexpected error occurred\n   */\n  @Override\n  public boolean principalExists(String principal)\n      throws KerberosOperationException {\n\n    if (!isOpen()) {\n      throw new KerberosOperationException(\"This operation handler has not been opened\");\n    }\n\n    if (principal == null) {\n      return false;\n    } else {\n      // Create the KAdmin query to execute:\n      ShellCommandUtil.Result result = invokeKAdmin(String.format(\"get_principal %s\", principal));\n\n      // If there is data from STDOUT, see if the following string exists:\n      //    Principal: <principal>\n      String stdOut = result.getStdout();\n      return (stdOut != null) && stdOut.contains(String.format(\"Principal: %s\", principal));\n    }\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   *\n   * Updates service config properties of a cluster\n   * @param cluster   the cluster for which to update service configs\n   * @param configType   service config type to be updated\n   * @param properties    map of service config properties\n   * @param updateIfExists    flag indicating whether to update if a property already exists\n   * @param createNewConfigType  flag indicating whether to create new service config\n   *                             if the config type does not exist\n   * @param note   a short note on change\n   * @throws AmbariException if the operation fails\n   */\n  private void updateConfigurationPropertiesForCluster(\n    Cluster cluster,\n    String configType,\n    Map<String, String> properties,\n    boolean updateIfExists,\n    boolean createNewConfigType,\n    String note)\n    throws AmbariException {\n\n    String newTag = \"version\" + System.currentTimeMillis();\n\n    if ((properties != null) && (properties.size() > 0)) {\n      Map<String, Config> all = cluster.getConfigsByType(configType);\n      if (all == null || !all.containsKey(newTag)) {\n        Map<String, String> oldConfigProperties;\n        Config oldConfig = cluster.getDesiredConfigByType(configType);\n\n        if (oldConfig == null && !createNewConfigType) {\n          LOG.info(\"Config \" + configType + \" not found. Assuming service not installed. \" +\n            \"Skipping configuration properties update\");\n          return;\n        } else if (oldConfig == null) {\n          oldConfigProperties = new HashMap<String, String>();\n          newTag = \"version1\";\n        } else {\n          oldConfigProperties = oldConfig.getProperties();\n        }\n\n        Map<String, String> mergedProperties =\n          mergeProperties(oldConfigProperties, properties, updateIfExists);\n\n        if (!Maps.difference(oldConfigProperties, mergedProperties).areEqual()) {\n          LOG.info(\"Applying configuration with tag '{}' to \" +\n            \"cluster '{}'\", newTag, cluster.getClusterName());\n\n          ConfigurationRequest cr = new ConfigurationRequest();\n          cr.setClusterName(cluster.getClusterName());\n          cr.setVersionTag(newTag);\n          cr.setType(configType);\n          cr.setProperties(mergedProperties);\n          cr.setServiceConfigVersionNote(note);\n          controller.createConfiguration(cr);\n\n          Config baseConfig = cluster.getConfig(cr.getType(), cr.getVersionTag());\n          if (baseConfig != null) {\n            String authName = \"kerberization\";\n\n            if (cluster.addDesiredConfig(authName, Collections.singleton(baseConfig)) != null) {\n              String oldConfigString = (oldConfig != null) ? \" from='\" + oldConfig.getTag() + \"'\" : \"\";\n              LOG.info(\"cluster '\" + cluster.getClusterName() + \"' \"\n                + \"changed by: '\" + authName + \"'; \"\n                + \"type='\" + baseConfig.getType() + \"' \"\n                + \"tag='\" + baseConfig.getTag() + \"'\"\n                + oldConfigString);\n            }\n          }\n        } else {\n          LOG.info(\"No changes detected to config \" + configType + \". Skipping configuration properties update\");\n        }\n      }\n    }\n  }","id":86009,"modified_method":"/**\n   *\n   * Updates service config properties of a cluster\n   * @param cluster   the cluster for which to update service configs\n   * @param configType   service config type to be updated\n   * @param properties    map of service config properties\n   * @param updateIfExists    flag indicating whether to update if a property already exists\n   * @param createNewConfigType  flag indicating whether to create new service config\n   *                             if the config type does not exist\n   * @param note   a short note on change\n   * @throws AmbariException if the operation fails\n   */\n  private void updateConfigurationPropertiesForCluster(\n    Cluster cluster,\n    String configType,\n    Map<String, String> properties,\n    boolean updateIfExists,\n    boolean createNewConfigType,\n    String note)\n    throws AmbariException {\n\n    String newTag = \"version\" + System.currentTimeMillis();\n    String message;\n    if ((properties != null) && (properties.size() > 0)) {\n      Map<String, Config> all = cluster.getConfigsByType(configType);\n      if (all == null || !all.containsKey(newTag)) {\n        Map<String, String> oldConfigProperties;\n        Config oldConfig = cluster.getDesiredConfigByType(configType);\n\n        if (oldConfig == null && !createNewConfigType) {\n          message = String.format(\"Config %s not found. Assuming service not installed. \" +\n              \"Skipping configuration properties update\", configType);\n          actionLog.writeStdOut(message);\n          LOG.info(message);\n          return;\n        } else if (oldConfig == null) {\n          oldConfigProperties = new HashMap<String, String>();\n          newTag = \"version1\";\n        } else {\n          oldConfigProperties = oldConfig.getProperties();\n        }\n\n        Map<String, String> mergedProperties =\n          mergeProperties(oldConfigProperties, properties, updateIfExists);\n\n        if (!Maps.difference(oldConfigProperties, mergedProperties).areEqual()) {\n          message = String.format(\"Applying configuration with tag '%s' to \" +\n              \"cluster '%s'\", newTag, cluster.getClusterName());\n          actionLog.writeStdOut(message);\n          LOG.info(message);\n\n          ConfigurationRequest cr = new ConfigurationRequest();\n          cr.setClusterName(cluster.getClusterName());\n          cr.setVersionTag(newTag);\n          cr.setType(configType);\n          cr.setProperties(mergedProperties);\n          cr.setServiceConfigVersionNote(note);\n          controller.createConfiguration(cr);\n\n          Config baseConfig = cluster.getConfig(cr.getType(), cr.getVersionTag());\n          if (baseConfig != null) {\n            String authName = \"kerberization\";\n\n            if (cluster.addDesiredConfig(authName, Collections.singleton(baseConfig)) != null) {\n              String oldConfigString = (oldConfig != null) ? \" from='\" + oldConfig.getTag() + \"'\" : \"\";\n              message = \"cluster '\" + cluster.getClusterName() + \"' \"\n                  + \"changed by: '\" + authName + \"'; \"\n                  + \"type='\" + baseConfig.getType() + \"' \"\n                  + \"tag='\" + baseConfig.getTag() + \"'\"\n                  + oldConfigString;\n              LOG.info(message);\n              actionLog.writeStdOut(message);\n            }\n          }\n        } else {\n          message = \"No changes detected to config \" + configType + \". Skipping configuration properties update\";\n          LOG.info(message);\n          actionLog.writeStdOut(message);\n        }\n      }\n    }\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Executes this ServerAction\n   * <p/>\n   * This is typically called by the ServerActionExecutor in it's own thread, but there is no\n   * guarantee that this is the case.  It is expected that the ExecutionCommand and HostRoleCommand\n   * properties are set before calling this method.\n   *\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport declaring the status of the task\n   * @throws org.apache.ambari.server.AmbariException\n   *\n   * @throws InterruptedException\n   */\n  @Override\n  public CommandReport execute(ConcurrentMap<String, Object> requestSharedDataContext)\n    throws AmbariException, InterruptedException {\n\n    CommandReport commandReport = null;\n\n    String clusterName = getExecutionCommand().getClusterName();\n    Clusters clusters = controller.getClusters();\n    Cluster cluster = clusters.getCluster(clusterName);\n\n    String dataDirectoryPath = getCommandParameterValue(getCommandParameters(), KerberosServerAction.DATA_DIRECTORY);\n\n    // If the data directory path is set, attempt to process further, else assume there is no work to do\n    if (dataDirectoryPath != null) {\n      File dataDirectory = new File(dataDirectoryPath);\n\n      // If the data directory exists, attempt to process further, else assume there is no work to do\n      if (dataDirectory.exists()) {\n        KerberosActionDataFileReader indexReader = null;\n        KerberosConfigDataFileReader configReader = null;\n\n        try {\n          // If the action data file exists, iterate over the records to find the identity-specific\n          // configuration settings to update\n          File indexFile = new File(dataDirectory, KerberosActionDataFile.DATA_FILE_NAME);\n          if (indexFile.exists()) {\n            indexReader = new KerberosActionDataFileReader(indexFile);\n\n            for (Map<String, String> record : indexReader) {\n              String principal = record.get(KerberosActionDataFile.PRINCIPAL);\n              String principalConfig = record.get(KerberosActionDataFile.PRINCIPAL_CONFIGURATION);\n              String[] principalTokens = principalConfig.split(\"/\");\n              if (principalTokens.length == 2) {\n                String principalConfigType = principalTokens[0];\n                String principalConfigProp = principalTokens[1];\n                addConfigTypePropVal(principalConfigType, principalConfigProp, principal);\n              }\n\n              String keytabPath = record.get(KerberosActionDataFile.KEYTAB_FILE_PATH);\n              String keytabConfig = record.get(KerberosActionDataFile.KEYTAB_FILE_CONFIGURATION);\n              String[] keytabTokens = keytabConfig.split(\"/\");\n              if (keytabTokens.length == 2) {\n                String keytabConfigType = keytabTokens[0];\n                String keytabConfigProp = keytabTokens[1];\n                addConfigTypePropVal(keytabConfigType, keytabConfigProp, keytabPath);\n              }\n            }\n          }\n\n          // If the config data file exists, iterate over the records to find the (explicit)\n          // configuration settings to update\n          File configFile = new File(dataDirectory, KerberosConfigDataFile.DATA_FILE_NAME);\n          if (configFile.exists()) {\n            configReader = new KerberosConfigDataFileReader(configFile);\n            for (Map<String, String> record : configReader) {\n              String configType = record.get(KerberosConfigDataFile.CONFIGURATION_TYPE);\n              String configKey = record.get(KerberosConfigDataFile.KEY);\n              String configVal = record.get(KerberosConfigDataFile.VALUE);\n              addConfigTypePropVal(configType, configKey, configVal);\n            }\n          }\n\n          for (Map.Entry<String, Map<String, String>> entry : configurations.entrySet()) {\n            updateConfigurationPropertiesForCluster(\n                cluster,\n                entry.getKey(),     // configType\n                entry.getValue(),   // properties\n                true,               // updateIfExists\n                true,               // createNew\n                \"update services configs to enable kerberos\");\n          }\n        } catch (IOException e) {\n          String message = \"Could not update services configs to enable kerberos\";\n          LOG.error(message, e);\n          commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n        } finally {\n          if (indexReader != null && !indexReader.isClosed()) {\n            try {\n              indexReader.close();\n            } catch (Throwable t) {\n              // ignored\n            }\n          }\n          if (configReader != null && !configReader.isClosed()) {\n            try {\n              configReader.close();\n            } catch (Throwable t) {\n              // ignored\n            }\n          }\n        }\n      }\n    }\n\n    return (commandReport == null)\n        ? createCommandReport(0, HostRoleStatus.COMPLETED, \"{}\", null, null)\n        : commandReport;\n  }","id":86010,"modified_method":"/**\n   * Executes this ServerAction\n   * <p/>\n   * This is typically called by the ServerActionExecutor in it's own thread, but there is no\n   * guarantee that this is the case.  It is expected that the ExecutionCommand and HostRoleCommand\n   * properties are set before calling this method.\n   *\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport declaring the status of the task\n   * @throws org.apache.ambari.server.AmbariException\n   *\n   * @throws InterruptedException\n   */\n  @Override\n  public CommandReport execute(ConcurrentMap<String, Object> requestSharedDataContext)\n    throws AmbariException, InterruptedException {\n\n    CommandReport commandReport = null;\n\n    String clusterName = getExecutionCommand().getClusterName();\n    Clusters clusters = controller.getClusters();\n    Cluster cluster = clusters.getCluster(clusterName);\n\n    String dataDirectoryPath = getCommandParameterValue(getCommandParameters(), KerberosServerAction.DATA_DIRECTORY);\n\n    // If the data directory path is set, attempt to process further, else assume there is no work to do\n    if (dataDirectoryPath != null) {\n      File dataDirectory = new File(dataDirectoryPath);\n\n      // If the data directory exists, attempt to process further, else assume there is no work to do\n      if (dataDirectory.exists()) {\n        KerberosActionDataFileReader indexReader = null;\n        KerberosConfigDataFileReader configReader = null;\n\n        try {\n          // If the action data file exists, iterate over the records to find the identity-specific\n          // configuration settings to update\n          File indexFile = new File(dataDirectory, KerberosActionDataFile.DATA_FILE_NAME);\n          if (indexFile.exists()) {\n            indexReader = new KerberosActionDataFileReader(indexFile);\n\n            for (Map<String, String> record : indexReader) {\n              String principal = record.get(KerberosActionDataFile.PRINCIPAL);\n              String principalConfig = record.get(KerberosActionDataFile.PRINCIPAL_CONFIGURATION);\n              String[] principalTokens = principalConfig.split(\"/\");\n              if (principalTokens.length == 2) {\n                String principalConfigType = principalTokens[0];\n                String principalConfigProp = principalTokens[1];\n                addConfigTypePropVal(principalConfigType, principalConfigProp, principal);\n              }\n\n              String keytabPath = record.get(KerberosActionDataFile.KEYTAB_FILE_PATH);\n              String keytabConfig = record.get(KerberosActionDataFile.KEYTAB_FILE_CONFIGURATION);\n              String[] keytabTokens = keytabConfig.split(\"/\");\n              if (keytabTokens.length == 2) {\n                String keytabConfigType = keytabTokens[0];\n                String keytabConfigProp = keytabTokens[1];\n                addConfigTypePropVal(keytabConfigType, keytabConfigProp, keytabPath);\n              }\n            }\n          }\n\n          // If the config data file exists, iterate over the records to find the (explicit)\n          // configuration settings to update\n          File configFile = new File(dataDirectory, KerberosConfigDataFile.DATA_FILE_NAME);\n          if (configFile.exists()) {\n            configReader = new KerberosConfigDataFileReader(configFile);\n            for (Map<String, String> record : configReader) {\n              String configType = record.get(KerberosConfigDataFile.CONFIGURATION_TYPE);\n              String configKey = record.get(KerberosConfigDataFile.KEY);\n              String configVal = record.get(KerberosConfigDataFile.VALUE);\n              addConfigTypePropVal(configType, configKey, configVal);\n            }\n          }\n\n          for (Map.Entry<String, Map<String, String>> entry : configurations.entrySet()) {\n            updateConfigurationPropertiesForCluster(\n                cluster,\n                entry.getKey(),     // configType\n                entry.getValue(),   // properties\n                true,               // updateIfExists\n                true,               // createNew\n                \"update services configs to enable kerberos\");\n          }\n        } catch (IOException e) {\n          String message = \"Could not update services configs to enable kerberos\";\n          actionLog.writeStdErr(message);\n          LOG.error(message, e);\n          commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(),\n              actionLog.getStdErr());\n        } finally {\n          if (indexReader != null && !indexReader.isClosed()) {\n            try {\n              indexReader.close();\n            } catch (Throwable t) {\n              // ignored\n            }\n          }\n          if (configReader != null && !configReader.isClosed()) {\n            try {\n              configReader.close();\n            } catch (Throwable t) {\n              // ignored\n            }\n          }\n        }\n      }\n    }\n\n    return (commandReport == null)\n        ? createCommandReport(0, HostRoleStatus.COMPLETED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr())\n        : commandReport;\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"protected String readWadl() {\n        String wadlURL = (String)context.get(ToolConstants.CFG_WSDLURL);\n        wadlURL = URIParserUtil.getAbsoluteURI(wadlURL);\n        \n        try {\n            URL url = new URL(wadlURL);\n            return IOUtils.toString(url.openStream());\n        } catch (IOException e) {\n            throw new ToolException(e);\n        }\n    }","id":86011,"modified_method":"protected String readWadl() {\n        String wadlURL = (String)context.get(WadlToolConstants.CFG_WADLURL);\n        wadlURL = URIParserUtil.getAbsoluteURI(wadlURL);\n        \n        try {\n            URL url = new URL(wadlURL);\n            return IOUtils.toString(url.openStream());\n        } catch (IOException e) {\n            throw new ToolException(e);\n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void processWadl() {\n        File outDir = new File((String)context.get(ToolConstants.CFG_OUTPUTDIR));\n        String wadl = readWadl();\n\n        SourceGenerator sg = new SourceGenerator();  \n        \n        // generate\n        sg.generateSource(wadl, outDir, \"proxy\");\n        \n        // compile \n        if (context.optionSet(ToolConstants.CFG_COMPILE)) {\n            new ClassUtils().compile(context);\n        }\n\n    }","id":86012,"modified_method":"private void processWadl() {\n        File outDir = new File((String)context.get(WadlToolConstants.CFG_OUTPUTDIR));\n        String wadl = readWadl();\n\n        SourceGenerator sg = new SourceGenerator();\n        boolean isInterface = context.optionSet(WadlToolConstants.CFG_INTERFACE);\n        boolean isServer = context.optionSet(WadlToolConstants.CFG_SERVER);\n        if (isServer) {\n            sg.setGenerateInterfaces(isInterface);\n            sg.setGenerateImplementation(true);\n        }\n        \n        // generate\n        String codeType = context.optionSet(WadlToolConstants.CFG_TYPES)\n            ? SourceGenerator.CODE_TYPE_GRAMMAR : SourceGenerator.CODE_TYPE_PROXY;\n        sg.generateSource(wadl, outDir, codeType);\n        \n        // compile \n        if (context.optionSet(WadlToolConstants.CFG_COMPILE)) {\n            new ClassUtils().compile(context);\n        }\n\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"public void buildToolContext() {\n        getContext();\n        if (context.get(ToolConstants.CFG_OUTPUTDIR) == null) {\n            context.put(ToolConstants.CFG_OUTPUTDIR, \".\");\n        }\n    }","id":86013,"modified_method":"public void buildToolContext() {\n        getContext();\n        if (context.get(WadlToolConstants.CFG_OUTPUTDIR) == null) {\n            context.put(WadlToolConstants.CFG_OUTPUTDIR, \".\");\n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void verifyFiles(String ext) {\n        List<File> files = FileUtils.getFilesRecurse(output, \".+\\\\.\" + ext + \"$\");\n        assertEquals(7, files.size());\n        assertTrue(checkContains(files, \"superbooks.Book.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.Book2.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.Chapter.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.ObjectFactory.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.package-info.\" + ext));\n        assertTrue(checkContains(files, \"org.apache.cxf.jaxrs.model.wadl.FormInterface.\" + ext));\n        assertTrue(checkContains(files, \"org.apache.cxf.jaxrs.model.wadl.BookStore.\" + ext));\n    }","id":86014,"modified_method":"private void verifyFiles(String ext, boolean interfacesAndImpl) {\n        List<File> files = FileUtils.getFilesRecurse(output, \".+\\\\.\" + ext + \"$\");\n        assertEquals(interfacesAndImpl ? 9 : 7, files.size());\n        assertTrue(checkContains(files, \"superbooks.Book.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.Book2.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.Chapter.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.ObjectFactory.\" + ext));\n        assertTrue(checkContains(files, \"superbooks.package-info.\" + ext));\n        assertTrue(checkContains(files, \"org.apache.cxf.jaxrs.model.wadl.FormInterface.\" + ext));\n        assertTrue(checkContains(files, \"org.apache.cxf.jaxrs.model.wadl.BookStore.\" + ext));\n        if (interfacesAndImpl) {\n            assertTrue(checkContains(files, \"org.apache.cxf.jaxrs.model.wadl.FormInterfaceImpl.\" + ext));\n            assertTrue(checkContains(files, \"org.apache.cxf.jaxrs.model.wadl.BookStoreImpl.\" + ext));\n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"@Test    \n    public void testCodeGen() {\n        try {\n            JAXRSContainer container = new JAXRSContainer(null);\n            ToolContext context = new ToolContext();\n\n            context.put(ToolConstants.CFG_OUTPUTDIR, output.getCanonicalPath());\n\n            context.put(ToolConstants.CFG_WSDLURL, getLocation(\"/wadl/bookstore.xml\"));\n\n\n            container.setContext(context);\n            container.execute();\n\n            assertNotNull(output.list());\n            \n            verifyFiles(\"java\");\n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":86015,"modified_method":"@Test    \n    public void testCodeGenImpl() {\n        try {\n            JAXRSContainer container = new JAXRSContainer(null);\n            ToolContext context = new ToolContext();\n\n            context.put(WadlToolConstants.CFG_OUTPUTDIR, output.getCanonicalPath());\n\n            context.put(WadlToolConstants.CFG_WADLURL, getLocation(\"/wadl/bookstore.xml\"));\n            context.put(WadlToolConstants.CFG_SERVER, \"true\");\n            //context.put(WadlToolConstants.CFG_COMPILE, \"true\");\n            \n            container.setContext(context);\n            container.execute();\n\n            assertNotNull(output.list());\n            \n            verifyFiles(\"java\", false);\n            //verifyFiles(\"classes\");\n        } catch (Exception e) {\n            fail();\n            e.printStackTrace();\n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void writeResourceMethod(Element resourceEl, Element methodEl, \n                                     Set<String> imports, StringBuilder sbCode, \n                                     Set<String> typeClassNames, GrammarInfo gInfo) {\n        String id = methodEl.getAttribute(\"id\");\n        String methodName = methodEl.getAttribute(\"name\");\n        String path = resourceEl.getAttribute(\"path\");\n        if (id.length() == 0) {\n            LOG.warning(\"Method with path \" + path + \" can not be mapped to a class method\");\n            return;\n        }\n        \n        sbCode.append(TAB);\n        writeAnnotation(sbCode, imports, Path.class, path, true, true);\n        if (methodName.length() > 0) {\n            if (HTTP_METHOD_ANNOTATIONS.containsKey(methodName.toLowerCase())) {\n                writeAnnotation(sbCode, imports, \n                                HTTP_METHOD_ANNOTATIONS.get(methodName.toLowerCase()), null, true, true);\n            } else {\n                // TODO : write a custom annotation class based on HttpMethod    \n            }\n        }\n        \n        List<Element> responseEls = DOMUtils.getChildrenWithName(methodEl, \n                                                                 WadlGenerator.WADL_NS, \"response\");\n        List<Element> requestEls = DOMUtils.getChildrenWithName(methodEl, \n                                                                WadlGenerator.WADL_NS, \"request\");\n        \n        if (methodName.length() > 0) {\n            writeFormatAnnotations(requestEls, sbCode, imports, true);\n            writeFormatAnnotations(responseEls, sbCode, imports, false);\n        }\n        if (!generateInterfaces) {\n            sbCode.append(\"public \");\n        }\n        boolean responseTypeAvailable = true;\n        if (methodName.length() > 0) {\n            responseTypeAvailable = writeResponseType(responseEls, sbCode, imports, typeClassNames, gInfo);\n            sbCode.append(id);\n        } else {\n            QName qname = JAXRSUtils.convertStringToQName(id);\n            String packageName = PackageUtils.getPackageNameByNameSpaceURI(qname.getNamespaceURI());\n            String clsSimpleName = getSchemaClassName(packageName, gInfo, qname.getLocalPart(), \n                                                      typeClassNames);\n            String localName = clsSimpleName == null ? qname.getLocalPart() \n                : clsSimpleName.substring(packageName.length() + 1);\n            String parentId = ((Element)resourceEl.getParentNode()).getAttribute(\"id\");\n            writeSubResponseType(id.equals(parentId), clsSimpleName == null ? qname.getNamespaceURI() \n                : clsSimpleName.substring(0, packageName.length()), localName, sbCode, imports);\n            // TODO : we need to take care of multiple subresource locators with diff @Path\n            // returning the same type; also we might have ids like \"{org.apache.cxf}Book#getName\" \n            sbCode.append(\"get\" + localName);\n        }\n        \n        sbCode.append(\"(\");\n        List<Element> inParamElements = new LinkedList<Element>();\n        inParamElements.addAll(DOMUtils.getChildrenWithName(resourceEl, \n                                                            WadlGenerator.WADL_NS, \"param\"));\n        boolean form = false;\n        if (requestEls.size() == 1 && inParamElements.size() == 0) {\n            inParamElements.addAll(DOMUtils.getChildrenWithName(requestEls.get(0), \n                 WadlGenerator.WADL_NS, \"param\"));\n            addFormParameters(inParamElements, requestEls.get(0));\n            form = true;\n        }\n        writeRequestTypes(requestEls, inParamElements, sbCode, imports, typeClassNames, gInfo,\n                          form);\n        sbCode.append(\")\");\n        if (generateInterfaces) {\n            sbCode.append(\";\");\n        } else {\n            generateEmptyMethodBody(sbCode, responseTypeAvailable);\n        }\n        sbCode.append(getLineSep()).append(getLineSep());\n    }","id":86016,"modified_method":"private void writeResourceMethod(Element resourceEl, Element methodEl, \n                                     Set<String> imports, StringBuilder sbCode, \n                                     Set<String> typeClassNames, GrammarInfo gInfo,\n                                     boolean interfaceIsGenerated) {\n        String id = methodEl.getAttribute(\"id\");\n        String methodName = methodEl.getAttribute(\"name\");\n        \n        List<Element> responseEls = DOMUtils.getChildrenWithName(methodEl, \n                                                                 WadlGenerator.WADL_NS, \"response\");\n        List<Element> requestEls = DOMUtils.getChildrenWithName(methodEl, \n                                                                WadlGenerator.WADL_NS, \"request\");\n        \n        \n        if (writeAnnotations(interfaceIsGenerated)) {\n            String path = resourceEl.getAttribute(\"path\");\n            if (id.length() == 0) {\n                LOG.warning(\"Method with path \" + path + \" can not be mapped to a class method\");\n                return;\n            }\n            sbCode.append(TAB);\n            writeAnnotation(sbCode, imports, Path.class, path, true, true);\n        \n            if (methodName.length() > 0) {\n                if (HTTP_METHOD_ANNOTATIONS.containsKey(methodName.toLowerCase())) {\n                    writeAnnotation(sbCode, imports, \n                                    HTTP_METHOD_ANNOTATIONS.get(methodName.toLowerCase()), null, true, true);\n                } else {\n                    // TODO : write a custom annotation class name based on HttpMethod    \n                }\n                \n                writeFormatAnnotations(requestEls, sbCode, imports, true);\n                writeFormatAnnotations(responseEls, sbCode, imports, false);\n            }\n        } else {\n            sbCode.append(getLineSep()).append(TAB);\n        }\n        \n        if (!interfaceIsGenerated) {\n            sbCode.append(\"public \");\n        }\n        boolean responseTypeAvailable = true;\n        if (methodName.length() > 0) {\n            responseTypeAvailable = writeResponseType(responseEls, sbCode, imports, typeClassNames, gInfo);\n            sbCode.append(id);\n        } else {\n            QName qname = JAXRSUtils.convertStringToQName(id);\n            String packageName = PackageUtils.getPackageNameByNameSpaceURI(qname.getNamespaceURI());\n            String clsSimpleName = getSchemaClassName(packageName, gInfo, qname.getLocalPart(), \n                                                      typeClassNames);\n            String localName = clsSimpleName == null ? qname.getLocalPart() \n                : clsSimpleName.substring(packageName.length() + 1);\n            String parentId = ((Element)resourceEl.getParentNode()).getAttribute(\"id\");\n            writeSubResponseType(id.equals(parentId), clsSimpleName == null ? qname.getNamespaceURI() \n                : clsSimpleName.substring(0, packageName.length()), localName, sbCode, imports);\n            // TODO : we need to take care of multiple subresource locators with diff @Path\n            // returning the same type; also we might have ids like \"{org.apache.cxf}Book#getName\" \n            sbCode.append(\"get\" + localName);\n        }\n        \n        sbCode.append(\"(\");\n        List<Element> inParamElements = new LinkedList<Element>();\n        inParamElements.addAll(DOMUtils.getChildrenWithName(resourceEl, \n                                                            WadlGenerator.WADL_NS, \"param\"));\n        writeRequestTypes(requestEls, inParamElements, sbCode, imports, typeClassNames, gInfo,\n                          interfaceIsGenerated);\n        sbCode.append(\")\");\n        if (interfaceIsGenerated) {\n            sbCode.append(\";\");\n        } else {\n            generateEmptyMethodBody(sbCode, responseTypeAvailable);\n        }\n        sbCode.append(getLineSep()).append(getLineSep());\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void writeMethods(Element rElement,  \n                              Set<String> imports, StringBuilder sbCode, \n                              Set<String> typeClassNames, GrammarInfo gInfo) {\n        List<Element> methodEls = DOMUtils.getChildrenWithName(rElement, \n            WadlGenerator.WADL_NS, \"method\");\n       \n        for (Element methodEl : methodEls) {\n            writeResourceMethod(rElement, methodEl, imports, sbCode, typeClassNames, gInfo);    \n        }\n    }","id":86017,"modified_method":"private void writeMethods(Element rElement,  \n                              Set<String> imports, StringBuilder sbCode, \n                              Set<String> typeClassNames, GrammarInfo gInfo,\n                              boolean interfaceIsGenerated) {\n        List<Element> methodEls = DOMUtils.getChildrenWithName(rElement, \n            WadlGenerator.WADL_NS, \"method\");\n       \n        for (Element methodEl : methodEls) {\n            writeResourceMethod(rElement, methodEl, imports, sbCode, typeClassNames, gInfo, \n                                interfaceIsGenerated);    \n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private String getClassType() {\n        return generateInterfaces ? \"interface\" : \"class\";\n    }","id":86018,"modified_method":"private String getClassType(boolean interfaceIsGenerated) {\n        return interfaceIsGenerated ? \"interface\" : \"class\";\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void writeResourceClass(Element rElement, Set<String> typeClassNames, \n                                    GrammarInfo gInfo, File src) {\n        String resourceId = rElement.getAttribute(\"id\");\n        String path = rElement.getAttribute(\"path\");\n        if (resourceId.length() == 0) {\n            LOG.warning(\"Resource with path \" + path + \" can not be mapped to a class\");\n            return;\n        }\n        \n        \n        QName qname = JAXRSUtils.convertStringToQName(resourceId);\n        if (getSchemaClassName(PackageUtils.getPackageNameByNameSpaceURI(qname.getNamespaceURI()), \n                               gInfo, qname.getLocalPart(), typeClassNames) != null) {\n            return; \n        }\n        \n        StringBuilder sbImports = new StringBuilder();\n        StringBuilder sbCode = new StringBuilder();\n        Set<String> imports = createImports();\n        \n        sbImports.append(getClassComment()).append(getLineSep());\n        sbImports.append(\"package \" + qname.getNamespaceURI())\n            .append(\";\").append(getLineSep()).append(getLineSep());\n        \n        writeAnnotation(sbCode, imports, Path.class, path, true, false);\n        sbCode.append(\"public \" + getClassType() + \" \" + qname.getLocalPart() \n                                       + \" {\" + getLineSep() + getLineSep());\n        \n        writeMethods(rElement, imports, sbCode, typeClassNames, gInfo);\n        \n        List<Element> childEls = DOMUtils.getChildrenWithName(rElement, \n            WadlGenerator.WADL_NS, \"resource\");\n        for (Element childEl : childEls) {\n            if (childEl.getAttribute(\"id\").length() == 0) {\n                writeMethods(childEl, imports, sbCode, typeClassNames, gInfo);\n            } else {\n                writeResourceMethod(childEl, childEl, imports, sbCode, typeClassNames, gInfo);\n            }\n        }\n        sbCode.append(\"}\");\n        writeImports(sbImports, imports);\n        \n        createJavaSourceFile(src, qname, sbCode, sbImports);\n        \n        for (Element subEl : childEls) {\n            String id = subEl.getAttribute(\"id\");\n            if (id.length() > 0 && !resourceId.equals(id) && !id.startsWith(\"{java\")) {\n                writeResourceClass(subEl, typeClassNames, gInfo, src);\n            }\n        }\n    }","id":86019,"modified_method":"private void writeResourceClass(Element rElement, Set<String> typeClassNames, \n                                    GrammarInfo gInfo, File src, boolean interfaceIsGenerated) {\n        String resourceId = rElement.getAttribute(\"id\");\n        String path = rElement.getAttribute(\"path\");\n        if (resourceId.length() == 0) {\n            LOG.warning(\"Resource with path \" + path + \" can not be mapped to a class\");\n            return;\n        }\n        \n        \n        QName qname = JAXRSUtils.convertStringToQName(resourceId);\n        if (getSchemaClassName(PackageUtils.getPackageNameByNameSpaceURI(qname.getNamespaceURI()), \n                               gInfo, qname.getLocalPart(), typeClassNames) != null) {\n            return; \n        }\n        \n        StringBuilder sbImports = new StringBuilder();\n        StringBuilder sbCode = new StringBuilder();\n        Set<String> imports = createImports();\n        \n        sbImports.append(getClassComment()).append(getLineSep());\n        sbImports.append(\"package \" + qname.getNamespaceURI())\n            .append(\";\").append(getLineSep()).append(getLineSep());\n        \n        if (writeAnnotations(interfaceIsGenerated)) {\n            writeAnnotation(sbCode, imports, Path.class, path, true, false);\n        }\n        String className = getClassName(qname.getLocalPart(), interfaceIsGenerated);\n        sbCode.append(\"public \" + getClassType(interfaceIsGenerated) + \" \" + className);\n        writeImplementsInterface(sbCode, qname.getLocalPart(), interfaceIsGenerated);              \n        sbCode.append(\" {\" + getLineSep() + getLineSep());\n        \n        writeMethods(rElement, imports, sbCode, typeClassNames, gInfo, interfaceIsGenerated);\n        \n        List<Element> childEls = DOMUtils.getChildrenWithName(rElement, \n            WadlGenerator.WADL_NS, \"resource\");\n        for (Element childEl : childEls) {\n            if (childEl.getAttribute(\"id\").length() == 0) {\n                writeMethods(childEl, imports, sbCode, typeClassNames, gInfo, interfaceIsGenerated);\n            } else {\n                writeResourceMethod(childEl, childEl, imports, sbCode, typeClassNames, gInfo, \n                                    interfaceIsGenerated);\n            }\n        }\n        sbCode.append(\"}\");\n        writeImports(sbImports, imports);\n        \n        createJavaSourceFile(src, new QName(qname.getNamespaceURI(), className), sbCode, sbImports);\n        \n        for (Element subEl : childEls) {\n            String id = subEl.getAttribute(\"id\");\n            if (id.length() > 0 && !resourceId.equals(id) && !id.startsWith(\"{java\")) {\n                writeResourceClass(subEl, typeClassNames, gInfo, src, interfaceIsGenerated);\n            }\n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void writeRequestTypes(List<Element> requestEls,\n                                   List<Element> inParamEls, \n                                   StringBuilder sbCode, \n                                   Set<String> imports, \n                                   Set<String> typeClassNames, \n                                   GrammarInfo gInfo,\n                                   boolean form) {\n        \n        String elementName = null;\n        \n        List<Element> repElements = requestEls.size() == 1 \n            ? DOMUtils.getChildrenWithName(requestEls.get(0), WadlGenerator.WADL_NS, \"representation\")\n            : CastUtils.cast(Collections.emptyList(), Element.class);\n        if (repElements.size() > 0) {    \n            elementName = getElementRefName(repElements, typeClassNames, gInfo, imports);\n        }\n        if (elementName != null) {\n            sbCode.append(elementName).append(\" \").append(elementName.toLowerCase());\n            if (inParamEls.size() > 0) {\n                sbCode.append(\", \");\n            }\n        } else if (inParamEls.size() == 0) {\n            if (form) {\n                addImport(imports, MultivaluedMap.class.getName());\n                sbCode.append(\"MultivaluedMap map\");\n            }\n            return;\n        }\n        for (int i = 0; i < inParamEls.size(); i++) {\n            Element paramEl = inParamEls.get(i);\n\n            String name = paramEl.getAttribute(\"name\");\n            Class<?> paramAnnotation = form ? FormParam.class \n                : PARAM_ANNOTATIONS.get(paramEl.getAttribute(\"style\"));\n            writeAnnotation(sbCode, imports, paramAnnotation, name, false, false);\n            String type = getPrimitiveType(paramEl);\n            if (Boolean.valueOf(paramEl.getAttribute(\"repeating\"))) {\n                addImport(imports, List.class.getName());\n                type = \"List<\" + type + \">\";\n            }\n            sbCode.append(\" \").append(type).append(\" \").append(name.replace('.', '_'));\n            if (i + 1 < inParamEls.size()) {\n                sbCode.append(\", \");\n                if (i + 1 >= 4 && ((i + 1) % 4) == 0) {\n                    sbCode.append(getLineSep()).append(TAB).append(TAB).append(TAB).append(TAB);\n                }\n            }\n        }\n    }","id":86020,"modified_method":"private void writeRequestTypes(List<Element> requestEls,\n                                   List<Element> inParamEls, \n                                   StringBuilder sbCode, \n                                   Set<String> imports, \n                                   Set<String> typeClassNames, \n                                   GrammarInfo gInfo,\n                                   boolean interfaceIsGenerated) {\n        boolean form = false;\n        if (requestEls.size() == 1 && inParamEls.size() == 0) {\n            inParamEls.addAll(DOMUtils.getChildrenWithName(requestEls.get(0), \n                 WadlGenerator.WADL_NS, \"param\"));\n            addFormParameters(inParamEls, requestEls.get(0));\n            form = true;\n        }\n        \n        String elementName = null;\n        \n        List<Element> repElements = requestEls.size() == 1 \n            ? DOMUtils.getChildrenWithName(requestEls.get(0), WadlGenerator.WADL_NS, \"representation\")\n            : CastUtils.cast(Collections.emptyList(), Element.class);\n        if (repElements.size() > 0) {    \n            elementName = getElementRefName(repElements, typeClassNames, gInfo, imports);\n        }\n        if (elementName != null) {\n            sbCode.append(elementName).append(\" \").append(elementName.toLowerCase());\n            if (inParamEls.size() > 0) {\n                sbCode.append(\", \");\n            }\n        } else if (inParamEls.size() == 0) {\n            if (form) {\n                addImport(imports, MultivaluedMap.class.getName());\n                sbCode.append(\"MultivaluedMap map\");\n            }\n            return;\n        }\n        for (int i = 0; i < inParamEls.size(); i++) {\n            Element paramEl = inParamEls.get(i);\n\n            String name = paramEl.getAttribute(\"name\");\n            if (writeAnnotations(interfaceIsGenerated)) {\n                Class<?> paramAnnotation = form ? FormParam.class \n                    : PARAM_ANNOTATIONS.get(paramEl.getAttribute(\"style\"));\n                writeAnnotation(sbCode, imports, paramAnnotation, name, false, false);\n                sbCode.append(\" \");\n            }\n            String type = getPrimitiveType(paramEl);\n            if (Boolean.valueOf(paramEl.getAttribute(\"repeating\"))) {\n                addImport(imports, List.class.getName());\n                type = \"List<\" + type + \">\";\n            }\n            sbCode.append(type).append(\" \").append(name.replace('.', '_'));\n            if (i + 1 < inParamEls.size()) {\n                sbCode.append(\", \");\n                if (i + 1 >= 4 && ((i + 1) % 4) == 0) {\n                    sbCode.append(getLineSep()).append(TAB).append(TAB).append(TAB).append(TAB);\n                }\n            }\n        }\n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private void generateResourceClasses(Element appElement, List<Element> schemaElements, \n                                         Set<String> typeClassNames, File src) {\n        List<Element> resourcesEls = DOMUtils.getChildrenWithName(appElement, \n            WadlGenerator.WADL_NS, \"resources\");\n        if (resourcesEls.size() != 1) {\n            throw new IllegalStateException(\"WADL resources element is missing\");\n        }\n        \n        List<Element> resourceEls = DOMUtils.getChildrenWithName(resourcesEls.get(0), \n            WadlGenerator.WADL_NS, \"resource\");\n        if (resourceEls.size() == 0) {\n            throw new IllegalStateException(\"WADL has no resource elements\");\n        }\n        \n        GrammarInfo gInfo = getGrammarInfo(appElement, schemaElements);\n        for (Element resource : resourceEls) {\n            writeResourceClass(resource, typeClassNames, gInfo, src);\n        }\n        \n        generateMainClass(resourcesEls.get(0), src);\n        \n    }","id":86021,"modified_method":"private void generateResourceClasses(Element appElement, List<Element> schemaElements, \n                                         Set<String> typeClassNames, File src) {\n        List<Element> resourcesEls = DOMUtils.getChildrenWithName(appElement, \n            WadlGenerator.WADL_NS, \"resources\");\n        if (resourcesEls.size() != 1) {\n            throw new IllegalStateException(\"WADL resources element is missing\");\n        }\n        \n        List<Element> resourceEls = DOMUtils.getChildrenWithName(resourcesEls.get(0), \n            WadlGenerator.WADL_NS, \"resource\");\n        if (resourceEls.size() == 0) {\n            throw new IllegalStateException(\"WADL has no resource elements\");\n        }\n        \n        GrammarInfo gInfo = getGrammarInfo(appElement, schemaElements);\n        for (Element resource : resourceEls) {\n            writeResourceClass(resource, typeClassNames, gInfo, src, generateInterfaces);\n            if (generateInterfaces && generateImpl) {\n                writeResourceClass(resource, typeClassNames, gInfo, src, false);\n            }\n        }\n        \n        generateMainClass(resourcesEls.get(0), src);\n        \n    }","commit_id":"993de5fd909fa247908feba587cd53a9a5b626dc","url":"https://github.com/apache/cxf"},{"original_method":"private static boolean validTestDependency(MavenCoordinate coordinate) {\n\n        Pattern log4j = Pattern.compile(\"^log4j$\");\n        Pattern slf4jLog4j = Pattern.compile(\"^slf4j-log4j12$\");\n\n        boolean valid = !log4j.matcher(coordinate.getArtifactId()).matches() && !slf4jLog4j.matcher(coordinate.getArtifactId()).matches();\n\n        if (!valid) {\n            debug(\"Discarded test dependency \" + coordinate.toCanonicalForm());\n        }\n\n        return valid;\n    }","id":86022,"modified_method":"private static boolean validTestDependency(MavenCoordinate coordinate) {\n\n        Pattern[] patterns = new Pattern[]{Pattern.compile(\"^log4j$\"), Pattern.compile(\"^slf4j-log4j12$\"), Pattern.compile(\"^slf4j-simple\")};\n\n        boolean valid = true;\n        for (Pattern p : patterns) {\n            if (p.matcher(coordinate.getArtifactId()).matches()) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) {\n            debug(\"Discarded test dependency \" + coordinate.toCanonicalForm());\n        }\n\n        return valid;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"private static ClassLoader getExtensionClassloader() {\n        ClassLoader cl = AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> Thread.currentThread().getContextClassLoader());\n        if (cl == null) {\n            cl = ClassLoader.getSystemClassLoader();\n        }\n\n        return cl;\n    }","id":86023,"modified_method":"private static ClassLoader getExtensionClassloader() {\n        ClassLoader cl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n            @Override\n            public ClassLoader run() {\n                return Thread.currentThread().getContextClassLoader();\n            }\n        });\n        if (cl == null) {\n            cl = ClassLoader.getSystemClassLoader();\n        }\n\n        return cl;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"private static JavaArchive addTestResources(JavaArchive ark, ITestConfig config) throws IOException {\n        File test = new File(config.getModulesPath() + config.getModuleName() + \"/target/test-classes/\");\n        File[] fs = Optional.ofNullable(test.listFiles()).orElse(new File[]{});\n        LinkedList<File> testFiles = new LinkedList<>(Arrays.asList(fs));\n        while (!testFiles.isEmpty()) {\n            File f = testFiles.pop();\n            String relative = test.getCanonicalFile().toURI().relativize(f.getCanonicalFile().toURI()).getPath();\n            if (f.isFile()) {\n                ark = ark.addAsResource(f, relative);\n            } else {\n                ark = ark.addAsDirectory(relative);\n                File[] files = Optional.ofNullable(f.listFiles()).orElse(new File[]{});\n                testFiles.addAll(Arrays.asList(files));\n            }\n        }\n\n        return ark;\n    }","id":86024,"modified_method":"private static JavaArchive addTestResources(JavaArchive ark, ITestConfig config) throws IOException {\n        File test = new File(config.getModulesPath() + config.getModuleName() + \"/target/test-classes/\");\n        File[] fs = test.listFiles();\n        if (fs == null) {\n            fs = new File[]{};\n        }\n        LinkedList<File> testFiles = new LinkedList<>(Arrays.asList(fs));\n        while (!testFiles.isEmpty()) {\n            File f = testFiles.pop();\n            String relative = test.getCanonicalFile().toURI().relativize(f.getCanonicalFile().toURI()).getPath();\n            if (f.isFile()) {\n                ark = ark.addAsResource(f, relative);\n            } else {\n                ark = ark.addAsDirectory(relative);\n                File[] files = f.listFiles();\n                if (files == null) {\n                    files = new File[]{};\n                }\n                testFiles.addAll(Arrays.asList(files));\n            }\n        }\n\n        return ark;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static void copyResource(String folder, String fileNameRegex, String targetFolder) throws IOException {\n\n        Pattern pattern = Pattern.compile(fileNameRegex);\n\n        File sourceFolder = new File(folder);\n        File[] candidates = sourceFolder.listFiles((dir, name) -> pattern.matcher(name).matches());\n        if (candidates.length == 0) {\n            Assert.fail(\"No file matching regex \" + fileNameRegex + \" has been found\");\n        }\n\n        File f = candidates[0];\n        FileUtils.copyFileToDirectory(f, new File(targetFolder));\n    }","id":86025,"modified_method":"public static void copyResource(String folder, String fileNameRegex, String targetFolder) throws IOException {\n\n        final Pattern pattern = Pattern.compile(fileNameRegex);\n\n        File sourceFolder = new File(folder);\n        File[] candidates = sourceFolder.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return pattern.matcher(name).matches();\n            }\n        });\n        if (candidates.length == 0) {\n            Assert.fail(\"No file matching regex \" + fileNameRegex + \" has been found\");\n        }\n\n        File f = candidates[0];\n        FileUtils.copyFileToDirectory(f, new File(targetFolder));\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static Archive<?> springBootPackage(ITestConfig config) throws Exception {\n\n        ExtensionLoader extensionLoader = new ServiceExtensionLoader(Collections.singleton(getExtensionClassloader()));\n        extensionLoader.addOverride(ZipExporter.class, SpringBootZipExporterImpl.class);\n        ConfigurationBuilder builder = new ConfigurationBuilder().extensionLoader(extensionLoader);\n        Configuration conf = builder.build();\n\n        Domain domain = ShrinkWrap.createDomain(conf);\n\n        JavaArchive ark = domain.getArchiveFactory().create(JavaArchive.class, \"test.jar\");\n\n        ark = ark.addAsManifestResource(\"BOOT-MANIFEST.MF\", \"MANIFEST.MF\");\n        ark = ark.addAsResource(\"spring-boot-itest.properties\");\n\n        ark = ark.addAsDirectories(\"/lib\");\n\n        String version = config.getMavenVersion();\n        if (version == null) {\n            // It is missing when launching from IDE\n            List<MavenResolvedArtifact> resolved = Arrays.asList(Maven.resolver().loadPomFromFile(\"pom.xml\").importRuntimeDependencies().resolve().withTransitivity().asResolvedArtifact());\n            Optional<MavenResolvedArtifact> camelDep = resolved.stream().filter(dep -> dep.getCoordinate().getGroupId().equals(\"org.apache.camel\")).findAny();\n            version = camelDep.map(art -> art.getCoordinate().getVersion()).orElse(null);\n            debug(\"Resolved version: \" + version);\n            if (version == null) {\n                throw new IllegalStateException(\"Cannot determine the current version of the camel component\");\n            }\n        }\n\n        // Test dependencies\n        List<MavenDependency> testDependencies = new LinkedList<>();\n        if (config.getIncludeTestDependencies() || config.getUnitTestEnabled()) {\n\n            List<MavenResolvedArtifact> testArtifacts = Arrays.asList(Maven.resolver()\n                    .loadPomFromFile(config.getModulesPath() + config.getModuleName() + \"/pom.xml\")\n                    .importTestDependencies()\n                    .resolve().withoutTransitivity().asResolvedArtifact());\n\n            MavenDependencyExclusion[] excl = new MavenDependencyExclusion[]{MavenDependencies.createExclusion(\"org.slf4j\", \"slf4j-log4j12\"), MavenDependencies.createExclusion(\"log4j\", \"log4j\")};\n\n            testDependencies = testArtifacts.stream()\n                    .map(MavenResolvedArtifact::getCoordinate)\n                    .filter(ArquillianPackager::validTestDependency) // remove direct logging dependencies from test libs\n                    .map(c -> MavenDependencies.createDependency(c, ScopeType.RUNTIME, false, excl)) // remove transitive logging dependencies from test libs\n                    .collect(Collectors.toList());\n        }\n\n\n        MavenCoordinate jar = MavenCoordinates.createCoordinate(config.getMavenGroup(), config.getModuleName(), version, PackagingType.JAR, null);\n        MavenDependency dep = MavenDependencies.createDependency(jar, ScopeType.COMPILE, false);\n\n        List<File> dependencies = new LinkedList<>();\n        dependencies.addAll(Arrays.asList(Maven.resolver()\n                .loadPomFromFile(\"pom.xml\")\n                .importRuntimeDependencies()\n                .addDependencies(dep)\n                .addDependencies(testDependencies)\n                .resolve()\n                .withTransitivity()\n                .asFile()));\n\n\n        // The spring boot-loader dependency will be added to the main jar, so it should be excluded from the embedded ones\n        excludeDependencyRegex(dependencies, \"^spring-boot-loader-[0-9].*\");\n\n        // Add all dependencies as spring-boot nested jars\n        ark = addDependencies(ark, dependencies);\n\n        if (config.getUnitTestEnabled()) {\n            // Add unit test classes of the module under test\n            ark = addTestResources(ark, config);\n        }\n\n        // Add common packages to main jar\n        ark = ark.addPackages(true, \"org.apache.camel.itest.springboot\");\n        ark = ark.addPackages(true, \"org.springframework.boot.loader\");\n        ark = ark.addPackages(true, \"org.jboss.shrinkwrap\");\n\n        return ClassPath.builder().add(ark).build();\n    }","id":86026,"modified_method":"public static Archive<?> springBootPackage(ITestConfig config) throws Exception {\n\n        ExtensionLoader extensionLoader = new ServiceExtensionLoader(Collections.singleton(getExtensionClassloader()));\n        extensionLoader.addOverride(ZipExporter.class, SpringBootZipExporterImpl.class);\n        ConfigurationBuilder builder = new ConfigurationBuilder().extensionLoader(extensionLoader);\n        Configuration conf = builder.build();\n\n        Domain domain = ShrinkWrap.createDomain(conf);\n\n        JavaArchive ark = domain.getArchiveFactory().create(JavaArchive.class, \"test.jar\");\n\n        ark = ark.addAsManifestResource(\"BOOT-MANIFEST.MF\", \"MANIFEST.MF\");\n        ark = ark.addAsResource(\"spring-boot-itest.properties\");\n\n        for (Map.Entry<String, String> res : config.getResources().entrySet()) {\n            ark = ark.addAsResource(res.getKey(), res.getValue());\n        }\n\n        ark = ark.addAsDirectories(\"/lib\");\n\n        String version = System.getProperty(\"itestComponentVersion\");\n        if (version == null) {\n            config.getMavenVersion();\n        }\n        if (version == null) {\n            // It is missing when launching from IDE\n            List<MavenResolvedArtifact> resolved = Arrays.asList(Maven.resolver().loadPomFromFile(\"pom.xml\").importRuntimeDependencies().resolve().withTransitivity().asResolvedArtifact());\n            for (MavenResolvedArtifact dep : resolved) {\n                if (dep.getCoordinate().getGroupId().equals(\"org.apache.camel\")) {\n                    version = dep.getCoordinate().getVersion();\n                    break;\n                }\n            }\n        }\n\n        debug(\"Resolved version: \" + version);\n        if (version == null) {\n            throw new IllegalStateException(\"Cannot determine the current version of the camel component\");\n        }\n\n        MavenDependencyExclusion[] loggingHellExclusions = new MavenDependencyExclusion[]{MavenDependencies.createExclusion(\"org.slf4j\", \"slf4j-log4j12\"), MavenDependencies.createExclusion(\"log4j\",\n                \"log4j\"), MavenDependencies.createExclusion(\"org.slf4j\", \"slf4j-simple\")};\n\n        // Module dependencies\n        List<MavenDependency> moduleDependencies = new LinkedList<>();\n\n        MavenCoordinate mainJar = MavenCoordinates.createCoordinate(config.getMavenGroup(), config.getModuleName(), version, PackagingType.JAR, null);\n        MavenDependency mainDep = MavenDependencies.createDependency(mainJar, ScopeType.COMPILE, false, loggingHellExclusions);\n        moduleDependencies.add(mainDep);\n\n        for (String canonicalForm : config.getAdditionalDependencies()) {\n            MavenCoordinate coord = MavenCoordinates.createCoordinate(canonicalForm);\n            MavenDependency dep = MavenDependencies.createDependency(coord, ScopeType.RUNTIME, false);\n            moduleDependencies.add(dep);\n        }\n\n        if (config.getIncludeProvidedDependencies() || config.getIncludeTestDependencies() || config.getUnitTestEnabled()) {\n\n            List<ScopeType> scopes = new LinkedList<>();\n            if (config.getIncludeTestDependencies() || config.getUnitTestEnabled()) {\n                scopes.add(ScopeType.TEST);\n            }\n            if (config.getIncludeProvidedDependencies()) {\n                scopes.add(ScopeType.PROVIDED);\n            }\n\n            List<MavenResolvedArtifact> moduleArtifacts = Arrays.asList(Maven.resolver()\n                    .loadPomFromFile(config.getModulesPath() + config.getModuleName() + \"/pom.xml\")\n                    .importDependencies(scopes.toArray(new ScopeType[]{}))\n                    .resolve().withoutTransitivity().asResolvedArtifact());\n\n\n            for (MavenResolvedArtifact art : moduleArtifacts) {\n                MavenCoordinate c = art.getCoordinate();\n                if (!validTestDependency(c)) {\n                    continue;\n                }\n                MavenDependency dep = MavenDependencies.createDependency(c, ScopeType.RUNTIME, false, loggingHellExclusions);\n                moduleDependencies.add(dep);\n            }\n        }\n\n        List<File> dependencies = new LinkedList<>();\n        dependencies.addAll(Arrays.asList(Maven.resolver()\n                .loadPomFromFile(\"pom.xml\")\n                .importRuntimeDependencies()\n                .addDependencies(moduleDependencies)\n                .resolve()\n                .withTransitivity()\n                .asFile()));\n\n\n        // The spring boot-loader dependency will be added to the main jar, so it should be excluded from the embedded ones\n        excludeDependencyRegex(dependencies, \"^spring-boot-loader-[0-9].*\");\n\n        // Add all dependencies as spring-boot nested jars\n        ark = addDependencies(ark, dependencies);\n\n        if (config.getUnitTestEnabled()) {\n            // Add unit test classes of the module under test\n            ark = addTestResources(ark, config);\n        }\n\n        // Add common packages to main jar\n        ark = ark.addPackages(true, \"org.apache.camel.itest.springboot\");\n        ark = ark.addPackages(true, \"org.springframework.boot.loader\");\n        ark = ark.addPackages(true, \"org.jboss.shrinkwrap\");\n\n        return ClassPath.builder().add(ark).build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelBoxTest.class))\n                .build();\n    }","id":86027,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelBoxTest.class))\n                .autostart(false) // needs configuration\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelIbatisTest.class))\n                .build();\n    }","id":86028,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelIbatisTest.class))\n                .resource(\"components/ibatis-SqlMapConfig.xml\", \"SqlMapConfig.xml\")\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelKubernetesTest.class))\n                .build();\n    }","id":86029,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelKubernetesTest.class))\n                .dependency(\"org.hibernate:hibernate-validator:\" + HIBERNATE_VALIDATOR_VERSION)\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelMybatisTest.class))\n                .build();\n    }","id":86030,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelMybatisTest.class))\n                .resource(\"components/mybatis-SqlMapConfig.xml\", \"SqlMapConfig.xml\")\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSalesforceTest.class))\n                .build();\n    }","id":86031,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSalesforceTest.class))\n                .autostart(false) // needs configuration\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSpringRedisTest.class))\n                .build();\n    }","id":86032,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSpringRedisTest.class))\n                .dependency(\"org.springframework.data:spring-data-redis:\" + SPRING_DATA_REDIS_VERSION)\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSwaggerJavaTest.class))\n                .build();\n    }","id":86033,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSwaggerJavaTest.class))\n                .dependency(\"org.hibernate:hibernate-validator:\" + HIBERNATE_VALIDATOR_VERSION)\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSwaggerTest.class))\n                .build();\n    }","id":86034,"modified_method":"public static ITestConfig createTestConfig() {\n        return new ITestConfigBuilder()\n                .module(inferModuleName(CamelSwaggerTest.class))\n                .dependency(\"org.hibernate:hibernate-validator:\" + HIBERNATE_VALIDATOR_VERSION)\n                .build();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Boolean executeTest(ITestConfig config, String component) throws Exception {\n\n        logger.info(\"Getting Camel component: {}\", component);\n\n        org.apache.camel.Component comp = context.getComponent(component, true, false);\n        assertNotNull(\"Cannot get module with name: \" + component, comp);\n\n        logger.info(\"Found Camel module: {} instance: {} with className: {}\", component, comp, comp.getClass());\n        return true;\n    }","id":86035,"modified_method":"@Override\n    public Boolean executeTest(ITestConfig config, String component) throws Exception {\n\n        logger.info(\"Getting Camel component: {}\", component);\n\n        org.apache.camel.Component comp = context.getComponent(component, true, config.getAutoStartComponent());\n\n        assertNotNull(\"Cannot get module with name: \" + component, comp);\n\n        logger.info(\"Found Camel module: {} instance: {} with className: {}\", component, comp, comp.getClass());\n        return true;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"ITestConfig{\");\n        sb.append(\"moduleName='\").append(moduleName).append('\\'');\n        sb.append(\", mavenGroup='\").append(mavenGroup).append('\\'');\n        sb.append(\", mavenVersion='\").append(mavenVersion).append('\\'');\n        sb.append(\", modulesPath='\").append(modulesPath).append('\\'');\n        sb.append(\", includeTestDependencies=\").append(includeTestDependencies);\n        sb.append(\", unitTestEnabled=\").append(unitTestEnabled);\n        sb.append(\", unitTestInclusionPattern='\").append(unitTestInclusionPattern).append('\\'');\n        sb.append(\", unitTestExclusionPattern='\").append(unitTestExclusionPattern).append('\\'');\n        sb.append(\", unitTestBasePackage='\").append(unitTestBasePackage).append('\\'');\n        sb.append(\", unitTestsExpectedNumber=\").append(unitTestsExpectedNumber);\n        sb.append('}');\n        return sb.toString();\n    }","id":86036,"modified_method":"@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder(\"ITestConfig{\");\n        sb.append(\"moduleName='\").append(moduleName).append('\\'');\n        sb.append(\", mavenGroup='\").append(mavenGroup).append('\\'');\n        sb.append(\", mavenVersion='\").append(mavenVersion).append('\\'');\n        sb.append(\", modulesPath='\").append(modulesPath).append('\\'');\n        sb.append(\", includeTestDependencies=\").append(includeTestDependencies);\n        sb.append(\", includeProvidedDependencies=\").append(includeProvidedDependencies);\n        sb.append(\", unitTestEnabled=\").append(unitTestEnabled);\n        sb.append(\", unitTestInclusionPattern='\").append(unitTestInclusionPattern).append('\\'');\n        sb.append(\", unitTestExclusionPattern='\").append(unitTestExclusionPattern).append('\\'');\n        sb.append(\", unitTestBasePackage='\").append(unitTestBasePackage).append('\\'');\n        sb.append(\", unitTestsExpectedNumber=\").append(unitTestsExpectedNumber);\n        sb.append(\", resources=\").append(resources);\n        sb.append(\", additionalDependencies=\").append(additionalDependencies);\n        sb.append(\", autoStartComponent=\").append(autoStartComponent);\n        sb.append('}');\n        return sb.toString();\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"private Optional<Boolean> booleanProperty(String name) {\n        return property(name).map(Boolean::valueOf);\n    }","id":86037,"modified_method":"private Boolean booleanPropertyOr(String name, Boolean defaultVal) {\n        String prop = propertyOr(name, null);\n        Boolean res = defaultVal;\n        if (prop != null) {\n            res = Boolean.valueOf(prop);\n        }\n\n        return res;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"private Optional<String> property(String name) {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                InputStream in = getClass().getResourceAsStream(PROPERTIES_FILE);\n                properties.load(in);\n            } catch (Exception e) {\n                throw new IllegalStateException(\"Unable to load property file: \" + PROPERTIES_FILE, e);\n            }\n        }\n\n        return Optional.ofNullable(properties.getProperty(name));\n    }","id":86038,"modified_method":"private String propertyOr(String name, String defaultVal) {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                InputStream in = getClass().getResourceAsStream(PROPERTIES_FILE);\n                properties.load(in);\n            } catch (Exception e) {\n                throw new IllegalStateException(\"Unable to load property file: \" + PROPERTIES_FILE, e);\n            }\n        }\n\n        String res = properties.getProperty(name);\n        if (res == null) {\n            res = defaultVal;\n        }\n        return res;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public ITestConfig build() {\n\n        // Checking conditions\n        if (config.getModuleName() == null) {\n            fail(\"ModuleName is required\");\n        }\n\n        // Set the defaults\n        if (config.getUnitTestEnabled() == null) {\n            config.setUnitTestEnabled(booleanProperty(\"unitTestEnabled\").orElse(false));\n        }\n\n        if (config.getMavenGroup() == null) {\n            config.setMavenGroup(property(\"mavenGroup\").orElse(\"org.apache.camel\"));\n        }\n\n        if (config.getMavenVersion() == null) {\n            config.setMavenVersion(property(\"mavenVersion\").orElse(null));\n        }\n\n        if (config.getUnitTestInclusionPattern() == null) {\n            config.setUnitTestInclusionPattern(property(\"unitTestInclusionPattern\").orElse(\"^.*Test$\")); // All tests\n        }\n\n        if (config.getUnitTestExclusionPattern() == null) {\n            config.setUnitTestExclusionPattern(property(\"unitTestExclusionPattern\").orElse(\".*(\\\\.integration\\\\..*|XXXTest$)\")); // Integration test\n        }\n\n        if (config.getIncludeTestDependencies() == null) {\n            config.setIncludeTestDependencies(booleanProperty(\"includeTestDependencies\").orElse(config.getUnitTestEnabled()));\n        }\n\n        if (config.getModulesPath() == null) {\n            config.setModulesPath(property(\"modulesPath\").orElse(\"../../components/\"));\n        }\n\n        if (config.getUnitTestBasePackage() == null) {\n            config.setUnitTestBasePackage(property(\"unitTestBasePackage\").orElse(\"org.apache.camel\"));\n        }\n\n        return config;\n    }","id":86039,"modified_method":"public ITestConfig build() {\n\n        // Checking conditions\n        if (config.getModuleName() == null) {\n            fail(\"ModuleName is required\");\n        }\n\n        // Set the defaults\n        if (config.getUnitTestEnabled() == null) {\n            config.setUnitTestEnabled(booleanPropertyOr(\"unitTestEnabled\", false));\n        }\n\n        if (config.getMavenGroup() == null) {\n            config.setMavenGroup(propertyOr(\"mavenGroup\", \"org.apache.camel\"));\n        }\n\n        if (config.getMavenVersion() == null) {\n            config.setMavenVersion(propertyOr(\"mavenVersion\", null));\n        }\n\n        if (config.getUnitTestInclusionPattern() == null) {\n            config.setUnitTestInclusionPattern(propertyOr(\"unitTestInclusionPattern\", \"^.*Test$\")); // All tests\n        }\n\n        if (config.getUnitTestExclusionPattern() == null) {\n            config.setUnitTestExclusionPattern(propertyOr(\"unitTestExclusionPattern\", \".*(\\\\.integration\\\\..*|XXXTest$)\")); // Integration test\n        }\n\n        if (config.getIncludeTestDependencies() == null) {\n            config.setIncludeTestDependencies(booleanPropertyOr(\"includeTestDependencies\", config.getUnitTestEnabled()));\n        }\n\n        if (config.getIncludeProvidedDependencies() == null) {\n            config.setIncludeProvidedDependencies(booleanPropertyOr(\"includeProvidedDependencies\", true));\n        }\n\n        if (config.getModulesPath() == null) {\n            config.setModulesPath(propertyOr(\"modulesPath\", \"../../components/\"));\n        }\n\n        if (config.getUnitTestBasePackage() == null) {\n            config.setUnitTestBasePackage(propertyOr(\"unitTestBasePackage\", \"org.apache.camel\"));\n        }\n\n        if (config.getAutoStartComponent() == null) {\n            config.setAutoStartComponent(booleanPropertyOr(\"autostartComponent\", true));\n        }\n\n        if (config.getResources() == null) {\n            config.setResources(Collections.emptyMap());\n        }\n\n        if (config.getAdditionalDependencies() == null) {\n            config.setAdditionalDependencies(Collections.emptySet());\n        }\n\n        return config;\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void exportJar() throws Exception {\n\n        Archive<?> archive = ArquillianPackager.springBootPackage(new ITestConfigBuilder()\n                .module(\"camel-jetty9\")\n                .build());\n\n\n        new ZipExporterImpl(archive).exportTo(new File(\"target/export.zip\"), true);\n\n    }","id":86040,"modified_method":"@Test\n    public void exportJar() throws Exception {\n\n        Archive<?> archive = ArquillianPackager.springBootPackage(new ITestConfigBuilder()\n                .module(\"camel-box\")\n                .build());\n\n\n        new ZipExporterImpl(archive).exportTo(new File(\"target/export.zip\"), true);\n\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public UnitTestResult executeTest(ITestConfig config, String component) throws Exception {\n\n        logger.info(\"Spring-Boot test configuration {}\", config);\n\n        Pattern pattern = Pattern.compile(config.getUnitTestInclusionPattern());\n\n        logger.info(\"Scaning the classpath for test classes\");\n        ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);\n\n        scanner.addIncludeFilter(new RegexPatternTypeFilter(pattern));\n\n        List<String> testClasses = new LinkedList<>(scanner.findCandidateComponents(config.getUnitTestBasePackage()).stream().map(bd -> bd.getBeanClassName()).collect(Collectors.toList()));\n\n        if (config.getUnitTestExclusionPattern() != null) {\n            Pattern exclusionPattern = Pattern.compile(config.getUnitTestExclusionPattern());\n            for (Iterator<String> it = testClasses.iterator(); it.hasNext();) {\n                String cn = it.next();\n                if (exclusionPattern.matcher(cn).matches()) {\n                    logger.warn(\"Excluding Test Class: {}\", cn);\n                    it.remove();\n                }\n            }\n        }\n\n        List<Class<?>> classes = new ArrayList<>();\n        for (String cn : testClasses) {\n            Class<?> clazz = Class.forName(cn);\n            if (isAdmissible(clazz)) {\n                logger.info(\"Found admissible test class: {}\", cn);\n                classes.add(clazz);\n            }\n        }\n\n\n        Result result = JUnitCore.runClasses(classes.toArray(new Class[]{}));\n        logger.info(\"Run JUnit tests on {} test classes\", classes.size());\n        logger.info(\"Success: \" + result.wasSuccessful() + \" - Test Run: \" + result.getRunCount() + \" - Failures: \" + result.getFailureCount() + \" - Ignored Tests: \" + result.getIgnoreCount());\n\n        for (Failure f : result.getFailures()) {\n            logger.warn(\"Failed test description: {}\", f.getDescription());\n            logger.warn(\"Message: {}\", f.getMessage());\n            if (f.getException() != null) {\n                logger.warn(\"Exception thrown from test\", f.getException());\n            }\n        }\n\n        if (!result.wasSuccessful()) {\n            Assert.fail(\"Some unit tests failed (\" + result.getFailureCount() + \"/\" + result.getRunCount() + \"), check the logs for more details\");\n        }\n\n        if (result.getRunCount() == 0 && config.getUnitTestsExpectedNumber() == null) {\n            Assert.fail(\"No tests have been found\");\n        }\n\n        Integer expectedTests = config.getUnitTestsExpectedNumber();\n        if (expectedTests != null && expectedTests != result.getRunCount()) {\n            Assert.fail(\"Wrong number of tests: expected \" + expectedTests + \" found \" + result.getRunCount());\n        }\n\n        return new UnitTestResult(result);\n    }","id":86041,"modified_method":"@Override\n    public UnitTestResult executeTest(ITestConfig config, String component) throws Exception {\n\n        logger.info(\"Spring-Boot test configuration {}\", config);\n\n        Pattern pattern = Pattern.compile(config.getUnitTestInclusionPattern());\n\n        logger.info(\"Scaning the classpath for test classes\");\n        ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);\n\n        scanner.addIncludeFilter(new RegexPatternTypeFilter(pattern));\n\n        Set<BeanDefinition> defs = scanner.findCandidateComponents(config.getUnitTestBasePackage());\n        List<String> testClasses = new LinkedList<>();\n        for (BeanDefinition bd : defs) {\n            testClasses.add(bd.getBeanClassName());\n        }\n\n        if (config.getUnitTestExclusionPattern() != null) {\n            Pattern exclusionPattern = Pattern.compile(config.getUnitTestExclusionPattern());\n            for (Iterator<String> it = testClasses.iterator(); it.hasNext();) {\n                String cn = it.next();\n                if (exclusionPattern.matcher(cn).matches()) {\n                    logger.warn(\"Excluding Test Class: {}\", cn);\n                    it.remove();\n                }\n            }\n        }\n\n        List<Class<?>> classes = new ArrayList<>();\n        for (String cn : testClasses) {\n            Class<?> clazz = Class.forName(cn);\n            if (isAdmissible(clazz)) {\n                logger.info(\"Found admissible test class: {}\", cn);\n                classes.add(clazz);\n            }\n        }\n\n\n        Result result = JUnitCore.runClasses(classes.toArray(new Class[]{}));\n        logger.info(\"Run JUnit tests on {} test classes\", classes.size());\n        logger.info(\"Success: \" + result.wasSuccessful() + \" - Test Run: \" + result.getRunCount() + \" - Failures: \" + result.getFailureCount() + \" - Ignored Tests: \" + result.getIgnoreCount());\n\n        for (Failure f : result.getFailures()) {\n            logger.warn(\"Failed test description: {}\", f.getDescription());\n            logger.warn(\"Message: {}\", f.getMessage());\n            if (f.getException() != null) {\n                logger.warn(\"Exception thrown from test\", f.getException());\n            }\n        }\n\n        if (!result.wasSuccessful()) {\n            Assert.fail(\"Some unit tests failed (\" + result.getFailureCount() + \"/\" + result.getRunCount() + \"), check the logs for more details\");\n        }\n\n        if (result.getRunCount() == 0 && config.getUnitTestsExpectedNumber() == null) {\n            Assert.fail(\"No tests have been found\");\n        }\n\n        Integer expectedTests = config.getUnitTestsExpectedNumber();\n        if (expectedTests != null && expectedTests != result.getRunCount()) {\n            Assert.fail(\"Wrong number of tests: expected \" + expectedTests + \" found \" + result.getRunCount());\n        }\n\n        return new UnitTestResult(result);\n    }","commit_id":"a441b8938d036df618990e719d2f4a140840442d","url":"https://github.com/apache/camel"},{"original_method":"public boolean acceptModule(ModuleIdentifier module) {\n            return !anyArtifact || !(matches(moduleId.getGroup(), module.getGroup()) && matches(moduleId.getName(), module.getName()));\n        }","id":86042,"modified_method":"public boolean acceptModule(ModuleIdentifier module) {\n            return isArtifactExclude || !(matches(moduleId.getGroup(), module.getGroup()) && matches(moduleId.getName(), module.getName()));\n        }","commit_id":"87ff6262791fd4a461619d352384340a7fe77f6a","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean acceptArtifact(ModuleIdentifier module, IvyArtifactName artifact) {\n            return !(matches(moduleId.getGroup(), module.getGroup())\n                    && matches(moduleId.getName(), module.getName())\n                    && matches(ivyArtifactName.getName(), artifact.getName())\n                    && matches(ivyArtifactName.getExtension(), artifact.getExtension())\n                    && matches(ivyArtifactName.getType(), artifact.getType()));\n        }","id":86043,"modified_method":"public boolean acceptArtifact(ModuleIdentifier module, IvyArtifactName artifact) {\n            if (isArtifactExclude) {\n                return !(matches(moduleId.getGroup(), module.getGroup())\n                        && matches(moduleId.getName(), module.getName())\n                        && matches(ivyArtifactName.getName(), artifact.getName())\n                        && matches(ivyArtifactName.getExtension(), artifact.getExtension())\n                        && matches(ivyArtifactName.getType(), artifact.getType()));\n            }\n            return true;\n        }","commit_id":"87ff6262791fd4a461619d352384340a7fe77f6a","url":"https://github.com/gradle/gradle"},{"original_method":"private ExcludeRuleBackedSpec(Iterable<ExcludeRule> excludeRules) {\n            for (ExcludeRule rule : excludeRules) {\n\n                if (!(rule.getMatcher() instanceof ExactPatternMatcher)) {\n                    excludeSpecs.add(new ExcludeRuleSpec(rule));\n                    continue;\n                }\n\n                ArtifactId artifactId = rule.getId();\n                ModuleId moduleId = artifactId.getModuleId();\n                boolean anyOrganisation = isWildcard(moduleId.getOrganisation());\n                boolean anyModule = isWildcard(moduleId.getName());\n                boolean anyArtifact = isWildcard(artifactId.getName()) && isWildcard(artifactId.getType()) && isWildcard(artifactId.getExt());\n\n                if (anyArtifact) {\n                    if (!anyOrganisation && !anyModule) {\n                        excludeSpecs.add(new ModuleIdSpec(moduleId.getOrganisation(), moduleId.getName()));\n                    } else if (!anyModule) {\n                        excludeSpecs.add(new ModuleNameSpec(moduleId.getName()));\n                    } else if (!anyOrganisation) {\n                        excludeSpecs.add(new GroupNameSpec(moduleId.getOrganisation()));\n                    } else {\n                        excludeSpecs.add(new ExcludeRuleSpec(rule)); // Should be 'accept nothing'\n                    }\n                } else {\n                    excludeSpecs.add(new ArtifactSpec(rule));\n                }\n            }\n        }","id":86044,"modified_method":"private ExcludeRuleBackedSpec(Iterable<ExcludeRule> excludeRules) {\n            for (ExcludeRule rule : excludeRules) {\n\n                if (!(rule.getMatcher() instanceof ExactPatternMatcher)) {\n                    excludeSpecs.add(new ExcludeRuleSpec(rule));\n                    continue;\n                }\n\n                ArtifactId artifactId = rule.getId();\n                ModuleId moduleId = artifactId.getModuleId();\n                boolean anyOrganisation = isWildcard(moduleId.getOrganisation());\n                boolean anyModule = isWildcard(moduleId.getName());\n                boolean anyArtifact = isWildcard(artifactId.getName()) && isWildcard(artifactId.getType()) && isWildcard(artifactId.getExt());\n\n                if (anyArtifact) {\n                    if (!anyOrganisation && !anyModule) {\n                        excludeSpecs.add(new ModuleIdSpec(moduleId.getOrganisation(), moduleId.getName()));\n                    } else if (!anyModule) {\n                        excludeSpecs.add(new ModuleNameSpec(moduleId.getName()));\n                    } else if (!anyOrganisation) {\n                        excludeSpecs.add(new GroupNameSpec(moduleId.getOrganisation()));\n                    } else {\n                        excludeSpecs.add(new ExcludeAllModulesSpec());\n                    }\n                } else {\n                    excludeSpecs.add(new ArtifactSpec(rule));\n                }\n            }\n        }","commit_id":"87ff6262791fd4a461619d352384340a7fe77f6a","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        protected boolean acceptsAllModules() {\n            return !anyArtifact;\n        }","id":86045,"modified_method":"@Override\n        protected boolean acceptsAllModules() {\n            return isArtifactExclude;\n        }","commit_id":"87ff6262791fd4a461619d352384340a7fe77f6a","url":"https://github.com/gradle/gradle"},{"original_method":"private ExcludeRuleSpec(ExcludeRule rule) {\n            this.moduleId = DefaultModuleIdentifier.newId(rule.getId().getModuleId().getOrganisation(), rule.getId().getModuleId().getName());\n            this.ivyArtifactName = new DefaultIvyArtifactName(rule.getId().getName(), rule.getId().getType(), rule.getId().getExt());\n            anyArtifact = isWildcard(ivyArtifactName.getName()) && isWildcard(ivyArtifactName.getType()) && isWildcard(ivyArtifactName.getExtension());\n            this.matcher = rule.getMatcher();\n        }","id":86046,"modified_method":"private ExcludeRuleSpec(ExcludeRule rule) {\n            this.moduleId = DefaultModuleIdentifier.newId(rule.getId().getModuleId().getOrganisation(), rule.getId().getModuleId().getName());\n            this.ivyArtifactName = new DefaultIvyArtifactName(rule.getId().getName(), rule.getId().getType(), rule.getId().getExt());\n            this.matcher = rule.getMatcher();\n            isArtifactExclude = !isWildcard(ivyArtifactName.getName()) || !isWildcard(ivyArtifactName.getType()) || !isWildcard(ivyArtifactName.getExtension());\n        }","commit_id":"87ff6262791fd4a461619d352384340a7fe77f6a","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n  public void addSeveral() throws IOException {\n    byte[] data = FileUtil.loadFileBytes(new File(getTestDataPath(), \"encoding.xml\"));\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    String addedFile2 = \"$APP_CONFIG$/crucibleConnector.xml\";\n    getProvider().saveContent(addedFile, data, data.length, RoamingType.PER_USER, false);\n\n    GitEx git = getRepositoryManager().getGit();\n    IndexDiff diff = git.computeIndexDiff();\n    assertThat(diff.diff(), equalTo(true));\n    assertThat(diff.getAdded(), contains(equalTo(addedFile), equalTo(addedFile2)));\n    assertThat(diff.getChanged(), empty());\n    assertThat(diff.getRemoved(), empty());\n    assertThat(diff.getModified(), empty());\n    assertThat(diff.getUntracked(), empty());\n    assertThat(diff.getUntrackedFolders(), empty());\n  }","id":86047,"modified_method":"@Test\n  public void addSeveral() throws IOException {\n    byte[] data = FileUtil.loadFileBytes(new File(getTestDataPath(), \"encoding.xml\"));\n    byte[] data2 = FileUtil.loadFileBytes(new File(getTestDataPath(), \"crucibleConnector.xml\"));\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    String addedFile2 = \"$APP_CONFIG$/crucibleConnector.xml\";\n    getProvider().saveContent(addedFile, data, data.length, RoamingType.PER_USER, false);\n    getProvider().saveContent(addedFile2, data2, data2.length, RoamingType.PER_USER, false);\n\n    IndexDiff diff = GitPackage.computeIndexDiff(getRepositoryManager().getRepository());\n    assertThat(diff.diff(), equalTo(true));\n    assertThat(diff.getAdded(), contains(equalTo(addedFile), equalTo(addedFile2)));\n    assertThat(diff.getChanged(), empty());\n    assertThat(diff.getRemoved(), empty());\n    assertThat(diff.getModified(), empty());\n    assertThat(diff.getUntracked(), empty());\n    assertThat(diff.getUntrackedFolders(), empty());\n  }","commit_id":"8a3b57eb8ff5095b2178e4c97bce48ade6c8f046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Repository getRepository() {\n    return getRepositoryManager().getGit().getRepository();\n  }","id":86048,"modified_method":"@NotNull\n  private static Repository getRepository() {\n    return getRepositoryManager().getRepository();\n  }","commit_id":"8a3b57eb8ff5095b2178e4c97bce48ade6c8f046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void add() throws IOException {\n    byte[] data = FileUtil.loadFileBytes(new File(getTestDataPath(), \"encoding.xml\"));\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    getProvider().saveContent(addedFile, data, data.length, RoamingType.PER_USER, false);\n\n    GitEx git = getRepositoryManager().getGit();\n    IndexDiff diff = git.computeIndexDiff();\n    assertThat(diff.diff(), equalTo(true));\n    assertThat(diff.getAdded(), contains(equalTo(addedFile)));\n    assertThat(diff.getChanged(), empty());\n    assertThat(diff.getRemoved(), empty());\n    assertThat(diff.getModified(), empty());\n    assertThat(diff.getUntracked(), empty());\n    assertThat(diff.getUntrackedFolders(), empty());\n  }","id":86049,"modified_method":"@Test\n  public void add() throws IOException {\n    byte[] data = FileUtil.loadFileBytes(new File(getTestDataPath(), \"encoding.xml\"));\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    getProvider().saveContent(addedFile, data, data.length, RoamingType.PER_USER, false);\n\n    IndexDiff diff = GitPackage.computeIndexDiff(getRepositoryManager().getRepository());\n    assertThat(diff.diff(), equalTo(true));\n    assertThat(diff.getAdded(), contains(equalTo(addedFile)));\n    assertThat(diff.getChanged(), empty());\n    assertThat(diff.getRemoved(), empty());\n    assertThat(diff.getModified(), empty());\n    assertThat(diff.getUntracked(), empty());\n    assertThat(diff.getUntrackedFolders(), empty());\n  }","commit_id":"8a3b57eb8ff5095b2178e4c97bce48ade6c8f046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private File createFileRemote(@Nullable String branchName) throws IOException, GitAPIException {\n    GitEx git = new GitEx(testWatcher.getRepository(ICS_DIR));\n\n    if (branchName != null) {\n      // jgit cannot checkout&create branch if no HEAD (no commits in our empty repository), so we create initial empty commit\n      git.commit().setMessage(\"\").call();\n\n      git.checkout().setCreateBranch(true).setName(branchName).call();\n    }\n\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    File workTree = git.getRepository().getWorkTree();\n    FileUtil.copy(new File(getTestDataPath(), \"encoding.xml\"), new File(workTree, addedFile));\n    git.add(addedFile);\n    git.commit().setMessage(\"\").call();\n    return workTree;\n  }","id":86050,"modified_method":"@NotNull\n  private File createFileRemote(@Nullable String branchName) throws IOException, GitAPIException {\n    Git git = new Git(testWatcher.getRepository(ICS_DIR));\n\n    if (branchName != null) {\n      // jgit cannot checkout&create branch if no HEAD (no commits in our empty repository), so we create initial empty commit\n      git.commit().setMessage(\"\").call();\n\n      git.checkout().setCreateBranch(true).setName(branchName).call();\n    }\n\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    File workTree = git.getRepository().getWorkTree();\n    FileUtil.copy(new File(getTestDataPath(), \"encoding.xml\"), new File(workTree, addedFile));\n    git.add().addFilepattern(addedFile).call();\n    git.commit().setMessage(\"\").call();\n    return workTree;\n  }","commit_id":"8a3b57eb8ff5095b2178e4c97bce48ade6c8f046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void delete(byte[] data, boolean directory) throws IOException {\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    getProvider().saveContent(addedFile, data, data.length, RoamingType.PER_USER, true);\n    getProvider().delete(directory ? \"$APP_CONFIG$\" : addedFile, RoamingType.PER_USER);\n\n    GitEx git = getRepositoryManager().getGit();\n    IndexDiff diff = git.computeIndexDiff();\n    assertThat(diff.diff(), equalTo(false));\n    assertThat(diff.getAdded(), empty());\n    assertThat(diff.getChanged(), empty());\n    assertThat(diff.getRemoved(), empty());\n    assertThat(diff.getModified(), empty());\n    assertThat(diff.getUntracked(), empty());\n    assertThat(diff.getUntrackedFolders(), empty());\n  }","id":86051,"modified_method":"private static void delete(byte[] data, boolean directory) throws IOException {\n    String addedFile = \"$APP_CONFIG$/encoding.xml\";\n    getProvider().saveContent(addedFile, data, data.length, RoamingType.PER_USER, true);\n    getProvider().delete(directory ? \"$APP_CONFIG$\" : addedFile, RoamingType.PER_USER);\n\n    IndexDiff diff = GitPackage.computeIndexDiff(getRepositoryManager().getRepository());\n    assertThat(diff.diff(), equalTo(false));\n    assertThat(diff.getAdded(), empty());\n    assertThat(diff.getChanged(), empty());\n    assertThat(diff.getRemoved(), empty());\n    assertThat(diff.getModified(), empty());\n    assertThat(diff.getUntracked(), empty());\n    assertThat(diff.getUntrackedFolders(), empty());\n  }","commit_id":"8a3b57eb8ff5095b2178e4c97bce48ade6c8f046","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void fillComponents(UIContainer tofill, ViewParameters viewParams, ComponentChecker checker) {\n\t\tGeneralViewParameters params = (GeneralViewParameters) viewParams;\n\t\t\n\t\t// security model:\n\t\t// canEditPage and canReadPage are normal Sakai privileges. They apply\n\t\t// to all\n\t\t// pages in the site.\n\t\t// However when presented with a page, we need to make sure it's\n\t\t// actually in\n\t\t// this site, or users could get to pages in other sites. That's done\n\t\t// by updatePageObject. The model is that producers always work on the\n\t\t// current page, and updatePageObject makes sure that is in the current\n\t\t// site.\n\t\t// At that point we can safely use canEditPage.\n\n\t\t// somewhat misleading. sendingPage specifies the page we're supposed to\n\t\t// go to.  If path is \"none\", we don't want this page to be what we see\n\t\t// when we come back to the tool\n\t\tif (params.getSendingPage() != -1) {\n\t\t\t// will fail if page not in this site\n\t\t\t// security then depends upon making sure that we only deal with\n\t\t\t// this page\n\t\t\ttry {\n\t\t\t\tsimplePageBean.updatePageObject(params.getSendingPage(), !params.getPath().equals(\"none\"));\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"ShowPage permission exception \" + e);\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean canEditPage = simplePageBean.canEditPage();\n\t\tboolean canReadPage = simplePageBean.canReadPage();\n\t\t\n\t\tboolean cameFromGradingPane = params.getPath().equals(\"none\");\n\n\t\tif (!canReadPage) {\n\t\t\t// this code is intended for the situation where site permissions\n\t\t\t// haven't been set up.\n\t\t\t// So if the user can't read the page (which is pretty abnormal),\n\t\t\t// see if they have site.upd.\n\t\t\t// if so, give them some explanation and offer to call the\n\t\t\t// permissions helper\n\t\t\tString ref = \"/site/\" + simplePageBean.getCurrentSiteId();\n\t\t\tif (simplePageBean.canEditSite()) {\n\t\t\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\t\tUIOutput.make(tofill, \"needPermissions\");\n\n\t\t\t\tGeneralViewParameters permParams = new GeneralViewParameters();\n\t\t\t\tpermParams.setSendingPage(-1L);\n\t\t\t\tcreateStandardToolBarLink(PermissionsHelperProducer.VIEW_ID, tofill, \"callpermissions\", \"simplepage.permissions\", permParams, \"simplepage.permissions.tooltip\");\n\n\t\t\t}\n\n\t\t\t// in any case, tell them they can't read the page\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.nopermissions\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.addTool == GeneralViewParameters.COMMENTS) {\n\t\t\tsimplePageBean.addCommentsSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_CONTENT) {\n\t\t\tsimplePageBean.addStudentContentSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_PAGE) {\n\t\t\tsimplePageBean.createStudentPage(params.studentItemId);\n\t\t\tcanEditPage = simplePageBean.canEditPage();\n\t\t}\n\n\t\t// error from previous operation\n\t\tString errMessage = simplePageBean.errMessage();\n\t\tif (errMessage != null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", errMessage);\n\t\t}\n\n\t\t// Find the MSIE version, if we're running it.\n\t\tint ieVersion = checkIEVersion();\n\n\t\tif (simplePageBean.getTopRefresh()) {\n\t\t\tUIOutput.make(tofill, \"refresh\");\n\t\t}\n\n\t\tif (canEditPage) {\n\t\t    // special instructor-only javascript setup.\n\t\t\tUIOutput.make(tofill, \"instructoronly\");\n\t\t}\n\n\t\t// set up locale\n\t\tLocale M_locale = null;\n\t\tString langLoc[] = localegetter.get().toString().split(\"_\");\n\t\tif (langLoc.length >= 2) {\n\t\t\tif (\"en\".equals(langLoc[0]) && \"ZA\".equals(langLoc[1])) {\n\t\t\t\tM_locale = new Locale(\"en\", \"GB\");\n\t\t\t} else {\n\t\t\t\tM_locale = new Locale(langLoc[0], langLoc[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tM_locale = new Locale(langLoc[0]);\n\t\t}\n\n\t\t// clear session attribute if necessary, after calling Samigo\n\t\tString clearAttr = params.getClearAttr();\n\n\t\tif (clearAttr != null && !clearAttr.equals(\"\")) {\n\t\t\tSession session = SessionManager.getCurrentSession();\n\t\t\t// don't let users clear random attributes\n\t\t\tif (clearAttr.startsWith(\"LESSONBUILDER_RETURNURL\")) {\n\t\t\t\tsession.setAttribute(clearAttr, null);\n\t\t\t}\n\t\t}\n\n\t\tif (multimediaTypes == null) {\n\t\t\tString mmTypes = ServerConfigurationService.getString(\"lessonbuilder.multimedia.types\", DEFAULT_TYPES);\n\t\t\tmultimediaTypes = mmTypes.split(\",\");\n\t\t\tfor (int i = 0; i < multimediaTypes.length; i++) {\n\t\t\t\tmultimediaTypes[i] = multimediaTypes[i].trim().toLowerCase();\n\t\t\t}\n\t\t\tArrays.sort(multimediaTypes);\n\t\t}\n\n\t\t// remember that page tool was reset, so we need to give user the option\n\t\t// of going to the last page from the previous session\n\t\tSimplePageToolDao.PageData lastPage = simplePageBean.toolWasReset();\n\n\t\t// if starting the tool, sendingpage isn't set. the following call\n\t\t// will give us the top page.\n\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\n\t\t// now we need to find our own item, for access checks, etc.\n\t\tSimplePageItem pageItem = null;\n\t\tif (currentPage != null) {\n\t\t\tpageItem = simplePageBean.getCurrentPageItem(params.getItemId());\n\t\t}\n\t\t// one more security check: make sure the item actually involves this\n\t\t// page.\n\t\t// otherwise someone could pass us an item from a different page in\n\t\t// another site\n\t\t// actually this normally happens if the page doesn't exist and we don't\n\t\t// have permission to create it\n\t\tif (currentPage == null || pageItem == null || \n\t\t    (pageItem.getType() != SimplePageItem.STUDENT_CONTENT &&Long.valueOf(pageItem.getSakaiId()) != currentPage.getPageId()) ||\n\t\t    !simplePageBean.isItemVisible(pageItem)) {\n\t\t\tlog.warn(\"ShowPage item not in page\");\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// I believe we've now checked all the args for permissions issues. All\n\t\t// other item and\n\t\t// page references are generated here based on the contents of the page\n\t\t// and items.\n\n\t\tif (currentPage == null || pageItem == null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.impossible1\"));\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Set up customizable CSS\n\t\tContentResource cssLink = simplePageBean.getCssForCurrentPage();\n\t\tif(cssLink != null) {\n\t\t\tUIOutput.make(tofill, \"customCSS\").decorate(new UIFreeAttributeDecorator(\"href\", cssLink.getUrl()));\n\t\t}\n\n\t\t// offer to go to saved page if this is the start of a session, in case\n\t\t// user has logged off and logged on again.\n\t\t// need to offer to go to previous page? even if a new session, no need\n\t\t// if we're already on that page\n\t\tif (lastPage != null && lastPage.pageId != currentPage.getPageId()) {\n\t\t\tUIOutput.make(tofill, \"refreshAlert\");\n\t\t\tUIOutput.make(tofill, \"refresh-message\", messageLocator.getMessage(\"simplepage.last-visited\"));\n\t\t\t// Should simply refresh\n\t\t\tGeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\tp.setSendingPage(lastPage.pageId);\n\t\t\tp.setItemId(lastPage.itemId);\n\t\t\t// reset the path to the saved one\n\t\t\tp.setPath(\"log\");\n\t\t\t\n\t\t\tString name = lastPage.name;\n\t\t\t\n\t\t\t// Titles are set oddly by Student Content Pages\n\t\t\tSimplePage lastPageObj = simplePageToolDao.getPage(lastPage.pageId);\n\t\t\tif(lastPageObj.getOwner() != null) {\n\t\t\t\tname = lastPageObj.getTitle();\n\t\t\t}\n\t\t\t\n\t\t\tUIInternalLink.make(tofill, \"refresh-link\", name, p);\n\t\t}\n\n\t\t// path is the breadcrumbs. Push, pop or reset depending upon path=\n\t\t// programmer documentation.\n\t\tString title;\n\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\ttitle = pageItem.getName();\n\t\t}else {\n\t\t\ttitle = currentPage.getTitle();\n\t\t}\n\t\t\n\t\tString newPath = null;\n\t\t\n\t\t// If the path is \"none\", then we don't want to record this page as being viewed, or set a path\n\t\tif(!params.getPath().equals(\"none\")) {\n\t\t\tnewPath = simplePageBean.adjustPath(params.getPath(), currentPage.getPageId(), pageItem.getId(), title);\n\t\t\tsimplePageBean.adjustBackPath(params.getBackPath(), currentPage.getPageId(), pageItem.getId(), pageItem.getName());\n\t\t}\n\t\t\n\t\t// potentially need time zone for setting release date\n\t\tif (!canEditPage && currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\tdf.setTimeZone(tz);\n\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\tString releaseMessage = messageLocator.getMessage(\"simplepage.not_yet_available_releasedate\").replace(\"{}\", releaseDate);\n\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", releaseMessage);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// put out link to index of pages\n\t\tGeneralViewParameters showAll = new GeneralViewParameters(PagePickerProducer.VIEW_ID);\n\t\tshowAll.setSource(\"summary\");\n\t\tUIInternalLink.make(tofill, \"show-pages\", messageLocator.getMessage(\"simplepage.showallpages\"), showAll);\n\t\t\n\t\tif (canEditPage) {\n\t\t\t// show tool bar, but not if coming from grading pane\n\t\t\tif(!cameFromGradingPane) {\n\t\t\t\tcreateToolBar(tofill, currentPage, (pageItem.getType() == SimplePageItem.STUDENT_CONTENT));\n\t\t\t}\n\t\t\t\n\t\t\tUIOutput.make(tofill, \"title-descrip\");\n\t\t\tString label = null;\n\t\t\tif (pageItem.getType() == SimplePageItem.STUDENT_CONTENT)\n\t\t\t    label = messageLocator.getMessage(\"simplepage.editTitle\");\n\t\t\telse\n\t\t\t    label = messageLocator.getMessage(\"simplepage.title\");\n\t\t\tString descrip = null;\n\t\t\tif (pageItem.getType() == SimplePageItem.STUDENT_CONTENT)\n\t\t\t    descrip = messageLocator.getMessage(\"simplepage.title-student-descrip\");\n\t\t\telse if (pageItem.getPageId() == 0)\n\t\t\t    descrip = messageLocator.getMessage(\"simplepage.title-top-descrip\");\n\t\t\telse\n\t\t\t    descrip = messageLocator.getMessage(\"simplepage.title-descrip\");\n\n\t\t\tUIOutput.make(tofill, \"edit-title\").decorate(new UIFreeAttributeDecorator(\"title\", descrip));\n\t\t\tUIOutput.make(tofill, \"edit-title-text\", label);\n\t\t\tUIOutput.make(tofill, \"title-descrip-text\", descrip);\n\n\t\t\tif (pageItem.getPageId() == 0) { // top level page\n\t\t\t\tUIOutput.make(tofill, \"toppage-descrip\");\n\t\t\t\tUIOutput.make(tofill, \"new-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-page-tooltip\")));\n\t\t\t\tUIOutput.make(tofill, \"import-cc\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.import_cc\")));\n\t\t\t}\n\t\t\t\n\t\t\t// Checks to see that user can edit and that this is either a top level page,\n\t\t\t// or a top level student page (not a subpage to a student page)\n\t\t\tif(simplePageBean.getEditPrivs() == 0 && (pageItem.getPageId() == 0)) {\n\t\t\t\tUIOutput.make(tofill, \"remove-descrip\");\n\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t} else if (simplePageBean.getEditPrivs() == 0 && currentPage.getOwner() != null) {\n\t\t\t\tSimpleStudentPage studentPage = simplePageToolDao.findStudentPage(currentPage.getTopParent());\n\t\t\t\tif (studentPage != null && studentPage.getPageId() == currentPage.getPageId()) {\n\t\t\t\t\tUIOutput.make(tofill, \"remove-descrip\");\n\t\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUIOutput.make(tofill, \"dialogDiv\");\n\t\t} else if (!canReadPage)\n\t\t\treturn;\n\t\telse {\n\t\t\t// see if there are any unsatisfied prerequisites\n\t\t\tList<String> needed = simplePageBean.pagesNeeded(pageItem);\n\t\t\tif (needed.size() > 0) {\n\t\t\t\t// yes. error and abort\n\t\t\t\tif (pageItem.getPageId() != 0) {\n\t\t\t\t\t// not top level. This should only happen from a \"next\"\n\t\t\t\t\t// link.\n\t\t\t\t\t// at any rate, the best approach is to send the user back\n\t\t\t\t\t// to the calling page\n\t\t\t\t\tList<SimplePageBean.PathEntry> path = simplePageBean.getHierarchy();\n\t\t\t\t\tSimplePageBean.PathEntry containingPage = null;\n\t\t\t\t\tif (path.size() > 1) {\n\t\t\t\t\t\t// page above this. this page is on the top\n\t\t\t\t\t\tcontainingPage = path.get(path.size() - 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (containingPage != null) { // not a top level page, point\n\t\t\t\t\t\t// to containing page\n\t\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\t\tview.setSendingPage(containingPage.pageId);\n\t\t\t\t\t\tview.setItemId(containingPage.pageItemId);\n\t\t\t\t\t\tview.setPath(Integer.toString(path.size() - 2));\n\t\t\t\t\t\tUIInternalLink.make(tofill, \"redirect-link\", containingPage.title, view);\n\t\t\t\t\t\tUIOutput.make(tofill, \"redirect\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// top level page where prereqs not satisified. Output list of\n\t\t\t\t// pages he needs to do first\n\t\t\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.has_prerequistes\"));\n\t\t\t\tUIBranchContainer errorList = UIBranchContainer.make(tofill, \"error-list:\");\n\t\t\t\tfor (String errorItem : needed) {\n\t\t\t\t\tUIBranchContainer errorListItem = UIBranchContainer.make(errorList, \"error-item:\");\n\t\t\t\t\tUIOutput.make(errorListItem, \"error-item-text\", errorItem);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tToolSession toolSession = SessionManager.getCurrentToolSession();\n\t\tString helpurl = (String)toolSession.getAttribute(\"sakai-portal:help-action\");\n\t\tString reseturl = (String)toolSession.getAttribute(\"sakai-portal:reset-action\");\n\n\t\tif (helpurl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"helpbutton\" : \"helpbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"openWindow('\" + helpurl + \"', 'Help', 'resizeable=yes,toolbar=no,scrollbars=yes,menubar=yes,width=800,height=600'); return false\"));\n\n\t\tif (reseturl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"resetbutton\" : \"resetbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"location.href='\" + reseturl + \"'; return false\"));\n\n\t\t// note page accessed. the code checks to see whether all the required\n\t\t// items on it have been finished, and if so marks it complete, else just updates\n\t\t// access date save the path because if user goes to it later we want to restore the\n\t\t// breadcrumbs\n\t\tif(newPath != null) {\n\t\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\t\tsimplePageBean.track(pageItem.getId(), newPath);\n\t\t\t}else {\n\t\t\t\tsimplePageBean.track(pageItem.getId(), newPath, currentPage.getPageId());\n\t\t\t}\n\t\t}\n\n\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\t\t\n\t\tif(currentPage.getOwner() != null && simplePageBean.getEditPrivs() == 0) {\n\t\t\tSimpleStudentPage student = simplePageToolDao.findStudentPageByPageId(currentPage.getPageId());\n\t\t\t\n\t\t\t// Make sure this is a top level student page\n\t\t\tif(student != null) {\n\t\t\t\tUIOutput.make(tofill, \"gradingSpan\");\n\t\t\t\tUIOutput.make(tofill, \"commentsUUID\", String.valueOf(student.getId()));\n\t\t\t\tUIOutput.make(tofill, \"commentPoints\", String.valueOf((student.getPoints() != null? student.getPoints() : \"\")));\n\t\t\t\n\t\t\t\tList<SimpleStudentPage> studentPages = simplePageToolDao.findStudentPages(student.getItemId());\n\t\t\t\t\n\t\t\t\tCollections.sort(studentPages, new Comparator<SimpleStudentPage>() {\n\t\t\t\t\tpublic int compare(SimpleStudentPage o1, SimpleStudentPage o2) {\n\t\t\t\t\t\tString title1 = o1.getTitle();\n\t\t\t\t\t\tif (title1 == null)\n\t\t\t\t\t\t\ttitle1 = \"\";\n\t\t\t\t\t\tString title2 = o2.getTitle();\n\t\t\t\t\t\tif (title2 == null)\n\t\t\t\t\t\t\ttitle2 = \"\";\n\t\t\t\t\t\treturn title1.compareTo(title2);\n\t\t\t\t    }\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfor(int in = 0; in < studentPages.size(); in++) {\n\t\t\t\t\tif(studentPages.get(in).isDeleted()) {\n\t\t\t\t\t\tstudentPages.remove(in);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint i = -1;\n\t\t\t\n\t\t\t\tfor(int in = 0; in < studentPages.size(); in++) {\n\t\t\t\t\tif(student.getId() == studentPages.get(in).getId()) {\n\t\t\t\t\t\ti = in;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(i > 0) {\n\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, studentPages.get(i-1).getPageId());\n\t\t\t\t\teParams.setItemId(studentPages.get(i-1).getItemId());\n\t\t\t\t\teParams.setPath(\"next\");\n\t\t\t\t\n\t\t\t\t\tUIInternalLink.make(tofill, \"gradingBack\", eParams);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(i < studentPages.size() - 1) {\n\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, studentPages.get(i+1).getPageId());\n\t\t\t\t\teParams.setItemId(studentPages.get(i+1).getItemId());\n\t\t\t\t\teParams.setPath(\"next\");\n\t\t\t\t\n\t\t\t\t\tUIInternalLink.make(tofill, \"gradingForward\", eParams);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tprintGradingForm(tofill);\n\t\t\t}\n\t\t}\n\n\t\t// breadcrumbs\n\t\tif (pageItem.getPageId() != 0) {\n\t\t\t// Not top-level, so we have to show breadcrumbs\n\n\t\t\tList<SimplePageBean.PathEntry> breadcrumbs = simplePageBean.getHierarchy();\n\n\t\t\tint index = 0;\n\t\t\tif (breadcrumbs.size() > 1) {\n\t\t\t\tUIOutput.make(tofill, \"crumbdiv\");\n\t\t\t\tfor (SimplePageBean.PathEntry e : breadcrumbs) {\n\t\t\t\t\t// don't show current page. We already have a title. This\n\t\t\t\t\t// was too much\n\t\t\t\t\tUIBranchContainer crumb = UIBranchContainer.make(tofill, \"crumb:\");\n\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\tview.setSendingPage(e.pageId);\n\t\t\t\t\tview.setItemId(e.pageItemId);\n\t\t\t\t\tview.setPath(Integer.toString(index));\n\t\t\t\t\tif (index < breadcrumbs.size() - 1) {\n\t\t\t\t\t\t// Not the last item\n\t\t\t\t\t\tUIInternalLink.make(crumb, \"crumb-link\", e.title, view);\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", \" > \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", e.title).decorate(new UIStyleDecorator(\"bold\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// see if there's a next item in sequence.\n\t\tsimplePageBean.addPrevLink(tofill, pageItem);\n\t\tsimplePageBean.addNextLink(tofill, pageItem);\n\n\t\t// swfObject is not currently used\n\t\tboolean shownSwfObject = false;\n\n\t\t// items to show\n\t\tList<SimplePageItem> itemList = (List<SimplePageItem>) simplePageBean.getItemsOnPage(currentPage.getPageId());\n\t\t\n\t\t// Move all items with sequence <= 0 to the end of the list.\n\t\t// Count is necessary to guarantee we don't infinite loop over a\n\t\t// list that only has items with sequence <= 0.\n\t\tint count = 1;\n\t\twhile(itemList.size() > count && itemList.get(0).getSequence() <= 0) {\n\t\t\titemList.add(itemList.remove(0));\n\t\t\tcount++;\n\t\t}\n\n\t\t// Make sure we only add the comments javascript file once,\n\t\t// even if there are multiple comments tools on the page.\n\t\tboolean addedCommentsScript = false;\n\t\tint commentsCount = 0;\n\n\t\t// Find the most recent comment on the page by current user\n\t\tlong postedCommentId = -1;\n\t\tif (params.postedComment) {\n\t\t\tpostedCommentId = findMostRecentComment();\n\t\t}\n\n\t\t//\n\t\t//\n\t\t// MAIN list of items\n\t\t//\n\t\t// produce the main table\n\t\tif (itemList.size() > 0) {\n\t\t\tUIBranchContainer container = UIBranchContainer.make(tofill, \"itemContainer:\");\n\n\t\t\tboolean showRefresh = false;\n\t\t\tint textboxcount = 1;\n\n\t\t\tUIBranchContainer tableContainer = UIBranchContainer.make(container, \"itemTable:\");\n\n\t\t\t// formatting: two columns:\n\t\t\t// 1: edit buttons, omitted for student\n\t\t\t// 2: main content\n\t\t\t// For links, which have status icons, the main content is a flush\n\t\t\t// left div with the icon\n\t\t\t// followed by a div with margin-left:30px. That takes it beyond the\n\t\t\t// icon, and avoids the\n\t\t\t// wrap-around appearance you'd get without the margin.\n\t\t\t// Normally the description is shown as a second div with\n\t\t\t// indentation in the CSS.\n\t\t\t// That puts it below the link. However with a link that's a button,\n\t\t\t// we do float left\n\t\t\t// for the button so the text wraps around it. I think that's\n\t\t\t// probably what people would expect.\n\n\t\t\tUIOutput.make(tableContainer, \"colgroup\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"col1\");\n\t\t\t}\n\t\t\tUIOutput.make(tableContainer, \"col2\");\n\n\t\t\t// the table header is for accessibility tools only, so it's\n\t\t\t// positioned off screen\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"header-edits\");\n\t\t\t}\n\n\t\t\tUIOutput.make(tableContainer, \"header-items\");\n\n\t\t\tfor (SimplePageItem i : itemList) {\n\n\t\t\t\t// listitem is mostly historical. it uses some shared HTML, but\n\t\t\t\t// if I were\n\t\t\t\t// doing it from scratch I wouldn't make this distinction. At\n\t\t\t\t// the moment it's\n\t\t\t\t// everything that isn't inline.\n\n\t\t\t\tboolean listItem = !(i.getType() == SimplePageItem.TEXT || i.getType() == SimplePageItem.MULTIMEDIA\n\t\t\t\t\t\t|| i.getType() == SimplePageItem.COMMENTS || i.getType() == SimplePageItem.STUDENT_CONTENT);\n\t\t\t\t// (i.getType() == SimplePageItem.PAGE &&\n\t\t\t\t// \"button\".equals(i.getFormat())))\n\n\t\t\t\tUIBranchContainer tableRow = UIBranchContainer.make(tableContainer, \"item:\");\n\t\t\t\tif (!simplePageBean.isItemVisible(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// you really need the HTML file open at the same time to make\n\t\t\t\t// sense of the following code\n\t\t\t\tif (listItem) { // Not an HTML Text, Element or Multimedia\n\t\t\t\t\t// Element\n\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id2\", String.valueOf(i.getId()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// users can declare a page item to be navigational. If so\n\t\t\t\t\t// we display\n\t\t\t\t\t// it to the left of the normal list items, and use a\n\t\t\t\t\t// button. This is\n\t\t\t\t\t// used for pages that are \"next\" pages, i.e. they replace\n\t\t\t\t\t// this page\n\t\t\t\t\t// rather than creating a new level in the breadcrumbs.\n\t\t\t\t\t// Since they can't\n\t\t\t\t\t// be required, they don't need the status image, which is\n\t\t\t\t\t// good because\n\t\t\t\t\t// they're displayed with colspan=2, so there's no space for\n\t\t\t\t\t// the image.\n\n\t\t\t\t\tboolean navButton = \"button\".equals(i.getFormat()) && !i.isRequired();\n\t\t\t\t\tboolean notDone = false;\n\t\t\t\t\tStatus status = Status.NOT_REQUIRED;\n\t\t\t\t\tif (!navButton) {\n\t\t\t\t\t\tstatus = handleStatusImage(tableRow, i);\n\t\t\t\t\t\tif (status == Status.REQUIRED) {\n\t\t\t\t\t\t\tnotDone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean isInline = (i.getType() == SimplePageItem.BLTI && \"inline\".equals(i.getFormat()));\n\n\t\t\t\t\tUIOutput linktd = UIOutput.make(tableRow, \"item-td\");\n\t\t\t\t\tUIBranchContainer linkdiv = null;\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    linkdiv = UIBranchContainer.make(tableRow, \"link-div:\");\n\t\t\t\t\t    UIOutput itemicon = UIOutput.make(linkdiv,\"item-icon\");\n\t\t\t\t\t    switch (i.getType()) {\n\t\t\t\t\t    case SimplePageItem.FORUM:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/comments.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/page_edit.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/pencil.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.BLTI:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/application_go.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.PAGE:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/book_open.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.RESOURCE:\n\t\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\t\t\n\t\t\t\t\t\tString src = imageToMimeMap.get(mimeType);\n\t\t\t\t\t\tif (src == null) {\n\t\t\t\t\t\t    String image = ContentTypeImageService.getContentTypeImage(mimeType);\n\t\t\t\t\t\t    if (image != null)\n\t\t\t\t\t\t\tsrc = \"/library/image/\" + image;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(src != null) {\n\t\t\t\t\t\t    itemicon.decorate(new UIFreeAttributeDecorator(\"src\", src));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput descriptiondiv = null;\n\n\t\t\t\t\t// refresh isn't actually used anymore. We've changed the\n\t\t\t\t\t// way things are\n\t\t\t\t\t// done so the user never has to request a refresh.\n\t\t\t\t\t//   FYI: this actually puts in an IFRAME for inline BLTI items\n\t\t\t\t\tshowRefresh = !makeLink(tableRow, \"link\", i, canEditPage, currentPage, notDone, status) || showRefresh;\n\n\t\t\t\t\t// dummy is used when an assignment, quiz, or forum item is\n\t\t\t\t\t// copied\n\t\t\t\t\t// from another site. The way the copy code works, our\n\t\t\t\t\t// import code\n\t\t\t\t\t// doesn't have access to the necessary info to use the item\n\t\t\t\t\t// from the\n\t\t\t\t\t// new site. So we add a dummy, which generates an\n\t\t\t\t\t// explanation that the\n\t\t\t\t\t// author is going to have to choose the item from the\n\t\t\t\t\t// current site\n\t\t\t\t\tif (i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\tString code = null;\n\t\t\t\t\t\tswitch (i.getType()) {\n\t\t\t\t\t\tcase SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assignment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assessment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.FORUM:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.forum\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", messageLocator.getMessage(code));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", i.getDescription());\n\t\t\t\t\t}\n\t\t\t\t\tif (isInline)\n\t\t\t\t\t    descriptiondiv.decorate(new UIFreeAttributeDecorator(\"style\", \"margin-top: 4px\"));\n\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    // nav button gets float left so any description goes to its\n\t\t\t\t\t    // right. Otherwise the\n\t\t\t\t\t    // description block will display underneath\n\t\t\t\t\t    if (\"button\".equals(i.getFormat())) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"style\", \"float:left\"));\n\t\t\t\t\t    }\n\t\t\t\t\t    // for accessibility\n\t\t\t\t\t    if (navButton) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"role\", \"navigation\"));\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\t// note that a lot of the info here is used by the\n\t\t\t\t\t// javascript that prepares\n\t\t\t\t\t// the jQuery dialogs\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-td\");\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.generic\").replace(\"{}\", i.getName())));\n\n\t\t\t\t\t\t// the following information is displayed using <INPUT\n\t\t\t\t\t\t// type=hidden ...\n\t\t\t\t\t\t// it contains information needed to populate the \"edit\"\n\t\t\t\t\t\t// popup dialog\n\t\t\t\t\t\tUIOutput.make(tableRow, \"prerequisite-info\", String.valueOf(i.isPrerequisite()));\n\n\t\t\t\t\t\tString itemGroupString = null;\n\n\t\t\t\t\t\tif (i.getType() == SimplePageItem.ASSIGNMENT) {\n\t\t\t\t\t\t\t// the type indicates whether scoring is letter\n\t\t\t\t\t\t\t// grade, number, etc.\n\t\t\t\t\t\t\t// the javascript needs this to present the right\n\t\t\t\t\t\t\t// choices to the user\n\t\t\t\t\t\t\t// types 6 and 8 aren't legal scoring types, so they\n\t\t\t\t\t\t\t// are used as\n\t\t\t\t\t\t\t// markers for quiz or forum. I ran out of numbers\n\t\t\t\t\t\t\t// and started using\n\t\t\t\t\t\t\t// text for things that aren't scoring types. That's\n\t\t\t\t\t\t\t// better anyway\n\t\t\t\t\t\t\tint type = 4;\n\t\t\t\t\t\t\tLessonEntity assignment = null;\n\t\t\t\t\t\t\tif (!i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\t\t\tassignment = assignmentEntity.getEntity(i.getSakaiId(), simplePageBean);\n\t\t\t\t\t\t\t\tif (assignment != null) {\n\t\t\t\t\t\t\t\t\ttype = assignment.getTypeOfGrade();\n\t\t\t\t\t\t\t\t\tString editUrl = assignment.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, assignment, true);\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", String.valueOf(type));\n\t\t\t\t\t\t\tString requirement = String.valueOf(i.getSubrequirement());\n\t\t\t\t\t\t\tif ((type == SimplePageItem.PAGE || type == SimplePageItem.ASSIGNMENT) && i.getSubrequirement()) {\n\t\t\t\t\t\t\t\trequirement = i.getRequirementText();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", requirement);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.ASSESSMENT) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"6\"); // Not used by\n\t\t\t\t\t\t\t// assignments,\n\t\t\t\t\t\t\t// so it is\n\t\t\t\t\t\t\t// safe to dedicate to assessments\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", (i.getSubrequirement() ? i.getRequirementText() : \"false\"));\n\t\t\t\t\t\t\tLessonEntity quiz = quizEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (quiz != null) {\n\t\t\t\t\t\t\t\tString editUrl = quiz.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teditUrl = quiz.editItemSettingsUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-settings-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, quiz, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.BLTI) {\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"type\", \"b\");\n\t\t\t\t\t\t    LessonEntity blti= (bltiEntity == null ? null : bltiEntity.getEntity(i.getSakaiId()));\n\t\t\t\t\t\t    if (blti != null) {\n\t\t\t\t\t\t\tString editUrl = blti.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\tif (editUrl != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-format\", i.getFormat());\n\n\t\t\t\t\t\t\tif (i.getHeight() != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-height\", i.getHeight());\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.FORUM) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"extra-info\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"8\");\n\t\t\t\t\t\t\tLessonEntity forum = forumEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (forum != null) {\n\t\t\t\t\t\t\t\tString editUrl = forum.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, forum, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.PAGE) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"page\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-next\", Boolean.toString(i.getNextPage()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-button\", Boolean.toString(\"button\".equals(i.getFormat())));\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.RESOURCE) {\n\t\t\t\t\t\t        itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tif (simplePageBean.getInherited())\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", \"--inherited--\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-samewindow\", Boolean.toString(i.isSameWindow()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, (isInline ? \"item-group-titles-div\" : \"item-group-titles\"), \" [\" + itemGroupString + \"]\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// the following are for the inline item types. Multimedia\n\t\t\t\t\t// is the most complex because\n\t\t\t\t\t// it can be IMG, IFRAME, or OBJECT, and Youtube is treated\n\t\t\t\t\t// separately\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.MULTIMEDIA) {\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tStringTokenizer token = new StringTokenizer(i.getSakaiId(), \".\");\n\n\t\t\t\t\tString extension = \"\";\n\n\t\t\t\t\twhile (token.hasMoreTokens()) {\n\t\t\t\t\t\textension = token.nextToken().toLowerCase();\n\t\t\t\t\t}\n\n\t\t\t\t\t// the extension is almost never used. Normally we have\n\t\t\t\t\t// the MIME type and use it. Extension is used only if\n\t\t\t\t\t// for some reason we don't have the MIME type\n\t\t\t\t\tUIComponent item;\n\t\t\t\t\tString youtubeKey;\n\n\t\t\t\t\tLength width = null;\n\t\t\t\t\tif (i.getWidth() != null) {\n\t\t\t\t\t\twidth = new Length(i.getWidth());\n\t\t\t\t\t}\n\t\t\t\t\tLength height = null;\n\t\t\t\t\tif (i.getHeight() != null) {\n\t\t\t\t\t\theight = new Length(i.getHeight());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the MIME type. For multimedia types is should be in\n\t\t\t\t\t// the html field.\n\t\t\t\t\t// The old code saved the URL there. So if it looks like a\n\t\t\t\t\t// URL ignore it.\n\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\tif (mimeType != null && (mimeType.startsWith(\"http\") || mimeType.equals(\"\"))) {\n\t\t\t\t\t\tmimeType = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// here goes. dispatch on the type and produce the right tag\n\t\t\t\t\t// type,\n\t\t\t\t\t// followed by the hidden INPUT tags with information for the\n\t\t\t\t\t// edit dialog\n\t\t\t\t\tif (simplePageBean.isImageType(i)) {\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"imageSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles3\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups3\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tString imageName = i.getAlt();\n\t\t\t\t\t\tif (imageName == null || imageName.equals(\"\")) {\n\t\t\t\t\t\t\timageName = abbrevUrl(i.getURL());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"image\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", imageName));\n\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(lengthOk(height)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// stuff for the jquery dialog\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype2\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id4\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description2\", i.getDescription());\n\n\t\t\t\t\t} else if ((youtubeKey = simplePageBean.getYoutubeKey(i)) != null) {\n\t\t\t\t\t\tString youtubeUrl = \"http://www.youtube.com/v/\" + youtubeKey + \"?version=3\";\n\t\t\t\t\t\t// this is very odd. The official youtube embedding uses\n\t\t\t\t\t\t// <OBJECT> with\n\t\t\t\t\t\t// a stylesheet to specify size. But the only values\n\t\t\t\t\t\t// that actually\n\t\t\t\t\t\t// work are px and percent. I.e. it works just like the\n\t\t\t\t\t\t// old\n\t\t\t\t\t\t// HTML length types. A real stylesheet length\n\t\t\t\t\t\t// understands other units.\n\t\t\t\t\t\t// I'm generating a style sheet, so that our HTML\n\t\t\t\t\t\t// embedding is as close\n\t\t\t\t\t\t// to theirs as possible, even the lengths are actually\n\t\t\t\t\t\t// interpreted as old style\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles4\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups4\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if width is blank or 100% scale the height\n\t\t\t\t\t\tif (width != null && height != null && !height.number.equals(\"\")) {\n\t\t\t\t\t\t\tif (width.number.equals(\"\") && width.unit.equals(\"\") || width.number.equals(\"100\") && width.unit.equals(\"%\")) {\n\n\t\t\t\t\t\t\t\tint h = Integer.parseInt(height.number);\n\t\t\t\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\t\t\t\twidth.number = Integer.toString((int) Math.round(h * 1.641025641));\n\t\t\t\t\t\t\t\t\twidth.unit = height.unit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// <object style=\"height: 390px; width: 640px\"><param\n\t\t\t\t\t\t// name=\"movie\"\n\t\t\t\t\t\t// value=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"><param\n\t\t\t\t\t\t// name=\"allowFullScreen\" value=\"true\"><param\n\t\t\t\t\t\t// name=\"allowScriptAccess\" value=\"always\"><embed\n\t\t\t\t\t\t// src=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"\n\t\t\t\t\t\t// type=\"application/x-shockwave-flash\"\n\t\t\t\t\t\t// allowfullscreen=\"true\" allowScriptAccess=\"always\"\n\t\t\t\t\t\t// width=\"640\" height=\"390\"><\/object>\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeObject\");\n\t\t\t\t\t\t// youtube seems ok with length and width\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"style\", getStyle(width, height)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.youtube_player\")));\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", youtubeUrl));\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeEmbed\").decorate(new UIFreeAttributeDecorator(\"type\", \"application/x-shockwave-flash\")).decorate(new UIFreeAttributeDecorator(\"src\", youtubeUrl));\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeURL\", youtubeUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id5\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtube-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"youtube-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.youtube\")));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description4\", i.getDescription());\n\t\t\t\t\t\t\n\t\t\t\t\t\t// as of Oct 28, 2010, we store the mime type. mimeType\n\t\t\t\t\t\t// null is an old entry.\n\t\t\t\t\t\t// For that use the old approach of checking the\n\t\t\t\t\t\t// extension.\n\t\t\t\t\t\t// Otherwise we want to use iframes for HTML and OBJECT\n\t\t\t\t\t\t// for everything else\n\t\t\t\t\t\t// We need the iframes because IE up through 8 doesn't\n\t\t\t\t\t\t// reliably display\n\t\t\t\t\t\t// HTML with OBJECT. Experiments show that everything\n\t\t\t\t\t\t// else works with OBJECT\n\t\t\t\t\t\t// for most browsers. Unfortunately IE, even IE 9,\n\t\t\t\t\t\t// doesn't reliably call the\n\t\t\t\t\t\t// right player with OBJECT. EMBED works. But it's not\n\t\t\t\t\t\t// as nice because you can't\n\t\t\t\t\t\t// nest error recovery code. So we use OBJECT for\n\t\t\t\t\t\t// everything except IE, where we\n\t\t\t\t\t\t// use EMBED. OBJECT does work with Flash.\n\t\t\t\t\t\t// application/xhtml+xml is XHTML.\n\n\t\t\t\t\t} else if ((mimeType != null && !mimeType.equals(\"text/html\") && !mimeType.equals(\"application/xhtml+xml\")) || (mimeType == null && Arrays.binarySearch(multimediaTypes, extension) >= 0)) {\n\n\t\t\t\t\t\t// this code is used for everything that isn't an image,\n\t\t\t\t\t\t// Youtube, or HTML. Typically\n\t\t\t\t\t\t// this is a flash presentation or a movie. Try to be\n\t\t\t\t\t\t// smart about how we show movies.\n\t\t\t\t\t\t// HTML is done with an IFRAME in the next \"if\" case\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles5\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups5\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIComponent item2;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"movieSpan\");\n\n\t\t\t\t\t\tString movieUrl = i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner());\n\t\t\t\t\t\tString oMimeType = mimeType; // in case we change it for\n\t\t\t\t\t\t// FLV or others\n\t\t\t\t\t\tboolean useFlvPlayer = false;\n\t\t\t\t\t\tboolean useJwPlayer = false;\n\t\t\t\t\t\t// in theory m4v can be DMRed. But Apple's DRM is\n\t\t\t\t\t\t// useless on a web page, so it's got to be an\n\t\t\t\t\t\t// unprotected file.\n\t\t\t\t\t\tboolean isMp4 = mimeType.equals(\"video/mp4\") || mimeType.equals(\"video/x-m4v\");\n\t\t\t\t\t\t// FLV is special. There's no player for flash video in\n\t\t\t\t\t\t// the browser\n\t\t\t\t\t\t// it shows with a special flash program, which I\n\t\t\t\t\t\t// supply. For the moment MP4 is\n\t\t\t\t\t\t// shown with the same player so it uses much of the\n\t\t\t\t\t\t// same code\n\t\t\t\t\t\tif (mimeType != null && (mimeType.equals(\"video/x-flv\") || isMp4)) {\n\t\t\t\t\t\t\tmimeType = \"application/x-shockwave-flash\";\n\t\t\t\t\t\t\tuseJwPlayer = ServerConfigurationService.getBoolean(\"lessonbuilder.usejwplayer\", false);\n\t\t\t\t\t\t\tif (useJwPlayer) {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/jwflvplayer.swf\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/StrobeMediaPlayback.swf\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuseFlvPlayer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// for IE, if we're not supplying a player it's safest\n\t\t\t\t\t\t// to use embed\n\t\t\t\t\t\t// otherwise Quicktime won't work. Oddly, with IE 9 only\n\t\t\t\t\t\t// it works if you set CLASSID to the MIME type,\n\t\t\t\t\t\t// but that's so unexpected that I hate to rely on it.\n\t\t\t\t\t\t// EMBED is in HTML 5, so I think we're OK\n\t\t\t\t\t\t// using it permanently for IE.\n\t\t\t\t\t\t// I prefer OBJECT where possible because of the nesting\n\t\t\t\t\t\t// ability.\n\t\t\t\t\t\tboolean useEmbed = ieVersion > 0 && !mimeType.equals(\"application/x-shockwave-flash\");\n\n\t\t\t\t\t\tif (useEmbed) {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieEmbed\").decorate(new UIFreeAttributeDecorator(\"src\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieObject\").decorate(new UIFreeAttributeDecorator(\"data\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mimeType != null) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", mimeType));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"style\", \"border: 1px solid black\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\tif (useFlvPlayer) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"flashvars\").decorate(new UIFreeAttributeDecorator(\"value\", (useJwPlayer ? \"file=\" : \"src=\") + URLEncoder.encode(myUrl() + i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", movieUrl));\n\t\t\t\t\t\t\tif (!isMp4) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-br\");\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"noplugin\", i.getName(), movieUrl);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isMp4) {\n\t\t\t\t\t\t\t// do fallback. for ie use EMBED\n\t\t\t\t\t\t\tif (ieVersion > 0) {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-embed\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-object\").decorate(new UIFreeAttributeDecorator(\"data\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (oMimeType != null) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", oMimeType));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-inject\").decorate(new UIFreeAttributeDecorator(\"value\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"mp4-noplugin\", i.getName(), i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype5\", oMimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id6\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movie-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"edit-movie\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description3\", i.getDescription());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// finally, HTML. Use an iframe\n\t\t\t\t\t\t// definition of resizeiframe, at top of page\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles2\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups2\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"iframe\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\t\t\t\t\t\t// if user specifies auto, use Javascript to resize the\n\t\t\t\t\t\t// iframe when the\n\t\t\t\t\t\t// content changes. This only works for URLs with the\n\t\t\t\t\t\t// same origin, i.e.\n\t\t\t\t\t\t// URLs in this sakai system\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"onload\", \"resizeiframe('\" + item.getFullID() + \"')\"));\n\t\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", \"300\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// we seem OK without a spec\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.web_content\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype3\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id3\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"Printing Description\");\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description5\", i.getDescription());\n\t\t\t\t\t}\n\n\t\t\t\t\t// end of multimedia object\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.COMMENTS) {\n\t\t\t\t\t// Load later using AJAX and CommentsProducer\n\n\t\t\t\t\tUIOutput.make(tableRow, \"commentsSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.fake-missing-prereqs\"));\n\n\t\t\t\t\t// students get warning and not the content\n\t\t\t\t\tif (!isAvailable && !canEditPage) {\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.missing-prereqs\"));\n\t\t\t\t\t}else {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsDiv\");\n\t\t\t\t\t\tPlacement placement = toolManager.getCurrentPlacement();\n\t\t\t\t\t\tUIOutput.make(tableRow, \"placementId\", placement.getId());\n\n\t\t\t\t\t\tCommentsViewParameters eParams = new CommentsViewParameters(CommentsProducer.VIEW_ID);\n\t\t\t\t\t\teParams.itemId = i.getId();\n\t\t\t\t\t\tif (params.postedComment) {\n\t\t\t\t\t\t\teParams.postedComment = postedCommentId;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(params.author != null && !params.author.equals(\"\")) {\n\t\t\t\t\t\t\teParams.author = params.author;\n\t\t\t\t\t\t\teParams.showAllComments = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"commentsLink\", eParams);\n\n\t\t\t\t\t\tif (!addedCommentsScript) {\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"comments-script\");\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"fckScript\");\n\t\t\t\t\t\t\taddedCommentsScript = true;\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"delete-dialog\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// forced comments have to be edited on the main page\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\t// Checks to make sure that the comments item isn't on a student page.\n\t\t\t\t\t\t\t// That it is graded.  And that we didn't just come from the grading pane.\n\t\t\t\t\t\t\tif(i.getPageId() > 0 && i.getGradebookId() != null && !cameFromGradingPane) {\n\t\t\t\t\t\t\t\tGradingPaneViewParameters gp = new GradingPaneViewParameters(GradingPaneProducer.VIEW_ID);\n\t\t\t\t\t\t\t\tgp.commentsItemId = i.getId();\n\t\t\t\t\t\t\t\tgp.pageId = currentPage.getPageId();\n\t\t\t\t\t\t\t\tgp.pageItemId = pageItem.getId();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tUIInternalLink.make(tableRow, \"gradingPaneLink\", messageLocator.getMessage(\"simplepage.show-grading-pane\"), gp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"comments-td\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (i.getSequence() > 0) {\n\t\t\t\t\t\t\t    UILink.make(tableRow, \"edit-comments\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.comments\")));\n\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsGrade\", String.valueOf(i.getGradebookId() != null));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsMaxPoints\", String.valueOf(i.getGradebookPoints()));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    String itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\t    if (itemGroupString != null) {\n\t\t\t\t\t\t\t    \tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\t    \tif (itemGroupTitles != null) {\n\t\t\t\t\t\t\t    \t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t\t    \t}\n\t\t\t\t\t\t\t    \tUIOutput.make(tableRow, \"comments-groups\", itemGroupString);\n\t\t\t\t\t\t\t    \tUIOutput.make(tableRow, \"item-group-titles6\", itemGroupTitles);\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    \t\n\t\t\t\t\t\t\t// Allows AJAX posting of comment grades\n\t\t\t\t\t    \tprintGradingForm(tofill);\n\t\t\t\t\t    }\n\n\t\t\t\t\t    UIForm form = UIForm.make(tableRow, \"comment-form\");\n\n\t\t\t\t\t    UIInput.make(form, \"comment-item-id\", \"#{simplePageBean.itemId}\", String.valueOf(i.getId()));\n\t\t\t\t\t    UIInput.make(form, \"comment-edit-id\", \"#{simplePageBean.editId}\");\n\n\t\t\t\t\t    // usage * image is required and not done\n\t\t\t\t\t    if (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\tUIOutput.make(tableRow, \"comment-required-image\");\n\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-link\");\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-text\", messageLocator.getMessage(\"simplepage.add-comment\"));\n\t\t\t\t\t    UIInput fckInput = UIInput.make(form, \"comment-text-area-evolved:\", \"#{simplePageBean.formattedComment}\");\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"height\", \"175\"));\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"width\", \"800\"));\n\t\t\t\t\t    fckInput.decorate(new UIStyleDecorator(\"evolved-box\"));\n\n\t\t\t\t\t    ((SakaiFCKTextEvolver) richTextEvolver).evolveTextInput(fckInput, \"\" + commentsCount);\n\n\t\t\t\t\t    UICommand.make(form, \"add-comment\", \"#{simplePageBean.addComment}\");\n\t\t\t\t\t}\n\n\t\t\t\t}else if(i.getType() == SimplePageItem.STUDENT_CONTENT) {\n\t\t\t\t\tUIOutput.make(tableRow, \"studentSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-fake-missing-prereqs\"));\n\t\t\t\t\telse if (!isAvailable && !canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-missing-prereqs\"));\n\t\t\t\t\telse {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentDiv\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tHashMap<Long, SimplePageLogEntry> cache = simplePageBean.cacheStudentPageLogEntries(i.getId());\n\t\t\t\t\t\tList<SimpleStudentPage> studentPages = simplePageToolDao.findStudentPages(i.getId());\n\t\t\t\t\t\n\t\t\t\t\t\tboolean hasOwnPage = false;\n\t\t\t\t\t\tString userId = UserDirectoryService.getCurrentUser().getId();\n\t\t\t\t\t\t\n\t\t\t\t\t\tHashMap<String, String> anonymousLookup = new HashMap<String, String>();\n\t\t\t\t\t\tif(i.isAnonymous()) {\n\t\t\t\t\t\t\tint counter = 1;\n\t\t\t\t\t\t\tfor(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\t\t\tif(anonymousLookup.get(page.getOwner()) == null) {\n\t\t\t\t\t\t\t\t\tanonymousLookup.put(page.getOwner(), messageLocator.getMessage(\"simplepage.anonymous\") + \" \" + counter++);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t    Collections.sort(studentPages, new Comparator<SimpleStudentPage>() {\n\t\t\t\t\t\t    public int compare(SimpleStudentPage o1, SimpleStudentPage o2) {\n\t\t\t\t\t\t\tString title1 = o1.getTitle();\n\t\t\t\t\t\t\tif (title1 == null)\n\t\t\t\t\t\t\t    title1 = \"\";\n\t\t\t\t\t\t\tString title2 = o2.getTitle();\n\t\t\t\t\t\t\tif (title2 == null)\n\t\t\t\t\t\t\t    title2 = \"\";\n\t\t\t\t\t\t\treturn title1.compareTo(title2);\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t});\t\t\t\t\t    \n\n\t\t\t\t\t\t// Print each row in the table\n\t\t\t\t\t\tfor(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\t\tif(page.isDeleted()) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tSimplePageLogEntry entry = cache.get(page.getPageId());\n\t\t\t\t\t\t\tUIBranchContainer row = UIBranchContainer.make(tableRow, \"studentRow:\");\n\t\t\t\t\t\t\tUIOutput.make(row, \"studentCell\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, page.getPageId());\n\t\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\t\teParams.setPath(\"push\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString studentTitle = page.getTitle();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(!i.isAnonymous() || canEditPage) {\n\t\t\t\t\t\t\t\t\tString ownerName = UserDirectoryService.getUser(page.getOwner()).getDisplayName();\n\t\t\t\t\t\t\t\t\tif (ownerName != null && ownerName.equals(studentTitle))\n\t\t\t\t\t\t\t\t\t    studentTitle = \"(\" + ownerName + \")\";\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t    studentTitle += \" (\" + UserDirectoryService.getUser(page.getOwner()).getDisplayName() + \")\";\n\t\t\t\t\t\t\t\t}else if(page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\t\t\tstudentTitle += \" (\" + messageLocator.getMessage(\"simplepage.comment-you\") + \")\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIInternalLink.make(row, \"studentLink\", studentTitle, eParams);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Never visited page\n\t\t\t\t\t\t\tif(entry == null) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"newPageImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-page\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// There's content they haven't seen\n\t\t\t\t\t\t\tif(entry == null || entry.getLastViewed().compareTo(page.getLastUpdated()) < 0) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"newContentImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-content\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// The comments tool exists, so we might have to show the icon\n\t\t\t\t\t\t\tif(i.getShowComments() != null && i.getShowComments()) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"commentsImgCell\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// New comments have been added since they last viewed the page\n\t\t\t\t\t\t\tif(page.getLastCommentChange() != null && (entry == null || entry.getLastViewed().compareTo(page.getLastCommentChange()) < 0)) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"newCommentsImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-comments\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\t\thasOwnPage = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i.getGradebookId() != null && simplePageBean.getEditPrivs() == 0) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"studentGradingCell\", String.valueOf((page.getPoints() != null? page.getPoints() : \"\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t\tif(!hasOwnPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"linkRow\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"linkCell\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"student-required-image\");\n\t\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID);\n\t\t\t\t\t\t\teParams.addTool = GeneralViewParameters.STUDENT_PAGE;\n\t\t\t\t\t\t\teParams.studentItemId = i.getId();\n\t\t\t\t\t\t\tUIInternalLink.make(tableRow, \"linkLink\", messageLocator.getMessage(\"simplepage.add-page\"), eParams);\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tif(canEditPage) {\n\t\t\t\t\t\t\t// Checks to make sure that the comments are graded and that we didn't\n\t\t\t\t\t\t\t// just come from a grading pane (would be confusing)\n\t\t\t\t\t\t\tif(i.getAltGradebook() != null && !cameFromGradingPane) {\n\t\t\t\t\t\t\t\tGradingPaneViewParameters gp = new GradingPaneViewParameters(GradingPaneProducer.VIEW_ID);\n\t\t\t\t\t\t\t\tgp.commentsItemId = i.getId();\n\t\t\t\t\t\t\t\tgp.pageId = currentPage.getPageId();\n\t\t\t\t\t\t\t\tgp.pageItemId = pageItem.getId();\n\t\t\t\t\t\t\t\tgp.studentContentItem = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tUIInternalLink.make(tableRow, \"studentGradingPaneLink\", messageLocator.getMessage(\"simplepage.show-grading-pane\"), gp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"student-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"edit-student\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.student\")));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentComments\", String.valueOf(i.getShowComments()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"forcedAnon\", String.valueOf(i.getForcedCommentsAnonymous()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentGrade\", String.valueOf(i.getGradebookId() != null));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentMaxPoints\", String.valueOf(i.getGradebookPoints()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentGrade2\", String.valueOf(i.getAltGradebook() != null));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentMaxPoints2\", String.valueOf(i.getAltPoints()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"student-groups\", itemGroupString);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles7\", itemGroupTitles);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}  else {\n\t\t\t\t\t// remaining type must be a block of HTML\n\t\t\t\t\tUIOutput.make(tableRow, \"itemSpan\");\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups-titles-text\", itemGroupTitles);\n\n\t\t\t\t\tUIVerbatim.make(tableRow, \"content\", (i.getHtml() == null ? \"\" : i.getHtml()));\n\n\t\t\t\t\t// editing is done using a special producer that calls FCK.\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters();\n\t\t\t\t\t\teParams.setSendingPage(currentPage.getPageId());\n\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\teParams.viewID = EditPageProducer.VIEW_ID;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edittext-td\");\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), eParams).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.textbox\").replace(\"{}\", Integer.toString(textboxcount))));\n\n\t\t\t\t\t\ttextboxcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// end of items. This is the end for normal users. Following is\n\t\t\t// special\n\t\t\t// checks and putting out the dialogs for the popups, for\n\t\t\t// instructors.\n\n\t\t\tboolean showBreak = false;\n\n\t\t\t// I believe refresh is now done automatically in all cases\n\t\t\t// if (showRefresh) {\n\t\t\t// UIOutput.make(tofill, \"refreshAlert\");\n\t\t\t//\n\t\t\t// // Should simply refresh\n\t\t\t// GeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\t// p.setSendingPage(currentPage.getPageId());\n\t\t\t// UIInternalLink.make(tofill, \"refreshLink\", p);\n\t\t\t// showBreak = true;\n\t\t\t// }\n\n\t\t\t// stuff goes on the page in the order in the HTML file. So the fact\n\t\t\t// that it's here doesn't mean it shows\n\t\t\t// up at the end. This code produces errors and other odd stuff.\n\n\t\t\tif (canEditPage) {\n\t\t\t\t// if the page is hidden, warn the faculty [students get stopped\n\t\t\t\t// at\n\t\t\t\t// the top]\n\t\t\t\tif (currentPage.isHidden()) {\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.pagehidden\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.pagehidden.text\"));\n\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t\t// similarly warn them if it isn't released yet\n\t\t\t\t} else if (currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\t\t\tdf.setTimeZone(tz);\n\t\t\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.notreleased\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.notreleased.text\").replace(\"{}\", releaseDate));\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showBreak) {\n\t\t\t\tUIOutput.make(tofill, \"breakAfterWarnings\");\n\t\t\t}\n\t\t}\n\n\t\t// more warnings: if no item on the page, give faculty instructions,\n\t\t// students an error\n\t\tif (itemList.size() == 0) {\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"startupHelp\")\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"src\", \n\t\t\t\t\tgetLocalizedURL( (pageItem.getType() == SimplePageItem.STUDENT_CONTENT) ? \"student.html\" : \"general.html\")))\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"id\", \"iframe\"));\n\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.noitems_error_user\"));\n\t\t\t}\n\t\t}\n\n\t\t// now output the dialogs. but only for faculty (to avoid making the\n\t\t// file bigger)\n\t\tif (canEditPage) {\n\t\t\tcreateSubpageDialog(tofill, currentPage);\n\t\t}\n\n\t\tcreateDialogs(tofill, currentPage, pageItem);\n\t}","id":86052,"modified_method":"public void fillComponents(UIContainer tofill, ViewParameters viewParams, ComponentChecker checker) {\n\t\tGeneralViewParameters params = (GeneralViewParameters) viewParams;\n\t\t\n\t\t// security model:\n\t\t// canEditPage and canReadPage are normal Sakai privileges. They apply\n\t\t// to all\n\t\t// pages in the site.\n\t\t// However when presented with a page, we need to make sure it's\n\t\t// actually in\n\t\t// this site, or users could get to pages in other sites. That's done\n\t\t// by updatePageObject. The model is that producers always work on the\n\t\t// current page, and updatePageObject makes sure that is in the current\n\t\t// site.\n\t\t// At that point we can safely use canEditPage.\n\n\t\t// somewhat misleading. sendingPage specifies the page we're supposed to\n\t\t// go to.  If path is \"none\", we don't want this page to be what we see\n\t\t// when we come back to the tool\n\t\tif (params.getSendingPage() != -1) {\n\t\t\t// will fail if page not in this site\n\t\t\t// security then depends upon making sure that we only deal with\n\t\t\t// this page\n\t\t\ttry {\n\t\t\t\tsimplePageBean.updatePageObject(params.getSendingPage(), !params.getPath().equals(\"none\"));\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"ShowPage permission exception \" + e);\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean canEditPage = simplePageBean.canEditPage();\n\t\tboolean canReadPage = simplePageBean.canReadPage();\n\t\t\n\t\tboolean cameFromGradingPane = params.getPath().equals(\"none\");\n\n\t\tif (!canReadPage) {\n\t\t\t// this code is intended for the situation where site permissions\n\t\t\t// haven't been set up.\n\t\t\t// So if the user can't read the page (which is pretty abnormal),\n\t\t\t// see if they have site.upd.\n\t\t\t// if so, give them some explanation and offer to call the\n\t\t\t// permissions helper\n\t\t\tString ref = \"/site/\" + simplePageBean.getCurrentSiteId();\n\t\t\tif (simplePageBean.canEditSite()) {\n\t\t\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\t\tUIOutput.make(tofill, \"needPermissions\");\n\n\t\t\t\tGeneralViewParameters permParams = new GeneralViewParameters();\n\t\t\t\tpermParams.setSendingPage(-1L);\n\t\t\t\tcreateStandardToolBarLink(PermissionsHelperProducer.VIEW_ID, tofill, \"callpermissions\", \"simplepage.permissions\", permParams, \"simplepage.permissions.tooltip\");\n\n\t\t\t}\n\n\t\t\t// in any case, tell them they can't read the page\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.nopermissions\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.addTool == GeneralViewParameters.COMMENTS) {\n\t\t\tsimplePageBean.addCommentsSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_CONTENT) {\n\t\t\tsimplePageBean.addStudentContentSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_PAGE) {\n\t\t\tsimplePageBean.createStudentPage(params.studentItemId);\n\t\t\tcanEditPage = simplePageBean.canEditPage();\n\t\t}\n\n\t\t// error from previous operation\n\t\tString errMessage = simplePageBean.errMessage();\n\t\tif (errMessage != null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", errMessage);\n\t\t}\n\n\t\t// Find the MSIE version, if we're running it.\n\t\tint ieVersion = checkIEVersion();\n\n\t\tif (simplePageBean.getTopRefresh()) {\n\t\t\tUIOutput.make(tofill, \"refresh\");\n\t\t}\n\n\t\tif (canEditPage) {\n\t\t    // special instructor-only javascript setup.\n\t\t\tUIOutput.make(tofill, \"instructoronly\");\n\t\t}\n\n\t\t// set up locale\n\t\tLocale M_locale = null;\n\t\tString langLoc[] = localegetter.get().toString().split(\"_\");\n\t\tif (langLoc.length >= 2) {\n\t\t\tif (\"en\".equals(langLoc[0]) && \"ZA\".equals(langLoc[1])) {\n\t\t\t\tM_locale = new Locale(\"en\", \"GB\");\n\t\t\t} else {\n\t\t\t\tM_locale = new Locale(langLoc[0], langLoc[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tM_locale = new Locale(langLoc[0]);\n\t\t}\n\n\t\t// clear session attribute if necessary, after calling Samigo\n\t\tString clearAttr = params.getClearAttr();\n\n\t\tif (clearAttr != null && !clearAttr.equals(\"\")) {\n\t\t\tSession session = SessionManager.getCurrentSession();\n\t\t\t// don't let users clear random attributes\n\t\t\tif (clearAttr.startsWith(\"LESSONBUILDER_RETURNURL\")) {\n\t\t\t\tsession.setAttribute(clearAttr, null);\n\t\t\t}\n\t\t}\n\n\t\tif (multimediaTypes == null) {\n\t\t\tString mmTypes = ServerConfigurationService.getString(\"lessonbuilder.multimedia.types\", DEFAULT_TYPES);\n\t\t\tmultimediaTypes = mmTypes.split(\",\");\n\t\t\tfor (int i = 0; i < multimediaTypes.length; i++) {\n\t\t\t\tmultimediaTypes[i] = multimediaTypes[i].trim().toLowerCase();\n\t\t\t}\n\t\t\tArrays.sort(multimediaTypes);\n\t\t}\n\n\t\t// remember that page tool was reset, so we need to give user the option\n\t\t// of going to the last page from the previous session\n\t\tSimplePageToolDao.PageData lastPage = simplePageBean.toolWasReset();\n\n\t\t// if starting the tool, sendingpage isn't set. the following call\n\t\t// will give us the top page.\n\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\n\t\t// now we need to find our own item, for access checks, etc.\n\t\tSimplePageItem pageItem = null;\n\t\tif (currentPage != null) {\n\t\t\tpageItem = simplePageBean.getCurrentPageItem(params.getItemId());\n\t\t}\n\t\t// one more security check: make sure the item actually involves this\n\t\t// page.\n\t\t// otherwise someone could pass us an item from a different page in\n\t\t// another site\n\t\t// actually this normally happens if the page doesn't exist and we don't\n\t\t// have permission to create it\n\t\tif (currentPage == null || pageItem == null || \n\t\t    (pageItem.getType() != SimplePageItem.STUDENT_CONTENT &&Long.valueOf(pageItem.getSakaiId()) != currentPage.getPageId()) ||\n\t\t    !simplePageBean.isItemVisible(pageItem)) {\n\t\t\tlog.warn(\"ShowPage item not in page\");\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// I believe we've now checked all the args for permissions issues. All\n\t\t// other item and\n\t\t// page references are generated here based on the contents of the page\n\t\t// and items.\n\n\t\tif (currentPage == null || pageItem == null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.impossible1\"));\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Set up customizable CSS\n\t\tContentResource cssLink = simplePageBean.getCssForCurrentPage();\n\t\tif(cssLink != null) {\n\t\t\tUIOutput.make(tofill, \"customCSS\").decorate(new UIFreeAttributeDecorator(\"href\", cssLink.getUrl()));\n\t\t}\n\n\t\t// offer to go to saved page if this is the start of a session, in case\n\t\t// user has logged off and logged on again.\n\t\t// need to offer to go to previous page? even if a new session, no need\n\t\t// if we're already on that page\n\t\tif (lastPage != null && lastPage.pageId != currentPage.getPageId()) {\n\t\t\tUIOutput.make(tofill, \"refreshAlert\");\n\t\t\tUIOutput.make(tofill, \"refresh-message\", messageLocator.getMessage(\"simplepage.last-visited\"));\n\t\t\t// Should simply refresh\n\t\t\tGeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\tp.setSendingPage(lastPage.pageId);\n\t\t\tp.setItemId(lastPage.itemId);\n\t\t\t// reset the path to the saved one\n\t\t\tp.setPath(\"log\");\n\t\t\t\n\t\t\tString name = lastPage.name;\n\t\t\t\n\t\t\t// Titles are set oddly by Student Content Pages\n\t\t\tSimplePage lastPageObj = simplePageToolDao.getPage(lastPage.pageId);\n\t\t\tif(lastPageObj.getOwner() != null) {\n\t\t\t\tname = lastPageObj.getTitle();\n\t\t\t}\n\t\t\t\n\t\t\tUIInternalLink.make(tofill, \"refresh-link\", name, p);\n\t\t}\n\n\t\t// path is the breadcrumbs. Push, pop or reset depending upon path=\n\t\t// programmer documentation.\n\t\tString title;\n\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\ttitle = pageItem.getName();\n\t\t}else {\n\t\t\ttitle = currentPage.getTitle();\n\t\t}\n\t\t\n\t\tString newPath = null;\n\t\t\n\t\t// If the path is \"none\", then we don't want to record this page as being viewed, or set a path\n\t\tif(!params.getPath().equals(\"none\")) {\n\t\t\tnewPath = simplePageBean.adjustPath(params.getPath(), currentPage.getPageId(), pageItem.getId(), title);\n\t\t\tsimplePageBean.adjustBackPath(params.getBackPath(), currentPage.getPageId(), pageItem.getId(), pageItem.getName());\n\t\t}\n\t\t\n\t\t// potentially need time zone for setting release date\n\t\tif (!canEditPage && currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\tdf.setTimeZone(tz);\n\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\tString releaseMessage = messageLocator.getMessage(\"simplepage.not_yet_available_releasedate\").replace(\"{}\", releaseDate);\n\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", releaseMessage);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// put out link to index of pages\n\t\tGeneralViewParameters showAll = new GeneralViewParameters(PagePickerProducer.VIEW_ID);\n\t\tshowAll.setSource(\"summary\");\n\t\tUIInternalLink.make(tofill, \"show-pages\", messageLocator.getMessage(\"simplepage.showallpages\"), showAll);\n\t\t\n\t\tif (canEditPage) {\n\t\t\t// show tool bar, but not if coming from grading pane\n\t\t\tif(!cameFromGradingPane) {\n\t\t\t\tcreateToolBar(tofill, currentPage, (pageItem.getType() == SimplePageItem.STUDENT_CONTENT));\n\t\t\t}\n\t\t\t\n\t\t\tUIOutput.make(tofill, \"title-descrip\");\n\t\t\tString label = null;\n\t\t\tif (pageItem.getType() == SimplePageItem.STUDENT_CONTENT)\n\t\t\t    label = messageLocator.getMessage(\"simplepage.editTitle\");\n\t\t\telse\n\t\t\t    label = messageLocator.getMessage(\"simplepage.title\");\n\t\t\tString descrip = null;\n\t\t\tif (pageItem.getType() == SimplePageItem.STUDENT_CONTENT)\n\t\t\t    descrip = messageLocator.getMessage(\"simplepage.title-student-descrip\");\n\t\t\telse if (pageItem.getPageId() == 0)\n\t\t\t    descrip = messageLocator.getMessage(\"simplepage.title-top-descrip\");\n\t\t\telse\n\t\t\t    descrip = messageLocator.getMessage(\"simplepage.title-descrip\");\n\n\t\t\tUIOutput.make(tofill, \"edit-title\").decorate(new UIFreeAttributeDecorator(\"title\", descrip));\n\t\t\tUIOutput.make(tofill, \"edit-title-text\", label);\n\t\t\tUIOutput.make(tofill, \"title-descrip-text\", descrip);\n\n\t\t\tif (pageItem.getPageId() == 0) { // top level page\n\t\t\t\tUIOutput.make(tofill, \"toppage-descrip\");\n\t\t\t\tUIOutput.make(tofill, \"new-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-page-tooltip\")));\n\t\t\t\tUIOutput.make(tofill, \"import-cc\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.import_cc\")));\n\t\t\t}\n\t\t\t\n\t\t\t// Checks to see that user can edit and that this is either a top level page,\n\t\t\t// or a top level student page (not a subpage to a student page)\n\t\t\tif(simplePageBean.getEditPrivs() == 0 && (pageItem.getPageId() == 0)) {\n\t\t\t\tUIOutput.make(tofill, \"remove-descrip\");\n\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t} else if (simplePageBean.getEditPrivs() == 0 && currentPage.getOwner() != null) {\n\t\t\t\tSimpleStudentPage studentPage = simplePageToolDao.findStudentPage(currentPage.getTopParent());\n\t\t\t\tif (studentPage != null && studentPage.getPageId() == currentPage.getPageId()) {\n\t\t\t\t\tUIOutput.make(tofill, \"remove-descrip\");\n\t\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUIOutput.make(tofill, \"dialogDiv\");\n\t\t} else if (!canReadPage)\n\t\t\treturn;\n\t\telse {\n\t\t\t// see if there are any unsatisfied prerequisites\n\t\t\tList<String> needed = simplePageBean.pagesNeeded(pageItem);\n\t\t\tif (needed.size() > 0) {\n\t\t\t\t// yes. error and abort\n\t\t\t\tif (pageItem.getPageId() != 0) {\n\t\t\t\t\t// not top level. This should only happen from a \"next\"\n\t\t\t\t\t// link.\n\t\t\t\t\t// at any rate, the best approach is to send the user back\n\t\t\t\t\t// to the calling page\n\t\t\t\t\tList<SimplePageBean.PathEntry> path = simplePageBean.getHierarchy();\n\t\t\t\t\tSimplePageBean.PathEntry containingPage = null;\n\t\t\t\t\tif (path.size() > 1) {\n\t\t\t\t\t\t// page above this. this page is on the top\n\t\t\t\t\t\tcontainingPage = path.get(path.size() - 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (containingPage != null) { // not a top level page, point\n\t\t\t\t\t\t// to containing page\n\t\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\t\tview.setSendingPage(containingPage.pageId);\n\t\t\t\t\t\tview.setItemId(containingPage.pageItemId);\n\t\t\t\t\t\tview.setPath(Integer.toString(path.size() - 2));\n\t\t\t\t\t\tUIInternalLink.make(tofill, \"redirect-link\", containingPage.title, view);\n\t\t\t\t\t\tUIOutput.make(tofill, \"redirect\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// top level page where prereqs not satisified. Output list of\n\t\t\t\t// pages he needs to do first\n\t\t\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.has_prerequistes\"));\n\t\t\t\tUIBranchContainer errorList = UIBranchContainer.make(tofill, \"error-list:\");\n\t\t\t\tfor (String errorItem : needed) {\n\t\t\t\t\tUIBranchContainer errorListItem = UIBranchContainer.make(errorList, \"error-item:\");\n\t\t\t\t\tUIOutput.make(errorListItem, \"error-item-text\", errorItem);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tToolSession toolSession = SessionManager.getCurrentToolSession();\n\t\tString helpurl = (String)toolSession.getAttribute(\"sakai-portal:help-action\");\n\t\tString reseturl = (String)toolSession.getAttribute(\"sakai-portal:reset-action\");\n\n\t\tif (helpurl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"helpbutton\" : \"helpbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"openWindow('\" + helpurl + \"', 'Help', 'resizeable=yes,toolbar=no,scrollbars=yes,menubar=yes,width=800,height=600'); return false\"));\n\n\t\tif (reseturl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"resetbutton\" : \"resetbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"location.href='\" + reseturl + \"'; return false\"));\n\n\t\t// note page accessed. the code checks to see whether all the required\n\t\t// items on it have been finished, and if so marks it complete, else just updates\n\t\t// access date save the path because if user goes to it later we want to restore the\n\t\t// breadcrumbs\n\t\tif(newPath != null) {\n\t\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\t\tsimplePageBean.track(pageItem.getId(), newPath);\n\t\t\t}else {\n\t\t\t\tsimplePageBean.track(pageItem.getId(), newPath, currentPage.getPageId());\n\t\t\t}\n\t\t}\n\n\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\t\t\n\t\tif(currentPage.getOwner() != null && simplePageBean.getEditPrivs() == 0) {\n\t\t\tSimpleStudentPage student = simplePageToolDao.findStudentPageByPageId(currentPage.getPageId());\n\t\t\t\n\t\t\t// Make sure this is a top level student page\n\t\t\tif(student != null) {\n\t\t\t\tUIOutput.make(tofill, \"gradingSpan\");\n\t\t\t\tUIOutput.make(tofill, \"commentsUUID\", String.valueOf(student.getId()));\n\t\t\t\tUIOutput.make(tofill, \"commentPoints\", String.valueOf((student.getPoints() != null? student.getPoints() : \"\")));\n\t\t\t\n\t\t\t\tList<SimpleStudentPage> studentPages = simplePageToolDao.findStudentPages(student.getItemId());\n\t\t\t\t\n\t\t\t\tCollections.sort(studentPages, new Comparator<SimpleStudentPage>() {\n\t\t\t\t\tpublic int compare(SimpleStudentPage o1, SimpleStudentPage o2) {\n\t\t\t\t\t\tString title1 = o1.getTitle();\n\t\t\t\t\t\tif (title1 == null)\n\t\t\t\t\t\t\ttitle1 = \"\";\n\t\t\t\t\t\tString title2 = o2.getTitle();\n\t\t\t\t\t\tif (title2 == null)\n\t\t\t\t\t\t\ttitle2 = \"\";\n\t\t\t\t\t\treturn title1.compareTo(title2);\n\t\t\t\t    }\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfor(int in = 0; in < studentPages.size(); in++) {\n\t\t\t\t\tif(studentPages.get(in).isDeleted()) {\n\t\t\t\t\t\tstudentPages.remove(in);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint i = -1;\n\t\t\t\n\t\t\t\tfor(int in = 0; in < studentPages.size(); in++) {\n\t\t\t\t\tif(student.getId() == studentPages.get(in).getId()) {\n\t\t\t\t\t\ti = in;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(i > 0) {\n\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, studentPages.get(i-1).getPageId());\n\t\t\t\t\teParams.setItemId(studentPages.get(i-1).getItemId());\n\t\t\t\t\teParams.setPath(\"next\");\n\t\t\t\t\n\t\t\t\t\tUIInternalLink.make(tofill, \"gradingBack\", eParams);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif(i < studentPages.size() - 1) {\n\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, studentPages.get(i+1).getPageId());\n\t\t\t\t\teParams.setItemId(studentPages.get(i+1).getItemId());\n\t\t\t\t\teParams.setPath(\"next\");\n\t\t\t\t\n\t\t\t\t\tUIInternalLink.make(tofill, \"gradingForward\", eParams);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tprintGradingForm(tofill);\n\t\t\t}\n\t\t}\n\n\t\t// breadcrumbs\n\t\tif (pageItem.getPageId() != 0) {\n\t\t\t// Not top-level, so we have to show breadcrumbs\n\n\t\t\tList<SimplePageBean.PathEntry> breadcrumbs = simplePageBean.getHierarchy();\n\n\t\t\tint index = 0;\n\t\t\tif (breadcrumbs.size() > 1) {\n\t\t\t\tUIOutput.make(tofill, \"crumbdiv\");\n\t\t\t\tfor (SimplePageBean.PathEntry e : breadcrumbs) {\n\t\t\t\t\t// don't show current page. We already have a title. This\n\t\t\t\t\t// was too much\n\t\t\t\t\tUIBranchContainer crumb = UIBranchContainer.make(tofill, \"crumb:\");\n\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\tview.setSendingPage(e.pageId);\n\t\t\t\t\tview.setItemId(e.pageItemId);\n\t\t\t\t\tview.setPath(Integer.toString(index));\n\t\t\t\t\tif (index < breadcrumbs.size() - 1) {\n\t\t\t\t\t\t// Not the last item\n\t\t\t\t\t\tUIInternalLink.make(crumb, \"crumb-link\", e.title, view);\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", \" > \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", e.title).decorate(new UIStyleDecorator(\"bold\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// see if there's a next item in sequence.\n\t\tsimplePageBean.addPrevLink(tofill, pageItem);\n\t\tsimplePageBean.addNextLink(tofill, pageItem);\n\n\t\t// swfObject is not currently used\n\t\tboolean shownSwfObject = false;\n\n\t\t// items to show\n\t\tList<SimplePageItem> itemList = (List<SimplePageItem>) simplePageBean.getItemsOnPage(currentPage.getPageId());\n\t\t\n\t\t// Move all items with sequence <= 0 to the end of the list.\n\t\t// Count is necessary to guarantee we don't infinite loop over a\n\t\t// list that only has items with sequence <= 0.\n\t\tint count = 1;\n\t\twhile(itemList.size() > count && itemList.get(0).getSequence() <= 0) {\n\t\t\titemList.add(itemList.remove(0));\n\t\t\tcount++;\n\t\t}\n\n\t\t// Make sure we only add the comments javascript file once,\n\t\t// even if there are multiple comments tools on the page.\n\t\tboolean addedCommentsScript = false;\n\t\tint commentsCount = 0;\n\n\t\t// Find the most recent comment on the page by current user\n\t\tlong postedCommentId = -1;\n\t\tif (params.postedComment) {\n\t\t\tpostedCommentId = findMostRecentComment();\n\t\t}\n\n\t\t//\n\t\t//\n\t\t// MAIN list of items\n\t\t//\n\t\t// produce the main table\n\t\tif (itemList.size() > 0) {\n\t\t\tUIBranchContainer container = UIBranchContainer.make(tofill, \"itemContainer:\");\n\n\t\t\tboolean showRefresh = false;\n\t\t\tint textboxcount = 1;\n\n\t\t\tUIBranchContainer tableContainer = UIBranchContainer.make(container, \"itemTable:\");\n\n\t\t\t// formatting: two columns:\n\t\t\t// 1: edit buttons, omitted for student\n\t\t\t// 2: main content\n\t\t\t// For links, which have status icons, the main content is a flush\n\t\t\t// left div with the icon\n\t\t\t// followed by a div with margin-left:30px. That takes it beyond the\n\t\t\t// icon, and avoids the\n\t\t\t// wrap-around appearance you'd get without the margin.\n\t\t\t// Normally the description is shown as a second div with\n\t\t\t// indentation in the CSS.\n\t\t\t// That puts it below the link. However with a link that's a button,\n\t\t\t// we do float left\n\t\t\t// for the button so the text wraps around it. I think that's\n\t\t\t// probably what people would expect.\n\n\t\t\tUIOutput.make(tableContainer, \"colgroup\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"col1\");\n\t\t\t}\n\t\t\tUIOutput.make(tableContainer, \"col2\");\n\n\t\t\t// the table header is for accessibility tools only, so it's\n\t\t\t// positioned off screen\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"header-edits\");\n\t\t\t}\n\n\t\t\tUIOutput.make(tableContainer, \"header-items\");\n\n\t\t\tfor (SimplePageItem i : itemList) {\n\n\t\t\t\t// listitem is mostly historical. it uses some shared HTML, but\n\t\t\t\t// if I were\n\t\t\t\t// doing it from scratch I wouldn't make this distinction. At\n\t\t\t\t// the moment it's\n\t\t\t\t// everything that isn't inline.\n\n\t\t\t\tboolean listItem = !(i.getType() == SimplePageItem.TEXT || i.getType() == SimplePageItem.MULTIMEDIA\n\t\t\t\t\t\t|| i.getType() == SimplePageItem.COMMENTS || i.getType() == SimplePageItem.STUDENT_CONTENT);\n\t\t\t\t// (i.getType() == SimplePageItem.PAGE &&\n\t\t\t\t// \"button\".equals(i.getFormat())))\n\n\t\t\t\tUIBranchContainer tableRow = UIBranchContainer.make(tableContainer, \"item:\");\n\t\t\t\tif (!simplePageBean.isItemVisible(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// you really need the HTML file open at the same time to make\n\t\t\t\t// sense of the following code\n\t\t\t\tif (listItem) { // Not an HTML Text, Element or Multimedia\n\t\t\t\t\t// Element\n\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id2\", String.valueOf(i.getId()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// users can declare a page item to be navigational. If so\n\t\t\t\t\t// we display\n\t\t\t\t\t// it to the left of the normal list items, and use a\n\t\t\t\t\t// button. This is\n\t\t\t\t\t// used for pages that are \"next\" pages, i.e. they replace\n\t\t\t\t\t// this page\n\t\t\t\t\t// rather than creating a new level in the breadcrumbs.\n\t\t\t\t\t// Since they can't\n\t\t\t\t\t// be required, they don't need the status image, which is\n\t\t\t\t\t// good because\n\t\t\t\t\t// they're displayed with colspan=2, so there's no space for\n\t\t\t\t\t// the image.\n\n\t\t\t\t\tboolean navButton = \"button\".equals(i.getFormat()) && !i.isRequired();\n\t\t\t\t\tboolean notDone = false;\n\t\t\t\t\tStatus status = Status.NOT_REQUIRED;\n\t\t\t\t\tif (!navButton) {\n\t\t\t\t\t\tstatus = handleStatusImage(tableRow, i);\n\t\t\t\t\t\tif (status == Status.REQUIRED) {\n\t\t\t\t\t\t\tnotDone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean isInline = (i.getType() == SimplePageItem.BLTI && \"inline\".equals(i.getFormat()));\n\n\t\t\t\t\tUIOutput linktd = UIOutput.make(tableRow, \"item-td\");\n\t\t\t\t\tUIBranchContainer linkdiv = null;\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    linkdiv = UIBranchContainer.make(tableRow, \"link-div:\");\n\t\t\t\t\t    UIOutput itemicon = UIOutput.make(linkdiv,\"item-icon\");\n\t\t\t\t\t    switch (i.getType()) {\n\t\t\t\t\t    case SimplePageItem.FORUM:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/comments.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/page_edit.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/pencil.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.BLTI:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/application_go.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.PAGE:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/book_open.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.RESOURCE:\n\t\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\t\t\n\t\t\t\t\t\tString src = imageToMimeMap.get(mimeType);\n\t\t\t\t\t\tif (src == null) {\n\t\t\t\t\t\t    String image = ContentTypeImageService.getContentTypeImage(mimeType);\n\t\t\t\t\t\t    if (image != null)\n\t\t\t\t\t\t\tsrc = \"/library/image/\" + image;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(src != null) {\n\t\t\t\t\t\t    itemicon.decorate(new UIFreeAttributeDecorator(\"src\", src));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput descriptiondiv = null;\n\n\t\t\t\t\t// refresh isn't actually used anymore. We've changed the\n\t\t\t\t\t// way things are\n\t\t\t\t\t// done so the user never has to request a refresh.\n\t\t\t\t\t//   FYI: this actually puts in an IFRAME for inline BLTI items\n\t\t\t\t\tshowRefresh = !makeLink(tableRow, \"link\", i, canEditPage, currentPage, notDone, status) || showRefresh;\n\n\t\t\t\t\t// dummy is used when an assignment, quiz, or forum item is\n\t\t\t\t\t// copied\n\t\t\t\t\t// from another site. The way the copy code works, our\n\t\t\t\t\t// import code\n\t\t\t\t\t// doesn't have access to the necessary info to use the item\n\t\t\t\t\t// from the\n\t\t\t\t\t// new site. So we add a dummy, which generates an\n\t\t\t\t\t// explanation that the\n\t\t\t\t\t// author is going to have to choose the item from the\n\t\t\t\t\t// current site\n\t\t\t\t\tif (i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\tString code = null;\n\t\t\t\t\t\tswitch (i.getType()) {\n\t\t\t\t\t\tcase SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assignment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assessment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.FORUM:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.forum\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", messageLocator.getMessage(code));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", i.getDescription());\n\t\t\t\t\t}\n\t\t\t\t\tif (isInline)\n\t\t\t\t\t    descriptiondiv.decorate(new UIFreeAttributeDecorator(\"style\", \"margin-top: 4px\"));\n\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    // nav button gets float left so any description goes to its\n\t\t\t\t\t    // right. Otherwise the\n\t\t\t\t\t    // description block will display underneath\n\t\t\t\t\t    if (\"button\".equals(i.getFormat())) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"style\", \"float:left\"));\n\t\t\t\t\t    }\n\t\t\t\t\t    // for accessibility\n\t\t\t\t\t    if (navButton) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"role\", \"navigation\"));\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\t// note that a lot of the info here is used by the\n\t\t\t\t\t// javascript that prepares\n\t\t\t\t\t// the jQuery dialogs\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-td\");\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.generic\").replace(\"{}\", i.getName())));\n\n\t\t\t\t\t\t// the following information is displayed using <INPUT\n\t\t\t\t\t\t// type=hidden ...\n\t\t\t\t\t\t// it contains information needed to populate the \"edit\"\n\t\t\t\t\t\t// popup dialog\n\t\t\t\t\t\tUIOutput.make(tableRow, \"prerequisite-info\", String.valueOf(i.isPrerequisite()));\n\n\t\t\t\t\t\tString itemGroupString = null;\n\n\t\t\t\t\t\tif (i.getType() == SimplePageItem.ASSIGNMENT) {\n\t\t\t\t\t\t\t// the type indicates whether scoring is letter\n\t\t\t\t\t\t\t// grade, number, etc.\n\t\t\t\t\t\t\t// the javascript needs this to present the right\n\t\t\t\t\t\t\t// choices to the user\n\t\t\t\t\t\t\t// types 6 and 8 aren't legal scoring types, so they\n\t\t\t\t\t\t\t// are used as\n\t\t\t\t\t\t\t// markers for quiz or forum. I ran out of numbers\n\t\t\t\t\t\t\t// and started using\n\t\t\t\t\t\t\t// text for things that aren't scoring types. That's\n\t\t\t\t\t\t\t// better anyway\n\t\t\t\t\t\t\tint type = 4;\n\t\t\t\t\t\t\tLessonEntity assignment = null;\n\t\t\t\t\t\t\tif (!i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\t\t\tassignment = assignmentEntity.getEntity(i.getSakaiId(), simplePageBean);\n\t\t\t\t\t\t\t\tif (assignment != null) {\n\t\t\t\t\t\t\t\t\ttype = assignment.getTypeOfGrade();\n\t\t\t\t\t\t\t\t\tString editUrl = assignment.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, assignment, true);\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", String.valueOf(type));\n\t\t\t\t\t\t\tString requirement = String.valueOf(i.getSubrequirement());\n\t\t\t\t\t\t\tif ((type == SimplePageItem.PAGE || type == SimplePageItem.ASSIGNMENT) && i.getSubrequirement()) {\n\t\t\t\t\t\t\t\trequirement = i.getRequirementText();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", requirement);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.ASSESSMENT) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"6\"); // Not used by\n\t\t\t\t\t\t\t// assignments,\n\t\t\t\t\t\t\t// so it is\n\t\t\t\t\t\t\t// safe to dedicate to assessments\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", (i.getSubrequirement() ? i.getRequirementText() : \"false\"));\n\t\t\t\t\t\t\tLessonEntity quiz = quizEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (quiz != null) {\n\t\t\t\t\t\t\t\tString editUrl = quiz.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teditUrl = quiz.editItemSettingsUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-settings-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, quiz, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.BLTI) {\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"type\", \"b\");\n\t\t\t\t\t\t    LessonEntity blti= (bltiEntity == null ? null : bltiEntity.getEntity(i.getSakaiId()));\n\t\t\t\t\t\t    if (blti != null) {\n\t\t\t\t\t\t\tString editUrl = blti.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\tif (editUrl != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-format\", i.getFormat());\n\n\t\t\t\t\t\t\tif (i.getHeight() != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-height\", i.getHeight());\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.FORUM) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"extra-info\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"8\");\n\t\t\t\t\t\t\tLessonEntity forum = forumEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (forum != null) {\n\t\t\t\t\t\t\t\tString editUrl = forum.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, forum, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.PAGE) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"page\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-next\", Boolean.toString(i.getNextPage()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-button\", Boolean.toString(\"button\".equals(i.getFormat())));\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.RESOURCE) {\n\t\t\t\t\t\t        itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tif (simplePageBean.getInherited())\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", \"--inherited--\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-samewindow\", Boolean.toString(i.isSameWindow()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, (isInline ? \"item-group-titles-div\" : \"item-group-titles\"), \" [\" + itemGroupString + \"]\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// the following are for the inline item types. Multimedia\n\t\t\t\t\t// is the most complex because\n\t\t\t\t\t// it can be IMG, IFRAME, or OBJECT, and Youtube is treated\n\t\t\t\t\t// separately\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.MULTIMEDIA) {\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tStringTokenizer token = new StringTokenizer(i.getSakaiId(), \".\");\n\n\t\t\t\t\tString extension = \"\";\n\n\t\t\t\t\twhile (token.hasMoreTokens()) {\n\t\t\t\t\t\textension = token.nextToken().toLowerCase();\n\t\t\t\t\t}\n\n\t\t\t\t\t// the extension is almost never used. Normally we have\n\t\t\t\t\t// the MIME type and use it. Extension is used only if\n\t\t\t\t\t// for some reason we don't have the MIME type\n\t\t\t\t\tUIComponent item;\n\t\t\t\t\tString youtubeKey;\n\n\t\t\t\t\tLength width = null;\n\t\t\t\t\tif (i.getWidth() != null) {\n\t\t\t\t\t\twidth = new Length(i.getWidth());\n\t\t\t\t\t}\n\t\t\t\t\tLength height = null;\n\t\t\t\t\tif (i.getHeight() != null) {\n\t\t\t\t\t\theight = new Length(i.getHeight());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the MIME type. For multimedia types is should be in\n\t\t\t\t\t// the html field.\n\t\t\t\t\t// The old code saved the URL there. So if it looks like a\n\t\t\t\t\t// URL ignore it.\n\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\tif (mimeType != null && (mimeType.startsWith(\"http\") || mimeType.equals(\"\"))) {\n\t\t\t\t\t\tmimeType = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// here goes. dispatch on the type and produce the right tag\n\t\t\t\t\t// type,\n\t\t\t\t\t// followed by the hidden INPUT tags with information for the\n\t\t\t\t\t// edit dialog\n\t\t\t\t\tif (simplePageBean.isImageType(i)) {\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"imageSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles3\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups3\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tString imageName = i.getAlt();\n\t\t\t\t\t\tif (imageName == null || imageName.equals(\"\")) {\n\t\t\t\t\t\t\timageName = abbrevUrl(i.getURL());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"image\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", imageName));\n\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(lengthOk(height)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// stuff for the jquery dialog\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype2\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id4\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description2\", i.getDescription());\n\n\t\t\t\t\t} else if ((youtubeKey = simplePageBean.getYoutubeKey(i)) != null) {\n\t\t\t\t\t\tString youtubeUrl = \"http://www.youtube.com/embed/\" + youtubeKey;\n\t\t\t\t\t\t// this is very odd. The official youtube embedding uses\n\t\t\t\t\t\t// <OBJECT> with\n\t\t\t\t\t\t// a stylesheet to specify size. But the only values\n\t\t\t\t\t\t// that actually\n\t\t\t\t\t\t// work are px and percent. I.e. it works just like the\n\t\t\t\t\t\t// old\n\t\t\t\t\t\t// HTML length types. A real stylesheet length\n\t\t\t\t\t\t// understands other units.\n\t\t\t\t\t\t// I'm generating a style sheet, so that our HTML\n\t\t\t\t\t\t// embedding is as close\n\t\t\t\t\t\t// to theirs as possible, even the lengths are actually\n\t\t\t\t\t\t// interpreted as old style\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles4\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups4\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if width is blank or 100% scale the height\n\t\t\t\t\t\tif (width != null && height != null && !height.number.equals(\"\")) {\n\t\t\t\t\t\t\tif (width.number.equals(\"\") && width.unit.equals(\"\") || width.number.equals(\"100\") && width.unit.equals(\"%\")) {\n\n\t\t\t\t\t\t\t\tint h = Integer.parseInt(height.number);\n\t\t\t\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\t\t\t\twidth.number = Integer.toString((int) Math.round(h * 1.641025641));\n\t\t\t\t\t\t\t\t\twidth.unit = height.unit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// <object style=\"height: 390px; width: 640px\"><param\n\t\t\t\t\t\t// name=\"movie\"\n\t\t\t\t\t\t// value=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"><param\n\t\t\t\t\t\t// name=\"allowFullScreen\" value=\"true\"><param\n\t\t\t\t\t\t// name=\"allowScriptAccess\" value=\"always\"><embed\n\t\t\t\t\t\t// src=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"\n\t\t\t\t\t\t// type=\"application/x-shockwave-flash\"\n\t\t\t\t\t\t// allowfullscreen=\"true\" allowScriptAccess=\"always\"\n\t\t\t\t\t\t// width=\"640\" height=\"390\"><\/object>\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeIFrame\");\n\t\t\t\t\t\t// youtube seems ok with length and width\n\t\t\t\t\t\tif(lengthOk(height)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.youtube_player\")));\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"src\", youtubeUrl));\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeURL\", youtubeUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id5\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtube-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"youtube-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.youtube\")));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description4\", i.getDescription());\n\t\t\t\t\t\t\n\t\t\t\t\t\t// as of Oct 28, 2010, we store the mime type. mimeType\n\t\t\t\t\t\t// null is an old entry.\n\t\t\t\t\t\t// For that use the old approach of checking the\n\t\t\t\t\t\t// extension.\n\t\t\t\t\t\t// Otherwise we want to use iframes for HTML and OBJECT\n\t\t\t\t\t\t// for everything else\n\t\t\t\t\t\t// We need the iframes because IE up through 8 doesn't\n\t\t\t\t\t\t// reliably display\n\t\t\t\t\t\t// HTML with OBJECT. Experiments show that everything\n\t\t\t\t\t\t// else works with OBJECT\n\t\t\t\t\t\t// for most browsers. Unfortunately IE, even IE 9,\n\t\t\t\t\t\t// doesn't reliably call the\n\t\t\t\t\t\t// right player with OBJECT. EMBED works. But it's not\n\t\t\t\t\t\t// as nice because you can't\n\t\t\t\t\t\t// nest error recovery code. So we use OBJECT for\n\t\t\t\t\t\t// everything except IE, where we\n\t\t\t\t\t\t// use EMBED. OBJECT does work with Flash.\n\t\t\t\t\t\t// application/xhtml+xml is XHTML.\n\n\t\t\t\t\t} else if ((mimeType != null && !mimeType.equals(\"text/html\") && !mimeType.equals(\"application/xhtml+xml\")) || (mimeType == null && Arrays.binarySearch(multimediaTypes, extension) >= 0)) {\n\n\t\t\t\t\t\t// this code is used for everything that isn't an image,\n\t\t\t\t\t\t// Youtube, or HTML. Typically\n\t\t\t\t\t\t// this is a flash presentation or a movie. Try to be\n\t\t\t\t\t\t// smart about how we show movies.\n\t\t\t\t\t\t// HTML is done with an IFRAME in the next \"if\" case\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles5\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups5\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIComponent item2;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"movieSpan\");\n\n\t\t\t\t\t\tString movieUrl = i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner());\n\t\t\t\t\t\tString oMimeType = mimeType; // in case we change it for\n\t\t\t\t\t\t// FLV or others\n\t\t\t\t\t\tboolean useFlvPlayer = false;\n\t\t\t\t\t\tboolean useJwPlayer = false;\n\t\t\t\t\t\t// in theory m4v can be DMRed. But Apple's DRM is\n\t\t\t\t\t\t// useless on a web page, so it's got to be an\n\t\t\t\t\t\t// unprotected file.\n\t\t\t\t\t\tboolean isMp4 = mimeType.equals(\"video/mp4\") || mimeType.equals(\"video/x-m4v\");\n\t\t\t\t\t\t// FLV is special. There's no player for flash video in\n\t\t\t\t\t\t// the browser\n\t\t\t\t\t\t// it shows with a special flash program, which I\n\t\t\t\t\t\t// supply. For the moment MP4 is\n\t\t\t\t\t\t// shown with the same player so it uses much of the\n\t\t\t\t\t\t// same code\n\t\t\t\t\t\tif (mimeType != null && (mimeType.equals(\"video/x-flv\") || isMp4)) {\n\t\t\t\t\t\t\tmimeType = \"application/x-shockwave-flash\";\n\t\t\t\t\t\t\tuseJwPlayer = ServerConfigurationService.getBoolean(\"lessonbuilder.usejwplayer\", false);\n\t\t\t\t\t\t\tif (useJwPlayer) {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/jwflvplayer.swf\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/StrobeMediaPlayback.swf\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuseFlvPlayer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// for IE, if we're not supplying a player it's safest\n\t\t\t\t\t\t// to use embed\n\t\t\t\t\t\t// otherwise Quicktime won't work. Oddly, with IE 9 only\n\t\t\t\t\t\t// it works if you set CLASSID to the MIME type,\n\t\t\t\t\t\t// but that's so unexpected that I hate to rely on it.\n\t\t\t\t\t\t// EMBED is in HTML 5, so I think we're OK\n\t\t\t\t\t\t// using it permanently for IE.\n\t\t\t\t\t\t// I prefer OBJECT where possible because of the nesting\n\t\t\t\t\t\t// ability.\n\t\t\t\t\t\tboolean useEmbed = ieVersion > 0 && !mimeType.equals(\"application/x-shockwave-flash\");\n\n\t\t\t\t\t\tif (useEmbed) {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieEmbed\").decorate(new UIFreeAttributeDecorator(\"src\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieObject\").decorate(new UIFreeAttributeDecorator(\"data\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mimeType != null) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", mimeType));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"style\", \"border: 1px solid black\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\tif (useFlvPlayer) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"flashvars\").decorate(new UIFreeAttributeDecorator(\"value\", (useJwPlayer ? \"file=\" : \"src=\") + URLEncoder.encode(myUrl() + i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", movieUrl));\n\t\t\t\t\t\t\tif (!isMp4) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-br\");\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"noplugin\", i.getName(), movieUrl);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isMp4) {\n\t\t\t\t\t\t\t// do fallback. for ie use EMBED\n\t\t\t\t\t\t\tif (ieVersion > 0) {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-embed\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-object\").decorate(new UIFreeAttributeDecorator(\"data\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (oMimeType != null) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", oMimeType));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-inject\").decorate(new UIFreeAttributeDecorator(\"value\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"mp4-noplugin\", i.getName(), i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype5\", oMimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id6\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movie-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"edit-movie\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description3\", i.getDescription());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// finally, HTML. Use an iframe\n\t\t\t\t\t\t// definition of resizeiframe, at top of page\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles2\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups2\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"iframe\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\t\t\t\t\t\t// if user specifies auto, use Javascript to resize the\n\t\t\t\t\t\t// iframe when the\n\t\t\t\t\t\t// content changes. This only works for URLs with the\n\t\t\t\t\t\t// same origin, i.e.\n\t\t\t\t\t\t// URLs in this sakai system\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"onload\", \"resizeiframe('\" + item.getFullID() + \"')\"));\n\t\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", \"300\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// we seem OK without a spec\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.web_content\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype3\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id3\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"Printing Description\");\n\t\t\t\t\t\tUIOutput.make(tableRow, \"description5\", i.getDescription());\n\t\t\t\t\t}\n\n\t\t\t\t\t// end of multimedia object\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.COMMENTS) {\n\t\t\t\t\t// Load later using AJAX and CommentsProducer\n\n\t\t\t\t\tUIOutput.make(tableRow, \"commentsSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.fake-missing-prereqs\"));\n\n\t\t\t\t\t// students get warning and not the content\n\t\t\t\t\tif (!isAvailable && !canEditPage) {\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.missing-prereqs\"));\n\t\t\t\t\t}else {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsDiv\");\n\t\t\t\t\t\tPlacement placement = toolManager.getCurrentPlacement();\n\t\t\t\t\t\tUIOutput.make(tableRow, \"placementId\", placement.getId());\n\n\t\t\t\t\t\tCommentsViewParameters eParams = new CommentsViewParameters(CommentsProducer.VIEW_ID);\n\t\t\t\t\t\teParams.itemId = i.getId();\n\t\t\t\t\t\tif (params.postedComment) {\n\t\t\t\t\t\t\teParams.postedComment = postedCommentId;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(params.author != null && !params.author.equals(\"\")) {\n\t\t\t\t\t\t\teParams.author = params.author;\n\t\t\t\t\t\t\teParams.showAllComments = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"commentsLink\", eParams);\n\n\t\t\t\t\t\tif (!addedCommentsScript) {\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"comments-script\");\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"fckScript\");\n\t\t\t\t\t\t\taddedCommentsScript = true;\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"delete-dialog\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// forced comments have to be edited on the main page\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\t// Checks to make sure that the comments item isn't on a student page.\n\t\t\t\t\t\t\t// That it is graded.  And that we didn't just come from the grading pane.\n\t\t\t\t\t\t\tif(i.getPageId() > 0 && i.getGradebookId() != null && !cameFromGradingPane) {\n\t\t\t\t\t\t\t\tGradingPaneViewParameters gp = new GradingPaneViewParameters(GradingPaneProducer.VIEW_ID);\n\t\t\t\t\t\t\t\tgp.commentsItemId = i.getId();\n\t\t\t\t\t\t\t\tgp.pageId = currentPage.getPageId();\n\t\t\t\t\t\t\t\tgp.pageItemId = pageItem.getId();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tUIInternalLink.make(tableRow, \"gradingPaneLink\", messageLocator.getMessage(\"simplepage.show-grading-pane\"), gp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"comments-td\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (i.getSequence() > 0) {\n\t\t\t\t\t\t\t    UILink.make(tableRow, \"edit-comments\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.comments\")));\n\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsGrade\", String.valueOf(i.getGradebookId() != null));\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"commentsMaxPoints\", String.valueOf(i.getGradebookPoints()));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    String itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\t    if (itemGroupString != null) {\n\t\t\t\t\t\t\t    \tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\t    \tif (itemGroupTitles != null) {\n\t\t\t\t\t\t\t    \t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t\t    \t}\n\t\t\t\t\t\t\t    \tUIOutput.make(tableRow, \"comments-groups\", itemGroupString);\n\t\t\t\t\t\t\t    \tUIOutput.make(tableRow, \"item-group-titles6\", itemGroupTitles);\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    \t\n\t\t\t\t\t\t\t// Allows AJAX posting of comment grades\n\t\t\t\t\t    \tprintGradingForm(tofill);\n\t\t\t\t\t    }\n\n\t\t\t\t\t    UIForm form = UIForm.make(tableRow, \"comment-form\");\n\n\t\t\t\t\t    UIInput.make(form, \"comment-item-id\", \"#{simplePageBean.itemId}\", String.valueOf(i.getId()));\n\t\t\t\t\t    UIInput.make(form, \"comment-edit-id\", \"#{simplePageBean.editId}\");\n\n\t\t\t\t\t    // usage * image is required and not done\n\t\t\t\t\t    if (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\tUIOutput.make(tableRow, \"comment-required-image\");\n\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-link\");\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-text\", messageLocator.getMessage(\"simplepage.add-comment\"));\n\t\t\t\t\t    UIInput fckInput = UIInput.make(form, \"comment-text-area-evolved:\", \"#{simplePageBean.formattedComment}\");\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"height\", \"175\"));\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"width\", \"800\"));\n\t\t\t\t\t    fckInput.decorate(new UIStyleDecorator(\"evolved-box\"));\n\n\t\t\t\t\t    ((SakaiFCKTextEvolver) richTextEvolver).evolveTextInput(fckInput, \"\" + commentsCount);\n\n\t\t\t\t\t    UICommand.make(form, \"add-comment\", \"#{simplePageBean.addComment}\");\n\t\t\t\t\t}\n\n\t\t\t\t}else if(i.getType() == SimplePageItem.STUDENT_CONTENT) {\n\t\t\t\t\tUIOutput.make(tableRow, \"studentSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-fake-missing-prereqs\"));\n\t\t\t\t\telse if (!isAvailable && !canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-missing-prereqs\"));\n\t\t\t\t\telse {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentDiv\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tHashMap<Long, SimplePageLogEntry> cache = simplePageBean.cacheStudentPageLogEntries(i.getId());\n\t\t\t\t\t\tList<SimpleStudentPage> studentPages = simplePageToolDao.findStudentPages(i.getId());\n\t\t\t\t\t\n\t\t\t\t\t\tboolean hasOwnPage = false;\n\t\t\t\t\t\tString userId = UserDirectoryService.getCurrentUser().getId();\n\t\t\t\t\t\t\n\t\t\t\t\t\tHashMap<String, String> anonymousLookup = new HashMap<String, String>();\n\t\t\t\t\t\tif(i.isAnonymous()) {\n\t\t\t\t\t\t\tint counter = 1;\n\t\t\t\t\t\t\tfor(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\t\t\tif(anonymousLookup.get(page.getOwner()) == null) {\n\t\t\t\t\t\t\t\t\tanonymousLookup.put(page.getOwner(), messageLocator.getMessage(\"simplepage.anonymous\") + \" \" + counter++);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t    Collections.sort(studentPages, new Comparator<SimpleStudentPage>() {\n\t\t\t\t\t\t    public int compare(SimpleStudentPage o1, SimpleStudentPage o2) {\n\t\t\t\t\t\t\tString title1 = o1.getTitle();\n\t\t\t\t\t\t\tif (title1 == null)\n\t\t\t\t\t\t\t    title1 = \"\";\n\t\t\t\t\t\t\tString title2 = o2.getTitle();\n\t\t\t\t\t\t\tif (title2 == null)\n\t\t\t\t\t\t\t    title2 = \"\";\n\t\t\t\t\t\t\treturn title1.compareTo(title2);\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t});\t\t\t\t\t    \n\n\t\t\t\t\t\t// Print each row in the table\n\t\t\t\t\t\tfor(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\t\tif(page.isDeleted()) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tSimplePageLogEntry entry = cache.get(page.getPageId());\n\t\t\t\t\t\t\tUIBranchContainer row = UIBranchContainer.make(tableRow, \"studentRow:\");\n\t\t\t\t\t\t\tUIOutput.make(row, \"studentCell\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, page.getPageId());\n\t\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\t\teParams.setPath(\"push\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString studentTitle = page.getTitle();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif(!i.isAnonymous() || canEditPage) {\n\t\t\t\t\t\t\t\t\tString ownerName = UserDirectoryService.getUser(page.getOwner()).getDisplayName();\n\t\t\t\t\t\t\t\t\tif (ownerName != null && ownerName.equals(studentTitle))\n\t\t\t\t\t\t\t\t\t    studentTitle = \"(\" + ownerName + \")\";\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t    studentTitle += \" (\" + UserDirectoryService.getUser(page.getOwner()).getDisplayName() + \")\";\n\t\t\t\t\t\t\t\t}else if(page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\t\t\tstudentTitle += \" (\" + messageLocator.getMessage(\"simplepage.comment-you\") + \")\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIInternalLink.make(row, \"studentLink\", studentTitle, eParams);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Never visited page\n\t\t\t\t\t\t\tif(entry == null) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"newPageImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-page\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// There's content they haven't seen\n\t\t\t\t\t\t\tif(entry == null || entry.getLastViewed().compareTo(page.getLastUpdated()) < 0) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"newContentImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-content\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t// The comments tool exists, so we might have to show the icon\n\t\t\t\t\t\t\tif(i.getShowComments() != null && i.getShowComments()) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"commentsImgCell\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// New comments have been added since they last viewed the page\n\t\t\t\t\t\t\tif(page.getLastCommentChange() != null && (entry == null || entry.getLastViewed().compareTo(page.getLastCommentChange()) < 0)) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"newCommentsImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-comments\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\t\thasOwnPage = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i.getGradebookId() != null && simplePageBean.getEditPrivs() == 0) {\n\t\t\t\t\t\t\t\tUIOutput.make(row, \"studentGradingCell\", String.valueOf((page.getPoints() != null? page.getPoints() : \"\")));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t\tif(!hasOwnPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"linkRow\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"linkCell\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"student-required-image\");\n\t\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID);\n\t\t\t\t\t\t\teParams.addTool = GeneralViewParameters.STUDENT_PAGE;\n\t\t\t\t\t\t\teParams.studentItemId = i.getId();\n\t\t\t\t\t\t\tUIInternalLink.make(tableRow, \"linkLink\", messageLocator.getMessage(\"simplepage.add-page\"), eParams);\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tif(canEditPage) {\n\t\t\t\t\t\t\t// Checks to make sure that the comments are graded and that we didn't\n\t\t\t\t\t\t\t// just come from a grading pane (would be confusing)\n\t\t\t\t\t\t\tif(i.getAltGradebook() != null && !cameFromGradingPane) {\n\t\t\t\t\t\t\t\tGradingPaneViewParameters gp = new GradingPaneViewParameters(GradingPaneProducer.VIEW_ID);\n\t\t\t\t\t\t\t\tgp.commentsItemId = i.getId();\n\t\t\t\t\t\t\t\tgp.pageId = currentPage.getPageId();\n\t\t\t\t\t\t\t\tgp.pageItemId = pageItem.getId();\n\t\t\t\t\t\t\t\tgp.studentContentItem = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tUIInternalLink.make(tableRow, \"studentGradingPaneLink\", messageLocator.getMessage(\"simplepage.show-grading-pane\"), gp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"student-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"edit-student\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.student\")));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentComments\", String.valueOf(i.getShowComments()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"forcedAnon\", String.valueOf(i.getForcedCommentsAnonymous()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentGrade\", String.valueOf(i.getGradebookId() != null));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentMaxPoints\", String.valueOf(i.getGradebookPoints()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentGrade2\", String.valueOf(i.getAltGradebook() != null));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentMaxPoints2\", String.valueOf(i.getAltPoints()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"student-groups\", itemGroupString);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles7\", itemGroupTitles);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}  else {\n\t\t\t\t\t// remaining type must be a block of HTML\n\t\t\t\t\tUIOutput.make(tableRow, \"itemSpan\");\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups-titles-text\", itemGroupTitles);\n\n\t\t\t\t\tUIVerbatim.make(tableRow, \"content\", (i.getHtml() == null ? \"\" : i.getHtml()));\n\n\t\t\t\t\t// editing is done using a special producer that calls FCK.\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters();\n\t\t\t\t\t\teParams.setSendingPage(currentPage.getPageId());\n\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\teParams.viewID = EditPageProducer.VIEW_ID;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edittext-td\");\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), eParams).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.textbox\").replace(\"{}\", Integer.toString(textboxcount))));\n\n\t\t\t\t\t\ttextboxcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// end of items. This is the end for normal users. Following is\n\t\t\t// special\n\t\t\t// checks and putting out the dialogs for the popups, for\n\t\t\t// instructors.\n\n\t\t\tboolean showBreak = false;\n\n\t\t\t// I believe refresh is now done automatically in all cases\n\t\t\t// if (showRefresh) {\n\t\t\t// UIOutput.make(tofill, \"refreshAlert\");\n\t\t\t//\n\t\t\t// // Should simply refresh\n\t\t\t// GeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\t// p.setSendingPage(currentPage.getPageId());\n\t\t\t// UIInternalLink.make(tofill, \"refreshLink\", p);\n\t\t\t// showBreak = true;\n\t\t\t// }\n\n\t\t\t// stuff goes on the page in the order in the HTML file. So the fact\n\t\t\t// that it's here doesn't mean it shows\n\t\t\t// up at the end. This code produces errors and other odd stuff.\n\n\t\t\tif (canEditPage) {\n\t\t\t\t// if the page is hidden, warn the faculty [students get stopped\n\t\t\t\t// at\n\t\t\t\t// the top]\n\t\t\t\tif (currentPage.isHidden()) {\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.pagehidden\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.pagehidden.text\"));\n\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t\t// similarly warn them if it isn't released yet\n\t\t\t\t} else if (currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\t\t\tdf.setTimeZone(tz);\n\t\t\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.notreleased\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.notreleased.text\").replace(\"{}\", releaseDate));\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showBreak) {\n\t\t\t\tUIOutput.make(tofill, \"breakAfterWarnings\");\n\t\t\t}\n\t\t}\n\n\t\t// more warnings: if no item on the page, give faculty instructions,\n\t\t// students an error\n\t\tif (itemList.size() == 0) {\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"startupHelp\")\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"src\", \n\t\t\t\t\tgetLocalizedURL( (pageItem.getType() == SimplePageItem.STUDENT_CONTENT) ? \"student.html\" : \"general.html\")))\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"id\", \"iframe\"));\n\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.noitems_error_user\"));\n\t\t\t}\n\t\t}\n\n\t\t// now output the dialogs. but only for faculty (to avoid making the\n\t\t// file bigger)\n\t\tif (canEditPage) {\n\t\t\tcreateSubpageDialog(tofill, currentPage);\n\t\t}\n\n\t\tcreateDialogs(tofill, currentPage, pageItem);\n\t}","commit_id":"3eb7d25e3bc1cca3212a81a16264e8d778c24999","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void fillComponents(UIContainer tofill, ViewParameters viewParams, ComponentChecker checker) {\n\t\tGeneralViewParameters params = (GeneralViewParameters) viewParams;\n\t\t\n\t\t// security model:\n\t\t// canEditPage and canReadPage are normal Sakai privileges. They apply\n\t\t// to all\n\t\t// pages in the site.\n\t\t// However when presented with a page, we need to make sure it's\n\t\t// actually in\n\t\t// this site, or users could get to pages in other sites. That's done\n\t\t// by updatePageObject. The model is that producers always work on the\n\t\t// current page, and updatePageObject makes sure that is in the current\n\t\t// site.\n\t\t// At that point we can safely use canEditPage.\n\n\t\t// somewhat misleading. sendingPage specifies the page we're supposed to\n\t\t// go to\n\t\tif (params.getSendingPage() != -1) {\n\t\t\t// will fail if page not in this site\n\t\t\t// security then depends upon making sure that we only deal with\n\t\t\t// this page\n\t\t\ttry {\n\t\t\t\tsimplePageBean.updatePageObject(params.getSendingPage());\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"ShowPage permission exception \" + e);\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean canEditPage = simplePageBean.canEditPage();\n\t\tboolean canReadPage = simplePageBean.canReadPage();\n\n\t\tif (!canReadPage) {\n\t\t\t// this code is intended for the situation where site permissions\n\t\t\t// haven't been set up.\n\t\t\t// So if the user can't read the page (which is pretty abnormal),\n\t\t\t// see if they have site.upd.\n\t\t\t// if so, give them some explanation and offer to call the\n\t\t\t// permissions helper\n\t\t\tString ref = \"/site/\" + simplePageBean.getCurrentSiteId();\n\t\t\tif (simplePageBean.canEditSite()) {\n\t\t\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\t\tUIOutput.make(tofill, \"needPermissions\");\n\n\t\t\t\tGeneralViewParameters permParams = new GeneralViewParameters();\n\t\t\t\tpermParams.setSendingPage(-1L);\n\t\t\t\tcreateStandardToolBarLink(PermissionsHelperProducer.VIEW_ID, tofill, \"callpermissions\", \"simplepage.permissions\", permParams, \"simplepage.permissions.tooltip\");\n\n\t\t\t}\n\n\t\t\t// in any case, tell them they can't read the page\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.nopermissions\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.addTool == GeneralViewParameters.COMMENTS) {\n\t\t\tsimplePageBean.addCommentsSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_CONTENT) {\n\t\t\tsimplePageBean.addStudentContentSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_PAGE) {\n\t\t\tsimplePageBean.createStudentPage(params.studentItemId);\n\t\t\tcanEditPage = simplePageBean.canEditPage();\n\t\t}\n\n\t\t// error from previous operation\n\t\tString errMessage = simplePageBean.errMessage();\n\t\tif (errMessage != null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", errMessage);\n\t\t}\n\n\t\t// Find the MSIE version, if we're running it.\n\t\tint ieVersion = checkIEVersion();\n\n\t\tif (simplePageBean.getTopRefresh()) {\n\t\t\tUIOutput.make(tofill, \"refresh\");\n\t\t}\n\n\t\t// set up locale\n\t\tLocale M_locale = null;\n\t\tString langLoc[] = localegetter.get().toString().split(\"_\");\n\t\tif (langLoc.length >= 2) {\n\t\t\tif (\"en\".equals(langLoc[0]) && \"ZA\".equals(langLoc[1])) {\n\t\t\t\tM_locale = new Locale(\"en\", \"GB\");\n\t\t\t} else {\n\t\t\t\tM_locale = new Locale(langLoc[0], langLoc[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tM_locale = new Locale(langLoc[0]);\n\t\t}\n\n\t\t// clear session attribute if necessary, after calling Samigo\n\t\tString clearAttr = params.getClearAttr();\n\n\t\tif (clearAttr != null && !clearAttr.equals(\"\")) {\n\t\t\tSession session = SessionManager.getCurrentSession();\n\t\t\t// don't let users clear random attributes\n\t\t\tif (clearAttr.startsWith(\"LESSONBUILDER_RETURNURL\")) {\n\t\t\t\tsession.setAttribute(clearAttr, null);\n\t\t\t}\n\t\t}\n\n\t\tif (multimediaTypes == null) {\n\t\t\tString mmTypes = ServerConfigurationService.getString(\"lessonbuilder.multimedia.types\", DEFAULT_TYPES);\n\t\t\tmultimediaTypes = mmTypes.split(\",\");\n\t\t\tfor (int i = 0; i < multimediaTypes.length; i++) {\n\t\t\t\tmultimediaTypes[i] = multimediaTypes[i].trim().toLowerCase();\n\t\t\t}\n\t\t\tArrays.sort(multimediaTypes);\n\t\t}\n\n\t\t// remember that page tool was reset, so we need to give user the option\n\t\t// of going to the last page from the previous session\n\t\tSimplePageToolDao.PageData lastPage = simplePageBean.toolWasReset();\n\n\t\t// if starting the tool, sendingpage isn't set. the following call\n\t\t// will give us the top page.\n\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\n\t\t// now we need to find our own item, for access checks, etc.\n\t\tSimplePageItem pageItem = null;\n\t\tif (currentPage != null) {\n\t\t\tpageItem = simplePageBean.getCurrentPageItem(params.getItemId());\n\t\t}\n\t\t// one more security check: make sure the item actually involves this\n\t\t// page.\n\t\t// otherwise someone could pass us an item from a different page in\n\t\t// another site\n\t\t// actually this normally happens if the page doesn't exist and we don't\n\t\t// have permission to create it\n\t\tif (currentPage == null || pageItem == null || \n\t\t    (pageItem.getType() != SimplePageItem.STUDENT_CONTENT &&Long.valueOf(pageItem.getSakaiId()) != currentPage.getPageId()) ||\n\t\t    !simplePageBean.isItemVisible(pageItem)) {\n\t\t\tlog.warn(\"ShowPage item not in page\");\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// I believe we've now checked all the args for permissions issues. All\n\t\t// other item and\n\t\t// page references are generated here based on the contents of the page\n\t\t// and items.\n\n\t\tif (currentPage == null || pageItem == null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.impossible1\"));\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// offer to go to saved page if this is the start of a session, in case\n\t\t// user has logged off and logged on again.\n\t\t// need to offer to go to previous page? even if a new session, no need\n\t\t// if we're already on that page\n\t\tif (lastPage != null && lastPage.pageId != currentPage.getPageId()) {\n\t\t\tUIOutput.make(tofill, \"refreshAlert\");\n\t\t\tUIOutput.make(tofill, \"refresh-message\", messageLocator.getMessage(\"simplepage.last-visited\"));\n\t\t\t// Should simply refresh\n\t\t\tGeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\tp.setSendingPage(lastPage.pageId);\n\t\t\tp.setItemId(lastPage.itemId);\n\t\t\t// reset the path to the saved one\n\t\t\tp.setPath(\"log\");\n\t\t\t\n\t\t\tString name = lastPage.name;\n\t\t\t\n\t\t\t// Titles are set oddly by Student Content Pages\n\t\t\tSimplePage lastPageObj = simplePageToolDao.getPage(lastPage.pageId);\n\t\t\tif(lastPageObj.getOwner() != null) {\n\t\t\t\tname = lastPageObj.getTitle();\n\t\t\t}\n\t\t\t\n\t\t\tUIInternalLink.make(tofill, \"refresh-link\", name, p);\n\t\t}\n\n\t\t// path is the breadcrumbs. Push, pop or reset depending upon path=\n\t\t// programmer documentation.\n\t\tString title;\n\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\ttitle = pageItem.getName();\n\t\t}else {\n\t\t\ttitle = currentPage.getTitle();\n\t\t}\n\t\tString newPath = simplePageBean.adjustPath(params.getPath(), currentPage.getPageId(), pageItem.getId(), title);\n\t\tsimplePageBean.adjustBackPath(params.getBackPath(), currentPage.getPageId(), pageItem.getId(), pageItem.getName());\n\n\t\t// potentially need time zone for setting release date\n\t\tif (!canEditPage && currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\tdf.setTimeZone(tz);\n\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\tString releaseMessage = messageLocator.getMessage(\"simplepage.not_yet_available_releasedate\").replace(\"{}\", releaseDate);\n\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", releaseMessage);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// put out link to index of pages\n\t\tGeneralViewParameters showAll = new GeneralViewParameters(PagePickerProducer.VIEW_ID);\n\t\tshowAll.setSource(\"summary\");\n\t\tUIInternalLink.make(tofill, \"show-pages\", messageLocator.getMessage(\"simplepage.showallpages\"), showAll);\n\n\t\tif (canEditPage) {\n\t\t\t// show tool bar\n\t\t\tcreateToolBar(tofill, currentPage, (pageItem.getType() == SimplePageItem.STUDENT_CONTENT));\n\t\t\tUIOutput.make(tofill, \"edit-title\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.editTitle-tooltip\")));\n\n\t\t\tif (pageItem.getPageId() == 0) { // top level page\n\t\t\t\tUIOutput.make(tofill, \"new-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-page-tooltip\")));\n\t\t\t\tUIOutput.make(tofill, \"import-cc\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.import_cc\")));\n\t\t\t}\n\t\t\t\n\t\t\t// Checks to see that user can edit and that this is either a top level page,\n\t\t\t// or a top level student page (not a subpage to a student page)\n\t\t\tif(simplePageBean.getEditPrivs() == 0 && (pageItem.getPageId() == 0)) {\n\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t}else if(simplePageBean.getEditPrivs() == 0 && currentPage.getOwner() != null) {\n\t\t\t\tSimpleStudentPage studentPage = simplePageToolDao.findStudentPage(currentPage.getTopParent());\n\t\t\t\tif(studentPage != null && studentPage.getPageId() == currentPage.getPageId()) {\n\t\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUIOutput.make(tofill, \"dialogDiv\");\n\t\t} else if (!canReadPage)\n\t\t\treturn;\n\t\telse {\n\t\t\t// see if there are any unsatisfied prerequisites\n\t\t\tList<String> needed = simplePageBean.pagesNeeded(pageItem);\n\t\t\tif (needed.size() > 0) {\n\t\t\t\t// yes. error and abort\n\t\t\t\tif (pageItem.getPageId() != 0) {\n\t\t\t\t\t// not top level. This should only happen from a \"next\"\n\t\t\t\t\t// link.\n\t\t\t\t\t// at any rate, the best approach is to send the user back\n\t\t\t\t\t// to the calling page\n\t\t\t\t\tList<SimplePageBean.PathEntry> path = simplePageBean.getHierarchy();\n\t\t\t\t\tSimplePageBean.PathEntry containingPage = null;\n\t\t\t\t\tif (path.size() > 1) {\n\t\t\t\t\t\t// page above this. this page is on the top\n\t\t\t\t\t\tcontainingPage = path.get(path.size() - 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (containingPage != null) { // not a top level page, point\n\t\t\t\t\t\t// to containing page\n\t\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\t\tview.setSendingPage(containingPage.pageId);\n\t\t\t\t\t\tview.setItemId(containingPage.pageItemId);\n\t\t\t\t\t\tview.setPath(Integer.toString(path.size() - 2));\n\t\t\t\t\t\tUIInternalLink.make(tofill, \"redirect-link\", containingPage.title, view);\n\t\t\t\t\t\tUIOutput.make(tofill, \"redirect\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// top level page where prereqs not satisified. Output list of\n\t\t\t\t// pages he needs to do first\n\t\t\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.has_prerequistes\"));\n\t\t\t\tUIBranchContainer errorList = UIBranchContainer.make(tofill, \"error-list:\");\n\t\t\t\tfor (String errorItem : needed) {\n\t\t\t\t\tUIBranchContainer errorListItem = UIBranchContainer.make(errorList, \"error-item:\");\n\t\t\t\t\tUIOutput.make(errorListItem, \"error-item-text\", errorItem);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tToolSession toolSession = SessionManager.getCurrentToolSession();\n\t\tString helpurl = (String)toolSession.getAttribute(\"sakai-portal:help-action\");\n\t\tString reseturl = (String)toolSession.getAttribute(\"sakai-portal:reset-action\");\n\n\t\tif (helpurl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"helpbutton\" : \"helpbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"openWindow('\" + helpurl + \"', 'Help', 'resizeable=yes,toolbar=no,scrollbars=yes,menubar=yes,width=800,height=600'); return false\"));\n\n\t\tif (reseturl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"resetbutton\" : \"resetbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"location.href='\" + reseturl + \"'; return false\"));\n\n\t\t// note page accessed. the code checks to see whether all the required\n\t\t// items on it have been finished, and if so marks it complete, else just updates\n\t\t// access date save the path because if user goes to it later we want to restore the\n\t\t// breadcrumbs\n\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\tsimplePageBean.track(pageItem.getId(), newPath);\n\t\t}else {\n\t\t\tsimplePageBean.track(pageItem.getId(), newPath, currentPage.getPageId());\n\t\t}\n\n\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\n\t\t// breadcrumbs\n\t\tif (pageItem.getPageId() != 0) {\n\t\t\t// Not top-level, so we have to show breadcrumbs\n\n\t\t\tList<SimplePageBean.PathEntry> breadcrumbs = simplePageBean.getHierarchy();\n\n\t\t\tint index = 0;\n\t\t\tif (breadcrumbs.size() > 1) {\n\t\t\t\tUIOutput.make(tofill, \"crumbdiv\");\n\t\t\t\tfor (SimplePageBean.PathEntry e : breadcrumbs) {\n\t\t\t\t\t// don't show current page. We already have a title. This\n\t\t\t\t\t// was too much\n\t\t\t\t\tUIBranchContainer crumb = UIBranchContainer.make(tofill, \"crumb:\");\n\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\tview.setSendingPage(e.pageId);\n\t\t\t\t\tview.setItemId(e.pageItemId);\n\t\t\t\t\tview.setPath(Integer.toString(index));\n\t\t\t\t\tif (index < breadcrumbs.size() - 1) {\n\t\t\t\t\t\t// Not the last item\n\t\t\t\t\t\tUIInternalLink.make(crumb, \"crumb-link\", e.title, view);\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", \" > \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", e.title).decorate(new UIStyleDecorator(\"bold\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// see if there's a next item in sequence.\n\t\tsimplePageBean.addPrevLink(tofill, pageItem);\n\t\tsimplePageBean.addNextLink(tofill, pageItem);\n\n\t\t// swfObject is not currently used\n\t\tboolean shownSwfObject = false;\n\n\t\t// items to show\n\t\tList<SimplePageItem> itemList = (List<SimplePageItem>) simplePageBean.getItemsOnPage(currentPage.getPageId());\n\t\t\n\t\t// Move all items with sequence <= 0 to the end of the list.\n\t\t// Count is necessary to guarantee we don't infinite loop over a\n\t\t// list that only has items with sequence <= 0.\n\t\tint count = 1;\n\t\twhile(itemList.size() > count && itemList.get(0).getSequence() <= 0) {\n\t\t\titemList.add(itemList.remove(0));\n\t\t\tcount++;\n\t\t}\n\n\t\t// Make sure we only add the comments javascript file once,\n\t\t// even if there are multiple comments tools on the page.\n\t\tboolean addedCommentsScript = false;\n\t\tint commentsCount = 0;\n\n\t\t// Find the most recent comment on the page by current user\n\t\tlong postedCommentId = -1;\n\t\tif (params.postedComment) {\n\t\t\tpostedCommentId = findMostRecentComment();\n\t\t}\n\n\t\t//\n\t\t//\n\t\t// MAIN list of items\n\t\t//\n\t\t// produce the main table\n\t\tif (itemList.size() > 0) {\n\t\t\tUIBranchContainer container = UIBranchContainer.make(tofill, \"itemContainer:\");\n\n\t\t\tboolean showRefresh = false;\n\t\t\tint textboxcount = 1;\n\n\t\t\tUIBranchContainer tableContainer = UIBranchContainer.make(container, \"itemTable:\");\n\n\t\t\t// formatting: two columns:\n\t\t\t// 1: edit buttons, omitted for student\n\t\t\t// 2: main content\n\t\t\t// For links, which have status icons, the main content is a flush\n\t\t\t// left div with the icon\n\t\t\t// followed by a div with margin-left:30px. That takes it beyond the\n\t\t\t// icon, and avoids the\n\t\t\t// wrap-around appearance you'd get without the margin.\n\t\t\t// Normally the description is shown as a second div with\n\t\t\t// indentation in the CSS.\n\t\t\t// That puts it below the link. However with a link that's a button,\n\t\t\t// we do float left\n\t\t\t// for the button so the text wraps around it. I think that's\n\t\t\t// probably what people would expect.\n\n\t\t\tUIOutput.make(tableContainer, \"colgroup\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"col1\");\n\t\t\t}\n\t\t\tUIOutput.make(tableContainer, \"col2\");\n\n\t\t\t// the table header is for accessibility tools only, so it's\n\t\t\t// positioned off screen\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"header-edits\");\n\t\t\t}\n\n\t\t\tUIOutput.make(tableContainer, \"header-items\");\n\n\t\t\tfor (SimplePageItem i : itemList) {\n\n\t\t\t\t// listitem is mostly historical. it uses some shared HTML, but\n\t\t\t\t// if I were\n\t\t\t\t// doing it from scratch I wouldn't make this distinction. At\n\t\t\t\t// the moment it's\n\t\t\t\t// everything that isn't inline.\n\n\t\t\t\tboolean listItem = !(i.getType() == SimplePageItem.TEXT || i.getType() == SimplePageItem.MULTIMEDIA\n\t\t\t\t\t\t|| i.getType() == SimplePageItem.COMMENTS || i.getType() == SimplePageItem.STUDENT_CONTENT);\n\t\t\t\t// (i.getType() == SimplePageItem.PAGE &&\n\t\t\t\t// \"button\".equals(i.getFormat())))\n\n\t\t\t\tUIBranchContainer tableRow = UIBranchContainer.make(tableContainer, \"item:\");\n\t\t\t\tif (!simplePageBean.isItemVisible(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// you really need the HTML file open at the same time to make\n\t\t\t\t// sense of the following code\n\t\t\t\tif (listItem) { // Not an HTML Text, Element or Multimedia\n\t\t\t\t\t// Element\n\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id2\", String.valueOf(i.getId()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// users can declare a page item to be navigational. If so\n\t\t\t\t\t// we display\n\t\t\t\t\t// it to the left of the normal list items, and use a\n\t\t\t\t\t// button. This is\n\t\t\t\t\t// used for pages that are \"next\" pages, i.e. they replace\n\t\t\t\t\t// this page\n\t\t\t\t\t// rather than creating a new level in the breadcrumbs.\n\t\t\t\t\t// Since they can't\n\t\t\t\t\t// be required, they don't need the status image, which is\n\t\t\t\t\t// good because\n\t\t\t\t\t// they're displayed with colspan=2, so there's no space for\n\t\t\t\t\t// the image.\n\n\t\t\t\t\tboolean navButton = \"button\".equals(i.getFormat()) && !i.isRequired();\n\t\t\t\t\tboolean notDone = false;\n\t\t\t\t\tStatus status = Status.NOT_REQUIRED;\n\t\t\t\t\tif (!navButton) {\n\t\t\t\t\t\tstatus = handleStatusImage(tableRow, i);\n\t\t\t\t\t\tif (status == Status.REQUIRED) {\n\t\t\t\t\t\t\tnotDone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean isInline = (i.getType() == SimplePageItem.BLTI && \"inline\".equals(i.getFormat()));\n\n\t\t\t\t\tUIOutput linktd = UIOutput.make(tableRow, \"item-td\");\n\t\t\t\t\tUIBranchContainer linkdiv = null;\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    linkdiv = UIBranchContainer.make(tableRow, \"link-div:\");\n\t\t\t\t\t    UIOutput itemicon = UIOutput.make(linkdiv,\"item-icon\");\n\t\t\t\t\t    switch (i.getType()) {\n\t\t\t\t\t    case SimplePageItem.FORUM:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/comments.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/page_edit.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/pencil.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.BLTI:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/application_go.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.PAGE:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/book_open.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.RESOURCE:\n\t\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\t\t\n\t\t\t\t\t\tString src = imageToMimeMap.get(mimeType);\n\t\t\t\t\t\tif (src == null) {\n\t\t\t\t\t\t    String image = ContentTypeImageService.getContentTypeImage(mimeType);\n\t\t\t\t\t\t    if (image != null)\n\t\t\t\t\t\t\tsrc = \"/library/image/\" + image;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(src != null) {\n\t\t\t\t\t\t    itemicon.decorate(new UIFreeAttributeDecorator(\"src\", src));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput descriptiondiv = null;\n\n\t\t\t\t\t// refresh isn't actually used anymore. We've changed the\n\t\t\t\t\t// way things are\n\t\t\t\t\t// done so the user never has to request a refresh.\n\t\t\t\t\t//   FYI: this actually puts in an IFRAME for inline BLTI items\n\t\t\t\t\tshowRefresh = !makeLink(tableRow, \"link\", i, canEditPage, currentPage, notDone, status) || showRefresh;\n\n\t\t\t\t\t// dummy is used when an assignment, quiz, or forum item is\n\t\t\t\t\t// copied\n\t\t\t\t\t// from another site. The way the copy code works, our\n\t\t\t\t\t// import code\n\t\t\t\t\t// doesn't have access to the necessary info to use the item\n\t\t\t\t\t// from the\n\t\t\t\t\t// new site. So we add a dummy, which generates an\n\t\t\t\t\t// explanation that the\n\t\t\t\t\t// author is going to have to choose the item from the\n\t\t\t\t\t// current site\n\t\t\t\t\tif (i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\tString code = null;\n\t\t\t\t\t\tswitch (i.getType()) {\n\t\t\t\t\t\tcase SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assignment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assessment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.FORUM:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.forum\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", messageLocator.getMessage(code));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", i.getDescription());\n\t\t\t\t\t}\n\t\t\t\t\tif (isInline)\n\t\t\t\t\t    descriptiondiv.decorate(new UIFreeAttributeDecorator(\"style\", \"margin-top: 4px\"));\n\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    // nav button gets float left so any description goes to its\n\t\t\t\t\t    // right. Otherwise the\n\t\t\t\t\t    // description block will display underneath\n\t\t\t\t\t    if (\"button\".equals(i.getFormat())) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"style\", \"float:left\"));\n\t\t\t\t\t    }\n\t\t\t\t\t    // for accessibility\n\t\t\t\t\t    if (navButton) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"role\", \"navigation\"));\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\t// note that a lot of the info here is used by the\n\t\t\t\t\t// javascript that prepares\n\t\t\t\t\t// the jQuery dialogs\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-td\");\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.generic\").replace(\"{}\", i.getName())));\n\n\t\t\t\t\t\t// the following information is displayed using <INPUT\n\t\t\t\t\t\t// type=hidden ...\n\t\t\t\t\t\t// it contains information needed to populate the \"edit\"\n\t\t\t\t\t\t// popup dialog\n\t\t\t\t\t\tUIOutput.make(tableRow, \"prerequisite-info\", String.valueOf(i.isPrerequisite()));\n\n\t\t\t\t\t\tString itemGroupString = null;\n\n\t\t\t\t\t\tif (i.getType() == SimplePageItem.ASSIGNMENT) {\n\t\t\t\t\t\t\t// the type indicates whether scoring is letter\n\t\t\t\t\t\t\t// grade, number, etc.\n\t\t\t\t\t\t\t// the javascript needs this to present the right\n\t\t\t\t\t\t\t// choices to the user\n\t\t\t\t\t\t\t// types 6 and 8 aren't legal scoring types, so they\n\t\t\t\t\t\t\t// are used as\n\t\t\t\t\t\t\t// markers for quiz or forum. I ran out of numbers\n\t\t\t\t\t\t\t// and started using\n\t\t\t\t\t\t\t// text for things that aren't scoring types. That's\n\t\t\t\t\t\t\t// better anyway\n\t\t\t\t\t\t\tint type = 4;\n\t\t\t\t\t\t\tLessonEntity assignment = null;\n\t\t\t\t\t\t\tif (!i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\t\t\tassignment = assignmentEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\t\tif (assignment != null) {\n\t\t\t\t\t\t\t\t\ttype = assignment.getTypeOfGrade();\n\t\t\t\t\t\t\t\t\tString editUrl = assignment.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, assignment, true);\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", String.valueOf(type));\n\t\t\t\t\t\t\tString requirement = String.valueOf(i.getSubrequirement());\n\t\t\t\t\t\t\tif ((type == SimplePageItem.PAGE || type == SimplePageItem.ASSIGNMENT) && i.getSubrequirement()) {\n\t\t\t\t\t\t\t\trequirement = i.getRequirementText();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", requirement);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.ASSESSMENT) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"6\"); // Not used by\n\t\t\t\t\t\t\t// assignments,\n\t\t\t\t\t\t\t// so it is\n\t\t\t\t\t\t\t// safe to dedicate to assessments\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", (i.getSubrequirement() ? i.getRequirementText() : \"false\"));\n\t\t\t\t\t\t\tLessonEntity quiz = quizEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (quiz != null) {\n\t\t\t\t\t\t\t\tString editUrl = quiz.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teditUrl = quiz.editItemSettingsUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-settings-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, quiz, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.BLTI) {\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"type\", \"b\");\n\t\t\t\t\t\t    LessonEntity blti= (bltiEntity == null ? null : bltiEntity.getEntity(i.getSakaiId()));\n\t\t\t\t\t\t    if (blti != null) {\n\t\t\t\t\t\t\tString editUrl = blti.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\tif (editUrl != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-format\", i.getFormat());\n\n\t\t\t\t\t\t\tif (i.getHeight() != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-height\", i.getHeight());\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.FORUM) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"extra-info\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"8\");\n\t\t\t\t\t\t\tLessonEntity forum = forumEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (forum != null) {\n\t\t\t\t\t\t\t\tString editUrl = forum.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, forum, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.PAGE) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"page\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-next\", Boolean.toString(i.getNextPage()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-button\", Boolean.toString(\"button\".equals(i.getFormat())));\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.RESOURCE) {\n\t\t\t\t\t\t        itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tif (simplePageBean.getInherited())\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", \"--inherited--\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-samewindow\", Boolean.toString(i.isSameWindow()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, (isInline ? \"item-group-titles-div\" : \"item-group-titles\"), \" [\" + itemGroupString + \"]\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// the following are for the inline item types. Multimedia\n\t\t\t\t\t// is the most complex because\n\t\t\t\t\t// it can be IMG, IFRAME, or OBJECT, and Youtube is treated\n\t\t\t\t\t// separately\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.MULTIMEDIA) {\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tStringTokenizer token = new StringTokenizer(i.getSakaiId(), \".\");\n\n\t\t\t\t\tString extension = \"\";\n\n\t\t\t\t\twhile (token.hasMoreTokens()) {\n\t\t\t\t\t\textension = token.nextToken().toLowerCase();\n\t\t\t\t\t}\n\n\t\t\t\t\t// the extension is almost never used. Normally we have\n\t\t\t\t\t// the MIME type and use it. Extension is used only if\n\t\t\t\t\t// for some reason we don't have the MIME type\n\t\t\t\t\tUIComponent item;\n\t\t\t\t\tString youtubeKey;\n\n\t\t\t\t\tLength width = null;\n\t\t\t\t\tif (i.getWidth() != null) {\n\t\t\t\t\t\twidth = new Length(i.getWidth());\n\t\t\t\t\t}\n\t\t\t\t\tLength height = null;\n\t\t\t\t\tif (i.getHeight() != null) {\n\t\t\t\t\t\theight = new Length(i.getHeight());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the MIME type. For multimedia types is should be in\n\t\t\t\t\t// the html field.\n\t\t\t\t\t// The old code saved the URL there. So if it looks like a\n\t\t\t\t\t// URL ignore it.\n\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\tif (mimeType != null && (mimeType.startsWith(\"http\") || mimeType.equals(\"\"))) {\n\t\t\t\t\t\tmimeType = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// here goes. dispatch on the type and produce the right tag\n\t\t\t\t\t// type,\n\t\t\t\t\t// followed by the hidden INPUT tags with information for the\n\t\t\t\t\t// edit dialog\n\t\t\t\t\tif (simplePageBean.isImageType(i)) {\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"imageSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles3\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups3\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tString imageName = i.getAlt();\n\t\t\t\t\t\tif (imageName == null || imageName.equals(\"\")) {\n\t\t\t\t\t\t\timageName = abbrevUrl(i.getURL());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"image\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", imageName));\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld())).decorate(new UIFreeAttributeDecorator(\"height\", height.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// stuff for the jquery dialog\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description2\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype2\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id4\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ((youtubeKey = simplePageBean.getYoutubeKey(i)) != null) {\n\t\t\t\t\t\tString youtubeUrl = \"http://www.youtube.com/v/\" + youtubeKey + \"?version=3\";\n\t\t\t\t\t\t// this is very odd. The official youtube embedding uses\n\t\t\t\t\t\t// <OBJECT> with\n\t\t\t\t\t\t// a stylesheet to specify size. But the only values\n\t\t\t\t\t\t// that actually\n\t\t\t\t\t\t// work are px and percent. I.e. it works just like the\n\t\t\t\t\t\t// old\n\t\t\t\t\t\t// HTML length types. A real stylesheet length\n\t\t\t\t\t\t// understands other units.\n\t\t\t\t\t\t// I'm generating a style sheet, so that our HTML\n\t\t\t\t\t\t// embedding is as close\n\t\t\t\t\t\t// to theirs as possible, even the lengths are actually\n\t\t\t\t\t\t// interpreted as old style\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles4\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups4\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if width is blank or 100% scale the height\n\t\t\t\t\t\tif (width != null && height != null && !height.number.equals(\"\")) {\n\t\t\t\t\t\t\tif (width.number.equals(\"\") && width.unit.equals(\"\") || width.number.equals(\"100\") && width.unit.equals(\"%\")) {\n\n\t\t\t\t\t\t\t\tint h = Integer.parseInt(height.number);\n\t\t\t\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\t\t\t\twidth.number = Integer.toString((int) Math.round(h * 1.641025641));\n\t\t\t\t\t\t\t\t\twidth.unit = height.unit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// <object style=\"height: 390px; width: 640px\"><param\n\t\t\t\t\t\t// name=\"movie\"\n\t\t\t\t\t\t// value=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"><param\n\t\t\t\t\t\t// name=\"allowFullScreen\" value=\"true\"><param\n\t\t\t\t\t\t// name=\"allowScriptAccess\" value=\"always\"><embed\n\t\t\t\t\t\t// src=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"\n\t\t\t\t\t\t// type=\"application/x-shockwave-flash\"\n\t\t\t\t\t\t// allowfullscreen=\"true\" allowScriptAccess=\"always\"\n\t\t\t\t\t\t// width=\"640\" height=\"390\"><\/object>\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeObject\");\n\t\t\t\t\t\t// youtube seems ok with length and width\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"style\", getStyle(width, height)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.youtube_player\")));\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", youtubeUrl));\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeEmbed\").decorate(new UIFreeAttributeDecorator(\"type\", \"application/x-shockwave-flash\")).decorate(new UIFreeAttributeDecorator(\"src\", youtubeUrl));\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeURL\", youtubeUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description4\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id5\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtube-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"youtube-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.youtube\")));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// as of Oct 28, 2010, we store the mime type. mimeType\n\t\t\t\t\t\t// null is an old entry.\n\t\t\t\t\t\t// For that use the old approach of checking the\n\t\t\t\t\t\t// extension.\n\t\t\t\t\t\t// Otherwise we want to use iframes for HTML and OBJECT\n\t\t\t\t\t\t// for everything else\n\t\t\t\t\t\t// We need the iframes because IE up through 8 doesn't\n\t\t\t\t\t\t// reliably display\n\t\t\t\t\t\t// HTML with OBJECT. Experiments show that everything\n\t\t\t\t\t\t// else works with OBJECT\n\t\t\t\t\t\t// for most browsers. Unfortunately IE, even IE 9,\n\t\t\t\t\t\t// doesn't reliably call the\n\t\t\t\t\t\t// right player with OBJECT. EMBED works. But it's not\n\t\t\t\t\t\t// as nice because you can't\n\t\t\t\t\t\t// nest error recovery code. So we use OBJECT for\n\t\t\t\t\t\t// everything except IE, where we\n\t\t\t\t\t\t// use EMBED. OBJECT does work with Flash.\n\t\t\t\t\t\t// application/xhtml+xml is XHTML.\n\n\t\t\t\t\t} else if ((mimeType != null && !mimeType.equals(\"text/html\") && !mimeType.equals(\"application/xhtml+xml\")) || (mimeType == null && Arrays.binarySearch(multimediaTypes, extension) >= 0)) {\n\n\t\t\t\t\t\t// this code is used for everything that isn't an image,\n\t\t\t\t\t\t// Youtube, or HTML. Typically\n\t\t\t\t\t\t// this is a flash presentation or a movie. Try to be\n\t\t\t\t\t\t// smart about how we show movies.\n\t\t\t\t\t\t// HTML is done with an IFRAME in the next \"if\" case\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles5\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups5\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIComponent item2;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"movieSpan\");\n\n\t\t\t\t\t\tString movieUrl = i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner());\n\t\t\t\t\t\tString oMimeType = mimeType; // in case we change it for\n\t\t\t\t\t\t// FLV or others\n\t\t\t\t\t\tboolean useFlvPlayer = false;\n\t\t\t\t\t\tboolean useJwPlayer = false;\n\t\t\t\t\t\t// in theory m4v can be DMRed. But Apple's DRM is\n\t\t\t\t\t\t// useless on a web page, so it's got to be an\n\t\t\t\t\t\t// unprotected file.\n\t\t\t\t\t\tboolean isMp4 = mimeType.equals(\"video/mp4\") || mimeType.equals(\"video/x-m4v\");\n\t\t\t\t\t\t// FLV is special. There's no player for flash video in\n\t\t\t\t\t\t// the browser\n\t\t\t\t\t\t// it shows with a special flash program, which I\n\t\t\t\t\t\t// supply. For the moment MP4 is\n\t\t\t\t\t\t// shown with the same player so it uses much of the\n\t\t\t\t\t\t// same code\n\t\t\t\t\t\tif (mimeType != null && (mimeType.equals(\"video/x-flv\") || isMp4)) {\n\t\t\t\t\t\t\tmimeType = \"application/x-shockwave-flash\";\n\t\t\t\t\t\t\tuseJwPlayer = ServerConfigurationService.getBoolean(\"lessonbuilder.usejwplayer\", false);\n\t\t\t\t\t\t\tif (useJwPlayer) {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/jwflvplayer.swf\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/StrobeMediaPlayback.swf\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuseFlvPlayer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// for IE, if we're not supplying a player it's safest\n\t\t\t\t\t\t// to use embed\n\t\t\t\t\t\t// otherwise Quicktime won't work. Oddly, with IE 9 only\n\t\t\t\t\t\t// it works if you set CLASSID to the MIME type,\n\t\t\t\t\t\t// but that's so unexpected that I hate to rely on it.\n\t\t\t\t\t\t// EMBED is in HTML 5, so I think we're OK\n\t\t\t\t\t\t// using it permanently for IE.\n\t\t\t\t\t\t// I prefer OBJECT where possible because of the nesting\n\t\t\t\t\t\t// ability.\n\t\t\t\t\t\tboolean useEmbed = ieVersion > 0 && !mimeType.equals(\"application/x-shockwave-flash\");\n\n\t\t\t\t\t\tif (useEmbed) {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieEmbed\").decorate(new UIFreeAttributeDecorator(\"src\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieObject\").decorate(new UIFreeAttributeDecorator(\"data\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mimeType != null) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", mimeType));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"style\", \"border: 1px solid black\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\tif (useFlvPlayer) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"flashvars\").decorate(new UIFreeAttributeDecorator(\"value\", (useJwPlayer ? \"file=\" : \"src=\") + URLEncoder.encode(myUrl() + i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", movieUrl));\n\t\t\t\t\t\t\tif (!isMp4) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-br\");\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"noplugin\", i.getName(), movieUrl);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isMp4) {\n\t\t\t\t\t\t\t// do fallback. for ie use EMBED\n\t\t\t\t\t\t\tif (ieVersion > 0) {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-embed\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-object\").decorate(new UIFreeAttributeDecorator(\"data\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (oMimeType != null) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", oMimeType));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-inject\").decorate(new UIFreeAttributeDecorator(\"value\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"mp4-noplugin\", i.getName(), i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description3\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype5\", oMimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id6\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movie-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"edit-movie\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// finally, HTML. Use an iframe\n\t\t\t\t\t\t// definition of resizeiframe, at top of page\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles2\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups2\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"iframe\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\t\t\t\t\t\t// if user specifies auto, use Javascript to resize the\n\t\t\t\t\t\t// iframe when the\n\t\t\t\t\t\t// content changes. This only works for URLs with the\n\t\t\t\t\t\t// same origin, i.e.\n\t\t\t\t\t\t// URLs in this sakai system\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"onload\", \"resizeiframe('\" + item.getFullID() + \"')\"));\n\t\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", \"300\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// we seem OK without a spec\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.web_content\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description5\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype3\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id3\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end of multimedia object\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.COMMENTS) {\n\t\t\t\t\t// Load later using AJAX and CommentsProducer\n\n\t\t\t\t\tUIOutput.make(tableRow, \"commentsSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.fake-missing-prereqs\"));\n\n\t\t\t\t\t// students get warning and not the content\n\t\t\t\t\tif (!isAvailable && !canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.missing-prereqs\"));\n\t\t\t\t\telse {\n\t\t\t\t\t    UIOutput.make(tableRow, \"commentsDiv\");\n\t\t\t\t\t    Placement placement = toolManager.getCurrentPlacement();\n\t\t\t\t\t    UIOutput.make(tableRow, \"placementId\", placement.getId());\n\n\t\t\t\t\t    CommentsViewParameters eParams = new CommentsViewParameters(CommentsProducer.VIEW_ID);\n\t\t\t\t\t    eParams.itemId = i.getId();\n\t\t\t\t\t    if (params.postedComment) {\n\t\t\t\t\t\teParams.postedComment = postedCommentId;\n\t\t\t\t\t    }\n\n\t\t\t\t\t    UIInternalLink.make(tableRow, \"commentsLink\", eParams);\n\n\t\t\t\t\t    if (!addedCommentsScript) {\n\t\t\t\t\t\tUIOutput.make(tofill, \"comments-script\");\n\t\t\t\t\t\tUIOutput.make(tofill, \"fckScript\");\n\t\t\t\t\t\taddedCommentsScript = true;\n\t\t\t\t\t\tUIOutput.make(tofill, \"delete-dialog\");\n\t\t\t\t\t    }\n\n\t\t\t\t\t    if (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"comments-td\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-comments\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.comments\")));\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsId\", String.valueOf(i.getId()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t    String itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t    if (itemGroupTitles != null) {\n\t\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"comments-groups\", itemGroupString);\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-group-titles6\", itemGroupTitles);\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\n\t\t\t\t\t    UIForm form = UIForm.make(tableRow, \"comment-form\");\n\n\t\t\t\t\t    UIInput.make(form, \"comment-item-id\", \"#{simplePageBean.itemId}\", String.valueOf(i.getId()));\n\t\t\t\t\t    UIInput.make(form, \"comment-edit-id\", \"#{simplePageBean.editId}\");\n\n\t\t\t\t\t    // usage * image is required and not done\n\t\t\t\t\t    if (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\tUIOutput.make(tableRow, \"comment-required-image\");\n\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-link\");\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-text\", messageLocator.getMessage(\"simplepage.add-comment\"));\n\t\t\t\t\t    UIInput fckInput = UIInput.make(form, \"comment-text-area-evolved:\", \"#{simplePageBean.formattedComment}\");\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"height\", \"175\"));\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"width\", \"800\"));\n\t\t\t\t\t    fckInput.decorate(new UIStyleDecorator(\"evolved-box\"));\n\n\t\t\t\t\t    ((SakaiFCKTextEvolver) richTextEvolver).evolveTextInput(fckInput, \"\" + commentsCount);\n\n\t\t\t\t\t    UICommand.make(form, \"add-comment\", \"#{simplePageBean.addComment}\");\n\t\t\t\t\t}\n\n\t\t\t\t}else if(i.getType() == SimplePageItem.STUDENT_CONTENT) {\n\t\t\t\t\tUIOutput.make(tableRow, \"studentSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-fake-missing-prereqs\"));\n\t\t\t\t\tif (!isAvailable && !canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-missing-prereqs\"));\n\t\t\t\t\telse {\n\t\t\t\t\t    UIOutput.make(tableRow, \"studentDiv\");\n\t\t\t\t\t\n\t\t\t\t\t    HashMap<Long, SimplePageLogEntry> cache = simplePageBean.cacheStudentPageLogEntries(i.getId());\n\t\t\t\t\t    List<SimpleStudentPage> studentPages = simplePageToolDao.findStudentPages(i.getId());\n\t\t\t\t\t\n\t\t\t\t\t    boolean hasOwnPage = false;\n\t\t\t\t\t    String userId = UserDirectoryService.getCurrentUser().getId();\n\t\t\t\t\t\n\t\t\t\t\t    HashMap<String, String> anonymousLookup = new HashMap<String, String>();\n\t\t\t\t\t    if(i.isAnonymous()) {\n\t\t\t\t\t\tint counter = 1;\n\t\t\t\t\t\tfor(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\t\tif(anonymousLookup.get(page.getOwner()) == null) {\n\t\t\t\t\t\t\t\tanonymousLookup.put(page.getOwner(), messageLocator.getMessage(\"simplepage.anonymous\") + \" \" + counter++);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t    // Print each row in the table\n\t\t\t\t\t    for(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\tif(page.isDeleted()) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tSimplePageLogEntry entry = cache.get(page.getPageId());\n\t\t\t\t\t\tUIBranchContainer row = UIBranchContainer.make(tableRow, \"studentRow:\");\n\t\t\t\t\t\tUIOutput.make(row, \"studentCell\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, page.getPageId());\n\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\teParams.setPath(\"push\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tString username = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tusername = i.isAnonymous()? anonymousLookup.get(page.getOwner()) : UserDirectoryService.getUser(page.getOwner()).getDisplayName();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i.isAnonymous() && canEditPage) {\n\t\t\t\t\t\t\t\tusername += \" (\" + UserDirectoryService.getUser(page.getOwner()).getDisplayName() + \")\";\n\t\t\t\t\t\t\t}else if(i.isAnonymous() && page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\t\tusername += \" (\" + messageLocator.getMessage(\"simplepage.comment-you\") + \")\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\t\t\t\tusername = page.getTitle();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIInternalLink.make(row, \"studentLink\", username, eParams);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Never visited page\n\t\t\t\t\t\tif(entry == null) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"newPageImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-page\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// There's content they haven't seen\n\t\t\t\t\t\tif(entry == null || entry.getLastViewed().compareTo(page.getLastUpdated()) < 0) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"newContentImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-content\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// The comments tool exists, so we might have to show the icon\n\t\t\t\t\t\tif(i.getShowComments() != null && i.getShowComments()) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"commentsImgCell\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// New comments have been added since they last viewed the page\n\t\t\t\t\t\tif(page.getLastCommentChange() != null && (entry == null || entry.getLastViewed().compareTo(page.getLastCommentChange()) < 0)) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"newCommentsImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-comments\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\thasOwnPage = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t    if(!hasOwnPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"linkRow\");\n\t\t\t\t\t\tUIOutput.make(tableRow, \"linkCell\");\n\n\t\t\t\t\t\tif (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"student-required-image\");\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID);\n\t\t\t\t\t\teParams.addTool = GeneralViewParameters.STUDENT_PAGE;\n\t\t\t\t\t\teParams.studentItemId = i.getId();\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"linkLink\", messageLocator.getMessage(\"simplepage.add-page\"), eParams);\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t    if(canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"student-td\");\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-student\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.student\")));\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentId\", String.valueOf(i.getId()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentComments\", String.valueOf(i.getShowComments()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"forcedAnon\", String.valueOf(i.getForcedCommentsAnonymous()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t    String itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t    if (itemGroupTitles != null) {\n\t\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"student-groups\", itemGroupString);\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-group-titles7\", itemGroupTitles);\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t}  else {\n\t\t\t\t\t// remaining type must be a block of HTML\n\t\t\t\t\tUIOutput.make(tableRow, \"itemSpan\");\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups-titles-text\", itemGroupTitles);\n\n\t\t\t\t\tUIVerbatim.make(tableRow, \"content\", (i.getHtml() == null ? \"\" : i.getHtml()));\n\n\t\t\t\t\t// editing is done using a special producer that calls FCK.\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters();\n\t\t\t\t\t\teParams.setSendingPage(currentPage.getPageId());\n\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\teParams.viewID = EditPageProducer.VIEW_ID;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edittext-td\");\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), eParams).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.textbox\").replace(\"{}\", Integer.toString(textboxcount))));\n\n\t\t\t\t\t\ttextboxcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// end of items. This is the end for normal users. Following is\n\t\t\t// special\n\t\t\t// checks and putting out the dialogs for the popups, for\n\t\t\t// instructors.\n\n\t\t\tboolean showBreak = false;\n\n\t\t\t// I believe refresh is now done automatically in all cases\n\t\t\t// if (showRefresh) {\n\t\t\t// UIOutput.make(tofill, \"refreshAlert\");\n\t\t\t//\n\t\t\t// // Should simply refresh\n\t\t\t// GeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\t// p.setSendingPage(currentPage.getPageId());\n\t\t\t// UIInternalLink.make(tofill, \"refreshLink\", p);\n\t\t\t// showBreak = true;\n\t\t\t// }\n\n\t\t\t// stuff goes on the page in the order in the HTML file. So the fact\n\t\t\t// that it's here doesn't mean it shows\n\t\t\t// up at the end. This code produces errors and other odd stuff.\n\n\t\t\tif (canEditPage) {\n\t\t\t\t// if the page is hidden, warn the faculty [students get stopped\n\t\t\t\t// at\n\t\t\t\t// the top]\n\t\t\t\tif (currentPage.isHidden()) {\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.pagehidden\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.pagehidden.text\"));\n\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t\t// similarly warn them if it isn't released yet\n\t\t\t\t} else if (currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\t\t\tdf.setTimeZone(tz);\n\t\t\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.notreleased\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.notreleased.text\").replace(\"{}\", releaseDate));\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showBreak) {\n\t\t\t\tUIOutput.make(tofill, \"breakAfterWarnings\");\n\t\t\t}\n\t\t}\n\n\t\t// more warnings: if no item on the page, give faculty instructions,\n\t\t// students an error\n\t\tif (itemList.size() == 0) {\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"startupHelp\")\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"src\", \n\t\t\t\t\tgetLocalizedURL( (pageItem.getType() == SimplePageItem.STUDENT_CONTENT) ? \"student.html\" : \"general.html\")))\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"id\", \"iframe\"));\n\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.noitems_error_user\"));\n\t\t\t}\n\t\t}\n\n\t\t// now output the dialogs. but only for faculty (to avoid making the\n\t\t// file bigger)\n\t\tif (canEditPage) {\n\t\t\tcreateSubpageDialog(tofill, currentPage);\n\t\t}\n\n\t\tcreateDialogs(tofill, currentPage, pageItem);\n\t}","id":86053,"modified_method":"public void fillComponents(UIContainer tofill, ViewParameters viewParams, ComponentChecker checker) {\n\t\tGeneralViewParameters params = (GeneralViewParameters) viewParams;\n\t\t\n\t\t// security model:\n\t\t// canEditPage and canReadPage are normal Sakai privileges. They apply\n\t\t// to all\n\t\t// pages in the site.\n\t\t// However when presented with a page, we need to make sure it's\n\t\t// actually in\n\t\t// this site, or users could get to pages in other sites. That's done\n\t\t// by updatePageObject. The model is that producers always work on the\n\t\t// current page, and updatePageObject makes sure that is in the current\n\t\t// site.\n\t\t// At that point we can safely use canEditPage.\n\n\t\t// somewhat misleading. sendingPage specifies the page we're supposed to\n\t\t// go to\n\t\tif (params.getSendingPage() != -1) {\n\t\t\t// will fail if page not in this site\n\t\t\t// security then depends upon making sure that we only deal with\n\t\t\t// this page\n\t\t\ttry {\n\t\t\t\tsimplePageBean.updatePageObject(params.getSendingPage());\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"ShowPage permission exception \" + e);\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean canEditPage = simplePageBean.canEditPage();\n\t\tboolean canReadPage = simplePageBean.canReadPage();\n\n\t\tif (!canReadPage) {\n\t\t\t// this code is intended for the situation where site permissions\n\t\t\t// haven't been set up.\n\t\t\t// So if the user can't read the page (which is pretty abnormal),\n\t\t\t// see if they have site.upd.\n\t\t\t// if so, give them some explanation and offer to call the\n\t\t\t// permissions helper\n\t\t\tString ref = \"/site/\" + simplePageBean.getCurrentSiteId();\n\t\t\tif (simplePageBean.canEditSite()) {\n\t\t\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\t\tUIOutput.make(tofill, \"needPermissions\");\n\n\t\t\t\tGeneralViewParameters permParams = new GeneralViewParameters();\n\t\t\t\tpermParams.setSendingPage(-1L);\n\t\t\t\tcreateStandardToolBarLink(PermissionsHelperProducer.VIEW_ID, tofill, \"callpermissions\", \"simplepage.permissions\", permParams, \"simplepage.permissions.tooltip\");\n\n\t\t\t}\n\n\t\t\t// in any case, tell them they can't read the page\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.nopermissions\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.addTool == GeneralViewParameters.COMMENTS) {\n\t\t\tsimplePageBean.addCommentsSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_CONTENT) {\n\t\t\tsimplePageBean.addStudentContentSection();\n\t\t}else if(params.addTool == GeneralViewParameters.STUDENT_PAGE) {\n\t\t\tsimplePageBean.createStudentPage(params.studentItemId);\n\t\t\tcanEditPage = simplePageBean.canEditPage();\n\t\t}\n\n\t\t// error from previous operation\n\t\tString errMessage = simplePageBean.errMessage();\n\t\tif (errMessage != null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", errMessage);\n\t\t}\n\n\t\t// Find the MSIE version, if we're running it.\n\t\tint ieVersion = checkIEVersion();\n\n\t\tif (simplePageBean.getTopRefresh()) {\n\t\t\tUIOutput.make(tofill, \"refresh\");\n\t\t}\n\n\t\t// set up locale\n\t\tLocale M_locale = null;\n\t\tString langLoc[] = localegetter.get().toString().split(\"_\");\n\t\tif (langLoc.length >= 2) {\n\t\t\tif (\"en\".equals(langLoc[0]) && \"ZA\".equals(langLoc[1])) {\n\t\t\t\tM_locale = new Locale(\"en\", \"GB\");\n\t\t\t} else {\n\t\t\t\tM_locale = new Locale(langLoc[0], langLoc[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tM_locale = new Locale(langLoc[0]);\n\t\t}\n\n\t\t// clear session attribute if necessary, after calling Samigo\n\t\tString clearAttr = params.getClearAttr();\n\n\t\tif (clearAttr != null && !clearAttr.equals(\"\")) {\n\t\t\tSession session = SessionManager.getCurrentSession();\n\t\t\t// don't let users clear random attributes\n\t\t\tif (clearAttr.startsWith(\"LESSONBUILDER_RETURNURL\")) {\n\t\t\t\tsession.setAttribute(clearAttr, null);\n\t\t\t}\n\t\t}\n\n\t\tif (multimediaTypes == null) {\n\t\t\tString mmTypes = ServerConfigurationService.getString(\"lessonbuilder.multimedia.types\", DEFAULT_TYPES);\n\t\t\tmultimediaTypes = mmTypes.split(\",\");\n\t\t\tfor (int i = 0; i < multimediaTypes.length; i++) {\n\t\t\t\tmultimediaTypes[i] = multimediaTypes[i].trim().toLowerCase();\n\t\t\t}\n\t\t\tArrays.sort(multimediaTypes);\n\t\t}\n\n\t\t// remember that page tool was reset, so we need to give user the option\n\t\t// of going to the last page from the previous session\n\t\tSimplePageToolDao.PageData lastPage = simplePageBean.toolWasReset();\n\n\t\t// if starting the tool, sendingpage isn't set. the following call\n\t\t// will give us the top page.\n\t\tSimplePage currentPage = simplePageBean.getCurrentPage();\n\t\t\n\t\t// now we need to find our own item, for access checks, etc.\n\t\tSimplePageItem pageItem = null;\n\t\tif (currentPage != null) {\n\t\t\tpageItem = simplePageBean.getCurrentPageItem(params.getItemId());\n\t\t}\n\t\t// one more security check: make sure the item actually involves this\n\t\t// page.\n\t\t// otherwise someone could pass us an item from a different page in\n\t\t// another site\n\t\t// actually this normally happens if the page doesn't exist and we don't\n\t\t// have permission to create it\n\t\tif (currentPage == null || pageItem == null || \n\t\t    (pageItem.getType() != SimplePageItem.STUDENT_CONTENT &&Long.valueOf(pageItem.getSakaiId()) != currentPage.getPageId()) ||\n\t\t    !simplePageBean.isItemVisible(pageItem)) {\n\t\t\tlog.warn(\"ShowPage item not in page\");\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\treturn;\n\t\t}\n\n\t\t// I believe we've now checked all the args for permissions issues. All\n\t\t// other item and\n\t\t// page references are generated here based on the contents of the page\n\t\t// and items.\n\n\t\tif (currentPage == null || pageItem == null) {\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.impossible1\"));\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.not_available\"));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// offer to go to saved page if this is the start of a session, in case\n\t\t// user has logged off and logged on again.\n\t\t// need to offer to go to previous page? even if a new session, no need\n\t\t// if we're already on that page\n\t\tif (lastPage != null && lastPage.pageId != currentPage.getPageId()) {\n\t\t\tUIOutput.make(tofill, \"refreshAlert\");\n\t\t\tUIOutput.make(tofill, \"refresh-message\", messageLocator.getMessage(\"simplepage.last-visited\"));\n\t\t\t// Should simply refresh\n\t\t\tGeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\tp.setSendingPage(lastPage.pageId);\n\t\t\tp.setItemId(lastPage.itemId);\n\t\t\t// reset the path to the saved one\n\t\t\tp.setPath(\"log\");\n\t\t\t\n\t\t\tString name = lastPage.name;\n\t\t\t\n\t\t\t// Titles are set oddly by Student Content Pages\n\t\t\tSimplePage lastPageObj = simplePageToolDao.getPage(lastPage.pageId);\n\t\t\tif(lastPageObj.getOwner() != null) {\n\t\t\t\tname = lastPageObj.getTitle();\n\t\t\t}\n\t\t\t\n\t\t\tUIInternalLink.make(tofill, \"refresh-link\", name, p);\n\t\t}\n\n\t\t// path is the breadcrumbs. Push, pop or reset depending upon path=\n\t\t// programmer documentation.\n\t\tString title;\n\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\ttitle = pageItem.getName();\n\t\t}else {\n\t\t\ttitle = currentPage.getTitle();\n\t\t}\n\t\tString newPath = simplePageBean.adjustPath(params.getPath(), currentPage.getPageId(), pageItem.getId(), title);\n\t\tsimplePageBean.adjustBackPath(params.getBackPath(), currentPage.getPageId(), pageItem.getId(), pageItem.getName());\n\n\t\t// potentially need time zone for setting release date\n\t\tif (!canEditPage && currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\tdf.setTimeZone(tz);\n\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\tString releaseMessage = messageLocator.getMessage(\"simplepage.not_yet_available_releasedate\").replace(\"{}\", releaseDate);\n\n\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\tUIOutput.make(tofill, \"error\", releaseMessage);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// put out link to index of pages\n\t\tGeneralViewParameters showAll = new GeneralViewParameters(PagePickerProducer.VIEW_ID);\n\t\tshowAll.setSource(\"summary\");\n\t\tUIInternalLink.make(tofill, \"show-pages\", messageLocator.getMessage(\"simplepage.showallpages\"), showAll);\n\n\t\tif (canEditPage) {\n\t\t\t// show tool bar\n\t\t\tcreateToolBar(tofill, currentPage, (pageItem.getType() == SimplePageItem.STUDENT_CONTENT));\n\t\t\tUIOutput.make(tofill, \"edit-title\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.editTitle-tooltip\")));\n\n\t\t\tif (pageItem.getPageId() == 0) { // top level page\n\t\t\t\tUIOutput.make(tofill, \"new-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-page-tooltip\")));\n\t\t\t\tUIOutput.make(tofill, \"import-cc\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.import_cc\")));\n\t\t\t}\n\t\t\t\n\t\t\t// Checks to see that user can edit and that this is either a top level page,\n\t\t\t// or a top level student page (not a subpage to a student page)\n\t\t\tif(simplePageBean.getEditPrivs() == 0 && (pageItem.getPageId() == 0)) {\n\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t}else if(simplePageBean.getEditPrivs() == 0 && currentPage.getOwner() != null) {\n\t\t\t\tSimpleStudentPage studentPage = simplePageToolDao.findStudentPage(currentPage.getTopParent());\n\t\t\t\tif(studentPage != null && studentPage.getPageId() == currentPage.getPageId()) {\n\t\t\t\t\tUIOutput.make(tofill, \"remove-page\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.remove-page-tooltip\")));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUIOutput.make(tofill, \"dialogDiv\");\n\t\t} else if (!canReadPage)\n\t\t\treturn;\n\t\telse {\n\t\t\t// see if there are any unsatisfied prerequisites\n\t\t\tList<String> needed = simplePageBean.pagesNeeded(pageItem);\n\t\t\tif (needed.size() > 0) {\n\t\t\t\t// yes. error and abort\n\t\t\t\tif (pageItem.getPageId() != 0) {\n\t\t\t\t\t// not top level. This should only happen from a \"next\"\n\t\t\t\t\t// link.\n\t\t\t\t\t// at any rate, the best approach is to send the user back\n\t\t\t\t\t// to the calling page\n\t\t\t\t\tList<SimplePageBean.PathEntry> path = simplePageBean.getHierarchy();\n\t\t\t\t\tSimplePageBean.PathEntry containingPage = null;\n\t\t\t\t\tif (path.size() > 1) {\n\t\t\t\t\t\t// page above this. this page is on the top\n\t\t\t\t\t\tcontainingPage = path.get(path.size() - 2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (containingPage != null) { // not a top level page, point\n\t\t\t\t\t\t// to containing page\n\t\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\t\tview.setSendingPage(containingPage.pageId);\n\t\t\t\t\t\tview.setItemId(containingPage.pageItemId);\n\t\t\t\t\t\tview.setPath(Integer.toString(path.size() - 2));\n\t\t\t\t\t\tUIInternalLink.make(tofill, \"redirect-link\", containingPage.title, view);\n\t\t\t\t\t\tUIOutput.make(tofill, \"redirect\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// top level page where prereqs not satisified. Output list of\n\t\t\t\t// pages he needs to do first\n\t\t\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.has_prerequistes\"));\n\t\t\t\tUIBranchContainer errorList = UIBranchContainer.make(tofill, \"error-list:\");\n\t\t\t\tfor (String errorItem : needed) {\n\t\t\t\t\tUIBranchContainer errorListItem = UIBranchContainer.make(errorList, \"error-item:\");\n\t\t\t\t\tUIOutput.make(errorListItem, \"error-item-text\", errorItem);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tToolSession toolSession = SessionManager.getCurrentToolSession();\n\t\tString helpurl = (String)toolSession.getAttribute(\"sakai-portal:help-action\");\n\t\tString reseturl = (String)toolSession.getAttribute(\"sakai-portal:reset-action\");\n\n\t\tif (helpurl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"helpbutton\" : \"helpbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"openWindow('\" + helpurl + \"', 'Help', 'resizeable=yes,toolbar=no,scrollbars=yes,menubar=yes,width=800,height=600'); return false\"));\n\n\t\tif (reseturl != null)\n\t\t    UILink.make(tofill, (pageItem.getPageId() == 0 ? \"resetbutton\" : \"resetbutton2\")).\n\t\t\tdecorate(new UIFreeAttributeDecorator(\"onclick\",\n\t\t\t         \"location.href='\" + reseturl + \"'; return false\"));\n\n\t\t// note page accessed. the code checks to see whether all the required\n\t\t// items on it have been finished, and if so marks it complete, else just updates\n\t\t// access date save the path because if user goes to it later we want to restore the\n\t\t// breadcrumbs\n\t\tif(pageItem.getType() != SimplePageItem.STUDENT_CONTENT) {\n\t\t\tsimplePageBean.track(pageItem.getId(), newPath);\n\t\t}else {\n\t\t\tsimplePageBean.track(pageItem.getId(), newPath, currentPage.getPageId());\n\t\t}\n\n\t\tUIOutput.make(tofill, \"pagetitle\", currentPage.getTitle());\n\n\t\t// breadcrumbs\n\t\tif (pageItem.getPageId() != 0) {\n\t\t\t// Not top-level, so we have to show breadcrumbs\n\n\t\t\tList<SimplePageBean.PathEntry> breadcrumbs = simplePageBean.getHierarchy();\n\n\t\t\tint index = 0;\n\t\t\tif (breadcrumbs.size() > 1) {\n\t\t\t\tUIOutput.make(tofill, \"crumbdiv\");\n\t\t\t\tfor (SimplePageBean.PathEntry e : breadcrumbs) {\n\t\t\t\t\t// don't show current page. We already have a title. This\n\t\t\t\t\t// was too much\n\t\t\t\t\tUIBranchContainer crumb = UIBranchContainer.make(tofill, \"crumb:\");\n\t\t\t\t\tGeneralViewParameters view = new GeneralViewParameters(VIEW_ID);\n\t\t\t\t\tview.setSendingPage(e.pageId);\n\t\t\t\t\tview.setItemId(e.pageItemId);\n\t\t\t\t\tview.setPath(Integer.toString(index));\n\t\t\t\t\tif (index < breadcrumbs.size() - 1) {\n\t\t\t\t\t\t// Not the last item\n\t\t\t\t\t\tUIInternalLink.make(crumb, \"crumb-link\", e.title, view);\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", \" > \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tUIOutput.make(crumb, \"crumb-follow\", e.title).decorate(new UIStyleDecorator(\"bold\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// see if there's a next item in sequence.\n\t\tsimplePageBean.addPrevLink(tofill, pageItem);\n\t\tsimplePageBean.addNextLink(tofill, pageItem);\n\n\t\t// swfObject is not currently used\n\t\tboolean shownSwfObject = false;\n\n\t\t// items to show\n\t\tList<SimplePageItem> itemList = (List<SimplePageItem>) simplePageBean.getItemsOnPage(currentPage.getPageId());\n\t\t\n\t\t// Move all items with sequence <= 0 to the end of the list.\n\t\t// Count is necessary to guarantee we don't infinite loop over a\n\t\t// list that only has items with sequence <= 0.\n\t\tint count = 1;\n\t\twhile(itemList.size() > count && itemList.get(0).getSequence() <= 0) {\n\t\t\titemList.add(itemList.remove(0));\n\t\t\tcount++;\n\t\t}\n\n\t\t// Make sure we only add the comments javascript file once,\n\t\t// even if there are multiple comments tools on the page.\n\t\tboolean addedCommentsScript = false;\n\t\tint commentsCount = 0;\n\n\t\t// Find the most recent comment on the page by current user\n\t\tlong postedCommentId = -1;\n\t\tif (params.postedComment) {\n\t\t\tpostedCommentId = findMostRecentComment();\n\t\t}\n\n\t\t//\n\t\t//\n\t\t// MAIN list of items\n\t\t//\n\t\t// produce the main table\n\t\tif (itemList.size() > 0) {\n\t\t\tUIBranchContainer container = UIBranchContainer.make(tofill, \"itemContainer:\");\n\n\t\t\tboolean showRefresh = false;\n\t\t\tint textboxcount = 1;\n\n\t\t\tUIBranchContainer tableContainer = UIBranchContainer.make(container, \"itemTable:\");\n\n\t\t\t// formatting: two columns:\n\t\t\t// 1: edit buttons, omitted for student\n\t\t\t// 2: main content\n\t\t\t// For links, which have status icons, the main content is a flush\n\t\t\t// left div with the icon\n\t\t\t// followed by a div with margin-left:30px. That takes it beyond the\n\t\t\t// icon, and avoids the\n\t\t\t// wrap-around appearance you'd get without the margin.\n\t\t\t// Normally the description is shown as a second div with\n\t\t\t// indentation in the CSS.\n\t\t\t// That puts it below the link. However with a link that's a button,\n\t\t\t// we do float left\n\t\t\t// for the button so the text wraps around it. I think that's\n\t\t\t// probably what people would expect.\n\n\t\t\tUIOutput.make(tableContainer, \"colgroup\");\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"col1\");\n\t\t\t}\n\t\t\tUIOutput.make(tableContainer, \"col2\");\n\n\t\t\t// the table header is for accessibility tools only, so it's\n\t\t\t// positioned off screen\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tableContainer, \"header-edits\");\n\t\t\t}\n\n\t\t\tUIOutput.make(tableContainer, \"header-items\");\n\n\t\t\tfor (SimplePageItem i : itemList) {\n\n\t\t\t\t// listitem is mostly historical. it uses some shared HTML, but\n\t\t\t\t// if I were\n\t\t\t\t// doing it from scratch I wouldn't make this distinction. At\n\t\t\t\t// the moment it's\n\t\t\t\t// everything that isn't inline.\n\n\t\t\t\tboolean listItem = !(i.getType() == SimplePageItem.TEXT || i.getType() == SimplePageItem.MULTIMEDIA\n\t\t\t\t\t\t|| i.getType() == SimplePageItem.COMMENTS || i.getType() == SimplePageItem.STUDENT_CONTENT);\n\t\t\t\t// (i.getType() == SimplePageItem.PAGE &&\n\t\t\t\t// \"button\".equals(i.getFormat())))\n\n\t\t\t\tUIBranchContainer tableRow = UIBranchContainer.make(tableContainer, \"item:\");\n\t\t\t\tif (!simplePageBean.isItemVisible(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// you really need the HTML file open at the same time to make\n\t\t\t\t// sense of the following code\n\t\t\t\tif (listItem) { // Not an HTML Text, Element or Multimedia\n\t\t\t\t\t// Element\n\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id2\", String.valueOf(i.getId()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// users can declare a page item to be navigational. If so\n\t\t\t\t\t// we display\n\t\t\t\t\t// it to the left of the normal list items, and use a\n\t\t\t\t\t// button. This is\n\t\t\t\t\t// used for pages that are \"next\" pages, i.e. they replace\n\t\t\t\t\t// this page\n\t\t\t\t\t// rather than creating a new level in the breadcrumbs.\n\t\t\t\t\t// Since they can't\n\t\t\t\t\t// be required, they don't need the status image, which is\n\t\t\t\t\t// good because\n\t\t\t\t\t// they're displayed with colspan=2, so there's no space for\n\t\t\t\t\t// the image.\n\n\t\t\t\t\tboolean navButton = \"button\".equals(i.getFormat()) && !i.isRequired();\n\t\t\t\t\tboolean notDone = false;\n\t\t\t\t\tStatus status = Status.NOT_REQUIRED;\n\t\t\t\t\tif (!navButton) {\n\t\t\t\t\t\tstatus = handleStatusImage(tableRow, i);\n\t\t\t\t\t\tif (status == Status.REQUIRED) {\n\t\t\t\t\t\t\tnotDone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tboolean isInline = (i.getType() == SimplePageItem.BLTI && \"inline\".equals(i.getFormat()));\n\n\t\t\t\t\tUIOutput linktd = UIOutput.make(tableRow, \"item-td\");\n\t\t\t\t\tUIBranchContainer linkdiv = null;\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    linkdiv = UIBranchContainer.make(tableRow, \"link-div:\");\n\t\t\t\t\t    UIOutput itemicon = UIOutput.make(linkdiv,\"item-icon\");\n\t\t\t\t\t    switch (i.getType()) {\n\t\t\t\t\t    case SimplePageItem.FORUM:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/comments.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/page_edit.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/pencil.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.BLTI:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/application_go.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.PAGE:\n\t\t\t\t\t\titemicon.decorate(new UIFreeAttributeDecorator(\"src\", \"/library/image/silk/book_open.png\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    case SimplePageItem.RESOURCE:\n\t\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\t\t\n\t\t\t\t\t\tString src = imageToMimeMap.get(mimeType);\n\t\t\t\t\t\tif (src == null) {\n\t\t\t\t\t\t    String image = ContentTypeImageService.getContentTypeImage(mimeType);\n\t\t\t\t\t\t    if (image != null)\n\t\t\t\t\t\t\tsrc = \"/library/image/\" + image;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(src != null) {\n\t\t\t\t\t\t    itemicon.decorate(new UIFreeAttributeDecorator(\"src\", src));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput descriptiondiv = null;\n\n\t\t\t\t\t// refresh isn't actually used anymore. We've changed the\n\t\t\t\t\t// way things are\n\t\t\t\t\t// done so the user never has to request a refresh.\n\t\t\t\t\t//   FYI: this actually puts in an IFRAME for inline BLTI items\n\t\t\t\t\tshowRefresh = !makeLink(tableRow, \"link\", i, canEditPage, currentPage, notDone, status) || showRefresh;\n\n\t\t\t\t\t// dummy is used when an assignment, quiz, or forum item is\n\t\t\t\t\t// copied\n\t\t\t\t\t// from another site. The way the copy code works, our\n\t\t\t\t\t// import code\n\t\t\t\t\t// doesn't have access to the necessary info to use the item\n\t\t\t\t\t// from the\n\t\t\t\t\t// new site. So we add a dummy, which generates an\n\t\t\t\t\t// explanation that the\n\t\t\t\t\t// author is going to have to choose the item from the\n\t\t\t\t\t// current site\n\t\t\t\t\tif (i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\tString code = null;\n\t\t\t\t\t\tswitch (i.getType()) {\n\t\t\t\t\t\tcase SimplePageItem.ASSIGNMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assignment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.ASSESSMENT:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.assessment\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SimplePageItem.FORUM:\n\t\t\t\t\t\t\tcode = \"simplepage.copied.forum\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", messageLocator.getMessage(code));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdescriptiondiv = UIOutput.make(tableRow, \"description\", i.getDescription());\n\t\t\t\t\t}\n\t\t\t\t\tif (isInline)\n\t\t\t\t\t    descriptiondiv.decorate(new UIFreeAttributeDecorator(\"style\", \"margin-top: 4px\"));\n\n\t\t\t\t\tif (!isInline) {\n\t\t\t\t\t    // nav button gets float left so any description goes to its\n\t\t\t\t\t    // right. Otherwise the\n\t\t\t\t\t    // description block will display underneath\n\t\t\t\t\t    if (\"button\".equals(i.getFormat())) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"style\", \"float:left\"));\n\t\t\t\t\t    }\n\t\t\t\t\t    // for accessibility\n\t\t\t\t\t    if (navButton) {\n\t\t\t\t\t\tlinkdiv.decorate(new UIFreeAttributeDecorator(\"role\", \"navigation\"));\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\t// note that a lot of the info here is used by the\n\t\t\t\t\t// javascript that prepares\n\t\t\t\t\t// the jQuery dialogs\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-td\");\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.generic\").replace(\"{}\", i.getName())));\n\n\t\t\t\t\t\t// the following information is displayed using <INPUT\n\t\t\t\t\t\t// type=hidden ...\n\t\t\t\t\t\t// it contains information needed to populate the \"edit\"\n\t\t\t\t\t\t// popup dialog\n\t\t\t\t\t\tUIOutput.make(tableRow, \"prerequisite-info\", String.valueOf(i.isPrerequisite()));\n\n\t\t\t\t\t\tString itemGroupString = null;\n\n\t\t\t\t\t\tif (i.getType() == SimplePageItem.ASSIGNMENT) {\n\t\t\t\t\t\t\t// the type indicates whether scoring is letter\n\t\t\t\t\t\t\t// grade, number, etc.\n\t\t\t\t\t\t\t// the javascript needs this to present the right\n\t\t\t\t\t\t\t// choices to the user\n\t\t\t\t\t\t\t// types 6 and 8 aren't legal scoring types, so they\n\t\t\t\t\t\t\t// are used as\n\t\t\t\t\t\t\t// markers for quiz or forum. I ran out of numbers\n\t\t\t\t\t\t\t// and started using\n\t\t\t\t\t\t\t// text for things that aren't scoring types. That's\n\t\t\t\t\t\t\t// better anyway\n\t\t\t\t\t\t\tint type = 4;\n\t\t\t\t\t\t\tLessonEntity assignment = null;\n\t\t\t\t\t\t\tif (!i.getSakaiId().equals(SimplePageItem.DUMMY)) {\n\t\t\t\t\t\t\t\tassignment = assignmentEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\t\tif (assignment != null) {\n\t\t\t\t\t\t\t\t\ttype = assignment.getTypeOfGrade();\n\t\t\t\t\t\t\t\t\tString editUrl = assignment.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, assignment, true);\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", String.valueOf(type));\n\t\t\t\t\t\t\tString requirement = String.valueOf(i.getSubrequirement());\n\t\t\t\t\t\t\tif ((type == SimplePageItem.PAGE || type == SimplePageItem.ASSIGNMENT) && i.getSubrequirement()) {\n\t\t\t\t\t\t\t\trequirement = i.getRequirementText();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", requirement);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.ASSESSMENT) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"6\"); // Not used by\n\t\t\t\t\t\t\t// assignments,\n\t\t\t\t\t\t\t// so it is\n\t\t\t\t\t\t\t// safe to dedicate to assessments\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"requirement-text\", (i.getSubrequirement() ? i.getRequirementText() : \"false\"));\n\t\t\t\t\t\t\tLessonEntity quiz = quizEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (quiz != null) {\n\t\t\t\t\t\t\t\tString editUrl = quiz.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teditUrl = quiz.editItemSettingsUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-settings-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, quiz, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.BLTI) {\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"type\", \"b\");\n\t\t\t\t\t\t    LessonEntity blti= (bltiEntity == null ? null : bltiEntity.getEntity(i.getSakaiId()));\n\t\t\t\t\t\t    if (blti != null) {\n\t\t\t\t\t\t\tString editUrl = blti.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\tif (editUrl != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-format\", i.getFormat());\n\n\t\t\t\t\t\t\tif (i.getHeight() != null)\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-height\", i.getHeight());\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.FORUM) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"extra-info\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"8\");\n\t\t\t\t\t\t\tLessonEntity forum = forumEntity.getEntity(i.getSakaiId());\n\t\t\t\t\t\t\tif (forum != null) {\n\t\t\t\t\t\t\t\tString editUrl = forum.editItemUrl(simplePageBean);\n\t\t\t\t\t\t\t\tif (editUrl != null) {\n\t\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"edit-url\", editUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, forum, true);\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.PAGE) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"type\", \"page\");\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-next\", Boolean.toString(i.getNextPage()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"page-button\", Boolean.toString(\"button\".equals(i.getFormat())));\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\t\t\t\t\t\t} else if (i.getType() == SimplePageItem.RESOURCE) {\n\t\t\t\t\t\t        itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\t\tif (simplePageBean.getInherited())\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", \"--inherited--\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-groups\", itemGroupString );\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-samewindow\", Boolean.toString(i.isSameWindow()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\titemGroupString = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\t    UIOutput.make(tableRow, (isInline ? \"item-group-titles-div\" : \"item-group-titles\"), \" [\" + itemGroupString + \"]\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// the following are for the inline item types. Multimedia\n\t\t\t\t\t// is the most complex because\n\t\t\t\t\t// it can be IMG, IFRAME, or OBJECT, and Youtube is treated\n\t\t\t\t\t// separately\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.MULTIMEDIA) {\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups\", itemGroupString);\n\n\t\t\t\t\t// the reason this code is complex is that we try to choose\n\t\t\t\t\t// the best\n\t\t\t\t\t// HTML for displaying the particular type of object. We've\n\t\t\t\t\t// added complexities\n\t\t\t\t\t// over time as we get more experience with different\n\t\t\t\t\t// object types and browsers.\n\n\t\t\t\t\tStringTokenizer token = new StringTokenizer(i.getSakaiId(), \".\");\n\n\t\t\t\t\tString extension = \"\";\n\n\t\t\t\t\twhile (token.hasMoreTokens()) {\n\t\t\t\t\t\textension = token.nextToken().toLowerCase();\n\t\t\t\t\t}\n\n\t\t\t\t\t// the extension is almost never used. Normally we have\n\t\t\t\t\t// the MIME type and use it. Extension is used only if\n\t\t\t\t\t// for some reason we don't have the MIME type\n\t\t\t\t\tUIComponent item;\n\t\t\t\t\tString youtubeKey;\n\n\t\t\t\t\tLength width = null;\n\t\t\t\t\tif (i.getWidth() != null) {\n\t\t\t\t\t\twidth = new Length(i.getWidth());\n\t\t\t\t\t}\n\t\t\t\t\tLength height = null;\n\t\t\t\t\tif (i.getHeight() != null) {\n\t\t\t\t\t\theight = new Length(i.getHeight());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the MIME type. For multimedia types is should be in\n\t\t\t\t\t// the html field.\n\t\t\t\t\t// The old code saved the URL there. So if it looks like a\n\t\t\t\t\t// URL ignore it.\n\t\t\t\t\tString mimeType = i.getHtml();\n\t\t\t\t\tif (mimeType != null && (mimeType.startsWith(\"http\") || mimeType.equals(\"\"))) {\n\t\t\t\t\t\tmimeType = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// here goes. dispatch on the type and produce the right tag\n\t\t\t\t\t// type,\n\t\t\t\t\t// followed by the hidden INPUT tags with information for the\n\t\t\t\t\t// edit dialog\n\t\t\t\t\tif (simplePageBean.isImageType(i)) {\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"imageSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles3\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups3\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tString imageName = i.getAlt();\n\t\t\t\t\t\tif (imageName == null || imageName.equals(\"\")) {\n\t\t\t\t\t\t\timageName = abbrevUrl(i.getURL());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"image\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", imageName));\n\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(lengthOk(height)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// stuff for the jquery dialog\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"imageWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description2\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype2\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id4\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ((youtubeKey = simplePageBean.getYoutubeKey(i)) != null) {\n\t\t\t\t\t\tString youtubeUrl = \"http://www.youtube.com/v/\" + youtubeKey + \"?version=3\";\n\t\t\t\t\t\t// this is very odd. The official youtube embedding uses\n\t\t\t\t\t\t// <OBJECT> with\n\t\t\t\t\t\t// a stylesheet to specify size. But the only values\n\t\t\t\t\t\t// that actually\n\t\t\t\t\t\t// work are px and percent. I.e. it works just like the\n\t\t\t\t\t\t// old\n\t\t\t\t\t\t// HTML length types. A real stylesheet length\n\t\t\t\t\t\t// understands other units.\n\t\t\t\t\t\t// I'm generating a style sheet, so that our HTML\n\t\t\t\t\t\t// embedding is as close\n\t\t\t\t\t\t// to theirs as possible, even the lengths are actually\n\t\t\t\t\t\t// interpreted as old style\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles4\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups4\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if width is blank or 100% scale the height\n\t\t\t\t\t\tif (width != null && height != null && !height.number.equals(\"\")) {\n\t\t\t\t\t\t\tif (width.number.equals(\"\") && width.unit.equals(\"\") || width.number.equals(\"100\") && width.unit.equals(\"%\")) {\n\n\t\t\t\t\t\t\t\tint h = Integer.parseInt(height.number);\n\t\t\t\t\t\t\t\tif (h > 0) {\n\t\t\t\t\t\t\t\t\twidth.number = Integer.toString((int) Math.round(h * 1.641025641));\n\t\t\t\t\t\t\t\t\twidth.unit = height.unit;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// <object style=\"height: 390px; width: 640px\"><param\n\t\t\t\t\t\t// name=\"movie\"\n\t\t\t\t\t\t// value=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"><param\n\t\t\t\t\t\t// name=\"allowFullScreen\" value=\"true\"><param\n\t\t\t\t\t\t// name=\"allowScriptAccess\" value=\"always\"><embed\n\t\t\t\t\t\t// src=\"http://www.youtube.com/v/AKIC7OQqBrA?version=3\"\n\t\t\t\t\t\t// type=\"application/x-shockwave-flash\"\n\t\t\t\t\t\t// allowfullscreen=\"true\" allowScriptAccess=\"always\"\n\t\t\t\t\t\t// width=\"640\" height=\"390\"><\/object>\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeObject\");\n\t\t\t\t\t\t// youtube seems ok with length and width\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"style\", getStyle(width, height)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.youtube_player\")));\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", youtubeUrl));\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"youtubeEmbed\").decorate(new UIFreeAttributeDecorator(\"type\", \"application/x-shockwave-flash\")).decorate(new UIFreeAttributeDecorator(\"src\", youtubeUrl));\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtubeId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeURL\", youtubeUrl);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"currentYoutubeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description4\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id5\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"youtube-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"youtube-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.youtube\")));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// as of Oct 28, 2010, we store the mime type. mimeType\n\t\t\t\t\t\t// null is an old entry.\n\t\t\t\t\t\t// For that use the old approach of checking the\n\t\t\t\t\t\t// extension.\n\t\t\t\t\t\t// Otherwise we want to use iframes for HTML and OBJECT\n\t\t\t\t\t\t// for everything else\n\t\t\t\t\t\t// We need the iframes because IE up through 8 doesn't\n\t\t\t\t\t\t// reliably display\n\t\t\t\t\t\t// HTML with OBJECT. Experiments show that everything\n\t\t\t\t\t\t// else works with OBJECT\n\t\t\t\t\t\t// for most browsers. Unfortunately IE, even IE 9,\n\t\t\t\t\t\t// doesn't reliably call the\n\t\t\t\t\t\t// right player with OBJECT. EMBED works. But it's not\n\t\t\t\t\t\t// as nice because you can't\n\t\t\t\t\t\t// nest error recovery code. So we use OBJECT for\n\t\t\t\t\t\t// everything except IE, where we\n\t\t\t\t\t\t// use EMBED. OBJECT does work with Flash.\n\t\t\t\t\t\t// application/xhtml+xml is XHTML.\n\n\t\t\t\t\t} else if ((mimeType != null && !mimeType.equals(\"text/html\") && !mimeType.equals(\"application/xhtml+xml\")) || (mimeType == null && Arrays.binarySearch(multimediaTypes, extension) >= 0)) {\n\n\t\t\t\t\t\t// this code is used for everything that isn't an image,\n\t\t\t\t\t\t// Youtube, or HTML. Typically\n\t\t\t\t\t\t// this is a flash presentation or a movie. Try to be\n\t\t\t\t\t\t// smart about how we show movies.\n\t\t\t\t\t\t// HTML is done with an IFRAME in the next \"if\" case\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles5\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups5\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIComponent item2;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"movieSpan\");\n\n\t\t\t\t\t\tString movieUrl = i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner());\n\t\t\t\t\t\tString oMimeType = mimeType; // in case we change it for\n\t\t\t\t\t\t// FLV or others\n\t\t\t\t\t\tboolean useFlvPlayer = false;\n\t\t\t\t\t\tboolean useJwPlayer = false;\n\t\t\t\t\t\t// in theory m4v can be DMRed. But Apple's DRM is\n\t\t\t\t\t\t// useless on a web page, so it's got to be an\n\t\t\t\t\t\t// unprotected file.\n\t\t\t\t\t\tboolean isMp4 = mimeType.equals(\"video/mp4\") || mimeType.equals(\"video/x-m4v\");\n\t\t\t\t\t\t// FLV is special. There's no player for flash video in\n\t\t\t\t\t\t// the browser\n\t\t\t\t\t\t// it shows with a special flash program, which I\n\t\t\t\t\t\t// supply. For the moment MP4 is\n\t\t\t\t\t\t// shown with the same player so it uses much of the\n\t\t\t\t\t\t// same code\n\t\t\t\t\t\tif (mimeType != null && (mimeType.equals(\"video/x-flv\") || isMp4)) {\n\t\t\t\t\t\t\tmimeType = \"application/x-shockwave-flash\";\n\t\t\t\t\t\t\tuseJwPlayer = ServerConfigurationService.getBoolean(\"lessonbuilder.usejwplayer\", false);\n\t\t\t\t\t\t\tif (useJwPlayer) {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/jwflvplayer.swf\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmovieUrl = \"/sakai-lessonbuildertool-tool/templates/StrobeMediaPlayback.swf\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuseFlvPlayer = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// for IE, if we're not supplying a player it's safest\n\t\t\t\t\t\t// to use embed\n\t\t\t\t\t\t// otherwise Quicktime won't work. Oddly, with IE 9 only\n\t\t\t\t\t\t// it works if you set CLASSID to the MIME type,\n\t\t\t\t\t\t// but that's so unexpected that I hate to rely on it.\n\t\t\t\t\t\t// EMBED is in HTML 5, so I think we're OK\n\t\t\t\t\t\t// using it permanently for IE.\n\t\t\t\t\t\t// I prefer OBJECT where possible because of the nesting\n\t\t\t\t\t\t// ability.\n\t\t\t\t\t\tboolean useEmbed = ieVersion > 0 && !mimeType.equals(\"application/x-shockwave-flash\");\n\n\t\t\t\t\t\tif (useEmbed) {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieEmbed\").decorate(new UIFreeAttributeDecorator(\"src\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"movieObject\").decorate(new UIFreeAttributeDecorator(\"data\", movieUrl)).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mimeType != null) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", mimeType));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"style\", \"border: 1px solid black\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\tif (useFlvPlayer) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"flashvars\").decorate(new UIFreeAttributeDecorator(\"value\", (useJwPlayer ? \"file=\" : \"src=\") + URLEncoder.encode(myUrl() + i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieURLInject\").decorate(new UIFreeAttributeDecorator(\"value\", movieUrl));\n\t\t\t\t\t\t\tif (!isMp4) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"noplugin-br\");\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"noplugin\", i.getName(), movieUrl);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isMp4) {\n\t\t\t\t\t\t\t// do fallback. for ie use EMBED\n\t\t\t\t\t\t\tif (ieVersion > 0) {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-embed\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"alt\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titem2 = UIOutput.make(tableRow, \"mp4-object\").decorate(new UIFreeAttributeDecorator(\"data\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()))).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.mm_player\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (oMimeType != null) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"type\", oMimeType));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// some object types seem to need a specification\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem2.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!useEmbed) {\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-inject\").decorate(new UIFreeAttributeDecorator(\"value\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\n\t\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mp4-noplugin-p\", messageLocator.getMessage(\"simplepage.noplugin\"));\n\t\t\t\t\t\t\t\tUILink.make(tableRow, \"mp4-noplugin\", i.getName(), i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieId\", String.valueOf(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movieWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description3\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype5\", oMimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id6\", Long.toString(i.getId()));\n\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"movie-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"edit-movie\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// finally, HTML. Use an iframe\n\t\t\t\t\t\t// definition of resizeiframe, at top of page\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeSpan\");\n\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-group-titles2\", itemGroupTitles);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"item-groups2\", itemGroupString);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titem = UIOutput.make(tableRow, \"iframe\").decorate(new UIFreeAttributeDecorator(\"src\", i.getItemURL(simplePageBean.getCurrentSiteId(),currentPage.getOwner())));\n\t\t\t\t\t\t// if user specifies auto, use Javascript to resize the\n\t\t\t\t\t\t// iframe when the\n\t\t\t\t\t\t// content changes. This only works for URLs with the\n\t\t\t\t\t\t// same origin, i.e.\n\t\t\t\t\t\t// URLs in this sakai system\n\t\t\t\t\t\tif (getOrig(height).equals(\"auto\")) {\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"onload\", \"resizeiframe('\" + item.getFullID() + \"')\"));\n\t\t\t\t\t\t\tif (lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", \"300\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// we seem OK without a spec\n\t\t\t\t\t\t\tif (lengthOk(height) && lengthOk(width)) {\n\t\t\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"height\", height.getOld())).decorate(new UIFreeAttributeDecorator(\"width\", width.getOld()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\titem.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.web_content\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\n\t\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeHeight\", getOrig(height));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"iframeWidth\", getOrig(width));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"description5\", i.getDescription());\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"mimetype3\", mimeType);\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"current-item-id3\", Long.toString(i.getId()));\n\t\t\t\t\t\t\tUIOutput.make(tableRow, \"editmm-td\");\n\t\t\t\t\t\t\tUILink.make(tableRow, \"iframe-edit\", messageLocator.getMessage(\"simplepage.editItem\"), \"\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.url\").replace(\"{}\", abbrevUrl(i.getURL()))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end of multimedia object\n\n\t\t\t\t} else if (i.getType() == SimplePageItem.COMMENTS) {\n\t\t\t\t\t// Load later using AJAX and CommentsProducer\n\n\t\t\t\t\tUIOutput.make(tableRow, \"commentsSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.fake-missing-prereqs\"));\n\n\t\t\t\t\t// students get warning and not the content\n\t\t\t\t\tif (!isAvailable && !canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"missing-prereqs\", messageLocator.getMessage(\"simplepage.missing-prereqs\"));\n\t\t\t\t\telse {\n\t\t\t\t\t    UIOutput.make(tableRow, \"commentsDiv\");\n\t\t\t\t\t    Placement placement = toolManager.getCurrentPlacement();\n\t\t\t\t\t    UIOutput.make(tableRow, \"placementId\", placement.getId());\n\n\t\t\t\t\t    CommentsViewParameters eParams = new CommentsViewParameters(CommentsProducer.VIEW_ID);\n\t\t\t\t\t    eParams.itemId = i.getId();\n\t\t\t\t\t    if (params.postedComment) {\n\t\t\t\t\t\teParams.postedComment = postedCommentId;\n\t\t\t\t\t    }\n\n\t\t\t\t\t    UIInternalLink.make(tableRow, \"commentsLink\", eParams);\n\n\t\t\t\t\t    if (!addedCommentsScript) {\n\t\t\t\t\t\tUIOutput.make(tofill, \"comments-script\");\n\t\t\t\t\t\tUIOutput.make(tofill, \"fckScript\");\n\t\t\t\t\t\taddedCommentsScript = true;\n\t\t\t\t\t\tUIOutput.make(tofill, \"delete-dialog\");\n\t\t\t\t\t    }\n\n\t\t\t\t\t    if (canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"comments-td\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-comments\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.comments\")));\n\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsId\", String.valueOf(i.getId()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"commentsitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t    String itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t    if (itemGroupTitles != null) {\n\t\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"comments-groups\", itemGroupString);\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-group-titles6\", itemGroupTitles);\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\n\t\t\t\t\t    UIForm form = UIForm.make(tableRow, \"comment-form\");\n\n\t\t\t\t\t    UIInput.make(form, \"comment-item-id\", \"#{simplePageBean.itemId}\", String.valueOf(i.getId()));\n\t\t\t\t\t    UIInput.make(form, \"comment-edit-id\", \"#{simplePageBean.editId}\");\n\n\t\t\t\t\t    // usage * image is required and not done\n\t\t\t\t\t    if (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\tUIOutput.make(tableRow, \"comment-required-image\");\n\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-link\");\n\t\t\t\t\t    UIOutput.make(tableRow, \"add-comment-text\", messageLocator.getMessage(\"simplepage.add-comment\"));\n\t\t\t\t\t    UIInput fckInput = UIInput.make(form, \"comment-text-area-evolved:\", \"#{simplePageBean.formattedComment}\");\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"height\", \"175\"));\n\t\t\t\t\t    fckInput.decorate(new UIFreeAttributeDecorator(\"width\", \"800\"));\n\t\t\t\t\t    fckInput.decorate(new UIStyleDecorator(\"evolved-box\"));\n\n\t\t\t\t\t    ((SakaiFCKTextEvolver) richTextEvolver).evolveTextInput(fckInput, \"\" + commentsCount);\n\n\t\t\t\t\t    UICommand.make(form, \"add-comment\", \"#{simplePageBean.addComment}\");\n\t\t\t\t\t}\n\n\t\t\t\t}else if(i.getType() == SimplePageItem.STUDENT_CONTENT) {\n\t\t\t\t\tUIOutput.make(tableRow, \"studentSpan\");\n\n\t\t\t\t\tboolean isAvailable = simplePageBean.isItemAvailable(i);\n\t\t\t\t\t// faculty missing preqs get warning but still see the comments\n\t\t\t\t\tif (!isAvailable && canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-fake-missing-prereqs\"));\n\t\t\t\t\tif (!isAvailable && !canEditPage)\n\t\t\t\t\t    UIOutput.make(tableRow, \"student-missing-prereqs\", messageLocator.getMessage(\"simplepage.student-missing-prereqs\"));\n\t\t\t\t\telse {\n\t\t\t\t\t    UIOutput.make(tableRow, \"studentDiv\");\n\t\t\t\t\t\n\t\t\t\t\t    HashMap<Long, SimplePageLogEntry> cache = simplePageBean.cacheStudentPageLogEntries(i.getId());\n\t\t\t\t\t    List<SimpleStudentPage> studentPages = simplePageToolDao.findStudentPages(i.getId());\n\t\t\t\t\t\n\t\t\t\t\t    boolean hasOwnPage = false;\n\t\t\t\t\t    String userId = UserDirectoryService.getCurrentUser().getId();\n\t\t\t\t\t\n\t\t\t\t\t    HashMap<String, String> anonymousLookup = new HashMap<String, String>();\n\t\t\t\t\t    if(i.isAnonymous()) {\n\t\t\t\t\t\tint counter = 1;\n\t\t\t\t\t\tfor(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\t\tif(anonymousLookup.get(page.getOwner()) == null) {\n\t\t\t\t\t\t\t\tanonymousLookup.put(page.getOwner(), messageLocator.getMessage(\"simplepage.anonymous\") + \" \" + counter++);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t    // Print each row in the table\n\t\t\t\t\t    for(SimpleStudentPage page : studentPages) {\n\t\t\t\t\t\tif(page.isDeleted()) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tSimplePageLogEntry entry = cache.get(page.getPageId());\n\t\t\t\t\t\tUIBranchContainer row = UIBranchContainer.make(tableRow, \"studentRow:\");\n\t\t\t\t\t\tUIOutput.make(row, \"studentCell\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID, page.getPageId());\n\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\teParams.setPath(\"push\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tString username = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tusername = i.isAnonymous()? anonymousLookup.get(page.getOwner()) : UserDirectoryService.getUser(page.getOwner()).getDisplayName();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(i.isAnonymous() && canEditPage) {\n\t\t\t\t\t\t\t\tusername += \" (\" + UserDirectoryService.getUser(page.getOwner()).getDisplayName() + \")\";\n\t\t\t\t\t\t\t}else if(i.isAnonymous() && page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\t\tusername += \" (\" + messageLocator.getMessage(\"simplepage.comment-you\") + \")\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (UserNotDefinedException e) {\n\t\t\t\t\t\t\tusername = page.getTitle();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIInternalLink.make(row, \"studentLink\", username, eParams);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Never visited page\n\t\t\t\t\t\tif(entry == null) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"newPageImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-page\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// There's content they haven't seen\n\t\t\t\t\t\tif(entry == null || entry.getLastViewed().compareTo(page.getLastUpdated()) < 0) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"newContentImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-content\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// The comments tool exists, so we might have to show the icon\n\t\t\t\t\t\tif(i.getShowComments() != null && i.getShowComments()) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"commentsImgCell\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// New comments have been added since they last viewed the page\n\t\t\t\t\t\tif(page.getLastCommentChange() != null && (entry == null || entry.getLastViewed().compareTo(page.getLastCommentChange()) < 0)) {\n\t\t\t\t\t\t\tUIOutput.make(row, \"newCommentsImg\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.new-student-comments\")));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(page.getOwner().equals(userId)) {\n\t\t\t\t\t\t\thasOwnPage = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t    if(!hasOwnPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"linkRow\");\n\t\t\t\t\t\tUIOutput.make(tableRow, \"linkCell\");\n\n\t\t\t\t\t\tif (i.isRequired() && !simplePageBean.isItemComplete(i))\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"student-required-image\");\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters(ShowPageProducer.VIEW_ID);\n\t\t\t\t\t\teParams.addTool = GeneralViewParameters.STUDENT_PAGE;\n\t\t\t\t\t\teParams.studentItemId = i.getId();\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"linkLink\", messageLocator.getMessage(\"simplepage.add-page\"), eParams);\n\t\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t\t\t    if(canEditPage) {\n\t\t\t\t\t\tUIOutput.make(tableRow, \"student-td\");\n\t\t\t\t\t\tUILink.make(tableRow, \"edit-student\", messageLocator.getMessage(\"simplepage.editItem\"), \"\")\n\t\t\t\t\t\t\t\t.decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.student\")));\n\t\t\t\t\t\t\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentId\", String.valueOf(i.getId()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentAnon\", String.valueOf(i.isAnonymous()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentComments\", String.valueOf(i.getShowComments()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"forcedAnon\", String.valueOf(i.getForcedCommentsAnonymous()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-required\", String.valueOf(i.isRequired()));\n\t\t\t\t\t\tUIOutput.make(tableRow, \"studentitem-prerequisite\", String.valueOf(i.isPrerequisite()));\n\t\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\t\tif (itemGroupString != null) {\n\t\t\t\t\t\t    String itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\t\t    if (itemGroupTitles != null) {\n\t\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"student-groups\", itemGroupString);\n\t\t\t\t\t\t    UIOutput.make(tableRow, \"item-group-titles7\", itemGroupTitles);\n\t\t\t\t\t\t}\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t}  else {\n\t\t\t\t\t// remaining type must be a block of HTML\n\t\t\t\t\tUIOutput.make(tableRow, \"itemSpan\");\n\n\t\t\t\t\tString itemGroupString = simplePageBean.getItemGroupString(i, null, true);\n\t\t\t\t\tString itemGroupTitles = simplePageBean.getItemGroupTitles(itemGroupString);\n\t\t\t\t\tif (itemGroupTitles != null) {\n\t\t\t\t\t\titemGroupTitles = \"[\" + itemGroupTitles + \"]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tUIOutput.make(tableRow, \"item-groups-titles-text\", itemGroupTitles);\n\n\t\t\t\t\tUIVerbatim.make(tableRow, \"content\", (i.getHtml() == null ? \"\" : i.getHtml()));\n\n\t\t\t\t\t// editing is done using a special producer that calls FCK.\n\t\t\t\t\tif (canEditPage) {\n\t\t\t\t\t\tGeneralViewParameters eParams = new GeneralViewParameters();\n\t\t\t\t\t\teParams.setSendingPage(currentPage.getPageId());\n\t\t\t\t\t\teParams.setItemId(i.getId());\n\t\t\t\t\t\teParams.viewID = EditPageProducer.VIEW_ID;\n\t\t\t\t\t\tUIOutput.make(tableRow, \"edittext-td\");\n\t\t\t\t\t\tUIInternalLink.make(tableRow, \"edit-link\", messageLocator.getMessage(\"simplepage.editItem\"), eParams).decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.edit-title.textbox\").replace(\"{}\", Integer.toString(textboxcount))));\n\n\t\t\t\t\t\ttextboxcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// end of items. This is the end for normal users. Following is\n\t\t\t// special\n\t\t\t// checks and putting out the dialogs for the popups, for\n\t\t\t// instructors.\n\n\t\t\tboolean showBreak = false;\n\n\t\t\t// I believe refresh is now done automatically in all cases\n\t\t\t// if (showRefresh) {\n\t\t\t// UIOutput.make(tofill, \"refreshAlert\");\n\t\t\t//\n\t\t\t// // Should simply refresh\n\t\t\t// GeneralViewParameters p = new GeneralViewParameters(VIEW_ID);\n\t\t\t// p.setSendingPage(currentPage.getPageId());\n\t\t\t// UIInternalLink.make(tofill, \"refreshLink\", p);\n\t\t\t// showBreak = true;\n\t\t\t// }\n\n\t\t\t// stuff goes on the page in the order in the HTML file. So the fact\n\t\t\t// that it's here doesn't mean it shows\n\t\t\t// up at the end. This code produces errors and other odd stuff.\n\n\t\t\tif (canEditPage) {\n\t\t\t\t// if the page is hidden, warn the faculty [students get stopped\n\t\t\t\t// at\n\t\t\t\t// the top]\n\t\t\t\tif (currentPage.isHidden()) {\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.pagehidden\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.pagehidden.text\"));\n\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t\t// similarly warn them if it isn't released yet\n\t\t\t\t} else if (currentPage.getReleaseDate() != null && currentPage.getReleaseDate().after(new Date())) {\n\t\t\t\t\tDateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, M_locale);\n\t\t\t\t\tTimeZone tz = timeService.getLocalTimeZone();\n\t\t\t\t\tdf.setTimeZone(tz);\n\t\t\t\t\tString releaseDate = df.format(currentPage.getReleaseDate());\n\t\t\t\t\tUIOutput.make(tofill, \"hiddenAlert\").decorate(new UIFreeAttributeDecorator(\"title\", messageLocator.getMessage(\"simplepage.notreleased\")));\n\t\t\t\t\tUIVerbatim.make(tofill, \"hidden-text\", messageLocator.getMessage(\"simplepage.notreleased.text\").replace(\"{}\", releaseDate));\n\t\t\t\t\tshowBreak = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showBreak) {\n\t\t\t\tUIOutput.make(tofill, \"breakAfterWarnings\");\n\t\t\t}\n\t\t}\n\n\t\t// more warnings: if no item on the page, give faculty instructions,\n\t\t// students an error\n\t\tif (itemList.size() == 0) {\n\t\t\tif (canEditPage) {\n\t\t\t\tUIOutput.make(tofill, \"startupHelp\")\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"src\", \n\t\t\t\t\tgetLocalizedURL( (pageItem.getType() == SimplePageItem.STUDENT_CONTENT) ? \"student.html\" : \"general.html\")))\n\t\t\t\t    .decorate(new UIFreeAttributeDecorator(\"id\", \"iframe\"));\n\t\t\t\tUIOutput.make(tofill, \"iframeJavascript\");\n\n\t\t\t} else {\n\t\t\t\tUIOutput.make(tofill, \"error-div\");\n\t\t\t\tUIOutput.make(tofill, \"error\", messageLocator.getMessage(\"simplepage.noitems_error_user\"));\n\t\t\t}\n\t\t}\n\n\t\t// now output the dialogs. but only for faculty (to avoid making the\n\t\t// file bigger)\n\t\tif (canEditPage) {\n\t\t\tcreateSubpageDialog(tofill, currentPage);\n\t\t}\n\n\t\tcreateDialogs(tofill, currentPage, pageItem);\n\t}","commit_id":"e7b01f450e7cbe4c976669355d3d1223c6cf63a9","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    FileChooserDescriptor fcd = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    fcd.setShowFileSystemRoots(true);\n    fcd.setTitle(GitBundle.getString(\"init.destination.directory.title\"));\n    fcd.setDescription(GitBundle.getString(\"init.destination.directory.description\"));\n    fcd.setHideIgnored(false);\n    VirtualFile baseDir = e.getData(PlatformDataKeys.VIRTUAL_FILE);\n    if (baseDir == null) {\n      baseDir = project.getBaseDir();\n    }\n    final VirtualFile root = FileChooser.chooseFile(project, fcd, baseDir);\n    if (root == null) {\n      return;\n    }\n    if (GitUtil.isUnderGit(root)) {\n      final int v = Messages.showYesNoDialog(project,\n                                             GitBundle.message(\"init.warning.already.under.git\",\n                                                               StringUtil.escapeXml(root.getPresentableUrl())),\n                                             GitBundle.getString(\"init.warning.title\"),\n                                             Messages.getWarningIcon());\n      if (v != 0) {\n        return;\n      }\n    }\n\n    Git git = ServiceManager.getService(Git.class);\n\n    GitCommandResult result = git.init(project, root);\n    if (!result.success()) {\n      GitUIUtil.notify(GitVcs.IMPORTANT_ERROR_NOTIFICATION, project, \"Git init failed\", result.getErrorOutputAsHtmlString(),\n                       NotificationType.ERROR, null);\n      return;\n    }\n\n    if (project.isDefault()) return;\n    int rc = Messages.showYesNoDialog(project, GitBundle.getString(\"init.add.root.message\"), GitBundle.getString(\"init.add.root.title\"),\n                                      Messages.getQuestionIcon());\n    if (rc != 0) {\n      return;\n    }\n    final String path = root.equals(baseDir) ? \"\" : root.getPath();\n    final Project finalProject = project;\n    GitVcs.runInBackground(new Task.Backgroundable(finalProject, GitBundle.getString(\"common.refreshing\")) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        refreshAndConfigureVcsMappings(finalProject, root, path);\n      }\n    });\n  }","id":86054,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project == null) {\n      project = ProjectManager.getInstance().getDefaultProject();\n    }\n    FileChooserDescriptor fcd = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    fcd.setShowFileSystemRoots(true);\n    fcd.setTitle(GitBundle.getString(\"init.destination.directory.title\"));\n    fcd.setDescription(GitBundle.getString(\"init.destination.directory.description\"));\n    fcd.setHideIgnored(false);\n    VirtualFile baseDir = e.getData(PlatformDataKeys.VIRTUAL_FILE);\n    if (baseDir == null) {\n      baseDir = project.getBaseDir();\n    }\n    final VirtualFile root = FileChooser.chooseFile(project, fcd, baseDir);\n    if (root == null) {\n      return;\n    }\n    if (GitUtil.isUnderGit(root)) {\n      final int v = Messages.showYesNoDialog(project,\n                                             GitBundle.message(\"init.warning.already.under.git\",\n                                                               StringUtil.escapeXml(root.getPresentableUrl())),\n                                             GitBundle.getString(\"init.warning.title\"),\n                                             Messages.getWarningIcon());\n      if (v != 0) {\n        return;\n      }\n    }\n\n    Git git = ServiceManager.getService(Git.class);\n    GitVcs vcs = GitVcs.getInstance(project);\n    GitCommandResult result = git.init(project, root);\n    if (!result.success()) {\n      if (vcs != null && vcs.getExecutableValidator().isExecutableValid()) {\n        GitUIUtil.notify(GitVcs.IMPORTANT_ERROR_NOTIFICATION, project, \"Git init failed\", result.getErrorOutputAsHtmlString(),\n                         NotificationType.ERROR, null);\n      }\n      return;\n    }\n\n    if (project.isDefault()) return;\n    int rc = Messages.showYesNoDialog(project, GitBundle.getString(\"init.add.root.message\"), GitBundle.getString(\"init.add.root.title\"),\n                                      Messages.getQuestionIcon());\n    if (rc != 0) {\n      return;\n    }\n    final String path = root.equals(baseDir) ? \"\" : root.getPath();\n    final Project finalProject = project;\n    GitVcs.runInBackground(new Task.Backgroundable(finalProject, GitBundle.getString(\"common.refreshing\")) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        refreshAndConfigureVcsMappings(finalProject, root, path);\n      }\n    });\n  }","commit_id":"9f3d0e8ac113452da2ef37ba8122f7a67ea63596","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private synchronized void changeState(ClientAppState state, Exception e) {\n        _state = state;\n        _mgr.notify(this, state, null, e);\n    }","id":86055,"modified_method":"private synchronized void changeState(ClientAppState state, Exception e) {\n        _state = state;\n        if (_mgr != null)\n            _mgr.notify(this, state, null, e);\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            changeState(STOPPING);\n            for (LifeCycle lc : _jettys) {\n                if (lc.isRunning()) {\n                    try {\n                        lc.stop();\n                    } catch (Exception e) {\n                        changeState(STOPPING, e);\n                    }\n                }\n            }\n            changeState(STOPPED);\n        }","id":86056,"modified_method":"public void run() {\n            for (LifeCycle lc : _jettys) {\n                if (lc.isRunning()) {\n                    try {\n                        lc.stop();\n                    } catch (Exception e) {\n                        changeState(STOPPING, e);\n                    }\n                }\n            }\n            changeState(STOPPED);\n        }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n         *  Modified from XmlConfiguration.main()\n         */\n        public void run() {\n            changeState(STARTING);\n            for (LifeCycle lc : _jettys) {\n                if (!lc.isRunning()) {\n                    try {\n                        lc.start();\n                    } catch (Exception e) {\n                        changeState(START_FAILED, e);\n                        return;\n                    }\n                }\n            }\n            changeState(RUNNING);\n            _mgr.register(JettyStart.this);\n        }","id":86057,"modified_method":"/**\n         *  Modified from XmlConfiguration.main()\n         */\n        public void run() {\n            for (LifeCycle lc : _jettys) {\n                if (!lc.isRunning()) {\n                    try {\n                        lc.start();\n                    } catch (Exception e) {\n                        changeState(START_FAILED, e);\n                        return;\n                    }\n                }\n            }\n            changeState(RUNNING);\n            if (_mgr != null)\n                _mgr.register(JettyStart.this);\n        }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Starter() {\n            super(\"JettyStarter\");\n        }","id":86058,"modified_method":"public Starter() {\n            super(\"JettyStarter\");\n            changeState(STARTING);\n        }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Stopper() {\n            super(\"JettyStopper\");\n        }","id":86059,"modified_method":"public Stopper() {\n            super(\"JettyStopper\");\n            changeState(STOPPING);\n        }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  All args must be XML file names.\n     *  Does not support any of the other argument types from org.mortbay.start.Main.\n     */\n    public JettyStart(I2PAppContext context, ClientAppManager mgr, String[] args) throws Exception {\n        _state = UNINITIALIZED;\n        _context = context;\n        _mgr = mgr;\n        _args = args;\n        _jettys = new ArrayList(args.length);\n        parseArgs(args);\n        _state = INITIALIZED;\n    }","id":86060,"modified_method":"/**\n     *  All args must be XML file names.\n     *  Does not support any of the other argument types from org.mortbay.start.Main.\n     *\n     *  @param context unused, may be null\n     *  @param mgr may be null e.g. for use in plugins\n     */\n    public JettyStart(I2PAppContext context, ClientAppManager mgr, String[] args) throws Exception {\n        _state = UNINITIALIZED;\n        _mgr = mgr;\n        _args = args;\n        _jettys = new ArrayList(args.length);\n        parseArgs(args);\n        _state = INITIALIZED;\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public RouterAppManager(RouterContext ctx) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(RouterAppManager.class);\n        _clients = new ConcurrentHashMap(16);\n        _registered = new ConcurrentHashMap(8);\n    }","id":86061,"modified_method":"public RouterAppManager(RouterContext ctx) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(RouterAppManager.class);\n        _clients = new ConcurrentHashMap(16);\n        _registered = new ConcurrentHashMap(8);\n        ctx.addShutdownTask(new Shutdown());\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  http://irc.codehaus.org/display/JETTY/Porting+to+jetty6\n     *\n     *<pre>\n     *\tServer\n     *\t\tHandlerCollection\n     *\t\t\tContextHandlerCollection\n     *\t\t\t\tWebAppContext (i.e. ContextHandler)\n     *\t\t\t\t\tSessionHandler\n     *\t\t\t\t\tSecurityHandler\n     *\t\t\t\t\tServletHandler\n     *\t\t\t\t\t\tservlets...\n     *\t\t\t\tWebAppContext\n     *\t\t\t\t...\n     *\t\t\tDefaultHandler\n     *\t\t\tRequestLogHandler (opt)\n     *<\/pre>\n     */\n    public void startConsole() {\n        File workDir = new SecureDirectory(_context.getTempDir(), \"jetty-work\");\n        boolean workDirRemoved = FileUtil.rmdir(workDir, false);\n        if (!workDirRemoved)\n            System.err.println(\"ERROR: Unable to remove Jetty temporary work directory\");\n        boolean workDirCreated = workDir.mkdirs();\n        if (!workDirCreated)\n            System.err.println(\"ERROR: Unable to create Jetty temporary work directory\");\n\n        // so Jetty can find WebAppConfiguration\n        System.setProperty(\"jetty.class.path\", _context.getBaseDir() + \"/lib/routerconsole.jar\");\n        _server = new Server();\n        _server.setGracefulShutdown(1000);\n\n        try {\n            ThreadPool ctp = new CustomThreadPoolExecutor();\n            // Gone in Jetty 7\n            //ctp.prestartAllCoreThreads();\n            _server.setThreadPool(ctp);\n        } catch (Throwable t) {\n            // class not found...\n            System.out.println(\"INFO: Jetty concurrent ThreadPool unavailable, using QueuedThreadPool\");\n            QueuedThreadPool qtp = new QueuedThreadPool(MAX_THREADS);\n            qtp.setMinThreads(MIN_THREADS);\n            qtp.setMaxIdleTimeMs(MAX_IDLE_TIME);\n            _server.setThreadPool(qtp);\n        }\n\n        HandlerCollection hColl = new HandlerCollection();\n        ContextHandlerCollection chColl = new ContextHandlerCollection();\n        // gone in Jetty 7\n        //_server.addHandler(hColl);\n        _server.setHandler(hColl);\n        hColl.addHandler(chColl);\n        hColl.addHandler(new DefaultHandler());\n\n        String log = _context.getProperty(\"routerconsole.log\");\n        if (log != null) {\n            File logFile = new File(log);\n            if (!logFile.isAbsolute())\n                logFile = new File(_context.getLogDir(), \"logs/\" + log);\n            try {\n                RequestLogHandler rhl = new RequestLogHandler();\n                rhl.setRequestLog(new NCSARequestLog(logFile.getAbsolutePath()));\n                hColl.addHandler(rhl);\n            } catch (Exception ioe) {\n                System.err.println(\"ERROR: Unable to create Jetty log: \" + ioe);\n            }\n        }\n        boolean rewrite = false;\n        Properties props = webAppProperties();\n        if (props.isEmpty()) {\n            props.setProperty(PREFIX + ROUTERCONSOLE + ENABLED, \"true\");\n            rewrite = true;\n        }\n\n        // Get an absolute path with a trailing slash for the webapps dir\n        // We assume relative to the base install dir for backward compatibility\n        File app = new File(_webAppsDir);\n        if (!app.isAbsolute()) {\n            app = new File(_context.getBaseDir(), _webAppsDir);\n            try {\n                _webAppsDir = app.getCanonicalPath();\n            } catch (IOException ioe) {}\n        }\n        if (!_webAppsDir.endsWith(\"/\"))\n            _webAppsDir += '/';\n\n        HandlerWrapper rootWebApp = null;\n        ServletHandler rootServletHandler = null;\n        List<Connector> connectors = new ArrayList(4);\n        try {\n            int boundAddresses = 0;\n            Set addresses = Addresses.getAllAddresses();\n            boolean hasIPV4 = addresses.contains(\"0.0.0.0\");\n            boolean hasIPV6 = addresses.contains(\"0:0:0:0:0:0:0:0\");\n\n            // add standard listeners\n            int lport = 0;\n            if (_listenPort != null) {\n                try {\n                    lport = Integer.parseInt(_listenPort);\n                } catch (NumberFormatException nfe) {}\n                if (lport <= 0)\n                    System.err.println(\"Bad routerconsole port \" + _listenPort);\n            }\n            if (lport > 0) {\n                StringTokenizer tok = new StringTokenizer(_listenHost, \" ,\");\n                while (tok.hasMoreTokens()) {\n                    String host = tok.nextToken().trim();\n                    try {\n                        // Test before we add the connector, because Jetty 6 won't start if any of the\n                        // connectors are bad\n                        InetAddress test = InetAddress.getByName(host);\n                        if ((!hasIPV6) && (!(test instanceof Inet4Address)))\n                            throw new IOException(\"IPv6 addresses unsupported\");\n                        if ((!hasIPV4) && (test instanceof Inet4Address))\n                            throw new IOException(\"IPv4 addresses unsupported\");\n                        ServerSocket testSock = null;\n                        try {\n                            // On Windows, this was passing and Jetty was still failing,\n                            // possibly due to %scope_id ???\n                            // https://issues.apache.org/jira/browse/ZOOKEEPER-667\n                            //testSock = new ServerSocket(0, 0, test);\n                            // so do exactly what Jetty does in SelectChannelConnector.open()\n                            testSock = new ServerSocket();\n                            InetSocketAddress isa = new InetSocketAddress(host, 0);\n                            testSock.bind(isa);\n                        } finally {\n                            if (testSock != null) try { testSock.close(); } catch (IOException ioe) {}\n                        }\n                        //if (host.indexOf(\":\") >= 0) // IPV6 - requires patched Jetty 5\n                        //    _server.addListener('[' + host + \"]:\" + _listenPort);\n                        //else\n                        //    _server.addListener(host + ':' + _listenPort);\n                        AbstractConnector lsnr;\n                        if (SystemVersion.isJava6() && !SystemVersion.isGNU()) {\n                            SelectChannelConnector slsnr = new SelectChannelConnector();\n                            slsnr.setUseDirectBuffers(false);  // default true seems to be leaky\n                            lsnr = slsnr;\n                        } else {\n                            // Jetty 6 and NIO on Java 5 don't get along that well\n                            // Also: http://jira.codehaus.org/browse/JETTY-1238\n                            // \"Do not use GCJ with Jetty, it will not work.\"\n                            // Actually it does if you don't use NIO\n                            lsnr = new SocketConnector();\n                        }\n                        lsnr.setHost(host);\n                        lsnr.setPort(lport);\n                        lsnr.setMaxIdleTime(90*1000);  // default 10 sec\n                        lsnr.setName(\"ConsoleSocket\");   // all with same name will use the same thread pool\n                        //_server.addConnector(lsnr);\n                        connectors.add(lsnr);\n                        boundAddresses++;\n                    } catch (Exception ioe) {\n                        System.err.println(\"Unable to bind routerconsole to \" + host + \" port \" + _listenPort + \": \" + ioe);\n                        System.err.println(\"You may ignore this warning if the console is still available at http://localhost:\" + _listenPort);\n                    }\n                }\n                // XXX: what if listenhosts do not include 127.0.0.1? (Should that ever even happen?)\n                _context.portMapper().register(PortMapper.SVC_CONSOLE,lport);\n            }\n\n            // add SSL listeners\n            int sslPort = 0;\n            if (_sslListenPort != null) {\n                try {\n                    sslPort = Integer.parseInt(_sslListenPort);\n                } catch (NumberFormatException nfe) {}\n                if (sslPort <= 0)\n                    System.err.println(\"Bad routerconsole SSL port \" + _sslListenPort);\n            }\n            if (sslPort > 0) {\n                File keyStore = new File(_context.getConfigDir(), \"keystore/console.ks\");\n                if (verifyKeyStore(keyStore)) {\n                    // the keystore path and password\n                    SslContextFactory sslFactory = new SslContextFactory(keyStore.getAbsolutePath());\n                    sslFactory.setKeyStorePassword(_context.getProperty(PROP_KEYSTORE_PASSWORD, DEFAULT_KEYSTORE_PASSWORD));\n                    // the X.509 cert password (if not present, verifyKeyStore() returned false)\n                    sslFactory.setKeyManagerPassword(_context.getProperty(PROP_KEY_PASSWORD, \"thisWontWork\"));\n                    StringTokenizer tok = new StringTokenizer(_sslListenHost, \" ,\");\n                    while (tok.hasMoreTokens()) {\n                        String host = tok.nextToken().trim();\n                        // doing it this way means we don't have to escape an IPv6 host with []\n                        try {\n                            // Test before we add the connector, because Jetty 6 won't start if any of the\n                            // connectors are bad\n                            InetAddress test = InetAddress.getByName(host);\n                            if ((!hasIPV6) && (!(test instanceof Inet4Address)))\n                                throw new IOException(\"IPv6 addresses unsupported\");\n                            if ((!hasIPV4) && (test instanceof Inet4Address))\n                                throw new IOException(\"IPv4 addresses unsupported\");\n                            ServerSocket testSock = null;\n                            try {\n                                // see comments above\n                                //testSock = new ServerSocket(0, 0, test);\n                                testSock = new ServerSocket();\n                                InetSocketAddress isa = new InetSocketAddress(host, 0);\n                                testSock.bind(isa);\n                            } finally {\n                                if (testSock != null) try { testSock.close(); } catch (IOException ioe) {}\n                            }\n                            // TODO if class not found use SslChannelConnector\n                            AbstractConnector ssll;\n                            if (SystemVersion.isJava6() && !SystemVersion.isGNU()) {\n                                SslSelectChannelConnector sssll = new SslSelectChannelConnector(sslFactory);\n                                sssll.setUseDirectBuffers(false);  // default true seems to be leaky\n                                ssll = sssll;\n                            } else {\n                                // Jetty 6 and NIO on Java 5 don't get along that well\n                                SslSocketConnector sssll = new SslSocketConnector(sslFactory);\n                                ssll = sssll;\n                            }\n                            ssll.setHost(host);\n                            ssll.setPort(sslPort);\n                            ssll.setMaxIdleTime(90*1000);  // default 10 sec\n                            ssll.setName(\"ConsoleSocket\");   // all with same name will use the same thread pool\n                            //_server.addConnector(ssll);\n                            connectors.add(ssll);\n                            boundAddresses++;\n                        } catch (Exception e) {\n                            System.err.println(\"Unable to bind routerconsole to \" + host + \" port \" + sslPort + \" for SSL: \" + e);\n                            if (SystemVersion.isGNU())\n                                System.err.println(\"Probably because GNU classpath does not support Sun keystores\");\n                            System.err.println(\"You may ignore this warning if the console is still available at https://localhost:\" + sslPort);\n                        }\n                    }\n                    _context.portMapper().register(PortMapper.SVC_HTTPS_CONSOLE,sslPort);\n                } else {\n                    System.err.println(\"Unable to create or access keystore for SSL: \" + keyStore.getAbsolutePath());\n                }\n            }\n\n            if (boundAddresses <= 0) {\n                System.err.println(\"Unable to bind routerconsole to any address on port \" + _listenPort + (sslPort > 0 ? (\" or SSL port \" + sslPort) : \"\"));\n                return;\n            }\n\n            File tmpdir = new SecureDirectory(workDir, ROUTERCONSOLE + \"-\" +\n                                                       (_listenPort != null ? _listenPort : _sslListenPort));\n            tmpdir.mkdir();\n            rootServletHandler = new ServletHandler();\n            rootWebApp = new LocaleWebAppHandler(_context,\n                                                  \"/\", _webAppsDir + ROUTERCONSOLE + \".war\",\n                                                 tmpdir, rootServletHandler);\n            initialize(_context, (WebAppContext)(rootWebApp.getHandler()));\n            chColl.addHandler(rootWebApp);\n\n        } catch (Exception ioe) {\n            ioe.printStackTrace();\n        }\n\n        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=364936\n        // WARN:oejw.WebAppContext:Failed startup of context o.e.j.w.WebAppContext{/,jar:file:/.../webapps/routerconsole.war!/},/.../webapps/routerconsole.war\n        // java.lang.IllegalStateException: zip file closed\n        Resource.setDefaultUseCaches(false);\n        try {\n            // start does a mapContexts()\n            _server.start();\n        } catch (Throwable me) {\n            // NoClassFoundDefError from a webapp is a throwable, not an exception\n            System.err.println(\"Error starting the Router Console server: \" + me);\n            me.printStackTrace();\n        }\n\n        if (_server.isRunning()) {\n            // Add and start the connectors one-by-one\n            boolean error = false;\n            for (Connector conn : connectors) {\n                try {\n                    _server.addConnector(conn);\n                    // start after adding so it gets the right thread pool\n                    conn.start();\n                } catch (Throwable me) {\n                    try {\n                        _server.removeConnector(conn);\n                    } catch (Throwable t) {\n                        t.printStackTrace();\n                    }\n                    System.err.println(\"WARNING: Error starting \" + conn + \": \" + me);\n                    me.printStackTrace();\n                    error = true;\n                }\n            }\n            if (error) {\n                System.err.println(\"WARNING: Error starting one or more listeners of the Router Console server.\\n\" +\n                               \"If your console is still accessible at http://127.0.0.1:\" + _listenPort + \"/,\\n\" +\n                               \"this may be a problem only with binding to the IPV6 address ::1.\\n\" +\n                               \"If so, you may ignore this error, or remove the\\n\" +\n                               \"\\\"::1,\\\" in the \\\"clientApp.0.args\\\" line of the clients.config file.\");\n            }\n        }\n\n        // Start all the other webapps after the server is up,\n        // so things start faster.\n        // Jetty 6 starts the connector before the router console is ready\n        // This also prevents one webapp from breaking the whole thing\n        List<String> notStarted = new ArrayList();\n        if (_server.isRunning()) {\n            File dir = new File(_webAppsDir);\n            String fileNames[] = dir.list(WarFilenameFilter.instance());\n            if (fileNames != null) {\n                for (int i = 0; i < fileNames.length; i++) {\n                    String appName = fileNames[i].substring(0, fileNames[i].lastIndexOf(\".war\"));\n                    String enabled = props.getProperty(PREFIX + appName + ENABLED);\n                    if (! \"false\".equals(enabled)) {\n                        try {\n                            String path = new File(dir, fileNames[i]).getCanonicalPath();\n                            WebAppStarter.startWebApp(_context, chColl, appName, path);\n                            if (enabled == null) {\n                                // do this so configclients.jsp knows about all apps from reading the config\n                                props.setProperty(PREFIX + appName + ENABLED, \"true\");\n                                rewrite = true;\n                            }\n                        } catch (Throwable t) {\n                            System.err.println(\"ERROR: Failed to start \" + appName + ' ' + t);\n                            t.printStackTrace();\n                            notStarted.add(appName);\n                        }\n                    } else {\n                        notStarted.add(appName);\n                    }\n                }\n                changeState(RUNNING);\n                if (_mgr != null)\n                    _mgr.register(this);\n            }\n        } else {\n            System.err.println(\"ERROR: Router console did not start, not starting webapps\");\n            changeState(START_FAILED);\n        }\n\n        if (rewrite)\n            storeWebAppProperties(_context, props);\n\n        if (rootServletHandler != null && notStarted.size() > 0) {\n            // map each not-started webapp to the error page\n            ServletHolder noWebApp = rootServletHandler.getServlet(\"net.i2p.router.web.jsp.nowebapp_jsp\");\n            for (int i = 0; i < notStarted.size(); i++) {\n                // we want a new handler for each one since if the webapp is started we remove the handler???\n                try {\n                    if (noWebApp != null) {\n                        String path = '/' + notStarted.get(i);\n                        // LocaleWebAppsHandler adds a .jsp\n                        rootServletHandler.addServletWithMapping(noWebApp, path + \".jsp\");\n                        rootServletHandler.addServletWithMapping(noWebApp, path + \"/*\");\n                    } else {\n                        System.err.println(\"Can't find nowebapp.jsp?\");\n                    }\n                } catch (Throwable me) {\n                     System.err.println(me);\n                     me.printStackTrace();\n                }\n            }\n        }\n\n        Thread t = new I2PAppThread(new StatSummarizer(), \"StatSummarizer\", true);\n        t.setPriority(Thread.NORM_PRIORITY - 1);\n        t.start();\n        \n            ConsoleUpdateManager um = new ConsoleUpdateManager(_context);\n            um.start();\n        \n            if (PluginStarter.pluginsEnabled(_context)) {\n                t = new I2PAppThread(new PluginStarter(_context), \"PluginStarter\", true);\n                t.setPriority(Thread.NORM_PRIORITY - 1);\n                t.start();\n                _context.addShutdownTask(new PluginStopper(_context));\n            }\n            // stat summarizer registers its own hook\n            _context.addShutdownTask(new ServerShutdown());\n            ConfigServiceHandler.registerSignalHandler(_context);\n    }","id":86062,"modified_method":"/**\n     *  http://irc.codehaus.org/display/JETTY/Porting+to+jetty6\n     *\n     *<pre>\n     *\tServer\n     *\t\tHandlerCollection\n     *\t\t\tContextHandlerCollection\n     *\t\t\t\tWebAppContext (i.e. ContextHandler)\n     *\t\t\t\t\tSessionHandler\n     *\t\t\t\t\tSecurityHandler\n     *\t\t\t\t\tServletHandler\n     *\t\t\t\t\t\tservlets...\n     *\t\t\t\tWebAppContext\n     *\t\t\t\t...\n     *\t\t\tDefaultHandler\n     *\t\t\tRequestLogHandler (opt)\n     *<\/pre>\n     */\n    public void startConsole() {\n        File workDir = new SecureDirectory(_context.getTempDir(), \"jetty-work\");\n        boolean workDirRemoved = FileUtil.rmdir(workDir, false);\n        if (!workDirRemoved)\n            System.err.println(\"ERROR: Unable to remove Jetty temporary work directory\");\n        boolean workDirCreated = workDir.mkdirs();\n        if (!workDirCreated)\n            System.err.println(\"ERROR: Unable to create Jetty temporary work directory\");\n\n        // so Jetty can find WebAppConfiguration\n        System.setProperty(\"jetty.class.path\", _context.getBaseDir() + \"/lib/routerconsole.jar\");\n        _server = new Server();\n        _server.setGracefulShutdown(1000);\n\n        try {\n            ThreadPool ctp = new CustomThreadPoolExecutor();\n            // Gone in Jetty 7\n            //ctp.prestartAllCoreThreads();\n            _server.setThreadPool(ctp);\n        } catch (Throwable t) {\n            // class not found...\n            System.out.println(\"INFO: Jetty concurrent ThreadPool unavailable, using QueuedThreadPool\");\n            QueuedThreadPool qtp = new QueuedThreadPool(MAX_THREADS);\n            qtp.setMinThreads(MIN_THREADS);\n            qtp.setMaxIdleTimeMs(MAX_IDLE_TIME);\n            _server.setThreadPool(qtp);\n        }\n\n        HandlerCollection hColl = new HandlerCollection();\n        ContextHandlerCollection chColl = new ContextHandlerCollection();\n        // gone in Jetty 7\n        //_server.addHandler(hColl);\n        _server.setHandler(hColl);\n        hColl.addHandler(chColl);\n        hColl.addHandler(new DefaultHandler());\n\n        String log = _context.getProperty(\"routerconsole.log\");\n        if (log != null) {\n            File logFile = new File(log);\n            if (!logFile.isAbsolute())\n                logFile = new File(_context.getLogDir(), \"logs/\" + log);\n            try {\n                RequestLogHandler rhl = new RequestLogHandler();\n                rhl.setRequestLog(new NCSARequestLog(logFile.getAbsolutePath()));\n                hColl.addHandler(rhl);\n            } catch (Exception ioe) {\n                System.err.println(\"ERROR: Unable to create Jetty log: \" + ioe);\n            }\n        }\n        boolean rewrite = false;\n        Properties props = webAppProperties();\n        if (props.isEmpty()) {\n            props.setProperty(PREFIX + ROUTERCONSOLE + ENABLED, \"true\");\n            rewrite = true;\n        }\n\n        // Get an absolute path with a trailing slash for the webapps dir\n        // We assume relative to the base install dir for backward compatibility\n        File app = new File(_webAppsDir);\n        if (!app.isAbsolute()) {\n            app = new File(_context.getBaseDir(), _webAppsDir);\n            try {\n                _webAppsDir = app.getCanonicalPath();\n            } catch (IOException ioe) {}\n        }\n        if (!_webAppsDir.endsWith(\"/\"))\n            _webAppsDir += '/';\n\n        HandlerWrapper rootWebApp = null;\n        ServletHandler rootServletHandler = null;\n        List<Connector> connectors = new ArrayList(4);\n        try {\n            int boundAddresses = 0;\n            Set addresses = Addresses.getAllAddresses();\n            boolean hasIPV4 = addresses.contains(\"0.0.0.0\");\n            boolean hasIPV6 = addresses.contains(\"0:0:0:0:0:0:0:0\");\n\n            // add standard listeners\n            int lport = 0;\n            if (_listenPort != null) {\n                try {\n                    lport = Integer.parseInt(_listenPort);\n                } catch (NumberFormatException nfe) {}\n                if (lport <= 0)\n                    System.err.println(\"Bad routerconsole port \" + _listenPort);\n            }\n            if (lport > 0) {\n                StringTokenizer tok = new StringTokenizer(_listenHost, \" ,\");\n                while (tok.hasMoreTokens()) {\n                    String host = tok.nextToken().trim();\n                    try {\n                        // Test before we add the connector, because Jetty 6 won't start if any of the\n                        // connectors are bad\n                        InetAddress test = InetAddress.getByName(host);\n                        if ((!hasIPV6) && (!(test instanceof Inet4Address)))\n                            throw new IOException(\"IPv6 addresses unsupported\");\n                        if ((!hasIPV4) && (test instanceof Inet4Address))\n                            throw new IOException(\"IPv4 addresses unsupported\");\n                        ServerSocket testSock = null;\n                        try {\n                            // On Windows, this was passing and Jetty was still failing,\n                            // possibly due to %scope_id ???\n                            // https://issues.apache.org/jira/browse/ZOOKEEPER-667\n                            //testSock = new ServerSocket(0, 0, test);\n                            // so do exactly what Jetty does in SelectChannelConnector.open()\n                            testSock = new ServerSocket();\n                            InetSocketAddress isa = new InetSocketAddress(host, 0);\n                            testSock.bind(isa);\n                        } finally {\n                            if (testSock != null) try { testSock.close(); } catch (IOException ioe) {}\n                        }\n                        //if (host.indexOf(\":\") >= 0) // IPV6 - requires patched Jetty 5\n                        //    _server.addListener('[' + host + \"]:\" + _listenPort);\n                        //else\n                        //    _server.addListener(host + ':' + _listenPort);\n                        AbstractConnector lsnr;\n                        if (SystemVersion.isJava6() && !SystemVersion.isGNU()) {\n                            SelectChannelConnector slsnr = new SelectChannelConnector();\n                            slsnr.setUseDirectBuffers(false);  // default true seems to be leaky\n                            lsnr = slsnr;\n                        } else {\n                            // Jetty 6 and NIO on Java 5 don't get along that well\n                            // Also: http://jira.codehaus.org/browse/JETTY-1238\n                            // \"Do not use GCJ with Jetty, it will not work.\"\n                            // Actually it does if you don't use NIO\n                            lsnr = new SocketConnector();\n                        }\n                        lsnr.setHost(host);\n                        lsnr.setPort(lport);\n                        lsnr.setMaxIdleTime(90*1000);  // default 10 sec\n                        lsnr.setName(\"ConsoleSocket\");   // all with same name will use the same thread pool\n                        //_server.addConnector(lsnr);\n                        connectors.add(lsnr);\n                        boundAddresses++;\n                    } catch (Exception ioe) {\n                        System.err.println(\"Unable to bind routerconsole to \" + host + \" port \" + _listenPort + \": \" + ioe);\n                        System.err.println(\"You may ignore this warning if the console is still available at http://localhost:\" + _listenPort);\n                    }\n                }\n                // XXX: what if listenhosts do not include 127.0.0.1? (Should that ever even happen?)\n                _context.portMapper().register(PortMapper.SVC_CONSOLE,lport);\n            }\n\n            // add SSL listeners\n            int sslPort = 0;\n            if (_sslListenPort != null) {\n                try {\n                    sslPort = Integer.parseInt(_sslListenPort);\n                } catch (NumberFormatException nfe) {}\n                if (sslPort <= 0)\n                    System.err.println(\"Bad routerconsole SSL port \" + _sslListenPort);\n            }\n            if (sslPort > 0) {\n                File keyStore = new File(_context.getConfigDir(), \"keystore/console.ks\");\n                if (verifyKeyStore(keyStore)) {\n                    // the keystore path and password\n                    SslContextFactory sslFactory = new SslContextFactory(keyStore.getAbsolutePath());\n                    sslFactory.setKeyStorePassword(_context.getProperty(PROP_KEYSTORE_PASSWORD, DEFAULT_KEYSTORE_PASSWORD));\n                    // the X.509 cert password (if not present, verifyKeyStore() returned false)\n                    sslFactory.setKeyManagerPassword(_context.getProperty(PROP_KEY_PASSWORD, \"thisWontWork\"));\n                    StringTokenizer tok = new StringTokenizer(_sslListenHost, \" ,\");\n                    while (tok.hasMoreTokens()) {\n                        String host = tok.nextToken().trim();\n                        // doing it this way means we don't have to escape an IPv6 host with []\n                        try {\n                            // Test before we add the connector, because Jetty 6 won't start if any of the\n                            // connectors are bad\n                            InetAddress test = InetAddress.getByName(host);\n                            if ((!hasIPV6) && (!(test instanceof Inet4Address)))\n                                throw new IOException(\"IPv6 addresses unsupported\");\n                            if ((!hasIPV4) && (test instanceof Inet4Address))\n                                throw new IOException(\"IPv4 addresses unsupported\");\n                            ServerSocket testSock = null;\n                            try {\n                                // see comments above\n                                //testSock = new ServerSocket(0, 0, test);\n                                testSock = new ServerSocket();\n                                InetSocketAddress isa = new InetSocketAddress(host, 0);\n                                testSock.bind(isa);\n                            } finally {\n                                if (testSock != null) try { testSock.close(); } catch (IOException ioe) {}\n                            }\n                            // TODO if class not found use SslChannelConnector\n                            AbstractConnector ssll;\n                            if (SystemVersion.isJava6() && !SystemVersion.isGNU()) {\n                                SslSelectChannelConnector sssll = new SslSelectChannelConnector(sslFactory);\n                                sssll.setUseDirectBuffers(false);  // default true seems to be leaky\n                                ssll = sssll;\n                            } else {\n                                // Jetty 6 and NIO on Java 5 don't get along that well\n                                SslSocketConnector sssll = new SslSocketConnector(sslFactory);\n                                ssll = sssll;\n                            }\n                            ssll.setHost(host);\n                            ssll.setPort(sslPort);\n                            ssll.setMaxIdleTime(90*1000);  // default 10 sec\n                            ssll.setName(\"ConsoleSocket\");   // all with same name will use the same thread pool\n                            //_server.addConnector(ssll);\n                            connectors.add(ssll);\n                            boundAddresses++;\n                        } catch (Exception e) {\n                            System.err.println(\"Unable to bind routerconsole to \" + host + \" port \" + sslPort + \" for SSL: \" + e);\n                            if (SystemVersion.isGNU())\n                                System.err.println(\"Probably because GNU classpath does not support Sun keystores\");\n                            System.err.println(\"You may ignore this warning if the console is still available at https://localhost:\" + sslPort);\n                        }\n                    }\n                    _context.portMapper().register(PortMapper.SVC_HTTPS_CONSOLE,sslPort);\n                } else {\n                    System.err.println(\"Unable to create or access keystore for SSL: \" + keyStore.getAbsolutePath());\n                }\n            }\n\n            if (boundAddresses <= 0) {\n                System.err.println(\"Unable to bind routerconsole to any address on port \" + _listenPort + (sslPort > 0 ? (\" or SSL port \" + sslPort) : \"\"));\n                return;\n            }\n\n            File tmpdir = new SecureDirectory(workDir, ROUTERCONSOLE + \"-\" +\n                                                       (_listenPort != null ? _listenPort : _sslListenPort));\n            tmpdir.mkdir();\n            rootServletHandler = new ServletHandler();\n            rootWebApp = new LocaleWebAppHandler(_context,\n                                                  \"/\", _webAppsDir + ROUTERCONSOLE + \".war\",\n                                                 tmpdir, rootServletHandler);\n            initialize(_context, (WebAppContext)(rootWebApp.getHandler()));\n            chColl.addHandler(rootWebApp);\n\n        } catch (Exception ioe) {\n            ioe.printStackTrace();\n        }\n\n        // https://bugs.eclipse.org/bugs/show_bug.cgi?id=364936\n        // WARN:oejw.WebAppContext:Failed startup of context o.e.j.w.WebAppContext{/,jar:file:/.../webapps/routerconsole.war!/},/.../webapps/routerconsole.war\n        // java.lang.IllegalStateException: zip file closed\n        Resource.setDefaultUseCaches(false);\n        try {\n            // start does a mapContexts()\n            _server.start();\n        } catch (Throwable me) {\n            // NoClassFoundDefError from a webapp is a throwable, not an exception\n            System.err.println(\"Error starting the Router Console server: \" + me);\n            me.printStackTrace();\n        }\n\n        if (_server.isRunning()) {\n            // Add and start the connectors one-by-one\n            boolean error = false;\n            for (Connector conn : connectors) {\n                try {\n                    _server.addConnector(conn);\n                    // start after adding so it gets the right thread pool\n                    conn.start();\n                } catch (Throwable me) {\n                    try {\n                        _server.removeConnector(conn);\n                    } catch (Throwable t) {\n                        t.printStackTrace();\n                    }\n                    System.err.println(\"WARNING: Error starting \" + conn + \": \" + me);\n                    me.printStackTrace();\n                    error = true;\n                }\n            }\n            if (error) {\n                System.err.println(\"WARNING: Error starting one or more listeners of the Router Console server.\\n\" +\n                               \"If your console is still accessible at http://127.0.0.1:\" + _listenPort + \"/,\\n\" +\n                               \"this may be a problem only with binding to the IPV6 address ::1.\\n\" +\n                               \"If so, you may ignore this error, or remove the\\n\" +\n                               \"\\\"::1,\\\" in the \\\"clientApp.0.args\\\" line of the clients.config file.\");\n            }\n        }\n\n        // Start all the other webapps after the server is up,\n        // so things start faster.\n        // Jetty 6 starts the connector before the router console is ready\n        // This also prevents one webapp from breaking the whole thing\n        List<String> notStarted = new ArrayList();\n        if (_server.isRunning()) {\n            File dir = new File(_webAppsDir);\n            String fileNames[] = dir.list(WarFilenameFilter.instance());\n            if (fileNames != null) {\n                for (int i = 0; i < fileNames.length; i++) {\n                    String appName = fileNames[i].substring(0, fileNames[i].lastIndexOf(\".war\"));\n                    String enabled = props.getProperty(PREFIX + appName + ENABLED);\n                    if (! \"false\".equals(enabled)) {\n                        try {\n                            String path = new File(dir, fileNames[i]).getCanonicalPath();\n                            WebAppStarter.startWebApp(_context, chColl, appName, path);\n                            if (enabled == null) {\n                                // do this so configclients.jsp knows about all apps from reading the config\n                                props.setProperty(PREFIX + appName + ENABLED, \"true\");\n                                rewrite = true;\n                            }\n                        } catch (Throwable t) {\n                            System.err.println(\"ERROR: Failed to start \" + appName + ' ' + t);\n                            t.printStackTrace();\n                            notStarted.add(appName);\n                        }\n                    } else {\n                        notStarted.add(appName);\n                    }\n                }\n                changeState(RUNNING);\n                if (_mgr != null)\n                    _mgr.register(this);\n            }\n        } else {\n            System.err.println(\"ERROR: Router console did not start, not starting webapps\");\n            changeState(START_FAILED);\n        }\n\n        if (rewrite)\n            storeWebAppProperties(_context, props);\n\n        if (rootServletHandler != null && notStarted.size() > 0) {\n            // map each not-started webapp to the error page\n            ServletHolder noWebApp = rootServletHandler.getServlet(\"net.i2p.router.web.jsp.nowebapp_jsp\");\n            for (int i = 0; i < notStarted.size(); i++) {\n                // we want a new handler for each one since if the webapp is started we remove the handler???\n                try {\n                    if (noWebApp != null) {\n                        String path = '/' + notStarted.get(i);\n                        // LocaleWebAppsHandler adds a .jsp\n                        rootServletHandler.addServletWithMapping(noWebApp, path + \".jsp\");\n                        rootServletHandler.addServletWithMapping(noWebApp, path + \"/*\");\n                    } else {\n                        System.err.println(\"Can't find nowebapp.jsp?\");\n                    }\n                } catch (Throwable me) {\n                     System.err.println(me);\n                     me.printStackTrace();\n                }\n            }\n        }\n\n        Thread t = new I2PAppThread(new StatSummarizer(), \"StatSummarizer\", true);\n        t.setPriority(Thread.NORM_PRIORITY - 1);\n        t.start();\n        \n            ConsoleUpdateManager um = new ConsoleUpdateManager(_context);\n            um.start();\n        \n            if (PluginStarter.pluginsEnabled(_context)) {\n                t = new I2PAppThread(new PluginStarter(_context), \"PluginStarter\", true);\n                t.setPriority(Thread.NORM_PRIORITY - 1);\n                t.start();\n            }\n            // stat summarizer registers its own hook\n            // RouterAppManager registers its own hook\n            if (_mgr == null)\n                _context.addShutdownTask(new ServerShutdown());\n            ConfigServiceHandler.registerSignalHandler(_context);\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** @since 0.9.4 */\n    public void shutdown(String[] args) {\n        changeState(STOPPING);\n        try {\n            _server.stop();\n        } catch (Exception ie) {}\n        PortMapper portMapper = _context.portMapper();\n        portMapper.unregister(PortMapper.SVC_CONSOLE);\n        portMapper.unregister(PortMapper.SVC_HTTPS_CONSOLE);\n        changeState(STOPPED);\n    }","id":86063,"modified_method":"/** @since 0.9.4 */\n    public synchronized void shutdown(String[] args) {\n        if (_state == STOPPED)\n            return;\n        changeState(STOPPING);\n        if (PluginStarter.pluginsEnabled(_context))\n            (new I2PAppThread(new PluginStopper(_context), \"PluginStopper\")).start();\n        try {\n            _server.stop();\n        } catch (Exception ie) {}\n        PortMapper portMapper = _context.portMapper();\n        portMapper.unregister(PortMapper.SVC_CONSOLE);\n        portMapper.unregister(PortMapper.SVC_HTTPS_CONSOLE);\n        changeState(STOPPED);\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  ClientApp interface\n     *  @throws IllegalArgumentException if unable to load config from file\n     *  @since 0.9.4\n     */\n    public void startup() {\n        loadControllers(_configFile);\n        if (_mgr != null)\n            _mgr.register(this);\n        _context.addShutdownTask(new Shutdown());\n    }","id":86064,"modified_method":"/**\n     *  ClientApp interface\n     *  @throws IllegalArgumentException if unable to load config from file\n     *  @since 0.9.4\n     */\n    public void startup() {\n        loadControllers(_configFile);\n        if (_mgr != null)\n            _mgr.register(this);\n            // RouterAppManager registers its own shutdown hook\n        else\n            _context.addShutdownTask(new Shutdown());\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     *  Warning - destroys the singleton!\n     *  Caller must root a new context before calling instance() or main() again.\n     *  Agressively kill and null everything to reduce memory usage in the JVM\n     *  after stopping, and to recognize what must be reinitialized on restart (Android)\n     *\n     *  @since 0.8.8\n     */\n    public void shutdown() {\n        changeState(STOPPING);\n        if (_mgr != null)\n            _mgr.unregister(this);\n        unloadControllers();\n        synchronized (TunnelControllerGroup.class) {\n            if (_instance == this)\n                _instance = null;\n        }\n/// fixme static\n        I2PTunnelClientBase.killClientExecutor();\n        changeState(STOPPED);\n    }","id":86065,"modified_method":"/**\n     *  Warning - destroys the singleton!\n     *  Caller must root a new context before calling instance() or main() again.\n     *  Agressively kill and null everything to reduce memory usage in the JVM\n     *  after stopping, and to recognize what must be reinitialized on restart (Android)\n     *\n     *  @since 0.8.8\n     */\n    public synchronized void shutdown() {\n        if (_state != STARTING && _state != RUNNING)\n            return;\n        changeState(STOPPING);\n        if (_mgr != null)\n            _mgr.unregister(this);\n        unloadControllers();\n        synchronized (TunnelControllerGroup.class) {\n            if (_instance == this)\n                _instance = null;\n        }\n/// fixme static\n        I2PTunnelClientBase.killClientExecutor();\n        changeState(STOPPED);\n    }","commit_id":"813a1981d94439acfd9c32474c54afa04d65a674","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n\tpublic void onDestroy() {\n\t\tsuper.onDestroy();\n\t\t((OsmandApplication)getApplication()).setNavigationService(null);\n\t\t\n\t\t// remove updates\n\t\tLocationManager locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);\n\t\tlocationManager.removeUpdates(this);\n\t\t\n\t\tif (!isContinuous()) {\n\t\t\tWakeLock lock = getLock(this);\n\t\t\tif (lock.isHeld()) {\n\t\t\t\tlock.release();\n\t\t\t}\n\t\t}\n\t\t// remove alarm\n\t\tAlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\n\t\talarmManager.cancel(pendingIntent);\n\t\t// remove notification\n\t\tNotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\tmNotificationManager.cancel(NOTIFICATION_SERVICE_ID);\n\t\tif (broadcastReceiver != null) {\n\t\t\tunregisterReceiver(broadcastReceiver);\n\t\t\tbroadcastReceiver = null;\n\t\t}\n\t}","id":86066,"modified_method":"@Override\n\tpublic void onDestroy() {\n\t\tsuper.onDestroy();\n\t\t((OsmandApplication)getApplication()).setNavigationService(null);\n\t\t\n\t\t// remove updates\n\t\tLocationManager locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);\n\t\tlocationManager.removeUpdates(this);\n\t\t\n\t\tif (!isContinuous()) {\n\t\t\tWakeLock lock = getLock(this);\n\t\t\tif (lock.isHeld()) {\n\t\t\t\tlock.release();\n\t\t\t}\n\t\t}\n\t\t// remove alarm\n\t\tAlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\n\t\talarmManager.cancel(pendingIntent);\n\t\t// remove notification\n\t\tNotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\tmNotificationManager.cancel(NOTIFICATION_SERVICE_ID);\n\t\tif (broadcastReceiver != null) {\n\t\t\tunregisterReceiver(broadcastReceiver);\n\t\t\tbroadcastReceiver = null;\n\t\t}\n\n\t\tif (mStopForeground != null) {\n\t\t\tLog.d(PlatformUtil.TAG, \"invoke stopForeground\");\n\t\t\ttry {\n\t\t\t\tmStopForeground.invoke(this, Boolean.TRUE);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke stopForeground failed\");\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke stopForeground failed\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tLog.d(PlatformUtil.TAG, \"invoke setForeground\");\n\t\t\ttry {\n\t\t\t\tmSetForeground.invoke(this, Boolean.FALSE);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke setForeground failed\");\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke setForeground failed\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"9c89ae1edb41e04255781553c2c97dcd2e20b4e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n\t\thandler = new Handler();\n\t\tClientContext cl = ((OsmandApplication) getApplication());\n\t\tsettings = cl.getSettings();\n\t\t\n\t\tstartedForNavigation = intent.getBooleanExtra(NAVIGATION_START_SERVICE_PARAM, false);\n\t\tif (startedForNavigation) {\n\t\t\tserviceOffInterval = 0;\n\t\t} else {\n\t\t\tserviceOffInterval = settings.SERVICE_OFF_INTERVAL.get();\n\t\t}\n\t\t// use only gps provider\n\t\tserviceOffProvider = LocationManager.GPS_PROVIDER;\n\t\tserviceError = serviceOffInterval / 5;\n\t\t// 1. not more than 12 mins\n\t\tserviceError = Math.min(serviceError, 12 * 60 * 1000);\n\t\t// 2. not less than 30 seconds\n\t\tserviceError = Math.max(serviceError, 30 * 1000);\n\t\t// 3. not more than serviceOffInterval\n\t\tserviceError = Math.min(serviceError, serviceOffInterval);\n\t\t\n\t\t\n\t\tsavingTrackHelper = ((OsmandApplication) getApplication()).getSavingTrackHelper();\n\t\tliveMonitoringHelper = ((OsmandApplication) getApplication()).getLiveMonitoringHelper();\n\t\t\n\t\troutingHelper = ((OsmandApplication)getApplication()).getRoutingHelper();\n\t\t((OsmandApplication)getApplication()).setNavigationService(this);\n\t\t\n\t\t// requesting \n\t\tif(isContinuous()){\n\t\t\t// request location updates\n\t\t\tLocationManager locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);\n\t\t\ttry {\n\t\t\t\tlocationManager.requestLocationUpdates(serviceOffProvider, 0, 0, NavigationService.this);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tToast.makeText(this, R.string.gps_not_available, Toast.LENGTH_LONG).show();\n\t\t\t\tLog.d(PlatformUtil.TAG, \"GPS location provider not available\"); //$NON-NLS-1$\n\t\t\t}\n\t\t} else {\n\t\t\tAlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\n\t\t\tpendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(this, OnNavigationServiceAlarmReceiver.class), PendingIntent.FLAG_UPDATE_CURRENT);\n\t\t\talarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 500, serviceOffInterval, pendingIntent);\n\t\t}\n\t\t\t\n\t\t// registering icon at top level\n\t\t// Leave icon visible even for navigation for proper testing\n//\t\tif (!startedForNavigation) {\n\t\t\tbroadcastReceiver = new BroadcastReceiver() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tNavigationService.this.stopSelf();\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tregisterReceiver(broadcastReceiver, new IntentFilter(OSMAND_STOP_SERVICE_ACTION));\n\t\t\tIntent notificationIntent = new Intent(OSMAND_STOP_SERVICE_ACTION);\n\t\t\tNotification notification = new Notification(R.drawable.bgs_icon, \"\", //$NON-NLS-1$\n\t\t\t\t\tSystem.currentTimeMillis());\n\t\t\tnotification.flags = Notification.FLAG_NO_CLEAR;\n\t\t\tnotification.setLatestEventInfo(this, Version.getAppName(cl), getString(R.string.service_stop_background_service),\n\t\t\t\t\tPendingIntent.getBroadcast(this, 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT));\n\t\t\tNotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\t\tmNotificationManager.notify(NOTIFICATION_SERVICE_ID, notification);\n//\t\t}\n\t\treturn START_REDELIVER_INTENT;\n\t}","id":86067,"modified_method":"@Override\n\tpublic int onStartCommand(Intent intent, int flags, int startId) {\n\t\thandler = new Handler();\n\t\tClientContext cl = ((OsmandApplication) getApplication());\n\t\tsettings = cl.getSettings();\n\t\t\n\t\tstartedForNavigation = intent.getBooleanExtra(NAVIGATION_START_SERVICE_PARAM, false);\n\t\tif (startedForNavigation) {\n\t\t\tserviceOffInterval = 0;\n\t\t} else {\n\t\t\tserviceOffInterval = settings.SERVICE_OFF_INTERVAL.get();\n\t\t}\n\t\t// use only gps provider\n\t\tserviceOffProvider = LocationManager.GPS_PROVIDER;\n\t\tserviceError = serviceOffInterval / 5;\n\t\t// 1. not more than 12 mins\n\t\tserviceError = Math.min(serviceError, 12 * 60 * 1000);\n\t\t// 2. not less than 30 seconds\n\t\tserviceError = Math.max(serviceError, 30 * 1000);\n\t\t// 3. not more than serviceOffInterval\n\t\tserviceError = Math.min(serviceError, serviceOffInterval);\n\t\t\n\t\t\n\t\tsavingTrackHelper = ((OsmandApplication) getApplication()).getSavingTrackHelper();\n\t\tliveMonitoringHelper = ((OsmandApplication) getApplication()).getLiveMonitoringHelper();\n\t\t\n\t\troutingHelper = ((OsmandApplication)getApplication()).getRoutingHelper();\n\t\t((OsmandApplication)getApplication()).setNavigationService(this);\n\t\t\n\t\t// requesting \n\t\tif(isContinuous()){\n\t\t\t// request location updates\n\t\t\tLocationManager locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);\n\t\t\ttry {\n\t\t\t\tlocationManager.requestLocationUpdates(serviceOffProvider, 0, 0, NavigationService.this);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tToast.makeText(this, R.string.gps_not_available, Toast.LENGTH_LONG).show();\n\t\t\t\tLog.d(PlatformUtil.TAG, \"GPS location provider not available\"); //$NON-NLS-1$\n\t\t\t}\n\t\t} else {\n\t\t\tAlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE);\n\t\t\tpendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(this, OnNavigationServiceAlarmReceiver.class), PendingIntent.FLAG_UPDATE_CURRENT);\n\t\t\talarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 500, serviceOffInterval, pendingIntent);\n\t\t}\n\t\t\t\n\t\t// registering icon at top level\n\t\t// Leave icon visible even for navigation for proper testing\n//\t\tif (!startedForNavigation) {\n\t\t\tbroadcastReceiver = new BroadcastReceiver() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\t\tNavigationService.this.stopSelf();\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tregisterReceiver(broadcastReceiver, new IntentFilter(OSMAND_STOP_SERVICE_ACTION));\n\t\t\tIntent notificationIntent = new Intent(OSMAND_STOP_SERVICE_ACTION);\n\t\t\tNotification notification = new Notification(R.drawable.bgs_icon, \"\", //$NON-NLS-1$\n\t\t\t\t\tSystem.currentTimeMillis());\n\t\t\tnotification.flags = Notification.FLAG_NO_CLEAR;\n\t\t\tnotification.setLatestEventInfo(this, Version.getAppName(cl), getString(R.string.service_stop_background_service),\n\t\t\t\t\tPendingIntent.getBroadcast(this, 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT));\n\t\t\tNotificationManager mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\t\tif (mStartForeground != null) {\n\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke startForeground\");\n\t\t\t\ttry {\n\t\t\t\t\tmStartForeground.invoke(this, NOTIFICATION_SERVICE_ID, notification);\n\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke startForeground failed\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke startForeground failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke setForeground\");\n\t\t\t\tmNotificationManager.notify(NOTIFICATION_SERVICE_ID, notification);\n\t\t\t\ttry {\n\t\t\t\t\tmSetForeground.invoke(this, Boolean.TRUE);\n\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke setForeground failed\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tLog.d(PlatformUtil.TAG, \"invoke setForeground failed\");\n\t\t\t\t}\n\t\t\t}\n//\t\t}\n\t\treturn START_REDELIVER_INTENT;\n\t}","commit_id":"9c89ae1edb41e04255781553c2c97dcd2e20b4e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\t// initializing variables\n\t\tsetForeground(true);\n\t}","id":86068,"modified_method":"@Override\n\tpublic void onCreate() {\n\t\tsuper.onCreate();\n\t\t// initializing variables\n\t\tcheckForegroundAPI();\n\t}","commit_id":"9c89ae1edb41e04255781553c2c97dcd2e20b4e1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void register() {\n    myGrowl.setAllowedNotifications(getAllNotifications());\n    try {\n      myGrowl.setDefaultNotifications(getAllNotifications());\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n    myGrowl.register();\n  }","id":86069,"modified_method":"private void register() {\n    myGrowl.setAllowedNotifications(ArrayUtil.toStringArray(myNotifications));\n    myGrowl.setDefaultNotifications(ArrayUtil.toStringArray(myNotifications));\n    myGrowl.register();\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void notify(Set<String> allNotifications, @NotNull String notificationName, String title, String description) {\n    if (!myNotifications.equals(allNotifications)) {\n      myNotifications.addAll(allNotifications);\n      register();\n    }\n\n    try {\n      myGrowl.notifyGrowlOf(notificationName, title, description);\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","id":86070,"modified_method":"@Override\n  public void notify(@NotNull Set<String> allNames, @NotNull String name, @NotNull String title, @NotNull String description) {\n    try {\n      if (!myNotifications.equals(allNames)) {\n        myNotifications.addAll(allNames);\n        register();\n      }\n\n      myGrowl.notifyGrowlOf(name, title, description);\n    }\n    catch (Exception e) {\n      LOG.warn(e);\n    }\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrowlNotifications() {\n    this(ApplicationNamesInfo.getInstance().getFullProductName());\n  }","id":86071,"modified_method":"private GrowlNotifications() {\n    myGrowl = new Growl(ApplicationNamesInfo.getInstance().getFullProductName());\n    myNotifications = new TreeSet<String>();\n    register();\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void notify(Set<String> allNotifications, @NotNull String notificationName, String title, String description) {\n    final ID notification = invoke(Foundation.getObjcClass(\"NSUserNotification\"), \"new\");\n    invoke(notification, \"setTitle:\", nsString(StringUtil.stripHtml(title == null ? \"\" : title, true).replace(\"%\", \"%%\")));\n    invoke(notification, \"setInformativeText:\", nsString(StringUtil.stripHtml(description == null ? \"\" : description, true).replace(\"%\", \"%%\")));\n    final ID center = invoke(Foundation.getObjcClass(\"NSUserNotificationCenter\"), \"defaultUserNotificationCenter\");\n    invoke(center, \"deliverNotification:\", notification);\n  }","id":86072,"modified_method":"@Override\n  public void notify(@NotNull Set<String> allNames, @NotNull String name, @NotNull String title, @NotNull String description) {\n    final ID notification = invoke(Foundation.getObjcClass(\"NSUserNotification\"), \"new\");\n    invoke(notification, \"setTitle:\", nsString(StringUtil.stripHtml(title, true).replace(\"%\", \"%%\")));\n    invoke(notification, \"setInformativeText:\", nsString(StringUtil.stripHtml(description, true).replace(\"%\", \"%%\")));\n    final ID center = invoke(Foundation.getObjcClass(\"NSUserNotificationCenter\"), \"defaultUserNotificationCenter\");\n    invoke(center, \"deliverNotification:\", notification);\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MountainLionNotifications() {\n    final MessageBusConnection connection = ApplicationManager.getApplication().getMessageBus().connect();\n    connection.subscribe(ApplicationActivationListener.TOPIC, new ApplicationActivationListener() {\n      @Override\n      public void applicationActivated(IdeFrame ideFrame) {\n        cleanupDeliveredNotifications();\n      }\n\n      @Override\n      public void applicationDeactivated(IdeFrame ideFrame) {}\n    });\n    connection.subscribe(AppLifecycleListener.TOPIC, new AppLifecycleListener.Adapter() {\n      @Override\n      public void appClosing() {\n        cleanupDeliveredNotifications();\n      }\n    });\n  }","id":86073,"modified_method":"private MountainLionNotifications() {\n    final MessageBusConnection connection = ApplicationManager.getApplication().getMessageBus().connect();\n    connection.subscribe(ApplicationActivationListener.TOPIC, new ApplicationActivationListener.Adapter() {\n      @Override\n      public void applicationActivated(IdeFrame ideFrame) {\n        cleanupDeliveredNotifications();\n      }\n    });\n    connection.subscribe(AppLifecycleListener.TOPIC, new AppLifecycleListener.Adapter() {\n      @Override\n      public void appClosing() {\n        cleanupDeliveredNotifications();\n      }\n    });\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void cleanupDeliveredNotifications() {\n    final ID center = invoke(Foundation.getObjcClass(\"NSUserNotificationCenter\"), \"defaultUserNotificationCenter\");\n    invoke(center, \"removeAllDeliveredNotifications\");\n  }","id":86074,"modified_method":"private static void cleanupDeliveredNotifications() {\n    final ID center = invoke(Foundation.getObjcClass(\"NSUserNotificationCenter\"), \"defaultUserNotificationCenter\");\n    invoke(center, \"removeAllDeliveredNotifications\");\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void notify(@NotNull String notificationName, @NotNull String title, @NotNull String text) {\n    if (!areNotificationsEnabled() || ApplicationManager.getApplication().isActive()) return;\n\n    if (SystemInfo.isLinux && Registry.is(\"ide.linux.gtk.notifications.enabled\") ) {\n      LibNotifyWrapper.showWithAppIcon(title, text);\n      return;\n    }\n\n    final MacNotifications notifications;\n    try {\n      notifications = getMacNotifications();\n    }\n    catch (Throwable e) {\n      myGrowlDisabled = true;\n      return;\n    }\n\n    myState.NOTIFICATIONS.add(notificationName);\n    notifications.notify(myState.NOTIFICATIONS, notificationName, title, text);\n  }","id":86075,"modified_method":"@Override\n  public void notify(@NotNull String notificationName, @NotNull String title, @NotNull String text) {\n    if (myNotifier != null && !ApplicationManager.getApplication().isActive()) {\n      myState.NOTIFICATIONS.add(notificationName);\n      myNotifier.notify(myState.NOTIFICATIONS, notificationName, title, text);\n    }\n  }","commit_id":"4d26c0a72dc1d73169af20a0f0e9fc7e3a09e2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isInStock(\n\t\tShoppingItem item, ShoppingItemField[] itemFields,\n\t\tString[] fieldsArray, Integer orderedQuantity) {\n\n\t\tif (!item.isFields()) {\n\t\t\tint stockQuantity = item.getStockQuantity();\n\n\t\t\tif ((stockQuantity > 0) &&\n\t\t\t\t(stockQuantity >= orderedQuantity.intValue())) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint rowPos = getFieldsQuantitiesPos(item, itemFields, fieldsArray);\n\n\t\t\tString[] fieldsQuantities = item.getFieldsQuantitiesArray();\n\n\t\t\tint stockQuantity = GetterUtil.getInteger(fieldsQuantities[rowPos]);\n\n\t\t\ttry {\n\t\t\t\tif ((stockQuantity > 0) &&\n\t\t\t\t\t(stockQuantity >= orderedQuantity.intValue())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","id":86076,"modified_method":"public static boolean isInStock(\n\t\tShoppingItem item, ShoppingItemField[] itemFields,\n\t\tString[] fieldsArray, Integer orderedQuantity) {\n\n\t\tif (!item.isFields()) {\n\t\t\tint stockQuantity = item.getStockQuantity();\n\n\t\t\tif ((stockQuantity > 0) &&\n\t\t\t\t(stockQuantity >= orderedQuantity.intValue())) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint rowPos = getFieldsQuantitiesPos(item, itemFields, fieldsArray);\n\n\t\t\tString[] fieldsQuantities = item.getFieldsQuantitiesArray();\n\n\t\t\tint stockQuantity = 0; \n\n\t\t\tif (fieldsQuantities.length > 0) {\n\t\t\t\tstockQuantity = GetterUtil.getInteger(fieldsQuantities[rowPos]);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif ((stockQuantity > 0) &&\n\t\t\t\t\t(stockQuantity >= orderedQuantity.intValue())) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"8d4853cd09cb4e941f3756ff71548b01f4b59ced","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getLayoutsJSON(\n\t\t\tHttpServletRequest request, long groupId, boolean privateLayout,\n\t\t\tlong parentLayoutId, long[] expandedLayoutIds)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tint start = ParamUtil.getInteger(request, \"start\");\n\t\tint end = ParamUtil.getInteger(\n\t\t\trequest, \"end\",\n\t\t\tstart + PropsValues.LAYOUT_MANAGE_PAGES_INITIAL_CHILDREN);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tList<Layout> layoutAncestors = null;\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroupId, privateLayout, parentLayoutId);\n\n\t\tlong selPlid = ParamUtil.getLong(request, \"selPlid\");\n\n\t\tif (selPlid != 0) {\n\t\t\tLayout selLayout = LayoutLocalServiceUtil.getLayout(selPlid);\n\n\t\t\tlayoutAncestors = selLayout.getAncestors();\n\n\t\t\tlayoutAncestors.add(selLayout);\n\t\t}\n\n\t\tString treeId = _getScopedPaginationTreeId(request);\n\n\t\tString paginationJSON = SessionClicks.get(\n\t\t\tsession, treeId, StringPool.BLANK);\n\n\t\tif (Validator.isNotNull(paginationJSON) && (end >= 0)) {\n\t\t\tJSONObject paginationJSONObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\tpaginationJSON);\n\n\t\t\tString key = String.valueOf(parentLayoutId);\n\n\t\t\tif (paginationJSONObject.has(key)) {\n\t\t\t\tint paginationEnd = paginationJSONObject.getInt(key);\n\n\t\t\t\tif (paginationEnd > end) {\n\t\t\t\t\tend = paginationEnd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart = Math.max(0, Math.min(start, layouts.size()));\n\n\t\tend = Math.min(end, layouts.size());\n\n\t\tif (end < 0) {\n\t\t\tend = layouts.size();\n\t\t}\n\n\t\tfor (Layout layout : layouts.subList(start, end)) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tif ((layoutAncestors != null) && layoutAncestors.contains(layout) ||\n\t\t\t\tArrayUtil.contains(expandedLayoutIds, layout.getLayoutId())) {\n\n\t\t\t\tString childrenJSON = StringPool.BLANK;\n\n\t\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, virtualLayout.getSourceGroupId(),\n\t\t\t\t\t\tvirtualLayout.getPrivateLayout(),\n\t\t\t\t\t\tvirtualLayout.getLayoutId(), expandedLayoutIds);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, groupId, layout.getPrivateLayout(),\n\t\t\t\t\t\tlayout.getLayoutId(), expandedLayoutIds);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"children\", JSONFactoryUtil.createJSONObject(childrenJSON));\n\t\t\t}\n\n\t\t\tjsonObject.put(\"contentDisplayPage\", layout.isContentDisplayPage());\n\t\t\tjsonObject.put(\"friendlyURL\", layout.getFriendlyURL());\n\n\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\tjsonObject.put(\"groupId\", virtualLayout.getSourceGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjsonObject.put(\"groupId\", layout.getGroupId());\n\t\t\t}\n\n\t\t\tjsonObject.put(\"hasChildren\", layout.hasChildren());\n\t\t\tjsonObject.put(\"layoutId\", layout.getLayoutId());\n\t\t\tjsonObject.put(\"name\", layout.getName(themeDisplay.getLocale()));\n\t\t\tjsonObject.put(\"parentLayoutId\", layout.getParentLayoutId());\n\t\t\tjsonObject.put(\"plid\", layout.getPlid());\n\t\t\tjsonObject.put(\"priority\", layout.getPriority());\n\t\t\tjsonObject.put(\"privateLayout\", layout.isPrivateLayout());\n\t\t\tjsonObject.put(\"type\", layout.getType());\n\t\t\tjsonObject.put(\"updateable\", SitesUtil.isLayoutUpdateable(layout));\n\t\t\tjsonObject.put(\"uuid\", layout.getUuid());\n\n\t\t\tLayoutRevision layoutRevision = LayoutStagingUtil.getLayoutRevision(\n\t\t\t\tlayout);\n\n\t\t\tif (layoutRevision != null) {\n\t\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\t\tlong recentLayoutSetBranchId =\n\t\t\t\t\tStagingUtil.getRecentLayoutSetBranchId(\n\t\t\t\t\t\tuser, layout.getLayoutSet().getLayoutSetId());\n\n\t\t\t\tif (StagingUtil.isIncomplete(layout, recentLayoutSetBranchId)) {\n\t\t\t\t\tjsonObject.put(\"incomplete\", true);\n\t\t\t\t}\n\n\t\t\t\tlong layoutSetBranchId = layoutRevision.getLayoutSetBranchId();\n\n\t\t\t\tLayoutSetBranch layoutSetBranch =\n\t\t\t\t\tLayoutSetBranchLocalServiceUtil.getLayoutSetBranch(\n\t\t\t\t\t\tlayoutSetBranchId);\n\n\t\t\t\tLayoutBranch layoutBranch = layoutRevision.getLayoutBranch();\n\n\t\t\t\tif (!layoutBranch.isMaster()) {\n\t\t\t\t\tjsonObject.put(\n\t\t\t\t\t\t\"layoutBranchId\", layoutBranch.getLayoutBranchId());\n\t\t\t\t\tjsonObject.put(\"layoutBranchName\", layoutBranch.getName());\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutRevisionId\", layoutRevision.getLayoutRevisionId());\n\t\t\t\tjsonObject.put(\"layoutSetBranchId\", layoutSetBranchId);\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutSetBranchName\", layoutSetBranch.getName());\n\t\t\t}\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tJSONObject responseJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tresponseJSONObject.put(\"layouts\", jsonArray);\n\t\tresponseJSONObject.put(\"total\", layouts.size());\n\n\t\treturn responseJSONObject.toString();\n\t}","id":86077,"modified_method":"public static String getLayoutsJSON(\n\t\t\tHttpServletRequest request, long groupId, boolean privateLayout,\n\t\t\tlong parentLayoutId, long[] expandedLayoutIds)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tList<Layout> layoutAncestors = null;\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroupId, privateLayout, parentLayoutId);\n\n\t\tint start = 0;\n\t\tint end = layouts.size();\n\n\t\tlong selPlid = ParamUtil.getLong(request, \"selPlid\");\n\n\t\tif (selPlid != 0) {\n\t\t\tLayout selLayout = LayoutLocalServiceUtil.getLayout(selPlid);\n\n\t\t\tlayoutAncestors = selLayout.getAncestors();\n\n\t\t\tlayoutAncestors.add(selLayout);\n\t\t}\n\n\t\tif (PropsValues.LAYOUT_MANAGE_PAGES_INITIAL_CHILDREN > -1) {\n\t\t\tstart = ParamUtil.getInteger(request, \"start\");\n\t\t\tend = ParamUtil.getInteger(\n\t\t\t\trequest, \"end\",\n\t\t\t\tstart + PropsValues.LAYOUT_MANAGE_PAGES_INITIAL_CHILDREN);\n\n\t\t\tString treeId = _getScopedPaginationTreeId(request);\n\n\t\t\tString paginationJSON = SessionClicks.get(\n\t\t\t\tsession, treeId, StringPool.BLANK);\n\n\t\t\tif (Validator.isNotNull(paginationJSON) && (end >= 0)) {\n\t\t\t\tJSONObject paginationJSONObject =\n\t\t\t\t\tJSONFactoryUtil.createJSONObject(paginationJSON);\n\n\t\t\t\tString key = String.valueOf(parentLayoutId);\n\n\t\t\t\tif (paginationJSONObject.has(key)) {\n\t\t\t\t\tint paginationEnd = paginationJSONObject.getInt(key);\n\n\t\t\t\t\tif (paginationEnd > end) {\n\t\t\t\t\t\tend = paginationEnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstart = Math.max(0, Math.min(start, layouts.size()));\n\n\t\t\tend = Math.min(end, layouts.size());\n\n\t\t\tif (end < 0) {\n\t\t\t\tend = layouts.size();\n\t\t\t}\n\t\t}\n\n\t\tfor (Layout layout : layouts.subList(start, end)) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tif ((layoutAncestors != null) && layoutAncestors.contains(layout) ||\n\t\t\t\tArrayUtil.contains(expandedLayoutIds, layout.getLayoutId())) {\n\n\t\t\t\tString childrenJSON = StringPool.BLANK;\n\n\t\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, virtualLayout.getSourceGroupId(),\n\t\t\t\t\t\tvirtualLayout.getPrivateLayout(),\n\t\t\t\t\t\tvirtualLayout.getLayoutId(), expandedLayoutIds);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, groupId, layout.getPrivateLayout(),\n\t\t\t\t\t\tlayout.getLayoutId(), expandedLayoutIds);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"children\", JSONFactoryUtil.createJSONObject(childrenJSON));\n\t\t\t}\n\n\t\t\tjsonObject.put(\"contentDisplayPage\", layout.isContentDisplayPage());\n\t\t\tjsonObject.put(\"friendlyURL\", layout.getFriendlyURL());\n\n\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\tjsonObject.put(\"groupId\", virtualLayout.getSourceGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjsonObject.put(\"groupId\", layout.getGroupId());\n\t\t\t}\n\n\t\t\tjsonObject.put(\"hasChildren\", layout.hasChildren());\n\t\t\tjsonObject.put(\"layoutId\", layout.getLayoutId());\n\t\t\tjsonObject.put(\"name\", layout.getName(themeDisplay.getLocale()));\n\t\t\tjsonObject.put(\"parentLayoutId\", layout.getParentLayoutId());\n\t\t\tjsonObject.put(\"plid\", layout.getPlid());\n\t\t\tjsonObject.put(\"priority\", layout.getPriority());\n\t\t\tjsonObject.put(\"privateLayout\", layout.isPrivateLayout());\n\t\t\tjsonObject.put(\"type\", layout.getType());\n\t\t\tjsonObject.put(\"updateable\", SitesUtil.isLayoutUpdateable(layout));\n\t\t\tjsonObject.put(\"uuid\", layout.getUuid());\n\n\t\t\tLayoutRevision layoutRevision = LayoutStagingUtil.getLayoutRevision(\n\t\t\t\tlayout);\n\n\t\t\tif (layoutRevision != null) {\n\t\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\t\tlong recentLayoutSetBranchId =\n\t\t\t\t\tStagingUtil.getRecentLayoutSetBranchId(\n\t\t\t\t\t\tuser, layout.getLayoutSet().getLayoutSetId());\n\n\t\t\t\tif (StagingUtil.isIncomplete(layout, recentLayoutSetBranchId)) {\n\t\t\t\t\tjsonObject.put(\"incomplete\", true);\n\t\t\t\t}\n\n\t\t\t\tlong layoutSetBranchId = layoutRevision.getLayoutSetBranchId();\n\n\t\t\t\tLayoutSetBranch layoutSetBranch =\n\t\t\t\t\tLayoutSetBranchLocalServiceUtil.getLayoutSetBranch(\n\t\t\t\t\t\tlayoutSetBranchId);\n\n\t\t\t\tLayoutBranch layoutBranch = layoutRevision.getLayoutBranch();\n\n\t\t\t\tif (!layoutBranch.isMaster()) {\n\t\t\t\t\tjsonObject.put(\n\t\t\t\t\t\t\"layoutBranchId\", layoutBranch.getLayoutBranchId());\n\t\t\t\t\tjsonObject.put(\"layoutBranchName\", layoutBranch.getName());\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutRevisionId\", layoutRevision.getLayoutRevisionId());\n\t\t\t\tjsonObject.put(\"layoutSetBranchId\", layoutSetBranchId);\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutSetBranchName\", layoutSetBranch.getName());\n\t\t\t}\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tJSONObject responseJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tresponseJSONObject.put(\"layouts\", jsonArray);\n\t\tresponseJSONObject.put(\"total\", layouts.size());\n\n\t\treturn responseJSONObject.toString();\n\t}","commit_id":"3f4504987e5c3219895512a9e90f0ceb76908427","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n   * Tests whether the committed set is advanced properly on WAL replay.\n   */\n  @Test\n  public void testCommittedSetClearing() throws Exception {\n    CConfiguration conf = getConfiguration(\"testCommittedSetClearing\");\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 0); // no cleanup thread\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_INTERVAL, 0); // no periodic snapshots\n\n    TransactionStateStorage storage1 = null;\n    TransactionStateStorage storage2 = null;\n    try {\n      storage1 = getStorage(conf);\n      InMemoryTransactionManager txManager = new InMemoryTransactionManager\n        (conf, storage1, injector.getInstance(MetricsCollectionService.class));\n      txManager.startAndWait();\n\n      // TODO: replace with new persistence tests\n      final byte[] a = { 'a' };\n      final byte[] b = { 'b' };\n      // start a tx1, add a change A and commit\n      Transaction tx1 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx1, Collections.singleton(a)));\n      Assert.assertTrue(txManager.commit(tx1));\n      // start a tx2 and add a change B\n      Transaction tx2 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx2, Collections.singleton(b)));\n      // start a tx3\n      Transaction tx3 = txManager.startShort();\n      TransactionSnapshot origState = txManager.getCurrentState();\n      LOG.info(\"Orig state: \" + origState);\n\n      // simulate a failure by starting a new tx manager without stopping first\n      storage2 = getStorage(conf);\n      txManager = new InMemoryTransactionManager(conf, storage2, injector.getInstance(MetricsCollectionService.class));\n      txManager.startAndWait();\n\n      // check that the reloaded state matches the old\n      TransactionSnapshot newState = txManager.getCurrentState();\n      LOG.info(\"New state: \" + newState);\n      assertEquals(origState, newState);\n\n    } finally {\n      if (storage1 != null) {\n        storage1.stopAndWait();\n      }\n      if (storage2 != null) {\n        storage2.stopAndWait();\n      }\n    }\n  }","id":86078,"modified_method":"/**\n   * Tests whether the committed set is advanced properly on WAL replay.\n   */\n  @Test\n  public void testCommittedSetClearing() throws Exception {\n    CConfiguration conf = getConfiguration(\"testCommittedSetClearing\");\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 0); // no cleanup thread\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_INTERVAL, 0); // no periodic snapshots\n\n    TransactionStateStorage storage1 = null;\n    TransactionStateStorage storage2 = null;\n    try {\n      storage1 = getStorage(conf);\n      InMemoryTransactionManager txManager = new InMemoryTransactionManager\n        (conf, storage1, new NoOpMetricsCollectionService());\n      txManager.startAndWait();\n\n      // TODO: replace with new persistence tests\n      final byte[] a = { 'a' };\n      final byte[] b = { 'b' };\n      // start a tx1, add a change A and commit\n      Transaction tx1 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx1, Collections.singleton(a)));\n      Assert.assertTrue(txManager.commit(tx1));\n      // start a tx2 and add a change B\n      Transaction tx2 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx2, Collections.singleton(b)));\n      // start a tx3\n      Transaction tx3 = txManager.startShort();\n      TransactionSnapshot origState = txManager.getCurrentState();\n      LOG.info(\"Orig state: \" + origState);\n\n      // simulate a failure by starting a new tx manager without stopping first\n      storage2 = getStorage(conf);\n      txManager = new InMemoryTransactionManager(conf, storage2, new NoOpMetricsCollectionService());\n      txManager.startAndWait();\n\n      // check that the reloaded state matches the old\n      TransactionSnapshot newState = txManager.getCurrentState();\n      LOG.info(\"New state: \" + newState);\n      assertEquals(origState, newState);\n\n    } finally {\n      if (storage1 != null) {\n        storage1.stopAndWait();\n      }\n      if (storage2 != null) {\n        storage2.stopAndWait();\n      }\n    }\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTransactionManagerPersistence() throws Exception {\n    CConfiguration conf = getConfiguration(\"testTransactionManagerPersistence\");\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 0); // no cleanup thread\n    // start snapshot thread, but with long enough interval so we only get snapshots on shutdown\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_INTERVAL, 600);\n\n    TransactionStateStorage storage = null;\n    TransactionStateStorage storage2 = null;\n    TransactionStateStorage storage3 = null;\n    try {\n      storage = getStorage(conf);\n      InMemoryTransactionManager txManager = new InMemoryTransactionManager\n        (conf, storage, injector.getInstance(MetricsCollectionService.class));\n      txManager.startAndWait();\n\n      // TODO: replace with new persistence tests\n      final byte[] a = { 'a' };\n      final byte[] b = { 'b' };\n      // start a tx1, add a change A and commit\n      Transaction tx1 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx1, Collections.singleton(a)));\n      Assert.assertTrue(txManager.commit(tx1));\n      // start a tx2 and add a change B\n      Transaction tx2 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx2, Collections.singleton(b)));\n      // start a tx3\n      Transaction tx3 = txManager.startShort();\n      // restart\n      txManager.stopAndWait();\n      TransactionSnapshot origState = txManager.getCurrentState();\n      LOG.info(\"Orig state: \" + origState);\n\n      Thread.sleep(100);\n      // starts a new tx manager\n      storage2 = getStorage(conf);\n      txManager = new InMemoryTransactionManager(conf, storage2, injector.getInstance(MetricsCollectionService.class));\n      txManager.startAndWait();\n\n      // check that the reloaded state matches the old\n      TransactionSnapshot newState = txManager.getCurrentState();\n      LOG.info(\"New state: \" + newState);\n      assertEquals(origState, newState);\n\n      // commit tx2\n      Assert.assertTrue(txManager.commit(tx2));\n      // start another transaction, must be greater than tx3\n      Transaction tx4 = txManager.startShort();\n      Assert.assertTrue(tx4.getWritePointer() > tx3.getWritePointer());\n      // tx1 must be visble from tx2, but tx3 and tx4 must not\n      Assert.assertTrue(tx2.isVisible(tx1.getWritePointer()));\n      Assert.assertFalse(tx2.isVisible(tx3.getWritePointer()));\n      Assert.assertFalse(tx2.isVisible(tx4.getWritePointer()));\n      // add same change for tx3\n      Assert.assertFalse(txManager.canCommit(tx3, Collections.singleton(b)));\n      // check visibility with new xaction\n      Transaction tx5 = txManager.startShort();\n      Assert.assertTrue(tx5.isVisible(tx1.getWritePointer()));\n      Assert.assertTrue(tx5.isVisible(tx2.getWritePointer()));\n      Assert.assertFalse(tx5.isVisible(tx3.getWritePointer()));\n      Assert.assertFalse(tx5.isVisible(tx4.getWritePointer()));\n      // can commit tx3?\n      txManager.abort(tx3);\n      txManager.abort(tx4);\n      txManager.abort(tx5);\n      // start new tx and verify its exclude list is empty\n      Transaction tx6 = txManager.startShort();\n      Assert.assertFalse(tx6.hasExcludes());\n      txManager.abort(tx6);\n\n      // now start 5 x claim size transactions\n      Transaction tx = txManager.startShort();\n      for (int i = 1; i < 50; i++) {\n        tx = txManager.startShort();\n      }\n      origState = txManager.getCurrentState();\n\n      Thread.sleep(100);\n      // simulate crash by starting a new tx manager without a stopAndWait\n      storage3 = getStorage(conf);\n      txManager = new InMemoryTransactionManager(conf, storage3, injector.getInstance(MetricsCollectionService.class));\n      txManager.startAndWait();\n\n      // verify state again matches (this time should include WAL replay)\n      newState = txManager.getCurrentState();\n      assertEquals(origState, newState);\n\n      // get a new transaction and verify it is greater\n      Transaction txAfter = txManager.startShort();\n      Assert.assertTrue(txAfter.getWritePointer() > tx.getWritePointer());\n    } finally {\n      if (storage != null) {\n        storage.stopAndWait();\n      }\n      if (storage2 != null) {\n        storage2.stopAndWait();\n      }\n      if (storage3 != null) {\n        storage3.stopAndWait();\n      }\n    }\n  }","id":86079,"modified_method":"@Test\n  public void testTransactionManagerPersistence() throws Exception {\n    CConfiguration conf = getConfiguration(\"testTransactionManagerPersistence\");\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 0); // no cleanup thread\n    // start snapshot thread, but with long enough interval so we only get snapshots on shutdown\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_INTERVAL, 600);\n\n    TransactionStateStorage storage = null;\n    TransactionStateStorage storage2 = null;\n    TransactionStateStorage storage3 = null;\n    try {\n      storage = getStorage(conf);\n      InMemoryTransactionManager txManager = new InMemoryTransactionManager\n        (conf, storage, new NoOpMetricsCollectionService());\n      txManager.startAndWait();\n\n      // TODO: replace with new persistence tests\n      final byte[] a = { 'a' };\n      final byte[] b = { 'b' };\n      // start a tx1, add a change A and commit\n      Transaction tx1 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx1, Collections.singleton(a)));\n      Assert.assertTrue(txManager.commit(tx1));\n      // start a tx2 and add a change B\n      Transaction tx2 = txManager.startShort();\n      Assert.assertTrue(txManager.canCommit(tx2, Collections.singleton(b)));\n      // start a tx3\n      Transaction tx3 = txManager.startShort();\n      // restart\n      txManager.stopAndWait();\n      TransactionSnapshot origState = txManager.getCurrentState();\n      LOG.info(\"Orig state: \" + origState);\n\n      Thread.sleep(100);\n      // starts a new tx manager\n      storage2 = getStorage(conf);\n      txManager = new InMemoryTransactionManager(conf, storage2, new NoOpMetricsCollectionService());\n      txManager.startAndWait();\n\n      // check that the reloaded state matches the old\n      TransactionSnapshot newState = txManager.getCurrentState();\n      LOG.info(\"New state: \" + newState);\n      assertEquals(origState, newState);\n\n      // commit tx2\n      Assert.assertTrue(txManager.commit(tx2));\n      // start another transaction, must be greater than tx3\n      Transaction tx4 = txManager.startShort();\n      Assert.assertTrue(tx4.getWritePointer() > tx3.getWritePointer());\n      // tx1 must be visble from tx2, but tx3 and tx4 must not\n      Assert.assertTrue(tx2.isVisible(tx1.getWritePointer()));\n      Assert.assertFalse(tx2.isVisible(tx3.getWritePointer()));\n      Assert.assertFalse(tx2.isVisible(tx4.getWritePointer()));\n      // add same change for tx3\n      Assert.assertFalse(txManager.canCommit(tx3, Collections.singleton(b)));\n      // check visibility with new xaction\n      Transaction tx5 = txManager.startShort();\n      Assert.assertTrue(tx5.isVisible(tx1.getWritePointer()));\n      Assert.assertTrue(tx5.isVisible(tx2.getWritePointer()));\n      Assert.assertFalse(tx5.isVisible(tx3.getWritePointer()));\n      Assert.assertFalse(tx5.isVisible(tx4.getWritePointer()));\n      // can commit tx3?\n      txManager.abort(tx3);\n      txManager.abort(tx4);\n      txManager.abort(tx5);\n      // start new tx and verify its exclude list is empty\n      Transaction tx6 = txManager.startShort();\n      Assert.assertFalse(tx6.hasExcludes());\n      txManager.abort(tx6);\n\n      // now start 5 x claim size transactions\n      Transaction tx = txManager.startShort();\n      for (int i = 1; i < 50; i++) {\n        tx = txManager.startShort();\n      }\n      origState = txManager.getCurrentState();\n\n      Thread.sleep(100);\n      // simulate crash by starting a new tx manager without a stopAndWait\n      storage3 = getStorage(conf);\n      txManager = new InMemoryTransactionManager(conf, storage3, new NoOpMetricsCollectionService());\n      txManager.startAndWait();\n\n      // verify state again matches (this time should include WAL replay)\n      newState = txManager.getCurrentState();\n      assertEquals(origState, newState);\n\n      // get a new transaction and verify it is greater\n      Transaction txAfter = txManager.startShort();\n      Assert.assertTrue(txAfter.getWritePointer() > tx.getWritePointer());\n    } finally {\n      if (storage != null) {\n        storage.stopAndWait();\n      }\n      if (storage2 != null) {\n        storage2.stopAndWait();\n      }\n      if (storage3 != null) {\n        storage3.stopAndWait();\n      }\n    }\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized TransactionSnapshot getSnapshot() throws IOException {\n    TransactionSnapshot snapshot = null;\n    if (!isRunning() && !isStopping()) {\n      return null;\n    }\n\n    long now = System.currentTimeMillis();\n    // avoid duplicate snapshots at same timestamp\n    if (now == lastSnapshotTime || (currentLog != null && now == currentLog.getTimestamp())) {\n      try {\n        TimeUnit.MILLISECONDS.sleep(1);\n      } catch (InterruptedException ie) { }\n    }\n    // copy in memory state\n    snapshot = getCurrentState();\n    if (metricsCollectionService != null) {\n      metricsCollector.gauge(\"invalid\", invalid.size());\n      metricsCollector.gauge(\"inprogress\", inProgress.size());\n      metricsCollector.gauge(\"committing\", committingChangeSets.size());\n      metricsCollector.gauge(\"committed\", committedChangeSets.size());\n    }\n\n    LOG.info(\"Starting snapshot of transaction state with timestamp {}\", snapshot.getTimestamp());\n    LOG.info(\"Returning snapshot of state: \" + snapshot);\n    return snapshot;\n  }","id":86080,"modified_method":"public synchronized TransactionSnapshot getSnapshot() throws IOException {\n    TransactionSnapshot snapshot = null;\n    if (!isRunning() && !isStopping()) {\n      return null;\n    }\n\n    long now = System.currentTimeMillis();\n    // avoid duplicate snapshots at same timestamp\n    if (now == lastSnapshotTime || (currentLog != null && now == currentLog.getTimestamp())) {\n      try {\n        TimeUnit.MILLISECONDS.sleep(1);\n      } catch (InterruptedException ie) { }\n    }\n    // copy in memory state\n    snapshot = getCurrentState();\n\n    metricsCollector.gauge(\"invalid\", invalid.size());\n    metricsCollector.gauge(\"inprogress\", inProgress.size());\n    metricsCollector.gauge(\"committing\", committingChangeSets.size());\n    metricsCollector.gauge(\"committed\", committedChangeSets.size());\n\n    LOG.info(\"Starting snapshot of transaction state with timestamp {}\", snapshot.getTimestamp());\n    LOG.info(\"Returning snapshot of state: \" + snapshot);\n    return snapshot;\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * This constructor should only be used for testing. It uses default configuration and a no-op persistor.\n   * If this constructor is used, there is no need to call init().\n   */\n  public InMemoryTransactionManager() {\n    this(CConfiguration.create(), new NoOpTransactionStateStorage(), null);\n  }","id":86081,"modified_method":"/**\n   * This constructor should only be used for testing. It uses default configuration and a no-op persistor.\n   * If this constructor is used, there is no need to call init().\n   */\n  public InMemoryTransactionManager() {\n    this(CConfiguration.create(), new NoOpTransactionStateStorage(),\n         new NoOpMetricsCollectionService());\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public InMemoryTransactionManager(CConfiguration conf, @Nonnull TransactionStateStorage persistor,\n                                    @Nullable MetricsCollectionService metricsCollectionService) {\n    this.persistor = persistor;\n    cleanupInterval = conf.getInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL,\n                                  Constants.Transaction.Manager.DEFAULT_TX_CLEANUP_INTERVAL);\n    defaultTimeout = conf.getInt(Constants.Transaction.Manager.CFG_TX_TIMEOUT,\n                                 Constants.Transaction.Manager.DEFAULT_TX_TIMEOUT);\n    snapshotFrequencyInSeconds = conf.getLong(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_INTERVAL,\n                                              Constants.Transaction.Manager.DEFAULT_TX_SNAPSHOT_INTERVAL);\n    // must always keep at least 1 snapshot\n    snapshotRetainCount = Math.max(conf.getInt(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_RETAIN,\n                                               Constants.Transaction.Manager.DEFAULT_TX_SNAPSHOT_RETAIN), 1);\n    this.metricsCollectionService = metricsCollectionService;\n    if (metricsCollectionService != null) {\n      metricsCollector = metricsCollectionService.getCollector(MetricsScope.REACTOR, \"transactions\", \"0\");\n    }\n    clear();\n  }","id":86082,"modified_method":"@Inject\n  public InMemoryTransactionManager(CConfiguration conf, @Nonnull TransactionStateStorage persistor,\n                                    @Nullable MetricsCollectionService metricsCollectionService) {\n    this.persistor = persistor;\n    cleanupInterval = conf.getInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL,\n                                  Constants.Transaction.Manager.DEFAULT_TX_CLEANUP_INTERVAL);\n    defaultTimeout = conf.getInt(Constants.Transaction.Manager.CFG_TX_TIMEOUT,\n                                 Constants.Transaction.Manager.DEFAULT_TX_TIMEOUT);\n    snapshotFrequencyInSeconds = conf.getLong(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_INTERVAL,\n                                              Constants.Transaction.Manager.DEFAULT_TX_SNAPSHOT_INTERVAL);\n    // must always keep at least 1 snapshot\n    snapshotRetainCount = Math.max(conf.getInt(Constants.Transaction.Manager.CFG_TX_SNAPSHOT_RETAIN,\n                                               Constants.Transaction.Manager.DEFAULT_TX_SNAPSHOT_RETAIN), 1);\n    this.metricsCollectionService = metricsCollectionService;\n    metricsCollector = metricsCollectionService.getCollector(MetricsScope.REACTOR, \"transactions\", \"0\");\n\n    clear();\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTransactionCleanup() throws Exception {\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 3);\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_TIMEOUT, 2);\n    // using a new tx manager that cleans up\n    InMemoryTransactionManager txm = new InMemoryTransactionManager\n      (conf, new InMemoryTransactionStateStorage(), injector.getInstance(MetricsCollectionService.class));\n    txm.startAndWait();\n    try {\n      Assert.assertEquals(0, txm.getInvalidSize());\n      Assert.assertEquals(0, txm.getCommittedSize());\n      // start a transaction and leave it open\n      Transaction tx1 = txm.startShort();\n      // start a long running transaction and leave it open\n      Transaction tx2 = txm.startLong();\n      Transaction tx3 = txm.startLong();\n      // start and commit a bunch of transactions\n      for (int i = 0; i < 10; i++) {\n        Transaction tx = txm.startShort();\n        Assert.assertTrue(txm.canCommit(tx, Collections.singleton(new byte[] { (byte) i })));\n        Assert.assertTrue(txm.commit(tx));\n      }\n      // all of these should still be in the committed set\n      Assert.assertEquals(0, txm.getInvalidSize());\n      Assert.assertEquals(10, txm.getCommittedSize());\n      // sleep longer than the cleanup interval\n      TimeUnit.SECONDS.sleep(5);\n      // transaction should now be invalid\n      Assert.assertEquals(1, txm.getInvalidSize());\n      // run another transaction\n      Transaction txx = txm.startShort();\n      // verify the exclude\n      Assert.assertFalse(txx.isVisible(tx1.getWritePointer()));\n      Assert.assertFalse(txx.isVisible(tx2.getWritePointer()));\n      Assert.assertFalse(txx.isVisible(tx3.getWritePointer()));\n      // try to commit the last transaction that was started\n      Assert.assertTrue(txm.canCommit(txx, Collections.singleton(new byte[] { 0x0a })));\n      Assert.assertTrue(txm.commit(txx));\n\n      // now the committed change sets should be empty again\n      Assert.assertEquals(0, txm.getCommittedSize());\n      // cannot commit transaction as it was timed out\n      try {\n        txm.canCommit(tx1, Collections.singleton(new byte[] { 0x11 }));\n        Assert.fail();\n      } catch (TransactionNotInProgressException e) {\n        // expected\n      }\n      txm.abort(tx1);\n      // abort should have removed from invalid\n      Assert.assertEquals(0, txm.getInvalidSize());\n      // run another bunch of transactions\n      for (int i = 0; i < 10; i++) {\n        Transaction tx = txm.startShort();\n        Assert.assertTrue(txm.canCommit(tx, Collections.singleton(new byte[] { (byte) i })));\n        Assert.assertTrue(txm.commit(tx));\n      }\n      // none of these should still be in the committed set (tx2 is long-running).\n      Assert.assertEquals(0, txm.getInvalidSize());\n      Assert.assertEquals(0, txm.getCommittedSize());\n      // commit tx2, abort tx3\n      Assert.assertTrue(txm.commit(tx2));\n      txm.abort(tx3);\n      // none of these should still be in the committed set (tx2 is long-running).\n      // Only tx3 is invalid list as it was aborted and is long-running. tx1 is short one and it rolled back its changes\n      // so it should NOT be in invalid list\n      Assert.assertEquals(1, txm.getInvalidSize());\n      Assert.assertEquals(tx3.getWritePointer(), (long) txm.getCurrentState().getInvalid().iterator().next());\n      Assert.assertEquals(1, txm.getExcludedListSize());\n    } finally {\n      txm.stopAndWait();\n    }\n  }","id":86083,"modified_method":"@Test\n  public void testTransactionCleanup() throws Exception {\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 3);\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_TIMEOUT, 2);\n    // using a new tx manager that cleans up\n    InMemoryTransactionManager txm = new InMemoryTransactionManager\n      (conf, new InMemoryTransactionStateStorage(), new NoOpMetricsCollectionService());\n    txm.startAndWait();\n    try {\n      Assert.assertEquals(0, txm.getInvalidSize());\n      Assert.assertEquals(0, txm.getCommittedSize());\n      // start a transaction and leave it open\n      Transaction tx1 = txm.startShort();\n      // start a long running transaction and leave it open\n      Transaction tx2 = txm.startLong();\n      Transaction tx3 = txm.startLong();\n      // start and commit a bunch of transactions\n      for (int i = 0; i < 10; i++) {\n        Transaction tx = txm.startShort();\n        Assert.assertTrue(txm.canCommit(tx, Collections.singleton(new byte[] { (byte) i })));\n        Assert.assertTrue(txm.commit(tx));\n      }\n      // all of these should still be in the committed set\n      Assert.assertEquals(0, txm.getInvalidSize());\n      Assert.assertEquals(10, txm.getCommittedSize());\n      // sleep longer than the cleanup interval\n      TimeUnit.SECONDS.sleep(5);\n      // transaction should now be invalid\n      Assert.assertEquals(1, txm.getInvalidSize());\n      // run another transaction\n      Transaction txx = txm.startShort();\n      // verify the exclude\n      Assert.assertFalse(txx.isVisible(tx1.getWritePointer()));\n      Assert.assertFalse(txx.isVisible(tx2.getWritePointer()));\n      Assert.assertFalse(txx.isVisible(tx3.getWritePointer()));\n      // try to commit the last transaction that was started\n      Assert.assertTrue(txm.canCommit(txx, Collections.singleton(new byte[] { 0x0a })));\n      Assert.assertTrue(txm.commit(txx));\n\n      // now the committed change sets should be empty again\n      Assert.assertEquals(0, txm.getCommittedSize());\n      // cannot commit transaction as it was timed out\n      try {\n        txm.canCommit(tx1, Collections.singleton(new byte[] { 0x11 }));\n        Assert.fail();\n      } catch (TransactionNotInProgressException e) {\n        // expected\n      }\n      txm.abort(tx1);\n      // abort should have removed from invalid\n      Assert.assertEquals(0, txm.getInvalidSize());\n      // run another bunch of transactions\n      for (int i = 0; i < 10; i++) {\n        Transaction tx = txm.startShort();\n        Assert.assertTrue(txm.canCommit(tx, Collections.singleton(new byte[] { (byte) i })));\n        Assert.assertTrue(txm.commit(tx));\n      }\n      // none of these should still be in the committed set (tx2 is long-running).\n      Assert.assertEquals(0, txm.getInvalidSize());\n      Assert.assertEquals(0, txm.getCommittedSize());\n      // commit tx2, abort tx3\n      Assert.assertTrue(txm.commit(tx2));\n      txm.abort(tx3);\n      // none of these should still be in the committed set (tx2 is long-running).\n      // Only tx3 is invalid list as it was aborted and is long-running. tx1 is short one and it rolled back its changes\n      // so it should NOT be in invalid list\n      Assert.assertEquals(1, txm.getInvalidSize());\n      Assert.assertEquals(tx3.getWritePointer(), (long) txm.getCurrentState().getInvalid().iterator().next());\n      Assert.assertEquals(1, txm.getExcludedListSize());\n    } finally {\n      txm.stopAndWait();\n    }\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void before() {\n\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 0); // no cleanup thread\n    // todo should create two sets of tests, one with LocalFileTxStateStorage and one with InMemoryTxStateStorage\n    injector = Guice.createInjector(\n      new AbstractModule() {\n      @Override\n      protected void configure() {\n        MetricsCollectionService metricsCollectionService = new NoOpMetricsCollectionService();\n        bind(MetricsCollectionService.class).toInstance(metricsCollectionService);\n      }\n    });\n    txStateStorage = new InMemoryTransactionStateStorage();\n    txManager = new InMemoryTransactionManager\n      (conf, txStateStorage, injector.getInstance(MetricsCollectionService.class));\n    txManager.startAndWait();\n  }","id":86084,"modified_method":"@Before\n  public void before() {\n\n    conf.setInt(Constants.Transaction.Manager.CFG_TX_CLEANUP_INTERVAL, 0); // no cleanup thread\n    // todo should create two sets of tests, one with LocalFileTxStateStorage and one with InMemoryTxStateStorage\n    txStateStorage = new InMemoryTransactionStateStorage();\n    txManager = new InMemoryTransactionManager\n      (conf, txStateStorage, new NoOpMetricsCollectionService());\n    txManager.startAndWait();\n  }","commit_id":"968fd17a87e6cce862952172a96e3b60a5907fd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void configure(BackendTarget backend, String serializedCatalog,\n                          CatalogContext catalogContext,\n                          int kfactor, CatalogSpecificPlanner csp,\n                          int numberOfPartitions,\n                          boolean createForRejoin,\n                          StatsAgent agent,\n                          MemoryStats memStats,\n                          CommandLog cl,\n                          NodeDRGateway drGateway)\n        throws KeeperException, InterruptedException, ExecutionException\n    {\n        super.configureCommon(backend, serializedCatalog, catalogContext,\n                csp, numberOfPartitions,\n                createForRejoin && isRejoinable(), agent, memStats, cl);\n        // add ourselves to the ephemeral node list which BabySitters will watch for this\n        // partition\n        LeaderElector.createParticipantNode(m_messenger.getZK(),\n                LeaderElector.electionDirForPartition(m_partitionId),\n                Long.toString(getInitiatorHSId()), null);\n    }","id":86085,"modified_method":"@Override\n    public void configure(BackendTarget backend, String serializedCatalog,\n                          CatalogContext catalogContext,\n                          int kfactor, CatalogSpecificPlanner csp,\n                          int numberOfPartitions,\n                          boolean createForRejoin,\n                          StatsAgent agent,\n                          MemoryStats memStats,\n                          CommandLog cl,\n                          NodeDRGateway drGateway)\n        throws KeeperException, InterruptedException, ExecutionException\n    {\n        super.configureCommon(backend, serializedCatalog, catalogContext,\n                csp, numberOfPartitions,\n                createForRejoin && isRejoinable(), null, null, cl);\n        // add ourselves to the ephemeral node list which BabySitters will watch for this\n        // partition\n        LeaderElector.createParticipantNode(m_messenger.getZK(),\n                LeaderElector.electionDirForPartition(m_partitionId),\n                Long.toString(getInitiatorHSId()), null);\n    }","commit_id":"5195a6b0edd5a36074349330bf399db19e041a5f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Create a new execution site and the corresponding EE */\n    public Site(\n            SiteTaskerQueue scheduler,\n            long siteId,\n            BackendTarget backend,\n            CatalogContext context,\n            String serializedCatalog,\n            long txnId,\n            int partitionId,\n            int numPartitions,\n            boolean createForRejoin,\n            int snapshotPriority,\n            InitiatorMailbox initiatorMailbox,\n            StatsAgent agent,\n            MemoryStats memStats)\n    {\n        m_siteId = siteId;\n        m_context = context;\n        m_partitionId = partitionId;\n        m_numberOfPartitions = numPartitions;\n        m_scheduler = scheduler;\n        m_backend = backend;\n        m_isRejoining = createForRejoin;\n        m_snapshotPriority = snapshotPriority;\n        // need this later when running in the final thread.\n        m_startupConfig = new StartupConfig(serializedCatalog, txnId);\n        m_lastCommittedTxnId = TxnEgo.makeZero(partitionId).getTxnId();\n        m_lastCommittedSpHandle = TxnEgo.makeZero(partitionId).getTxnId();\n        m_currentTxnId = Long.MIN_VALUE;\n        m_initiatorMailbox = initiatorMailbox;\n\n        m_tableStats = new TableStats(m_siteId);\n        agent.registerStatsSource(SysProcSelector.TABLE,\n                                  m_siteId,\n                                  m_tableStats);\n        m_indexStats = new IndexStats(m_siteId);\n        agent.registerStatsSource(SysProcSelector.INDEX,\n                                  m_siteId,\n                                  m_indexStats);\n        m_memStats = memStats;\n    }","id":86086,"modified_method":"/** Create a new execution site and the corresponding EE */\n    public Site(\n            SiteTaskerQueue scheduler,\n            long siteId,\n            BackendTarget backend,\n            CatalogContext context,\n            String serializedCatalog,\n            long txnId,\n            int partitionId,\n            int numPartitions,\n            boolean createForRejoin,\n            int snapshotPriority,\n            InitiatorMailbox initiatorMailbox,\n            StatsAgent agent,\n            MemoryStats memStats)\n    {\n        m_siteId = siteId;\n        m_context = context;\n        m_partitionId = partitionId;\n        m_numberOfPartitions = numPartitions;\n        m_scheduler = scheduler;\n        m_backend = backend;\n        m_isRejoining = createForRejoin;\n        m_snapshotPriority = snapshotPriority;\n        // need this later when running in the final thread.\n        m_startupConfig = new StartupConfig(serializedCatalog, txnId);\n        m_lastCommittedTxnId = TxnEgo.makeZero(partitionId).getTxnId();\n        m_lastCommittedSpHandle = TxnEgo.makeZero(partitionId).getTxnId();\n        m_currentTxnId = Long.MIN_VALUE;\n        m_initiatorMailbox = initiatorMailbox;\n\n        if (agent != null) {\n            m_tableStats = new TableStats(m_siteId);\n            agent.registerStatsSource(SysProcSelector.TABLE,\n                                      m_siteId,\n                                      m_tableStats);\n            m_indexStats = new IndexStats(m_siteId);\n            agent.registerStatsSource(SysProcSelector.INDEX,\n                                      m_siteId,\n                                      m_indexStats);\n            m_memStats = memStats;\n        } else {\n            // MPI doesn't need to track these stats\n            m_tableStats = null;\n            m_indexStats = null;\n            m_memStats = null;\n        }\n    }","commit_id":"5195a6b0edd5a36074349330bf399db19e041a5f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Create an ee and load the volt shared library */\n    public ExecutionEngine(long siteId, int partitionId) {\n        m_partitionId = partitionId;\n        org.voltdb.EELibraryLoader.loadExecutionEngineLibrary(true);\n        m_plannerStats = new PlannerStatsCollector(siteId);\n        final StatsAgent statsAgent = VoltDB.instance().getStatsAgent();\n        statsAgent.registerStatsSource(SysProcSelector.PLANNER, siteId, m_plannerStats);\n    }","id":86087,"modified_method":"/** Create an ee and load the volt shared library */\n    public ExecutionEngine(long siteId, int partitionId) {\n        m_partitionId = partitionId;\n        org.voltdb.EELibraryLoader.loadExecutionEngineLibrary(true);\n        // In mock test environments there may be no stats agent.\n        final StatsAgent statsAgent = VoltDB.instance().getStatsAgent();\n        if (statsAgent != null) {\n            m_plannerStats = new PlannerStatsCollector(siteId);\n            statsAgent.registerStatsSource(SysProcSelector.PLANNER, siteId, m_plannerStats);\n        }\n    }","commit_id":"50db02a82d02f2b50e1bf081dddd288c1a1df908","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public AdHocPlannedStatement planSql(String sqlIn, Object partitionParam, boolean inferSP, boolean allowParameterization) {\n        CacheUse cacheUse = CacheUse.FAIL;\n        m_plannerStats.startPlanning();\n        try {\n            if ((sqlIn == null) || (sqlIn.length() == 0)) {\n                throw new RuntimeException(\"Can't plan empty or null SQL.\");\n            }\n            // remove any spaces or newlines\n            String sql = sqlIn.trim();\n\n            hostLog.debug(\"received sql stmt: \" + sql);\n\n            // no caching for forced single or forced multi SQL\n            boolean cacheable = (partitionParam == null) && (inferSP);\n\n            // check the literal cache for a match\n            if (cacheable) {\n                AdHocPlannedStatement cachedPlan = m_cache.getWithSQL(sqlIn);\n                if (cachedPlan != null) {\n                    cacheUse = CacheUse.HIT1;\n                    return cachedPlan;\n                }\n                else {\n                    cacheUse = CacheUse.MISS;\n                }\n            }\n\n            //Reset plan node id counter\n            AbstractPlanNode.resetPlanNodeIds();\n\n            //////////////////////\n            // PLAN THE STMT\n            //////////////////////\n\n            TrivialCostModel costModel = new TrivialCostModel();\n            PartitioningForStatement partitioning = new PartitioningForStatement(partitionParam, inferSP, inferSP);\n            QueryPlanner planner = new QueryPlanner(\n                    sql, \"PlannerTool\", \"PlannerToolProc\", m_cluster, m_database,\n                    partitioning, m_hsql, new DatabaseEstimates(), true,\n                    AD_HOC_JOINED_TABLE_LIMIT, costModel, null, null);\n            CompiledPlan plan = null;\n            String parsedToken = null;\n            try {\n                planner.parse();\n                parsedToken = planner.parameterize();\n                if (parsedToken != null) {\n\n                    // if cacheable, check the cache for a matching pre-parameterized plan\n                    // if plan found, build the full plan using the parameter data in the\n                    // QueryPlanner.\n                    if (cacheable) {\n                        CorePlan core = m_cache.getWithParsedToken(parsedToken);\n                        if (core != null) {\n                            ParameterSet params = new ParameterSet();\n                            planner.buildParameterSetFromExtractedLiteralsAndReturnPartitionIndex(\n                                    core.parameterTypes, params);\n                            Object partitionKey = null;\n                            if (core.partitioningParamIndex >= 0) {\n                                partitionKey = params.toArray()[core.partitioningParamIndex];\n                            }\n                            AdHocPlannedStatement ahps = new AdHocPlannedStatement(sql.getBytes(VoltDB.UTF8ENCODING),\n                                                                                   core,\n                                                                                   params,\n                                                                                   partitionKey);\n                            m_cache.put(sql, parsedToken, ahps);\n                            cacheUse = CacheUse.HIT2;\n                            return ahps;\n                        }\n                    }\n\n                    // if not cacheable or no cach hit, do the expensive full planning\n                    plan = planner.plan();\n                    assert(plan != null);\n                }\n            } catch (Exception e) {\n                throw new RuntimeException(\"Error compiling query: \" + e.getMessage(), e);\n            }\n\n            if (plan == null) {\n                throw new RuntimeException(\"Null plan received in PlannerTool.planSql\");\n            }\n\n            if (!allowParameterization &&\n                (plan.extractedParamValues.size() == 0) &&\n                (plan.parameters.length > 0))\n            {\n                throw new RuntimeException(\"ERROR: PARAMETERIZATION IN AD HOC QUERY\");\n            }\n\n            if (plan.isContentDeterministic() == false) {\n                String potentialErrMsg =\n                    \"Statement has a non-deterministic result - statement: \\\"\" +\n                    sql + \"\\\" , reason: \" + plan.nondeterminismDetail();\n                // throw new RuntimeException(potentialErrMsg);\n                hostLog.warn(potentialErrMsg);\n            }\n\n            //////////////////////\n            // OUTPUT THE RESULT\n            //////////////////////\n\n            AdHocPlannedStatement ahps = new AdHocPlannedStatement(plan, m_catalogVersion);\n\n            if (cacheable && planner.compiledAsParameterizedPlan()) {\n                assert(parsedToken != null);\n                assert(((ahps.partitionParam == null) && (ahps.core.partitioningParamIndex == -1)) ||\n                       ((ahps.partitionParam != null) && (ahps.core.partitioningParamIndex >= 0)));\n                m_cache.put(sqlIn, parsedToken, ahps);\n            }\n            return ahps;\n        }\n        finally {\n            m_plannerStats.endPlanning(m_cache.getLiteralCacheSize(), m_cache.getCoreCacheSize(), cacheUse, -1);\n        }\n    }","id":86088,"modified_method":"public AdHocPlannedStatement planSql(String sqlIn, Object partitionParam, boolean inferSP, boolean allowParameterization) {\n        CacheUse cacheUse = CacheUse.FAIL;\n        if (m_plannerStats != null) {\n            m_plannerStats.startPlanning();\n        }\n        try {\n            if ((sqlIn == null) || (sqlIn.length() == 0)) {\n                throw new RuntimeException(\"Can't plan empty or null SQL.\");\n            }\n            // remove any spaces or newlines\n            String sql = sqlIn.trim();\n\n            hostLog.debug(\"received sql stmt: \" + sql);\n\n            // no caching for forced single or forced multi SQL\n            boolean cacheable = (partitionParam == null) && (inferSP);\n\n            // check the literal cache for a match\n            if (cacheable) {\n                AdHocPlannedStatement cachedPlan = m_cache.getWithSQL(sqlIn);\n                if (cachedPlan != null) {\n                    cacheUse = CacheUse.HIT1;\n                    return cachedPlan;\n                }\n                else {\n                    cacheUse = CacheUse.MISS;\n                }\n            }\n\n            //Reset plan node id counter\n            AbstractPlanNode.resetPlanNodeIds();\n\n            //////////////////////\n            // PLAN THE STMT\n            //////////////////////\n\n            TrivialCostModel costModel = new TrivialCostModel();\n            PartitioningForStatement partitioning = new PartitioningForStatement(partitionParam, inferSP, inferSP);\n            QueryPlanner planner = new QueryPlanner(\n                    sql, \"PlannerTool\", \"PlannerToolProc\", m_cluster, m_database,\n                    partitioning, m_hsql, new DatabaseEstimates(), true,\n                    AD_HOC_JOINED_TABLE_LIMIT, costModel, null, null);\n            CompiledPlan plan = null;\n            String parsedToken = null;\n            try {\n                planner.parse();\n                parsedToken = planner.parameterize();\n                if (parsedToken != null) {\n\n                    // if cacheable, check the cache for a matching pre-parameterized plan\n                    // if plan found, build the full plan using the parameter data in the\n                    // QueryPlanner.\n                    if (cacheable) {\n                        CorePlan core = m_cache.getWithParsedToken(parsedToken);\n                        if (core != null) {\n                            ParameterSet params = new ParameterSet();\n                            planner.buildParameterSetFromExtractedLiteralsAndReturnPartitionIndex(\n                                    core.parameterTypes, params);\n                            Object partitionKey = null;\n                            if (core.partitioningParamIndex >= 0) {\n                                partitionKey = params.toArray()[core.partitioningParamIndex];\n                            }\n                            AdHocPlannedStatement ahps = new AdHocPlannedStatement(sql.getBytes(VoltDB.UTF8ENCODING),\n                                                                                   core,\n                                                                                   params,\n                                                                                   partitionKey);\n                            m_cache.put(sql, parsedToken, ahps);\n                            cacheUse = CacheUse.HIT2;\n                            return ahps;\n                        }\n                    }\n\n                    // if not cacheable or no cach hit, do the expensive full planning\n                    plan = planner.plan();\n                    assert(plan != null);\n                }\n            } catch (Exception e) {\n                throw new RuntimeException(\"Error compiling query: \" + e.getMessage(), e);\n            }\n\n            if (plan == null) {\n                throw new RuntimeException(\"Null plan received in PlannerTool.planSql\");\n            }\n\n            if (!allowParameterization &&\n                (plan.extractedParamValues.size() == 0) &&\n                (plan.parameters.length > 0))\n            {\n                throw new RuntimeException(\"ERROR: PARAMETERIZATION IN AD HOC QUERY\");\n            }\n\n            if (plan.isContentDeterministic() == false) {\n                String potentialErrMsg =\n                    \"Statement has a non-deterministic result - statement: \\\"\" +\n                    sql + \"\\\" , reason: \" + plan.nondeterminismDetail();\n                // throw new RuntimeException(potentialErrMsg);\n                hostLog.warn(potentialErrMsg);\n            }\n\n            //////////////////////\n            // OUTPUT THE RESULT\n            //////////////////////\n\n            AdHocPlannedStatement ahps = new AdHocPlannedStatement(plan, m_catalogVersion);\n\n            if (cacheable && planner.compiledAsParameterizedPlan()) {\n                assert(parsedToken != null);\n                assert(((ahps.partitionParam == null) && (ahps.core.partitioningParamIndex == -1)) ||\n                       ((ahps.partitionParam != null) && (ahps.core.partitioningParamIndex >= 0)));\n                m_cache.put(sqlIn, parsedToken, ahps);\n            }\n            return ahps;\n        }\n        finally {\n            if (m_plannerStats != null) {\n                m_plannerStats.endPlanning(m_cache.getLiteralCacheSize(), m_cache.getCoreCacheSize(), cacheUse, -1);\n            }\n        }\n    }","commit_id":"50db02a82d02f2b50e1bf081dddd288c1a1df908","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public PlannerTool(final Cluster cluster, final Database database, int catalogVersion) {\n        assert(cluster != null);\n        assert(database != null);\n\n        m_database = database;\n        m_cluster = cluster;\n        m_catalogVersion = catalogVersion;\n        m_cache = AdHocCompilerCache.getCacheForCatalogVersion(catalogVersion);\n\n        // LOAD HSQL\n        m_hsql = HSQLInterface.loadHsqldb();\n        String hexDDL = m_database.getSchema();\n        String ddl = Encoder.hexDecodeToString(hexDDL);\n        String[] commands = ddl.split(\"\\n\");\n        for (String command : commands) {\n            String decoded_cmd = Encoder.hexDecodeToString(command);\n            decoded_cmd = decoded_cmd.trim();\n            if (decoded_cmd.length() == 0)\n                continue;\n            try {\n                m_hsql.runDDLCommand(decoded_cmd);\n            }\n            catch (HSQLParseException e) {\n                // need a good error message here\n                throw new RuntimeException(\"Error creating hsql: \" + e.getMessage() + \" in DDL statement: \" + decoded_cmd);\n            }\n        }\n\n        hostLog.info(\"hsql loaded\");\n\n        // Create and register a singleton planner stats collector, if this is the first time.\n        synchronized (this) {\n            if (m_plannerStats == null) {\n                m_plannerStats = new PlannerStatsCollector(-1);\n                final StatsAgent statsAgent = VoltDB.instance().getStatsAgent();\n                statsAgent.registerStatsSource(SysProcSelector.PLANNER, -1, m_plannerStats);\n            }\n        }\n    }","id":86089,"modified_method":"public PlannerTool(final Cluster cluster, final Database database, int catalogVersion) {\n        assert(cluster != null);\n        assert(database != null);\n\n        m_database = database;\n        m_cluster = cluster;\n        m_catalogVersion = catalogVersion;\n        m_cache = AdHocCompilerCache.getCacheForCatalogVersion(catalogVersion);\n\n        // LOAD HSQL\n        m_hsql = HSQLInterface.loadHsqldb();\n        String hexDDL = m_database.getSchema();\n        String ddl = Encoder.hexDecodeToString(hexDDL);\n        String[] commands = ddl.split(\"\\n\");\n        for (String command : commands) {\n            String decoded_cmd = Encoder.hexDecodeToString(command);\n            decoded_cmd = decoded_cmd.trim();\n            if (decoded_cmd.length() == 0)\n                continue;\n            try {\n                m_hsql.runDDLCommand(decoded_cmd);\n            }\n            catch (HSQLParseException e) {\n                // need a good error message here\n                throw new RuntimeException(\"Error creating hsql: \" + e.getMessage() + \" in DDL statement: \" + decoded_cmd);\n            }\n        }\n\n        hostLog.info(\"hsql loaded\");\n\n        // Create and register a singleton planner stats collector, if this is the first time.\n        // In mock test environments there may be no stats agent.\n        synchronized (this) {\n            if (m_plannerStats == null) {\n                final StatsAgent statsAgent = VoltDB.instance().getStatsAgent();\n                if (statsAgent != null) {\n                    m_plannerStats = new PlannerStatsCollector(-1);\n                    statsAgent.registerStatsSource(SysProcSelector.PLANNER, -1, m_plannerStats);\n                }\n            }\n        }\n    }","commit_id":"50db02a82d02f2b50e1bf081dddd288c1a1df908","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public StatefulSession getSession() {\r\n        return this.session;\r\n    }","id":86090,"modified_method":"public StatefulKnowledgeSession getSession() {\r\n        return this.session;\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public AgendaGroupDelegate() {\r\n        final Reader drl = new InputStreamReader( AgendaGroupDelegate.class.getResourceAsStream( \"/org/drools/examples/conway/conway-agendagroup.drl\" ) );\r\n\r\n        try {\r\n            PackageBuilder builder = new PackageBuilder();\r\n            builder.addPackageFromDrl( drl );\r\n\r\n            RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n            ruleBase.addPackage( builder.getPackage() );\r\n\r\n            this.session = ruleBase.newStatefulSession();\r\n\r\n        } catch ( Exception e ) {\r\n            throw new RuntimeException( e );\r\n        }\r\n    }","id":86091,"modified_method":"public AgendaGroupDelegate() {\r\n        final Reader drl = new InputStreamReader( AgendaGroupDelegate.class.getResourceAsStream( \"/org/drools/examples/conway/conway-agendagroup.drl\" ) );\r\n\r\n        try {\r\n            KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n            kbuilder.addResource( drl, KnowledgeType.DRL );\r\n            \r\n            KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n            kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\r\n            \r\n            this.session = kbase.newStatefulKnowledgeSession();\r\n        } catch ( Exception e ) {\r\n            throw new RuntimeException( e );\r\n        }\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean nextGeneration() {\r\n        // System.out.println( \"next generation\" );\r\n        session.setFocus( \"kill\" );\r\n        session.setFocus( \"birth\" );\r\n        session.setFocus( \"reset calculate\" );\r\n        session.setFocus( \"rest\" );\r\n        session.setFocus( \"evaluate\" );\r\n        session.setFocus( \"calculate\" );        \r\n        return session.fireAllRules() != 0;\r\n        //return session.getAgenda().getAgendaGroup( \"calculate\" ).size() != 0;\r\n    }","id":86092,"modified_method":"public boolean nextGeneration() {\r\n        // System.out.println( \"next generation\" );\r\n        this.session.getAgenda().getAgendaGroup( \"kill\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"birth\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"reset calculate\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"rest\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"evaluate\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"calculate\" ).setFocus();        \r\n        return session.fireAllRules() != 0;\r\n        //return session.getAgenda().getAgendaGroup( \"calculate\" ).size() != 0;\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void killAll() {\r\n        this.session.setFocus( \"calculate\" );\r\n        this.session.setFocus( \"kill all\" );\r\n        this.session.setFocus( \"calculate\" );\r\n        this.session.fireAllRules();\r\n    }","id":86093,"modified_method":"public void killAll() {\r\n        this.session.getAgenda().getAgendaGroup( \"calculate\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"kill all\" ).setFocus();\r\n        this.session.getAgenda().getAgendaGroup( \"calculate\" ).setFocus();\r\n        this.session.fireAllRules();\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init() {\r\n        this.session.setFocus( \"register neighbor\" );\r\n        this.session.fireAllRules();     \r\n        session.clearAgendaGroup( \"calculate\" );\r\n    }","id":86094,"modified_method":"public void init() {\r\n        this.session.getAgenda().getAgendaGroup( \"register neighbor\" ).setFocus();\r\n        this.session.fireAllRules();     \r\n        this.session.getAgenda().getAgendaGroup( \"calculate\" ).clear();\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public StatefulSession getSession() {\r\n        return this.session;\r\n    }","id":86095,"modified_method":"public StatefulKnowledgeSession getSession() {\r\n        return this.session;\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public RuleFlowDelegate() {\r\n        final Reader drl = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/conway-ruleflow.drl\" ) );\r\n        final Reader generationRf = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/generation.rf\" ) );\r\n        final Reader killAllRf = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/killAll.rf\" ) );\r\n        final Reader registerNeighborRf = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/registerNeighbor.rf\" ) );\r\n\r\n        try {\r\n            PackageBuilder builder = new PackageBuilder();\r\n            builder.addPackageFromDrl( drl );\r\n            builder.addRuleFlow( generationRf );\r\n            builder.addRuleFlow( killAllRf );\r\n            builder.addRuleFlow( registerNeighborRf );\r\n\r\n            RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n            ruleBase.addPackage( builder.getPackage() );\r\n\r\n            this.session = ruleBase.newStatefulSession();\r\n\r\n        } catch ( Exception e ) {\r\n            throw new RuntimeException( e );\r\n        }\r\n    }","id":86096,"modified_method":"public RuleFlowDelegate() {\r\n        final Reader drl = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/conway-ruleflow.drl\" ) );\r\n        final Reader generationRf = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/generation.rf\" ) );\r\n        final Reader killAllRf = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/killAll.rf\" ) );\r\n        final Reader registerNeighborRf = new InputStreamReader( CellGridImpl.class.getResourceAsStream( \"/org/drools/examples/conway/registerNeighbor.rf\" ) );\r\n\r\n        try {\r\n            KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n            kbuilder.addResource( drl, KnowledgeType.DRL );\r\n            kbuilder.addResource(  generationRf, KnowledgeType.DRF );\r\n            kbuilder.addResource( killAllRf, KnowledgeType.DRF );\r\n            kbuilder.addResource( registerNeighborRf, KnowledgeType.DRF );\r\n            \r\n            KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n            kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\r\n            \r\n            this.session = kbase.newStatefulKnowledgeSession();\r\n\r\n        } catch ( Exception e ) {\r\n            throw new RuntimeException( e );\r\n        }\r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init() {\r\n        this.session.startProcess( \"register neighbor\" );\r\n        this.session.fireAllRules();\r\n        session.clearRuleFlowGroup( \"calculate\" );\r\n    }","id":86097,"modified_method":"public void init() {\r\n        this.session.startProcess( \"register neighbor\" );\r\n        this.session.fireAllRules();\r\n        session.getAgenda().getRuleFlowGroup( \"calculate\" ).clear();       \r\n    }","commit_id":"f67ac851abf1af7e32df9f09efd27d56f9894654","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n\t * Evaluate the select expression.\n\t * \n\t * @param docs\n\t * @return\n\t * @throws PermissionDeniedException\n\t * @throws EXistException\n\t * @throws XPathException\n\t */\n\tprotected NodeList select(DocumentSet docs)\n\t\tthrows PermissionDeniedException, EXistException, XPathException {\n\t\ttry {\n\t\t\tXQueryContext context = new XQueryContext(broker);\n\t\t\tcontext.setExclusiveMode(true);\n\t\t\tcontext.setStaticallyKnownDocuments(docs);\n\t\t\tMap.Entry entry;\n\t\t\tfor (Iterator i = namespaces.entrySet().iterator(); i.hasNext();) {\n\t\t\t\tentry = (Map.Entry) i.next();\n\t\t\t\tcontext.declareNamespace(\n\t\t\t\t\t(String) entry.getKey(),\n\t\t\t\t\t(String) entry.getValue());\n\t\t\t}\n\t\t\tXQueryLexer lexer = new XQueryLexer(new StringReader(selectStmt));\n\t\t\tXQueryParser parser = new XQueryParser(lexer);\n\t\t\tXQueryTreeParser treeParser = new XQueryTreeParser(context);\n\t\t\tparser.xpath();\n\t\t\tif (parser.foundErrors()) {\n\t\t\t\tthrow new RuntimeException(parser.getErrorMessage());\n\t\t\t}\n\n\t\t\tAST ast = parser.getAST();\n\n\t\t\tPathExpr expr = new PathExpr(context);\n\t\t\ttreeParser.xpath(ast, expr);\n\t\t\tif (treeParser.foundErrors()) {\n\t\t\t\tthrow new RuntimeException(treeParser.getErrorMessage());\n\t\t\t}\n\t\t\tlong start = System.currentTimeMillis();\n\n\t\t\tSequence resultSeq = expr.eval(null, null);\n\t\t\tif (resultSeq.getItemType() != Type.NODE)\n\t\t\t\tthrow new EXistException(\"select expression should evaluate to a\" + \"node-set\");\n\t\t\tLOG.debug(\"found \" + resultSeq.getLength() + \" for select: \" + selectStmt);\n\t\t\treturn (NodeList)resultSeq;\n\t\t} catch (RecognitionException e) {\n\t\t\tLOG.warn(\"error while parsing select expression\", e);\n\t\t\tthrow new EXistException(e);\n\t\t} catch (TokenStreamException e) {\n\t\t\tLOG.warn(\"error while parsing select expression\", e);\n\t\t\tthrow new EXistException(e);\n\t\t}\n\t}","id":86098,"modified_method":"/**\n\t * Evaluate the select expression.\n\t * \n\t * @param docs\n\t * @return\n\t * @throws PermissionDeniedException\n\t * @throws EXistException\n\t * @throws XPathException\n\t */\n\tprotected NodeList select(DocumentSet docs)\n\t\tthrows PermissionDeniedException, EXistException, XPathException {\n\t\ttry {\n\t\t\tXQueryContext context = new XQueryContext(broker);\n\t\t\tcontext.setExclusiveMode(true);\n\t\t\tcontext.setStaticallyKnownDocuments(docs);\n\t\t\tMap.Entry entry;\n\t\t\tfor (Iterator i = namespaces.entrySet().iterator(); i.hasNext();) {\n\t\t\t\tentry = (Map.Entry) i.next();\n\t\t\t\tcontext.declareNamespace(\n\t\t\t\t\t(String) entry.getKey(),\n\t\t\t\t\t(String) entry.getValue());\n\t\t\t}\n\t\t\tXQueryLexer lexer = new XQueryLexer(new StringReader(selectStmt));\n\t\t\tXQueryParser parser = new XQueryParser(lexer);\n\t\t\tXQueryTreeParser treeParser = new XQueryTreeParser(context);\n\t\t\tparser.xpath();\n\t\t\tif (parser.foundErrors()) {\n\t\t\t\tthrow new RuntimeException(parser.getErrorMessage());\n\t\t\t}\n\n\t\t\tAST ast = parser.getAST();\n\n\t\t\tPathExpr expr = new PathExpr(context);\n\t\t\ttreeParser.xpath(ast, expr);\n\t\t\tif (treeParser.foundErrors()) {\n\t\t\t\tthrow new RuntimeException(treeParser.getErrorMessage());\n\t\t\t}\n\t\t\tlong start = System.currentTimeMillis();\n\n\t\t\tSequence resultSeq = expr.eval(null, null);\n\t\t\tif (!Type.subTypeOf(resultSeq.getItemType(), Type.NODE))\n\t\t\t\tthrow new EXistException(\"select expression should evaluate to a node-set; got \" +\n\t\t\t\t        Type.getTypeName(resultSeq.getItemType()));\n\t\t\tLOG.debug(\"found \" + resultSeq.getLength() + \" for select: \" + selectStmt);\n\t\t\treturn (NodeList)resultSeq.toNodeSet();\n\t\t} catch (RecognitionException e) {\n\t\t\tLOG.warn(\"error while parsing select expression\", e);\n\t\t\tthrow new EXistException(e);\n\t\t} catch (TokenStreamException e) {\n\t\t\tLOG.warn(\"error while parsing select expression\", e);\n\t\t\tthrow new EXistException(e);\n\t\t}\n\t}","commit_id":"dac0b61ac234ca2d99b48213e5da9d7752d26463","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Release all acquired document locks.\n\t */\n\tprotected void unlockDocuments() {\n\t    lockedDocuments.unlock(true);\n\t}","id":86099,"modified_method":"/**\n\t * Release all acquired document locks.\n\t */\n\tprotected void unlockDocuments() {\n\t    if(lockedDocuments == null)\n\t        return;\n\t    lockedDocuments.unlock(true);\n\t}","commit_id":"dac0b61ac234ca2d99b48213e5da9d7752d26463","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @see org.exist.xupdate.Modification#process(org.exist.dom.DocumentSet)\n     */\n    public long process() throws PermissionDeniedException, LockException,\n            EXistException, XPathException {\n        try {\n            NodeImpl[] ql = selectAndLock();\n            IndexListener listener = new IndexListener(ql);\n            NodeImpl node;\n            Node parent;\n            DocumentImpl doc = null;\n            Collection collection = null, prevCollection = null;\n            for (int i = 0; i < ql.length; i++) {\n                node = ql[i];\n                doc = (DocumentImpl) node.getOwnerDocument();\n                if (!doc.getPermissions().validate(broker.getUser(),\n                        Permission.UPDATE))\n                        throw new PermissionDeniedException(\n                                \"permission to remove document denied\");\n                collection = doc.getCollection();\n                if (prevCollection != null && collection != prevCollection)\n                        doc.getBroker().saveCollection(prevCollection);\n                doc.setIndexListener(listener);\n                parent = node.getParentNode();\n                if (parent.getNodeType() != Node.ELEMENT_NODE) {\n                    throw new EXistException(\n                            \"you cannot remove the document element. Use update \"\n                                    + \"instead\");\n                } else\n                    parent.removeChild(node);\n                doc.clearIndexListener();\n                doc.setLastModified(System.currentTimeMillis());\n                prevCollection = collection;\n            }\n            if (doc != null) doc.getBroker().saveCollection(collection);\n            return ql.length;\n        } finally {\n            unlockDocuments();\n        }\n    }","id":86100,"modified_method":"/**\n     * @see org.exist.xupdate.Modification#process(org.exist.dom.DocumentSet)\n     */\n    public long process() throws PermissionDeniedException, LockException,\n            EXistException, XPathException {\n        try {\n            NodeImpl[] ql = selectAndLock();\n            IndexListener listener = new IndexListener(ql);\n            NodeImpl node;\n            Node parent;\n            DocumentImpl doc = null;\n            Collection collection = null, prevCollection = null;\n            for (int i = 0; i < ql.length; i++) {\n                node = ql[i];\n                doc = (DocumentImpl) node.getOwnerDocument();\n                if (!doc.getPermissions().validate(broker.getUser(),\n                        Permission.UPDATE))\n                        throw new PermissionDeniedException(\n                                \"permission to remove document denied\");\n                collection = doc.getCollection();\n                if (prevCollection != null && collection != prevCollection)\n                        doc.getBroker().saveCollection(prevCollection);\n                doc.setIndexListener(listener);\n                parent = node.getParentNode();\n                if (parent.getNodeType() != Node.ELEMENT_NODE) {\n                    LOG.debug(\"parent = \" + parent.getNodeType() + \"; \" + parent.getNodeName());\n                    throw new EXistException(\n                            \"you cannot remove the document element. Use update \"\n                                    + \"instead\");\n                } else\n                    parent.removeChild(node);\n                doc.clearIndexListener();\n                doc.setLastModified(System.currentTimeMillis());\n                prevCollection = collection;\n            }\n            if (doc != null) doc.getBroker().saveCollection(collection);\n            return ql.length;\n        } finally {\n            unlockDocuments();\n        }\n    }","commit_id":"dac0b61ac234ca2d99b48213e5da9d7752d26463","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * This implementation tries to process the \"where\" clause in advance, i.e. in one single\n\t * step. This is possible if the input sequence is a node set and the where expression\n\t * has no dependencies on other variables than those declared in this \"for\" statement.\n\t * \n\t * @see org.exist.xquery.Expression#eval(org.exist.xquery.StaticContext, org.exist.dom.DocumentSet, org.exist.xquery.value.Sequence, org.exist.xquery.value.Item)\n\t */\n\tpublic Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem,\n\t\tSequence resultSequence)\n\t\tthrows XPathException {\n\t\t// Save the local variable stack\n\t\tLocalVariable mark = context.markLocalVariables(false);\n\t\t\n\t\t// Evaluate the \"in\" expression\n\t\tSequence in = inputSequence.eval(null, null);\n\t\tclearContext(in);\n        \n\t\t// Declare the iteration variable\n\t\tLocalVariable var = new LocalVariable(QName.parse(context, varName, null));\n        var.setSequenceType(sequenceType);\n\t\tcontext.declareVariable(var);\n\t\t\n\t\t// Declare positional variable\n\t\tLocalVariable at = null;\n\t\tif(positionalVariable != null) {\n\t\t\tat = new LocalVariable(QName.parse(context, positionalVariable, null));\n            at.setSequenceType(POSITIONAL_VAR_TYPE);\n\t\t\tcontext.declareVariable(at);\n\t\t}\n\t\t\n\t\t// Assign the whole input sequence to the bound variable.\n\t\t// This is required if we process the \"where\" or \"order by\" clause\n\t\t// in one step.\n\t\tvar.setValue(in);\n\t\t\n\t\t// Save the current context document set to the variable as a hint\n\t\t// for path expressions occurring in the \"return\" clause.\n\t\tif(in instanceof NodeSet) {\n\t\t    DocumentSet contextDocs = ((NodeSet)in).getDocumentSet();\n\t\t    var.setContextDocs(contextDocs);\n\t\t}\n\n\t\t// Check if we can speed up the processing of the \"order by\" clause.\n\t\tboolean fastOrderBy = false; // checkOrderSpecs(in);\n\t\t\n\t\t// See if we can process the \"where\" clause in a single step (instead of\n\t\t// calling the where expression for each item in the input sequence)\n\t\t// This is possible if the input sequence is a node set and has no\n\t\t// dependencies on the current context item.\n\t\tboolean fastExec = whereExpr != null &&\n\t\t\t( whereExpr.getDependencies() & Dependency.CONTEXT_ITEM ) == 0 &&\n\t\t\tat == null &&\n\t\t\tin.getItemType() == Type.NODE;\n\t\t\n\t\t// If possible, apply the where expression ahead of the iteration\n\t\tif(fastExec) {\n\t\t\tif(!in.isCached())\n\t\t\t\tsetContext(in);\n\t\t\tin = applyWhereExpression(in);\n\t\t\tif(!in.isCached())\n\t\t\t\tclearContext(in);\n\t\t}\n\t\t\n\t\t// PreorderedValueSequence applies the order specs to all items\n\t\t// in one single processing step\n\t\tif(fastOrderBy) {\n\t\t\tin = new PreorderedValueSequence(orderSpecs, in);\n\t\t}\n\t\t\n\t\t// Otherwise, if there's an order by clause, wrap the result into\n\t\t// an OrderedValueSequence. OrderedValueSequence will compute\n\t\t// order expressions for every item when it is added to the result sequence.\n\t\tif(resultSequence == null) {\n\t\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t\tresultSequence = \n\t\t\t\t\tnew OrderedValueSequence(orderSpecs, in.getLength());\n\t\t\telse\n\t\t\t\tresultSequence = new ValueSequence();\n\t\t}\n\t\t\t\n\t\tSequence val = null;\n\t\tint p = 1;\n\t\tIntegerValue atVal = new IntegerValue(1);\n\t\tif(positionalVariable != null)\n\t\t\tat.setValue(atVal);\n\t\t\n\t\t// Loop through each variable binding\n\t\tfor (SequenceIterator i = in.iterate(); i.hasNext(); p++) {\n\t\t    context.proceed(this);\n\t\t\tcontextItem = i.nextItem();\n\t\t\tcontext.setContextPosition(p);\n\t\t\t\n//\t\t\tatVal.setValue(p); // seb: this does not create a new Value. the old Value is referenced from results\n\t\t\tif(positionalVariable != null)\n\t\t\t\tat.setValue(new IntegerValue(p));\n\t\t\t \n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\t\t// set variable value to current item\n\t\t\tvar.setValue(contextSequence);\n            var.checkType();\n\t\t\tval = contextSequence;\n\t\t\t\n\t\t\t// check optional where clause\n\t\t\tif (whereExpr != null && (!fastExec)) {\n\t\t\t\tif(contextItem instanceof NodeProxy)\n\t\t\t\t\t((NodeProxy)contextItem).addContextNode((NodeProxy)contextItem);\n\t\t\t\tSequence bool = applyWhereExpression(null);\n\t\t\t\tif(contextItem instanceof NodeProxy)\n\t\t\t\t\t((NodeProxy)contextItem).clearContext();\n\t\t\t\t// if where returned false, continue\n\t\t\t\tif(!bool.effectiveBooleanValue())\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tval = contextItem.toSequence();\n\t\t\t\n\t\t\t/* if the returnExpr is another BindingExpression, call it\n\t\t\t * with the result sequence.\n\t\t\t */\n\t\t\tif(returnExpr instanceof BindingExpression)\n\t\t\t\t((BindingExpression)returnExpr).eval(null, null, resultSequence);\n\t\t\t\n\t\t\t// otherwise call the return expression and add results to resultSequence\n\t\t\telse {\n\t\t\t\tval = returnExpr.eval(null);\n\t\t\t\tresultSequence.addAll(val);\n\t\t\t}\n\t\t}\n\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t((OrderedValueSequence)resultSequence).sort();\n\t\t\n\t\t// restore the local variable stack\n\t\tcontext.popLocalVariables(mark);\n\t\treturn resultSequence;\n\t}","id":86101,"modified_method":"/**\n\t * This implementation tries to process the \"where\" clause in advance, i.e. in one single\n\t * step. This is possible if the input sequence is a node set and the where expression\n\t * has no dependencies on other variables than those declared in this \"for\" statement.\n\t * \n\t * @see org.exist.xquery.Expression#eval(org.exist.xquery.StaticContext, org.exist.dom.DocumentSet, org.exist.xquery.value.Sequence, org.exist.xquery.value.Item)\n\t */\n\tpublic Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem,\n\t\tSequence resultSequence)\n\t\tthrows XPathException {\n\t\t// Save the local variable stack\n\t\tLocalVariable mark = context.markLocalVariables(false);\n\t\t\n\t\t// Evaluate the \"in\" expression\n\t\tSequence in = inputSequence.eval(null, null);\n\t\tclearContext(in);\n        \n\t\t// Declare the iteration variable\n\t\tLocalVariable var = new LocalVariable(QName.parse(context, varName, null));\n        var.setSequenceType(sequenceType);\n\t\tcontext.declareVariable(var);\n\t\t\n\t\t// Declare positional variable\n\t\tLocalVariable at = null;\n\t\tif(positionalVariable != null) {\n\t\t\tat = new LocalVariable(QName.parse(context, positionalVariable, null));\n            at.setSequenceType(POSITIONAL_VAR_TYPE);\n\t\t\tcontext.declareVariable(at);\n\t\t}\n\t\t\n\t\t// Assign the whole input sequence to the bound variable.\n\t\t// This is required if we process the \"where\" or \"order by\" clause\n\t\t// in one step.\n\t\tvar.setValue(in);\n\t\t\n\t\t// Save the current context document set to the variable as a hint\n\t\t// for path expressions occurring in the \"return\" clause.\n\t\tif(in instanceof NodeSet) {\n\t\t    DocumentSet contextDocs = ((NodeSet)in).getDocumentSet();\n\t\t    var.setContextDocs(contextDocs);\n\t\t}\n\n\t\t// Check if we can speed up the processing of the \"order by\" clause.\n\t\tboolean fastOrderBy = false; // checkOrderSpecs(in);\n\t\t\n\t\t// See if we can process the \"where\" clause in a single step (instead of\n\t\t// calling the where expression for each item in the input sequence)\n\t\t// This is possible if the input sequence is a node set and has no\n\t\t// dependencies on the current context item.\n\t\tboolean fastExec = whereExpr != null &&\n\t\t\t( whereExpr.getDependencies() & Dependency.CONTEXT_ITEM ) == 0 &&\n\t\t\tat == null &&\n\t\t\tType.subTypeOf( in.getItemType() , Type.NODE);\n\t\t\n\t\t// If possible, apply the where expression ahead of the iteration\n\t\tif(fastExec) {\n\t\t\tif(!in.isCached())\n\t\t\t\tsetContext(in);\n\t\t\tin = applyWhereExpression(in);\n\t\t\tif(!in.isCached())\n\t\t\t\tclearContext(in);\n\t\t}\n\t\t\n\t\t// PreorderedValueSequence applies the order specs to all items\n\t\t// in one single processing step\n\t\tif(fastOrderBy) {\n\t\t\tin = new PreorderedValueSequence(orderSpecs, in);\n\t\t}\n\t\t\n\t\t// Otherwise, if there's an order by clause, wrap the result into\n\t\t// an OrderedValueSequence. OrderedValueSequence will compute\n\t\t// order expressions for every item when it is added to the result sequence.\n\t\tif(resultSequence == null) {\n\t\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t\tresultSequence = \n\t\t\t\t\tnew OrderedValueSequence(orderSpecs, in.getLength());\n\t\t\telse\n\t\t\t\tresultSequence = new ValueSequence();\n\t\t}\n\t\t\t\n\t\tSequence val = null;\n\t\tint p = 1;\n\t\tIntegerValue atVal = new IntegerValue(1);\n\t\tif(positionalVariable != null)\n\t\t\tat.setValue(atVal);\n\t\t\n\t\t// Loop through each variable binding\n\t\tfor (SequenceIterator i = in.iterate(); i.hasNext(); p++) {\n\t\t    context.proceed(this);\n\t\t\tcontextItem = i.nextItem();\n\t\t\tcontext.setContextPosition(p);\n\t\t\t\n//\t\t\tatVal.setValue(p); // seb: this does not create a new Value. the old Value is referenced from results\n\t\t\tif(positionalVariable != null)\n\t\t\t\tat.setValue(new IntegerValue(p));\n\t\t\t \n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\t\t// set variable value to current item\n\t\t\tvar.setValue(contextSequence);\n            var.checkType();\n\t\t\tval = contextSequence;\n\t\t\t\n\t\t\t// check optional where clause\n\t\t\tif (whereExpr != null && (!fastExec)) {\n\t\t\t\tif(contextItem instanceof NodeProxy)\n\t\t\t\t\t((NodeProxy)contextItem).addContextNode((NodeProxy)contextItem);\n\t\t\t\tSequence bool = applyWhereExpression(null);\n\t\t\t\tif(contextItem instanceof NodeProxy)\n\t\t\t\t\t((NodeProxy)contextItem).clearContext();\n\t\t\t\t// if where returned false, continue\n\t\t\t\tif(!bool.effectiveBooleanValue())\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tval = contextItem.toSequence();\n\t\t\t\n\t\t\t/* if the returnExpr is another BindingExpression, call it\n\t\t\t * with the result sequence.\n\t\t\t */\n\t\t\tif(returnExpr instanceof BindingExpression)\n\t\t\t\t((BindingExpression)returnExpr).eval(null, null, resultSequence);\n\t\t\t\n\t\t\t// otherwise call the return expression and add results to resultSequence\n\t\t\telse {\n\t\t\t\tval = returnExpr.eval(null);\n\t\t\t\tresultSequence.addAll(val);\n\t\t\t}\n\t\t}\n\t\tif(orderSpecs != null && !fastOrderBy)\n\t\t\t((OrderedValueSequence)resultSequence).sort();\n\t\t\n\t\t// restore the local variable stack\n\t\tcontext.popLocalVariables(mark);\n\t\treturn resultSequence;\n\t}","commit_id":"8d59c2265f9f9c657df90577535b6fef65c14b00","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\tif (contextSequence.getItemType() != Type.NODE)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tString lang =\n\t\t\tgetArgument(0)\n\t\t\t\t.eval(contextSequence)\n\t\t\t\t.getStringValue();\n\t\tQName qname = new QName(\"lang\", context.getURIForPrefix(\"xml\"), \"xml\");\n\t\tNodeSet attribs = context.getBroker().getElementIndex().getAttributesByName(contextSequence.toNodeSet().getDocumentSet(), qname, null);\n\t\tNodeSet temp = new ExtArrayNodeSet();\n\t\tNodeProxy p;\n\t\tString langValue;\n\t\tint hyphen;\n\t\tboolean include;\n\t\tfor (Iterator i = attribs.iterator(); i.hasNext();) {\n\t\t\tinclude = false;\n\t\t\tp = (NodeProxy) i.next();\n\t\t\tlangValue = p.getNodeValue();\n\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n\t\t\tif (!include) {\n\t\t\t\thyphen = langValue.indexOf('-');\n\t\t\t\tif (hyphen != -1) {\n\t\t\t\t\tlangValue = langValue.substring(0, hyphen);\n\t\t\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (include) {\n\t\t\t\tp.gid = XMLUtil.getParentId(p.getDocument(), p.gid);\n\t\t\t\tif (p.gid > -1) {\n\t\t\t\t\tp.setNodeType(Node.ELEMENT_NODE);\n\t\t\t\t\ttemp.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (temp.getLength() > 0) {\n\t\t\tNodeSet result =\n\t\t\t\t((NodeSet) contextSequence).selectAncestorDescendant(\n\t\t\t\t\ttemp,\n\t\t\t\t\tNodeSet.DESCENDANT,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse);\n\t\t\tfor (Iterator i = result.iterator(); i.hasNext();) {\n\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\tp.addContextNode(p);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","id":86102,"modified_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\tif (!(Type.subTypeOf(contextSequence.getItemType(), Type.NODE)))\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tString lang =\n\t\t\tgetArgument(0)\n\t\t\t\t.eval(contextSequence)\n\t\t\t\t.getStringValue();\n\t\tQName qname = new QName(\"lang\", context.getURIForPrefix(\"xml\"), \"xml\");\n\t\tNodeSet attribs = context.getBroker().getElementIndex().getAttributesByName(contextSequence.toNodeSet().getDocumentSet(), qname, null);\n\t\tNodeSet temp = new ExtArrayNodeSet();\n\t\tNodeProxy p;\n\t\tString langValue;\n\t\tint hyphen;\n\t\tboolean include;\n\t\tfor (Iterator i = attribs.iterator(); i.hasNext();) {\n\t\t\tinclude = false;\n\t\t\tp = (NodeProxy) i.next();\n\t\t\tlangValue = p.getNodeValue();\n\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n\t\t\tif (!include) {\n\t\t\t\thyphen = langValue.indexOf('-');\n\t\t\t\tif (hyphen != -1) {\n\t\t\t\t\tlangValue = langValue.substring(0, hyphen);\n\t\t\t\t\tinclude = lang.equalsIgnoreCase(langValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (include) {\n\t\t\t\tp.gid = XMLUtil.getParentId(p.getDocument(), p.gid);\n\t\t\t\tif (p.gid > -1) {\n\t\t\t\t\tp.setNodeType(Node.ELEMENT_NODE);\n\t\t\t\t\ttemp.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (temp.getLength() > 0) {\n\t\t\tNodeSet result =\n\t\t\t\t((NodeSet) contextSequence).selectAncestorDescendant(\n\t\t\t\t\ttemp,\n\t\t\t\t\tNodeSet.DESCENDANT,\n\t\t\t\t\ttrue,\n\t\t\t\t\tfalse);\n\t\t\tfor (Iterator i = result.iterator(); i.hasNext();) {\n\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\tp.addContextNode(p);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn Sequence.EMPTY_SEQUENCE;\n\t}","commit_id":"7f190f4adae8912b7f273935ac3fb8723ca14d97","url":"https://github.com/eXist-db/exist"},{"original_method":"public String[] retrieveByDocument(\n\t\tString sessionId,\n\t\tint start,\n\t\tint howmany,\n\t\tString docPath,\n\t\tboolean indent,\n\t\tboolean xinclude,\n\t\tString highlight)\n\t\tthrows RemoteException {\n\t\tSession session = getSession(sessionId);\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(session.getUser());\n\t\t\tSequence qr = (Sequence) session.getQueryResult().result;\n\t\t\tif (qr == null)\n\t\t\t\tthrow new RemoteException(\"result set unknown or timed out\");\n\t\t\tString xml[] = null;\n\t\t\tswitch (qr.getItemType()) {\n\t\t\t\tcase Type.NODE :\n\t\t\t\t\tNodeList resultSet = (NodeSet)qr;\n\t\t\t\t\tArraySet hitsByDoc = new ArraySet(50);\n\t\t\t\t\tNodeProxy p;\n\t\t\t\t\tString path;\n\t\t\t\t\tfor (Iterator i = ((NodeSet) resultSet).iterator(); i.hasNext();) {\n\t\t\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\t\t\tpath = p.getDocument().getCollection().getName() + '/' + p.getDocument().getFileName();\n\t\t\t\t\t\tif (path.equals(docPath))\n\t\t\t\t\t\t\thitsByDoc.add(p);\n\t\t\t\t\t}\n\t\t\t\t\t--start;\n\t\t\t\t\tif (start < 0 || start > hitsByDoc.getLength())\n\t\t\t\t\t\tthrow new RemoteException(\n\t\t\t\t\t\t\t\"index \" + start + \"out of bounds (\" + hitsByDoc.getLength() + \")\");\n\t\t\t\t\tif (start + howmany >= hitsByDoc.getLength())\n\t\t\t\t\t\thowmany = hitsByDoc.getLength() - start;\n\t\t\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\t\t\tserializer.reset();\n\t\t\t\t\tserializer.setProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n\t\t\t\t\tserializer.setProperty(EXistOutputKeys.EXPAND_XINCLUDES, xinclude ? \"yes\" : \"no\");\n\t\t\t\t\tserializer.setProperty(EXistOutputKeys.HIGHLIGHT_MATCHES, highlight);\n\n\t\t\t\t\txml = new String[howmany];\n\t\t\t\t\tfor (int i = 0; i < howmany; i++) {\n\t\t\t\t\t\tNodeProxy proxy = ((NodeSet) hitsByDoc).get(start);\n\t\t\t\t\t\tif (proxy == null)\n\t\t\t\t\t\t\tthrow new RuntimeException(\"not found: \" + start);\n\t\t\t\t\t\txml[i] = serializer.serialize(proxy);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tthrow new RemoteException(\"result set is not a node list\");\n\t\t\t}\n\t\t\treturn xml;\n\t\t} catch (Exception e) {\n\t\t\tLOG.warn(e);\n\t\t\te.printStackTrace();\n\t\t\tthrow new RemoteException(e.getMessage(), e);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","id":86103,"modified_method":"public String[] retrieveByDocument(\n\t\tString sessionId,\n\t\tint start,\n\t\tint howmany,\n\t\tString docPath,\n\t\tboolean indent,\n\t\tboolean xinclude,\n\t\tString highlight)\n\t\tthrows RemoteException {\n\t\tSession session = getSession(sessionId);\n\t\tDBBroker broker = null;\n\t\ttry {\n\t\t\tbroker = pool.get(session.getUser());\n\t\t\tSequence qr = (Sequence) session.getQueryResult().result;\n\t\t\tif (qr == null)\n\t\t\t\tthrow new RemoteException(\"result set unknown or timed out\");\n\t\t\tString xml[] = null;\n\t\t\tif (Type.subTypeOf(qr.getItemType(), Type.NODE)) {\n\t\t\t\tNodeList resultSet = (NodeSet)qr;\n\t\t\t\tArraySet hitsByDoc = new ArraySet(50);\n\t\t\t\tNodeProxy p;\n\t\t\t\tString path;\n\t\t\t\tfor (Iterator i = ((NodeSet) resultSet).iterator(); i.hasNext();) {\n\t\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\t\tpath = p.getDocument().getCollection().getName() + '/' + p.getDocument().getFileName();\n\t\t\t\t\tif (path.equals(docPath))\n\t\t\t\t\t\thitsByDoc.add(p);\n\t\t\t\t}\n\t\t\t\t--start;\n\t\t\t\tif (start < 0 || start > hitsByDoc.getLength())\n\t\t\t\t\tthrow new RemoteException(\n\t\t\t\t\t\t\"index \" + start + \"out of bounds (\" + hitsByDoc.getLength() + \")\");\n\t\t\t\tif (start + howmany >= hitsByDoc.getLength())\n\t\t\t\t\thowmany = hitsByDoc.getLength() - start;\n\t\t\t\tSerializer serializer = broker.getSerializer();\n\t\t\t\tserializer.reset();\n\t\t\t\tserializer.setProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n\t\t\t\tserializer.setProperty(EXistOutputKeys.EXPAND_XINCLUDES, xinclude ? \"yes\" : \"no\");\n\t\t\t\tserializer.setProperty(EXistOutputKeys.HIGHLIGHT_MATCHES, highlight);\n\n\t\t\t\txml = new String[howmany];\n\t\t\t\tfor (int i = 0; i < howmany; i++) {\n\t\t\t\t\tNodeProxy proxy = ((NodeSet) hitsByDoc).get(start);\n\t\t\t\t\tif (proxy == null)\n\t\t\t\t\t\tthrow new RuntimeException(\"not found: \" + start);\n\t\t\t\t\txml[i] = serializer.serialize(proxy);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow new RemoteException(\"result set is not a node list\");\n\t\t\treturn xml;\n\t\t} catch (Exception e) {\n\t\t\tLOG.warn(e);\n\t\t\te.printStackTrace();\n\t\t\tthrow new RemoteException(e.getMessage(), e);\n\t\t} finally {\n\t\t\tpool.release(broker);\n\t\t}\n\t}","commit_id":"7f190f4adae8912b7f273935ac3fb8723ca14d97","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testFor() {\n\t\tResourceSet result;\n\t\tString query;\n\t\tXMLResource resu;\n\t\ttry {\n\t\t\tXPathQueryService service = \n\t\t\t\tstoreXMLStringAndGetQueryService(NUMBERS_XML, numbers);\n\n\t\t\tSystem.out.println(\"testFor 1: ========\" );\n\t\t\tquery = \"for $f in /*/item return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tassertEquals( \"XQuery: \" + query, 4, result.getSize() );\n\n\t\t\tSystem.out.println(\"testFor 2: ========\" );\n\t\t\tquery = \"for $f in /*/item  order by $f ascending  return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"3\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\n\n\t\t\tSystem.out.println(\"testFor 3: ========\" );\n\t\t\tquery = \"for $f in /*/item  order by $f descending  return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"2\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\n\n\t\t\tSystem.out.println(\"testFor 4: ========\" );\n\t\t\tquery = \"for $f in /*/item  order by xs:double($f/price) descending  return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"4\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\n\t\t} catch (XMLDBException e) {\n\t\t\tSystem.out.println(\"testFor(): XMLDBException: \"+e);\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}","id":86104,"modified_method":"public void testFor() {\n\t\tResourceSet result;\n\t\tString query;\n\t\tXMLResource resu;\n\t\ttry {\n\t\t\tXPathQueryService service = \n\t\t\t\tstoreXMLStringAndGetQueryService(NUMBERS_XML, numbers);\n\n\t\t\tSystem.out.println(\"testFor 1: ========\" );\n\t\t\tquery = \"for $f in /*/item return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tassertEquals( \"XQuery: \" + query, 4, result.getSize() );\n\n\t\t\tSystem.out.println(\"testFor 2: ========\" );\n\t\t\tquery = \"for $f in /*/item  order by $f ascending  return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"3\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\n\n\t\t\tSystem.out.println(\"testFor 3: ========\" );\n\t\t\tquery = \"for $f in /*/item  order by $f descending  return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"2\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\n\n\t\t\tSystem.out.println(\"testFor 4: ========\" );\n\t\t\tquery = \"for $f in /*/item  order by xs:double($f/price) descending  return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"4\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\n\t\t\t\n\t\t\tSystem.out.println(\"testFor 5: ========\" );\n\t\t\tquery = \"for $f in //item where $f/@id = '3' return $f\";\n\t\t\tresult = service.queryResource(NUMBERS_XML, query );\n\t\t\tprintResult(result);\n\t\t\tresu = (XMLResource) result.getResource(0);\n\t\t\tassertEquals( \"XQuery: \" + query, \"3\", ((Element)resu.getContentAsDOM()).getAttribute(\"id\") );\t\n\t\t\t\n\t\t} catch (XMLDBException e) {\n\t\t\tSystem.out.println(\"testFor(): XMLDBException: \"+e);\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}","commit_id":"7f190f4adae8912b7f273935ac3fb8723ca14d97","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n  public RuleMatch[] match(final AnalyzedSentence sentence) {\n    final List<RuleMatch> ruleMatches = new ArrayList<>();\n    final AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();\n    AnalyzedTokenReadings prevToken = null;\n    for (int i = 1; i < tokens.length; i++) {  // ignoring token 0, i.e., SENT_START\n      AnalyzedTokenReadings token = tokens[i];\n      String prevTokenStr = prevToken != null ? prevToken.getToken() : null;\n      if (\"a\".equalsIgnoreCase(prevTokenStr) || \"an\".equalsIgnoreCase(prevTokenStr)) {\n        Determiner determiner = getCorrectDeterminerFor(token);\n        if (prevTokenStr != null) {\n          String msg = null;\n          if (\"a\".equalsIgnoreCase(prevTokenStr) && determiner == Determiner.AN) {\n            String replacement = StringTools.startsWithUppercase(prevTokenStr) ? \"An\" : \"an\";\n            msg = \"Use <suggestion>\" + replacement + \"<\/suggestion> instead of '\" + prevTokenStr + \"' if the following \"+\n                    \"word starts with a vowel sound, e.g. 'an article', 'an hour'\";\n          } else if (\"an\".equalsIgnoreCase(prevTokenStr) && determiner == Determiner.A) {\n            String replacement = StringTools.startsWithUppercase(prevTokenStr) ? \"A\" : \"a\";\n            msg = \"Use <suggestion>\" + replacement + \"<\/suggestion> instead of '\" + prevTokenStr + \"' if the following \"+\n                    \"word doesn't start with a vowel sound, e.g. 'a sentence', 'a university'\";\n          }\n          if (msg != null) {\n            RuleMatch match = new RuleMatch(this, prevToken.getStartPos(), prevToken.getEndPos(), msg, \"Wrong article\");\n            ruleMatches.add(match);\n          }\n        }\n      }\n      if (token.hasPosTag(\"DT\")) {\n        prevToken = token;\n      } else if (token.getToken().matches(\"[-\\\"()\\\\[\\\\]]+\")) {\n        // skip e.g. the quote in >>an \"industry party\"<<\n      } else {\n        prevToken = null;\n      }\n    }\n    return toRuleMatchArray(ruleMatches);\n  }","id":86105,"modified_method":"@Override\n  public RuleMatch[] match(final AnalyzedSentence sentence) {\n    final List<RuleMatch> ruleMatches = new ArrayList<>();\n    final AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();\n    int prevTokenIndex = 0;\n    for (int i = 1; i < tokens.length; i++) {  // ignoring token 0, i.e., SENT_START\n      AnalyzedTokenReadings token = tokens[i];\n      String prevTokenStr = prevTokenIndex > 0 ? tokens[prevTokenIndex].getToken() : null;\n\n      boolean isSentenceStart = prevTokenIndex == 1;\n      boolean equalsA = \"a\".equalsIgnoreCase(prevTokenStr);\n      boolean equalsAn = \"an\".equalsIgnoreCase(prevTokenStr);\n\n      if (!isSentenceStart) {\n          equalsA = \"a\".equals(prevTokenStr);\n          equalsAn = \"an\".equals(prevTokenStr);\n      }\n\n      if (equalsA || equalsAn) {\n        Determiner determiner = getCorrectDeterminerFor(token);\n        String msg = null;\n        if (equalsA && determiner == Determiner.AN) {\n          String replacement = StringTools.startsWithUppercase(prevTokenStr) ? \"An\" : \"an\";\n          msg = \"Use <suggestion>\" + replacement + \"<\/suggestion> instead of '\" + prevTokenStr + \"' if the following \"+\n                  \"word starts with a vowel sound, e.g. 'an article', 'an hour'\";\n        } else if (equalsAn && determiner == Determiner.A) {\n          String replacement = StringTools.startsWithUppercase(prevTokenStr) ? \"A\" : \"a\";\n          msg = \"Use <suggestion>\" + replacement + \"<\/suggestion> instead of '\" + prevTokenStr + \"' if the following \"+\n                  \"word doesn't start with a vowel sound, e.g. 'a sentence', 'a university'\";\n        }\n        if (msg != null) {\n          RuleMatch match = new RuleMatch(\n              this, tokens[prevTokenIndex].getStartPos(), tokens[prevTokenIndex].getEndPos(), msg, \"Wrong article\");\n          ruleMatches.add(match);\n        }\n      }\n      if (token.hasPosTag(\"DT\")) {\n        prevTokenIndex = i;\n      } else if (token.getToken().matches(\"[-\\\"()\\\\[\\\\]]+\")) {\n        // skip e.g. the quote in >>an \"industry party\"<<\n      } else {\n        prevTokenIndex = 0;\n      }\n    }\n    return toRuleMatchArray(ruleMatches);\n  }","commit_id":"eab412ac2eca208ec0685523d41c2a0ae3cd9c52","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testRule() throws IOException {\n\n    // correct sentences:\n    assertCorrect(\"This is a test sentence.\");\n    assertCorrect(\"It was an hour ago.\");\n    assertCorrect(\"A university is ...\");\n    assertCorrect(\"A one-way street ...\");\n    assertCorrect(\"An hour's work ...\");\n    assertCorrect(\"Going to an \\\"industry party\\\".\");\n    assertCorrect(\"An 8-year old boy ...\");\n    assertCorrect(\"An 18-year old boy ...\");\n    assertCorrect(\"The A-levels are ...\");\n    assertCorrect(\"An NOP check ...\");\n    assertCorrect(\"A USA-wide license ...\");\n    assertCorrect(\"...asked a UN member.\");\n    assertCorrect(\"In an un-united Germany...\");\n    //fixed false alarms:\n    assertCorrect(\"Here, a and b are supplementary angles.\");\n    assertCorrect(\"The Qur'an was translated into Polish.\");\n    assertCorrect(\"See an:Grammatica\");\n    assertCorrect(\"See http://www.an.com\");\n\n    // errors:\n    assertIncorrect(\"It was a hour ago.\");\n    assertIncorrect(\"It was an sentence that's long.\");\n    assertIncorrect(\"It was a uninteresting talk.\");\n    assertIncorrect(\"An university\");\n    assertIncorrect(\"A unintersting ...\");\n    assertIncorrect(\"A hour's work ...\");\n    assertIncorrect(\"Going to a \\\"industry party\\\".\");\n    final RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\"It was a uninteresting talk with an long sentence.\"));\n    assertEquals(2, matches.length);\n\n    // With uppercase letters:\n    assertCorrect(\"A University\");\n    assertCorrect(\"A Europe wide something\");\n\n    assertIncorrect(\"then an University sdoj fixme sdoopsd\");\n    assertIncorrect(\"A 8-year old boy ...\");\n    assertIncorrect(\"A 18-year old boy ...\");\n    assertIncorrect(\"...asked an UN member.\");\n    assertIncorrect(\"In a un-united Germany...\");\n\n    //Test on acronyms/initials:\n    assertCorrect(\"A. R.J. Turgot\");\n\n    //mixed case as dictionary-based exception\n    assertCorrect(\"Anyone for an MSc?\");\n    assertIncorrect(\"Anyone for a MSc?\");\n    //mixed case from general case\n    assertCorrect(\"Anyone for an XMR-based writer?\");\n\n    //Test on apostrophes\n    assertCorrect(\"Its name in English is a[1] (), plural A's, As, as, or a's.\");\n\n    // Both are correct according to Merriam Webster (http://www.merriam-webster.com/dictionary/a%5B2%5D),\n    // although some people disagree (http://www.theslot.com/a-an.html):\n    assertCorrect(\"An historic event\");\n    assertCorrect(\"A historic event\");\n  }","id":86106,"modified_method":"public void testRule() throws IOException {\n\n    // correct sentences:\n    assertCorrect(\"This is a test sentence.\");\n    assertCorrect(\"It was an hour ago.\");\n    assertCorrect(\"A university is ...\");\n    assertCorrect(\"A one-way street ...\");\n    assertCorrect(\"An hour's work ...\");\n    assertCorrect(\"Going to an \\\"industry party\\\".\");\n    assertCorrect(\"An 8-year old boy ...\");\n    assertCorrect(\"An 18-year old boy ...\");\n    assertCorrect(\"The A-levels are ...\");\n    assertCorrect(\"An NOP check ...\");\n    assertCorrect(\"A USA-wide license ...\");\n    assertCorrect(\"...asked a UN member.\");\n    assertCorrect(\"In an un-united Germany...\");\n    //fixed false alarms:\n    assertCorrect(\"Here, a and b are supplementary angles.\");\n    assertCorrect(\"The Qur'an was translated into Polish.\");\n    assertCorrect(\"See an:Grammatica\");\n    assertCorrect(\"See http://www.an.com\");\n    assertCorrect(\"Station A equals station B.\");\n\n    // errors:\n    assertIncorrect(\"It was a hour ago.\");\n    assertIncorrect(\"It was an sentence that's long.\");\n    assertIncorrect(\"It was a uninteresting talk.\");\n    assertIncorrect(\"An university\");\n    assertIncorrect(\"A unintersting ...\");\n    assertIncorrect(\"A hour's work ...\");\n    assertIncorrect(\"Going to a \\\"industry party\\\".\");\n    final RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\"It was a uninteresting talk with an long sentence.\"));\n    assertEquals(2, matches.length);\n\n    // With uppercase letters:\n    assertCorrect(\"A University\");\n    assertCorrect(\"A Europe wide something\");\n\n    assertIncorrect(\"then an University sdoj fixme sdoopsd\");\n    assertIncorrect(\"A 8-year old boy ...\");\n    assertIncorrect(\"A 18-year old boy ...\");\n    assertIncorrect(\"...asked an UN member.\");\n    assertIncorrect(\"In a un-united Germany...\");\n\n    //Test on acronyms/initials:\n    assertCorrect(\"A. R.J. Turgot\");\n\n    //mixed case as dictionary-based exception\n    assertCorrect(\"Anyone for an MSc?\");\n    assertIncorrect(\"Anyone for a MSc?\");\n    //mixed case from general case\n    assertCorrect(\"Anyone for an XMR-based writer?\");\n\n    //Test on apostrophes\n    assertCorrect(\"Its name in English is a[1] (), plural A's, As, as, or a's.\");\n\n    // Both are correct according to Merriam Webster (http://www.merriam-webster.com/dictionary/a%5B2%5D),\n    // although some people disagree (http://www.theslot.com/a-an.html):\n    assertCorrect(\"An historic event\");\n    assertCorrect(\"A historic event\");\n  }","commit_id":"eab412ac2eca208ec0685523d41c2a0ae3cd9c52","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public Object bindFromInputParams(Map<Object, Object> params) {\n    if (params != null) {\n      Object value = params.get(paramNumber);\n      Object result = toParsedTree(value);\n      if (!this.equals(result)) {\n        params.remove(paramNumber);\n      }\n      return result;\n    }\n    return this;\n  }","id":86107,"modified_method":"public Object bindFromInputParams(Map<Object, Object> params) {\n    if (params != null) {\n      Object value = params.get(paramNumber);\n      Object result = toParsedTree(value);\n      return result;\n    }\n    return this;\n  }","commit_id":"aa04842f1be3e68edcfc0460ef1791f2f9bcb8d1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Binds parameters.\r\n   */\r\n  public void bindParameters(final Map<Object, Object> iArgs) {\r\n    if (parameterItems == null || iArgs == null || iArgs.size() == 0)\r\n      return;\r\n\r\n    for (Entry<Object, Object> entry : iArgs.entrySet()) {\r\n      if (entry.getKey() instanceof Integer)\r\n        parameterItems.get(((Integer) entry.getKey())).setValue(entry.setValue(entry.getValue()));\r\n      else {\r\n        String paramName = entry.getKey().toString();\r\n        for (OSQLFilterItemParameter value : parameterItems) {\r\n          if (value.getName().equalsIgnoreCase(paramName)) {\r\n            value.setValue(entry.getValue());\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }","id":86108,"modified_method":"/**\r\n   * Binds parameters.\r\n   */\r\n  public void bindParameters(final Map<Object, Object> iArgs) {\r\n    if (parameterItems == null || iArgs == null || iArgs.size() == 0)\r\n      return;\r\n\r\n    for (int i = 0; i < parameterItems.size(); i++) {\r\n      OSQLFilterItemParameter value = parameterItems.get(i);\r\n      if (\"?\".equals(value.getName())) {\r\n        value.setValue(iArgs.get(i));\r\n      } else {\r\n        value.setValue(iArgs.get(value.getName()));\r\n      }\r\n    }\r\n  }","commit_id":"aa04842f1be3e68edcfc0460ef1791f2f9bcb8d1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/** {@inheritDoc} */\n    public void bind(final Name name, Object object) throws NamingException {\n        check(name, Action.BIND);\n\n        if(namingStore instanceof WritableNamingStore) {\n            final Name absoluteName = getAbsoluteName(name);\n            if (object instanceof Referenceable) {\n                object = ((Referenceable) object).getReference();\n            }\n            getWritableNamingStore().bind(absoluteName, object);\n        } else {\n            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();\n        }\n\n    }","id":86109,"modified_method":"/** {@inheritDoc} */\n    public void bind(final Name name, final Object object) throws NamingException {\n        check(name, Action.BIND);\n\n        if(namingStore instanceof WritableNamingStore) {\n            final Name absoluteName = getAbsoluteName(name);\n            final Object value;\n            if (object instanceof Referenceable) {\n                value = ((Referenceable) object).getReference();\n            } else {\n                value = object;\n            }\n            if (System.getSecurityManager() == null) {\n                getWritableNamingStore().bind(absoluteName, value);\n            } else {\n                // The permissions check has already happened for the binding further permissions should be allowed\n                final NamingException e = AccessController.doPrivileged(new PrivilegedAction<NamingException>() {\n                    @Override\n                    public NamingException run() {\n                        try {\n                            getWritableNamingStore().bind(absoluteName, value);\n                        } catch (NamingException e) {\n                            return e;\n                        }\n                        return null;\n                    }\n                });\n                // Check that a NamingException wasn't thrown during the bind\n                if (e != null) {\n                    throw e;\n                }\n            }\n        } else {\n            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();\n        }\n\n    }","commit_id":"2d03267e41b9acf097e0e82671d31cd68e223efe","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\r\n   * Returns grouped variables.\r\n   * @param ctx context.\r\n   * @param ir sequence to be filled.\r\n   * @throws QueryException on error. \r\n   */\r\n  private void retG(final QueryContext ctx, final ItemIter ir)\r\n      throws QueryException {\r\n    Var[] pgvars = new Var[group.gp.gv.length];\r\n    Var[] pgngvar = new Var[group.gp.ngv.length];\r\n    for(int j = 0; j <  group.gp.gv.length; j++) \r\n      pgvars[j] = ctx.vars.get(group.gp.gv[j]);\r\n    for(int j = 0; j <  group.gp.ngv.length; j++) \r\n      pgngvar[j] = ctx.vars.get(group.gp.ngv[j]);\r\n\r\n    for(int i = 0; i < group.gp.partitions.size(); i++) { // bind grouping var\r\n      final HashMap<Var, ItemList> ngvars = group.gp.items.get(i);\r\n      final GroupNode gn =  group.gp.partitions.get(i);\r\n      for(int j = 0; j < group.gp.gv.length; j++)\r\n        pgvars[j].bind(gn.its[j], ctx);\r\n\r\n      for(int j = 0; j < group.gp.gv.length; j++) {\r\n        final ItemList its = ngvars.get(group.gp.ngv[j]); \r\n        pgngvar[j].bind(\r\n            Seq.get(its.list, its.size), ctx);\r\n      }\r\n      ir.add(ctx.iter(ret));\r\n    }\r\n  }","id":86110,"modified_method":"/**\r\n   * Returns grouped variables.\r\n   * @param ctx context.\r\n   * @param ir sequence to be filled.\r\n   * @throws QueryException on error. \r\n   */\r\n  private void retG(final QueryContext ctx, final ItemIter ir)\r\n      throws QueryException {\r\n    Var[] pgvars = new Var[group.gp.gv.length];\r\n    Var[] pgngvar = new Var[group.gp.ngv.length];\r\n    for(int j = 0; j <  group.gp.gv.length; j++) \r\n      pgvars[j] = ctx.vars.get(group.gp.gv[j]);\r\n    for(int j = 0; j <  group.gp.ngv.length; j++) \r\n      pgngvar[j] = ctx.vars.get(group.gp.ngv[j]);\r\n\r\n    for(int i = 0; i < group.gp.partitions.size(); i++) { // bind grouping var\r\n      final HashMap<Var, ItemList> ngvars = group.gp.items.get(i);\r\n      final GroupNode gn =  group.gp.partitions.get(i);\r\n      for(int j = 0; j < group.gp.gv.length; j++)\r\n        pgvars[j].bind(gn.its[j], ctx);\r\n      \r\n      for(int j = 0; j < group.gp.ngv.length; j++) {\r\n        final ItemList its = ngvars.get(group.gp.ngv[j]);\r\n        if(its != null)\r\n        pgngvar[j].bind(\r\n            Seq.get(its.list, its.size), ctx);\r\n        else pgngvar[j].bind(Seq.get(null, 0), ctx);\r\n      }\r\n      ir.add(ctx.iter(ret));\r\n    }\r\n  }","commit_id":"93f38c4e52fd98aa9ce8daccad0da4e8d8d0edbf","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * Get the value from the injected context.\n     *\n     * @return The value of the named entry\n     * @throws IllegalStateException\n     */\n    public synchronized ManagedReferenceFactory getValue() throws IllegalStateException {\n        return managedReferenceFactory.getValue();\n    }","id":86111,"modified_method":"/**\n     * Get the value from the injected context.\n     *\n     * @return The value of the named entry\n     * @throws IllegalStateException\n     */\n    public ManagedReferenceFactory getValue() throws IllegalStateException {\n        return managedReferenceFactory.getValue();\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public String toString() {\n        return \"BinderService[name=\" + name + \",source=\" + source + \",deployment=\" + deploymentServiceName +\"]\";\n    }","id":86112,"modified_method":"@Override\n    public String toString() {\n        return \"BinderService[name=\" + name + \", source=\" + source + \", refcnt=\" + (refcnt != null ? refcnt.get() : \"n/a\") +\"]\";\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void acquire() {\n        refcnt.incrementAndGet();\n    }","id":86113,"modified_method":"public void acquire() {\n        if (refcnt != null) {\n            refcnt.incrementAndGet();\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Unbind the entry from the injected context.\n     *\n     * @param context The stop context\n     */\n    public synchronized void stop(StopContext context) {\n        final ServiceBasedNamingStore namingStore = namingStoreValue.getValue();\n        namingStore.remove(context.getController().getName());\n        if(deploymentServiceName != null) {\n            // remove the service name from the related deployment runtime bindings management service,\n            final Set<ServiceName> duBindingReferences = (Set<ServiceName>) controller.getServiceContainer().getService(JndiNamingDependencyProcessor.serviceName(deploymentServiceName)).getValue();\n            if(duBindingReferences != null) {\n                // the set is null if the binder service was stopped by the deployment unit undeploy\n                duBindingReferences.remove(controller.getName());\n            }\n        }\n    }","id":86114,"modified_method":"/**\n     * Unbind the entry from the injected context.\n     *\n     * @param context The stop context\n     */\n    public void stop(StopContext context) {\n        final ServiceBasedNamingStore namingStore = namingStoreValue.getValue();\n        namingStore.remove(controller.getName());\n        ROOT_LOGGER.tracef(\"Unbound resource %s into naming store %s (service name %s)\", name, namingStore, context.getController().getName());\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct new instance.\n     *\n     * @param name The JNDI name to use for binding. May be either an absolute or relative name\n     * @param source\n     * @param deploymentServiceName the service name for the related deployment unit\n     */\n    public BinderService(final String name, Object source, ServiceName deploymentServiceName) {\n        if (name.startsWith(\"java:\")) {\n            //this is an absolute reference\n            this.name = name.substring(name.indexOf('/') + 1);\n        } else {\n            this.name = name;\n        }\n        this.source = source;\n        this.deploymentServiceName = deploymentServiceName;\n    }","id":86115,"modified_method":"/**\n     * Construct new instance.\n     *\n     * @param name The JNDI name to use for binding. May be either an absolute or relative name\n     * @param source\n     * @param shared indicates if the bind may be shared among multiple deployments, if true the service tracks references indicated through acquire(), and automatically stops once all deployments unreference it through release()\n     */\n    public BinderService(final String name, Object source, boolean shared) {\n        if (name.startsWith(\"java:\")) {\n            //this is an absolute reference\n            this.name = name.substring(name.indexOf('/') + 1);\n        } else {\n            this.name = name;\n        }\n        this.source = source;\n        refcnt = shared ? new AtomicInteger(0) : null;\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Bind the entry into the injected context.\n     *\n     * @param context The start context\n     * @throws StartException If the entity can not be bound\n     */\n    public synchronized void start(StartContext context) throws StartException {\n        final ServiceBasedNamingStore namingStore = namingStoreValue.getValue();\n        ServiceController<?> controller = context.getController();\n        this.controller = controller;\n        namingStore.add(controller.getName());\n        ROOT_LOGGER.tracef(\"Bound resource %s into naming store %s (service name %s)\", name, namingStore, controller.getName());\n        if(deploymentServiceName != null) {\n            // add this controller service name to the related deployment runtime bindings management service, which if stop will release this service too, thus removing the bind\n            final Set<ServiceName> duBindingReferences = (Set<ServiceName>) controller.getServiceContainer().getService(JndiNamingDependencyProcessor.serviceName(deploymentServiceName)).getValue();\n            duBindingReferences.add(controller.getName());\n        }\n    }","id":86116,"modified_method":"/**\n     * Bind the entry into the injected context.\n     *\n     * @param context The start context\n     * @throws StartException If the entity can not be bound\n     */\n    public void start(StartContext context) throws StartException {\n        final ServiceBasedNamingStore namingStore = namingStoreValue.getValue();\n        controller = context.getController();\n        namingStore.add(controller.getName());\n        ROOT_LOGGER.tracef(\"Bound resource %s into naming store %s (service name %s)\", name, namingStore, controller.getName());\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the injector for the item to be bound.\n     *\n     * @return the injector\n     */\n    public Injector<ManagedReferenceFactory> getManagedObjectInjector() {\n        return managedReferenceFactory;\n    }","id":86117,"modified_method":"/**\n     * Get the injector for the item to be bound.\n     *\n     * @return the injector\n     */\n    public InjectedValue<ManagedReferenceFactory> getManagedObjectInjector() {\n        return managedReferenceFactory;\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the naming store injector.\n     *\n     * @return the injector\n     */\n    public Injector<ServiceBasedNamingStore> getNamingStoreInjector() {\n        return namingStoreValue;\n    }","id":86118,"modified_method":"/**\n     * Get the naming store injector.\n     *\n     * @return the injector\n     */\n    public InjectedValue<ServiceBasedNamingStore> getNamingStoreInjector() {\n        return namingStoreValue;\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public BinderService(final String name) {\n        this(name, null, null);\n    }","id":86119,"modified_method":"public BinderService(final String name) {\n        this(name, null, false);\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct new instance.\n     *\n     * @param name The JNDI name to use for binding. May be either an absolute or relative name\n     */\n    public BinderService(final String name, Object source) {\n        this(name,source,null);\n    }","id":86120,"modified_method":"/**\n     * Construct new instance.\n     *\n     * @param name The JNDI name to use for binding. May be either an absolute or relative name\n     */\n    public BinderService(final String name, Object source) {\n        this(name, source, false);\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void release() {\n        if (refcnt.decrementAndGet() <= 0 && controller != null) {\n            controller.setMode(ServiceController.Mode.REMOVE);\n        }\n    }","id":86121,"modified_method":"public void release() {\n        if (refcnt != null && refcnt.decrementAndGet() <= 0 && controller != null) {\n            controller.setMode(ServiceController.Mode.REMOVE);\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processClassConfigurations(final DeploymentPhaseContext phaseContext, final EEApplicationClasses applicationClasses, final EEModuleConfiguration moduleConfiguration, final Map<ServiceName, BindingConfiguration> deploymentDescriptorBindings, final Set<String> handledClasses, final ComponentNamingMode namingMode, final Set<Class<?>> classes, final String componentName, final ServiceName ownerName, final IntHolder handleCount, final List<ServiceName> dependencies) throws DeploymentUnitProcessingException {\n        for (final Class<?> clazz : classes) {\n            new ClassDescriptionTraversal(clazz, applicationClasses) {\n                @Override\n                protected void handle(final Class<?> currentClass, final EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    if (classDescription == null) {\n                        return;\n                    }\n                    if (classDescription.isInvalid()) {\n                        throw MESSAGES.componentClassHasErrors(classDescription.getClassName(), componentName, classDescription.getInvalidMessage());\n                    }\n                    //only process classes once\n                    if (handledClasses.contains(classDescription.getClassName())) {\n                        return;\n                    }\n                    handledClasses.add(classDescription.getClassName());\n                    // TODO: Should the view configuration just return a Set instead of a List? Or is there a better way to\n                    // handle these duplicates?\n                    if (!MetadataCompleteMarker.isMetadataComplete(phaseContext.getDeploymentUnit())) {\n                        final Set<BindingConfiguration> classLevelBindings = new HashSet<BindingConfiguration>(classDescription.getBindingConfigurations());\n                        for (BindingConfiguration binding : classLevelBindings) {\n                            final String bindingName = binding.getName();\n                            final boolean compBinding = bindingName.startsWith(\"java:comp\") || !bindingName.startsWith(\"java:\");\n                            if (namingMode == ComponentNamingMode.CREATE && compBinding) {\n                                //components with their own comp context do their own binding\n                                continue;\n                            }\n                            final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(moduleConfiguration.getApplicationName(), moduleConfiguration.getModuleName(), null, false, binding.getName());\n\n                            ROOT_LOGGER.tracef(\"Binding %s using service %s\", binding.getName(), bindInfo.getBinderServiceName());\n\n                            if (deploymentDescriptorBindings.containsKey(bindInfo.getBinderServiceName())) {\n                                continue; //this has been overridden by a DD binding\n                            }\n                            addJndiBinding(moduleConfiguration, binding, phaseContext, bindInfo.getBinderServiceName(), ownerName, handleCount, dependencies);\n                        }\n                    }\n                }\n            }.run();\n        }\n    }","id":86122,"modified_method":"private void processClassConfigurations(final DeploymentPhaseContext phaseContext, final EEApplicationClasses applicationClasses, final EEModuleConfiguration moduleConfiguration, final Map<ServiceName, BindingConfiguration> deploymentDescriptorBindings, final Set<String> handledClasses, final ComponentNamingMode namingMode, final Set<Class<?>> classes, final String componentName, final List<ServiceName> dependencies) throws DeploymentUnitProcessingException {\n        for (final Class<?> clazz : classes) {\n            new ClassDescriptionTraversal(clazz, applicationClasses) {\n                @Override\n                protected void handle(final Class<?> currentClass, final EEModuleClassDescription classDescription) throws DeploymentUnitProcessingException {\n                    if (classDescription == null) {\n                        return;\n                    }\n                    if (classDescription.isInvalid()) {\n                        throw MESSAGES.componentClassHasErrors(classDescription.getClassName(), componentName, classDescription.getInvalidMessage());\n                    }\n                    //only process classes once\n                    if (handledClasses.contains(classDescription.getClassName())) {\n                        return;\n                    }\n                    handledClasses.add(classDescription.getClassName());\n                    // TODO: Should the view configuration just return a Set instead of a List? Or is there a better way to\n                    // handle these duplicates?\n                    if (!MetadataCompleteMarker.isMetadataComplete(phaseContext.getDeploymentUnit())) {\n                        final Set<BindingConfiguration> classLevelBindings = new HashSet<BindingConfiguration>(classDescription.getBindingConfigurations());\n                        for (BindingConfiguration binding : classLevelBindings) {\n                            final String bindingName = binding.getName();\n                            final boolean compBinding = bindingName.startsWith(\"java:comp\") || !bindingName.startsWith(\"java:\");\n                            if (namingMode == ComponentNamingMode.CREATE && compBinding) {\n                                //components with their own comp context do their own binding\n                                continue;\n                            }\n                            final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(moduleConfiguration.getApplicationName(), moduleConfiguration.getModuleName(), null, false, binding.getName());\n\n                            ROOT_LOGGER.tracef(\"Binding %s using service %s\", binding.getName(), bindInfo.getBinderServiceName());\n\n                            if (deploymentDescriptorBindings.containsKey(bindInfo.getBinderServiceName())) {\n                                continue; //this has been overridden by a DD binding\n                            }\n                            addJndiBinding(moduleConfiguration, binding, phaseContext, dependencies);\n                        }\n                    }\n                }\n            }.run();\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void addJndiBinding(final EEModuleConfiguration module, final BindingConfiguration bindingConfiguration, final DeploymentPhaseContext phaseContext, ServiceName serviceName, ServiceName ownerName, IntHolder handleCount, final List<ServiceName> dependencies) throws DeploymentUnitProcessingException {\n        // Gather information about the dependency\n        final String bindingName = bindingConfiguration.getName().startsWith(\"java:\") ? bindingConfiguration.getName() : \"java:module/env/\" + bindingConfiguration.getName();\n\n        final ServiceVerificationHandler serviceVerificationHandler = phaseContext.getDeploymentUnit().getAttachment(org.jboss.as.server.deployment.Attachments.SERVICE_VERIFICATION_HANDLER);\n\n        InjectionSource.ResolutionContext resolutionContext = new InjectionSource.ResolutionContext(\n                true,\n                module.getModuleName(),\n                module.getModuleName(),\n                module.getApplicationName()\n        );\n\n        // Check to see if this entry should actually be bound into JNDI.\n        if (bindingName != null) {\n            final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(module.getApplicationName(), module.getModuleName(), module.getModuleName(), false, bindingName);\n\n            if (bindingName.startsWith(\"java:comp\") || bindingName.startsWith(\"java:module\") || bindingName.startsWith(\"java:app\")) {\n                //this is a binding that does not need to be shared.\n\n                try {\n                    final BinderService service = new BinderService(bindInfo.getBindName(), bindingConfiguration.getSource());\n                    dependencies.add(bindInfo.getBinderServiceName());\n                    ServiceBuilder<ManagedReferenceFactory> serviceBuilder = phaseContext.getServiceTarget().addService(bindInfo.getBinderServiceName(), service);\n                    bindingConfiguration.getSource().getResourceValue(resolutionContext, serviceBuilder, phaseContext, service.getManagedObjectInjector());\n                    serviceBuilder.addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, service.getNamingStoreInjector());\n                    serviceBuilder.install();\n                } catch (DuplicateServiceException e) {\n                    ServiceController<ManagedReferenceFactory> registered = (ServiceController<ManagedReferenceFactory>) CurrentServiceContainer.getServiceContainer().getService(bindInfo.getBinderServiceName());\n                    if (registered == null)\n                        throw e;\n\n                    BinderService service = (BinderService) registered.getService();\n                    if (!service.getSource().equals(bindingConfiguration.getSource()))\n                        throw MESSAGES.conflictingBinding(bindingName, bindingConfiguration.getSource());\n                } catch (CircularDependencyException e) {\n                    throw MESSAGES.circularDependency(bindingName);\n                }\n\n            } else {\n                ServiceController<ManagedReferenceFactory> controller = null;\n                BinderService service;\n                try {\n                    service = new BinderService(bindInfo.getBindName(), bindingConfiguration.getSource());\n                    dependencies.add(bindInfo.getBinderServiceName());\n                    ServiceBuilder<ManagedReferenceFactory> serviceBuilder = CurrentServiceContainer.getServiceContainer().addService(bindInfo.getBinderServiceName(), service);\n                    bindingConfiguration.getSource().getResourceValue(resolutionContext, serviceBuilder, phaseContext, service.getManagedObjectInjector());\n                    serviceBuilder.addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, service.getNamingStoreInjector());\n                    serviceBuilder.addListener(serviceVerificationHandler);\n                    controller = serviceBuilder.install();\n\n                    service.acquire();\n                } catch (DuplicateServiceException e) {\n                    controller = (ServiceController<ManagedReferenceFactory>) CurrentServiceContainer.getServiceContainer().getService(bindInfo.getBinderServiceName());\n                    if (controller == null)\n                        throw e;\n\n                    service = (BinderService) controller.getService();\n                    if (!equals(service.getSource(), bindingConfiguration.getSource())) {\n                        throw MESSAGES.conflictingBinding(bindingName, bindingConfiguration.getSource());\n                    }\n                    service.acquire();\n                }\n                //as these bindings are not child services\n                //we need to add a listener that released the service when the deployment stops\n                ServiceController<?> unitService = CurrentServiceContainer.getServiceContainer().getService(phaseContext.getDeploymentUnit().getServiceName());\n                final BinderService binderService = service;\n                unitService.addListener(new BinderReleaseListener(binderService));\n            }\n\n        } else {\n            throw MESSAGES.nullBindingName(bindingConfiguration);\n        }\n    }","id":86123,"modified_method":"protected void addJndiBinding(final EEModuleConfiguration module, final BindingConfiguration bindingConfiguration, final DeploymentPhaseContext phaseContext, final List<ServiceName> dependencies) throws DeploymentUnitProcessingException {\n        // Gather information about the dependency\n        final String bindingName = bindingConfiguration.getName().startsWith(\"java:\") ? bindingConfiguration.getName() : \"java:module/env/\" + bindingConfiguration.getName();\n\n        final ServiceVerificationHandler serviceVerificationHandler = phaseContext.getDeploymentUnit().getAttachment(org.jboss.as.server.deployment.Attachments.SERVICE_VERIFICATION_HANDLER);\n\n        InjectionSource.ResolutionContext resolutionContext = new InjectionSource.ResolutionContext(\n                true,\n                module.getModuleName(),\n                module.getModuleName(),\n                module.getApplicationName()\n        );\n\n        // Check to see if this entry should actually be bound into JNDI.\n        if (bindingName != null) {\n            final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(module.getApplicationName(), module.getModuleName(), module.getModuleName(), false, bindingName);\n            dependencies.add(bindInfo.getBinderServiceName());\n            if (bindingName.startsWith(\"java:comp\") || bindingName.startsWith(\"java:module\") || bindingName.startsWith(\"java:app\")) {\n                //this is a binding that does not need to be shared.\n                try {\n                    final BinderService service = new BinderService(bindInfo.getBindName(), bindingConfiguration.getSource());\n                    ServiceBuilder<ManagedReferenceFactory> serviceBuilder = phaseContext.getServiceTarget().addService(bindInfo.getBinderServiceName(), service);\n                    bindingConfiguration.getSource().getResourceValue(resolutionContext, serviceBuilder, phaseContext, service.getManagedObjectInjector());\n                    serviceBuilder.addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, service.getNamingStoreInjector());\n                    serviceBuilder.install();\n                } catch (DuplicateServiceException e) {\n                    ServiceController<ManagedReferenceFactory> registered = (ServiceController<ManagedReferenceFactory>) CurrentServiceContainer.getServiceContainer().getService(bindInfo.getBinderServiceName());\n                    if (registered == null)\n                        throw e;\n                    BinderService service = (BinderService) registered.getService();\n                    if (!service.getSource().equals(bindingConfiguration.getSource()))\n                        throw MESSAGES.conflictingBinding(bindingName, bindingConfiguration.getSource());\n                } catch (CircularDependencyException e) {\n                    throw MESSAGES.circularDependency(bindingName);\n                }\n            } else {\n                BinderService service;\n                try {\n                    service = new BinderService(bindInfo.getBindName(), bindingConfiguration.getSource(), true);\n                    ServiceBuilder<ManagedReferenceFactory> serviceBuilder = CurrentServiceContainer.getServiceContainer().addService(bindInfo.getBinderServiceName(), service);\n                    bindingConfiguration.getSource().getResourceValue(resolutionContext, serviceBuilder, phaseContext, service.getManagedObjectInjector());\n                    serviceBuilder.addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, service.getNamingStoreInjector());\n                    serviceBuilder.addListener(serviceVerificationHandler);\n                    serviceBuilder.install();\n                } catch (DuplicateServiceException e) {\n                    final ServiceController<ManagedReferenceFactory> controller = (ServiceController<ManagedReferenceFactory>) CurrentServiceContainer.getServiceContainer().getService(bindInfo.getBinderServiceName());\n                    if (controller == null)\n                        throw e;\n                    service = (BinderService) controller.getService();\n                    if (!equals(service.getSource(), bindingConfiguration.getSource())) {\n                        throw MESSAGES.conflictingBinding(bindingName, bindingConfiguration.getSource());\n                    }\n                }\n                //as these bindings are not child services\n                //we need to add a listener that released the service when the deployment stops\n                service.acquire();\n                ServiceController<?> unitService = CurrentServiceContainer.getServiceContainer().getService(phaseContext.getDeploymentUnit().getServiceName());\n                unitService.addListener(new BinderReleaseListener(service));\n            }\n        } else {\n            throw MESSAGES.nullBindingName(bindingConfiguration);\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleConfiguration moduleConfiguration = deploymentUnit.getAttachment(Attachments.EE_MODULE_CONFIGURATION);\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final DeploymentClassIndex classIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.CLASS_INDEX);\n        if (moduleConfiguration == null || DeploymentUtils.skipRepeatedActivation(deploymentUnit, 0)) {\n            return;\n        }\n        final List<ServiceName> dependencies = deploymentUnit.getAttachmentList(org.jboss.as.server.deployment.Attachments.JNDI_DEPENDENCIES);\n\n        final Map<ServiceName, BindingConfiguration> deploymentDescriptorBindings = new HashMap<ServiceName, BindingConfiguration>();\n\n        // bindings\n        // Handle duplicates binding from the same source\n        // TODO: Should the view configuration just return a Set instead of a List? Or is there a better way to\n        // handle these duplicates?\n        IntHolder moduleCount = new IntHolder();\n        final List<BindingConfiguration> bindingConfigurations = eeModuleDescription.getBindingConfigurations();\n\n        //we need to make sure that java:module/env and java:comp/env are always available\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            bindingConfigurations.add(new BindingConfiguration(\"java:module/env\", new ContextInjectionSource(\"env\", \"java:module/env\")));\n        }\n        if (deploymentUnit.getParent() == null) {\n            bindingConfigurations.add(new BindingConfiguration(\"java:app/env\", new ContextInjectionSource(\"env\", \"java:app/env\")));\n        }\n\n\n        final ServiceName moduleOwnerName = deploymentUnit.getServiceName().append(\"module\").append(moduleConfiguration.getApplicationName()).append(moduleConfiguration.getModuleName());\n        for (BindingConfiguration binding : bindingConfigurations) {\n\n            final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(moduleConfiguration.getApplicationName(), moduleConfiguration.getModuleName(), null, false, binding.getName());\n\n            deploymentDescriptorBindings.put(bindInfo.getBinderServiceName(), binding);\n            addJndiBinding(moduleConfiguration, binding, phaseContext, bindInfo.getBinderServiceName(), moduleOwnerName, moduleCount, dependencies);\n        }\n\n        //now we process all component level bindings, for components that do not have their own java:comp namespace.\n        // these are bindings that have been added via a deployment descriptor\n        for (final ComponentConfiguration componentConfiguration : moduleConfiguration.getComponentConfigurations()) {\n            // TODO: Should the view configuration just return a Set instead of a List? Or is there a better way to\n            // handle these duplicates?\n            for (BindingConfiguration binding : componentConfiguration.getComponentDescription().getBindingConfigurations()) {\n                final String bindingName = binding.getName();\n                final boolean compBinding = bindingName.startsWith(\"java:comp\") || !bindingName.startsWith(\"java:\");\n                if (componentConfiguration.getComponentDescription().getNamingMode() == ComponentNamingMode.CREATE && compBinding) {\n                    //components with there own comp context do their own binding\n                    continue;\n                }\n\n                final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(moduleConfiguration.getApplicationName(), moduleConfiguration.getModuleName(), null, false, binding.getName());\n                deploymentDescriptorBindings.put(bindInfo.getBinderServiceName(), binding);\n                addJndiBinding(moduleConfiguration, binding, phaseContext, bindInfo.getBinderServiceName(), moduleOwnerName, moduleCount, dependencies);\n            }\n        }\n\n        //now add all class level bindings\n        final Set<String> handledClasses = new HashSet<String>();\n\n        for (final ComponentConfiguration componentConfiguration : moduleConfiguration.getComponentConfigurations()) {\n            final Set<Class<?>> classConfigurations = new HashSet<Class<?>>();\n            classConfigurations.add(componentConfiguration.getComponentClass());\n\n            for (final InterceptorDescription interceptor : componentConfiguration.getComponentDescription().getAllInterceptors()) {\n                try {\n                    final ClassIndex interceptorClass = classIndex.classIndex(interceptor.getInterceptorClassName());\n                    classConfigurations.add(interceptorClass.getModuleClass());\n                } catch (ClassNotFoundException e) {\n                    throw MESSAGES.cannotLoadInterceptor(e, interceptor.getInterceptorClassName(), componentConfiguration.getComponentClass());\n                }\n            }\n            processClassConfigurations(phaseContext, applicationClasses, moduleConfiguration, deploymentDescriptorBindings, handledClasses, componentConfiguration.getComponentDescription().getNamingMode(), classConfigurations, componentConfiguration.getComponentName(), moduleOwnerName, moduleCount, dependencies);\n        }\n\n    }","id":86124,"modified_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleConfiguration moduleConfiguration = deploymentUnit.getAttachment(Attachments.EE_MODULE_CONFIGURATION);\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final DeploymentClassIndex classIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.CLASS_INDEX);\n        if (moduleConfiguration == null || DeploymentUtils.skipRepeatedActivation(deploymentUnit, 0)) {\n            return;\n        }\n        final List<ServiceName> dependencies = deploymentUnit.getAttachmentList(org.jboss.as.server.deployment.Attachments.JNDI_DEPENDENCIES);\n\n        final Map<ServiceName, BindingConfiguration> deploymentDescriptorBindings = new HashMap<ServiceName, BindingConfiguration>();\n\n        final List<BindingConfiguration> bindingConfigurations = eeModuleDescription.getBindingConfigurations();\n\n        //we need to make sure that java:module/env and java:comp/env are always available\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            bindingConfigurations.add(new BindingConfiguration(\"java:module/env\", new ContextInjectionSource(\"env\", \"java:module/env\")));\n        }\n        if (deploymentUnit.getParent() == null) {\n            bindingConfigurations.add(new BindingConfiguration(\"java:app/env\", new ContextInjectionSource(\"env\", \"java:app/env\")));\n        }\n\n        for (BindingConfiguration binding : bindingConfigurations) {\n\n            final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(moduleConfiguration.getApplicationName(), moduleConfiguration.getModuleName(), null, false, binding.getName());\n\n            deploymentDescriptorBindings.put(bindInfo.getBinderServiceName(), binding);\n            addJndiBinding(moduleConfiguration, binding, phaseContext, dependencies);\n        }\n\n        //now we process all component level bindings, for components that do not have their own java:comp namespace.\n        // these are bindings that have been added via a deployment descriptor\n        for (final ComponentConfiguration componentConfiguration : moduleConfiguration.getComponentConfigurations()) {\n            // TODO: Should the view configuration just return a Set instead of a List? Or is there a better way to\n            // handle these duplicates?\n            for (BindingConfiguration binding : componentConfiguration.getComponentDescription().getBindingConfigurations()) {\n                final String bindingName = binding.getName();\n                final boolean compBinding = bindingName.startsWith(\"java:comp\") || !bindingName.startsWith(\"java:\");\n                if (componentConfiguration.getComponentDescription().getNamingMode() == ComponentNamingMode.CREATE && compBinding) {\n                    //components with there own comp context do their own binding\n                    continue;\n                }\n\n                final ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(moduleConfiguration.getApplicationName(), moduleConfiguration.getModuleName(), null, false, binding.getName());\n                deploymentDescriptorBindings.put(bindInfo.getBinderServiceName(), binding);\n                addJndiBinding(moduleConfiguration, binding, phaseContext, dependencies);\n            }\n        }\n\n        //now add all class level bindings\n        final Set<String> handledClasses = new HashSet<String>();\n\n        for (final ComponentConfiguration componentConfiguration : moduleConfiguration.getComponentConfigurations()) {\n            final Set<Class<?>> classConfigurations = new HashSet<Class<?>>();\n            classConfigurations.add(componentConfiguration.getComponentClass());\n\n            for (final InterceptorDescription interceptor : componentConfiguration.getComponentDescription().getAllInterceptors()) {\n                try {\n                    final ClassIndex interceptorClass = classIndex.classIndex(interceptor.getInterceptorClassName());\n                    classConfigurations.add(interceptorClass.getModuleClass());\n                } catch (ClassNotFoundException e) {\n                    throw MESSAGES.cannotLoadInterceptor(e, interceptor.getInterceptorClassName(), componentConfiguration.getComponentClass());\n                }\n            }\n            processClassConfigurations(phaseContext, applicationClasses, moduleConfiguration, deploymentDescriptorBindings, handledClasses, componentConfiguration.getComponentDescription().getNamingMode(), classConfigurations, componentConfiguration.getComponentName(), dependencies);\n        }\n\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Set<ServiceName> getValue() throws IllegalStateException, IllegalArgumentException {\n        synchronized (this) {\n            if (serviceNames == null) {\n                serviceNames = Collections.synchronizedSet(new HashSet<ServiceName>());\n            }\n            return serviceNames;\n        }\n    }","id":86125,"modified_method":"@Override\n    public References getValue() throws IllegalStateException, IllegalArgumentException {\n        return references;\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void stop(StopContext context) {\n        synchronized (this) {\n            if(serviceNames != null) {\n                ServiceContainer container = context.getController().getServiceContainer();\n                for (ServiceName serviceName : serviceNames) {\n                    try {\n                        final ServiceController<?> serviceController = container.getService(serviceName);\n                        if(serviceController != null) {\n                            ((BinderService)serviceController.getService()).release();\n                        }\n                    } catch (Throwable e) {\n                        NamingLogger.ROOT_LOGGER.failedToReleaseBinderService(e);\n                    }\n                }\n                serviceNames = null;\n            }\n        }\n    }","id":86126,"modified_method":"@Override\n    public void stop(StopContext context) {\n        references.releaseAll();\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void bind(final Name name, final Object object) throws NamingException {\n        final ServiceName deploymentUnitServiceName = requireOwner();\n        final ServiceName bindName = buildServiceName(name);\n        bind(name, bindName, object, deploymentUnitServiceName);\n    }","id":86127,"modified_method":"public void bind(final Name name, final Object object) throws NamingException {\n        final Object owner = requireOwner();\n        final ServiceName bindName = buildServiceName(name);\n        bind(name, object, owner, bindName);\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void unbind(final Name name) throws NamingException {\n        requireOwner();\n        final ServiceName bindName = buildServiceName(name);\n        // do the unbinding\n        unbind(name, bindName);\n    }","id":86128,"modified_method":"public void unbind(final Name name) throws NamingException {\n        requireOwner();\n        final ServiceName bindName = buildServiceName(name);\n        final ServiceController<?> controller = getServiceRegistry().getService(bindName);\n        if (controller == null) {\n            throw MESSAGES.cannotResolveService(bindName);\n        }\n        controller.setMode(ServiceController.Mode.REMOVE);\n        final StabilityMonitor monitor = new StabilityMonitor();\n        monitor.addController(controller);\n        try {\n            monitor.awaitStability();\n        } catch (Exception e) {\n            throw namingException(\"Failed to unbind [\" + bindName + \"]\", e);\n        } finally {\n            monitor.removeController(controller);\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void pushOwner(final ServiceName du) {\n        WRITE_OWNER.push(du);\n    }","id":86129,"modified_method":"public static void pushOwner(final ServiceName deploymentUnitServiceName) {\n        WRITE_OWNER.push(deploymentUnitServiceName);\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private void bind(final Name name, final ServiceName bindName, final Object object, final ServiceName deploymentUnitServiceName) throws NamingException {\n        try {\n            final BinderService binderService = new BinderService(name.toString(), null, deploymentUnitServiceName);\n            final ServiceBuilder<?> builder = serviceTarget.addService(bindName, binderService)\n                    .addDependency(getServiceNameBase(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                    .addInjection(binderService.getManagedObjectInjector(), new ValueManagedReferenceFactory(new ImmediateValue<Object>(object)))\n                    .setInitialMode(ServiceController.Mode.ACTIVE);\n            final ServiceController<?> binderServiceController = builder.install();\n            final StabilityMonitor monitor = new StabilityMonitor();\n            monitor.addController(binderServiceController);\n            try {\n                monitor.awaitStability();\n            } finally {\n                monitor.removeController(binderServiceController);\n            }\n            final Exception startException = binderServiceController.getStartException();\n            if (startException != null) {\n                throw startException;\n            }\n            binderService.acquire();\n        } catch (Exception e) {\n            throw namingException(\"Failed to bind [\" + object + \"] at location [\" + bindName + \"]\", e);\n        }\n    }","id":86130,"modified_method":"private void bind(Name name, Object object, Object owner, ServiceName bindName) throws NamingException {\n        ServiceTarget serviceTarget = this.serviceTarget;\n        ServiceName deploymentUnitServiceName = null;\n        if (owner instanceof ServiceName) {\n            deploymentUnitServiceName = (ServiceName) owner;\n        } else {\n            serviceTarget = (ServiceTarget) owner;\n        }\n        try {\n            // unlike on deployment processors, we may assume here it's a shareable bind if the owner is a deployment, because deployment unshareable namespaces are readonly stores\n            final BinderService binderService = new BinderService(name.toString(), null, deploymentUnitServiceName != null);\n            final ServiceBuilder<?> builder = serviceTarget.addService(bindName, binderService)\n                    .addDependency(getServiceNameBase(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())\n                    .addInjection(binderService.getManagedObjectInjector(), new ImmediateManagedReferenceFactory(object))\n                    .setInitialMode(ServiceController.Mode.ACTIVE);\n            final ServiceController<?> binderServiceController = builder.install();\n            final StabilityMonitor monitor = new StabilityMonitor();\n            monitor.addController(binderServiceController);\n            try {\n                monitor.awaitStability();\n            } finally {\n                monitor.removeController(binderServiceController);\n            }\n            final Exception startException = binderServiceController.getStartException();\n            if (startException != null) {\n                throw startException;\n            }\n            if (deploymentUnitServiceName != null) {\n                binderService.acquire();\n                final RuntimeBindReleaseService.References duBindingReferences = (RuntimeBindReleaseService.References) binderServiceController.getServiceContainer().getService(JndiNamingDependencyProcessor.serviceName(deploymentUnitServiceName)).getValue();\n                duBindingReferences.add(binderService);\n            }\n        } catch (Exception e) {\n            throw namingException(\"Failed to bind [\" + object + \"] at location [\" + bindName + \"]\", e);\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ServiceName requireOwner() {\n        final ServiceName owner = WRITE_OWNER.peek();\n        if (owner == null) {\n            throw MESSAGES.readOnlyNamingContext();\n        }\n        return owner;\n    }","id":86131,"modified_method":"private Object requireOwner() {\n        final Object owner = WRITE_OWNER.peek();\n        if (owner == null) {\n            throw MESSAGES.readOnlyNamingContext();\n        }\n        return owner;\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void rebind(Name name, Object object) throws NamingException {\n        final ServiceName deploymentUnitServiceName = requireOwner();\n        final ServiceName bindName = buildServiceName(name);\n        try {\n            unbind(name, bindName);\n        } catch (NamingException ignore) {\n            // rebind may fail if there is no existing binding\n        }\n        bind(name, bindName, object, deploymentUnitServiceName);\n    }","id":86132,"modified_method":"public void rebind(Name name, Object object) throws NamingException {\n        final Object owner = requireOwner();\n        // re-set the existent binder service injected value\n        final ServiceName bindName = buildServiceName(name);\n        final ServiceController<?> controller = getServiceRegistry().getService(bindName);\n        if (controller == null) {\n            bind(name, object, owner, bindName);\n        } else {\n            final BinderService binderService = (BinderService) controller.getService();\n            if (owner instanceof ServiceName) {\n                final ServiceName deploymentUnitServiceName = (ServiceName) owner;\n                binderService.acquire();\n                final RuntimeBindReleaseService.References duBindingReferences = (RuntimeBindReleaseService.References) controller.getServiceContainer().getService(JndiNamingDependencyProcessor.serviceName(deploymentUnitServiceName)).getValue();\n                duBindingReferences.add(binderService);\n            }\n            binderService.getManagedObjectInjector().setValue(new ImmediateValue(new ImmediateManagedReferenceFactory(object)));\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOwnerBindingReferences() throws Exception {\n        final Name name = new CompositeName(\"test\");\n        final ServiceName serviceName = store.buildServiceName(name);\n        final Object value = new Object();\n\n        // ensure bind does not exists\n        try {\n            store.lookup(name);\n            fail(\"Should have thrown name not found\");\n        } catch (NameNotFoundException expect) {\n        }\n        // ensure the Foo's RuntimeBindReleaseService has no reference to the future bind\n        final Set<ServiceName> duBindingReferences = (Set<ServiceName>) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_FOO)).getValue();\n        assertFalse(duBindingReferences.contains(serviceName));\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n        try {\n            store.bind(name, value);\n            // Foo's RuntimeBindReleaseService should now have a reference to the new bind\n            assertTrue(duBindingReferences.contains(serviceName));\n\n            store.rebind(name, value);\n            // after rebind, Foo's RuntimeBindReleaseService should continue to have a reference to the bind\n            assertTrue(duBindingReferences.contains(serviceName));\n\n            store.unbind(name);\n            // Foo's RuntimeBindReleaseService reference to the bind should have been removed\n            assertFalse(duBindingReferences.contains(serviceName));\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n    }","id":86133,"modified_method":"@Test\n    public void testOwnerBindingReferences() throws Exception {\n        final Name name = new CompositeName(\"test\");\n        final ServiceName serviceName = store.buildServiceName(name);\n        final Object value = new Object();\n\n        // ensure bind does not exists\n        try {\n            store.lookup(name);\n            fail(\"Should have thrown name not found\");\n        } catch (NameNotFoundException expect) {\n        }\n        final RuntimeBindReleaseService.References duBindingReferences = (RuntimeBindReleaseService.References) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_FOO)).getValue();\n        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n        try {\n            store.bind(name, value);\n            // Foo's RuntimeBindReleaseService should now have a reference to the new bind\n            assertTrue(duBindingReferences.contains(serviceName));\n\n            store.rebind(name, value);\n            // after rebind, Foo's RuntimeBindReleaseService should continue to have a reference to the bind\n            assertTrue(duBindingReferences.contains(serviceName));\n\n            store.unbind(name);\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testMultipleOwnersBindingReferences() throws Exception {\n        final Name name = new CompositeName(\"test\");\n        final ServiceName serviceName = store.buildServiceName(name);\n        final Object value = new Object();\n\n        // ensure bind does not exists\n        try {\n            store.lookup(name);\n            fail(\"Should have thrown name not found\");\n        } catch (NameNotFoundException expect) {\n        }\n        // ensure the owners RuntimeBindReleaseService have no reference to the future bind\n        final Set<ServiceName> fooDuBindingReferences = (Set<ServiceName>) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_FOO)).getValue();\n        assertFalse(fooDuBindingReferences.contains(serviceName));\n        final Set<ServiceName> barDuBindingReferences = (Set<ServiceName>) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_BAR)).getValue();\n        assertFalse(barDuBindingReferences.contains(serviceName));\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n        try {\n            store.bind(name, value);\n            // Foo's RuntimeBindReleaseService should now have a reference to the new bind\n            assertTrue(fooDuBindingReferences.contains(serviceName));\n            // Bar's RuntimeBindReleaseService reference to the bind should not exist\n            assertFalse(barDuBindingReferences.contains(serviceName));\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_BAR);\n        try {\n            store.rebind(name, value);\n            // after rebind, Foo's RuntimeBindReleaseService reference to the bind should have been removed\n            assertFalse(fooDuBindingReferences.contains(serviceName));\n            // after rebind, Bar's RuntimeBindReleaseService reference to the bind should now exist\n            assertTrue(barDuBindingReferences.contains(serviceName));\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n        try {\n            store.unbind(name);\n            // after unbind, Foo's RuntimeBindReleaseService reference to the bind should still not exist\n            assertFalse(fooDuBindingReferences.contains(serviceName));\n            // after unbind, Bar's RuntimeBindReleaseService reference to the bind should have been removed\n            assertFalse(barDuBindingReferences.contains(serviceName));\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n    }","id":86134,"modified_method":"@Test\n    public void testMultipleOwnersBindingReferences() throws Exception {\n        final Name name = new CompositeName(\"test\");\n        final ServiceName serviceName = store.buildServiceName(name);\n        final Object value = new Object();\n\n        // ensure bind does not exists\n        try {\n            store.lookup(name);\n            fail(\"Should have thrown name not found\");\n        } catch (NameNotFoundException expect) {\n        }\n        // ensure the owners RuntimeBindReleaseService have no reference to the future bind\n        final RuntimeBindReleaseService.References fooDuBindingReferences = (RuntimeBindReleaseService.References) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_FOO)).getValue();\n        assertFalse(fooDuBindingReferences.contains(serviceName));\n        final RuntimeBindReleaseService.References barDuBindingReferences = (RuntimeBindReleaseService.References) container.getService(JndiNamingDependencyProcessor.serviceName(OWNER_BAR)).getValue();\n        assertFalse(barDuBindingReferences.contains(serviceName));\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n        try {\n            store.bind(name, value);\n            // Foo's RuntimeBindReleaseService should now have a reference to the new bind\n            assertTrue(fooDuBindingReferences.contains(serviceName));\n            // Bar's RuntimeBindReleaseService reference to the bind should not exist\n            assertFalse(barDuBindingReferences.contains(serviceName));\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_BAR);\n        try {\n            store.rebind(name, value);\n            // after rebind, Foo's RuntimeBindReleaseService reference to the bind should still exist\n            assertTrue(fooDuBindingReferences.contains(serviceName));\n            // after rebind, Bar's RuntimeBindReleaseService reference to the bind should now exist\n            assertTrue(barDuBindingReferences.contains(serviceName));\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n\n        WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n        try {\n            store.unbind(name);\n        } finally {\n            WritableServiceBasedNamingStore.popOwner();\n        }\n    }","commit_id":"9dba57580cc752af2d082da0fec87e31cb9c0bbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n\t * Gets a WebSession object from the HttpServletRequest, creating a new one\n\t * if it doesn't already exist.\n\t * \n\t * @param request\n\t *            The http request object\n\t * @return The session object\n\t */\n\tfinal WebSession getSession(final WebRequest request)\n\t{\n\t\tISessionStore sessionStore = getSessionStore();\n\t\tSession session = sessionStore.lookup(request);\n\n\t\tif (session == null)\n\t\t{\n\t\t\t// Create session using session factory\n\t\t\tsession = getSessionFactory().newSession();\n\n\t\t\t// Set the client Locale for this session\n\t\t\tsession.setLocale(request.getLocale());\n\n\t\t\t// Bind the session to the session store\n\t\t\tsessionStore.bind(request, session);\n\t\t}\n\n\t\tWebSession webSession;\n\t\tif (session instanceof WebSession)\n\t\t{\n\t\t\twebSession = (WebSession)session;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Session created by a WebApplication session factory \"\n\t\t\t\t\t+ \"must be a subclass of WebSession\");\n\t\t}\n\n\t\t// Set application on session\n\t\tsession.setApplication(this);\n\n\t\t// Set session attribute name and attach/reattach http servlet session\n\t\twebSession.initForRequest();\n\n\t\treturn webSession;\n\t}","id":86135,"modified_method":"/**\n\t * Gets a WebSession object from the HttpServletRequest, creating a new one\n\t * if it doesn't already exist.\n\t * \n\t * @param request\n\t *            The http request object\n\t * @return The session object\n\t */\n\tfinal WebSession getSession(final WebRequest request)\n\t{\n\t\tISessionStore sessionStore = getSessionStore();\n\t\tSession session = sessionStore.lookup(request);\n\n\t\tif (session == null)\n\t\t{\n\t\t\t// Create session using session factory\n\t\t\tsession = getSessionFactory().newSession();\n\t\t\t// Set the client Locale for this session\n\t\t\tsession.setLocale(request.getLocale());\n\t\t\t\n\t\t\tif (sessionStore.getSessionId(request) != null)\n\t\t\t{\n\t\t\t\t// Bind the session to the session store\n\t\t\t\tsessionStore.bind(request, session);\n\t\t\t}\n\t\t}\n\n\t\tWebSession webSession;\n\t\tif (session instanceof WebSession)\n\t\t{\n\t\t\twebSession = (WebSession)session;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Session created by a WebApplication session factory \"\n\t\t\t\t\t+ \"must be a subclass of WebSession\");\n\t\t}\n\n\t\t// Set application on session\n\t\tsession.setApplication(this);\n\n\t\t// Set session attribute name and attach/reattach http servlet session\n\t\twebSession.initForRequest();\n\n\t\treturn webSession;\n\t}","commit_id":"51df6a7094c7e9d55a9a5e1b3f04761dda7a7b50","url":"https://github.com/apache/wicket"},{"original_method":"public int read( ByteBuffer dst ) throws IOException\n        {\n            if ( pos >= data.length ) return -1;\n            int size = Math.min( data.length - pos, dst.capacity() );\n            dst.put( data, pos, size );\n            pos += size;\n            return size;\n        }","id":86136,"modified_method":"public int read( ByteBuffer dst ) throws IOException\n        {\n            if ( pos >= data.length ) return -1;\n            int size = Math.min( data.length - pos, dst.limit() - dst.position() );\n            dst.put( data, pos, size );\n            pos += size;\n            return size;\n        }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static void handleRequest( Master realMaster,\n            @SuppressWarnings( \"unused\" ) ChannelHandlerContext ctx,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        // TODO: is this really how you write stuff back?!\n        type.serializer.write( response.response(), buffer );\n        writeTransactionStreams( response.transactions(), buffer );\n    }","id":86137,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean brokerSaysIAmMaster()\n    {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":86138,"modified_method":"private boolean brokerSaysIAmMaster()\n    {\n        return ((AbstractBroker) broker).noobYouAreTheMaster();\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","id":86139,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final int eventIdentifier, final String resource,\n            final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeInt( eventIdentifier );\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        return sendRequest( RequestType.ROLLBACK, context, EMPTY_SERIALIZER, VOID_DESERIALIZER );\n    }","id":86140,"modified_method":"public Response<Void> rollbackTransaction( SlaveContext context, final int eventIdentifier )\n    {\n        return sendRequest( RequestType.ROLLBACK, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeInt( eventIdentifier );\n            }\n        }, VOID_DESERIALIZER );\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Client initClient()\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect( new InetSocketAddress( MasterServer.PORT ) );\n        return new Client( blockingReadHandler, channelFuture );\n    }","id":86141,"modified_method":"private static Client initClient()\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect( new InetSocketAddress( MasterServer.PORT ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        return client;\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception\n        {\n            ChannelBuffer message = (ChannelBuffer) e.getMessage();\n            handleRequest( realMaster, ctx, message );\n        }","id":86142,"modified_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception\n        {\n            ChannelBuffer message = (ChannelBuffer) e.getMessage();\n            e.getChannel().write( handleRequest( realMaster, message ) );\n        }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Ignore\n    @Test\n    public void testTwoSlaves() throws Exception\n    {\n        initializeDbs( 2 );\n        StandaloneDbCom db1 = slaveJvms.get( 0 );\n        StandaloneDbCom db2 = slaveJvms.get( 1 );\n        final String name = \"Mattias\";\n        db1.executeJob( new Job<Void>()\n        {\n            public Void execute( GraphDatabaseService db )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    Node node = db.createNode();\n                    db.getReferenceNode().createRelationshipTo( node, REL_TYPE );\n                    node.setProperty( \"name\", name );\n                    tx.success();\n                }\n                finally\n                {\n                    tx.finish();\n                }\n                return null;\n            }\n        } );\n        \n        String readName = db2.executeJob( new Job<String>()\n        {\n            public String execute( GraphDatabaseService db )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    Node refNode = db.getReferenceNode();\n                    // To force it to pull updates\n                    refNode.removeProperty( \"yoyoyoyo\" );\n                    Node node = refNode.getSingleRelationship( REL_TYPE,\n                            Direction.OUTGOING ).getEndNode();\n                    String name = (String) node.getProperty( \"name\" );\n                    node.setProperty( \"title\", \"Whatever\" );\n                    tx.success();\n                    return name;\n                }\n                finally\n                {\n                    tx.finish();\n                }\n            }\n        } );\n        \n        assertEquals( name, readName );\n        db1.pullUpdates();\n    }","id":86143,"modified_method":"@Test\n    public void testTwoSlaves() throws Exception\n    {\n        initializeDbs( 2 );\n        StandaloneDbCom db1 = slaveJvms.get( 0 );\n        StandaloneDbCom db2 = slaveJvms.get( 1 );\n        final String name = \"Mattias\";\n        db1.executeJob( new CommonJobs.CreateSubRefNodeJob( name ) );\n        String readName = db2.executeJob( new CommonJobs.SetSubRefNameJob() );\n        \n        assertEquals( name, readName );\n        db1.pullUpdates();\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void shutdownDbsAndVerify() throws Exception\n    {\n        for ( StandaloneDbCom slave : slaveJvms )\n        {\n            slave.shutdown();\n        }\n        masterJvm.shutdown();\n        \n        GraphDatabaseService masterDb = new EmbeddedGraphDatabase( MASTER_PATH.getAbsolutePath() );\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            GraphDatabaseService slaveDb =\n                    new EmbeddedGraphDatabase( slavePath( i ).getAbsolutePath() );\n            verify( masterDb, slaveDb );\n        }\n    }","id":86144,"modified_method":"@After\n    public void shutdownDbsAndVerify() throws Exception\n    {\n        for ( StandaloneDbCom slave : slaveJvms )\n        {\n            slave.initiateShutdown();\n        }\n        masterJvm.initiateShutdown();\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            waitUntilShutdownFileFound( slavePath( i ) );\n        }\n        waitUntilShutdownFileFound( MASTER_PATH );\n        \n        GraphDatabaseService masterDb = new EmbeddedGraphDatabase( MASTER_PATH.getAbsolutePath() );\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            GraphDatabaseService slaveDb =\n                    new EmbeddedGraphDatabase( slavePath( i ).getAbsolutePath() );\n            verify( masterDb, slaveDb );\n        }\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T executeJob( Job<T> job )\n    {\n        return job.execute( this.db );\n    }","id":86145,"modified_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        println( \"Job \" + job + \" executed\" );\n        return result;\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        db.pullUpdates();\n    }","id":86146,"modified_method":"public void pullUpdates()\n    {\n        println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown() throws RemoteException\n    {\n        this.location.unbind( this );\n        this.shutdown = true;\n    }","id":86147,"modified_method":"public void initiateShutdown() throws RemoteException\n    {\n        println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        this.db.shutdown();\n        this.shutdown = true;\n        println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 500 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws RemoteException\n    {\n        super();\n        \n        boolean isMaster = args.getBoolean( \"master\", null ).booleanValue();\n        String storeDir = args.get( \"path\", null );\n        AbstractBroker broker = isMaster ? new FakeMasterBroker() : new FakeSlaveBroker(\n                args.getNumber( \"id\", null ).intValue() );\n        this.db = new HighlyAvailableGraphDatabase( storeDir, new HashMap<String, String>(),\n                broker );\n        broker.setDb( this.db );\n        this.location = location;\n        this.location.ensureRegistryCreated();\n        this.location.bind( this );\n    }","id":86148,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        try\n        {\n            println( \"About to start\" );\n            boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n            AbstractBroker broker = isMaster ? new FakeMasterBroker() : new FakeSlaveBroker(\n                    args.getNumber( \"id\", null ).intValue() );\n            this.db = new HighlyAvailableGraphDatabase( storeDir, new HashMap<String, String>(),\n                    broker );\n            println( \"Started HA db\" );\n            broker.setDb( this.db );\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"e657cb78796a239f468f016e628fd0897f7fa124","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int read( ByteBuffer dst ) throws IOException\n        {\n            if ( pos >= data.length ) return -1;\n            int size = Math.min( data.length - pos, dst.capacity() );\n            dst.put( data, pos, size );\n            pos += size;\n            return size;\n        }","id":86149,"modified_method":"public int read( ByteBuffer dst ) throws IOException\n        {\n            if ( pos >= data.length ) return -1;\n            int size = Math.min( data.length - pos, dst.limit() - dst.position() );\n            dst.put( data, pos, size );\n            pos += size;\n            return size;\n        }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static void handleRequest( Master realMaster,\n            @SuppressWarnings( \"unused\" ) ChannelHandlerContext ctx,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        // TODO: is this really how you write stuff back?!\n        type.serializer.write( response.response(), buffer );\n        writeTransactionStreams( response.transactions(), buffer );\n    }","id":86150,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean brokerSaysIAmMaster()\n    {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":86151,"modified_method":"private boolean brokerSaysIAmMaster()\n    {\n        return ((AbstractBroker) broker).noobYouAreTheMaster();\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","id":86152,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final int eventIdentifier, final String resource,\n            final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeInt( eventIdentifier );\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        return sendRequest( RequestType.ROLLBACK, context, EMPTY_SERIALIZER, VOID_DESERIALIZER );\n    }","id":86153,"modified_method":"public Response<Void> rollbackTransaction( SlaveContext context, final int eventIdentifier )\n    {\n        return sendRequest( RequestType.ROLLBACK, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeInt( eventIdentifier );\n            }\n        }, VOID_DESERIALIZER );\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Client initClient()\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect( new InetSocketAddress( MasterServer.PORT ) );\n        return new Client( blockingReadHandler, channelFuture );\n    }","id":86154,"modified_method":"private static Client initClient()\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect( new InetSocketAddress( MasterServer.PORT ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        return client;\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception\n        {\n            ChannelBuffer message = (ChannelBuffer) e.getMessage();\n            handleRequest( realMaster, ctx, message );\n        }","id":86155,"modified_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception\n        {\n            ChannelBuffer message = (ChannelBuffer) e.getMessage();\n            e.getChannel().write( handleRequest( realMaster, message ) );\n        }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void shutdownDbsAndVerify() throws Exception\n    {\n        for ( StandaloneDbCom slave : slaveJvms )\n        {\n            slave.shutdown();\n        }\n        masterJvm.shutdown();\n        \n        GraphDatabaseService masterDb = new EmbeddedGraphDatabase( MASTER_PATH.getAbsolutePath() );\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            GraphDatabaseService slaveDb =\n                    new EmbeddedGraphDatabase( slavePath( i ).getAbsolutePath() );\n            verify( masterDb, slaveDb );\n        }\n    }","id":86156,"modified_method":"@After\n    public void shutdownDbsAndVerify() throws Exception\n    {\n        for ( StandaloneDbCom slave : slaveJvms )\n        {\n            slave.initiateShutdown();\n        }\n        masterJvm.initiateShutdown();\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            waitUntilShutdownFileFound( slavePath( i ) );\n        }\n        waitUntilShutdownFileFound( MASTER_PATH );\n        \n        GraphDatabaseService masterDb = new EmbeddedGraphDatabase( MASTER_PATH.getAbsolutePath() );\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            GraphDatabaseService slaveDb =\n                    new EmbeddedGraphDatabase( slavePath( i ).getAbsolutePath() );\n            verify( masterDb, slaveDb );\n        }\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Ignore\n    @Test\n    public void testTwoSlaves() throws Exception\n    {\n        initializeDbs( 2 );\n        StandaloneDbCom db1 = slaveJvms.get( 0 );\n        StandaloneDbCom db2 = slaveJvms.get( 1 );\n        final String name = \"Mattias\";\n        db1.executeJob( new Job<Void>()\n        {\n            public Void execute( GraphDatabaseService db )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    Node node = db.createNode();\n                    db.getReferenceNode().createRelationshipTo( node, REL_TYPE );\n                    node.setProperty( \"name\", name );\n                    tx.success();\n                }\n                finally\n                {\n                    tx.finish();\n                }\n                return null;\n            }\n        } );\n        \n        String readName = db2.executeJob( new Job<String>()\n        {\n            public String execute( GraphDatabaseService db )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    Node refNode = db.getReferenceNode();\n                    // To force it to pull updates\n                    refNode.removeProperty( \"yoyoyoyo\" );\n                    Node node = refNode.getSingleRelationship( REL_TYPE,\n                            Direction.OUTGOING ).getEndNode();\n                    String name = (String) node.getProperty( \"name\" );\n                    node.setProperty( \"title\", \"Whatever\" );\n                    tx.success();\n                    return name;\n                }\n                finally\n                {\n                    tx.finish();\n                }\n            }\n        } );\n        \n        assertEquals( name, readName );\n        db1.pullUpdates();\n    }","id":86157,"modified_method":"@Test\n    public void testTwoSlaves() throws Exception\n    {\n        initializeDbs( 2 );\n        StandaloneDbCom db1 = slaveJvms.get( 0 );\n        StandaloneDbCom db2 = slaveJvms.get( 1 );\n        final String name = \"Mattias\";\n        db1.executeJob( new CommonJobs.CreateSubRefNodeJob( name ) );\n        String readName = db2.executeJob( new CommonJobs.SetSubRefNameJob() );\n        \n        assertEquals( name, readName );\n        db1.pullUpdates();\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown() throws RemoteException\n    {\n        this.location.unbind( this );\n        this.shutdown = true;\n    }","id":86158,"modified_method":"public void initiateShutdown() throws RemoteException\n    {\n        println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        this.db.shutdown();\n        this.shutdown = true;\n        println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 500 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T executeJob( Job<T> job )\n    {\n        return job.execute( this.db );\n    }","id":86159,"modified_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        println( \"Job \" + job + \" executed\" );\n        return result;\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        db.pullUpdates();\n    }","id":86160,"modified_method":"public void pullUpdates()\n    {\n        println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws RemoteException\n    {\n        super();\n        \n        boolean isMaster = args.getBoolean( \"master\", null ).booleanValue();\n        String storeDir = args.get( \"path\", null );\n        AbstractBroker broker = isMaster ? new FakeMasterBroker() : new FakeSlaveBroker(\n                args.getNumber( \"id\", null ).intValue() );\n        this.db = new HighlyAvailableGraphDatabase( storeDir, new HashMap<String, String>(),\n                broker );\n        broker.setDb( this.db );\n        this.location = location;\n        this.location.ensureRegistryCreated();\n        this.location.bind( this );\n    }","id":86161,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        try\n        {\n            println( \"About to start\" );\n            boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n            AbstractBroker broker = isMaster ? new FakeMasterBroker() : new FakeSlaveBroker(\n                    args.getNumber( \"id\", null ).intValue() );\n            this.db = new HighlyAvailableGraphDatabase( storeDir, new HashMap<String, String>(),\n                    broker );\n            println( \"Started HA db\" );\n            broker.setDb( this.db );\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"07d99018a23b27a5478e425fc9e8063f7d840696","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n    protected static void handleRequest( Master realMaster,\n            @SuppressWarnings( \"unused\" ) ChannelHandlerContext ctx,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        // TODO: is this really how you write stuff back?!\n        type.serializer.write( response.response(), buffer );\n        writeTransactionStreams( response.transactions(), buffer );\n    }","id":86162,"modified_method":"@SuppressWarnings( \"unchecked\" )\n    protected static ChannelBuffer handleRequest( Master realMaster,\n            ChannelBuffer buffer ) throws IOException\n    {\n        RequestType type = RequestType.values()[buffer.readByte()];\n        final SlaveContext context = readSlaveContext( buffer );\n        Response<?> response = type.caller.callMaster( realMaster, context, buffer );\n        \n        ChannelBuffer targetBuffer = ChannelBuffers.dynamicBuffer();\n        type.serializer.write( response.response(), targetBuffer );\n        writeTransactionStreams( response.transactions(), targetBuffer );\n        return targetBuffer;\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int read( ByteBuffer dst ) throws IOException\n        {\n            if ( pos >= data.length ) return -1;\n            int size = Math.min( data.length - pos, dst.capacity() );\n            dst.put( data, pos, size );\n            pos += size;\n            return size;\n        }","id":86163,"modified_method":"public int read( ByteBuffer dst ) throws IOException\n        {\n            if ( pos >= data.length ) return -1;\n            int size = Math.min( data.length - pos, dst.limit() - dst.position() );\n            dst.put( data, pos, size );\n            pos += size;\n            return size;\n        }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean brokerSaysIAmMaster()\n    {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":86164,"modified_method":"private boolean brokerSaysIAmMaster()\n    {\n        return ((AbstractBroker) broker).noobYouAreTheMaster();\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, final String resource, final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","id":86165,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            final int eventIdentifier, final String resource,\n            final TransactionStream transactionStream )\n    {\n        return sendRequest( RequestType.COMMIT, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeInt( eventIdentifier );\n                writeString( buffer, resource );\n                writeTransactionStream(buffer, transactionStream);\n            }\n        }, new Deserializer<Long>()\n        {\n            @SuppressWarnings( \"boxing\" )\n            public Long read( ChannelBuffer buffer ) throws IOException\n            {\n                return buffer.readLong();\n            }\n        });\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        return sendRequest( RequestType.ROLLBACK, context, EMPTY_SERIALIZER, VOID_DESERIALIZER );\n    }","id":86166,"modified_method":"public Response<Void> rollbackTransaction( SlaveContext context, final int eventIdentifier )\n    {\n        return sendRequest( RequestType.ROLLBACK, context, new Serializer()\n        {\n            public void write( ChannelBuffer buffer ) throws IOException\n            {\n                buffer.writeInt( eventIdentifier );\n            }\n        }, VOID_DESERIALIZER );\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Client initClient()\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect( new InetSocketAddress( MasterServer.PORT ) );\n        return new Client( blockingReadHandler, channelFuture );\n    }","id":86167,"modified_method":"private static Client initClient()\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect( new InetSocketAddress( MasterServer.PORT ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        return client;\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception\n        {\n            ChannelBuffer message = (ChannelBuffer) e.getMessage();\n            handleRequest( realMaster, ctx, message );\n        }","id":86168,"modified_method":"@Override\n        public void messageReceived( ChannelHandlerContext ctx, MessageEvent e ) throws Exception\n        {\n            ChannelBuffer message = (ChannelBuffer) e.getMessage();\n            e.getChannel().write( handleRequest( realMaster, message ) );\n        }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n    public void shutdownDbsAndVerify() throws Exception\n    {\n        for ( StandaloneDbCom slave : slaveJvms )\n        {\n            slave.shutdown();\n        }\n        masterJvm.shutdown();\n        \n        GraphDatabaseService masterDb = new EmbeddedGraphDatabase( MASTER_PATH.getAbsolutePath() );\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            GraphDatabaseService slaveDb =\n                    new EmbeddedGraphDatabase( slavePath( i ).getAbsolutePath() );\n            verify( masterDb, slaveDb );\n        }\n    }","id":86169,"modified_method":"@After\n    public void shutdownDbsAndVerify() throws Exception\n    {\n        for ( StandaloneDbCom slave : slaveJvms )\n        {\n            slave.initiateShutdown();\n        }\n        masterJvm.initiateShutdown();\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            waitUntilShutdownFileFound( slavePath( i ) );\n        }\n        waitUntilShutdownFileFound( MASTER_PATH );\n        \n        GraphDatabaseService masterDb = new EmbeddedGraphDatabase( MASTER_PATH.getAbsolutePath() );\n        for ( int i = 0; i < slaveJvms.size(); i++ )\n        {\n            GraphDatabaseService slaveDb =\n                    new EmbeddedGraphDatabase( slavePath( i ).getAbsolutePath() );\n            verify( masterDb, slaveDb );\n        }\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Ignore\n    @Test\n    public void testTwoSlaves() throws Exception\n    {\n        initializeDbs( 2 );\n        StandaloneDbCom db1 = slaveJvms.get( 0 );\n        StandaloneDbCom db2 = slaveJvms.get( 1 );\n        final String name = \"Mattias\";\n        db1.executeJob( new Job<Void>()\n        {\n            public Void execute( GraphDatabaseService db )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    Node node = db.createNode();\n                    db.getReferenceNode().createRelationshipTo( node, REL_TYPE );\n                    node.setProperty( \"name\", name );\n                    tx.success();\n                }\n                finally\n                {\n                    tx.finish();\n                }\n                return null;\n            }\n        } );\n        \n        String readName = db2.executeJob( new Job<String>()\n        {\n            public String execute( GraphDatabaseService db )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    Node refNode = db.getReferenceNode();\n                    // To force it to pull updates\n                    refNode.removeProperty( \"yoyoyoyo\" );\n                    Node node = refNode.getSingleRelationship( REL_TYPE,\n                            Direction.OUTGOING ).getEndNode();\n                    String name = (String) node.getProperty( \"name\" );\n                    node.setProperty( \"title\", \"Whatever\" );\n                    tx.success();\n                    return name;\n                }\n                finally\n                {\n                    tx.finish();\n                }\n            }\n        } );\n        \n        assertEquals( name, readName );\n        db1.pullUpdates();\n    }","id":86170,"modified_method":"@Test\n    public void testTwoSlaves() throws Exception\n    {\n        initializeDbs( 2 );\n        StandaloneDbCom db1 = slaveJvms.get( 0 );\n        StandaloneDbCom db2 = slaveJvms.get( 1 );\n        final String name = \"Mattias\";\n        db1.executeJob( new CommonJobs.CreateSubRefNodeJob( name ) );\n        String readName = db2.executeJob( new CommonJobs.SetSubRefNameJob() );\n        \n        assertEquals( name, readName );\n        db1.pullUpdates();\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T executeJob( Job<T> job )\n    {\n        return job.execute( this.db );\n    }","id":86171,"modified_method":"public <T> T executeJob( Job<T> job ) throws RemoteException\n    {\n        println( \"Executing job \" + job );\n        T result = job.execute( this.db );\n        println( \"Job \" + job + \" executed\" );\n        return result;\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void pullUpdates()\n    {\n        db.pullUpdates();\n    }","id":86172,"modified_method":"public void pullUpdates()\n    {\n        println( \"pullUpdates\" );\n        db.pullUpdates();\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown() throws RemoteException\n    {\n        this.location.unbind( this );\n        this.shutdown = true;\n    }","id":86173,"modified_method":"public void initiateShutdown() throws RemoteException\n    {\n        println( \"Shutdown initiated\" );\n        this.location.unbind( this );\n        this.db.shutdown();\n        this.shutdown = true;\n        println( \"Shutdown done\" );\n        try\n        {\n            new File( new File( storeDir ), \"shutdown\" ).createNewFile();\n        }\n        catch ( IOException e )\n        {\n            println( \"Couldn't create file, damn it\", e );\n        }\n        new Thread()\n        {\n            public void run()\n            {\n                try\n                {\n                    Thread.sleep( 500 );\n                }\n                catch ( InterruptedException e )\n                {\n                    Thread.interrupted();\n                }\n                System.exit( 0 );\n            }\n        }.start();\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws RemoteException\n    {\n        super();\n        \n        boolean isMaster = args.getBoolean( \"master\", null ).booleanValue();\n        String storeDir = args.get( \"path\", null );\n        AbstractBroker broker = isMaster ? new FakeMasterBroker() : new FakeSlaveBroker(\n                args.getNumber( \"id\", null ).intValue() );\n        this.db = new HighlyAvailableGraphDatabase( storeDir, new HashMap<String, String>(),\n                broker );\n        broker.setDb( this.db );\n        this.location = location;\n        this.location.ensureRegistryCreated();\n        this.location.bind( this );\n    }","id":86174,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        try\n        {\n            println( \"About to start\" );\n            boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n            AbstractBroker broker = isMaster ? new FakeMasterBroker() : new FakeSlaveBroker(\n                    args.getNumber( \"id\", null ).intValue() );\n            this.db = new HighlyAvailableGraphDatabase( storeDir, new HashMap<String, String>(),\n                    broker );\n            println( \"Started HA db\" );\n            broker.setDb( this.db );\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"b1b1e2cf8a3b919bfae83c9b2683a3f89549b9e9","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n    * Expects {@link MyEntity} objects\n    * {@inheritDoc}\n    */\n   public String createEntity(EntityReference ref, Object entity, Map<String, Object> params) {\n      MyEntity me = (MyEntity) entity;\n      if (me.getStuff() == null) {\n         throw new IllegalArgumentException(\"stuff is not set, it is required\");\n      }\n      String newId = null;\n      int counter = 0;\n      while (newId == null) {\n         String id = \"my\"+counter++;\n         if (! myEntities.containsKey(id)) {\n            newId = id;\n         }\n      }\n      me.setId( newId );\n      myEntities.put(newId, me);\n      return newId;\n   }","id":86175,"modified_method":"/**\n    * Expects {@link MyEntity} objects\n    * {@inheritDoc}\n    */\n   public String createEntity(EntityReference ref, Object entity, Map<String, Object> params) {\n      MyEntity me = (MyEntity) entity;\n      if (me.getStuff() == null) {\n         throw new IllegalArgumentException(\"stuff is not set, it is required\");\n      }\n      String newId = me.getId();\n      int counter = 0;\n      if (newId == null || \"\".equals(newId)) {\n          while (newId == null) {\n             String id = \"my\"+counter++;\n             if (! myEntities.containsKey(id)) {\n                newId = id;\n             }\n          }\n          me.setId( newId );\n      }\n      myEntities.put(newId, me);\n      return newId;\n   }","commit_id":"9a3c36f1d4ede018cd19c4cd7a3e3d30aec022db","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Processing internal (EB) requests\n     * @return the result from the request (may be an error)\n     */\n    private ResponseBase generateInternalResult(String refKey, String reference, String entityURL, HttpServletRequest req, \n            HttpServletResponse res, Method method, Map<String, Map<String, String[]>> referencedParams) {\n        ResponseBase result = null;\n        ResponseError error = null;\n\n        /* WARNING: This is important to understand why this was done as is\n         * First of all, forget the servlet forwarding, it is hopeless.\n         * Why you ask? This is why, tomcat 5 has issues with calling forward using a set of custom\n         * httpservelet* objects, it REQUIRES objects that are tomcat objects and attempts to use and\n         * even cast to those objects. This causes 2 failures:\n         * 1) tomcat attempts to access specific attributes from the request which are not there in\n         * other request objects, thus it skips over processing the request entirely... without marking it as failed...\n         * 2) tomcat attempts to cast the response object to a tomcat object after most of the processing\n         * is complete and causes a ClassCastException which blows up everything\n         * \n         * The alternatives are using httpclient for everything (maybe not a bad plan)\n         * or calling the entity request handler directly, this has its own issues in that\n         * it actually causes problems with redirection and requires injecting things\n         * which depend on each other\n         * \n         * One last note on this, this all works fine in Jetty... tomcat fail\n         * Fun times for all\n         */\n\n        EntityHttpServletRequest entityRequest = new EntityHttpServletRequest(req, entityURL);\n        entityRequest.setContextPath(\"\");\n        if (Method.POST.equals(method) || Method.PUT.equals(method) ) {\n            // set only the unreferenced and correct referenced params for this request\n            log.warn(\"POST/PUT: Putting in params for key: \" + refKey);\n            entityRequest.clearParameters(); // also clears REFS_PARAM_NAME\n            entityRequest.setParameters( referencedParams.get(UNREFERENCED_PARAMS) );\n            String key = refKey + '.';\n            if (referencedParams.containsKey(key)) {\n                log.warn(\"Found RP for key: \" + key);\n                entityRequest.setParameters( referencedParams.get(key) );\n            }\n            // set the params from the query itself again\n            entityRequest.setParameters( entityRequest.pathQueryParams );\n            log.info(\"All request params: \" + entityRequest.getStringParameters());\n        } else {\n            entityRequest.removeParameter(REFS_PARAM_NAME); // make sure this is not passed along\n        }\n        entityRequest.setUseRealDispatcher(false); // we do not want to actually have the container handle forwarding\n        EntityHttpServletResponse entityResponse = new EntityHttpServletResponse(res);\n\n        boolean redirected = false;\n        do {\n            try {\n                entityRequestHandler.handleEntityAccess(entityRequest, entityResponse, null);\n                redirected = false; // assume no redirect\n            } catch (Exception e) {\n                String errorMessage = \"Failure attempting to process reference (\"+reference+\") for url (\"+entityURL+\"): \" + e.getMessage() + \":\" + e;\n                log.warn(errorMessage, e);\n                error = new ResponseError(reference, entityURL, errorMessage);\n                break; // take us out if there is a failure\n            }\n            // Must handle all redirects manually despite the annoyance - this is really crappy but oh well\n            if (entityResponse.isRedirected()) {\n                String redirectURL = entityResponse.getRedirectedUrl();\n                if (redirectURL == null || redirectURL.length() == 0) {\n                    throw new EntityException(\"Failed to find redirect URL when redirect was indicated by status (\"+entityResponse.getStatus()+\") for reference (\"+reference+\")\", reference);\n                }\n                entityURL = redirectURL;\n                // check that the redirect is not external\n                if ( entityURL.startsWith(servletContext) ) {\n                    // internal\n                    entityRequest.setPathString(redirectURL);\n                    entityResponse.reset();\n                    redirected = true;\n                } else {\n                    // TODO find a way to handle an external URL here\n                    redirected = false;\n                }\n            }\n        } while (redirected);\n\n        /** OLD CODE which can't work in tomcat 5\n        // setup the request and response objects to do the reference request\n        RequestDispatcher dispatcher = req.getRequestDispatcher(entityURL); // should only be the relative path from this webapp\n        // the request needs to get the full url or path though\n        EntityHttpServletRequest entityRequest = new EntityHttpServletRequest(req, req.getContextPath() + entityURL);\n        entityRequest.setContextPath(\"\");\n        entityRequest.removeParameter(REFS_PARAM_NAME); // make sure this is not passed along\n        EntityHttpServletResponse entityResponse = new EntityHttpServletResponse(res);\n\n        // fire off the URLs to the server and get back responses\n        try {\n            // need to forward instead of include to get headers back\n            dispatcher.forward(entityRequest, entityResponse);\n        } catch (Exception e) {\n            String errorMessage = \"Failure attempting to process reference (\"+reference+\"): \" + e.getMessage() + \":\" + e;\n            log.warn(errorMessage, e);\n            error = new ResponseError(reference, entityURL, errorMessage);\n        }\n         **/\n\n        // create the result object to encode and place into the final response\n        if (error == null) {\n            // all ok, create the result for the response object\n            // all cookies go into the main response\n            Cookie[] cookies = entityResponse.getCookies();\n            for (Cookie cookie : cookies) {\n                res.addCookie(cookie);\n            }\n            // status codes are compiled\n            int status = entityResponse.getStatus();\n            // create the result (with raw content)\n            result = new ResponseResult(reference, entityURL, status, entityResponse.getHeaders(), entityResponse.getContentAsString());\n        } else {\n            result = error;\n        }\n        return result;\n    }","id":86176,"modified_method":"/**\n     * Processing internal (EB) requests\n     * @return the result from the request (may be an error)\n     */\n    private ResponseBase generateInternalResult(String refKey, String reference, String entityURL, HttpServletRequest req, \n            HttpServletResponse res, Method method, Map<String, Map<String, String[]>> referencedParams) {\n        ResponseBase result = null;\n        ResponseError error = null;\n\n        /* WARNING: This is important to understand why this was done as is\n         * First of all, forget the servlet forwarding, it is hopeless.\n         * Why you ask? This is why, tomcat 5 has issues with calling forward using a set of custom\n         * httpservelet* objects, it REQUIRES objects that are tomcat objects and attempts to use and\n         * even cast to those objects. This causes 2 failures:\n         * 1) tomcat attempts to access specific attributes from the request which are not there in\n         * other request objects, thus it skips over processing the request entirely... without marking it as failed...\n         * 2) tomcat attempts to cast the response object to a tomcat object after most of the processing\n         * is complete and causes a ClassCastException which blows up everything\n         * \n         * The alternatives are using httpclient for everything (maybe not a bad plan)\n         * or calling the entity request handler directly, this has its own issues in that\n         * it actually causes problems with redirection and requires injecting things\n         * which depend on each other\n         * \n         * One last note on this, this all works fine in Jetty... tomcat fail\n         * Fun times for all\n         */\n\n        EntityHttpServletRequest entityRequest = new EntityHttpServletRequest(req, entityURL);\n        entityRequest.setContextPath(\"\");\n        if (Method.POST.equals(method) || Method.PUT.equals(method) ) {\n            // set only the unreferenced and correct referenced params for this request\n            entityRequest.clearParameters(); // also clears REFS_PARAM_NAME\n            entityRequest.setParameters( referencedParams.get(UNREFERENCED_PARAMS) );\n            String key = refKey + '.';\n            if (referencedParams.containsKey(key)) {\n                entityRequest.setParameters( referencedParams.get(key) );\n            }\n            // set the params from the query itself again\n            entityRequest.setParameters( entityRequest.pathQueryParams );\n            //log.info(\"All request params: \" + entityRequest.getStringParameters());\n        } else {\n            entityRequest.removeParameter(REFS_PARAM_NAME); // make sure this is not passed along\n        }\n        entityRequest.setUseRealDispatcher(false); // we do not want to actually have the container handle forwarding\n        EntityHttpServletResponse entityResponse = new EntityHttpServletResponse(res);\n\n        boolean redirected = false;\n        do {\n            try {\n                entityRequestHandler.handleEntityAccess(entityRequest, entityResponse, null);\n                redirected = false; // assume no redirect\n            } catch (Exception e) {\n                String errorMessage = \"Failure attempting to process reference (\"+reference+\") for url (\"+entityURL+\"): \" + e.getMessage() + \":\" + e;\n                log.warn(errorMessage, e);\n                error = new ResponseError(reference, entityURL, errorMessage);\n                break; // take us out if there is a failure\n            }\n            // Must handle all redirects manually despite the annoyance - this is really crappy but oh well\n            if (entityResponse.isRedirected()) {\n                String redirectURL = entityResponse.getRedirectedUrl();\n                if (redirectURL == null || redirectURL.length() == 0) {\n                    throw new EntityException(\"Failed to find redirect URL when redirect was indicated by status (\"+entityResponse.getStatus()+\") for reference (\"+reference+\")\", reference);\n                }\n                entityURL = redirectURL;\n                // check that the redirect is not external\n                if ( entityURL.startsWith(servletContext) ) {\n                    // internal\n                    entityRequest.setPathString(redirectURL);\n                    entityResponse.reset();\n                    redirected = true;\n                } else {\n                    // TODO find a way to handle an external URL here\n                    redirected = false;\n                }\n            }\n        } while (redirected);\n\n        /** OLD CODE which can't work in tomcat 5\n        // setup the request and response objects to do the reference request\n        RequestDispatcher dispatcher = req.getRequestDispatcher(entityURL); // should only be the relative path from this webapp\n        // the request needs to get the full url or path though\n        EntityHttpServletRequest entityRequest = new EntityHttpServletRequest(req, req.getContextPath() + entityURL);\n        entityRequest.setContextPath(\"\");\n        entityRequest.removeParameter(REFS_PARAM_NAME); // make sure this is not passed along\n        EntityHttpServletResponse entityResponse = new EntityHttpServletResponse(res);\n\n        // fire off the URLs to the server and get back responses\n        try {\n            // need to forward instead of include to get headers back\n            dispatcher.forward(entityRequest, entityResponse);\n        } catch (Exception e) {\n            String errorMessage = \"Failure attempting to process reference (\"+reference+\"): \" + e.getMessage() + \":\" + e;\n            log.warn(errorMessage, e);\n            error = new ResponseError(reference, entityURL, errorMessage);\n        }\n         **/\n\n        // create the result object to encode and place into the final response\n        if (error == null) {\n            // all ok, create the result for the response object\n            // all cookies go into the main response\n            Cookie[] cookies = entityResponse.getCookies();\n            for (Cookie cookie : cookies) {\n                res.addCookie(cookie);\n            }\n            // status codes are compiled\n            int status = entityResponse.getStatus();\n            // create the result (with raw content)\n            result = new ResponseResult(reference, entityURL, status, entityResponse.getHeaders(), entityResponse.getContentAsString());\n        } else {\n            result = error;\n        }\n        return result;\n    }","commit_id":"9a3c36f1d4ede018cd19c4cd7a3e3d30aec022db","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Handle the batch operations encoded in this view and request\n     * @param view the current view\n     * @param req the current request\n     * @param res the current response\n     */\n    public void handleBatch(EntityView view, HttpServletRequest req, HttpServletResponse res) {\n        if (view == null || req == null || res == null) {\n            throw new IllegalArgumentException(\"Could not process batch: invalid arguments, no args can be null (view=\"+view+\",req=\"+req+\",res=\"+res+\")\");\n        }\n\n        // set up the servlet context if this is the first time\n        if (this.servletContext == null) {\n            setServletContext( RequestUtils.getServletContext(req) );\n        }\n\n        // first find out which METHOD we are dealing with\n        String reqMethod = req.getMethod() == null ? EntityView.Method.GET.name() : req.getMethod().toUpperCase().trim();\n        Method method = HttpRESTUtils.makeMethodFromString(reqMethod);\n\n        if (Method.GET.equals(method) \n                || Method.POST.equals(method)\n                || Method.PUT.equals(method)\n                || Method.DELETE.equals(method)) {\n            // valid methods\n            res.setHeader(HEADER_BATCH_METHOD, method.name());\n        } else {\n            throw new IllegalArgumentException(\"Cannot batch \"+reqMethod+\" request method, cannot continue processing request: \" + view);\n        }\n\n        // now get to handling stuff\n        String format = view.getFormat();\n\n        // validate the the refs param\n        String[] refs = getRefsOrFail(req);\n\n        // decode the params into a set of reference params\n        Map<String, Map<String, String[]>> referencedParams = extractReferenceParams(req, method, refs);\n\n        // loop through all references\n        HashSet<String> processedRefsAndURLs = new HashSet<String>(); // holds all refs which we processed in this batch\n        HashMap<String, String> dataMap = new ArrayOrderedMap<String, String>(); // the returned content data from each ref\n        Map<String, ResponseBase> results = new ArrayOrderedMap<String, ResponseBase>(); // the results of all valid refs\n        boolean successOverall = false; // true if all ok or partial ok, false if exception occurs or all fail\n        boolean failure = false;\n        for (int i = 0; i < refs.length; i++) {\n            String refKey = \"ref\" + i;\n            String reference = refs[i];\n            // validate the reference is not blank\n            if (reference == null || \"\".equals(reference)) {\n                continue; // skip\n            }\n            // skip ones that are already done, we do not process twice unless it is a POST\n            if (! Method.POST.equals(method) \n                    && processedRefsAndURLs.contains(reference)) {\n                continue; // skip for GET/DELETE/PUT\n            }\n            String servletContext = getServletContext(); // will be the servlet context (e.g. /direct)\n            // fix anything that does not start with a slash or http\n            String entityURL = reference;\n            if (! reference.startsWith(\"/\") \n                    && ! reference.startsWith(\"http://\")) {\n                // assume this is an EB entity url without the slash\n                entityURL = servletContext + EntityView.SEPARATOR + reference;\n            }\n            // make sure no one tries to batch a batch\n            if (reference.startsWith(EntityRequestHandler.SLASH_BATCH)\n                    || reference.startsWith( getServletBatch() )) {\n                throw new EntityException(\"Failure processing batch request, \"\n                        + \"batch reference (\"+reference+\") (\"+entityURL+\") appears to be another \"\n                        + \"batch URL (contains \"+EntityRequestHandler.SLASH_BATCH+\"), \"\n                        + \"failure in batch request: \" + view,\n                        EntityRequestHandler.SLASH_BATCH, \n                        HttpServletResponse.SC_BAD_REQUEST);\n            }\n\n            // in case there are external ones we will reuse this httpclient\n            HttpClientWrapper clientWrapper = null;\n\n            // object will hold the results of this reference request\n            ResponseBase result = null;\n\n            // parse the entityURL, should hopefully not cause a failure\n            URLData ud = new URLData(entityURL);\n\n            /*\n             * identify the EB direct operations - \n             * this allows us to strip extensions and cleanup direct URLs as needed,\n             * possibly also handle these specially later on if desired,\n             * only EB operations can be handled internally\n             */\n            if ( servletContext.equals(ud.contextPath) ) {\n                if (ud.pathInfo == null || \"\".equals(ud.pathInfo)) {\n                    // looks like this servlet only with no path and we do not process that\n                    continue;\n                }\n\n                boolean success = false;\n                try {\n                    // parse the entityURL to verify it\n                    entityBrokerManager.parseReference(ud.pathInfo);\n                    success = true;\n                } catch (IllegalArgumentException e) {\n                    String errorMessage = \"Failure parsing direct entityURL (\"+entityURL+\") from reference (\"+reference+\") from path (\"+ud.pathInfo+\"): \" + e.getMessage() + \":\" + e.getCause();\n                    log.warn(errorMessage);\n                    result = new ResponseError(reference, entityURL, errorMessage);\n                }\n\n                if (success) {\n                    if (Method.GET.equals(method)) {\n                        // rebuild the entityURL with the correct extension in there for GET\n                        StringBuilder sb = new StringBuilder();\n                        sb.append( servletContext );\n                        sb.append(ud.pathInfoNoExtension);\n                        sb.append(EntityView.PERIOD);\n                        sb.append(format);\n                        if (ud.query.length() > 0) {\n                            // add on the query string\n                            sb.append('?');\n                            sb.append(ud.query);\n                        }\n                        entityURL = sb.toString();\n                    }\n\n                    // skip urls that are already done, we do not process twice\n                    if (processedRefsAndURLs.contains(entityURL)) {\n                        continue; // skip\n                    }\n\n                    result = generateInternalResult(refKey, reference, entityURL, req, res, method, referencedParams);\n                }\n\n            } else {\n                // non-EB URL so we have to fire it off using the HttpUtils\n\n                // http utils requires full URLs\n                entityURL = makeFullExternalURL(req, entityURL);\n\n                // set the client wrapper with cookies so we can reuse it for efficiency\n                if (clientWrapper == null) {\n                    clientWrapper = HttpRESTUtils.makeReusableHttpClient(false, 0, req.getCookies());\n                }\n                result = generateExternalResult(refKey, reference, entityURL, method, referencedParams, clientWrapper);\n            }\n\n            // special handling for null result (should really not happen unless there was a logic error)\n            if (result == null) {\n                successOverall = false;\n                failure = true;\n                throw new IllegalStateException(\"Somehow the result is null, this should never happen, fatal error\");\n            }\n\n            if (result instanceof ResponseError) {\n                // looks like a failure occurred, keep going though\n                successOverall = false;\n                failure = true;\n            } else {\n                // all ok, process data\n                int status = result.getStatus();\n                if (status >= 200 && status < 300) {\n                    successOverall = true;\n                }\n                if (status == HttpServletResponse.SC_NO_CONTENT) {\n                    // no content to process\n                    ((ResponseResult)result).content = null;\n                    ((ResponseResult)result).data = null;\n                } else {\n                    // process the content and see if it matches the expected result, if not we have to dump it in escaped\n                    String content = ((ResponseResult)result).content;\n                    String dataKey = checkContent(format, content, refKey, dataMap);\n                    ((ResponseResult)result).setDataKey(dataKey);\n                }\n            }\n\n            // store the processed ref and url so we do not do them again\n            processedRefsAndURLs.add(reference);\n            processedRefsAndURLs.add(entityURL);\n            results.put(refKey, result); // use an artificial key\n        }\n\n        // determine overall status\n        int overallStatus = HttpServletResponse.SC_OK;\n        if (failure == true || successOverall == false) {\n            overallStatus = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n        }\n\n        // die if every ref was invalid\n        if (results.size() == 0) {\n            throw new EntityException(\"Invalid request which resulted in no valid references to batch process, original _refs=(\"\n                    +ArrayUtils.arrayToString(refs)+\")\", EntityRequestHandler.SLASH_BATCH, HttpServletResponse.SC_BAD_REQUEST);\n        }\n\n        // compile all the responses into encoded data\n        String overallData = entityEncodingManager.encodeData(results, format, \"refs\", null);\n        // replace the data unique keys if there are any\n        overallData = reintegrateDataContent(format, dataMap, overallData);\n\n        // put response, headers, and code into the http response\n        applyOverallHeaders(res, results);\n        // put content into the response\n        try {\n            res.getWriter().write(overallData);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to encode data for overall response: \" + e.getMessage(), e);\n        }\n        // set overall status code\n        res.setStatus(overallStatus);\n    }","id":86177,"modified_method":"/**\n     * Handle the batch operations encoded in this view and request\n     * @param view the current view\n     * @param req the current request\n     * @param res the current response\n     */\n    public void handleBatch(EntityView view, HttpServletRequest req, HttpServletResponse res) {\n        if (view == null || req == null || res == null) {\n            throw new IllegalArgumentException(\"Could not process batch: invalid arguments, no args can be null (view=\"+view+\",req=\"+req+\",res=\"+res+\")\");\n        }\n\n        // set up the servlet context if this is the first time\n        if (this.servletContext == null) {\n            setServletContext( RequestUtils.getServletContext(req) );\n        }\n\n        // first find out which METHOD we are dealing with\n        String reqMethod = req.getMethod() == null ? EntityView.Method.GET.name() : req.getMethod().toUpperCase().trim();\n        Method method = HttpRESTUtils.makeMethodFromString(reqMethod);\n\n        if (Method.GET.equals(method) \n                || Method.POST.equals(method)\n                || Method.PUT.equals(method)\n                || Method.DELETE.equals(method)) {\n            // valid methods\n            res.setHeader(HEADER_BATCH_METHOD, method.name());\n        } else {\n            throw new IllegalArgumentException(\"Cannot batch \"+reqMethod+\" request method, cannot continue processing request: \" + view);\n        }\n\n        // now get to handling stuff\n        String format = view.getFormat();\n        String servletContext = getServletContext(); // will be the servlet context (e.g. /direct)\n\n        // validate the the refs param\n        String[] refs = getRefsOrFail(req);\n\n        // decode the params into a set of reference params\n        Map<String, Map<String, String[]>> referencedParams = extractReferenceParams(req, method, refs);\n\n        // loop through all references\n        HashSet<String> processedRefsAndURLs = new HashSet<String>(); // holds all refs which we processed in this batch\n        HashMap<String, String> dataMap = new ArrayOrderedMap<String, String>(); // the returned content data from each ref\n        Map<String, ResponseBase> results = new ArrayOrderedMap<String, ResponseBase>(); // the results of all valid refs\n        boolean successOverall = false; // true if all ok or partial ok, false if exception occurs or all fail\n        boolean failure = false;\n        for (int i = 0; i < refs.length; i++) {\n            String refKey = \"ref\" + i;\n            String reference = refs[i];\n            // validate the reference is not blank\n            if (reference == null || \"\".equals(reference)) {\n                continue; // skip\n            }\n            // skip ones that are already done, we do not process twice unless it is a POST\n            if (! Method.POST.equals(method) \n                    && processedRefsAndURLs.contains(reference)) {\n                continue; // skip for GET/DELETE/PUT\n            }\n            // fix anything that does not start with a slash or http\n            String entityURL = reference;\n            if (! reference.startsWith(\"/\") \n                    && ! reference.startsWith(\"http://\")) {\n                // assume this is an EB entity url without the slash\n                entityURL = servletContext + EntityView.SEPARATOR + reference;\n            }\n            // make sure no one tries to batch a batch\n            if (reference.startsWith(EntityRequestHandler.SLASH_BATCH)\n                    || reference.startsWith( getServletBatch() )) {\n                throw new EntityException(\"Failure processing batch request, \"\n                        + \"batch reference (\"+reference+\") (\"+entityURL+\") appears to be another \"\n                        + \"batch URL (contains \"+EntityRequestHandler.SLASH_BATCH+\"), \"\n                        + \"failure in batch request: \" + view,\n                        EntityRequestHandler.SLASH_BATCH, \n                        HttpServletResponse.SC_BAD_REQUEST);\n            }\n\n            // in case there are external ones we will reuse this httpclient\n            HttpClientWrapper clientWrapper = null;\n\n            // object will hold the results of this reference request\n            ResponseBase result = null;\n\n            // parse the entityURL, should hopefully not cause a failure\n            URLData ud = new URLData(entityURL);\n\n            /*\n             * identify the EB direct operations - \n             * this allows us to strip extensions and cleanup direct URLs as needed,\n             * possibly also handle these specially later on if desired,\n             * only EB operations can be handled internally\n             */\n            if ( servletContext.equals(ud.contextPath) ) {\n                if (ud.pathInfo == null || \"\".equals(ud.pathInfo)) {\n                    // looks like this servlet only with no path and we do not process that\n                    continue;\n                }\n\n                boolean success = false;\n                try {\n                    // parse the entityURL to verify it\n                    entityBrokerManager.parseReference(ud.pathInfo);\n                    success = true;\n                } catch (IllegalArgumentException e) {\n                    String errorMessage = \"Failure parsing direct entityURL (\"+entityURL+\") from reference (\"+reference+\") from path (\"+ud.pathInfo+\"): \" + e.getMessage() + \":\" + e.getCause();\n                    log.warn(errorMessage);\n                    result = new ResponseError(reference, entityURL, errorMessage);\n                }\n\n                if (success) {\n                    if (Method.GET.equals(method)) {\n                        // rebuild the entityURL with the correct extension in there for GET\n                        StringBuilder sb = new StringBuilder();\n                        sb.append( servletContext );\n                        sb.append(ud.pathInfoNoExtension);\n                        sb.append(EntityView.PERIOD);\n                        sb.append(format);\n                        if (ud.query.length() > 0) {\n                            // add on the query string\n                            sb.append('?');\n                            sb.append(ud.query);\n                        }\n                        entityURL = sb.toString();\n                    }\n\n                    // skip urls that are already done, we do not process twice\n                    if (! Method.POST.equals(method) \n                            && processedRefsAndURLs.contains(entityURL)) {\n                        continue; // skip\n                    }\n\n                    result = generateInternalResult(refKey, reference, entityURL, req, res, method, referencedParams);\n                }\n\n            } else {\n                // non-EB URL so we have to fire it off using the HttpUtils\n\n                // http utils requires full URLs\n                entityURL = makeFullExternalURL(req, entityURL);\n\n                // set the client wrapper with cookies so we can reuse it for efficiency\n                if (clientWrapper == null) {\n                    clientWrapper = HttpRESTUtils.makeReusableHttpClient(false, 0, req.getCookies());\n                }\n                result = generateExternalResult(refKey, reference, entityURL, method, referencedParams, clientWrapper);\n            }\n\n            // special handling for null result (should really not happen unless there was a logic error)\n            if (result == null) {\n                successOverall = false;\n                failure = true;\n                throw new IllegalStateException(\"Somehow the result is null, this should never happen, fatal error\");\n            }\n\n            if (result instanceof ResponseError) {\n                // looks like a failure occurred, keep going though\n                successOverall = false;\n                failure = true;\n            } else {\n                // all ok, process data\n                int status = result.getStatus();\n                if (status >= 200 && status < 300) {\n                    successOverall = true;\n                }\n                if (status == HttpServletResponse.SC_NO_CONTENT) {\n                    // no content to process\n                    ((ResponseResult)result).content = null;\n                    ((ResponseResult)result).data = null;\n                } else {\n                    // process the content and see if it matches the expected result, if not we have to dump it in escaped\n                    String content = ((ResponseResult)result).content;\n                    String dataKey = checkContent(format, content, refKey, dataMap);\n                    ((ResponseResult)result).setDataKey(dataKey);\n                }\n            }\n\n            // store the processed ref and url so we do not do them again\n            processedRefsAndURLs.add(reference);\n            processedRefsAndURLs.add(entityURL);\n            results.put(refKey, result); // use an artificial key\n        }\n\n        // determine overall status\n        int overallStatus = HttpServletResponse.SC_OK;\n        if (failure == true || successOverall == false) {\n            overallStatus = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n        }\n\n        // die if every ref was invalid\n        if (results.size() == 0) {\n            throw new EntityException(\"Invalid request which resulted in no valid references to batch process, original _refs=(\"\n                    +ArrayUtils.arrayToString(refs)+\")\", EntityRequestHandler.SLASH_BATCH, HttpServletResponse.SC_BAD_REQUEST);\n        }\n\n        // compile all the responses into encoded data\n        String overallData = entityEncodingManager.encodeData(results, format, \"refs\", null);\n        // replace the data unique keys if there are any\n        overallData = reintegrateDataContent(format, dataMap, overallData);\n\n        // put response, headers, and code into the http response\n        applyOverallHeaders(res, results);\n        // put content into the response\n        try {\n            res.getWriter().write(overallData);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unable to encode data for overall response: \" + e.getMessage(), e);\n        }\n        // set overall status code\n        res.setStatus(overallStatus);\n    }","commit_id":"9a3c36f1d4ede018cd19c4cd7a3e3d30aec022db","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Fires off a request using Jetty to the given uri (uses GET by default),\n     * also resets the request afterward so it can be used again if desired\n     * @param uri any uri which you want to test (should be valid for the test)\n     */\n    protected void fireRequest(String uri) {\n        this.response = new HttpTester(); // build a new response\n        this.request.setMethod(\"GET\");\n        this.request.setURI(uri);\n        try {\n            this.response.parse(tester.getResponses(request.generate()));\n        } catch (Exception e) {\n            fail(\"Could not parse the response to the request (\"+uri+\"): \" + e.getMessage());\n        }\n        prepareRequest(); // reset the request\n    }","id":86178,"modified_method":"/**\n     * Fires off a request using Jetty to the given uri (uses GET by default),\n     * also resets the request afterward so it can be used again if desired\n     * @param uri any uri which you want to test (should be valid for the test)\n     */\n    protected void fireRequest(String uri) {\n        fireRequest(uri, null, null);\n    }","commit_id":"9a3c36f1d4ede018cd19c4cd7a3e3d30aec022db","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * If this param is set then the sakai session for the current request is set to this rather than establishing one,\n     * will allow changing the session as well\n     */\n\n    /* (non-Javadoc)\n     * @see org.sakaiproject.entitybroker.EntityRequestHandler#handleEntityAccess(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public String handleEntityAccess(HttpServletRequest req, HttpServletResponse res, String path) {\n        // set the servlet context if not set\n        if (this.servletContext == null) {\n            setServletContext( RequestUtils.getServletContext(req) );\n        }\n\n        // get the path info if not set\n        if (path == null) {\n            path = req.getPathInfo();\n        }\n\n        String handledReference = null;\n\n        // special handling in case the session ID is sent in the request \n        // (allows setting up and reusing a session over and over without holding cookies)\n        if (entityBrokerManager.getExternalIntegrationProvider() != null) {\n            try {\n                entityBrokerManager.getExternalIntegrationProvider().handleUserSessionKey(req);\n            } catch (Exception e) {\n                log.warn(\"External handleUserSessionKey method failed, continuing...: \" + e);\n            }\n        }\n\n        if (path == null || \"\".equals(path) || \"/\".equals(path)) {\n            // SPECIAL handling for empty path\n            res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n            try {\n                res.sendRedirect( res.encodeRedirectURL(getServletContext() + SLASH_DESCRIBE) );\n            } catch (IOException e) {\n                // should never happen\n                throw new RuntimeException(\"Could not encode the redirect URL\");\n            }\n            // immediate exit from redirect\n            return \"/\";\n        } else {\n            // regular handling for direct URLs\n            if ( (SLASH_DESCRIBE).equals(path) \n                    || path.startsWith(SLASH_DESCRIBE + EntityReference.PERIOD)) {\n                // SPECIAL handling for the describe all URL\n                String format = TemplateParseUtil.findExtension(path)[2];\n                if (format == null) {\n                    format = Formats.HTML;\n                }\n                RequestUtils.setResponseEncoding(format, res);\n                String output = entityDescriptionManager.makeDescribeAll(format, req.getLocale()); // possibly get the locale from other places?\n                res.setContentLength(output.getBytes().length);\n                try {\n                    res.getWriter().write(output);\n                } catch (IOException e) {\n                    // should never happen\n                    throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                }\n                res.setStatus(HttpServletResponse.SC_OK);\n                handledReference = EntityView.SEPARATOR+\"\";\n            } else {\n                // STANDARD processing for the incoming view\n                EntityView view;\n                try {\n                    view = entityBrokerManager.parseEntityURL(path);\n                } catch (IllegalArgumentException e) {\n                    // FAILURE indicates we could not parse the reference\n                    throw new EntityException(\"Could not parse entity path (\"+path+\"): \" + e.getMessage(), path, HttpServletResponse.SC_BAD_REQUEST);\n                }\n\n                if (view == null) {\n                    // FAILURE no provider for this entity prefix\n                    throw new EntityException( \"Could not parse the incoming path (\"+path+\") and no entity provider could be found to handle the prefix\", \n                            path, HttpServletResponse.SC_NOT_IMPLEMENTED );\n                } else if ( DESCRIBE.equals(view.getEntityReference().getId()) ) {\n                    // SPECIAL handling for entity describe URLs\n                    String format = TemplateParseUtil.findExtension(path)[2];\n                    if (format == null) {\n                        format = Formats.HTML;\n                    }\n                    RequestUtils.setResponseEncoding(format, res);\n                    String entityId = req.getParameter(\"_id\");\n                    if (entityId == null || \"\".equals(entityId)) {\n                        entityId = FAKE_ID;\n                    }\n                    String output = entityDescriptionManager.makeDescribeEntity(view.getEntityReference().getPrefix(), entityId, format, req.getLocale());\n                    res.setContentLength(output.getBytes().length);\n                    try {\n                        res.getWriter().write(output);\n                    } catch (IOException e) {\n                        throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    handledReference = view.getEntityReference().getSpaceReference() + SLASH_DESCRIBE;\n\n                } else {\n                    // STANDARD reference successfully parsed\n                    String prefix = view.getEntityReference().getPrefix();\n\n                    // check for redirect\n                    Redirectable urlConfigurable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Redirectable.class);\n                    if (urlConfigurable != null) {\n                        // SPECIAL check for redirect\n                        String redirectURL = entityRedirectsManager.checkForTemplateMatch(urlConfigurable, path, req.getQueryString());\n                        if (redirectURL != null) {\n                            // SPECIAL handling for redirect\n                            if (\"\".equals(redirectURL)) {\n                                // do nothing but return an empty response\n                                res.setStatus(HttpServletResponse.SC_OK);\n                            } else {\n                                // do the redirect\n                                log.info(\"Entity Redirect: redirecting from (\"+path+\") to (\"+redirectURL+\")\");\n                                RequestUtils.handleURLRedirect(redirectURL, true, req, res);\n                            }\n                            return EntityView.SEPARATOR + prefix; // exit here for redirects\n                        }\n                    }\n\n                    // check for custom action\n                    CustomAction customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(1));\n                    if (customAction == null) {\n                        customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(2));\n                    }\n                    if (customAction == null) {\n                        // check to see if the entity exists\n                        if (! entityBrokerManager.entityExists(view.getEntityReference()) ) {\n                            // FAILURE invalid entity reference (entity does not exist)\n                            throw new EntityException( \"Attempted to access an entity URL path (\" + path + \") for an entity (\"\n                                    + view.getEntityReference() + \") that does not exist\", \n                                    view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                        }\n                    } else {\n                        // cleanup the entity reference, this has to be done because otherwise the custom action\n                        // on collections appears to be the id of an entity in the collection\n                        EntityReference cRef = view.getEntityReference();\n                        if (cRef.getId().equals(customAction.action)) {\n                            view.setEntityReference( new EntityReference(prefix, \"\") );\n                        }\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK); // default - other things can switch this later on\n\n                    // store format in attribute\n                    req.setAttribute(\"entity-format\", view.getFormat());\n\n                    // STANDARD initial processing complete\n                    // wrap in try block so that request storage is always cleaned up\n                    try {\n                        // store the current request and response\n                        requestGetter.setRequest(req);\n                        requestGetter.setResponse(res);\n                        // set the request variables\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), view.getEntityReference().toString());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestOrigin.name(), RequestStorage.RequestOrigin.REST.name());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestActive.name(), true);\n\n                        // handle the before interceptor\n                        RequestInterceptor interceptor = (RequestInterceptor) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestInterceptor.class);\n                        if (interceptor != null) {\n                            interceptor.before(view, req, res);\n                        }\n\n                        if (BATCH.equals(prefix)) {\n                            // special batch handling\n                            if (view.getExtension() == null) {\n                                // default extension is JSON\n                                view.setExtension(Formats.JSON);\n                            }\n                            entityBatchHandler.handleBatch(view, req, res);\n                        } else {\n                            // check for provider handling of this request\n                            RequestHandler handler = (RequestHandler) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestHandler.class);\n                            if (handler != null) {\n                                // SPECIAL provider is handling this request\n                                handleClassLoaderAccess(handler, req, res, view);\n                            } else {\n                                // STANDARD processing of the entity request internally start here\n                                // try to handle the request internally if possible\n    \n                                // identify the type of request (input or output) and the action (will be encoded in the viewKey)\n                                boolean output = RequestUtils.isRequestOutput(req, view);\n                                setResponseHeaders(view, res, requestStorage.getStorageMapCopy(), null);\n    \n                                boolean handled = false;\n                                // PROCESS CUSTOM ACTIONS\n                                ActionReturn actionReturn = null;\n                                if (customAction != null) {\n                                    // SPECIAL handle the custom action\n                                    ActionsExecutable actionProvider = entityProviderManager.getProviderByPrefixAndCapability(prefix, ActionsExecutable.class);\n                                    if (actionProvider == null) {\n                                        throw new EntityException( \"The provider for prefix (\"+prefix+\") cannot handle custom actions\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    // make sure this request is a valid type for this action\n                                    if (customAction.viewKey != null \n                                            && ! view.getViewKey().equals(customAction.viewKey)) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\") for request method \" + req.getMethod()\n                                                + \", The custom action view key (\"+customAction.viewKey+\") must match the request view key (\"+view.getViewKey()+\")\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    try {\n                                        actionReturn = entityActionsManager.handleCustomActionRequest(actionProvider, view, customAction.action, req, res, \n                                                requestStorage.getStorageMapCopy(true, false, true, true) );\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityNotFoundException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not find entity (\"+e.entityReference+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                                    } catch (FormatUnsupportedException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Format not supported (\"+e.format+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_ACCEPTABLE );\n                                    } catch (IllegalArgumentException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Illegal arguments: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    } catch (UnsupportedOperationException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not execute action: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    if (actionReturn == null \n                                            || actionReturn.output != null) {\n                                        // custom action processing complete\n                                        /* actionReturn.output != null - this means that there is an \n                                         * outputstream set and that the encoding has been,\n                                         * handled, however, the response status code should be set still\n                                         */\n                                        handled = true;\n                                    } else {\n                                        // if there are headers then set them now\n                                        addResponseHeaders(res, actionReturn.getHeaders());\n                                        // if the custom action returned entity data then we will encode it for output\n                                        if (actionReturn.entitiesList == null\n                                                && actionReturn.entityData == null) {\n                                            handled = true;\n                                        } else {\n                                            // there is entity data to return\n                                            output = true;\n                                            handled = false;\n                                            // populate the entity data\n                                            if (actionReturn.entitiesList != null) {\n                                                if (actionReturn.entitiesList.size() > 1) {\n                                                    // correct the view key which should be used now\n                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                }\n                                                entityBrokerManager.populateEntityData(actionReturn.entitiesList);\n                                            } else if (actionReturn.entityData != null) {\n                                                // correct the view key which should be used now\n                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                entityBrokerManager.populateEntityData( new EntityData[] {actionReturn.entityData} );\n                                            }\n                                        }\n                                    }\n                                }\n    \n                                boolean formatInvalidFailure = false;\n                                if (!handled) {\n                                    // INTERNAL PROCESSING OF REQUEST\n                                    try {\n                                        String format = view.getFormat();\n                                        if (output) {\n                                            // output request\n                                            String viewKey = view.getViewKey();\n                                            if (EntityView.VIEW_NEW.equals(viewKey)\n                                                    || EntityView.VIEW_EDIT.equals(viewKey) \n                                                    || EntityView.VIEW_DELETE.equals(viewKey) ) {\n                                                // request for the create/edit/delete entity forms\n                                                // TODO possibly generate new/edit/delete forms internally?\n                                                handled = false;\n                                            } else {\n                                                Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                                                if (outputable != null) {\n                                                    if (customAction != null) {\n                                                        // override format from the custom action\n                                                        if (actionReturn != null \n                                                                && actionReturn.format != null) {\n                                                            format = actionReturn.format;\n                                                        }\n                                                    }\n                                                    String[] outputFormats = outputable.getHandledOutputFormats();\n                                                    if (outputFormats == null || ReflectUtils.contains(outputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        RequestUtils.setResponseEncoding(format, res);\n    \n                                                        EntityReference ref = view.getEntityReference();\n                                                        // get the entities to output\n                                                        List<EntityData> entities = null;\n                                                        if (customAction != null \n                                                                && actionReturn != null) {\n                                                            // get entities from a custom action\n                                                            entities = actionReturn.entitiesList;\n                                                            if (entities != null) {\n                                                                // recode the collection\n                                                                if (entities.size() > 0) {\n                                                                    EntityData ed = entities.get(0);\n                                                                    ref = new EntityReference(ed.getEntityRef().getPrefix(), \"\");\n                                                                    view.setEntityReference( ref );\n                                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                                }\n                                                            } else if (actionReturn.entityData != null) {\n                                                                // this was a single object return so it should be encoded as such, thus we will recode the correct reference into the view\n                                                                ArrayList<EntityData> eList = new ArrayList<EntityData>();\n                                                                EntityData ed = actionReturn.entityData;\n                                                                // set title if not set\n                                                                if (! ed.isDisplayTitleSet()) {\n                                                                    ed.setDisplayTitle(customAction.action);\n                                                                }\n                                                                // add to list\n                                                                eList.add( ed );\n                                                                entities = eList;\n                                                                // make entity reference\n                                                                ref = ed.getEntityRef();\n                                                                if (ref == null) {\n                                                                    ref = new EntityReference(prefix, customAction.action);\n                                                                } else if (ref.getId() == null) {\n                                                                    ref = new EntityReference(ref.getPrefix(), customAction.action);\n                                                                }\n                                                                view.setEntityReference( ref );\n                                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                            }\n                                                        } else {\n                                                            // get from a search\n                                                            Search search = RequestUtils.makeSearchFromRequestParams(requestStorage.getStorageMapCopy(true, false, true, true)); // leave out headers));\n                                                            entities = entityBrokerManager.getEntitiesData(ref, search, requestStorage.getStorageMapCopy());\n                                                        }\n                                                        // set the modified header (use the sole entity in the list if there is one only)\n                                                        setLastModifiedHeaders(res, (entities != null && entities.size()==1 ? entities.get(0) : null), System.currentTimeMillis());\n    \n                                                        if (EntityView.Method.HEAD.name().equals(view.getMethod())) {\n                                                            // HEADER only\n                                                            res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                        } else {\n                                                            // GET\n                                                            OutputStream outputStream = new LazyResponseOutputStream(res);\n    \n                                                            /* try to use the provider formatter if one available,\n                                                             * if it decided not to handle it or none is available then control passes to internal\n                                                             */\n                                                            try {\n                                                                OutputFormattable formattable = (OutputFormattable) entityProviderManager.getProviderByPrefixAndCapability(prefix, OutputFormattable.class);\n                                                                if (formattable != null) {\n                                                                    // use provider's formatter\n                                                                    formattable.formatOutput(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream);\n                                                                    handled = true;\n                                                                }\n                                                            } catch (FormatUnsupportedException e) {\n                                                                // provider decided not to handle this format\n                                                                handled = false;\n                                                            }\n                                                            if (!handled) {\n                                                                // handle internally or fail\n                                                                entityEncodingManager.internalOutputFormatter(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream, view);\n                                                            }\n                                                            handled = true;\n                                                            res.setStatus(HttpServletResponse.SC_OK);\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Outputable restriction for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            // input request\n                                            if (EntityView.VIEW_DELETE.equals(view.getViewKey())) {\n                                                // delete request\n                                                Deleteable deleteable = (Deleteable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Deleteable.class);\n                                                if (deleteable != null) {\n                                                    deleteable.deleteEntity(view.getEntityReference(), requestStorage.getStorageMapCopy());\n                                                    res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                    handled = true;\n                                                }\n                                            } else {\n                                                // save request\n                                                Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Inputable.class);\n                                                if (inputable != null) {\n                                                    String[] inputFormats = inputable.getHandledInputFormats();\n                                                    if (inputFormats == null || ReflectUtils.contains(inputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        Object entity = null;\n                                                        InputStream inputStream = null;\n                                                        try {\n                                                            inputStream = req.getInputStream();\n                                                        } catch (IOException e) {\n                                                            throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                                                        }\n    \n                                                        /* try to use the provider translator if one available,\n                                                         * if it decided not to handle it or none is available then control passes to internal\n                                                         */\n                                                        try {\n                                                            InputTranslatable translatable = (InputTranslatable) entityProviderManager.getProviderByPrefixAndCapability(prefix, InputTranslatable.class);\n                                                            if (translatable != null) {\n                                                                // use provider's translator\n                                                                entity = translatable.translateFormattedData(view.getEntityReference(), \n                                                                        format, inputStream, requestStorage.getStorageMapCopy());\n                                                                handled = true;\n                                                            }\n                                                        } catch (FormatUnsupportedException e) {\n                                                            // provider decided not to handle this format\n                                                            handled = false;\n                                                        }\n                                                        if (!handled) {\n                                                            // use internal translators or fail\n                                                            entity = entityEncodingManager.internalInputTranslator(view.getEntityReference(), \n                                                                    format, inputStream, req);\n                                                        }\n    \n                                                        if (entity == null) {\n                                                            // FAILURE input could not be translated into an entity object\n                                                            handled = false;\n                                                            throw new EntityException(\"Unable to save entity (\"+view.getEntityReference()+\") with format (\"\n                                                                    +format+\"), translated entity object was null\", \n                                                                    view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                                                        } else {\n                                                            // setup all the headers for the response\n                                                            if (EntityView.VIEW_NEW.equals(view.getViewKey())) {\n                                                                Createable createable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Createable.class);\n                                                                if (createable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Createable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                String createdId = createable.createEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                view.setEntityReference( new EntityReference(prefix, createdId) ); // update the entity view\n                                                                res.setHeader(EntityRequestHandler.HEADER_ENTITY_ID, createdId);\n                                                                res.setStatus(HttpServletResponse.SC_CREATED);\n                                                                // added the id to the response to make it easier on Nico\n                                                                try {\n                                                                    OutputStream outputStream = res.getOutputStream();\n                                                                    outputStream.write( createdId.getBytes() );\n                                                                } catch (IOException e) {\n                                                                    // oh well, no id in the output\n                                                                } catch (RuntimeException e) {\n                                                                    // oh well, no id in the output\n                                                                }\n                                                            } else if (EntityView.VIEW_EDIT.equals(view.getViewKey())) {\n                                                                Updateable updateable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Updateable.class);\n                                                                if (updateable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Updateable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                updateable.updateEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                            } else {\n                                                                // FAILURE not delete, edit, or new\n                                                                throw new EntityException(\"Unable to handle entity input (\"+view.getEntityReference()+\"), \" +\n                                                                        \"action was not understood: \" + view.getViewKey(), \n                                                                        view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n                                                            }\n                                                            // return the location of this updated or created entity (without any extension)\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_URL, view.getEntityURL() );\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE, view.getEntityReference().toString() );\n                                                            handled = true;\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Inputable restriction for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // this format could not be handled internally so we will pass it to the access provider, nothing else to do here\n                                        formatInvalidFailure = true;\n                                        handled = false;\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityEncodingException e) {\n                                        // translate EEE into EE - internal server error\n                                        throw new EntityException(\"EntityEncodingException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);        \n                                    } catch (IllegalArgumentException e) {\n                                        // translate IAE into EE - bad request\n                                        throw new EntityException(\"IllegalArgumentException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);        \n                                    } catch (IllegalStateException e) {\n                                        // translate ISE into EE - internal server error\n                                        throw new EntityException(\"IllegalStateException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                                    }\n                                }\n    \n                                if (! handled) {\n                                    // default handling, send to the access provider if there is one (if none this will throw EntityException)\n                                    try {\n                                        boolean accessProviderExists = handleAccessProvider(view, req, res);\n                                        if (!accessProviderExists) {\n                                            if (formatInvalidFailure) {\n                                                // trigger the format \n                                                throw new FormatUnsupportedException(\"Nothing (AP and internal) available to handle the requested format\", view.getEntityReference()+\"\", view.getFormat());\n                                            }\n                                            String message = \"Access Provider: Attempted to access an entity URL path (\"\n                                                + view + \") using method (\"+view.getMethod()+\") for an entity (\" + view.getEntityReference() \n                                                + \") and view (\"+view.getViewKey()+\") when there is no \" \n                                                + \"access provider to handle the request for prefix (\" + view.getEntityReference().getPrefix() + \")\";\n                                            throw new EntityException( message, view.toString(), HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // TODO add in the methods \"allowed\" header?\n                                        throw new EntityException( \"AccessProvider: Method/Format unsupported: Will not handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \")\",\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                }\n                            }\n                        }\n                        handledReference = view.getEntityReference().toString();\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), handledReference);\n\n                        // handle the after interceptor\n                        if (interceptor != null) {\n                            interceptor.after(view, req, res);\n                        }\n                    } finally {\n                        // clear the request data no matter what happens\n                        requestStorage.reset();\n                        requestGetter.setRequest(null);\n                        requestGetter.setResponse(null);\n                    }\n                }\n            }\n        }\n        return handledReference;\n    }","id":86179,"modified_method":"/**\n     * If this param is set then the sakai session for the current request is set to this rather than establishing one,\n     * will allow changing the session as well\n     */\n\n    /* (non-Javadoc)\n     * @see org.sakaiproject.entitybroker.EntityRequestHandler#handleEntityAccess(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public String handleEntityAccess(HttpServletRequest req, HttpServletResponse res, String path) {\n        // set the servlet context if not set\n        if (this.servletContext == null) {\n            setServletContext( RequestUtils.getServletContext(req) );\n        }\n\n        // get the path info if not set\n        if (path == null) {\n            path = req.getPathInfo();\n        }\n\n        String handledReference = null;\n\n        // special handling in case the session ID is sent in the request \n        // (allows setting up and reusing a session over and over without holding cookies)\n        if (entityBrokerManager.getExternalIntegrationProvider() != null) {\n            try {\n                entityBrokerManager.getExternalIntegrationProvider().handleUserSessionKey(req);\n            } catch (Exception e) {\n                log.warn(\"External handleUserSessionKey method failed, continuing...: \" + e);\n            }\n        }\n\n        if (path == null || \"\".equals(path) || \"/\".equals(path)) {\n            // SPECIAL handling for empty path\n            res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n            try {\n                res.sendRedirect( res.encodeRedirectURL(getServletContext() + SLASH_DESCRIBE) );\n            } catch (IOException e) {\n                // should never happen\n                throw new RuntimeException(\"Could not encode the redirect URL\");\n            }\n            // immediate exit from redirect\n            return \"/\";\n        } else {\n            // regular handling for direct URLs\n            if ( (SLASH_DESCRIBE).equals(path) \n                    || path.startsWith(SLASH_DESCRIBE + EntityReference.PERIOD)) {\n                // SPECIAL handling for the describe all URL\n                String format = TemplateParseUtil.findExtension(path)[2];\n                if (format == null) {\n                    format = Formats.HTML;\n                }\n                RequestUtils.setResponseEncoding(format, res);\n                String output = entityDescriptionManager.makeDescribeAll(format, req.getLocale()); // possibly get the locale from other places?\n                res.setContentLength(output.getBytes().length);\n                try {\n                    res.getWriter().write(output);\n                } catch (IOException e) {\n                    // should never happen\n                    throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                }\n                res.setStatus(HttpServletResponse.SC_OK);\n                handledReference = EntityView.SEPARATOR+\"\";\n            } else {\n                // STANDARD processing for the incoming view\n                EntityView view;\n                try {\n                    view = entityBrokerManager.parseEntityURL(path);\n                } catch (IllegalArgumentException e) {\n                    // FAILURE indicates we could not parse the reference\n                    throw new EntityException(\"Could not parse entity path (\"+path+\"): \" + e.getMessage(), path, HttpServletResponse.SC_BAD_REQUEST);\n                }\n\n                if (view == null) {\n                    // FAILURE no provider for this entity prefix\n                    throw new EntityException( \"Could not parse the incoming path (\"+path+\") and no entity provider could be found to handle the prefix\", \n                            path, HttpServletResponse.SC_NOT_IMPLEMENTED );\n                } else if ( DESCRIBE.equals(view.getEntityReference().getId()) ) {\n                    // SPECIAL handling for entity describe URLs\n                    String format = TemplateParseUtil.findExtension(path)[2];\n                    if (format == null) {\n                        format = Formats.HTML;\n                    }\n                    RequestUtils.setResponseEncoding(format, res);\n                    String entityId = req.getParameter(\"_id\");\n                    if (entityId == null || \"\".equals(entityId)) {\n                        entityId = FAKE_ID;\n                    }\n                    String output = entityDescriptionManager.makeDescribeEntity(view.getEntityReference().getPrefix(), entityId, format, req.getLocale());\n                    res.setContentLength(output.getBytes().length);\n                    try {\n                        res.getWriter().write(output);\n                    } catch (IOException e) {\n                        throw new RuntimeException(\"Failed to put output into the response writer: \" + e.getMessage(), e);\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    handledReference = view.getEntityReference().getSpaceReference() + SLASH_DESCRIBE;\n\n                } else {\n                    // STANDARD reference successfully parsed\n                    String prefix = view.getEntityReference().getPrefix();\n\n                    // check for redirect\n                    Redirectable urlConfigurable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Redirectable.class);\n                    if (urlConfigurable != null) {\n                        // SPECIAL check for redirect\n                        String redirectURL = entityRedirectsManager.checkForTemplateMatch(urlConfigurable, path, req.getQueryString());\n                        if (redirectURL != null) {\n                            // SPECIAL handling for redirect\n                            if (\"\".equals(redirectURL)) {\n                                // do nothing but return an empty response\n                                res.setStatus(HttpServletResponse.SC_OK);\n                            } else {\n                                // do the redirect\n                                log.info(\"Entity Redirect: redirecting from (\"+path+\") to (\"+redirectURL+\")\");\n                                RequestUtils.handleURLRedirect(redirectURL, true, req, res);\n                            }\n                            return EntityView.SEPARATOR + prefix; // exit here for redirects\n                        }\n                    }\n\n                    // check for custom action\n                    CustomAction customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(1));\n                    if (customAction == null) {\n                        customAction = entityActionsManager.getCustomAction(prefix, view.getPathSegment(2));\n                    }\n                    if (customAction == null) {\n                        // check to see if the entity exists\n                        if (! entityBrokerManager.entityExists(view.getEntityReference()) ) {\n                            // FAILURE invalid entity reference (entity does not exist)\n                            throw new EntityException( \"Attempted to access an entity URL path (\" + path + \") for an entity (\"\n                                    + view.getEntityReference() + \") that does not exist\", \n                                    view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                        }\n                    } else {\n                        // cleanup the entity reference, this has to be done because otherwise the custom action\n                        // on collections appears to be the id of an entity in the collection\n                        EntityReference cRef = view.getEntityReference();\n                        if (cRef.getId().equals(customAction.action)) {\n                            view.setEntityReference( new EntityReference(prefix, \"\") );\n                        }\n                    }\n                    res.setStatus(HttpServletResponse.SC_OK); // default - other things can switch this later on\n\n                    // store format in attribute\n                    req.setAttribute(\"entity-format\", view.getFormat());\n\n                    // STANDARD initial processing complete\n                    // wrap in try block so that request storage is always cleaned up\n                    try {\n                        // store the current request and response\n                        requestGetter.setRequest(req);\n                        requestGetter.setResponse(res);\n                        // set the request variables\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), view.getEntityReference().toString());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestOrigin.name(), RequestStorage.RequestOrigin.REST.name());\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestActive.name(), true);\n\n                        // handle the before interceptor\n                        RequestInterceptor interceptor = (RequestInterceptor) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestInterceptor.class);\n                        if (interceptor != null) {\n                            interceptor.before(view, req, res);\n                        }\n\n                        if (BATCH.equals(prefix)) {\n                            // special batch handling\n                            if (view.getExtension() == null) {\n                                // default extension is JSON\n                                view.setExtension(Formats.JSON);\n                            }\n                            entityBatchHandler.handleBatch(view, req, res);\n                        } else {\n                            // check for provider handling of this request\n                            RequestHandler handler = (RequestHandler) entityProviderManager.getProviderByPrefixAndCapability(prefix, RequestHandler.class);\n                            if (handler != null) {\n                                // SPECIAL provider is handling this request\n                                handleClassLoaderAccess(handler, req, res, view);\n                            } else {\n                                // STANDARD processing of the entity request internally start here\n                                // try to handle the request internally if possible\n    \n                                // identify the type of request (input or output) and the action (will be encoded in the viewKey)\n                                boolean output = RequestUtils.isRequestOutput(req, view);\n                                setResponseHeaders(view, res, requestStorage.getStorageMapCopy(), null);\n    \n                                boolean handled = false;\n                                // PROCESS CUSTOM ACTIONS\n                                ActionReturn actionReturn = null;\n                                if (customAction != null) {\n                                    // SPECIAL handle the custom action\n                                    ActionsExecutable actionProvider = entityProviderManager.getProviderByPrefixAndCapability(prefix, ActionsExecutable.class);\n                                    if (actionProvider == null) {\n                                        throw new EntityException( \"The provider for prefix (\"+prefix+\") cannot handle custom actions\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    // make sure this request is a valid type for this action\n                                    if (customAction.viewKey != null \n                                            && ! view.getViewKey().equals(customAction.viewKey)) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\") for request method \" + req.getMethod()\n                                                + \", The custom action view key (\"+customAction.viewKey+\") must match the request view key (\"+view.getViewKey()+\")\", \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    try {\n                                        actionReturn = entityActionsManager.handleCustomActionRequest(actionProvider, view, customAction.action, req, res, \n                                                requestStorage.getStorageMapCopy(true, false, true, true) );\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityNotFoundException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not find entity (\"+e.entityReference+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_FOUND );\n                                    } catch (FormatUnsupportedException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Format not supported (\"+e.format+\"): \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_NOT_ACCEPTABLE );\n                                    } catch (IllegalArgumentException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Illegal arguments: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    } catch (UnsupportedOperationException e) {\n                                        throw new EntityException( \"Cannot execute custom action (\"+customAction.action+\"): Could not execute action: \" + e.getMessage(), \n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                    if (actionReturn == null \n                                            || actionReturn.output != null) {\n                                        // custom action processing complete\n                                        /* actionReturn.output != null - this means that there is an \n                                         * outputstream set and that the encoding has been,\n                                         * handled, however, the response status code should be set still\n                                         */\n                                        handled = true;\n                                    } else {\n                                        // if there are headers then set them now\n                                        addResponseHeaders(res, actionReturn.getHeaders());\n                                        // if the custom action returned entity data then we will encode it for output\n                                        if (actionReturn.entitiesList == null\n                                                && actionReturn.entityData == null) {\n                                            handled = true;\n                                        } else {\n                                            // there is entity data to return\n                                            output = true;\n                                            handled = false;\n                                            // populate the entity data\n                                            if (actionReturn.entitiesList != null) {\n                                                if (actionReturn.entitiesList.size() > 1) {\n                                                    // correct the view key which should be used now\n                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                }\n                                                entityBrokerManager.populateEntityData(actionReturn.entitiesList);\n                                            } else if (actionReturn.entityData != null) {\n                                                // correct the view key which should be used now\n                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                entityBrokerManager.populateEntityData( new EntityData[] {actionReturn.entityData} );\n                                            }\n                                        }\n                                    }\n                                }\n    \n                                boolean formatInvalidFailure = false;\n                                if (!handled) {\n                                    // INTERNAL PROCESSING OF REQUEST\n                                    try {\n                                        String format = view.getFormat();\n                                        if (output) {\n                                            // output request\n                                            String viewKey = view.getViewKey();\n                                            if (EntityView.VIEW_NEW.equals(viewKey)\n                                                    || EntityView.VIEW_EDIT.equals(viewKey) \n                                                    || EntityView.VIEW_DELETE.equals(viewKey) ) {\n                                                // request for the create/edit/delete entity forms\n                                                // TODO possibly generate new/edit/delete forms internally?\n                                                handled = false;\n                                            } else {\n                                                Outputable outputable = (Outputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Outputable.class);\n                                                if (outputable != null) {\n                                                    if (customAction != null) {\n                                                        // override format from the custom action\n                                                        if (actionReturn != null \n                                                                && actionReturn.format != null) {\n                                                            format = actionReturn.format;\n                                                        }\n                                                    }\n                                                    String[] outputFormats = outputable.getHandledOutputFormats();\n                                                    if (outputFormats == null || ReflectUtils.contains(outputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        RequestUtils.setResponseEncoding(format, res);\n    \n                                                        EntityReference ref = view.getEntityReference();\n                                                        // get the entities to output\n                                                        List<EntityData> entities = null;\n                                                        if (customAction != null \n                                                                && actionReturn != null) {\n                                                            // get entities from a custom action\n                                                            entities = actionReturn.entitiesList;\n                                                            if (entities != null) {\n                                                                // recode the collection\n                                                                if (entities.size() > 0) {\n                                                                    EntityData ed = entities.get(0);\n                                                                    ref = new EntityReference(ed.getEntityRef().getPrefix(), \"\");\n                                                                    view.setEntityReference( ref );\n                                                                    view.setViewKey(EntityView.VIEW_LIST);\n                                                                }\n                                                            } else if (actionReturn.entityData != null) {\n                                                                // this was a single object return so it should be encoded as such, thus we will recode the correct reference into the view\n                                                                ArrayList<EntityData> eList = new ArrayList<EntityData>();\n                                                                EntityData ed = actionReturn.entityData;\n                                                                // set title if not set\n                                                                if (! ed.isDisplayTitleSet()) {\n                                                                    ed.setDisplayTitle(customAction.action);\n                                                                }\n                                                                // add to list\n                                                                eList.add( ed );\n                                                                entities = eList;\n                                                                // make entity reference\n                                                                ref = ed.getEntityRef();\n                                                                if (ref == null) {\n                                                                    ref = new EntityReference(prefix, customAction.action);\n                                                                } else if (ref.getId() == null) {\n                                                                    ref = new EntityReference(ref.getPrefix(), customAction.action);\n                                                                }\n                                                                view.setEntityReference( ref );\n                                                                view.setViewKey(EntityView.VIEW_SHOW);\n                                                            }\n                                                        } else {\n                                                            // get from a search\n                                                            Search search = RequestUtils.makeSearchFromRequestParams(requestStorage.getStorageMapCopy(true, false, true, true)); // leave out headers));\n                                                            entities = entityBrokerManager.getEntitiesData(ref, search, requestStorage.getStorageMapCopy());\n                                                        }\n                                                        // set the modified header (use the sole entity in the list if there is one only)\n                                                        setLastModifiedHeaders(res, (entities != null && entities.size()==1 ? entities.get(0) : null), System.currentTimeMillis());\n    \n                                                        if (EntityView.Method.HEAD.name().equals(view.getMethod())) {\n                                                            // HEADER only\n                                                            res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                        } else {\n                                                            // GET\n                                                            OutputStream outputStream = new LazyResponseOutputStream(res);\n    \n                                                            /* try to use the provider formatter if one available,\n                                                             * if it decided not to handle it or none is available then control passes to internal\n                                                             */\n                                                            try {\n                                                                OutputFormattable formattable = (OutputFormattable) entityProviderManager.getProviderByPrefixAndCapability(prefix, OutputFormattable.class);\n                                                                if (formattable != null) {\n                                                                    // use provider's formatter\n                                                                    formattable.formatOutput(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream);\n                                                                    handled = true;\n                                                                }\n                                                            } catch (FormatUnsupportedException e) {\n                                                                // provider decided not to handle this format\n                                                                handled = false;\n                                                            }\n                                                            if (!handled) {\n                                                                // handle internally or fail\n                                                                entityEncodingManager.internalOutputFormatter(ref, format, entities, requestStorage.getStorageMapCopy(), outputStream, view);\n                                                            }\n                                                            handled = true;\n                                                            res.setStatus(HttpServletResponse.SC_OK);\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Outputable restriction for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            // input request\n                                            if (EntityView.VIEW_DELETE.equals(view.getViewKey())) {\n                                                // delete request\n                                                Deleteable deleteable = (Deleteable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Deleteable.class);\n                                                if (deleteable != null) {\n                                                    deleteable.deleteEntity(view.getEntityReference(), requestStorage.getStorageMapCopy());\n                                                    res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                    handled = true;\n                                                }\n                                            } else {\n                                                // save request\n                                                Inputable inputable = (Inputable) entityProviderManager.getProviderByPrefixAndCapability(prefix, Inputable.class);\n                                                if (inputable != null) {\n                                                    String[] inputFormats = inputable.getHandledInputFormats();\n                                                    if (inputFormats == null || ReflectUtils.contains(inputFormats, format) ) {\n                                                        // we are handling this type of format for this entity\n                                                        Object entity = null;\n                                                        InputStream inputStream = null;\n                                                        try {\n                                                            inputStream = req.getInputStream();\n                                                        } catch (IOException e) {\n                                                            throw new RuntimeException(\"Failed to get output stream from response: \" + view.getEntityReference(), e);\n                                                        }\n    \n                                                        /* try to use the provider translator if one available,\n                                                         * if it decided not to handle it or none is available then control passes to internal\n                                                         */\n                                                        try {\n                                                            InputTranslatable translatable = (InputTranslatable) entityProviderManager.getProviderByPrefixAndCapability(prefix, InputTranslatable.class);\n                                                            if (translatable != null) {\n                                                                // use provider's translator\n                                                                entity = translatable.translateFormattedData(view.getEntityReference(), \n                                                                        format, inputStream, requestStorage.getStorageMapCopy());\n                                                                handled = true;\n                                                            }\n                                                        } catch (FormatUnsupportedException e) {\n                                                            // provider decided not to handle this format\n                                                            handled = false;\n                                                        }\n                                                        if (!handled) {\n                                                            // use internal translators or fail\n                                                            entity = entityEncodingManager.internalInputTranslator(view.getEntityReference(), \n                                                                    format, inputStream, req);\n                                                        }\n    \n                                                        if (entity == null) {\n                                                            // FAILURE input could not be translated into an entity object\n                                                            handled = false;\n                                                            throw new EntityException(\"Unable to save entity (\"+view.getEntityReference()+\") with format (\"\n                                                                    +format+\"), translated entity object was null\", \n                                                                    view.toString(), HttpServletResponse.SC_BAD_REQUEST);\n                                                        } else {\n                                                            // setup all the headers for the response\n                                                            if (EntityView.VIEW_NEW.equals(view.getViewKey())) {\n                                                                Createable createable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Createable.class);\n                                                                if (createable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Createable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                String createdId = createable.createEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                if (createdId == null || \"\".equals(createdId)) {\n                                                                    throw new IllegalStateException(\"Could not get the createdId from the newly created entity for (\"+view+\"), please ensure the provider is returning a non-null and non-empty value from the create method, if the item was not created then an exception should have been thrown\");\n                                                                }\n                                                                view.setEntityReference( new EntityReference(prefix, createdId) ); // update the entity view\n                                                                res.setHeader(EntityRequestHandler.HEADER_ENTITY_ID, createdId);\n                                                                res.setStatus(HttpServletResponse.SC_CREATED);\n                                                                // added the id to the response to make it easier on Nico\n                                                                try {\n                                                                    OutputStream outputStream = res.getOutputStream();\n                                                                    outputStream.write( createdId.getBytes() );\n                                                                } catch (IOException e) {\n                                                                    // oh well, no id in the output\n                                                                } catch (RuntimeException e) {\n                                                                    // oh well, no id in the output\n                                                                }\n                                                            } else if (EntityView.VIEW_EDIT.equals(view.getViewKey())) {\n                                                                Updateable updateable = entityProviderManager.getProviderByPrefixAndCapability(prefix, Updateable.class);\n                                                                if (updateable == null) {\n                                                                    throw new EntityException(\"Unable to create new entity (\"+view+\"), \"\n                                                                            +Updateable.class.getName()+\" is not implemented for this entity type (\"+prefix+\")\", \n                                                                            view+\"\", HttpServletResponse.SC_NOT_IMPLEMENTED);\n                                                                }\n                                                                updateable.updateEntity(view.getEntityReference(), entity, requestStorage.getStorageMapCopy());\n                                                                res.setStatus(HttpServletResponse.SC_NO_CONTENT);\n                                                            } else {\n                                                                // FAILURE not delete, edit, or new\n                                                                throw new EntityException(\"Unable to handle entity input (\"+view.getEntityReference()+\"), \" +\n                                                                        \"action was not understood: \" + view.getViewKey(), \n                                                                        view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);\n                                                            }\n                                                            // return the location of this updated or created entity (without any extension)\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_URL, view.getEntityURL() );\n                                                            res.setHeader(EntityRequestHandler.HEADER_ENTITY_REFERENCE, view.getEntityReference().toString() );\n                                                            handled = true;\n                                                        }\n                                                    } else {\n                                                        // format type not handled\n                                                        throw new FormatUnsupportedException(\"Inputable restriction for \" \n                                                                + prefix + \" blocked handling this format (\"+format+\")\",\n                                                                view.getEntityReference()+\"\", format);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // this format could not be handled internally so we will pass it to the access provider, nothing else to do here\n                                        formatInvalidFailure = true;\n                                        handled = false;\n                                    } catch (SecurityException se) {\n                                        // AJAX/WS type security exceptions are handled specially, no redirect\n                                        throw new EntityException(\"Security exception handling request for view (\"+view+\"), \"\n                                                + \"this is typically caused by the current user not having access to the \"\n                                                + \"data requested or the user not being logged in at all :: message=\" + se.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_FORBIDDEN);\n                                    } catch (EntityEncodingException e) {\n                                        // translate EEE into EE - internal server error\n                                        throw new EntityException(\"EntityEncodingException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);        \n                                    } catch (IllegalArgumentException e) {\n                                        // translate IAE into EE - bad request\n                                        throw new EntityException(\"IllegalArgumentException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST);        \n                                    } catch (IllegalStateException e) {\n                                        // translate ISE into EE - internal server error\n                                        throw new EntityException(\"IllegalStateException: Unable to handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \"): \" + e.getMessage(),\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                                    }\n                                }\n    \n                                if (! handled) {\n                                    // default handling, send to the access provider if there is one (if none this will throw EntityException)\n                                    try {\n                                        boolean accessProviderExists = handleAccessProvider(view, req, res);\n                                        if (!accessProviderExists) {\n                                            if (formatInvalidFailure) {\n                                                // trigger the format \n                                                throw new FormatUnsupportedException(\"Nothing (AP and internal) available to handle the requested format\", view.getEntityReference()+\"\", view.getFormat());\n                                            }\n                                            String message = \"Access Provider: Attempted to access an entity URL path (\"\n                                                + view + \") using method (\"+view.getMethod()+\") for an entity (\" + view.getEntityReference() \n                                                + \") and view (\"+view.getViewKey()+\") when there is no \" \n                                                + \"access provider to handle the request for prefix (\" + view.getEntityReference().getPrefix() + \")\";\n                                            throw new EntityException( message, view.toString(), HttpServletResponse.SC_METHOD_NOT_ALLOWED );\n                                        }\n                                    } catch (FormatUnsupportedException e) {\n                                        // TODO add in the methods \"allowed\" header?\n                                        throw new EntityException( \"AccessProvider: Method/Format unsupported: Will not handle \" + (output ? \"output\" : \"input\") + \" request for format  \"+view.getFormat()+\" for this path (\" \n                                                + path + \") for prefix (\" + prefix + \") for entity (\" + view.getEntityReference() + \"), request url (\" + view.getOriginalEntityUrl() + \")\",\n                                                view.getEntityReference()+\"\", HttpServletResponse.SC_BAD_REQUEST );\n                                    }\n                                }\n                            }\n                        }\n                        handledReference = view.getEntityReference().toString();\n                        requestStorage.setRequestValue(RequestStorage.ReservedKeys._requestEntityReference.name(), handledReference);\n\n                        // handle the after interceptor\n                        if (interceptor != null) {\n                            interceptor.after(view, req, res);\n                        }\n                    } finally {\n                        // clear the request data no matter what happens\n                        requestStorage.reset();\n                        requestGetter.setRequest(null);\n                        requestGetter.setResponse(null);\n                    }\n                }\n            }\n        }\n        return handledReference;\n    }","commit_id":"9a3c36f1d4ede018cd19c4cd7a3e3d30aec022db","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Metadata parse(Element element, ParserContext context) {\n        String s = element.getLocalName();\n        if (\"endpoint\".equals(s)) {\n            return new EndpointDefinitionParser().parse(element, context);\n        } else if (\"server\".equals(s)) {\n            //TODO\n        } else if (\"client\".equals(s)) {\n            //TODO\n        }\n        return null;\n    }","id":86180,"modified_method":"public Metadata parse(Element element, ParserContext context) {\n        String s = element.getLocalName();\n        if (\"endpoint\".equals(s)) {\n            return new EndpointDefinitionParser().parse(element, context);\n        } else if (\"server\".equals(s)) {\n            return new ServerFactoryBeanDefinitionParser(JaxWsServerFactoryBean.class)\n                .parse(element, context);\n        } else if (\"client\".equals(s)) {\n            return new ClientProxyFactoryBeanDefinitionParser(JaxWsProxyFactoryBean.class)\n                .parse(element, context);\n        }\n        return null;\n    }","commit_id":"11d607f2632616fc3d26d366ce61a2d63ce9af19","url":"https://github.com/apache/cxf"},{"original_method":"public Server create() {\n        Server server = super.create();\n        init();\n        checkPrivateEndpoint(server.getEndpoint());\n        \n        return server;\n    }","id":86181,"modified_method":"public Server create() {\n        Server server = super.create();\n        initializeResourcesAndHandlerChain();\n        checkPrivateEndpoint(server.getEndpoint());\n        \n        return server;\n    }","commit_id":"11d607f2632616fc3d26d366ce61a2d63ce9af19","url":"https://github.com/apache/cxf"},{"original_method":"public String getId(Element element) {\n        return element.hasAttribute(\"id\") ? element.getAttribute(\"id\") : null;\n    }","id":86182,"modified_method":"public String getId(Element element, ParserContext context) {\n        return element.hasAttribute(\"id\") ? element.getAttribute(\"id\") : null;\n    }","commit_id":"11d607f2632616fc3d26d366ce61a2d63ce9af19","url":"https://github.com/apache/cxf"},{"original_method":"public Metadata parse(Element element, ParserContext context) {\n        MutableBeanMetadata cxfBean = context.createMetadata(MutableBeanMetadata.class);\n        cxfBean.setRuntimeClass(cls);\n        cxfBean.setId(getId(element));\n        parseAttributes(element, context, cxfBean);\n        parseChildElements(element, context, cxfBean);\n        return cxfBean;\n    }","id":86183,"modified_method":"public Metadata parse(Element element, ParserContext context) {\n        MutableBeanMetadata cxfBean = context.createMetadata(MutableBeanMetadata.class);\n        cxfBean.setRuntimeClass(cls);\n        String fact = getFactorySuffix();\n        if (fact == null) {\n            cxfBean.setId(getId(element, context));\n        } else {\n            cxfBean.setId(getId(element, context) + fact);            \n        }\n        parseAttributes(element, context, cxfBean);\n        parseChildElements(element, context, cxfBean);\n        if (hasBusProperty()) {\n            boolean foundBus = false;\n            for (BeanProperty bp : cxfBean.getProperties()) {\n                if (\"bus\".equals(bp.getName())) {\n                    foundBus = true;\n                }\n            }\n            if (!foundBus) {\n                cxfBean.addProperty(\"bus\", getBusRef(context, \"cxf\"));\n            }\n        }\n        if (fact != null) {\n            context.getComponentDefinitionRegistry().registerComponentDefinition(cxfBean);\n            \n            MutableBeanMetadata bean = context.createMetadata(MutableBeanMetadata.class);\n            bean.setId(getId(element, context));\n            bean.setFactoryComponent(cxfBean);\n            bean.setFactoryMethod(\"create\");\n            bean.setClassName(getFactoryCreateType(element));\n            return bean;\n        }\n        return cxfBean;\n    }","commit_id":"11d607f2632616fc3d26d366ce61a2d63ce9af19","url":"https://github.com/apache/cxf"},{"original_method":"protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tif (sc.getMajorVersion() == 2 && sc.getMinorVersion() < 5) {\n\t\t\t\t// Servlet <= 2.4: resort to name specified in web.xml, if any.\n\t\t\t\tString servletContextName = sc.getServletContextName();\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\tObjectUtils.getDisplayString(servletContextName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Servlet 2.5's getContextPath available!\n\t\t\t\ttry {\n\t\t\t\t\tString contextPath = (String) ServletContext.class.getMethod(\"getContextPath\").invoke(sc);\n\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\t\tObjectUtils.getDisplayString(contextPath));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new IllegalStateException(\"Failed to invoke Servlet 2.5 getContextPath method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine parent for root web application context, if any.\n\t\tApplicationContext parent = loadParentContext(sc);\n\n\t\twac.setParent(parent);\n\t\twac.setServletContext(sc);\n\t\twac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM));\n\t\tcustomizeContext(sc, wac);\n\t\twac.refresh();\n\t}","id":86184,"modified_method":"protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n\t\t\tif (idParam != null) {\n\t\t\t\twac.setId(idParam);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Generate default id...\n\t\t\t\tif (sc.getMajorVersion() == 2 && sc.getMinorVersion() < 5) {\n\t\t\t\t\t// Servlet <= 2.4: resort to name specified in web.xml, if any.\n\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\t\tObjectUtils.getDisplayString(sc.getServletContextName()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\t\tObjectUtils.getDisplayString(sc.getContextPath()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine parent for root web application context, if any.\n\t\tApplicationContext parent = loadParentContext(sc);\n\n\t\twac.setParent(parent);\n\t\twac.setServletContext(sc);\n\t\twac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM));\n\t\tcustomizeContext(sc, wac);\n\t\twac.refresh();\n\t}","commit_id":"6cd55b79861be6194dea3ef2a6a088948538b44e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {\n\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tServletContext sc = getServletContext();\n\t\t\tif (sc.getMajorVersion() == 2 && sc.getMinorVersion() < 5) {\n\t\t\t\t// Servlet <= 2.4: resort to name specified in web.xml, if any.\n\t\t\t\tString servletContextName = sc.getServletContextName();\n\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContextName +\n\t\t\t\t\t\t\t\".\" + getServletName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + getServletName());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Servlet 2.5's getContextPath available!\n\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + sc.getContextPath() +\n\t\t\t\t\t\t\"/\" + getServletName());\n\t\t\t}\n\t\t}\n\n\t\twac.setServletContext(getServletContext());\n\t\twac.setServletConfig(getServletConfig());\n\t\twac.setNamespace(getNamespace());\n\t\twac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));\n\n\t\tpostProcessWebApplicationContext(wac);\n\n\t\tapplyInitializers(wac);\n\n\t\twac.refresh();\n\t}","id":86185,"modified_method":"protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {\n\t\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n\t\t\t// The application context id is still set to its original default value\n\t\t\t// -> assign a more useful id based on available information\n\t\t\tif (this.contextId != null) {\n\t\t\t\twac.setId(this.contextId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Generate default id...\n\t\t\t\tServletContext sc = getServletContext();\n\t\t\t\tif (sc.getMajorVersion() == 2 && sc.getMinorVersion() < 5) {\n\t\t\t\t\t// Servlet <= 2.4: resort to name specified in web.xml, if any.\n\t\t\t\t\tString servletContextName = sc.getServletContextName();\n\t\t\t\t\tif (servletContextName != null) {\n\t\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + servletContextName +\n\t\t\t\t\t\t\t\t\".\" + getServletName());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + getServletName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Servlet 2.5's getContextPath available!\n\t\t\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n\t\t\t\t\t\t\tObjectUtils.getDisplayString(sc.getContextPath()) + \"/\" + getServletName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twac.setServletContext(getServletContext());\n\t\twac.setServletConfig(getServletConfig());\n\t\twac.setNamespace(getNamespace());\n\t\twac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));\n\n\t\tpostProcessWebApplicationContext(wac);\n\n\t\tapplyInitializers(wac);\n\n\t\twac.refresh();\n\t}","commit_id":"6cd55b79861be6194dea3ef2a6a088948538b44e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Resolves the given tag's page class and page parameters by parsing the\n\t * tag component name and then searching for a page class at the absolute or\n\t * relative URL specified by the href attribute of the tag.\n\t * <p>\n\t * None html references are treated similar.\n\t * \n\t * @param container\n\t *            The container where the link is\n\t * @param id\n\t *            the name of the component\n\t * @param tag\n\t *            the component tag\n\t * @return A BookmarkablePageLink to handle the href\n\t */\n\tprivate final Component resolveAutomaticLink(final MarkupContainer container, final String id,\n\t\t\tfinal ComponentTag tag)\n\t{\n\t\tfinal Page page = container.getPage();\n\n\t\t// Make the id (page-)unique\n\t\tfinal String autoId = id + Integer.toString(page.getAutoIndex());\n\n\t\t// get the tag name, which is something like 'a' or 'script'\n\t\tfinal String tagName = tag.getName();\n\n\t\t// By setting the component name, the tag becomes a Wicket component\n\t\t// tag, which must have a associated Component.\n\t\ttag.setId(autoId);\n\n\t\t// get the reference resolver\n\t\tITagReferenceResolver referenceResolver = (ITagReferenceResolver)tagNameToTagReferenceResolvers\n\t\t\t\t.get(tagName);\n\t\tif (referenceResolver == null)\n\t\t{\n\t\t\t// fallback on default\n\t\t\treferenceResolver = DEFAULT_ATTRIBUTE_RESOLVER;\n\t\t}\n\n\t\t// get the reference, which is typically the value of e.g. a href or src\n\t\t// attribute\n\t\tString reference = referenceResolver.getReference(tag);\n\n\t\t// create the path info object\n\t\tPathInfo pathInfo = new PathInfo(reference);\n\t\t// now get the resolver delegate\n\t\tIAutolinkResolverDelegate autolinkResolverDelegate = (IAutolinkResolverDelegate)tagNameToAutolinkResolverDelegates\n\t\t\t\t.get(tagName);\n\t\tComponent autoComponent = null;\n\t\tif (autolinkResolverDelegate != null)\n\t\t{\n\t\t\tautoComponent = autolinkResolverDelegate.newAutoComponent(container, autoId, pathInfo);\n\t\t}\n\n\t\tif (autoComponent == null)\n\t\t{\n\t\t\t// resolving didn't have the desired result or there was no delegate\n\t\t\t// found; fallback on the default resolving which is a simple\n\t\t\t// component that leaves the tag unchanged\n\t\t\tautoComponent = new AutolinkExternalLink(autoId, pathInfo.reference);\n\t\t}\n\n\t\treturn autoComponent;\n\t}","id":86186,"modified_method":"/**\n\t * Resolves the given tag's page class and page parameters by parsing the\n\t * tag component name and then searching for a page class at the absolute or\n\t * relative URL specified by the href attribute of the tag.\n\t * <p>\n\t * None html references are treated similar.\n\t * \n\t * @param container\n\t *            The container where the link is\n\t * @param id\n\t *            the name of the component\n\t * @param tag\n\t *            the component tag\n\t * @return A BookmarkablePageLink to handle the href\n\t */\n\tprivate final Component resolveAutomaticLink(final MarkupContainer container, final String id,\n\t\t\tfinal ComponentTag tag)\n\t{\n\t\tfinal Page page = container.getPage();\n\n\t\t// Make the id (page-)unique\n\t\tfinal String autoId = id + Integer.toString(page.getAutoIndex());\n\n\t\t// get the tag name, which is something like 'a' or 'script'\n\t\tfinal String tagName = tag.getName();\n\n\t\t// By setting the component name, the tag becomes a Wicket component\n\t\t// tag, which must have a associated Component.\n\t\tif (tag.getId() == null)\n\t\t{\n\t\t\ttag.setId(autoId);\n\t\t}\n\n\t\t// get the reference resolver\n\t\tITagReferenceResolver referenceResolver = (ITagReferenceResolver)tagNameToTagReferenceResolvers\n\t\t\t\t.get(tagName);\n\t\tif (referenceResolver == null)\n\t\t{\n\t\t\t// fallback on default\n\t\t\treferenceResolver = DEFAULT_ATTRIBUTE_RESOLVER;\n\t\t}\n\n\t\t// get the reference, which is typically the value of e.g. a href or src\n\t\t// attribute\n\t\tString reference = referenceResolver.getReference(tag);\n\n\t\t// create the path info object\n\t\tPathInfo pathInfo = new PathInfo(reference);\n\t\t// now get the resolver delegate\n\t\tIAutolinkResolverDelegate autolinkResolverDelegate = (IAutolinkResolverDelegate)tagNameToAutolinkResolverDelegates\n\t\t\t\t.get(tagName);\n\t\tComponent autoComponent = null;\n\t\tif (autolinkResolverDelegate != null)\n\t\t{\n\t\t\tautoComponent = autolinkResolverDelegate.newAutoComponent(container, autoId, pathInfo);\n\t\t}\n\n\t\tif (autoComponent == null)\n\t\t{\n\t\t\t// resolving didn't have the desired result or there was no delegate\n\t\t\t// found; fallback on the default resolving which is a simple\n\t\t\t// component that leaves the tag unchanged\n\t\t\tautoComponent = new AutolinkExternalLink(autoId, pathInfo.reference);\n\t\t}\n\n\t\treturn autoComponent;\n\t}","commit_id":"83dbd6d6ec3f6be4193024e7be56368454170176","url":"https://github.com/apache/wicket"},{"original_method":"public void startElement(Txn transaction, ElementImpl element, NodePath path) { \r\n        \tif (isDocumentGMLAware) {\r\n        \t\t//Release the deferred element\r\n        \t\tprocessDeferredElement();\r\n        \t\t//Retain this element\r\n\t    \t\tdeferredElement = element;  \r\n        \t}\r\n\t        //Forward the event to the next listener \r\n        \tsuper.startElement(transaction, element, path);\r\n        }","id":86187,"modified_method":"public void startElement(Txn transaction, ElementImpl element, NodePath path) { \r\n        \tif (isDocumentGMLAware) {\r\n        \t\t//Release the deferred element if any\r\n        \t\tif (deferredElement != null)        \t\t\r\n        \t\t\tprocessDeferredElement();\r\n        \t\t//Retain this element\r\n\t    \t\tdeferredElement = element;  \r\n        \t}\r\n\t        //Forward the event to the next listener \r\n        \tsuper.startElement(transaction, element, path);\r\n        }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"public void characters(Txn transaction, TextImpl text, NodePath path) {\r\n        \tif (isDocumentGMLAware) {\r\n        \t\t//Release the deferred element\r\n        \t\tprocessDeferredElement();\r\n\t        \tdeferredElement = null;\r\n\t        \ttry {\r\n\t        \t\tgeometryDocument.characters(text.getData().toCharArray(), 0, text.getLength());\r\n\t        \t} catch (Exception e) {\r\n\t        \t\tLOG.error(e);\r\n\t        \t}    \r\n        \t}\r\n        \t//Forward the event to the next listener \r\n        \tsuper.characters(transaction, text, path);\r\n        }","id":86188,"modified_method":"public void characters(Txn transaction, TextImpl text, NodePath path) {\r\n        \tif (isDocumentGMLAware) {\r\n        \t\t//Release the deferred element if any\r\n        \t\tif (deferredElement != null)        \t\t\r\n        \t\t\tprocessDeferredElement();\t        \t\r\n\t        \ttry {\r\n\t        \t\tgeometryDocument.characters(text.getData().toCharArray(), 0, text.getLength());\r\n\t        \t} catch (Exception e) {\r\n\t        \t\tLOG.error(e);\r\n\t        \t}    \r\n        \t}\r\n        \t//Forward the event to the next listener \r\n        \tsuper.characters(transaction, text, path);\r\n        }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"public Geometry transformGeometry(Geometry geometry, String sourceCRS, String targetCRS) throws SpatialIndexException {\r\n        //provisional workaround\r\n        if (\"osgb:BNG\".equalsIgnoreCase(sourceCRS.trim()))\r\n        \tsourceCRS = \"EPSG:27700\";  \t    \r\n        if (\"osgb:BNG\".equalsIgnoreCase(targetCRS.trim()))\r\n        \ttargetCRS = \"EPSG:27700\";    \t\r\n    \tMathTransform mathTransform = TransformationsFactory.getTransform(sourceCRS, targetCRS);\r\n        if (mathTransform == null) {\r\n    \t\tthrow new SpatialIndexException(\"Unable to get a transformation from '\" + sourceCRS + \"' to '\" + targetCRS +\"'\");        \t\t           \t\r\n        }\r\n        coordinateTransformer.setMathTransform(mathTransform);\r\n        try {\r\n        \treturn coordinateTransformer.transform(geometry);\r\n        } catch (TransformException e) {\r\n        \tthrow new SpatialIndexException(e);\r\n        }\r\n    }","id":86189,"modified_method":"public Geometry transformGeometry(Geometry geometry, String sourceCRS, String targetCRS) throws SpatialIndexException {\r\n        //provisional workarounds\r\n        if (\"osgb:BNG\".equalsIgnoreCase(sourceCRS.trim()))\r\n        \tsourceCRS = \"EPSG:27700\";  \t    \r\n        if (\"osgb:BNG\".equalsIgnoreCase(targetCRS.trim()))\r\n        \ttargetCRS = \"EPSG:27700\"; \r\n        MathTransform transform = (MathTransform)transformations.get(sourceCRS + \"_\" + targetCRS);\r\n\t\tif (transform == null) {\r\n    \t\ttry {\r\n\t    \t\ttry {        \t\r\n    \t\t\t\ttransform = CRS.findMathTransform(CRS.decode(sourceCRS), CRS.decode(targetCRS), useLenientMode);\r\n\t    \t\t} catch (OperationNotFoundException e) {\r\n\t    \t\t\tLOG.info(e);\r\n\t    \t\t\tLOG.info(\"Switching to lenient mode... beware of precision loss !\");\r\n\t    \t\t\t//Last parameter set to true ; won't bail out if it can't find the Bursa Wolf parameters\r\n\t        \t\t//as it is the case in current gt2-epsg-wkt-2.4-M1.jar\r\n\t    \t\t\tuseLenientMode = true;\r\n\t    \t\t\ttransform = CRS.findMathTransform(CRS.decode(sourceCRS), CRS.decode(targetCRS), useLenientMode);\t\r\n\t    \t\t}\r\n\t    \t\ttransformations.put(sourceCRS + \"_\" + targetCRS, transform);\r\n\t    \t\tLOG.debug(\"Instantiated transformation from '\" + sourceCRS + \"' to '\" + targetCRS + \"'\");\r\n\t        } catch (NoSuchAuthorityCodeException e) {\r\n\t        \tLOG.error(e);\r\n\t        } catch (FactoryException e) {\r\n\t        \tLOG.error(e);\r\n    \t\t}\r\n\t\t}\r\n        if (transform == null) {\r\n    \t\tthrow new SpatialIndexException(\"Unable to get a transformation from '\" + sourceCRS + \"' to '\" + targetCRS +\"'\");        \t\t           \t\r\n        }\r\n        coordinateTransformer.setMathTransform(transform);\r\n        try {\r\n        \treturn coordinateTransformer.transform(geometry);\r\n        } catch (TransformException e) {\r\n        \tthrow new SpatialIndexException(e);\r\n        }\r\n    }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"private void processDeferredElement() {\r\n        \tif (deferredElement == null)\r\n        \t\treturn;    \r\n    \t\t//We need to collect the retained element's attributes in order to feed the SAX handler\r\n    \t\tAttributesImpl attList = collectAttributes(deferredElement); \r\n        \ttry {\r\n        \t\tgeometryDocument.startElement(deferredElement.getNamespaceURI(), deferredElement.getLocalName(), deferredElement.getQName().getStringValue(), attList);\r\n        \t} catch (Exception e) {\r\n        \t\te.printStackTrace();\r\n        \t\tLOG.error(e);\r\n        \t}        \t       \t\r\n        }","id":86190,"modified_method":"private void processDeferredElement() {  \r\n    \t\t//We need to collect the deferred element's attributes in order to feed the SAX handler\r\n        \tAttributesImpl attList = new AttributesImpl();\r\n        \tNamedNodeMap attrs = deferredElement.getAttributes();\r\n        \t\r\n        \tString whatToPush = null;\r\n        \t\r\n        \tfor (int i = 0; i < attrs.getLength() ; i++) {\r\n        \t\tAttrImpl attrib = (AttrImpl)attrs.item(i);\r\n        \t\t\r\n            \t//Store the srs\r\n        \t\tif (GML_NS.equals(deferredElement.getNamespaceURI())) {        \t\t\t\r\n        \t\t\t//Maybe we could assume a configurable default value here        \t\t\t\r\n        \t\t\tif (attrib.getName().equals(\"srsName\")) {        \t\t\r\n        \t\t\t\twhatToPush = attrib.getValue();\r\n        \t\t\t}\r\n        \t\t} \r\n        \t\t\r\n        \t\tattList.addAttribute(attrib.getNamespaceURI(), \r\n        \t\t\t\tattrib.getLocalName(), \r\n        \t\t\t\tattrib.getQName().getStringValue(), \r\n        \t\t\t\tInteger.toString(attrib.getType()), \r\n        \t\t\t\tattrib.getValue());            \t\t\r\n        \t}\r\n        \t\r\n        \tsrsNamesStack.push(whatToPush);\r\n\r\n        \ttry {\r\n        \t\tgeometryDocument.startElement(deferredElement.getNamespaceURI(), deferredElement.getLocalName(), deferredElement.getQName().getStringValue(), attList);\r\n        \t} catch (Exception e) {\r\n        \t\te.printStackTrace();\r\n        \t\tLOG.error(e);\r\n        \t} finally {\r\n        \t\tdeferredElement = null;\r\n        \t}\r\n        }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"public void endElement(Txn transaction, ElementImpl element, NodePath path) {\r\n        \tif (isDocumentGMLAware) {   \r\n        \t\t//Release the deferred element\r\n\t        \tprocessDeferredElement();\r\n\t        \tdeferredElement = null;\r\n        \t\tString currentSrsName = null;\r\n        \t\tif (GML_NS.equals(element.getNamespaceURI()))\r\n        \t\t\tcurrentSrsName = (String)srsNamesStack.pop();        \t\t\r\n        \t\ttry {\r\n        \t\t\tgeometryDocument.endElement(element.getNamespaceURI(), element.getLocalName(), element.getQName().getStringValue());\r\n\t        \t\t//Some invalid/(yet) incomplete geometries don't have a SRS\r\n\t        \t\tif (streamedGeometry != null && currentSrsName != null) {   \r\n\t        \t\t\tcurrentNodeId = element.getNodeId();\r\n\t\t    \t\t\tgeometries.put(currentNodeId, new SRSGeometry(currentSrsName, streamedGeometry));\t\t        \t\t\r\n\t\t\t        \tif (flushAfter != -1 && geometries.size() >= flushAfter) {\r\n\t\t\t        \t\t//Mmmh... doesn't flush since it is currently dependant from the\r\n\t\t\t        \t\t//number of nodes in the DOM file ; would need refactorings\r\n\t\t\t        \t\t//currentDoc.getBroker().checkAvailableMemory();\r\n\t\t\t        \t\tcurrentDoc.getBroker().flush();\r\n\t\t\t        \t\t///Aaaaaargl !\r\n\t\t\t        \t\tfinal double percent = ((double) Runtime.getRuntime().freeMemory() / (double) Runtime.getRuntime().maxMemory()) * 100;\r\n\t\t\t                if (percent < 30) {\t\t\t        \t\t\r\n\t\t\t                \tSystem.gc();\r\n\t\t\t                }\r\n\t\t\t        \t}\r\n\t        \t\t}        \t\t\r\n\t        \t} catch (Exception e) {\r\n\t        \t\tLOG.error(\"Unable to collect geometry for node: \" + currentNodeId + \". Indexing will be skipped\", e);        \t\t\r\n\t    \t\t} finally {  \r\n\t    \t\t\tstreamedGeometry = null;\t        \t\t\t\r\n\t    \t\t}\r\n        \t}\r\n        \t//Forward the event to the next listener \r\n            super.endElement(transaction, element, path);\r\n        }","id":86191,"modified_method":"public void endElement(Txn transaction, ElementImpl element, NodePath path) {\r\n        \tif (isDocumentGMLAware) {   \r\n        \t\t//Release the deferred element if any\r\n        \t\tif (deferredElement != null)        \t\t\r\n        \t\t\tprocessDeferredElement();\t        \t\r\n\t        \t//Process the element \r\n        \t\tprocessCurrentElement(element);\r\n        \t}\r\n        \t//Forward the event to the next listener \r\n            super.endElement(transaction, element, path);\r\n        }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"protected synchronized void releaseConnection(DBBroker broker) throws SQLException {   \r\n    \tconnectionOwner = null;\r\n    }","id":86192,"modified_method":"protected synchronized void releaseConnection(DBBroker broker) throws SQLException {   \r\n    \tif (connectionOwner == null)\r\n    \t\tthrow new SQLException(\"Attempted to release a connection that wasn't acquired\");\r\n    \tconnectionOwner = null;\r\n    }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"protected boolean checkIndex(DBBroker broker, Connection conn) throws SQLException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\r\n\t    \t\t\"SELECT * FROM \" + GMLHSQLIndex.TABLE_NAME + \";\"\r\n\t    \t);\r\n    \tResultSet rs = null;\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n\t        while (rs.next()) {\t        \t\r\n\t        \tGeometry original_geometry = wkbReader.read(rs.getBytes(\"WKB\"));\t\t        \t\r\n\t            if (!original_geometry.equals(wktReader.read(rs.getString(\"WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\t\t            \t\r\n\t        \tGeometry EPSG4326_geometry = wkbReader.read(rs.getBytes(\"EPSG4326_WKB\"));\t\t        \t\r\n\t            if (!EPSG4326_geometry.equals(wktReader.read(rs.getString(\"EPSG4326_WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"EPSG4326_WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            \r\n\t        \tif (!original_geometry.getGeometryType().equals(rs.getString(\"GEOMETRY_TYPE\"))) {\r\n\t        \t\tLOG.info(\"Inconsistent geometry type: \" + rs.getDouble(\"GEOMETRY_TYPE\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t        \t\r\n\t            if (original_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getArea() != rs.getDouble(\"AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\t        \t\r\n\t        \t\r\n\t        \tString srsName = rs.getString(\"SRS_NAME\");\r\n\t        \ttry {\r\n\t            \tif (!transformGeometry(original_geometry, srsName, \"EPSG:4326\").equals(EPSG4326_geometry)) {\r\n\t\t        \t\tLOG.info(\"Transformed original geometry inconsistent with stored tranformed one\");\r\n\t            \t\treturn false;\r\n\t            \t}\r\n\t        \t} catch (SpatialIndexException e) {\r\n\t            \t//Transforms the exception into an SQLException.\r\n\t            \tSQLException ee = new SQLException(e.getMessage());\r\n\t            \tee.initCause(e);\r\n\t            \tthrow ee;\r\n\t        \t}\r\n\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"EPSG4326_MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"EPSG4326_MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"EPSG4326_MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"EPSG4326_MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"EPSG4326_MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"EPSG4326_MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"EPSG4326_MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"EPSG4326_MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"EPSG4326_CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"EPSG4326_CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getArea() != rs.getDouble(\"EPSG4326_AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"EPSG4326_AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            \r\n\t            if (original_geometry.isEmpty() == rs.getBoolean(\"IS_CLOSED\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_CLOSED\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isSimple() != rs.getBoolean(\"IS_SIMPLE\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_SIMPLE\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isValid() != rs.getBoolean(\"IS_VALID\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_VALID\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\r\n\t            DocumentImpl doc = null;\r\n\t            try {\r\n\t            \tdoc = (DocumentImpl)broker.getXMLResource(XmldbURI.create(rs.getString(\"DOCUMENT_URI\")));\r\n\t            } catch (PermissionDeniedException e) {\r\n        \t\t\t//The broker has no right on the document\r\n\t            \tLOG.error(e);\r\n\t            \treturn false;\r\n\t            }\r\n\t            NodeId nodeId = new DLN(rs.getInt(\"NODE_ID_UNITS\"), rs.getBytes(\"NODE_ID\"), 0); \t    \t\t\r\n\t            StoredNode node = broker.objectWith(new NodeProxy((DocumentImpl)doc, nodeId));\r\n\t        \tif (!GMLHSQLIndexWorker.GML_NS.equals(node.getNamespaceURI())) {\r\n\t        \t\tLOG.info(\"GML indexed node (\" + node.getNodeId()+ \") is in the '\" + \r\n\t        \t\t\t\tnode.getNamespaceURI() + \"' namespace. '\" + \r\n\t        \t\t\t\tGMLHSQLIndexWorker.GML_NS + \"' was expected !\");\r\n\t        \t\treturn false;\r\n\t        \t}\r\n\t        \tif (!original_geometry.getGeometryType().equals(node.getLocalName())) {\r\n\t        \t\tif (\"Box\".equals(node.getLocalName()) && \"Polygon\".equals(original_geometry.getGeometryType())) {\r\n\t        \t\t\tLOG.debug(\"GML indexed node (\" + node.getNodeId() + \") is a gml:Box indexed as a polygon\");\r\n\t        \t\t} else {\r\n\t        \t\t\tLOG.info(\"GML indexed node (\" + node.getNodeId() + \") has '\" + \r\n\t        \t\t\t\t\tnode.getLocalName() + \"' as its local name. '\" + \r\n\t        \t\t\t\t\toriginal_geometry.getGeometryType() + \"' was expected !\");\r\n\t        \t\t\treturn false;\r\n\t        \t\t}\r\n\t        \t}\r\n\t        \t\r\n\t    \t\tLOG.info(node);\t        \t\t\r\n\t        }\r\n\t        return true;\r\n\t        \r\n        } catch (ParseException e) {\r\n        \t//Transforms the exception into an SQLException.\r\n        \t//Very unlikely to happen though...\r\n        \tSQLException ee = new SQLException(e.getMessage());\r\n        \tee.initCause(e);\r\n        \tthrow ee;\r\n\t\t} finally {   \r\n\t\t\tif (rs != null)\r\n\t\t\t\trs.close();\r\n\t\t\tif (ps != null)\r\n\t\t\t\tps.close();\t\r\n\t    }\r\n    }","id":86193,"modified_method":"protected boolean checkIndex(DBBroker broker, Connection conn) throws SQLException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\r\n\t    \t\t\"SELECT * FROM \" + GMLHSQLIndex.TABLE_NAME + \";\"\r\n\t    \t);\r\n    \tResultSet rs = null;\r\n    \ttry {\r\n    \t\trs = ps.executeQuery();\r\n\t        while (rs.next()) {\t        \t\r\n\t        \tGeometry original_geometry = wkbReader.read(rs.getBytes(\"WKB\"));\t\t        \t\r\n\t            if (!original_geometry.equals(wktReader.read(rs.getString(\"WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\t\t            \t\r\n\t        \tGeometry EPSG4326_geometry = wkbReader.read(rs.getBytes(\"EPSG4326_WKB\"));\t\t        \t\r\n\t            if (!EPSG4326_geometry.equals(wktReader.read(rs.getString(\"EPSG4326_WKT\")))) {\r\n\t            \tLOG.info(\"Inconsistent WKT : \" + rs.getString(\"EPSG4326_WKT\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            \r\n\t        \tif (!original_geometry.getGeometryType().equals(rs.getString(\"GEOMETRY_TYPE\"))) {\r\n\t        \t\tLOG.info(\"Inconsistent geometry type: \" + rs.getDouble(\"GEOMETRY_TYPE\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t        \t\r\n\t            if (original_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (original_geometry.getArea() != rs.getDouble(\"AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\t        \t\r\n\t        \t\r\n\t        \tString srsName = rs.getString(\"SRS_NAME\");\r\n\t        \ttry {\r\n\t            \tif (!transformGeometry(original_geometry, srsName, \"EPSG:4326\").equals(EPSG4326_geometry)) {\r\n\t\t        \t\tLOG.info(\"Transformed original geometry inconsistent with stored tranformed one\");\r\n\t            \t\treturn false;\r\n\t            \t}\r\n\t        \t} catch (SpatialIndexException e) {\r\n\t            \t//Transforms the exception into an SQLException.\r\n\t            \tSQLException ee = new SQLException(e.getMessage());\r\n\t            \tee.initCause(e);\r\n\t            \tthrow ee;\r\n\t        \t}\r\n\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinX() != rs.getDouble(\"EPSG4326_MINX\")) {\r\n\t            \tLOG.info(\"Inconsistent MinX: \" + rs.getDouble(\"EPSG4326_MINX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxX() != rs.getDouble(\"EPSG4326_MAXX\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxX: \" + rs.getDouble(\"EPSG4326_MAXX\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMinY() != rs.getDouble(\"EPSG4326_MINY\")) {\r\n\t            \tLOG.info(\"Inconsistent MinY: \" + rs.getDouble(\"EPSG4326_MINY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getEnvelopeInternal().getMaxY() != rs.getDouble(\"EPSG4326_MAXY\")) {\r\n\t            \tLOG.info(\"Inconsistent MaxY: \" + rs.getDouble(\"EPSG4326_MAXY\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().x != rs.getDouble(\"EPSG4326_CENTROID_X\")) {\r\n\t            \tLOG.info(\"Inconsistent X for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_X\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getCentroid().getCoordinate().y != rs.getDouble(\"EPSG4326_CENTROID_Y\")) {\r\n\t            \tLOG.info(\"Inconsistent Y for centroid : \" + rs.getDouble(\"EPSG4326_CENTROID_Y\"));\r\n\t    \t\t\treturn false;\r\n\t        \t}\r\n\t            if (EPSG4326_geometry.getArea() != rs.getDouble(\"EPSG4326_AREA\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getDouble(\"EPSG4326_AREA\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            \r\n\t            if (original_geometry.isEmpty() == rs.getBoolean(\"IS_CLOSED\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_CLOSED\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isSimple() != rs.getBoolean(\"IS_SIMPLE\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_SIMPLE\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\t            if (original_geometry.isValid() != rs.getBoolean(\"IS_VALID\")) {\r\n\t            \tLOG.info(\"Inconsistent area: \" + rs.getBoolean(\"IS_VALID\"));\r\n\t    \t\t\treturn false;\r\n\t            }\r\n\r\n\t            DocumentImpl doc = null;\r\n\t            try {\r\n\t            \tdoc = (DocumentImpl)broker.getXMLResource(XmldbURI.create(rs.getString(\"DOCUMENT_URI\")));\r\n\t            } catch (PermissionDeniedException e) {\r\n        \t\t\t//The broker has no right on the document\r\n\t            \tLOG.error(e);\r\n\t            \treturn false;\r\n\t            }\r\n\t            NodeId nodeId = new DLN(rs.getInt(\"NODE_ID_UNITS\"), rs.getBytes(\"NODE_ID\"), 0); \t    \t\t\r\n\t            StoredNode node = broker.objectWith(new NodeProxy((DocumentImpl)doc, nodeId));\r\n\t            if (node == null) {\r\n\t            \tLOG.info(\"Node \" + nodeId + \"doesn't exist\");\r\n\t            \treturn false;\r\n\t            }\t            \t\r\n\t        \tif (!GMLHSQLIndexWorker.GML_NS.equals(node.getNamespaceURI())) {\r\n\t        \t\tLOG.info(\"GML indexed node (\" + node.getNodeId()+ \") is in the '\" + \r\n\t        \t\t\t\tnode.getNamespaceURI() + \"' namespace. '\" + \r\n\t        \t\t\t\tGMLHSQLIndexWorker.GML_NS + \"' was expected !\");\r\n\t        \t\treturn false;\r\n\t        \t}\r\n\t        \tif (!original_geometry.getGeometryType().equals(node.getLocalName())) {\r\n\t        \t\tif (\"Box\".equals(node.getLocalName()) && \"Polygon\".equals(original_geometry.getGeometryType())) {\r\n\t        \t\t\tLOG.debug(\"GML indexed node (\" + node.getNodeId() + \") is a gml:Box indexed as a polygon\");\r\n\t        \t\t} else {\r\n\t        \t\t\tLOG.info(\"GML indexed node (\" + node.getNodeId() + \") has '\" + \r\n\t        \t\t\t\t\tnode.getLocalName() + \"' as its local name. '\" + \r\n\t        \t\t\t\t\toriginal_geometry.getGeometryType() + \"' was expected !\");\r\n\t        \t\t\treturn false;\r\n\t        \t\t}\r\n\t        \t}\r\n\t        \t\r\n\t    \t\tLOG.info(node);\t        \t\t\r\n\t        }\r\n\t        return true;\r\n\t        \r\n        } catch (ParseException e) {\r\n        \t//Transforms the exception into an SQLException.\r\n        \t//Very unlikely to happen though...\r\n        \tSQLException ee = new SQLException(e.getMessage());\r\n        \tee.initCause(e);\r\n        \tthrow ee;\r\n\t\t} finally {   \r\n\t\t\tif (rs != null)\r\n\t\t\t\trs.close();\r\n\t\t\tif (ps != null)\r\n\t\t\t\tps.close();\t\r\n\t    }\r\n    }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"protected boolean saveGeometryNode(Geometry geometry, String srsName, DocumentImpl doc, NodeId nodeId, Connection conn) throws SQLException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\"INSERT INTO \" + GMLHSQLIndex.TABLE_NAME + \"(\" +\r\n        \t\t/*1*/ \"DOCUMENT_URI, \" +            \t\t\r\n        \t\t/*2*/ \"NODE_ID_UNITS, \" + \r\n        \t\t/*3*/ \"NODE_ID, \" +        \t\t\t\r\n        \t\t/*4*/ \"GEOMETRY_TYPE, \" +\r\n        \t\t/*5*/ \"SRS_NAME, \" +\r\n        \t\t/*6*/ \"WKT, \" +\r\n        \t\t/*7*/ \"WKB, \" +\r\n    \t\t\t/*8*/ \"MINX, \" +\r\n    \t\t\t/*9*/ \"MAXX, \" +\r\n    \t\t\t/*10*/ \"MINY, \" +\r\n    \t\t\t/*11*/ \"MAXY, \" +\r\n    \t\t\t/*12*/ \"CENTROID_X, \" +\r\n    \t\t\t/*13*/ \"CENTROID_Y, \" +\r\n    \t\t\t/*14*/ \"AREA, \" +\r\n    \t\t\t//Boundary ?        \t\t\r\n        \t\t/*15*/ \"EPSG4326_WKT, \" +\r\n        \t\t/*16*/ \"EPSG4326_WKB, \" +\r\n        \t\t/*17*/ \"EPSG4326_MINX, \" +\r\n    \t\t\t/*18*/ \"EPSG4326_MAXX, \" +\r\n    \t\t\t/*19*/ \"EPSG4326_MINY, \" +\r\n    \t\t\t/*20*/ \"EPSG4326_MAXY, \" +\r\n    \t\t\t/*21*/ \"EPSG4326_CENTROID_X, \" +\r\n    \t\t\t/*22*/ \"EPSG4326_CENTROID_Y, \" +\r\n    \t\t\t/*23*/ \"EPSG4326_AREA,\" +\r\n    \t\t\t//Boundary ?\r\n    \t\t\t/*24*/ \"IS_CLOSED, \" +\r\n    \t\t\t/*25*/ \"IS_SIMPLE, \" +\r\n    \t\t\t/*26*/ \"IS_VALID\" +    \t\t\t\r\n        \t\t\") VALUES (\" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?\"\r\n        \t\t+ \")\"\r\n            );       \r\n    \ttry {\r\n    \t\t//TODO : use a default SRS from the config file ?\r\n            if (srsName == null) {\r\n        \t\tLOG.error(\"Geometry has a null SRS\");\r\n        \t\treturn false;                  \t\r\n            }   \r\n            Geometry EPSG4326_geometry = null;\r\n            try {\r\n            \tEPSG4326_geometry = transformGeometry(geometry, srsName, \"EPSG:4326\");\r\n            } catch (SpatialIndexException e) {\r\n\t        \t//Transforms the exception into an SQLException.\r\n\t        \tSQLException ee = new SQLException(e.getMessage());\r\n\t        \tee.initCause(e);\r\n\t        \tthrow ee;\r\n            }\r\n            /*DOCUMENT_URI*/ ps.setString(1, doc.getURI().toString());\t\r\n            /*NODE_ID_UNITS*/ ps.setInt(2, nodeId.units());\r\n            byte[] bytes = new byte[nodeId.size()];\r\n            nodeId.serialize(bytes, 0);\r\n            /*NODE_ID*/ ps.setBytes(3, bytes);\r\n            /*GEOMETRY_TYPE*/ ps.setString(4, geometry.getGeometryType());\r\n            /*SRS_NAME*/ ps.setString(5, srsName);\r\n            /*WKT*/ ps.setString(6, wktWriter.write(geometry));\r\n            /*WKB*/ ps.setBytes(7, wkbWriter.write(geometry));\r\n            /*MINX*/ ps.setDouble(8, geometry.getEnvelopeInternal().getMinX());\r\n        \t/*MAXX*/ ps.setDouble(9, geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*MINY*/ ps.setDouble(10, geometry.getEnvelopeInternal().getMinY());\r\n        \t/*MAXY*/ ps.setDouble(11, geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*CENTROID_X*/ ps.setDouble(12, geometry.getCentroid().getCoordinate().x);   \r\n        \t/*CENTROID_Y*/ ps.setDouble(13, geometry.getCentroid().getCoordinate().y);  \r\n            //geometry.getRepresentativePoint()\r\n        \t/*AREA*/ ps.setDouble(14, geometry.getArea());\r\n        \t//Boundary ?\r\n            /*EPSG4326_WKT*/ ps.setString(15, wktWriter.write(EPSG4326_geometry));\r\n            /*EPSG4326_WKB*/ ps.setBytes(16, wkbWriter.write(EPSG4326_geometry));\t\t\r\n        \t/*EPSG4326_MINX*/ ps.setDouble(17, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n        \t/*EPSG4326_MAXX*/ ps.setDouble(18, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*EPSG4326_MINY*/ ps.setDouble(19, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n        \t/*EPSG4326_MAXY*/ ps.setDouble(20, EPSG4326_geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*EPSG4326_CENTROID_X*/ ps.setDouble(21, EPSG4326_geometry.getCentroid().getCoordinate().x);   \r\n        \t/*EPSG4326_CENTROID_Y*/ ps.setDouble(22, EPSG4326_geometry.getCentroid().getCoordinate().y);  \r\n            //EPSG4326_geometry.getRepresentativePoint()\r\n        \t/*EPSG4326_AREA*/ ps.setDouble(23, EPSG4326_geometry.getArea());\r\n\t\t\t//Boundary ?\r\n        \t//As discussed earlier, all instances of SFS geometry classes\r\n        \t//are topologically closed by definition.\r\n        \t//For empty Curves, isClosed is defined to have the value false.\r\n        \t/*IS_CLOSED*/ ps.setBoolean(24, !geometry.isEmpty());\r\n\t\t\t/*IS_SIMPLE*/ ps.setBoolean(25, geometry.isSimple());\r\n\t\t\t//Should always be true (the GML SAX parser makes a too severe check)\r\n\t\t\t/*IS_VALID*/ ps.setBoolean(26, geometry.isValid());\r\n        \treturn (ps.executeUpdate() == 1);\r\n    \t} finally {\r\n        \tif (ps != null)\r\n        \t\tps.close();\r\n            //Let's help the garbage collector...\r\n        \tgeometry = null;\r\n    \t}    \t\r\n    }","id":86194,"modified_method":"protected boolean saveGeometryNode(Geometry geometry, String srsName, DocumentImpl doc, NodeId nodeId, Connection conn) throws SQLException {\r\n    \tPreparedStatement ps = conn.prepareStatement(\"INSERT INTO \" + GMLHSQLIndex.TABLE_NAME + \"(\" +\r\n        \t\t/*1*/ \"DOCUMENT_URI, \" +            \t\t\r\n        \t\t/*2*/ \"NODE_ID_UNITS, \" + \r\n        \t\t/*3*/ \"NODE_ID, \" +        \t\t\t\r\n        \t\t/*4*/ \"GEOMETRY_TYPE, \" +\r\n        \t\t/*5*/ \"SRS_NAME, \" +\r\n        \t\t/*6*/ \"WKT, \" +\r\n        \t\t/*7*/ \"WKB, \" +\r\n    \t\t\t/*8*/ \"MINX, \" +\r\n    \t\t\t/*9*/ \"MAXX, \" +\r\n    \t\t\t/*10*/ \"MINY, \" +\r\n    \t\t\t/*11*/ \"MAXY, \" +\r\n    \t\t\t/*12*/ \"CENTROID_X, \" +\r\n    \t\t\t/*13*/ \"CENTROID_Y, \" +\r\n    \t\t\t/*14*/ \"AREA, \" +\r\n    \t\t\t//Boundary ?        \t\t\r\n        \t\t/*15*/ \"EPSG4326_WKT, \" +\r\n        \t\t/*16*/ \"EPSG4326_WKB, \" +\r\n        \t\t/*17*/ \"EPSG4326_MINX, \" +\r\n    \t\t\t/*18*/ \"EPSG4326_MAXX, \" +\r\n    \t\t\t/*19*/ \"EPSG4326_MINY, \" +\r\n    \t\t\t/*20*/ \"EPSG4326_MAXY, \" +\r\n    \t\t\t/*21*/ \"EPSG4326_CENTROID_X, \" +\r\n    \t\t\t/*22*/ \"EPSG4326_CENTROID_Y, \" +\r\n    \t\t\t/*23*/ \"EPSG4326_AREA,\" +\r\n    \t\t\t//Boundary ?\r\n    \t\t\t/*24*/ \"IS_CLOSED, \" +\r\n    \t\t\t/*25*/ \"IS_SIMPLE, \" +\r\n    \t\t\t/*26*/ \"IS_VALID\" +    \t\t\t\r\n        \t\t\") VALUES (\" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?, ?, ?, ?, ?, \" +\r\n        \t\t\t\"?\"\r\n        \t\t+ \")\"\r\n            );       \r\n    \ttry {\r\n            Geometry EPSG4326_geometry = null;\r\n            try {\r\n            \tEPSG4326_geometry = transformGeometry(geometry, srsName, \"EPSG:4326\");\r\n            } catch (SpatialIndexException e) {\r\n\t        \t//Transforms the exception into an SQLException.\r\n\t        \tSQLException ee = new SQLException(e.getMessage());\r\n\t        \tee.initCause(e);\r\n\t        \tthrow ee;\r\n            }\r\n            /*DOCUMENT_URI*/ ps.setString(1, doc.getURI().toString());\t\r\n            /*NODE_ID_UNITS*/ ps.setInt(2, nodeId.units());\r\n            byte[] bytes = new byte[nodeId.size()];\r\n            nodeId.serialize(bytes, 0);\r\n            /*NODE_ID*/ ps.setBytes(3, bytes);\r\n            /*GEOMETRY_TYPE*/ ps.setString(4, geometry.getGeometryType());\r\n            /*SRS_NAME*/ ps.setString(5, srsName);\r\n            /*WKT*/ ps.setString(6, wktWriter.write(geometry));\r\n            /*WKB*/ ps.setBytes(7, wkbWriter.write(geometry));\r\n            /*MINX*/ ps.setDouble(8, geometry.getEnvelopeInternal().getMinX());\r\n        \t/*MAXX*/ ps.setDouble(9, geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*MINY*/ ps.setDouble(10, geometry.getEnvelopeInternal().getMinY());\r\n        \t/*MAXY*/ ps.setDouble(11, geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*CENTROID_X*/ ps.setDouble(12, geometry.getCentroid().getCoordinate().x);   \r\n        \t/*CENTROID_Y*/ ps.setDouble(13, geometry.getCentroid().getCoordinate().y);  \r\n            //geometry.getRepresentativePoint()\r\n        \t/*AREA*/ ps.setDouble(14, geometry.getArea());\r\n        \t//Boundary ?\r\n            /*EPSG4326_WKT*/ ps.setString(15, wktWriter.write(EPSG4326_geometry));\r\n            /*EPSG4326_WKB*/ ps.setBytes(16, wkbWriter.write(EPSG4326_geometry));\t\t\r\n        \t/*EPSG4326_MINX*/ ps.setDouble(17, EPSG4326_geometry.getEnvelopeInternal().getMinX());\r\n        \t/*EPSG4326_MAXX*/ ps.setDouble(18, EPSG4326_geometry.getEnvelopeInternal().getMaxX());\r\n        \t/*EPSG4326_MINY*/ ps.setDouble(19, EPSG4326_geometry.getEnvelopeInternal().getMinY());\r\n        \t/*EPSG4326_MAXY*/ ps.setDouble(20, EPSG4326_geometry.getEnvelopeInternal().getMaxY());\r\n        \t/*EPSG4326_CENTROID_X*/ ps.setDouble(21, EPSG4326_geometry.getCentroid().getCoordinate().x);   \r\n        \t/*EPSG4326_CENTROID_Y*/ ps.setDouble(22, EPSG4326_geometry.getCentroid().getCoordinate().y);  \r\n            //EPSG4326_geometry.getRepresentativePoint()\r\n        \t/*EPSG4326_AREA*/ ps.setDouble(23, EPSG4326_geometry.getArea());\r\n\t\t\t//Boundary ?\r\n        \t//As discussed earlier, all instances of SFS geometry classes\r\n        \t//are topologically closed by definition.\r\n        \t//For empty Curves, isClosed is defined to have the value false.\r\n        \t/*IS_CLOSED*/ ps.setBoolean(24, !geometry.isEmpty());\r\n\t\t\t/*IS_SIMPLE*/ ps.setBoolean(25, geometry.isSimple());\r\n\t\t\t//Should always be true (the GML SAX parser makes a too severe check)\r\n\t\t\t/*IS_VALID*/ ps.setBoolean(26, geometry.isValid());\r\n        \treturn (ps.executeUpdate() == 1);\r\n    \t} finally {\r\n        \tif (ps != null)\r\n        \t\tps.close();\r\n            //Let's help the garbage collector...\r\n        \tgeometry = null;\r\n    \t}    \t\r\n    }","commit_id":"c2a4907f3883189b47be0a1e0efe87122fed6faf","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\n\tpublic void testTrackServicesByFilter() throws Exception {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tFilter filter = registry.getFilter(\"(a.property=G)\");\n\n\t\tServiceTracker<InterfaceOne, InterfaceOne> serviceTracker =\n\t\t\tregistry.trackServices(filter);\n\n\t\ttestTrackServices(serviceTracker, 1);\n\t}","id":86195,"modified_method":"@Test\n\tpublic void testTrackServicesByFilter() throws Exception {\n\t\tTestTrackServices testTrackServices = new TestTrackServices() {\n\n\t\t\t@Override\n\t\t\tpublic ServiceTracker<InterfaceOne, InterfaceOne>\n\t\t\t\tgetServiceTracker() {\n\n\t\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\t\t\n\t\t\t\tFilter filter = registry.getFilter(\"(a.property=G)\");\n\t\t\n\t\t\t\treturn registry.trackServices(filter);\n\t\t\t}\n\n\t\t};\n\n\t\ttestTrackServices.test(1);\n\t}","commit_id":"260e400e3dc25da86c7330dc04c9249df9cf278d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testTrackServicesByClass() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tServiceTracker<InterfaceOne, InterfaceOne> serviceTracker =\n\t\t\tregistry.trackServices(InterfaceOne.class);\n\n\t\ttestTrackServices(serviceTracker, 2);\n\t}","id":86196,"modified_method":"@Test\n\tpublic void testTrackServicesByClass() {\n\t\tTestTrackServices testTrackServices = new TestTrackServices() {\n\n\t\t\t@Override\n\t\t\tpublic ServiceTracker<InterfaceOne, InterfaceOne>\n\t\t\t\tgetServiceTracker() {\n\n\t\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\t\t\n\t\t\t\treturn registry.trackServices(InterfaceOne.class);\n\t\t\t}\n\n\t\t};\n\n\t\ttestTrackServices.test(2);\n\t}","commit_id":"260e400e3dc25da86c7330dc04c9249df9cf278d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testTrackServicesByClassName() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tServiceTracker<InterfaceOne, InterfaceOne> serviceTracker =\n\t\t\tregistry.trackServices(InterfaceOne.class.getName());\n\n\t\ttestTrackServices(serviceTracker, 2);\n\t}","id":86197,"modified_method":"@Test\n\tpublic void testTrackServicesByClassName() {\n\t\tTestTrackServices testTrackServices = new TestTrackServices() {\n\n\t\t\t@Override\n\t\t\tpublic ServiceTracker<InterfaceOne, InterfaceOne>\n\t\t\t\tgetServiceTracker() {\n\n\t\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\t\t\n\t\t\t\treturn registry.trackServices(InterfaceOne.class.getName());\n\t\t\t}\n\n\t\t};\n\n\t\ttestTrackServices.test(2);\n\t}","commit_id":"260e400e3dc25da86c7330dc04c9249df9cf278d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void schedule(Runnable r) {\n        System.out.println(\"Aventando una tarea al pool\");\n        tpool.submit(r, null);\n    }","id":86198,"modified_method":"@Override\n    public void schedule(Runnable r) {\n        System.out.printf(\"Submitting task into pool: %s%n\", r);\n        tpool.execute(r);\n    }","commit_id":"d69c8addb90baedab7a4967d90740247afb1856f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void finished() {\n        System.out.println(\"esperando a que termine el pool con \" + tpool.getActiveCount() + \" hilos activos y \" + tpool.getTaskCount() + \" tareas\");\n        try {\n            while (tpool.getActiveCount() > 0) {\n                tpool.awaitTermination(10, TimeUnit.SECONDS);\n                System.out.println(\"esperando a que termine el pool con \" + tpool.getActiveCount() + \" hilos activos y \" + tpool.getTaskCount() + \" tareas\");\n            }\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        } finally {\n            tpool.shutdownNow();\n        }\n    }","id":86199,"modified_method":"@Override\n    public void finished() {\n        System.out.printf(\"Waiting for pool to finish with %d active threads and %d tasks%n\", tpool.getActiveCount(), tpool.getTaskCount());\n        try {\n            tpool.shutdown();\n            while (tpool.getActiveCount() > 0) {\n                tpool.awaitTermination(5, TimeUnit.SECONDS);\n                System.out.printf(\"Waiting for pool to finish with %d active threads and %d tasks%n\", tpool.getActiveCount(), tpool.getTaskCount());\n            }\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        } finally {\n            tpool.shutdownNow();\n        }\n    }","commit_id":"d69c8addb90baedab7a4967d90740247afb1856f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public ConcurrentSuite(Class<?> clase) throws InitializationError {\n        super(clase, new AllDefaultPossibilitiesBuilder(true));\n        setScheduler(new ConcurrentScheduler());\n    }","id":86200,"modified_method":"public ConcurrentSuite(Class<?> clase, RunnerBuilder builder) throws InitializationError {\n        super(clase, builder);\n        setScheduler(new ConcurrentScheduler());\n    }","commit_id":"d69c8addb90baedab7a4967d90740247afb1856f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static List doDelete(PipelineContext pipelineContext, XFormsContainingDocument containingDocument, List collectionToUpdate, int deleteIndex) {\n\n        final boolean isEmptyNodesetBinding = collectionToUpdate == null || collectionToUpdate.size() == 0;\n\n        final List deletedNodeInfos;\n        if (isEmptyNodesetBinding) {\n            deletedNodeInfos = Collections.EMPTY_LIST;\n        } else if (deleteIndex == -1) {\n            // Delete the entire collection\n\n            deletedNodeInfos = new ArrayList(collectionToUpdate.size());\n            for (int i = 1; i <= collectionToUpdate.size(); i++) {\n                final NodeInfo deletedNodeInfo = doDeleteOne(containingDocument, collectionToUpdate, i);\n                if (deletedNodeInfo != null) {\n                    deletedNodeInfos.add(deletedNodeInfo);\n                }\n            }\n        } else {\n            // Find actual deletion point\n\n            final NodeInfo deletedNodeInfo = doDeleteOne(containingDocument, collectionToUpdate, deleteIndex);\n            if (deletedNodeInfo != null) {\n                deletedNodeInfos = Collections.singletonList(deletedNodeInfo);\n            } else {\n                deletedNodeInfos = Collections.EMPTY_LIST;\n            }\n        }\n\n        if (deletedNodeInfos.size() == 0) {\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:delete\", \"empty collection, terminating\");\n        } else {\n            // Identify the instance that actually changes\n            // NOTE: More than one instance may be modified. For now we look at the first one.\n            final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode((NodeInfo) deletedNodeInfos.get(0));\n\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:delete\", \"removed nodes\",\n                        new String[] { \"count\", Integer.toString(deletedNodeInfos.size()), \"instance\", modifiedInstance.getEffectiveId() });\n\n            // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n            modifiedInstance.getModel(containingDocument).setAllDeferredFlags(true);\n            containingDocument.getControls().markDirtySinceLastRequest(true);\n\n            // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n            modifiedInstance.getContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(modifiedInstance, deletedNodeInfos, deleteIndex));\n        }\n\n        return deletedNodeInfos;\n    }","id":86201,"modified_method":"public static List doDelete(PipelineContext pipelineContext, XFormsContainingDocument containingDocument, List collectionToUpdate, int deleteIndex) {\n\n        final boolean isEmptyNodesetBinding = collectionToUpdate == null || collectionToUpdate.size() == 0;\n\n        final List deletedNodeInfos;\n        if (isEmptyNodesetBinding) {\n            deletedNodeInfos = Collections.EMPTY_LIST;\n        } else if (deleteIndex == -1) {\n            // Delete the entire collection\n\n            deletedNodeInfos = new ArrayList(collectionToUpdate.size());\n            for (int i = 1; i <= collectionToUpdate.size(); i++) {\n                final NodeInfo deletedNodeInfo = doDeleteOne(containingDocument, collectionToUpdate, i);\n                if (deletedNodeInfo != null) {\n                    deletedNodeInfos.add(deletedNodeInfo);\n                }\n            }\n        } else {\n            // Find actual deletion point\n\n            final NodeInfo deletedNodeInfo = doDeleteOne(containingDocument, collectionToUpdate, deleteIndex);\n            if (deletedNodeInfo != null) {\n                deletedNodeInfos = Collections.singletonList(deletedNodeInfo);\n            } else {\n                deletedNodeInfos = Collections.EMPTY_LIST;\n            }\n        }\n\n        if (deletedNodeInfos.size() == 0) {\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:delete\", \"empty collection, terminating\");\n        } else {\n            // Identify the instance that actually changes\n            // NOTE: More than one instance may be modified. For now we look at the first one.\n            final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode((NodeInfo) deletedNodeInfos.get(0));\n\n            if (XFormsServer.logger.isDebugEnabled())\n                containingDocument.logDebug(\"xforms:delete\", \"removed nodes\",\n                        new String[] { \"count\", Integer.toString(deletedNodeInfos.size()), \"instance\",\n                                (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : null });\n\n            if (modifiedInstance  != null) {\n                // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n                \n                // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n                modifiedInstance.getModel(containingDocument).setAllDeferredFlags(true);\n                containingDocument.getControls().markDirtySinceLastRequest(true);\n\n                // \"4. If the delete is successful, the event xforms-delete is dispatched.\"\n                modifiedInstance.getContainer(containingDocument).dispatchEvent(pipelineContext, new XFormsDeleteEvent(modifiedInstance, deletedNodeInfos, deleteIndex));\n            }\n        }\n\n        return deletedNodeInfos;\n    }","commit_id":"296fffa807799d19e83f44f91e8f1ba19f9f5ccd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void doInsert(PipelineContext pipelineContext, XFormsContainingDocument containingDocument, String positionAttribute,\n                                List collectionToBeUpdated, NodeInfo insertContextNodeInfo, List originItems, int insertionIndex) {\n\n        final boolean isEmptyNodesetBinding = collectionToBeUpdated == null || collectionToBeUpdated.size() == 0;\n\n        // \"3. The origin node-set is determined.\"\n        // \"5. Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n        final List sourceNodes;\n        final List clonedNodes;\n        {\n            final List clonedNodesTemp;\n            if (originItems == null) {\n                // There are no explicitly specified origin objects, use node from Node Set Binding node-set\n\n                // \"If the origin attribute is not given and the Node Set Binding node-set is empty, then the origin\n                // node-set is the empty node-set. [...] The insert action is terminated with no effect if the\n                // origin node-set is the empty node-set.\"\n\n                if (isEmptyNodesetBinding) {\n                    if (XFormsServer.logger.isDebugEnabled())\n                        containingDocument.logDebug(\"xforms:insert\", \"origin node-set from node-set binding is empty, terminating\");\n                    return;\n                }\n\n                // \"Otherwise, if the origin attribute is not given, then the origin node-set consists of the last\n                // node of the Node Set Binding node-set.\"\n                final Node singleSourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1), CANNOT_INSERT_READONLY_MESSAGE);\n                final Node singleClonedNode = Dom4jUtils.createCopy(singleSourceNode);\n\n                sourceNodes = Collections.singletonList(singleSourceNode);\n                clonedNodesTemp = Collections.singletonList(singleClonedNode);\n\n                originItems = null;\n            } else {\n                // There are explicitly specified origin objects\n\n                // \"The insert action is terminated with no effect if the origin node-set is the empty node-set.\"\n                if (originItems.size() == 0) {\n                    if (XFormsServer.logger.isDebugEnabled())\n                        containingDocument.logDebug(\"xforms:insert\", \"origin node-set is empty, terminating\");\n                    return;\n                }\n\n                // \"Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n\n                sourceNodes = new ArrayList(originItems.size()); // set to max possible size\n                clonedNodesTemp = new ArrayList(originItems.size());\n\n                for (Iterator i = originItems.iterator(); i.hasNext();) {\n                    final Object currentObject = i.next();\n\n                    if (currentObject instanceof NodeInfo) {\n                        // This is the regular case covered by XForms 1.1 / XPath 1.0\n\n                        final Node sourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) currentObject, CANNOT_INSERT_READONLY_MESSAGE);\n                        final Node clonedNode = (sourceNode instanceof Element) ? ((Node) ((Element) sourceNode).createCopy()) : (Node) sourceNode.clone();\n\n                        sourceNodes.add(sourceNode);\n                        clonedNodesTemp.add(clonedNode);\n\n                    } else {\n                        // This is an extension: support sequences containing other items\n\n                        // Convert the result to a text node\n//                            final String stringValue = ((Item) currentObject).getStringValue();\n                        final String stringValue = currentObject.toString(); // we get String, Long, etc.\n                        final Text textNode = Dom4jUtils.createText(stringValue);\n\n                        sourceNodes.add(null); // there is no source node for this cloned node, it's a source item\n                        clonedNodesTemp.add(textNode);\n                    }\n                }\n            }\n\n            for (int i = 0; i < clonedNodesTemp.size(); i++) {\n                final Node clonedNodeTemp = (Node) clonedNodesTemp.get(i);\n\n                if (clonedNodeTemp instanceof Element)\n                    InstanceData.remove(clonedNodeTemp);\n                else if (clonedNodeTemp instanceof Attribute)\n                    InstanceData.remove(clonedNodeTemp);\n                else if (clonedNodeTemp instanceof Document) {\n                    final Element clonedNodeTempRootElement = clonedNodeTemp.getDocument().getRootElement();\n                    InstanceData.remove(clonedNodeTempRootElement);\n                    // We can never really insert a document into anything, but we assume that this means the root element\n                    clonedNodesTemp.set(i, clonedNodeTempRootElement.detach());\n                }\n            }\n            clonedNodes = clonedNodesTemp;\n        }\n\n        // \"6. The target location of each cloned node or nodes is determined\"\n        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target location\n        // depending on their node type.\"\n\n        // This attribute is a temporary HACK, used to improve performance when going offline\n        final boolean isAdjustIndexes = isAdjustIndexes(containingDocument);\n\n        // Identify the instance that actually changes\n        final XFormsInstance modifiedInstance;\n        // Find actual insertion point and insert\n        final NodeInfo insertLocationNodeInfo;\n        final List insertedNodes;\n        if (isEmptyNodesetBinding) {\n\n            // \"If the Node Set Binding node-set is not specified or empty, the insert location node is the insert\n            // context node.\"\n\n            // \"a. If the Node Set Binding node-set is not specified or empty, the target location depends on the\n            // node type of the cloned node. If the cloned node is an attribute, then the target location is before\n            // the first attribute of the insert location node. If the cloned node is not an attribute, then the\n            // target location is before the first child of the insert location node.\"\n\n            modifiedInstance = containingDocument.getInstanceForNode(insertContextNodeInfo);\n            insertLocationNodeInfo = insertContextNodeInfo;\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertContextNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            insertedNodes = doInsert(insertLocationNode, clonedNodes);\n\n            // Normalize text nodes if needed to respect XPath 1.0 constraint\n            {\n                boolean hasTextNode = false;\n                for (int i = 0; i < clonedNodes.size(); i++) {\n                    final Node clonedNode = (Node) clonedNodes.get(i);\n                    hasTextNode |= clonedNode.getNodeType() == Node.TEXT_NODE;\n                }\n                if (hasTextNode)\n                    Dom4jUtils.normalizeTextNodes(insertLocationNode);\n            }\n        } else {\n            // One or more nodes were inserted\n\n            // HACK used to improve performance when going offline: when !isAdjustIndexes, always insert at the end of the node-set\n            insertLocationNodeInfo = (NodeInfo) collectionToBeUpdated.get(isAdjustIndexes ? insertionIndex - 1 : collectionToBeUpdated.size() - 1);\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertLocationNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            modifiedInstance = containingDocument.getInstanceForNode(insertLocationNodeInfo);\n\n//                if (insertLocationNode.getNodeType() != clonedNode.getNodeType()) {\n//                    // \"2. If the node type of the cloned node does not match the node type of the insert location\n//                    // node, then the target location is before the first child or attribute of the insert location\n//                    // node, based on the node type of the cloned node.\"\n//\n//                    doInsert(insertLocationNode, clonedNode);\n//                } else {\n\n                if (insertLocationNode.getDocument().getRootElement() == insertLocationNode) {\n\n                    // \"c. if insert location node is the root element of an instance, then that instance root element\n                    // location is the target location. If there is more than one cloned node to insert, only the\n                    // first node that does not cause a conflict is considered.\"\n\n                    insertedNodes = doInsert(insertLocationNode.getDocument(), clonedNodes);\n\n                    // NOTE: Don't need to normalize text nodes in this case, as no new text node is inserted\n                } else {\n                    // \"d. Otherwise, the target location is immediately before or after the insert location\n                    // node, based on the position attribute setting or its default.\"\n\n                    if (insertLocationNode.getNodeType() == Node.ATTRIBUTE_NODE) {\n                        // Special case for attributes\n\n                        // NOTE: In XML, attributes are unordered. dom4j handles them as a list so has order, but\n                        // the XForms spec shouldn't rely on attribute order. We could try to keep the order, but it\n                        // is harder as we have to deal with removing duplicate attributes and find a reasonable\n                        // insertion strategy.\n\n                        // TODO: Don't think we should even do this now in XForms 1.1\n                        insertedNodes = doInsert(insertLocationNode.getParent(), clonedNodes);\n\n                    } else {\n                        // Other node types\n                        final Element parentNode = insertLocationNode.getParent();\n                        final List siblingElements = parentNode.content();\n                        final int actualIndex = siblingElements.indexOf(insertLocationNode);\n\n                        // Prepare insertion of new element\n                        final int actualInsertionIndex;\n                        if (positionAttribute == null || \"after\".equals(positionAttribute)) { // \"after\" is the default\n                            actualInsertionIndex = actualIndex + 1;\n                        } else if (\"before\".equals(positionAttribute)) {\n                            actualInsertionIndex = actualIndex;\n                        } else {\n                            throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after' if present.\");\n                        }\n\n                        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target\n                        // location depending on their node type.\"\n\n                        boolean hasTextNode = false;\n                        int addIndex = 0;\n                        insertedNodes = new ArrayList(clonedNodes.size());\n                        for (int i = 0; i < clonedNodes.size(); i++) {\n                            final Node clonedNode = (Node) clonedNodes.get(i);\n\n                            if (!(clonedNode instanceof Attribute || clonedNode instanceof Namespace)) {\n                                // Element, text, comment, processing instruction node\n                                siblingElements.add(actualInsertionIndex + addIndex, clonedNode);\n                                insertedNodes.add(clonedNode);\n                                hasTextNode |= clonedNode.getNodeType() == Node.TEXT_NODE;\n                                addIndex++;\n                            } else {\n                                // We never insert attributes or namespace nodes as siblings\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    containingDocument.logDebug(\"xforms:insert\", \"skipping insertion of node as sibling in element content\",\n                                            new String[] {\n                                                    \"type\", clonedNode.getNodeTypeName(),\n                                                    \"node\", clonedNode instanceof Attribute ? Dom4jUtils.attributeToString((Attribute) clonedNode) : clonedNode.toString()\n                                            } );\n                            }\n                        }\n\n                        // Normalize text nodes if needed to respect XPath 1.0 constraint\n                        if (hasTextNode)\n                            Dom4jUtils.normalizeTextNodes(parentNode);\n                    }\n                }\n//                }\n        }\n\n        // Whether some nodes were inserted\n        final boolean didInsertNodes = insertedNodes != null && insertedNodes.size() > 0;\n\n        // Log stuff\n        if (XFormsServer.logger.isDebugEnabled()) {\n            if (didInsertNodes)\n                containingDocument.logDebug(\"xforms:insert\", \"inserted nodes\",\n                        new String[] { \"count\", Integer.toString(insertedNodes.size()), \"instance\", modifiedInstance.getEffectiveId() });\n            else\n                containingDocument.logDebug(\"xforms:insert\", \"no node inserted\");\n        }\n\n        // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n        if (didInsertNodes) {\n            modifiedInstance.getModel(containingDocument).setAllDeferredFlags(true);\n            containingDocument.getControls().markDirtySinceLastRequest(true);\n        }\n\n        // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n        // XFormsInstance handles index and repeat items updates \n        {\n            final List insertedNodeInfos;\n            if (didInsertNodes) {\n                final DocumentWrapper documentWrapper = (DocumentWrapper) modifiedInstance.getDocumentInfo();\n                insertedNodeInfos = new ArrayList(insertedNodes.size());\n                for (Iterator i = insertedNodes.iterator(); i.hasNext();)\n                    insertedNodeInfos.add(documentWrapper.wrap(i.next()));\n            } else {\n                insertedNodeInfos = Collections.EMPTY_LIST;\n            }\n\n            modifiedInstance.getContainer(containingDocument).dispatchEvent(pipelineContext,\n                    new XFormsInsertEvent(modifiedInstance, insertedNodeInfos, originItems, insertLocationNodeInfo,\n                            positionAttribute == null ? \"after\" : positionAttribute, sourceNodes, clonedNodes, isAdjustIndexes));\n        }\n    }","id":86202,"modified_method":"public static void doInsert(PipelineContext pipelineContext, XFormsContainingDocument containingDocument, String positionAttribute,\n                                List collectionToBeUpdated, NodeInfo insertContextNodeInfo, List originItems, int insertionIndex) {\n\n        final boolean isEmptyNodesetBinding = collectionToBeUpdated == null || collectionToBeUpdated.size() == 0;\n\n        // \"3. The origin node-set is determined.\"\n        // \"5. Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n        final List sourceNodes;\n        final List clonedNodes;\n        {\n            final List clonedNodesTemp;\n            if (originItems == null) {\n                // There are no explicitly specified origin objects, use node from Node Set Binding node-set\n\n                // \"If the origin attribute is not given and the Node Set Binding node-set is empty, then the origin\n                // node-set is the empty node-set. [...] The insert action is terminated with no effect if the\n                // origin node-set is the empty node-set.\"\n\n                if (isEmptyNodesetBinding) {\n                    if (XFormsServer.logger.isDebugEnabled())\n                        containingDocument.logDebug(\"xforms:insert\", \"origin node-set from node-set binding is empty, terminating\");\n                    return;\n                }\n\n                // \"Otherwise, if the origin attribute is not given, then the origin node-set consists of the last\n                // node of the Node Set Binding node-set.\"\n                final Node singleSourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) collectionToBeUpdated.get(collectionToBeUpdated.size() - 1), CANNOT_INSERT_READONLY_MESSAGE);\n                final Node singleClonedNode = Dom4jUtils.createCopy(singleSourceNode);\n\n                sourceNodes = Collections.singletonList(singleSourceNode);\n                clonedNodesTemp = Collections.singletonList(singleClonedNode);\n\n                originItems = null;\n            } else {\n                // There are explicitly specified origin objects\n\n                // \"The insert action is terminated with no effect if the origin node-set is the empty node-set.\"\n                if (originItems.size() == 0) {\n                    if (XFormsServer.logger.isDebugEnabled())\n                        containingDocument.logDebug(\"xforms:insert\", \"origin node-set is empty, terminating\");\n                    return;\n                }\n\n                // \"Each node in the origin node-set is cloned in the order it appears in the origin node-set.\"\n\n                sourceNodes = new ArrayList(originItems.size()); // set to max possible size\n                clonedNodesTemp = new ArrayList(originItems.size());\n\n                for (Iterator i = originItems.iterator(); i.hasNext();) {\n                    final Object currentObject = i.next();\n\n                    if (currentObject instanceof NodeInfo) {\n                        // This is the regular case covered by XForms 1.1 / XPath 1.0\n\n                        final Node sourceNode = XFormsUtils.getNodeFromNodeInfoConvert((NodeInfo) currentObject, CANNOT_INSERT_READONLY_MESSAGE);\n                        final Node clonedNode = (sourceNode instanceof Element) ? ((Node) ((Element) sourceNode).createCopy()) : (Node) sourceNode.clone();\n\n                        sourceNodes.add(sourceNode);\n                        clonedNodesTemp.add(clonedNode);\n\n                    } else {\n                        // This is an extension: support sequences containing other items\n\n                        // Convert the result to a text node\n//                            final String stringValue = ((Item) currentObject).getStringValue();\n                        final String stringValue = currentObject.toString(); // we get String, Long, etc.\n                        final Text textNode = Dom4jUtils.createText(stringValue);\n\n                        sourceNodes.add(null); // there is no source node for this cloned node, it's a source item\n                        clonedNodesTemp.add(textNode);\n                    }\n                }\n            }\n\n            for (int i = 0; i < clonedNodesTemp.size(); i++) {\n                final Node clonedNodeTemp = (Node) clonedNodesTemp.get(i);\n\n                if (clonedNodeTemp instanceof Element)\n                    InstanceData.remove(clonedNodeTemp);\n                else if (clonedNodeTemp instanceof Attribute)\n                    InstanceData.remove(clonedNodeTemp);\n                else if (clonedNodeTemp instanceof Document) {\n                    final Element clonedNodeTempRootElement = clonedNodeTemp.getDocument().getRootElement();\n                    InstanceData.remove(clonedNodeTempRootElement);\n                    // We can never really insert a document into anything, but we assume that this means the root element\n                    clonedNodesTemp.set(i, clonedNodeTempRootElement.detach());\n                }\n            }\n            clonedNodes = clonedNodesTemp;\n        }\n\n        // \"6. The target location of each cloned node or nodes is determined\"\n        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target location\n        // depending on their node type.\"\n\n        // This attribute is a temporary HACK, used to improve performance when going offline\n        final boolean isAdjustIndexes = isAdjustIndexes(containingDocument);\n\n        // Identify the instance that actually changes\n        final XFormsInstance modifiedInstance;\n        // Find actual insertion point and insert\n        final NodeInfo insertLocationNodeInfo;\n        final List insertedNodes;\n        if (isEmptyNodesetBinding) {\n\n            // \"If the Node Set Binding node-set is not specified or empty, the insert location node is the insert\n            // context node.\"\n\n            // \"a. If the Node Set Binding node-set is not specified or empty, the target location depends on the\n            // node type of the cloned node. If the cloned node is an attribute, then the target location is before\n            // the first attribute of the insert location node. If the cloned node is not an attribute, then the\n            // target location is before the first child of the insert location node.\"\n\n            modifiedInstance = containingDocument.getInstanceForNode(insertContextNodeInfo);\n            insertLocationNodeInfo = insertContextNodeInfo;\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertContextNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            insertedNodes = doInsert(insertLocationNode, clonedNodes);\n\n            // Normalize text nodes if needed to respect XPath 1.0 constraint\n            {\n                boolean hasTextNode = false;\n                for (int i = 0; i < clonedNodes.size(); i++) {\n                    final Node clonedNode = (Node) clonedNodes.get(i);\n                    hasTextNode |= clonedNode.getNodeType() == Node.TEXT_NODE;\n                }\n                if (hasTextNode)\n                    Dom4jUtils.normalizeTextNodes(insertLocationNode);\n            }\n        } else {\n            // One or more nodes were inserted\n\n            // HACK used to improve performance when going offline: when !isAdjustIndexes, always insert at the end of the node-set\n            insertLocationNodeInfo = (NodeInfo) collectionToBeUpdated.get(isAdjustIndexes ? insertionIndex - 1 : collectionToBeUpdated.size() - 1);\n            final Node insertLocationNode = XFormsUtils.getNodeFromNodeInfo(insertLocationNodeInfo, CANNOT_INSERT_READONLY_MESSAGE);\n            modifiedInstance = containingDocument.getInstanceForNode(insertLocationNodeInfo);\n\n//                if (insertLocationNode.getNodeType() != clonedNode.getNodeType()) {\n//                    // \"2. If the node type of the cloned node does not match the node type of the insert location\n//                    // node, then the target location is before the first child or attribute of the insert location\n//                    // node, based on the node type of the cloned node.\"\n//\n//                    doInsert(insertLocationNode, clonedNode);\n//                } else {\n\n                if (insertLocationNode.getDocument().getRootElement() == insertLocationNode) {\n\n                    // \"c. if insert location node is the root element of an instance, then that instance root element\n                    // location is the target location. If there is more than one cloned node to insert, only the\n                    // first node that does not cause a conflict is considered.\"\n\n                    insertedNodes = doInsert(insertLocationNode.getDocument(), clonedNodes);\n\n                    // NOTE: Don't need to normalize text nodes in this case, as no new text node is inserted\n                } else {\n                    // \"d. Otherwise, the target location is immediately before or after the insert location\n                    // node, based on the position attribute setting or its default.\"\n\n                    if (insertLocationNode.getNodeType() == Node.ATTRIBUTE_NODE) {\n                        // Special case for attributes\n\n                        // NOTE: In XML, attributes are unordered. dom4j handles them as a list so has order, but\n                        // the XForms spec shouldn't rely on attribute order. We could try to keep the order, but it\n                        // is harder as we have to deal with removing duplicate attributes and find a reasonable\n                        // insertion strategy.\n\n                        // TODO: Don't think we should even do this now in XForms 1.1\n                        insertedNodes = doInsert(insertLocationNode.getParent(), clonedNodes);\n\n                    } else {\n                        // Other node types\n                        final Element parentNode = insertLocationNode.getParent();\n                        final List siblingElements = parentNode.content();\n                        final int actualIndex = siblingElements.indexOf(insertLocationNode);\n\n                        // Prepare insertion of new element\n                        final int actualInsertionIndex;\n                        if (positionAttribute == null || \"after\".equals(positionAttribute)) { // \"after\" is the default\n                            actualInsertionIndex = actualIndex + 1;\n                        } else if (\"before\".equals(positionAttribute)) {\n                            actualInsertionIndex = actualIndex;\n                        } else {\n                            throw new OXFException(\"Invalid 'position' attribute: \" + positionAttribute + \". Must be either 'before' or 'after' if present.\");\n                        }\n\n                        // \"7. The cloned node or nodes are inserted in the order they were cloned at their target\n                        // location depending on their node type.\"\n\n                        boolean hasTextNode = false;\n                        int addIndex = 0;\n                        insertedNodes = new ArrayList(clonedNodes.size());\n                        for (int i = 0; i < clonedNodes.size(); i++) {\n                            final Node clonedNode = (Node) clonedNodes.get(i);\n\n                            if (!(clonedNode instanceof Attribute || clonedNode instanceof Namespace)) {\n                                // Element, text, comment, processing instruction node\n                                siblingElements.add(actualInsertionIndex + addIndex, clonedNode);\n                                insertedNodes.add(clonedNode);\n                                hasTextNode |= clonedNode.getNodeType() == Node.TEXT_NODE;\n                                addIndex++;\n                            } else {\n                                // We never insert attributes or namespace nodes as siblings\n                                if (XFormsServer.logger.isDebugEnabled())\n                                    containingDocument.logDebug(\"xforms:insert\", \"skipping insertion of node as sibling in element content\",\n                                            new String[] {\n                                                    \"type\", clonedNode.getNodeTypeName(),\n                                                    \"node\", clonedNode instanceof Attribute ? Dom4jUtils.attributeToString((Attribute) clonedNode) : clonedNode.toString()\n                                            } );\n                            }\n                        }\n\n                        // Normalize text nodes if needed to respect XPath 1.0 constraint\n                        if (hasTextNode)\n                            Dom4jUtils.normalizeTextNodes(parentNode);\n                    }\n                }\n//                }\n        }\n\n        // Whether some nodes were inserted\n        final boolean didInsertNodes = insertedNodes != null && insertedNodes.size() > 0;\n\n        // Log stuff\n        if (XFormsServer.logger.isDebugEnabled()) {\n            if (didInsertNodes)\n                containingDocument.logDebug(\"xforms:insert\", \"inserted nodes\",\n                        new String[] { \"count\", Integer.toString(insertedNodes.size()), \"instance\",\n                                (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : null });\n            else\n                containingDocument.logDebug(\"xforms:insert\", \"no node inserted\");\n        }\n\n        // \"XForms Actions that change the tree structure of instance data result in setting all four flags to true\"\n        if (didInsertNodes && modifiedInstance  != null) {\n            // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n            modifiedInstance.getModel(containingDocument).setAllDeferredFlags(true);\n            containingDocument.getControls().markDirtySinceLastRequest(true);\n        }\n\n        // \"4. If the insert is successful, the event xforms-insert is dispatched.\"\n        // XFormsInstance handles index and repeat items updates \n        if (modifiedInstance  != null) {\n            // NOTE: Can be null if document into which delete is performed is not in an instance, e.g. in a variable\n            final List insertedNodeInfos;\n            if (didInsertNodes) {\n                final DocumentWrapper documentWrapper = (DocumentWrapper) modifiedInstance.getDocumentInfo();\n//                if (modifiedInstance != null) {\n                    // If we have an instance, we also have a wrapper\n//                    documentWrapper = (DocumentWrapper) modifiedInstance.getDocumentInfo();\n//                } else {\n//                    // Otherwise, hard to get to the wrapper, so create a new one\n//                    final Document insertDocument = ((Node) insertedNodes.get(0)).getDocument();\n//                    documentWrapper = new DocumentWrapper(insertDocument, null, new Configuration());\n//                }\n\n                insertedNodeInfos = new ArrayList(insertedNodes.size());\n                for (Iterator i = insertedNodes.iterator(); i.hasNext();)\n                    insertedNodeInfos.add(documentWrapper.wrap(i.next()));\n            } else {\n                insertedNodeInfos = Collections.EMPTY_LIST;\n            }\n\n            modifiedInstance.getContainer(containingDocument).dispatchEvent(pipelineContext,\n                    new XFormsInsertEvent(modifiedInstance, insertedNodeInfos, originItems, insertLocationNodeInfo,\n                            positionAttribute == null ? \"after\" : positionAttribute, sourceNodes, clonedNodes, isAdjustIndexes));\n        }\n    }","commit_id":"296fffa807799d19e83f44f91e8f1ba19f9f5ccd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void performDefaultAction(final PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n        if (XFormsEvents.XFORMS_MODEL_CONSTRUCT.equals(eventName)) {\n            // 4.2.1 The xforms-model-construct Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            final Element modelElement = modelDocument.getRootElement();\n\n            // 1. All XML Schemas loaded (throws xforms-link-exception)\n\n            loadSchemasIfNeeded(pipelineContext);\n            // TODO: throw exception event\n\n            // 2. Create XPath data model from instance (inline or external) (throws xforms-link-exception)\n            //    Instance may not be specified.\n\n//            if (instances == null) {\n            if (instances == null) {\n                instances = Arrays.asList(new XFormsInstance[instanceIds.size()]);\n                instancesMap = new HashMap(instanceIds.size());\n            }\n            {\n                // Build initial instance documents\n                final List instanceContainers = modelElement.elements(new QName(\"instance\", XFormsConstants.XFORMS_NAMESPACE));\n                final XFormsStaticState staticState = containingDocument.getStaticState();\n                final Map staticStateInstancesMap = (staticState != null && staticState.isInitialized()) ? staticState.getSharedInstancesMap() : null;\n                if (instanceContainers.size() > 0) {\n                    // Iterate through all instances\n                    int instancePosition = 0;\n                    for (Iterator i = instanceContainers.iterator(); i.hasNext(); instancePosition++) {\n\n                        final Element instanceContainerElement = (Element) i.next();\n                        final LocationData locationData = (LocationData) instanceContainerElement.getData();\n                        final String instanceId = XFormsInstance.getInstanceId(instanceContainerElement);\n\n                        // Handle read-only hints\n                        final boolean isReadonlyHint = XFormsInstance.isReadonlyHint(instanceContainerElement);\n                        final boolean isApplicationSharedHint = XFormsInstance.isApplicationSharedHint(instanceContainerElement);\n                        final long xxformsTimeToLive = XFormsInstance.getTimeToLive(instanceContainerElement);\n\n                        // Skip processing in case somebody has already set this particular instance\n                        if (instances.get(instancePosition) != null)\n                            continue;\n\n                        // Get instance from static state if possible\n                        if (staticStateInstancesMap != null) {\n                            final XFormsInstance staticStateInstance = (XFormsInstance) staticStateInstancesMap.get(instanceId);\n                            if (staticStateInstance != null) {\n                                // The instance is already available in the static state\n\n                                if (staticStateInstance.getDocumentInfo() == null) {\n                                    // Instance is not initialized yet\n\n                                    // This means that the instance was application shared\n                                    if (!staticStateInstance.isApplicationShared())\n                                        throw new ValidationException(\"Non-initialized instance has to be application shared for id: \" + staticStateInstance.getEffectiveId(),\n                                                (LocationData) instanceContainerElement.getData());\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        containingDocument.logDebug(\"model\", \"using instance from application shared instance cache (instance from static state was not initialized)\",\n                                                new String[] { \"id\", staticStateInstance.getEffectiveId() });\n\n                                    final SharedXFormsInstance sharedInstance\n                                            = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, staticStateInstance.getEffectiveId(), staticStateInstance.getEffectiveModelId(), staticStateInstance.getSourceURI(), staticStateInstance.getTimeToLive(), staticStateInstance.getValidation());\n                                    setInstance(sharedInstance, false);\n\n                                } else {\n                                    // Instance is initialized, just use it\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        containingDocument.logDebug(\"model\", \"using initialized instance from static state\",\n                                                new String[] { \"id\", staticStateInstance.getEffectiveId() });\n\n                                    setInstance(staticStateInstance, false);\n                                }\n\n                                continue;\n                            }\n                        }\n\n                        // Did not get the instance from static state\n                        final Object instanceDocument;// Document or DocumentInfo\n                        final String instanceSourceURI;\n                        final String xxformsUsername;\n                        final String xxformsPassword;\n                        final String xxformsValidation = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_VALIDATION_QNAME);\n\n                        containingDocument.startHandleOperation(\"model\", \"loading instance (including handling returned body)\");\n                        // TODO: log \"instance\", instanceId\n                        {\n                            final String instanceResource;\n                            {\n                                final String srcAttribute = instanceContainerElement.attributeValue(\"src\");\n                                final String resourceAttribute = instanceContainerElement.attributeValue(\"resource\");\n                                if (srcAttribute != null)\n                                    instanceResource = XFormsUtils.encodeHRRI(srcAttribute, true);\n                                else if (resourceAttribute != null)\n                                    instanceResource = XFormsUtils.encodeHRRI(resourceAttribute, true);\n                                else\n                                    instanceResource = null;\n                            }\n                            if (instanceResource == null) {\n                                // Inline instance\n                                final String xxformsExcludeResultPrefixes = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_EXCLUDE_RESULT_PREFIXES);\n                                final List children = instanceContainerElement.elements();\n                                if (children == null || children.size() != 1) {\n                                    // TODO: dispatch xforms-link-exception\n                                    final Throwable throwable = new ValidationException(\"xforms:instance element must contain exactly one child element\",\n                                            new ExtendedLocationData(locationData, \"processing inline XForms instance\", instanceContainerElement));\n                                    container.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, null, instanceContainerElement, throwable));\n                                    break;\n                                }\n                                {\n                                    final Document tempDocument;\n                                    // TODO: Implement as per XSLT 2.0. For now, we just support #all.\n                                    // TODO: Must implement namespace fixup, the code below can break serialization\n                                    if (\"#all\".equals(xxformsExcludeResultPrefixes)) {\n                                        tempDocument = Dom4jUtils.createDocumentCopyElement((Element) children.get(0));\n                                    } else if (xxformsExcludeResultPrefixes != null) {\n                                        final StringTokenizer st = new StringTokenizer(xxformsExcludeResultPrefixes);\n                                        final Map prefixesToExclude = new HashMap();\n                                        while (st.hasMoreTokens()) {\n                                            prefixesToExclude.put(st.nextToken(), \"\");\n                                        }\n                                        tempDocument = Dom4jUtils.createDocumentCopyParentNamespaces((Element) children.get(0), prefixesToExclude);\n                                    } else {\n                                        tempDocument = Dom4jUtils.createDocumentCopyParentNamespaces((Element) children.get(0));\n                                    }\n\n                                    if (!isReadonlyHint) {\n                                        instanceDocument = tempDocument;\n                                    } else {\n                                        instanceDocument = TransformerUtils.dom4jToTinyTree(tempDocument);\n                                    }\n                                }\n                                instanceSourceURI = null;\n                                xxformsUsername = null;\n                                xxformsPassword = null;\n                            } else if (!instanceResource.trim().equals(\"\")) {\n\n                                // External instance\n                                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                                // NOTE: Optimizing with include() for servlets doesn't allow detecting errors caused by\n                                // the included resource, so we don't allow this for now. Furthermore, we are forced to\n                                // \"optimize\" for portlet access.\n\n    //                            final boolean optimize = !NetUtils.urlHasProtocol(srcAttribute)\n    //                               && (externalContext.getRequest().getContainerType().equals(\"portlet\")\n    //                                    || (externalContext.getRequest().getContainerType().equals(\"servlet\")\n    //                                        && XFormsUtils.isOptimizeLocalInstanceLoads()));\n\n                                final boolean optimizeForPortlets = !NetUtils.urlHasProtocol(instanceResource)\n                                                            && externalContext.getRequest().getContainerType().equals(\"portlet\");\n\n                                final ConnectionResult connectionResult;\n                                if (optimizeForPortlets) {\n                                    // Use optimized local mode\n\n                                    final URI resolvedURI = XFormsUtils.resolveXMLBase(instanceContainerElement, instanceResource);\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        containingDocument.logDebug(\"model\", \"getting document from optimized URI\",\n                                                    new String[] { \"URI\", resolvedURI.toString() });\n\n                                    connectionResult = XFormsSubmissionUtils.openOptimizedConnection(pipelineContext, externalContext,\n                                            null, null, \"get\", resolvedURI.toString(), null, false, null, null);\n\n                                    instanceSourceURI = resolvedURI.toString();\n                                    xxformsUsername = null;\n                                    xxformsPassword = null;\n\n                                    try {\n                                        try {\n                                            // Handle connection errors\n                                            if (connectionResult.statusCode != 200) {\n                                                throw new OXFException(\"Got invalid return code while loading instance: \" + instanceResource + \", \" + connectionResult.statusCode);\n                                            }\n\n                                            // TODO: Handle validating and handleXInclude!\n\n                                            // Read result as XML\n                                            if (!isReadonlyHint) {\n                                                instanceDocument = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                            } else {\n                                                instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                            }\n                                        } catch (Exception e) {\n                                            final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"reading external XForms instance (optimized)\", instanceContainerElement);\n                                            dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, instanceResource, e, instanceContainerElement, extendedLocationData);\n                                            break;\n                                        }\n                                    } finally {\n                                        // Clean-up\n                                        if (connectionResult != null)\n                                            connectionResult.close();\n                                    }\n\n                                } else {\n                                    // Connect using external protocol\n\n                                    // Extension: username and password\n                                    // NOTE: Those don't use AVTs for now, because XPath expressions in those could access\n                                    // instances that haven't been loaded yet.\n                                    xxformsUsername = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_USERNAME_QNAME);\n                                    xxformsPassword = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_PASSWORD_QNAME);\n\n                                    final URL absoluteResolvedURL;\n                                    final String absoluteResolvedURLString;\n                                    {\n                                        final String resolvedURL = XFormsUtils.resolveResourceURL(pipelineContext, instanceContainerElement, instanceResource,\n                                                ExternalContext.Response.REWRITE_MODE_ABSOLUTE_PATH_OR_RELATIVE);\n                                        final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(resolvedURL);\n                                        if (inputName != null) {\n                                            // URL is input:*, keep it as is\n                                            absoluteResolvedURL = null;\n                                            absoluteResolvedURLString = resolvedURL;\n                                        } else {\n                                            // URL is regular URL, make sure it is absolute\n                                            absoluteResolvedURL = NetUtils.createAbsoluteURL(resolvedURL, null, externalContext);\n                                            absoluteResolvedURLString = absoluteResolvedURL.toExternalForm();\n                                        }\n                                    }\n\n                                    // Get instance from shared cache if possible\n                                    if (isApplicationSharedHint) {\n                                        final SharedXFormsInstance sharedXFormsInstance = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, instanceId, modelEffectiveId, absoluteResolvedURLString, xxformsTimeToLive, xxformsValidation);\n                                        setInstance(sharedXFormsInstance, false);\n                                        continue;\n                                    }\n\n                                    if (containingDocument.getURIResolver() == null || isApplicationSharedHint) {\n                                        // Connect directly if there is no resolver or if the instance is globally shared\n\n                                        if (XFormsServer.logger.isDebugEnabled())\n                                            containingDocument.logDebug(\"model\", \"getting document from URI\",\n                                                    new String[] { \"URI\", absoluteResolvedURLString });\n\n                                        connectionResult = NetUtils.openConnection(externalContext, containingDocument.getIndentedLogger(),\n                                                \"GET\", absoluteResolvedURL, xxformsUsername, xxformsPassword, null, null, null,\n                                                XFormsProperties.getForwardSubmissionHeaders(containingDocument));\n\n                                        try {\n                                            try {\n                                                // Handle connection errors\n                                                if (connectionResult.statusCode != 200) {\n                                                    throw new OXFException(\"Got invalid return code while loading instance: \" + instanceResource + \", \" + connectionResult.statusCode);\n                                                }\n\n                                                // TODO: Handle validating and XInclude!\n\n                                                // Read result as XML\n                                                if (!isReadonlyHint) {\n                                                    instanceDocument = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                                } else {\n                                                    instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                                }\n                                            } catch (Exception e) {\n                                                final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"reading external instance (no resolver)\", instanceContainerElement);\n                                                dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, instanceResource, e, instanceContainerElement, extendedLocationData);\n                                                break;\n                                            }\n                                        } finally {\n                                            // Clean-up\n                                            if (connectionResult != null)\n                                                connectionResult.close();\n                                        }\n\n                                    } else {\n                                        // Optimized case that uses the provided resolver\n                                        if (XFormsServer.logger.isDebugEnabled())\n                                            containingDocument.logDebug(\"model\", \"getting document from resolver\",\n                                                    new String[] { \"URI\", absoluteResolvedURLString });\n\n                                        try {\n                                            // TODO: Handle validating and handleXInclude!\n\n                                            if (!isReadonlyHint) {\n                                                instanceDocument = containingDocument.getURIResolver().readURLAsDocument(absoluteResolvedURLString, xxformsUsername, xxformsPassword,\n                                                        XFormsProperties.getForwardSubmissionHeaders(containingDocument));\n                                            } else {\n                                                instanceDocument = containingDocument.getURIResolver().readURLAsDocumentInfo(absoluteResolvedURLString, xxformsUsername, xxformsPassword,\n                                                        XFormsProperties.getForwardSubmissionHeaders(containingDocument));\n                                            }\n                                        } catch (Exception e) {\n                                            final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"reading external instance (resolver)\", instanceContainerElement);\n                                            dispatchXFormsLinkExceptionEvent(pipelineContext, new ConnectionResult(absoluteResolvedURLString), instanceResource, e, instanceContainerElement, extendedLocationData);\n                                            break;\n                                        }\n                                    }\n\n                                    instanceSourceURI = absoluteResolvedURLString;\n                                }\n                            } else {\n                                // Got a blank src attribute, just dispatch xforms-link-exception\n                                final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"processing XForms instance\", instanceContainerElement);\n                                final Throwable throwable = new ValidationException(\"Invalid blank URL specified for instance: \" + instanceId, extendedLocationData);\n                                container.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, instanceResource, instanceContainerElement, throwable));\n                                break;\n                            }\n                        }\n                        containingDocument.endHandleOperation();\n\n                        // Set instance and associated information if everything went well\n                        setInstanceDocument(instanceDocument, modelEffectiveId, instanceId, instanceSourceURI, xxformsUsername, xxformsPassword, isApplicationSharedHint, xxformsTimeToLive, xxformsValidation);\n                    }\n                }\n            }\n\n            // 3. P3P (N/A)\n\n            // 4. Instance data is constructed. Evaluate binds:\n            //    a. Evaluate nodeset\n            //    b. Apply model item properties on nodes\n            //    c. Throws xforms-binding-exception if the node has already model item property with same name\n            // TODO: a, b, c\n\n            // 5. xforms-rebuild, xforms-recalculate, xforms-revalidate\n            doRebuild(pipelineContext);\n            doRecalculate(pipelineContext);\n            doRevalidate(pipelineContext);\n\n            synchronizeInstanceDataEventState();\n\n        } else if (XFormsEvents.XXFORMS_READY.equals(eventName)) {\n\n            // This is called after xforms-ready events have been dispatched to all models\n\n            final XFormsStaticState staticState = containingDocument.getStaticState();\n\n            if (staticState != null && !staticState.isInitialized()) {\n                // The static state is open to adding instances\n                if (getInstances() != null) {\n                    for (Iterator instanceIterator = getInstances().iterator(); instanceIterator.hasNext();) {\n                        final XFormsInstance currentInstance = (XFormsInstance) instanceIterator.next();\n\n                        if (currentInstance instanceof SharedXFormsInstance) {\n\n                            // NOTE: We add all shared instances, even the globally shared ones, and the static state\n                            // decides of the amount of information to actually store\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"model\", \"adding read-only instance to static state\",\n                                    new String[] { \"instance\", currentInstance.getEffectiveId() });\n                            staticState.addSharedInstance((SharedXFormsInstance) currentInstance);\n                        }\n                        // TODO: something like staticState.hasReset(modelId);\n                        // TODO: maybe we won't do this here, but by restoring the initial dynamic state instead\n//                        final boolean modelHasReset = false;\n//                        else if (modelHasReset) {\n//                            if (XFormsServer.logger.isDebugEnabled())\n//                                containingDocument.logDebug(\"model\", \"adding reset instance to static state\",\n//                                    new String[] { \"instance\", currentInstance.getEffectiveId() });\n//                            staticState.addSharedInstance(currentInstance.createSharedInstance());\n//                        }\n                    }\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE.equals(eventName)) {\n            // 4.2.2 The xforms-model-construct-done Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            // TODO: implicit lazy instance construction\n\n        } else if (XFormsEvents.XFORMS_REBUILD.equals(eventName)) {\n            // 4.3.7 The xforms-rebuild Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRebuild(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RECALCULATE.equals(eventName)) {\n            // 4.3.6 The xforms-recalculate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRecalculate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REVALIDATE.equals(eventName)) {\n            // 4.3.5 The xforms-revalidate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRevalidate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REFRESH.equals(eventName)) {\n            // 4.3.4 The xforms-refresh Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRefresh(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RESET.equals(eventName)) {\n            // 4.3.8 The xforms-reset Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            // TODO\n            // \"The instance data is reset to the tree structure and values it had immediately\n            // after having processed the xforms-ready event.\"\n\n            // \"Then, the events xforms-rebuild, xforms-recalculate, xforms-revalidate and\n            // xforms-refresh are dispatched to the model element in sequence.\"\n            container.dispatchEvent(pipelineContext, new XFormsRebuildEvent(XFormsModel.this));\n            container.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(XFormsModel.this));\n            container.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(XFormsModel.this));\n            container.dispatchEvent(pipelineContext, new XFormsRefreshEvent(XFormsModel.this));\n\n        } else if (XFormsEvents.XFORMS_COMPUTE_EXCEPTION.equals(eventName) || XFormsEvents.XFORMS_LINK_EXCEPTION.equals(eventName)) {\n            // 4.5.4 The xforms-compute-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: Implementation-specific error string.\n            // The default action for this event results in the following: Fatal error.\n\n            // 4.5.2 The xforms-link-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: The URI that failed to load (xsd:anyURI)\n            // The default action for this event results in the following: Fatal error.\n\n            final XFormsExceptionEvent exceptionEvent = (XFormsExceptionEvent) event;\n            final Throwable throwable = exceptionEvent.getThrowable();\n            if (throwable instanceof RuntimeException)\n                throw (RuntimeException) throwable;\n            else\n                throw new ValidationException(\"Received fatal error event: \" + eventName, throwable, (LocationData) modelDocument.getRootElement().getData());\n        }\n    }","id":86203,"modified_method":"public void performDefaultAction(final PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n        if (XFormsEvents.XFORMS_MODEL_CONSTRUCT.equals(eventName)) {\n            // 4.2.1 The xforms-model-construct Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            final Element modelElement = modelDocument.getRootElement();\n\n            // 1. All XML Schemas loaded (throws xforms-link-exception)\n\n            loadSchemasIfNeeded(pipelineContext);\n            // TODO: throw exception event\n\n            // 2. Create XPath data model from instance (inline or external) (throws xforms-link-exception)\n            //    Instance may not be specified.\n\n//            if (instances == null) {\n            if (instances == null) {\n                instances = Arrays.asList(new XFormsInstance[instanceIds.size()]);\n                instancesMap = new HashMap(instanceIds.size());\n            }\n            {\n                // Build initial instance documents\n                final List instanceContainers = modelElement.elements(new QName(\"instance\", XFormsConstants.XFORMS_NAMESPACE));\n                final XFormsStaticState staticState = containingDocument.getStaticState();\n                final Map staticStateInstancesMap = (staticState != null && staticState.isInitialized()) ? staticState.getSharedInstancesMap() : null;\n                if (instanceContainers.size() > 0) {\n                    // Iterate through all instances\n                    int instancePosition = 0;\n                    for (Iterator i = instanceContainers.iterator(); i.hasNext(); instancePosition++) {\n\n                        final Element instanceContainerElement = (Element) i.next();\n                        final LocationData locationData = (LocationData) instanceContainerElement.getData();\n                        final String instanceId = XFormsInstance.getInstanceId(instanceContainerElement);\n\n                        // Handle read-only hints\n                        final boolean isReadonlyHint = XFormsInstance.isReadonlyHint(instanceContainerElement);\n                        final boolean isApplicationSharedHint = XFormsInstance.isApplicationSharedHint(instanceContainerElement);\n                        final long xxformsTimeToLive = XFormsInstance.getTimeToLive(instanceContainerElement);\n\n                        // Skip processing in case somebody has already set this particular instance\n                        if (instances.get(instancePosition) != null)\n                            continue;\n\n                        // Get instance from static state if possible\n                        if (staticStateInstancesMap != null) {\n                            final XFormsInstance staticStateInstance = (XFormsInstance) staticStateInstancesMap.get(instanceId);\n                            if (staticStateInstance != null) {\n                                // The instance is already available in the static state\n\n                                if (staticStateInstance.getDocumentInfo() == null) {\n                                    // Instance is not initialized yet\n\n                                    // This means that the instance was application shared\n                                    if (!staticStateInstance.isApplicationShared())\n                                        throw new ValidationException(\"Non-initialized instance has to be application shared for id: \" + staticStateInstance.getEffectiveId(),\n                                                (LocationData) instanceContainerElement.getData());\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        containingDocument.logDebug(\"model\", \"using instance from application shared instance cache (instance from static state was not initialized)\",\n                                                new String[] { \"id\", staticStateInstance.getEffectiveId() });\n\n                                    final SharedXFormsInstance sharedInstance\n                                            = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, staticStateInstance.getEffectiveId(), staticStateInstance.getEffectiveModelId(), staticStateInstance.getSourceURI(), staticStateInstance.getTimeToLive(), staticStateInstance.getValidation());\n                                    setInstance(sharedInstance, false);\n\n                                } else {\n                                    // Instance is initialized, just use it\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        containingDocument.logDebug(\"model\", \"using initialized instance from static state\",\n                                                new String[] { \"id\", staticStateInstance.getEffectiveId() });\n\n                                    setInstance(staticStateInstance, false);\n                                }\n\n                                continue;\n                            }\n                        }\n\n                        // Did not get the instance from static state\n                        final Object instanceDocument;// Document or DocumentInfo\n                        final String instanceSourceURI;\n                        final String xxformsUsername;\n                        final String xxformsPassword;\n                        final String xxformsValidation = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_VALIDATION_QNAME);\n\n                        containingDocument.startHandleOperation(\"model\", \"loading instance (including handling returned body)\");\n                        // TODO: log \"instance\", instanceId\n                        {\n                            final String instanceResource;\n                            {\n                                final String srcAttribute = instanceContainerElement.attributeValue(\"src\");\n                                final String resourceAttribute = instanceContainerElement.attributeValue(\"resource\");\n                                if (srcAttribute != null)\n                                    instanceResource = XFormsUtils.encodeHRRI(srcAttribute, true);\n                                else if (resourceAttribute != null)\n                                    instanceResource = XFormsUtils.encodeHRRI(resourceAttribute, true);\n                                else\n                                    instanceResource = null;\n                            }\n                            if (instanceResource == null) {\n                                // Inline instance\n                                final String xxformsExcludeResultPrefixes = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_EXCLUDE_RESULT_PREFIXES);\n                                final List children = instanceContainerElement.elements();\n                                if (children == null || children.size() != 1) {\n                                    // TODO: dispatch xforms-link-exception\n                                    final Throwable throwable = new ValidationException(\"xforms:instance element must contain exactly one child element\",\n                                            new ExtendedLocationData(locationData, \"processing inline XForms instance\", instanceContainerElement));\n                                    container.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, null, instanceContainerElement, throwable));\n                                    break;\n                                }\n                                // Extract document\n                                instanceDocument = XXFormsExtractDocument.extractDocument((Element) children.get(0), xxformsExcludeResultPrefixes, isReadonlyHint);\n\n                                instanceSourceURI = null;\n                                xxformsUsername = null;\n                                xxformsPassword = null;\n                            } else if (!instanceResource.trim().equals(\"\")) {\n\n                                // External instance\n                                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                                // NOTE: Optimizing with include() for servlets doesn't allow detecting errors caused by\n                                // the included resource, so we don't allow this for now. Furthermore, we are forced to\n                                // \"optimize\" for portlet access.\n\n    //                            final boolean optimize = !NetUtils.urlHasProtocol(srcAttribute)\n    //                               && (externalContext.getRequest().getContainerType().equals(\"portlet\")\n    //                                    || (externalContext.getRequest().getContainerType().equals(\"servlet\")\n    //                                        && XFormsUtils.isOptimizeLocalInstanceLoads()));\n\n                                final boolean optimizeForPortlets = !NetUtils.urlHasProtocol(instanceResource)\n                                                            && externalContext.getRequest().getContainerType().equals(\"portlet\");\n\n                                final ConnectionResult connectionResult;\n                                if (optimizeForPortlets) {\n                                    // Use optimized local mode\n\n                                    final URI resolvedURI = XFormsUtils.resolveXMLBase(instanceContainerElement, instanceResource);\n\n                                    if (XFormsServer.logger.isDebugEnabled())\n                                        containingDocument.logDebug(\"model\", \"getting document from optimized URI\",\n                                                    new String[] { \"URI\", resolvedURI.toString() });\n\n                                    connectionResult = XFormsSubmissionUtils.openOptimizedConnection(pipelineContext, externalContext,\n                                            null, null, \"get\", resolvedURI.toString(), null, false, null, null);\n\n                                    instanceSourceURI = resolvedURI.toString();\n                                    xxformsUsername = null;\n                                    xxformsPassword = null;\n\n                                    try {\n                                        try {\n                                            // Handle connection errors\n                                            if (connectionResult.statusCode != 200) {\n                                                throw new OXFException(\"Got invalid return code while loading instance: \" + instanceResource + \", \" + connectionResult.statusCode);\n                                            }\n\n                                            // TODO: Handle validating and handleXInclude!\n\n                                            // Read result as XML\n                                            if (!isReadonlyHint) {\n                                                instanceDocument = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                            } else {\n                                                instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                            }\n                                        } catch (Exception e) {\n                                            final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"reading external XForms instance (optimized)\", instanceContainerElement);\n                                            dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, instanceResource, e, instanceContainerElement, extendedLocationData);\n                                            break;\n                                        }\n                                    } finally {\n                                        // Clean-up\n                                        if (connectionResult != null)\n                                            connectionResult.close();\n                                    }\n\n                                } else {\n                                    // Connect using external protocol\n\n                                    // Extension: username and password\n                                    // NOTE: Those don't use AVTs for now, because XPath expressions in those could access\n                                    // instances that haven't been loaded yet.\n                                    xxformsUsername = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_USERNAME_QNAME);\n                                    xxformsPassword = instanceContainerElement.attributeValue(XFormsConstants.XXFORMS_PASSWORD_QNAME);\n\n                                    final URL absoluteResolvedURL;\n                                    final String absoluteResolvedURLString;\n                                    {\n                                        final String resolvedURL = XFormsUtils.resolveResourceURL(pipelineContext, instanceContainerElement, instanceResource,\n                                                ExternalContext.Response.REWRITE_MODE_ABSOLUTE_PATH_OR_RELATIVE);\n                                        final String inputName = ProcessorImpl.getProcessorInputSchemeInputName(resolvedURL);\n                                        if (inputName != null) {\n                                            // URL is input:*, keep it as is\n                                            absoluteResolvedURL = null;\n                                            absoluteResolvedURLString = resolvedURL;\n                                        } else {\n                                            // URL is regular URL, make sure it is absolute\n                                            absoluteResolvedURL = NetUtils.createAbsoluteURL(resolvedURL, null, externalContext);\n                                            absoluteResolvedURLString = absoluteResolvedURL.toExternalForm();\n                                        }\n                                    }\n\n                                    // Get instance from shared cache if possible\n                                    if (isApplicationSharedHint) {\n                                        final SharedXFormsInstance sharedXFormsInstance = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, instanceId, modelEffectiveId, absoluteResolvedURLString, xxformsTimeToLive, xxformsValidation);\n                                        setInstance(sharedXFormsInstance, false);\n                                        continue;\n                                    }\n\n                                    if (containingDocument.getURIResolver() == null || isApplicationSharedHint) {\n                                        // Connect directly if there is no resolver or if the instance is globally shared\n\n                                        if (XFormsServer.logger.isDebugEnabled())\n                                            containingDocument.logDebug(\"model\", \"getting document from URI\",\n                                                    new String[] { \"URI\", absoluteResolvedURLString });\n\n                                        connectionResult = NetUtils.openConnection(externalContext, containingDocument.getIndentedLogger(),\n                                                \"GET\", absoluteResolvedURL, xxformsUsername, xxformsPassword, null, null, null,\n                                                XFormsProperties.getForwardSubmissionHeaders(containingDocument));\n\n                                        try {\n                                            try {\n                                                // Handle connection errors\n                                                if (connectionResult.statusCode != 200) {\n                                                    throw new OXFException(\"Got invalid return code while loading instance: \" + instanceResource + \", \" + connectionResult.statusCode);\n                                                }\n\n                                                // TODO: Handle validating and XInclude!\n\n                                                // Read result as XML\n                                                if (!isReadonlyHint) {\n                                                    instanceDocument = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                                } else {\n                                                    instanceDocument = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, false);\n                                                }\n                                            } catch (Exception e) {\n                                                final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"reading external instance (no resolver)\", instanceContainerElement);\n                                                dispatchXFormsLinkExceptionEvent(pipelineContext, connectionResult, instanceResource, e, instanceContainerElement, extendedLocationData);\n                                                break;\n                                            }\n                                        } finally {\n                                            // Clean-up\n                                            if (connectionResult != null)\n                                                connectionResult.close();\n                                        }\n\n                                    } else {\n                                        // Optimized case that uses the provided resolver\n                                        if (XFormsServer.logger.isDebugEnabled())\n                                            containingDocument.logDebug(\"model\", \"getting document from resolver\",\n                                                    new String[] { \"URI\", absoluteResolvedURLString });\n\n                                        try {\n                                            // TODO: Handle validating and handleXInclude!\n\n                                            if (!isReadonlyHint) {\n                                                instanceDocument = containingDocument.getURIResolver().readURLAsDocument(absoluteResolvedURLString, xxformsUsername, xxformsPassword,\n                                                        XFormsProperties.getForwardSubmissionHeaders(containingDocument));\n                                            } else {\n                                                instanceDocument = containingDocument.getURIResolver().readURLAsDocumentInfo(absoluteResolvedURLString, xxformsUsername, xxformsPassword,\n                                                        XFormsProperties.getForwardSubmissionHeaders(containingDocument));\n                                            }\n                                        } catch (Exception e) {\n                                            final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"reading external instance (resolver)\", instanceContainerElement);\n                                            dispatchXFormsLinkExceptionEvent(pipelineContext, new ConnectionResult(absoluteResolvedURLString), instanceResource, e, instanceContainerElement, extendedLocationData);\n                                            break;\n                                        }\n                                    }\n\n                                    instanceSourceURI = absoluteResolvedURLString;\n                                }\n                            } else {\n                                // Got a blank src attribute, just dispatch xforms-link-exception\n                                final LocationData extendedLocationData = new ExtendedLocationData(locationData, \"processing XForms instance\", instanceContainerElement);\n                                final Throwable throwable = new ValidationException(\"Invalid blank URL specified for instance: \" + instanceId, extendedLocationData);\n                                container.dispatchEvent(pipelineContext, new XFormsLinkExceptionEvent(XFormsModel.this, instanceResource, instanceContainerElement, throwable));\n                                break;\n                            }\n                        }\n                        containingDocument.endHandleOperation();\n\n                        // Set instance and associated information if everything went well\n                        setInstanceDocument(instanceDocument, modelEffectiveId, instanceId, instanceSourceURI, xxformsUsername, xxformsPassword, isApplicationSharedHint, xxformsTimeToLive, xxformsValidation);\n                    }\n                }\n            }\n\n            // 3. P3P (N/A)\n\n            // 4. Instance data is constructed. Evaluate binds:\n            //    a. Evaluate nodeset\n            //    b. Apply model item properties on nodes\n            //    c. Throws xforms-binding-exception if the node has already model item property with same name\n            // TODO: a, b, c\n\n            // 5. xforms-rebuild, xforms-recalculate, xforms-revalidate\n            doRebuild(pipelineContext);\n            doRecalculate(pipelineContext);\n            doRevalidate(pipelineContext);\n\n            synchronizeInstanceDataEventState();\n\n        } else if (XFormsEvents.XXFORMS_READY.equals(eventName)) {\n\n            // This is called after xforms-ready events have been dispatched to all models\n\n            final XFormsStaticState staticState = containingDocument.getStaticState();\n\n            if (staticState != null && !staticState.isInitialized()) {\n                // The static state is open to adding instances\n                if (getInstances() != null) {\n                    for (Iterator instanceIterator = getInstances().iterator(); instanceIterator.hasNext();) {\n                        final XFormsInstance currentInstance = (XFormsInstance) instanceIterator.next();\n\n                        if (currentInstance instanceof SharedXFormsInstance) {\n\n                            // NOTE: We add all shared instances, even the globally shared ones, and the static state\n                            // decides of the amount of information to actually store\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"model\", \"adding read-only instance to static state\",\n                                    new String[] { \"instance\", currentInstance.getEffectiveId() });\n                            staticState.addSharedInstance((SharedXFormsInstance) currentInstance);\n                        }\n                        // TODO: something like staticState.hasReset(modelId);\n                        // TODO: maybe we won't do this here, but by restoring the initial dynamic state instead\n//                        final boolean modelHasReset = false;\n//                        else if (modelHasReset) {\n//                            if (XFormsServer.logger.isDebugEnabled())\n//                                containingDocument.logDebug(\"model\", \"adding reset instance to static state\",\n//                                    new String[] { \"instance\", currentInstance.getEffectiveId() });\n//                            staticState.addSharedInstance(currentInstance.createSharedInstance());\n//                        }\n                    }\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_MODEL_CONSTRUCT_DONE.equals(eventName)) {\n            // 4.2.2 The xforms-model-construct-done Event\n            // Bubbles: Yes / Cancelable: No / Context Info: None\n\n            // TODO: implicit lazy instance construction\n\n        } else if (XFormsEvents.XFORMS_REBUILD.equals(eventName)) {\n            // 4.3.7 The xforms-rebuild Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRebuild(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RECALCULATE.equals(eventName)) {\n            // 4.3.6 The xforms-recalculate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRecalculate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REVALIDATE.equals(eventName)) {\n            // 4.3.5 The xforms-revalidate Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRevalidate(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_REFRESH.equals(eventName)) {\n            // 4.3.4 The xforms-refresh Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            doRefresh(pipelineContext);\n\n        } else if (XFormsEvents.XFORMS_RESET.equals(eventName)) {\n            // 4.3.8 The xforms-reset Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            // TODO\n            // \"The instance data is reset to the tree structure and values it had immediately\n            // after having processed the xforms-ready event.\"\n\n            // \"Then, the events xforms-rebuild, xforms-recalculate, xforms-revalidate and\n            // xforms-refresh are dispatched to the model element in sequence.\"\n            container.dispatchEvent(pipelineContext, new XFormsRebuildEvent(XFormsModel.this));\n            container.dispatchEvent(pipelineContext, new XFormsRecalculateEvent(XFormsModel.this));\n            container.dispatchEvent(pipelineContext, new XFormsRevalidateEvent(XFormsModel.this));\n            container.dispatchEvent(pipelineContext, new XFormsRefreshEvent(XFormsModel.this));\n\n        } else if (XFormsEvents.XFORMS_COMPUTE_EXCEPTION.equals(eventName) || XFormsEvents.XFORMS_LINK_EXCEPTION.equals(eventName)) {\n            // 4.5.4 The xforms-compute-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: Implementation-specific error string.\n            // The default action for this event results in the following: Fatal error.\n\n            // 4.5.2 The xforms-link-exception Event\n            // Bubbles: Yes / Cancelable: No / Context Info: The URI that failed to load (xsd:anyURI)\n            // The default action for this event results in the following: Fatal error.\n\n            final XFormsExceptionEvent exceptionEvent = (XFormsExceptionEvent) event;\n            final Throwable throwable = exceptionEvent.getThrowable();\n            if (throwable instanceof RuntimeException)\n                throw (RuntimeException) throwable;\n            else\n                throw new ValidationException(\"Received fatal error event: \" + eventName, throwable, (LocationData) modelDocument.getRootElement().getData());\n        }\n    }","commit_id":"296fffa807799d19e83f44f91e8f1ba19f9f5ccd","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Utility method to extract event handlers.\n     *\n     * @param containingElement         element possibly containing event handlers\n     * @param eventNamesMap             Map<String, String> of event name to \"\"\n     * @return                          Map<String, List<XFormsEventHandler>> of observer id to List of XFormsEventHandler\n     */\n    public static Map extractEventHandlers(Element containingElement, Map eventNamesMap) {\n\n        // Nothing to do if there are no children elements\n        final List children = containingElement.elements();\n        if (children == null)\n            return null;\n\n        Map eventHandlersMap = null;\n        final String containerIdAttribute = containingElement.attributeValue(\"id\");\n        for (Iterator i = children.iterator(); i.hasNext();) {\n            final Element currentElement = (Element) i.next();\n\n            if (XFormsActions.isActionName(currentElement.getNamespaceURI(), currentElement.getName())) {\n                final String eventAttribute = currentElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n                if (eventAttribute != null) {\n\n                    // Found an action with ev:event attribute\n                    if (eventHandlersMap == null)\n                        eventHandlersMap = new HashMap();\n\n                    final XFormsEventHandlerImpl newEventHandlerImpl = new XFormsEventHandlerImpl(currentElement, containerIdAttribute);\n                    final String[] observerIds = newEventHandlerImpl.getObserverIds();\n                    for (int j = 0; j < observerIds.length; j++) {\n                        final String currentObserverId = observerIds[j];\n                        // Get handlers for observer\n                        final List eventHandlersForObserver;\n                        {\n                            final Object currentList = eventHandlersMap.get(currentObserverId);\n                            if (currentList == null) {\n                                eventHandlersForObserver = new ArrayList();\n                                eventHandlersMap.put(currentObserverId, eventHandlersForObserver);\n                            } else {\n                                eventHandlersForObserver = (List) currentList;\n                            }\n                        }\n\n                        // Add event handler\n                        eventHandlersForObserver.add(newEventHandlerImpl);\n                    }\n                    \n                    // Remember all event names\n                    final String[] eventNames = StringUtils.split(eventAttribute);\n                    for (int j = 0; j < eventNames.length; j++)\n                        eventNamesMap.put(eventNames[j], \"\");\n                }\n            }\n        }\n        return eventHandlersMap;\n    }","id":86204,"modified_method":"/**\n     * Utility method to extract event handlers.\n     *\n     * @param containingElement         element possibly containing event handlers\n     * @param eventNamesMap             Map<String, String> of event name to \"\"\n     * @return                          Map<String, List<XFormsEventHandler>> of observer id to List of XFormsEventHandler\n     */\n    public static Map extractEventHandlers(Element containingElement, Map eventNamesMap) {\n\n        // TODO: we should check recursively for all event handlers, except within inline instances\n\n        // Nothing to do if there are no children elements\n        final List children = containingElement.elements();\n        if (children == null)\n            return null;\n\n        Map eventHandlersMap = null;\n        final String containerIdAttribute = containingElement.attributeValue(\"id\");\n        for (Iterator i = children.iterator(); i.hasNext();) {\n            final Element currentElement = (Element) i.next();\n\n            if (XFormsActions.isActionName(currentElement.getNamespaceURI(), currentElement.getName())) {\n                final String eventAttribute = currentElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n                if (eventAttribute != null) {\n\n                    // Found an action with ev:event attribute\n                    if (eventHandlersMap == null)\n                        eventHandlersMap = new HashMap();\n\n                    addEventHandler(eventNamesMap, eventHandlersMap, containerIdAttribute, currentElement, eventAttribute);\n                }\n\n                // Handle nested actions with ev:observer or ev:target\n                // TODO: should check recursively\n                if (currentElement.getName().equals(XFormsActions.XFORMS_ACTION_ACTION)) {\n                    for (Iterator j = currentElement.elements().iterator(); j.hasNext();) {\n                        final Element currentActionElement = (Element) j.next();\n                        final String actionEventAttribute = currentActionElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n                        if (actionEventAttribute != null &&\n                                (currentActionElement.attributeValue(XFormsConstants.XML_EVENTS_OBSERVER_ATTRIBUTE_QNAME) != null\n                                    || currentActionElement.attributeValue(XFormsConstants.XML_EVENTS_TARGET_ATTRIBUTE_QNAME) != null)) {\n\n                            // Found a nested action\n                            if (eventHandlersMap == null)\n                                eventHandlersMap = new HashMap();\n\n                            // Mmh, containerIdAttribute here doesn't make much sense, does it? See XFormsActionInterpreter`\n                            addEventHandler(eventNamesMap, eventHandlersMap, containerIdAttribute, currentActionElement, actionEventAttribute);\n                        }\n                    }\n                }\n            }\n        }\n        return eventHandlersMap;\n    }","commit_id":"e2f055e4212303d58f7e91a473df27c35fa90ef2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            containingDocument.setGotSubmission();\n\n            boolean isDeferredSubmissionSecondPassReplaceAll = false;\n            XFormsSubmitErrorEvent submitErrorEvent = null;\n            XFormsSubmitDoneEvent submitDoneEvent = null;\n            final long submissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n\n            // Make sure submission element info is extracted\n            extractSubmissionElement();\n\n            // XPath function library and namespace mappings\n            final FunctionLibrary functionLibrary = XFormsContainingDocument.getFunctionLibrary();\n            final Map prefixToURIMap = containingDocument.getStaticState().getNamespaceMappings(getEffectiveId());\n\n            try {\n                final boolean isReplaceAll = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isReplaceInstance = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE);\n                final boolean isReplaceText = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_TEXT);\n                final boolean isReplaceNone = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE);\n\n                // Get current node for xforms:submission and instance containing the node to submit\n                final NodeInfo currentNodeInfo;\n                final XFormsInstance currentInstance;\n                // Create context (should we simply reuse that of the model?)\n                final XFormsContextStack contextStack = new XFormsContextStack(model);\n                final XFormsFunction.Context functionContext;\n                {\n                    contextStack.setBinding(pipelineContext, XFormsModelSubmission.this);\n\n                    currentNodeInfo = contextStack.getCurrentSingleNode();\n                    functionContext = contextStack.getFunctionContext();\n\n                    // Check that we have a current node and that it is pointing to a document or an element\n                    if (currentNodeInfo == null)\n                        throw new XFormsSubmissionException(\"Empty single-node binding on xforms:submission for submission id: \" + id, \"getting submission single-node binding\",\n                        \t\t XFormsSubmitErrorEvent.ErrorType.NO_DATA);\n\n                    if (!(currentNodeInfo instanceof DocumentInfo || currentNodeInfo.getNodeKind() == org.w3c.dom.Document.ELEMENT_NODE)) {\n                        throw new XFormsSubmissionException(\"xforms:submission: single-node binding must refer to a document node or an element.\", \"getting submission single-node binding\",\n                        \t\tXFormsSubmitErrorEvent.ErrorType.NO_DATA);\n                    }\n\n                    // Current instance may be null if the document submitted is not part of an instance\n                    currentInstance = contextStack.getCurrentInstance();\n                }\n\n                // Determine if the instance to submit has one or more bound and relevant upload controls\n                //\n                // o we don't check if we are currently initializing the document because at that point the\n                //   client cannot have any files to upload yet\n                //\n                // o we don't check if we have already processed the second pass of a submission during this\n                //   request, because it means that upload controls have been already committed\n                //\n                // o we don't check if we are requested not to with an attribute\n                //\n                // o we only check for replace=\"instance|none\" and if serialization must take place\n\n                boolean hasBoundRelevantUploadControl = false;\n                if (currentInstance!= null && !containingDocument.isInitializing() && !containingDocument.isGotSubmissionSecondPass() && xxfFormsEnsureUploads && !isReplaceAll && serialize) {\n                    final XFormsControls xformsControls = containingDocument.getXFormsControls();\n                    final List uploadControls = xformsControls.getCurrentControlsState().getUploadControls();\n                    if (uploadControls != null) {\n                        for (Iterator i = uploadControls.iterator(); i.hasNext();) {\n                            final XFormsUploadControl currentControl = (XFormsUploadControl) i.next();\n                            if (currentControl.isRelevant()) {\n                                final NodeInfo boundNodeInfo = currentControl.getBoundNode();\n                                if (currentInstance == currentInstance.getModel(containingDocument).getInstanceForNode(boundNodeInfo)) {\n                                    // Found one relevant upload control bound to the instance we are submitting\n                                    hasBoundRelevantUploadControl = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Evaluate early AVTs\n                {\n                    final String resolvedMethodQName = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMethod);\n                    resolvedMethod = Dom4jUtils.qNameToexplodedQName(Dom4jUtils.extractTextValueQName(prefixToURIMap, resolvedMethodQName));\n                }\n\n                final boolean isHandlingOptimizedGet = XFormsProperties.isOptimizeGetAllSubmission(containingDocument) && XFormsSubmissionUtils.isGet(resolvedMethod)\n                        && isReplaceAll\n                        && avtXXFormsUsername == null; // can't optimize if there are authentication credentials\n\n                final boolean isDeferredSubmission = (isReplaceAll && !isHandlingOptimizedGet) || (!isReplaceAll && serialize && hasBoundRelevantUploadControl);\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n                final boolean isDeferredSubmissionSecondPass = isDeferredSubmission && !isDeferredSubmissionFirstPass; // here we get XXFORMS_SUBMIT\n                isDeferredSubmissionSecondPassReplaceAll = isDeferredSubmissionSecondPass && isReplaceAll;\n\n                if (isDeferredSubmissionSecondPass)\n                    containingDocument.setGotSubmissionSecondPass();\n\n                // If a submission requiring a second pass was already set, then we ignore a subsequent submission but\n                // issue a warning\n                {\n                    final XFormsModelSubmission existingSubmission = containingDocument.getClientActiveSubmission();\n                    if (isDeferredSubmission && existingSubmission != null) {\n                        logger.warn(\"XForms - submission - another submission requiring a second pass already exists (\" + existingSubmission.getEffectiveId() + \"). Ignoring new submission (\" + this.getEffectiveId() + \").\");\n                        return;\n                    }\n                }\n\n                // \"The data model is updated\"\n                final XFormsModel modelForInstance;\n                if (currentInstance != null) {\n                    modelForInstance = currentInstance.getModel(containingDocument);\n                    {\n                        // NOTE: XForms 1.1 seems to say this should happen regardless of whether we serialize or not. If\n                        // the instance is not serialized and if no instance data is otherwise used for the submission,\n                        // this seems however unneeded.\n\n                        // TODO: XForms 1.1 says that we should rebuild/recalculate the \"model containing this submission\".\n\n                        final XFormsModel.DeferredActionContext deferredActionContext = modelForInstance.getDeferredActionContext();\n                        if (deferredActionContext != null) {\n                            if (deferredActionContext.rebuild) {\n                                modelForInstance.doRebuild(pipelineContext);\n                            }\n                            if (deferredActionContext.recalculate) {\n                                modelForInstance.doRecalculate(pipelineContext);\n                            }\n                        }\n                    }\n                } else {\n                    // Case where no instance was found\n                    modelForInstance = null;\n                }\n\n                final Document initialDocumentToSubmit;\n                if (serialize && !isDeferredSubmissionSecondPass) {\n                    initialDocumentToSubmit = createDocumentToSubmit(pipelineContext, currentNodeInfo, currentInstance, modelForInstance);\n                } else {\n                    initialDocumentToSubmit = null;\n                }\n\n                // Deferred submission: end of the first pass\n                if (isDeferredSubmissionFirstPass) {\n\n                    // Resolve the target AVT if needed\n                    resolvedXXFormsTarget = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsTarget);\n\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                // Evaluate late AVTs\n                {\n                    final String tempActionOrResource = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtActionOrResource);\n                    resolvedActionOrResource = XFormsUtils.encodeHRRI(tempActionOrResource, true);\n\n                    resolvedXXFormsUsername = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsUsername);\n                    resolvedXXFormsPassword = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsPassword);\n                    resolvedXXFormsReadonly = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsReadonly);\n                    resolvedXXFormsShared = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsShared);\n\n                    // Default is \"false\" for security reasons\n                    final String tempHandleXInclude = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsHandleXInclude);\n                    resolvedXXFormsHandleXInclude = \"true\".equals(tempHandleXInclude);\n                }\n\n                // Check read-only and shared hints\n                XFormsInstance.checkSharedHints(submissionElement, resolvedXXFormsReadonly, resolvedXXFormsShared);\n                final boolean isReadonlyHint = \"true\".equals(resolvedXXFormsReadonly);\n                final boolean isApplicationSharedHint = \"application\".equals(resolvedXXFormsShared);\n                final long timeToLive = XFormsInstance.getTimeToLive(submissionElement);\n                if (isApplicationSharedHint) {\n                    if (!XFormsSubmissionUtils.isGet(resolvedMethod))\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with method=\\\"get\\\".\",\n                                \"checking read-only and shared hints\");\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                } else if (isReadonlyHint) {\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:readonly=\\\"true\\\" can be \\\"true\\\" only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                }\n\n                final Document documentToSubmit;\n                if (serialize && isDeferredSubmissionSecondPass) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmitEvent) ? ((XXFormsSubmitEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        for (Iterator i = filesElement.elements().iterator(); i.hasNext();) {\n                            final Element parameterElement = (Element) i.next();\n                            final String name = parameterElement.element(\"name\").getTextTrim();\n\n                            final XFormsUploadControl uploadControl\n                                        = (XFormsUploadControl) containingDocument.getObjectById(name);\n\n                            // In case of xforms:repeat, the name of the template will not match an existing control\n                            if (uploadControl == null)\n                                continue;\n\n                            final Element valueElement = parameterElement.element(\"value\");\n                            final String value = valueElement.getTextTrim();\n\n                            final String filename;\n                            {\n                                final Element filenameElement = parameterElement.element(\"filename\");\n                                filename = (filenameElement != null) ? filenameElement.getTextTrim() : \"\";\n                            }\n                            final String mediatype;\n                            {\n                                final Element mediatypeElement = parameterElement.element(\"content-type\");\n                                mediatype = (mediatypeElement != null) ? mediatypeElement.getTextTrim() : \"\";\n                            }\n                            final String size = parameterElement.element(\"content-length\").getTextTrim();\n\n                            if (size.equals(\"0\") && filename.equals(\"\")) {\n                                // No file was selected in the UI\n                            } else {\n                                // A file was selected in the UI (note that the file may be empty)\n                                final String paramValueType = Dom4jUtils.qNameToexplodedQName(Dom4jUtils.extractAttributeValueQName(valueElement, XMLConstants.XSI_TYPE_QNAME));\n\n                                // Set value of uploaded file into the instance (will be xs:anyURI or xs:base64Binary)\n                                uploadControl.setExternalValue(pipelineContext, value, paramValueType, !isReplaceAll);\n\n                                // Handle filename, mediatype and size if necessary\n                                uploadControl.setFilename(pipelineContext, filename);\n                                uploadControl.setMediatype(pipelineContext, mediatype);\n                                uploadControl.setSize(pipelineContext, size);\n                            }\n                        }\n                    }\n\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(pipelineContext, currentNodeInfo, currentInstance, modelForInstance);\n\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = initialDocumentToSubmit;\n                }\n\n                if (serialize && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    // Fire xforms-submit-serialize\n\n                    // \"The event xforms-submit-serialize is dispatched. If the submission-body property of the event\n                    // is changed from the initial value of empty string, then the content of the submission-body\n                    // property string is used as the submission serialization. Otherwise, the submission serialization\n                    // consists of a serialization of the selected instance data according to the rules stated at 11.9\n                    // Submission Options.\"\n\n                    // TODO: pass submission-body attribute\n                    containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitSerializeEvent(XFormsModelSubmission.this));\n                    // TODO: look at result of submission-body attribute and see if submission body needs to be replaced\n                }\n\n                // Serialize\n                // To support: application/xml, application/x-www-form-urlencoded, multipart/related, multipart/form-data\n                final byte[] messageBody;\n                final String queryString;\n                final String defaultMediatypeForSerialization;\n                {\n                    if (resolvedMethod.equals(\"multipart-post\")) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"multipart/related\";\n\n                        // TODO\n                        throw new XFormsSubmissionException(\"xforms:submission: submission method not yet implemented: \" + resolvedMethod, \"serializing instance\");\n                    } else if (resolvedMethod.equals(\"form-data-post\")) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"multipart/form-data\";\n\n                        // TODO\n\n//                        final MultipartFormDataBuilder builder = new MultipartFormDataBuilder(, , null);\n\n                        throw new XFormsSubmissionException(\"xforms:submission: submission method not yet implemented: \" + resolvedMethod, \"serializing instance\");\n                    } else if (resolvedMethod.equals(\"urlencoded-post\")) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"application/x-www-form-urlencoded\";\n\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        queryString = null;\n                        messageBody = serialize? createWwwFormUrlEncoded(documentToSubmit).getBytes(\"UTF-8\") : null;// the resulting string is already ASCII\n                        defaultMediatypeForSerialization = \"application/x-www-form-urlencoded\";\n\n                    } else if (XFormsSubmissionUtils.isPost(resolvedMethod) || XFormsSubmissionUtils.isPut(resolvedMethod)) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"application/xml\";\n\n                        if (serialize) {\n\n                            if (XMLUtils.isXMLMediatype(serialization)) {\n                                // XML serialization\n\n                                // Serialize XML to a stream of bytes\n                                try {\n                                    final Transformer identity = TransformerUtils.getIdentityTransformer();\n                                    TransformerUtils.applyOutputProperties(identity,\n                                            \"xml\", version, null, null, encoding, omitxmldeclaration, standalone, indent, 4);\n\n                                    // TODO: use cdata-section-elements\n\n                                    final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                                    identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                                    messageBody = os.toByteArray();\n                                } catch (Exception e) {\n                                    throw new XFormsSubmissionException(e, \"xforms:submission: exception while serializing instance to XML.\", \"serializing instance\");\n                                }\n                                defaultMediatypeForSerialization = \"application/xml\";\n                            } else if (XMLUtils.isTextContentType(serialization)) {\n                                // Text serialization\n                                // TODO\n                                throw new XFormsSubmissionException(\"xforms:submission: text serialization is not yet implemented.\", \"serializing instance\");\n                            } else {\n                                // Binary serialization\n\n                                final String nodeType = InstanceData.getType(documentToSubmit.getRootElement());\n\n                                if (XMLConstants.XS_ANYURI_EXPLODED_QNAME.equals(nodeType)) {\n                                    // Interpret node as anyURI\n                                    // TODO: PERFORMANCE: Must pass InputStream all the way to the submission instead of storing into byte[] in memory!\n                                    final String uri = documentToSubmit.getRootElement().getStringValue();\n                                    messageBody = NetUtils.uriToByteArray(uri);\n                                } else if (XMLConstants.XS_BASE64BINARY_EXPLODED_QNAME.equals(nodeType)) {\n                                    // TODO\n                                    throw new XFormsSubmissionException(\"xforms:submission: binary serialization with base64Binary type is not yet implemented.\", \"serializing instance\");\n                                } else {\n                                    // TODO\n                                    throw new XFormsSubmissionException(\"xforms:submission: binary serialization without a type is not yet implemented.\", \"serializing instance\");\n                                }\n                                defaultMediatypeForSerialization = \"application/octet-stream\";\n                            }\n                        } else {\n                            messageBody = null;\n                            defaultMediatypeForSerialization = null;\n                        }\n                        queryString = null;\n\n                    } else if (XFormsSubmissionUtils.isGet(resolvedMethod) || XFormsSubmissionUtils.isDelete(resolvedMethod)) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"application/x-www-form-urlencoded\";\n\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        queryString = serialize ? createWwwFormUrlEncoded(documentToSubmit) : null;\n                        messageBody = null;\n                        defaultMediatypeForSerialization = null;\n\n                    } else {\n                        throw new XFormsSubmissionException(\"xforms:submission: invalid submission method requested: \" + resolvedMethod, \"serializing instance\");\n                    }\n                }\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Get URL type\n                final String urlType = submissionElement.attributeValue(XMLConstants.FORMATTING_URL_TYPE_QNAME);\n                final ExternalContext.Request request = externalContext.getRequest();\n\n                // Find instance to update\n                final XFormsInstance replaceInstance;\n                if (isReplaceInstance) {\n                    if (xxfReplaceInstanceId != null)\n                        replaceInstance = containingDocument.findInstance(xxfReplaceInstanceId);\n                    else if (replaceInstanceId != null)\n                        replaceInstance = model.getInstance(replaceInstanceId);\n                    else if (currentInstance == null)\n                        replaceInstance = model.getDefaultInstance();\n                    else\n                        replaceInstance = currentInstance;\n                } else {\n                    replaceInstance = null;\n                }\n\n                // Result information\n                ConnectionResult connectionResult = null;\n                final long externalSubmissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n                try {\n                    if ((isReplaceInstance || isReplaceNone) && resolvedActionOrResource.startsWith(\"test:\")) {\n                        // Test action\n\n                        if (messageBody == null)\n                            throw new XFormsSubmissionException(\"Action 'test:': no message body.\", \"processing submission response\");\n\n                        connectionResult = new ConnectionResult(null);\n                        connectionResult.statusCode = 200;\n                        connectionResult.responseHeaders = new HashMap();\n                        connectionResult.lastModified = 0;\n                        connectionResult.responseMediaType = \"application/xml\";\n                        connectionResult.dontHandleResponse = false;\n                        connectionResult.setResponseInputStream(new ByteArrayInputStream(messageBody));\n\n                    } else if (isHandlingOptimizedGet) {\n                        // GET with replace=\"all\": we can optimize and tell the client to just load the URL\n\n                        final String actionString = (queryString == null) ? resolvedActionOrResource : resolvedActionOrResource + ((resolvedActionOrResource.indexOf('?') == -1) ? \"?\" : \"\") + queryString;\n                        final String resultURL = XFormsLoadAction.resolveLoadValue(containingDocument, pipelineContext, submissionElement, true, actionString, null, null, fURLNorewrite, xxfShowProgress);\n                        connectionResult = new ConnectionResult(resultURL);\n                        connectionResult.dontHandleResponse = true;\n\n                    } else if (!NetUtils.urlHasProtocol(resolvedActionOrResource)\n                               && !fURLNorewrite\n                               && headerNames == null\n                               && ((request.getContainerType().equals(\"portlet\") && !\"resource\".equals(urlType))\n                                    || (request.getContainerType().equals(\"servlet\")\n                                        && (XFormsProperties.isOptimizeLocalSubmission(containingDocument) || isMethodOptimizedLocalSubmission())\n                                        &&  isReplaceAll))) {\n\n                        // This is an \"optimized\" submission, i.e. one that does not use an actual\n                        // protocol handler to access the resource\n\n                        // NOTE: Optimizing with include() for servlets doesn't allow detecting\n                        // errors caused by the included resource, so we don't allow this for now.\n\n                        // NOTE: For portlets, paths are served directly by the portlet, NOT as\n                        // resources.\n\n                        // Current limitations:\n                        // o Portlets cannot access resources outside the portlet except by using absolute URLs (unless f:url-type=\"resource\")\n                        // o Servlets cannot access resources on the same server but not in the current application\n                        //   except by using absolute URLs\n\n                        final URI resolvedURI = XFormsUtils.resolveXMLBase(submissionElement, resolvedActionOrResource);\n\n                        // NOTE: We don't want any changes to happen to the document upon xxforms-submit when producing\n                        // a new document so we don't dispatch xforms-submit-done and pass a null XFormsModelSubmission\n                        // in that case\n                        connectionResult = XFormsSubmissionUtils.doOptimized(pipelineContext, externalContext,\n                                isDeferredSubmissionSecondPassReplaceAll ? null : this, resolvedMethod, resolvedURI.toString(), (mediatype == null) ? defaultMediatypeForSerialization : mediatype, isReplaceAll,\n                                messageBody, queryString);\n\n                    } else {\n                        // This is a regular remote submission going through a protocol handler\n\n                        // Absolute URLs or absolute paths are allowed to a local servlet\n                        String resolvedURL;\n\n                        if (NetUtils.urlHasProtocol(resolvedActionOrResource) || fURLNorewrite) {\n                            // Don't touch the URL if it is absolute or if f:url-norewrite=\"true\"\n                            resolvedURL = resolvedActionOrResource;\n                        } else {\n                            // Rewrite URL\n                            resolvedURL = XFormsUtils.resolveResourceURL(pipelineContext, submissionElement, resolvedActionOrResource, false);\n\n                            if (request.getContainerType().equals(\"portlet\") && \"resource\".equals(urlType) && !NetUtils.urlHasProtocol(resolvedURL)) {\n                                // In this case, we have to prepend the complete server path\n                                resolvedURL = request.getScheme() + \"://\" + request.getServerName() + (request.getServerPort() > 0 ? \":\" + request.getServerPort() : \"\") + resolvedURL;\n                            }\n                        }\n\n                        if (isApplicationSharedHint) {\n                            // Get the instance from shared instance cache\n                            // This can only happen is method=\"get\" and replace=\"instance\" and xxforms:readonly=\"true\" and xxforms:shared=\"application\"\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"using instance from application shared instance cache\",\n                                        new String[] { \"instance\", replaceInstance.getEffectiveId() });\n\n                            final URL absoluteResolvedURL = XFormsSubmissionUtils.createAbsoluteURL(resolvedURL, queryString, externalContext);\n                            final String absoluteResolvedURLString = absoluteResolvedURL.toExternalForm();\n\n                            final SharedXFormsInstance sharedInstance\n                                    = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, replaceInstance.getEffectiveId(), replaceInstance.getModelId(), absoluteResolvedURLString, timeToLive, replaceInstance.getValidation());\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                        new String[] { \"instance\", sharedInstance.getEffectiveId() });\n\n                            // Handle new instance and associated events\n                            final XFormsModel replaceModel = sharedInstance.getModel(containingDocument);\n                            replaceModel.handleNewInstanceDocuments(pipelineContext, sharedInstance);\n\n                            connectionResult = null;\n                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, absoluteResolvedURLString, 200);\n                        } else {\n                            // Perform actual submission\n                            connectionResult = XFormsSubmissionUtils.doRegular(externalContext, containingDocument,\n                                    resolvedMethod, resolvedURL, resolvedXXFormsUsername, resolvedXXFormsPassword, (mediatype == null) ? defaultMediatypeForSerialization : mediatype,\n                                    messageBody, queryString, headerNames, headerNameValues);\n                        }\n                    }\n\n                    if (connectionResult != null && !connectionResult.dontHandleResponse) {\n                        // Handle response\n                        if (connectionResult.statusCode >= 200 && connectionResult.statusCode < 300) {// accept any success code (in particular \"201 Resource Created\")\n                            // Sucessful response\n                            if (connectionResult.hasContent()) {\n                                // There is a body\n\n                                if (isReplaceAll) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    if (!isDeferredSubmissionSecondPassReplaceAll) // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                                        containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult));\n\n                                    final ExternalContext.Response response = externalContext.getResponse();\n\n                                    // Forward headers to response\n                                    connectionResult.forwardHeaders(response);\n\n                                    // Forward content to response\n                                    NetUtils.copyStream(connectionResult.getResponseInputStream(), response.getOutputStream());\n\n                                    // TODO: [#306918] RFE: Must be able to do replace=\"all\" during initialization.\n                                    // http://forge.objectweb.org/tracker/index.php?func=detail&aid=306918&group_id=168&atid=350207\n                                    // Suggestion is to write either binary or XML to processor output ContentHandler,\n                                    // and make sure the code which would output the XHTML+XForms is disabled.\n\n                                } else if (isReplaceInstance) {\n\n                                    if (XMLUtils.isXMLMediatype(connectionResult.responseMediaType)) {\n                                        // Handling of XML media type\n                                        // Set new instance document to replace the one submitted\n\n                                        if (replaceInstance == null) {\n                                            // Replacement instance was specified but not found TODO: XForms 1.1 won't\n                                            // dispatch xforms-binding-exception here Not sure what's the right thing to\n                                            // do with 1.1, but this could be done as part of the model's static\n                                            // analysis if the instance value is not obtained through AVT, and\n                                            // dynamically otherwise. However, in the dynamic case, I think that this\n                                            // should be a (currently non-specified by XForms) xforms-binding-error.\n                                            containingDocument.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                        } else {\n                                            final XFormsInstance newInstance;\n                                            try {\n                                                // Read stream into Document\n                                                if (!isReadonlyHint) {\n                                                    // Resulting instance is not read-only\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with mutable instance\",\n                                                            new String[] { \"instance\", replaceInstance.getEffectiveId() });\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    final Document resultingInstanceDocument\n                                                            = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n                                                    newInstance = new XFormsInstance(replaceInstance.getModelId(), replaceInstance.getEffectiveId(), resultingInstanceDocument,\n                                                            connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword, false, -1, replaceInstance.getValidation());\n                                                } else {\n                                                    // Resulting instance is read-only\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                                            new String[] { \"instance\", replaceInstance.getEffectiveId() });\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    // NOTE: isApplicationSharedHint is always false when get get here. isApplicationSharedHint=\"true\" is handled above.\n                                                    final DocumentInfo resultingInstanceDocument = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n                                                    newInstance = new SharedXFormsInstance(replaceInstance.getModelId(), replaceInstance.getEffectiveId(), resultingInstanceDocument,\n                                                            connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword, false, -1, replaceInstance.getValidation());\n                                                }    \n                                            } catch (Exception e) {\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.PARSE_ERROR);\n                                                throw new XFormsSubmissionException(e, \"xforms:submission: exception while serializing XML to instance.\", \"processing instance replacement\");\n                                            }\n\n                                            // Handle new instance and associated events\n                                            final XFormsModel replaceModel = newInstance.getModel(containingDocument);\n                                            replaceModel.handleNewInstanceDocuments(pipelineContext, newInstance);\n\n                                            // Notify that submission is done\n                                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + connectionResult.responseMediaType, \"processing instance replacement\");\n                                    }\n                                } else if (isReplaceText) {\n\n                                    // XForms 1.1: \"If the replace attribute contains the value \"text\" and the\n                                    // submission response conforms to an XML mediatype (as defined by the content type\n                                    // specifiers in [RFC 3023]) or a text media type (as defined by a content type\n                                    // specifier of text/*), then the response data is encoded as text and replaces the\n                                    // content of the replacement target node.\"\n\n                                    // Get response body\n                                    String responseBody = \"\";\n                                    if (XMLUtils.isTextContentType(connectionResult.responseMediaType)) {\n                                        // Text mediatype (including text/xml), read stream into String\n                                        try {\n                                            final String charset = NetUtils.getTextCharsetFromContentType(connectionResult.responseMediaType);\n                                            final Reader reader = new InputStreamReader(connectionResult.responseInputStream, charset);\n                                            try {\n                                                responseBody = NetUtils.readStreamAsString(reader);\n                                            } finally {\n                                                try {\n                                                    reader.close();\n                                                } catch (Exception e) {\n                                                }\n                                            }\n                                        } catch (Exception e) {\n                                            XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                                        }\n                                    } else if (XMLUtils.isXMLMediatype(connectionResult.responseMediaType)) {\n                                        // XML mediatype other than text/xml\n\n                                        // TODO: What should we do if the response Content-Type includes a charset parameter?\n                                        final Reader reader = XMLUtils.getReaderFromXMLInputStream(connectionResult.resourceURI, connectionResult.responseInputStream);\n                                        try {\n                                            responseBody = NetUtils.readStreamAsString(reader);\n                                        } finally {\n                                            try {\n                                                reader.close();\n                                            } catch (Exception e) {\n                                            }\n                                        }\n                                    } else {\n                                        // This is a binary result\n\n                                        // Don't store anything for now as per the spec, but we could do something better by going beyond the spec\n                                        // NetUtils.inputStreamToAnyURI(pipelineContext, connectionResult.resultInputStream, NetUtils.SESSION_SCOPE);\n\n                                        // XForms 1.1: \"For a success response including a body that is both a non-XML\n                                        // media type (i.e. with a content type not matching any of the specifiers in\n                                        // [RFC 3023]) and a non-text type (i.e. with a content type not matching\n                                        // text/*), when the value of the replace attribute on element submission is\n                                        // \"text\", nothing in the document is replaced and submission processing\n                                        // concludes after dispatching xforms-submit-error with appropriate context\n                                        // information, including an error-type of resource-error.\"\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Mediatype is neither text nor XML for replace=\\\"text\\\": \" + connectionResult.responseMediaType, \"reading response body\");\n                                    }\n\n                                    // Find target location\n                                    final NodeInfo destinationNodeInfo;\n                                    if (target != null) {\n                                        // Evaluate destination node\n                                        final Object destinationObject\n                                                = XPathCache.evaluateSingle(pipelineContext, currentNodeInfo, target, prefixToURIMap,\n                                                contextStack.getCurrentVariables(), functionLibrary, functionContext, null, getLocationData());\n\n                                        if (destinationObject instanceof NodeInfo) {\n                                            destinationNodeInfo = (NodeInfo) destinationObject;\n                                            if (destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ATTRIBUTE_NODE) {\n                                                // Throw target-error\n\n                                                // XForms 1.1: \"If the processing of the target attribute fails, then\n                                                // submission processing ends after dispatching the event\n                                                // xforms-submit-error with an error-type of target-error.\"\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"target attribute doesn't point to an element or attribute for replace=\\\"text\\\".\", \"processing target attribute\");\n                                            }\n                                        } else {\n                                            // Throw target-error\n\n                                            // XForms 1.1: \"If the processing of the target attribute fails, then\n                                            // submission processing ends after dispatching the event\n                                            // xforms-submit-error with an error-type of target-error.\"\n                                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                            throw new XFormsSubmissionException(\"target attribute doesn't point to a node for replace=\\\"text\\\".\", \"processing target attribute\");\n                                        }\n                                    } else {\n                                        // Handle default destination\n                                        destinationNodeInfo = replaceInstance.getInstanceRootElementInfo();\n                                    }\n\n                                    // Set value into the instance\n                                    XFormsSetvalueAction.doSetValue(pipelineContext, containingDocument, this, destinationNodeInfo, responseBody, null, false);\n\n                                    // Notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n\n                                } else if (isReplaceNone) {\n                                    // Just notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                } else {\n                                    submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR);\n                                    throw new XFormsSubmissionException(\"xforms:submission: invalid replace attribute: \" + replace, \"processing instance replacement\");\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n\n                                if (isReplaceInstance) {\n                                    // XForms 1.1 says it is fine not to have a body, but in most cases you will want\n                                    // to know that no instance replacement took place\n                                    XFormsServer.logger.warn(\"XForms - submission - instance replacement did not take place upon successful response because no body was provided. Submission: \"\n                                            + getEffectiveId());\n                                }\n\n                                submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                            }\n                        } else if (connectionResult.statusCode == 302 || connectionResult.statusCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            connectionResult.forwardHeaders(response);\n\n                            // Forward redirect\n                            response.setStatus(connectionResult.statusCode);\n\n                        } else {\n                            // Error code received\n                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                            throw new XFormsSubmissionException(\"xforms:submission for submission id: \" + id + \", error code received when submitting instance: \" + connectionResult.statusCode, \"processing submission response\");\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (connectionResult != null) {\n                        connectionResult.close();\n                    }\n                    // Log time spent in submission if needed\n                    if (XFormsServer.logger.isDebugEnabled()) {\n                        final long submissionTime = System.currentTimeMillis() - externalSubmissionStartTime;\n                        containingDocument.logDebug(\"submission\", \"external submission time including handling returned body\",\n                            new String[] { \"time\", Long.toString(submissionTime) });\n                    }\n                }\n            } catch (Throwable e) {\n                if (isDeferredSubmissionSecondPassReplaceAll && XFormsProperties.isOptimizeLocalSubmission(containingDocument)) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new XFormsSubmissionException(e, \"Error while processing xforms:submission\", \"processing submission\");\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    if (submitErrorEvent == null)\n                        submitErrorEvent = new XFormsSubmitErrorEvent(XFormsModelSubmission.this, resolvedActionOrResource,\n                                (e instanceof XFormsSubmissionException)\n                                        ? ((XFormsSubmissionException) e).getErrorType()\n                                        : XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR, 0);\n                    \n                    submitErrorEvent.setThrowable(e);\n                    containingDocument.dispatchEvent(pipelineContext, submitErrorEvent);\n                }\n            } finally {\n                // If submission succeeded, dispatch success event\n                if (submitDoneEvent != null && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    containingDocument.dispatchEvent(pipelineContext, submitDoneEvent);\n                }\n                // Log total time spent in submission if needed\n                if (XFormsServer.logger.isDebugEnabled()) {\n                    final long submissionTime = System.currentTimeMillis() - submissionStartTime;\n                    containingDocument.logDebug(\"submission\", \"total submission time\",\n                        new String[] { \"time\", Long.toString(submissionTime) });\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new ValidationException(\"Binding exception for target: \" + event.getTargetObject().getEffectiveId(), event.getTargetObject().getLocationData());\n        }\n    }","id":86205,"modified_method":"public void performDefaultAction(PipelineContext pipelineContext, XFormsEvent event) {\n        final String eventName = event.getEventName();\n\n        if (XFormsEvents.XFORMS_SUBMIT.equals(eventName) || XFormsEvents.XXFORMS_SUBMIT.equals(eventName)) {\n            // 11.1 The xforms-submit Event\n            // Bubbles: Yes / Cancelable: Yes / Context Info: None\n\n            containingDocument.setGotSubmission();\n\n            boolean isDeferredSubmissionSecondPassReplaceAll = false;\n            XFormsSubmitErrorEvent submitErrorEvent = null;\n            XFormsSubmitDoneEvent submitDoneEvent = null;\n            final long submissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n\n            // Make sure submission element info is extracted\n            extractSubmissionElement();\n\n            // XPath function library and namespace mappings\n            final FunctionLibrary functionLibrary = XFormsContainingDocument.getFunctionLibrary();\n            final Map prefixToURIMap = containingDocument.getStaticState().getNamespaceMappings(getEffectiveId());\n\n            try {\n                final boolean isReplaceAll = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_ALL);\n                final boolean isReplaceInstance = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_INSTANCE);\n                final boolean isReplaceText = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_TEXT);\n                final boolean isReplaceNone = replace.equals(XFormsConstants.XFORMS_SUBMIT_REPLACE_NONE);\n\n                // Get current node for xforms:submission and instance containing the node to submit\n                final NodeInfo currentNodeInfo;\n                final XFormsInstance currentInstance;\n                // Create context (should we simply reuse that of the model?)\n                final XFormsContextStack contextStack = new XFormsContextStack(model);\n                final XFormsFunction.Context functionContext;\n                {\n                    contextStack.setBinding(pipelineContext, XFormsModelSubmission.this);\n\n                    currentNodeInfo = contextStack.getCurrentSingleNode();\n                    functionContext = contextStack.getFunctionContext();\n\n                    // Check that we have a current node and that it is pointing to a document or an element\n                    if (currentNodeInfo == null)\n                        throw new XFormsSubmissionException(\"Empty single-node binding on xforms:submission for submission id: \" + id, \"getting submission single-node binding\",\n                        \t\t XFormsSubmitErrorEvent.ErrorType.NO_DATA);\n\n                    if (!(currentNodeInfo instanceof DocumentInfo || currentNodeInfo.getNodeKind() == org.w3c.dom.Document.ELEMENT_NODE)) {\n                        throw new XFormsSubmissionException(\"xforms:submission: single-node binding must refer to a document node or an element.\", \"getting submission single-node binding\",\n                        \t\tXFormsSubmitErrorEvent.ErrorType.NO_DATA);\n                    }\n\n                    // Current instance may be null if the document submitted is not part of an instance\n                    currentInstance = contextStack.getCurrentInstance();\n                }\n\n                // Determine if the instance to submit has one or more bound and relevant upload controls\n                //\n                // o we don't check if we are currently initializing the document because at that point the\n                //   client cannot have any files to upload yet\n                //\n                // o we don't check if we have already processed the second pass of a submission during this\n                //   request, because it means that upload controls have been already committed\n                //\n                // o we don't check if we are requested not to with an attribute\n                //\n                // o we only check for replace=\"instance|none\" and if serialization must take place\n\n                boolean hasBoundRelevantUploadControl = false;\n                if (currentInstance!= null && !containingDocument.isInitializing() && !containingDocument.isGotSubmissionSecondPass() && xxfFormsEnsureUploads && !isReplaceAll && serialize) {\n                    final XFormsControls xformsControls = containingDocument.getXFormsControls();\n                    final List uploadControls = xformsControls.getCurrentControlsState().getUploadControls();\n                    if (uploadControls != null) {\n                        for (Iterator i = uploadControls.iterator(); i.hasNext();) {\n                            final XFormsUploadControl currentControl = (XFormsUploadControl) i.next();\n                            if (currentControl.isRelevant()) {\n                                final NodeInfo boundNodeInfo = currentControl.getBoundNode();\n                                if (currentInstance == currentInstance.getModel(containingDocument).getInstanceForNode(boundNodeInfo)) {\n                                    // Found one relevant upload control bound to the instance we are submitting\n                                    hasBoundRelevantUploadControl = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Evaluate early AVTs\n                {\n                    final String resolvedMethodQName = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtMethod);\n                    resolvedMethod = Dom4jUtils.qNameToexplodedQName(Dom4jUtils.extractTextValueQName(prefixToURIMap, resolvedMethodQName));\n                }\n\n                final boolean isHandlingOptimizedGet = XFormsProperties.isOptimizeGetAllSubmission(containingDocument) && XFormsSubmissionUtils.isGet(resolvedMethod)\n                        && isReplaceAll\n                        && avtXXFormsUsername == null; // can't optimize if there are authentication credentials\n\n                final boolean isDeferredSubmission = (isReplaceAll && !isHandlingOptimizedGet) || (!isReplaceAll && serialize && hasBoundRelevantUploadControl);\n                final boolean isDeferredSubmissionFirstPass = isDeferredSubmission && XFormsEvents.XFORMS_SUBMIT.equals(eventName);\n                final boolean isDeferredSubmissionSecondPass = isDeferredSubmission && !isDeferredSubmissionFirstPass; // here we get XXFORMS_SUBMIT\n                isDeferredSubmissionSecondPassReplaceAll = isDeferredSubmissionSecondPass && isReplaceAll;\n\n                if (isDeferredSubmissionSecondPass)\n                    containingDocument.setGotSubmissionSecondPass();\n\n                // If a submission requiring a second pass was already set, then we ignore a subsequent submission but\n                // issue a warning\n                {\n                    final XFormsModelSubmission existingSubmission = containingDocument.getClientActiveSubmission();\n                    if (isDeferredSubmission && existingSubmission != null) {\n                        logger.warn(\"XForms - submission - another submission requiring a second pass already exists (\" + existingSubmission.getEffectiveId() + \"). Ignoring new submission (\" + this.getEffectiveId() + \").\");\n                        return;\n                    }\n                }\n\n                // \"The data model is updated\"\n                final XFormsModel modelForInstance;\n                if (currentInstance != null) {\n                    modelForInstance = currentInstance.getModel(containingDocument);\n                    {\n                        // NOTE: XForms 1.1 seems to say this should happen regardless of whether we serialize or not. If\n                        // the instance is not serialized and if no instance data is otherwise used for the submission,\n                        // this seems however unneeded.\n\n                        // TODO: XForms 1.1 says that we should rebuild/recalculate the \"model containing this submission\".\n\n                        final XFormsModel.DeferredActionContext deferredActionContext = modelForInstance.getDeferredActionContext();\n                        if (deferredActionContext != null) {\n                            if (deferredActionContext.rebuild) {\n                                modelForInstance.doRebuild(pipelineContext);\n                            }\n                            if (deferredActionContext.recalculate) {\n                                modelForInstance.doRecalculate(pipelineContext);\n                            }\n                        }\n                    }\n                } else {\n                    // Case where no instance was found\n                    modelForInstance = null;\n                }\n\n                final Document initialDocumentToSubmit;\n                if (serialize && !isDeferredSubmissionSecondPass) {\n                    initialDocumentToSubmit = createDocumentToSubmit(pipelineContext, currentNodeInfo, currentInstance, modelForInstance);\n                } else {\n                    initialDocumentToSubmit = null;\n                }\n\n                // Deferred submission: end of the first pass\n                if (isDeferredSubmissionFirstPass) {\n\n                    // Resolve the target AVT if needed\n                    resolvedXXFormsTarget = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsTarget);\n\n                    // When replace=\"all\", we wait for the submission of an XXFormsSubmissionEvent from the client\n                    containingDocument.setClientActiveSubmission(this);\n                    return;\n                }\n\n                // Evaluate late AVTs\n                {\n                    final String tempActionOrResource = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtActionOrResource);\n                    resolvedActionOrResource = XFormsUtils.encodeHRRI(tempActionOrResource, true);\n\n                    resolvedXXFormsUsername = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsUsername);\n                    resolvedXXFormsPassword = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsPassword);\n                    resolvedXXFormsReadonly = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsReadonly);\n                    resolvedXXFormsShared = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsShared);\n\n                    // Default is \"false\" for security reasons\n                    final String tempHandleXInclude = XFormsUtils.resolveAttributeValueTemplates(pipelineContext, currentNodeInfo, contextStack.getCurrentVariables(), functionLibrary, functionContext, prefixToURIMap, getLocationData(), avtXXFormsHandleXInclude);\n                    resolvedXXFormsHandleXInclude = \"true\".equals(tempHandleXInclude);\n                }\n\n                // Check read-only and shared hints\n                XFormsInstance.checkSharedHints(submissionElement, resolvedXXFormsReadonly, resolvedXXFormsShared);\n                final boolean isReadonlyHint = \"true\".equals(resolvedXXFormsReadonly);\n                final boolean isApplicationSharedHint = \"application\".equals(resolvedXXFormsShared);\n                final long timeToLive = XFormsInstance.getTimeToLive(submissionElement);\n                if (isApplicationSharedHint) {\n                    if (!XFormsSubmissionUtils.isGet(resolvedMethod))\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with method=\\\"get\\\".\",\n                                \"checking read-only and shared hints\");\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:shared=\\\"application\\\" can be set only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                } else if (isReadonlyHint) {\n                    if (!isReplaceInstance)\n                        throw new XFormsSubmissionException(\"xforms:submission: xxforms:readonly=\\\"true\\\" can be \\\"true\\\" only with replace=\\\"instance\\\".\",\n                                \"checking read-only and shared hints\");\n                }\n\n                final Document documentToSubmit;\n                if (serialize && isDeferredSubmissionSecondPass) {\n                    // Handle uploaded files if any\n                    final Element filesElement = (event instanceof XXFormsSubmitEvent) ? ((XXFormsSubmitEvent) event).getFilesElement() : null;\n                    if (filesElement != null) {\n                        for (Iterator i = filesElement.elements().iterator(); i.hasNext();) {\n                            final Element parameterElement = (Element) i.next();\n                            final String name = parameterElement.element(\"name\").getTextTrim();\n\n                            final XFormsUploadControl uploadControl\n                                        = (XFormsUploadControl) containingDocument.getObjectById(name);\n\n                            // In case of xforms:repeat, the name of the template will not match an existing control\n                            if (uploadControl == null)\n                                continue;\n\n                            final Element valueElement = parameterElement.element(\"value\");\n                            final String value = valueElement.getTextTrim();\n\n                            final String filename;\n                            {\n                                final Element filenameElement = parameterElement.element(\"filename\");\n                                filename = (filenameElement != null) ? filenameElement.getTextTrim() : \"\";\n                            }\n                            final String mediatype;\n                            {\n                                final Element mediatypeElement = parameterElement.element(\"content-type\");\n                                mediatype = (mediatypeElement != null) ? mediatypeElement.getTextTrim() : \"\";\n                            }\n                            final String size = parameterElement.element(\"content-length\").getTextTrim();\n\n                            if (size.equals(\"0\") && filename.equals(\"\")) {\n                                // No file was selected in the UI\n                            } else {\n                                // A file was selected in the UI (note that the file may be empty)\n                                final String paramValueType = Dom4jUtils.qNameToexplodedQName(Dom4jUtils.extractAttributeValueQName(valueElement, XMLConstants.XSI_TYPE_QNAME));\n\n                                // Set value of uploaded file into the instance (will be xs:anyURI or xs:base64Binary)\n                                uploadControl.setExternalValue(pipelineContext, value, paramValueType, !isReplaceAll);\n\n                                // Handle filename, mediatype and size if necessary\n                                uploadControl.setFilename(pipelineContext, filename);\n                                uploadControl.setMediatype(pipelineContext, mediatype);\n                                uploadControl.setSize(pipelineContext, size);\n                            }\n                        }\n                    }\n\n                    // Create document to submit\n                    documentToSubmit = createDocumentToSubmit(pipelineContext, currentNodeInfo, currentInstance, modelForInstance);\n\n                } else {\n                    // Don't recreate document\n                    documentToSubmit = initialDocumentToSubmit;\n                }\n\n                final String overriddenSerializedData;\n                if (serialize && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    // Fire xforms-submit-serialize\n\n                    // \"The event xforms-submit-serialize is dispatched. If the submission-body property of the event\n                    // is changed from the initial value of empty string, then the content of the submission-body\n                    // property string is used as the submission serialization. Otherwise, the submission serialization\n                    // consists of a serialization of the selected instance data according to the rules stated at 11.9\n                    // Submission Options.\"\n\n                    final XFormsSubmitSerializeEvent serializeEvent = new XFormsSubmitSerializeEvent(XFormsModelSubmission.this);\n                    containingDocument.dispatchEvent(pipelineContext, serializeEvent);\n\n                    // TODO: rest of submission should happen upon default action of event\n\n                    overriddenSerializedData = serializeEvent.getSerializedData();\n                } else {\n                    overriddenSerializedData = null;\n                }\n\n                // Serialize\n                // To support: application/xml, application/x-www-form-urlencoded, multipart/related, multipart/form-data\n                final byte[] messageBody;\n                final String queryString;\n                final String defaultMediatypeForSerialization;\n                {\n                    if (overriddenSerializedData != null && !overriddenSerializedData.equals(\"\")) {\n                        // Form author set data to serialize\n\n                        // TODO: more work to do here, or integrate below in different methods?\n                        if (serialization == null)\n                            serialization = \"application/xml\";\n\n                        queryString = null;\n                        messageBody = overriddenSerializedData.getBytes(\"UTF-8\");\n                        defaultMediatypeForSerialization = \"application/xml\";\n\n                    } else if (resolvedMethod.equals(\"multipart-post\")) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"multipart/related\";\n\n                        // TODO\n                        throw new XFormsSubmissionException(\"xforms:submission: submission method not yet implemented: \" + resolvedMethod, \"serializing instance\");\n                    } else if (resolvedMethod.equals(\"form-data-post\")) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"multipart/form-data\";\n\n                        // TODO\n\n//                        final MultipartFormDataBuilder builder = new MultipartFormDataBuilder(, , null);\n\n                        throw new XFormsSubmissionException(\"xforms:submission: submission method not yet implemented: \" + resolvedMethod, \"serializing instance\");\n                    } else if (resolvedMethod.equals(\"urlencoded-post\")) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"application/x-www-form-urlencoded\";\n\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        queryString = null;\n                        messageBody = serialize ? createWwwFormUrlEncoded(documentToSubmit).getBytes(\"UTF-8\") : null;// the resulting string is already ASCII\n                        defaultMediatypeForSerialization = \"application/x-www-form-urlencoded\";\n\n                    } else if (XFormsSubmissionUtils.isPost(resolvedMethod) || XFormsSubmissionUtils.isPut(resolvedMethod)) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"application/xml\";\n\n                        if (serialize) {\n\n                            if (XMLUtils.isXMLMediatype(serialization)) {\n                                // XML serialization\n\n                                // Serialize XML to a stream of bytes\n                                try {\n                                    final Transformer identity = TransformerUtils.getIdentityTransformer();\n                                    TransformerUtils.applyOutputProperties(identity,\n                                            \"xml\", version, null, null, encoding, omitxmldeclaration, standalone, indent, 4);\n\n                                    // TODO: use cdata-section-elements\n\n                                    final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                                    identity.transform(new DocumentSource(documentToSubmit), new StreamResult(os));\n                                    messageBody = os.toByteArray();\n                                } catch (Exception e) {\n                                    throw new XFormsSubmissionException(e, \"xforms:submission: exception while serializing instance to XML.\", \"serializing instance\");\n                                }\n                                defaultMediatypeForSerialization = \"application/xml\";\n                            } else if (XMLUtils.isTextContentType(serialization)) {\n                                // Text serialization\n                                // TODO\n                                throw new XFormsSubmissionException(\"xforms:submission: text serialization is not yet implemented.\", \"serializing instance\");\n                            } else {\n                                // Binary serialization\n\n                                final String nodeType = InstanceData.getType(documentToSubmit.getRootElement());\n\n                                if (XMLConstants.XS_ANYURI_EXPLODED_QNAME.equals(nodeType)) {\n                                    // Interpret node as anyURI\n                                    // TODO: PERFORMANCE: Must pass InputStream all the way to the submission instead of storing into byte[] in memory!\n                                    final String uri = documentToSubmit.getRootElement().getStringValue();\n                                    messageBody = NetUtils.uriToByteArray(uri);\n                                } else if (XMLConstants.XS_BASE64BINARY_EXPLODED_QNAME.equals(nodeType)) {\n                                    // TODO\n                                    throw new XFormsSubmissionException(\"xforms:submission: binary serialization with base64Binary type is not yet implemented.\", \"serializing instance\");\n                                } else {\n                                    // TODO\n                                    throw new XFormsSubmissionException(\"xforms:submission: binary serialization without a type is not yet implemented.\", \"serializing instance\");\n                                }\n                                defaultMediatypeForSerialization = \"application/octet-stream\";\n                            }\n                        } else {\n                            messageBody = null;\n                            defaultMediatypeForSerialization = null;\n                        }\n                        queryString = null;\n\n                    } else if (XFormsSubmissionUtils.isGet(resolvedMethod) || XFormsSubmissionUtils.isDelete(resolvedMethod)) {\n\n                        // Set default serialization based on method\n                        if (serialization == null)\n                            serialization = \"application/x-www-form-urlencoded\";\n\n                        // Perform \"application/x-www-form-urlencoded\" serialization\n                        queryString = serialize ? createWwwFormUrlEncoded(documentToSubmit) : null;\n                        messageBody = null;\n                        defaultMediatypeForSerialization = null;\n\n                    } else {\n                        throw new XFormsSubmissionException(\"xforms:submission: invalid submission method requested: \" + resolvedMethod, \"serializing instance\");\n                    }\n                }\n\n                final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n                // Get URL type\n                final String urlType = submissionElement.attributeValue(XMLConstants.FORMATTING_URL_TYPE_QNAME);\n                final ExternalContext.Request request = externalContext.getRequest();\n\n                // Find instance to update\n                final XFormsInstance replaceInstance;\n                if (isReplaceInstance) {\n                    if (xxfReplaceInstanceId != null)\n                        replaceInstance = containingDocument.findInstance(xxfReplaceInstanceId);\n                    else if (replaceInstanceId != null)\n                        replaceInstance = model.getInstance(replaceInstanceId);\n                    else if (currentInstance == null)\n                        replaceInstance = model.getDefaultInstance();\n                    else\n                        replaceInstance = currentInstance;\n                } else {\n                    replaceInstance = null;\n                }\n\n                // Result information\n                ConnectionResult connectionResult = null;\n                final long externalSubmissionStartTime = XFormsServer.logger.isDebugEnabled() ? System.currentTimeMillis() : 0;\n                try {\n                    if ((isReplaceInstance || isReplaceNone) && resolvedActionOrResource.startsWith(\"test:\")) {\n                        // Test action\n\n                        if (messageBody == null)\n                            throw new XFormsSubmissionException(\"Action 'test:': no message body.\", \"processing submission response\");\n\n                        connectionResult = new ConnectionResult(null);\n                        connectionResult.statusCode = 200;\n                        connectionResult.responseHeaders = new HashMap();\n                        connectionResult.lastModified = 0;\n                        connectionResult.responseMediaType = \"application/xml\";\n                        connectionResult.dontHandleResponse = false;\n                        connectionResult.setResponseInputStream(new ByteArrayInputStream(messageBody));\n\n                    } else if (isHandlingOptimizedGet) {\n                        // GET with replace=\"all\": we can optimize and tell the client to just load the URL\n\n                        final String actionString = (queryString == null) ? resolvedActionOrResource : resolvedActionOrResource + ((resolvedActionOrResource.indexOf('?') == -1) ? \"?\" : \"\") + queryString;\n                        final String resultURL = XFormsLoadAction.resolveLoadValue(containingDocument, pipelineContext, submissionElement, true, actionString, null, null, fURLNorewrite, xxfShowProgress);\n                        connectionResult = new ConnectionResult(resultURL);\n                        connectionResult.dontHandleResponse = true;\n\n                    } else if (!NetUtils.urlHasProtocol(resolvedActionOrResource)\n                               && !fURLNorewrite\n                               && headerNames == null\n                               && ((request.getContainerType().equals(\"portlet\") && !\"resource\".equals(urlType))\n                                    || (request.getContainerType().equals(\"servlet\")\n                                        && (XFormsProperties.isOptimizeLocalSubmission(containingDocument) || isMethodOptimizedLocalSubmission())\n                                        &&  isReplaceAll))) {\n\n                        // This is an \"optimized\" submission, i.e. one that does not use an actual\n                        // protocol handler to access the resource\n\n                        // NOTE: Optimizing with include() for servlets doesn't allow detecting\n                        // errors caused by the included resource, so we don't allow this for now.\n\n                        // NOTE: For portlets, paths are served directly by the portlet, NOT as\n                        // resources.\n\n                        // Current limitations:\n                        // o Portlets cannot access resources outside the portlet except by using absolute URLs (unless f:url-type=\"resource\")\n                        // o Servlets cannot access resources on the same server but not in the current application\n                        //   except by using absolute URLs\n\n                        final URI resolvedURI = XFormsUtils.resolveXMLBase(submissionElement, resolvedActionOrResource);\n\n                        // NOTE: We don't want any changes to happen to the document upon xxforms-submit when producing\n                        // a new document so we don't dispatch xforms-submit-done and pass a null XFormsModelSubmission\n                        // in that case\n                        connectionResult = XFormsSubmissionUtils.doOptimized(pipelineContext, externalContext,\n                                isDeferredSubmissionSecondPassReplaceAll ? null : this, resolvedMethod, resolvedURI.toString(), (mediatype == null) ? defaultMediatypeForSerialization : mediatype, isReplaceAll,\n                                messageBody, queryString);\n\n                    } else {\n                        // This is a regular remote submission going through a protocol handler\n\n                        // Absolute URLs or absolute paths are allowed to a local servlet\n                        String resolvedURL;\n\n                        if (NetUtils.urlHasProtocol(resolvedActionOrResource) || fURLNorewrite) {\n                            // Don't touch the URL if it is absolute or if f:url-norewrite=\"true\"\n                            resolvedURL = resolvedActionOrResource;\n                        } else {\n                            // Rewrite URL\n                            resolvedURL = XFormsUtils.resolveResourceURL(pipelineContext, submissionElement, resolvedActionOrResource, false);\n\n                            if (request.getContainerType().equals(\"portlet\") && \"resource\".equals(urlType) && !NetUtils.urlHasProtocol(resolvedURL)) {\n                                // In this case, we have to prepend the complete server path\n                                resolvedURL = request.getScheme() + \"://\" + request.getServerName() + (request.getServerPort() > 0 ? \":\" + request.getServerPort() : \"\") + resolvedURL;\n                            }\n                        }\n\n                        if (isApplicationSharedHint) {\n                            // Get the instance from shared instance cache\n                            // This can only happen is method=\"get\" and replace=\"instance\" and xxforms:readonly=\"true\" and xxforms:shared=\"application\"\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"using instance from application shared instance cache\",\n                                        new String[] { \"instance\", replaceInstance.getEffectiveId() });\n\n                            final URL absoluteResolvedURL = XFormsSubmissionUtils.createAbsoluteURL(resolvedURL, queryString, externalContext);\n                            final String absoluteResolvedURLString = absoluteResolvedURL.toExternalForm();\n\n                            final SharedXFormsInstance sharedInstance\n                                    = XFormsServerSharedInstancesCache.instance().find(pipelineContext, containingDocument, replaceInstance.getEffectiveId(), replaceInstance.getModelId(), absoluteResolvedURLString, timeToLive, replaceInstance.getValidation());\n\n                            if (XFormsServer.logger.isDebugEnabled())\n                                containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                        new String[] { \"instance\", sharedInstance.getEffectiveId() });\n\n                            // Handle new instance and associated events\n                            final XFormsModel replaceModel = sharedInstance.getModel(containingDocument);\n                            replaceModel.handleNewInstanceDocuments(pipelineContext, sharedInstance);\n\n                            connectionResult = null;\n                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, absoluteResolvedURLString, 200);\n                        } else {\n                            // Perform actual submission\n                            connectionResult = XFormsSubmissionUtils.doRegular(externalContext, containingDocument,\n                                    resolvedMethod, resolvedURL, resolvedXXFormsUsername, resolvedXXFormsPassword, (mediatype == null) ? defaultMediatypeForSerialization : mediatype,\n                                    messageBody, queryString, headerNames, headerNameValues);\n                        }\n                    }\n\n                    if (connectionResult != null && !connectionResult.dontHandleResponse) {\n                        // Handle response\n                        if (connectionResult.statusCode >= 200 && connectionResult.statusCode < 300) {// accept any success code (in particular \"201 Resource Created\")\n                            // Sucessful response\n                            if (connectionResult.hasContent()) {\n                                // There is a body\n\n                                if (isReplaceAll) {\n                                    // When we get here, we are in a mode where we need to send the reply\n                                    // directly to an external context, if any.\n\n                                    // \"the event xforms-submit-done is dispatched\"\n                                    if (!isDeferredSubmissionSecondPassReplaceAll) // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                                        containingDocument.dispatchEvent(pipelineContext, new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult));\n\n                                    final ExternalContext.Response response = externalContext.getResponse();\n\n                                    // Forward headers to response\n                                    connectionResult.forwardHeaders(response);\n\n                                    // Forward content to response\n                                    NetUtils.copyStream(connectionResult.getResponseInputStream(), response.getOutputStream());\n\n                                    // TODO: [#306918] RFE: Must be able to do replace=\"all\" during initialization.\n                                    // http://forge.objectweb.org/tracker/index.php?func=detail&aid=306918&group_id=168&atid=350207\n                                    // Suggestion is to write either binary or XML to processor output ContentHandler,\n                                    // and make sure the code which would output the XHTML+XForms is disabled.\n\n                                } else if (isReplaceInstance) {\n\n                                    if (XMLUtils.isXMLMediatype(connectionResult.responseMediaType)) {\n                                        // Handling of XML media type\n                                        // Set new instance document to replace the one submitted\n\n                                        if (replaceInstance == null) {\n                                            // Replacement instance was specified but not found TODO: XForms 1.1 won't\n                                            // dispatch xforms-binding-exception here Not sure what's the right thing to\n                                            // do with 1.1, but this could be done as part of the model's static\n                                            // analysis if the instance value is not obtained through AVT, and\n                                            // dynamically otherwise. However, in the dynamic case, I think that this\n                                            // should be a (currently non-specified by XForms) xforms-binding-error.\n                                            containingDocument.dispatchEvent(pipelineContext, new XFormsBindingExceptionEvent(XFormsModelSubmission.this));\n                                        } else {\n                                            final XFormsInstance newInstance;\n                                            try {\n                                                // Read stream into Document\n                                                if (!isReadonlyHint) {\n                                                    // Resulting instance is not read-only\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with mutable instance\",\n                                                            new String[] { \"instance\", replaceInstance.getEffectiveId() });\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    final Document resultingInstanceDocument\n                                                            = TransformerUtils.readDom4j(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n                                                    newInstance = new XFormsInstance(replaceInstance.getModelId(), replaceInstance.getEffectiveId(), resultingInstanceDocument,\n                                                            connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword, false, -1, replaceInstance.getValidation());\n                                                } else {\n                                                    // Resulting instance is read-only\n\n                                                    if (XFormsServer.logger.isDebugEnabled())\n                                                        containingDocument.logDebug(\"submission\", \"replacing instance with read-only instance\",\n                                                            new String[] { \"instance\", replaceInstance.getEffectiveId() });\n\n                                                    // TODO: What about configuring validation? And what default to choose?\n                                                    // NOTE: isApplicationSharedHint is always false when get get here. isApplicationSharedHint=\"true\" is handled above.\n                                                    final DocumentInfo resultingInstanceDocument = TransformerUtils.readTinyTree(connectionResult.getResponseInputStream(), connectionResult.resourceURI, resolvedXXFormsHandleXInclude);\n                                                    newInstance = new SharedXFormsInstance(replaceInstance.getModelId(), replaceInstance.getEffectiveId(), resultingInstanceDocument,\n                                                            connectionResult.resourceURI, resolvedXXFormsUsername, resolvedXXFormsPassword, false, -1, replaceInstance.getValidation());\n                                                }    \n                                            } catch (Exception e) {\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.PARSE_ERROR);\n                                                throw new XFormsSubmissionException(e, \"xforms:submission: exception while serializing XML to instance.\", \"processing instance replacement\");\n                                            }\n\n                                            // Handle new instance and associated events\n                                            final XFormsModel replaceModel = newInstance.getModel(containingDocument);\n                                            replaceModel.handleNewInstanceDocuments(pipelineContext, newInstance);\n\n                                            // Notify that submission is done\n                                            submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                        }\n                                    } else {\n                                        // Other media type\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Body received with non-XML media type for replace=\\\"instance\\\": \" + connectionResult.responseMediaType, \"processing instance replacement\");\n                                    }\n                                } else if (isReplaceText) {\n\n                                    // XForms 1.1: \"If the replace attribute contains the value \"text\" and the\n                                    // submission response conforms to an XML mediatype (as defined by the content type\n                                    // specifiers in [RFC 3023]) or a text media type (as defined by a content type\n                                    // specifier of text/*), then the response data is encoded as text and replaces the\n                                    // content of the replacement target node.\"\n\n                                    // Get response body\n                                    String responseBody = \"\";\n                                    if (XMLUtils.isTextContentType(connectionResult.responseMediaType)) {\n                                        // Text mediatype (including text/xml), read stream into String\n                                        try {\n                                            final String charset = NetUtils.getTextCharsetFromContentType(connectionResult.responseMediaType);\n                                            final Reader reader = new InputStreamReader(connectionResult.responseInputStream, charset);\n                                            try {\n                                                responseBody = NetUtils.readStreamAsString(reader);\n                                            } finally {\n                                                try {\n                                                    reader.close();\n                                                } catch (Exception e) {\n                                                }\n                                            }\n                                        } catch (Exception e) {\n                                            XFormsServer.logger.error(\"XForms - submission - error while reading response body \", e);\n                                        }\n                                    } else if (XMLUtils.isXMLMediatype(connectionResult.responseMediaType)) {\n                                        // XML mediatype other than text/xml\n\n                                        // TODO: What should we do if the response Content-Type includes a charset parameter?\n                                        final Reader reader = XMLUtils.getReaderFromXMLInputStream(connectionResult.resourceURI, connectionResult.responseInputStream);\n                                        try {\n                                            responseBody = NetUtils.readStreamAsString(reader);\n                                        } finally {\n                                            try {\n                                                reader.close();\n                                            } catch (Exception e) {\n                                            }\n                                        }\n                                    } else {\n                                        // This is a binary result\n\n                                        // Don't store anything for now as per the spec, but we could do something better by going beyond the spec\n                                        // NetUtils.inputStreamToAnyURI(pipelineContext, connectionResult.resultInputStream, NetUtils.SESSION_SCOPE);\n\n                                        // XForms 1.1: \"For a success response including a body that is both a non-XML\n                                        // media type (i.e. with a content type not matching any of the specifiers in\n                                        // [RFC 3023]) and a non-text type (i.e. with a content type not matching\n                                        // text/*), when the value of the replace attribute on element submission is\n                                        // \"text\", nothing in the document is replaced and submission processing\n                                        // concludes after dispatching xforms-submit-error with appropriate context\n                                        // information, including an error-type of resource-error.\"\n                                        submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                                        throw new XFormsSubmissionException(\"Mediatype is neither text nor XML for replace=\\\"text\\\": \" + connectionResult.responseMediaType, \"reading response body\");\n                                    }\n\n                                    // Find target location\n                                    final NodeInfo destinationNodeInfo;\n                                    if (target != null) {\n                                        // Evaluate destination node\n                                        final Object destinationObject\n                                                = XPathCache.evaluateSingle(pipelineContext, currentNodeInfo, target, prefixToURIMap,\n                                                contextStack.getCurrentVariables(), functionLibrary, functionContext, null, getLocationData());\n\n                                        if (destinationObject instanceof NodeInfo) {\n                                            destinationNodeInfo = (NodeInfo) destinationObject;\n                                            if (destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ELEMENT_NODE && destinationNodeInfo.getNodeKind() != org.w3c.dom.Document.ATTRIBUTE_NODE) {\n                                                // Throw target-error\n\n                                                // XForms 1.1: \"If the processing of the target attribute fails, then\n                                                // submission processing ends after dispatching the event\n                                                // xforms-submit-error with an error-type of target-error.\"\n                                                submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                                throw new XFormsSubmissionException(\"target attribute doesn't point to an element or attribute for replace=\\\"text\\\".\", \"processing target attribute\");\n                                            }\n                                        } else {\n                                            // Throw target-error\n\n                                            // XForms 1.1: \"If the processing of the target attribute fails, then\n                                            // submission processing ends after dispatching the event\n                                            // xforms-submit-error with an error-type of target-error.\"\n                                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.TARGET_ERROR);\n                                            throw new XFormsSubmissionException(\"target attribute doesn't point to a node for replace=\\\"text\\\".\", \"processing target attribute\");\n                                        }\n                                    } else {\n                                        // Handle default destination\n                                        destinationNodeInfo = replaceInstance.getInstanceRootElementInfo();\n                                    }\n\n                                    // Set value into the instance\n                                    XFormsSetvalueAction.doSetValue(pipelineContext, containingDocument, this, destinationNodeInfo, responseBody, null, false);\n\n                                    // Notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n\n                                } else if (isReplaceNone) {\n                                    // Just notify that processing is terminated\n                                    submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                                } else {\n                                    submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR);\n                                    throw new XFormsSubmissionException(\"xforms:submission: invalid replace attribute: \" + replace, \"processing instance replacement\");\n                                }\n\n                            } else {\n                                // There is no body, notify that processing is terminated\n\n                                if (isReplaceInstance) {\n                                    // XForms 1.1 says it is fine not to have a body, but in most cases you will want\n                                    // to know that no instance replacement took place\n                                    XFormsServer.logger.warn(\"XForms - submission - instance replacement did not take place upon successful response because no body was provided. Submission: \"\n                                            + getEffectiveId());\n                                }\n\n                                submitDoneEvent = new XFormsSubmitDoneEvent(XFormsModelSubmission.this, connectionResult);\n                            }\n                        } else if (connectionResult.statusCode == 302 || connectionResult.statusCode == 301) {\n                            // Got a redirect\n\n                            final ExternalContext.Response response = externalContext.getResponse();\n\n                            // Forward headers to response\n                            connectionResult.forwardHeaders(response);\n\n                            // Forward redirect\n                            response.setStatus(connectionResult.statusCode);\n\n                        } else {\n                            // Error code received\n                            submitErrorEvent = createErrorEvent(pipelineContext, connectionResult, XFormsSubmitErrorEvent.ErrorType.RESOURCE_ERROR);\n                            throw new XFormsSubmissionException(\"xforms:submission for submission id: \" + id + \", error code received when submitting instance: \" + connectionResult.statusCode, \"processing submission response\");\n                        }\n                    }\n                } finally {\n                    // Clean-up\n                    if (connectionResult != null) {\n                        connectionResult.close();\n                    }\n                    // Log time spent in submission if needed\n                    if (XFormsServer.logger.isDebugEnabled()) {\n                        final long submissionTime = System.currentTimeMillis() - externalSubmissionStartTime;\n                        containingDocument.logDebug(\"submission\", \"external submission time including handling returned body\",\n                            new String[] { \"time\", Long.toString(submissionTime) });\n                    }\n                }\n            } catch (Throwable e) {\n                if (isDeferredSubmissionSecondPassReplaceAll && XFormsProperties.isOptimizeLocalSubmission(containingDocument)) {\n                    // It doesn't serve any purpose here to dispatch an event, so we just propagate the exception\n                    throw new XFormsSubmissionException(e, \"Error while processing xforms:submission\", \"processing submission\");\n                } else {\n                    // Any exception will cause an error event to be dispatched\n                    if (submitErrorEvent == null)\n                        submitErrorEvent = new XFormsSubmitErrorEvent(XFormsModelSubmission.this, resolvedActionOrResource,\n                                (e instanceof XFormsSubmissionException)\n                                        ? ((XFormsSubmissionException) e).getErrorType()\n                                        : XFormsSubmitErrorEvent.ErrorType.XXFORMS_INTERNAL_ERROR, 0);\n                    \n                    submitErrorEvent.setThrowable(e);\n                    containingDocument.dispatchEvent(pipelineContext, submitErrorEvent);\n                }\n            } finally {\n                // If submission succeeded, dispatch success event\n                if (submitDoneEvent != null && !isDeferredSubmissionSecondPassReplaceAll) { // we don't want any changes to happen to the document upon xxforms-submit when producing a new document\n                    containingDocument.dispatchEvent(pipelineContext, submitDoneEvent);\n                }\n                // Log total time spent in submission if needed\n                if (XFormsServer.logger.isDebugEnabled()) {\n                    final long submissionTime = System.currentTimeMillis() - submissionStartTime;\n                    containingDocument.logDebug(\"submission\", \"total submission time\",\n                        new String[] { \"time\", Long.toString(submissionTime) });\n                }\n            }\n\n        } else if (XFormsEvents.XFORMS_BINDING_EXCEPTION.equals(eventName)) {\n            // The default action for this event results in the following: Fatal error.\n            throw new ValidationException(\"Binding exception for target: \" + event.getTargetObject().getEffectiveId(), event.getTargetObject().getLocationData());\n        }\n    }","commit_id":"e2f055e4212303d58f7e91a473df27c35fa90ef2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static boolean doSetValue(PipelineContext pipelineContext, XFormsContainingDocument containingDocument,\n                                     XFormsEventTarget eventTarget, NodeInfo currentNode,\n                                     String valueToSet, String type, boolean isCalculate) {\n        final String currentValue = XFormsInstance.getValueForNodeInfo(currentNode);\n        if (!currentValue.equals(valueToSet)) {// TODO: Check if we are allowed to do this optimization\n\n            if (XFormsServer.logger.isDebugEnabled()) {\n                final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n                containingDocument.logDebug(\"setvalue\", \"setting instance value\", new String[] { \"value\", valueToSet, \"instance\", modifiedInstance.getEffectiveId() });\n            }\n\n            XFormsInstance.setValueForNodeInfo(pipelineContext, containingDocument, eventTarget, currentNode, valueToSet, type);\n\n            if (!isCalculate) {\n                // When this is called from a calculate, we don't set the flags as revalidate and refresh will have been set already\n\n                final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n                final XFormsModel.DeferredActionContext deferredActionContext = modifiedInstance.getModel(containingDocument).getDeferredActionContext();\n\n                // \"XForms Actions that change only the value of an instance node results in setting the flags for\n                // recalculate, revalidate, and refresh to true and making no change to the flag for rebuild\".\n                if (deferredActionContext != null) {\n                    deferredActionContext.recalculate = true;\n                    deferredActionContext.revalidate = true;\n                    deferredActionContext.refresh = true;\n                }\n            }\n\n            containingDocument.getXFormsControls().markDirtySinceLastRequest();\n\n            return true;\n        } else {\n            return false;\n        }\n    }","id":86206,"modified_method":"public static boolean doSetValue(PipelineContext pipelineContext, XFormsContainingDocument containingDocument,\n                                     XFormsEventTarget eventTarget, NodeInfo currentNode,\n                                     String valueToSet, String type, boolean isCalculate) {\n        final String currentValue = XFormsInstance.getValueForNodeInfo(currentNode);\n        if (!currentValue.equals(valueToSet)) {// TODO: Check if we are allowed to do this optimization\n\n            if (XFormsServer.logger.isDebugEnabled()) {\n                final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n                containingDocument.logDebug(\"setvalue\", \"setting instance value\", new String[] { \"value\", valueToSet,\n                        \"instance\", (modifiedInstance != null) ? modifiedInstance.getEffectiveId() : \"N/A\" });\n            }\n\n            XFormsInstance.setValueForNodeInfo(pipelineContext, containingDocument, eventTarget, currentNode, valueToSet, type);\n\n            if (!isCalculate) {\n                // When this is called from a calculate, we don't set the flags as revalidate and refresh will have been set already\n\n                final XFormsInstance modifiedInstance = containingDocument.getInstanceForNode(currentNode);\n                if (modifiedInstance != null) {// can be null if you set a value in a non-instance doc\n                    final XFormsModel.DeferredActionContext deferredActionContext = modifiedInstance.getModel(containingDocument).getDeferredActionContext();\n\n                    // \"XForms Actions that change only the value of an instance node results in setting the flags for\n                    // recalculate, revalidate, and refresh to true and making no change to the flag for rebuild\".\n                    if (deferredActionContext != null) {\n                        deferredActionContext.recalculate = true;\n                        deferredActionContext.revalidate = true;\n                        deferredActionContext.refresh = true;\n                    }\n                }\n            }\n\n            containingDocument.getXFormsControls().markDirtySinceLastRequest();\n\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"e2f055e4212303d58f7e91a473df27c35fa90ef2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public synchronized boolean analyzeIfNecessary(final PipelineContext pipelineContext) {\n        if (!isAnalyzed) {\n            controlNamesMap = new HashMap();\n            eventNamesMap = new HashMap();\n            eventHandlersMap = new HashMap();\n            controlElementsMap = new HashMap();\n            defaultRepeatIdToIndex = new HashMap();\n            repeatChildrenMap = new HashMap();\n            repeatDescendantsMap = new HashMap();\n\n            final Configuration xpathConfiguration = new Configuration();\n            final DocumentWrapper controlsDocumentInfo = new DocumentWrapper(controlsDocument, null, xpathConfiguration);\n\n            // Iterate over static controls tree\n            final FastStringBuffer repeatHierarchyStringBuffer = new FastStringBuffer(1024);\n            visitAllControlStatic(new ControlElementVisitorListener() {\n\n                private Stack repeatAncestorsStack = new Stack();\n\n                public void startVisitControl(Element controlElement, String controlId) {\n\n                    // Gather control name\n                    final String controlName = controlElement.getName();\n                    controlNamesMap.put(controlName, \"\");\n\n                    final LocationData locationData = new ExtendedLocationData((LocationData) controlElement.getData(), \"gathering static control information\", controlElement);\n\n                    // Check for mandatory and optional bindings\n                    if (controlElement != null && XFormsConstants.XFORMS_NAMESPACE_URI.equals(controlElement.getNamespaceURI())) {\n                        if (XFormsControls.mandatorySingleNodeControls.get(controlName) != null\n                                && !(controlElement.attribute(\"ref\") != null || controlElement.attribute(\"bind\") != null)) {\n                            throw new ValidationException(\"Missing mandatory single node binding for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.noSingleNodeControls.get(controlName) != null\n                                && (controlElement.attribute(\"ref\") != null || controlElement.attribute(\"bind\") != null)) {\n                            throw new ValidationException(\"Single node binding is prohibited for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.mandatoryNodesetControls.get(controlName) != null\n                                && !(controlElement.attribute(\"nodeset\") != null || controlElement.attribute(\"bind\") != null)) {\n                            throw new ValidationException(\"Missing mandatory nodeset binding for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.noNodesetControls.get(controlName) != null\n                                && controlElement.attribute(\"nodeset\") != null) {\n                            throw new ValidationException(\"Node-set binding is prohibited for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.singleNodeOrValueControls.get(controlName) != null\n                                && !(controlElement.attribute(\"ref\") != null || controlElement.attribute(\"bind\") != null || controlElement.attribute(\"value\") != null)) {\n                            throw new ValidationException(\"Missing mandatory single node binding or value attribute for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                    }\n\n                    // Gather event handlers\n                    // Map<String, List<XFormsEventHandler>> of observer id to List of XFormsEventHandler\n                    final Map controlEventHandlersMap = XFormsEventHandlerImpl.extractEventHandlers(controlElement, eventNamesMap);\n                    mergeEventHandlers(eventHandlersMap, controlEventHandlersMap);\n\n                    // Gather static control\n                    controlElementsMap.put(controlId, controlElement);\n\n                    // Gather xforms:repeat information\n                    if (controlName.equals(\"repeat\")) {\n                        // Find initial indexes\n                        {\n                            // Create control without parent, just to hold iterations\n                            final XFormsRepeatControl repeatControl\n                                    = new XFormsRepeatControl(null, null, controlElement, controlElement.getName(), controlId);\n\n                            // Remember initial index\n                            defaultRepeatIdToIndex.put(repeatControl.getRepeatId(), new Integer(repeatControl.getStartIndex()));\n                        }\n                        // Find repeat parents\n                        {\n                            // Create repeat hierarchy string\n                            if (repeatHierarchyStringBuffer.length() > 0)\n                                repeatHierarchyStringBuffer.append(',');\n\n                            repeatHierarchyStringBuffer.append(controlId);\n\n                            if (repeatAncestorsStack.size() > 0) {\n                                // If we have a parent, append it\n                                final String parentRepeatId = (String) repeatAncestorsStack.peek();\n                                repeatHierarchyStringBuffer.append(' ');\n                                repeatHierarchyStringBuffer.append(parentRepeatId);\n                            }\n                        }\n                        // Find repeat children\n                        {\n                            if (repeatAncestorsStack.size() > 0) {\n                                // If we have a parent, tell the parent that it has a child\n                                final String parentRepeatId = (String) repeatAncestorsStack.peek();\n                                List parentRepeatList = (List) repeatChildrenMap.get(parentRepeatId);\n                                if (parentRepeatList == null) {\n                                    parentRepeatList = new ArrayList();\n                                    repeatChildrenMap.put(parentRepeatId, parentRepeatList);\n                                }\n                                parentRepeatList.add(controlId);\n                            }\n\n                        }\n\n                        repeatAncestorsStack.push(controlId);\n                    }\n\n                    // Gather itemset information\n                    if (controlName.equals(\"select\") || controlName.equals(\"select1\")) {\n\n                        final NodeInfo controlNodeInfo = controlsDocumentInfo.wrap(controlElement);\n\n                        // Try to figure out if we have dynamic items. This attempts to cover all cases, including\n                        // nested xforms:output controls.\n                        final boolean hasNonStaticItem = ((Boolean) XPathCache.evaluateSingle(pipelineContext, controlNodeInfo,\n                                \"exists(.//xforms:*[@ref or @nodeset or @bind or @value])\", BASIC_NAMESPACE_MAPPINGS,\n                                null, null, null, null, locationData)).booleanValue();\n\n                        // Remember information\n                        if (itemsInfoMap == null)\n                            itemsInfoMap = new HashMap();\n                        itemsInfoMap.put(controlId, new ItemsInfo(hasNonStaticItem));\n                    }\n                }\n\n                public void endVisitControl(Element controlElement, String controlId) {\n                    final String controlName = controlElement.getName();\n                    if (controlName.equals(\"repeat\")) {\n                        repeatAncestorsStack.pop();\n                    }\n                }\n            });\n\n            // Gather online/offline information\n            {\n                // NOTE: We attempt to localize what triggers can cause, upon DOMActivate, xxforms:online, xxforms:offline and xxforms:offline-save actions\n                final List onlineTriggerIds = XPathCache.evaluate(pipelineContext, controlsDocumentInfo,\n                    \"for $handler in for $action in //xxforms:online return ($action/ancestor-or-self::*[@ev:event and tokenize(@ev:event, '\\\\s+') = 'DOMActivate'])[1]\" +\n                    \"   return for $id in $handler/../descendant-or-self::xforms:trigger/@id return string($id)\", BASIC_NAMESPACE_MAPPINGS,\n                    null, null, null, null, locationData);\n\n                final List offlineTriggerIds = XPathCache.evaluate(pipelineContext, controlsDocumentInfo,\n                    \"for $handler in for $action in //xxforms:offline return ($action/ancestor-or-self::*[@ev:event and tokenize(@ev:event, '\\\\s+') = 'DOMActivate'])[1]\" +\n                    \"   return for $id in $handler/../descendant-or-self::xforms:trigger/@id return string($id)\", BASIC_NAMESPACE_MAPPINGS,\n                    null, null, null, null, locationData);\n\n                final List offlineSaveTriggerIds = XPathCache.evaluate(pipelineContext, controlsDocumentInfo,\n                    \"for $handler in for $action in //xxforms:offline-save return ($action/ancestor-or-self::*[@ev:event and tokenize(@ev:event, '\\\\s+') = 'DOMActivate'])[1]\" +\n                    \"   return for $id in $handler/../descendant-or-self::xforms:trigger/@id return string($id)\", BASIC_NAMESPACE_MAPPINGS,\n                    null, null, null, null, locationData);\n\n                for (Iterator i = onlineTriggerIds.iterator(); i.hasNext();) {\n                    final String currentId = (String) i.next();\n                    addClasses(currentId, \"xxforms-online\");\n                }\n\n                for (Iterator i = offlineTriggerIds.iterator(); i.hasNext();) {\n                    final String currentId = (String) i.next();\n                    addClasses(currentId, \"xxforms-offline\");\n                }\n\n                for (Iterator i = offlineSaveTriggerIds.iterator(); i.hasNext();) {\n                    final String currentId = (String) i.next();\n                    addClasses(currentId, \"xxforms-offline-save\");\n                }\n\n                {\n                    // Create list of all the documents to search\n                    final List documentInfos = new ArrayList(modelDocuments.size() + 1);\n                    for (Iterator i = modelDocuments.iterator(); i.hasNext();) {\n                        documentInfos.add(new DocumentWrapper((Document) i.next(), null, xpathConfiguration));\n                    }\n                    documentInfos.add(controlsDocumentInfo);\n\n                    // Search for xxforms:offline which are not within instances\n                    for (Iterator i = documentInfos.iterator(); i.hasNext();) {\n                        final DocumentInfo currentDocumentInfo = (DocumentInfo) i.next();\n                        hasOfflineSupport |= ((Boolean) XPathCache.evaluateSingle(pipelineContext, currentDocumentInfo,\n                            \"exists(//xxforms:offline[not(ancestor::xforms:instance)])\", BASIC_NAMESPACE_MAPPINGS,\n                            null, null, null, null, locationData)).booleanValue();\n                    }\n                }\n            }\n\n            repeatHierarchyString = repeatHierarchyStringBuffer.toString();\n\n            // Iterate over models\n            for (Iterator i = getModelDocuments().iterator(); i.hasNext();) {\n\n                final Element modelElement; {\n                    final Document modelDocument = (Document) i.next();\n                    modelElement = modelDocument.getRootElement();\n                }\n\n                final Map modelEventHandlers = XFormsEventHandlerImpl.extractEventHandlers(modelElement, eventNamesMap);\n                mergeEventHandlers(eventHandlersMap, modelEventHandlers);\n\n                // Iterate over model submissions\n                for (Iterator j = modelElement.elements(new QName(\"submission\", XFormsConstants.XFORMS_NAMESPACE)).iterator(); j.hasNext();) {\n                    final Element currentSubmissionElement = (Element) j.next();\n\n                    final Map submissionEventHandlers = XFormsEventHandlerImpl.extractEventHandlers(currentSubmissionElement, eventNamesMap);\n                    mergeEventHandlers(eventHandlersMap, submissionEventHandlers);\n                }\n            }\n            isAnalyzed = true;\n            return true;\n        } else {\n            return false;\n        }\n    }","id":86207,"modified_method":"public synchronized boolean analyzeIfNecessary(final PipelineContext pipelineContext) {\n        if (!isAnalyzed) {\n            controlNamesMap = new HashMap();\n            eventNamesMap = new HashMap();\n            eventHandlersMap = new HashMap();\n            controlElementsMap = new HashMap();\n            defaultRepeatIdToIndex = new HashMap();\n            repeatChildrenMap = new HashMap();\n            repeatDescendantsMap = new HashMap();\n\n            final Configuration xpathConfiguration = new Configuration();\n            final DocumentWrapper controlsDocumentInfo = new DocumentWrapper(controlsDocument, null, xpathConfiguration);\n\n            // Iterate over static controls tree\n            final FastStringBuffer repeatHierarchyStringBuffer = new FastStringBuffer(1024);\n            visitAllControlStatic(new ControlElementVisitorListener() {\n\n                private Stack repeatAncestorsStack = new Stack();\n\n                public void startVisitControl(Element controlElement, String controlId) {\n\n                    // Gather control name\n                    final String controlName = controlElement.getName();\n                    controlNamesMap.put(controlName, \"\");\n\n                    final LocationData locationData = new ExtendedLocationData((LocationData) controlElement.getData(), \"gathering static control information\", controlElement);\n\n                    // Check for mandatory and optional bindings\n                    if (controlElement != null && XFormsConstants.XFORMS_NAMESPACE_URI.equals(controlElement.getNamespaceURI())) {\n                        if (XFormsControls.mandatorySingleNodeControls.get(controlName) != null\n                                && !(controlElement.attribute(\"ref\") != null || controlElement.attribute(\"bind\") != null)) {\n                            throw new ValidationException(\"Missing mandatory single node binding for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.noSingleNodeControls.get(controlName) != null\n                                && (controlElement.attribute(\"ref\") != null || controlElement.attribute(\"bind\") != null)) {\n                            throw new ValidationException(\"Single node binding is prohibited for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.mandatoryNodesetControls.get(controlName) != null\n                                && !(controlElement.attribute(\"nodeset\") != null || controlElement.attribute(\"bind\") != null)) {\n                            throw new ValidationException(\"Missing mandatory nodeset binding for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.noNodesetControls.get(controlName) != null\n                                && controlElement.attribute(\"nodeset\") != null) {\n                            throw new ValidationException(\"Node-set binding is prohibited for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                        if (XFormsControls.singleNodeOrValueControls.get(controlName) != null\n                                && !(controlElement.attribute(\"ref\") != null || controlElement.attribute(\"bind\") != null || controlElement.attribute(\"value\") != null)) {\n                            throw new ValidationException(\"Missing mandatory single node binding or value attribute for element: \" + controlElement.getQualifiedName(), locationData);\n                        }\n                    }\n\n                    // Gather event handlers\n                    // Map<String, List<XFormsEventHandler>> of observer id to List of XFormsEventHandler\n                    final Map controlEventHandlersMap = XFormsEventHandlerImpl.extractEventHandlers(controlElement, eventNamesMap);\n                    mergeEventHandlers(eventHandlersMap, controlEventHandlersMap);\n\n                    // Gather static control\n                    controlElementsMap.put(controlId, controlElement);\n\n                    // Gather xforms:repeat information\n                    if (controlName.equals(\"repeat\")) {\n                        // Find initial indexes\n                        {\n                            // Create control without parent, just to hold iterations\n                            final XFormsRepeatControl repeatControl\n                                    = new XFormsRepeatControl(null, null, controlElement, controlElement.getName(), controlId);\n\n                            // Remember initial index\n                            defaultRepeatIdToIndex.put(repeatControl.getRepeatId(), new Integer(repeatControl.getStartIndex()));\n                        }\n                        // Find repeat parents\n                        {\n                            // Create repeat hierarchy string\n                            if (repeatHierarchyStringBuffer.length() > 0)\n                                repeatHierarchyStringBuffer.append(',');\n\n                            repeatHierarchyStringBuffer.append(controlId);\n\n                            if (repeatAncestorsStack.size() > 0) {\n                                // If we have a parent, append it\n                                final String parentRepeatId = (String) repeatAncestorsStack.peek();\n                                repeatHierarchyStringBuffer.append(' ');\n                                repeatHierarchyStringBuffer.append(parentRepeatId);\n                            }\n                        }\n                        // Find repeat children\n                        {\n                            if (repeatAncestorsStack.size() > 0) {\n                                // If we have a parent, tell the parent that it has a child\n                                final String parentRepeatId = (String) repeatAncestorsStack.peek();\n                                List parentRepeatList = (List) repeatChildrenMap.get(parentRepeatId);\n                                if (parentRepeatList == null) {\n                                    parentRepeatList = new ArrayList();\n                                    repeatChildrenMap.put(parentRepeatId, parentRepeatList);\n                                }\n                                parentRepeatList.add(controlId);\n                            }\n\n                        }\n\n                        repeatAncestorsStack.push(controlId);\n                    }\n\n                    // Gather itemset information\n                    if (controlName.equals(\"select\") || controlName.equals(\"select1\")) {\n\n                        final NodeInfo controlNodeInfo = controlsDocumentInfo.wrap(controlElement);\n\n                        // Try to figure out if we have dynamic items. This attempts to cover all cases, including\n                        // nested xforms:output controls.\n                        final boolean hasNonStaticItem = ((Boolean) XPathCache.evaluateSingle(pipelineContext, controlNodeInfo,\n                                \"exists(.//xforms:*[@ref or @nodeset or @bind or @value])\", BASIC_NAMESPACE_MAPPINGS,\n                                null, null, null, null, locationData)).booleanValue();\n\n                        // Remember information\n                        if (itemsInfoMap == null)\n                            itemsInfoMap = new HashMap();\n                        itemsInfoMap.put(controlId, new ItemsInfo(hasNonStaticItem));\n                    }\n                }\n\n                public void endVisitControl(Element controlElement, String controlId) {\n                    final String controlName = controlElement.getName();\n                    if (controlName.equals(\"repeat\")) {\n                        repeatAncestorsStack.pop();\n                    }\n                }\n            });\n\n            // Gather online/offline information\n            {\n                // NOTE: We attempt to localize what triggers can cause, upon DOMActivate, xxforms:online, xxforms:offline and xxforms:offline-save actions\n                final List onlineTriggerIds = XPathCache.evaluate(pipelineContext, controlsDocumentInfo,\n                    \"for $handler in for $action in //xxforms:online return ($action/ancestor-or-self::*[@ev:event and tokenize(@ev:event, '\\\\s+') = 'DOMActivate'])[1]\" +\n                    \"   return for $id in $handler/../descendant-or-self::xforms:trigger/@id return string($id)\", BASIC_NAMESPACE_MAPPINGS,\n                    null, null, null, null, locationData);\n\n                final List offlineTriggerIds = XPathCache.evaluate(pipelineContext, controlsDocumentInfo,\n                    \"for $handler in for $action in //xxforms:offline return ($action/ancestor-or-self::*[@ev:event and tokenize(@ev:event, '\\\\s+') = 'DOMActivate'])[1]\" +\n                    \"   return for $id in $handler/../descendant-or-self::xforms:trigger/@id return string($id)\", BASIC_NAMESPACE_MAPPINGS,\n                    null, null, null, null, locationData);\n\n                final List offlineSaveTriggerIds = XPathCache.evaluate(pipelineContext, controlsDocumentInfo,\n                    \"for $handler in for $action in //xxforms:offline-save return ($action/ancestor-or-self::*[@ev:event and tokenize(@ev:event, '\\\\s+') = 'DOMActivate'])[1]\" +\n                    \"   return for $id in $handler/../descendant-or-self::xforms:trigger/@id return string($id)\", BASIC_NAMESPACE_MAPPINGS,\n                    null, null, null, null, locationData);\n\n                for (Iterator i = onlineTriggerIds.iterator(); i.hasNext();) {\n                    final String currentId = (String) i.next();\n                    addClasses(currentId, \"xxforms-online\");\n                }\n\n                for (Iterator i = offlineTriggerIds.iterator(); i.hasNext();) {\n                    final String currentId = (String) i.next();\n                    addClasses(currentId, \"xxforms-offline\");\n                }\n\n                for (Iterator i = offlineSaveTriggerIds.iterator(); i.hasNext();) {\n                    final String currentId = (String) i.next();\n                    addClasses(currentId, \"xxforms-offline-save\");\n                }\n\n                {\n                    // Create list of all the documents to search\n                    final List documentInfos = new ArrayList(modelDocuments.size() + 1);\n                    for (Iterator i = modelDocuments.iterator(); i.hasNext();) {\n                        documentInfos.add(new DocumentWrapper((Document) i.next(), null, xpathConfiguration));\n                    }\n                    documentInfos.add(controlsDocumentInfo);\n\n                    // Search for xxforms:offline which are not within instances\n                    for (Iterator i = documentInfos.iterator(); i.hasNext();) {\n                        final DocumentInfo currentDocumentInfo = (DocumentInfo) i.next();\n                        hasOfflineSupport |= ((Boolean) XPathCache.evaluateSingle(pipelineContext, currentDocumentInfo,\n                            \"exists(//xxforms:offline[not(ancestor::xforms:instance)])\", BASIC_NAMESPACE_MAPPINGS,\n                            null, null, null, null, locationData)).booleanValue();\n                    }\n                }\n            }\n\n            repeatHierarchyString = repeatHierarchyStringBuffer.toString();\n\n            // Iterate over models\n            for (Iterator i = getModelDocuments().iterator(); i.hasNext();) {\n\n                final Element modelElement; {\n                    final Document modelDocument = (Document) i.next();\n                    modelElement = modelDocument.getRootElement();\n                }\n\n                // Iterate over model submissions\n                for (Iterator j = modelElement.elements(new QName(\"submission\", XFormsConstants.XFORMS_NAMESPACE)).iterator(); j.hasNext();) {\n                    final Element currentSubmissionElement = (Element) j.next();\n\n                    final Map submissionEventHandlers = XFormsEventHandlerImpl.extractEventHandlers(currentSubmissionElement, eventNamesMap);\n                    mergeEventHandlers(eventHandlersMap, submissionEventHandlers);\n                }\n\n                // Handle event handlers directly in model\n                final Map modelEventHandlers = XFormsEventHandlerImpl.extractEventHandlers(modelElement, eventNamesMap);\n                mergeEventHandlers(eventHandlersMap, modelEventHandlers);\n\n            }\n            isAnalyzed = true;\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"e2f055e4212303d58f7e91a473df27c35fa90ef2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Item evaluateItem(XPathContext xpathContext) throws XPathException {\n\n        final Expression qNameExpression = (argument == null || argument.length < 1) ? null : argument[0];\n        final String qName = (qNameExpression == null) ? null : qNameExpression.evaluateAsString(xpathContext);\n\n        final Expression valueExpression = (argument == null || argument.length < 2) ? null : argument[1];\n        final Item item = (valueExpression == null) ? null : valueExpression.evaluateItem(xpathContext);\n        final String value = (item != null) ? item.getStringValue() : \"\";\n\n        final int colonIndex = qName.indexOf(':');\n        final Attribute attribute;\n        if (colonIndex == -1) {\n            // NCName\n            attribute = Dom4jUtils.createAttribute(new QName(qName), value);\n        } else {\n            // QName-but-not-NCName\n            final String prefix = qName.substring(0, colonIndex);\n\n            final XFormsContextStack contextStack = getContextStack(xpathContext);\n            final Map namespaceMappings = getContainingDocument(xpathContext).getNamespaceMappings(contextStack.getCurrentBindingContext().getControlElement());\n\n            final String uri = (String) namespaceMappings.get(prefix);\n            if (uri == null)\n                throw new OXFException(\"Namespace prefix not in space for QName: \" + qName);\n\n            attribute = Dom4jUtils.createAttribute(new QName(qName.substring(colonIndex + 1), new Namespace(prefix, uri)), value);\n        }\n\n        return XXFormsElement.documentWrapper.wrap(attribute);\n    }","id":86208,"modified_method":"public Item evaluateItem(XPathContext xpathContext) throws XPathException {\n\n        final Expression qNameExpression = (argument == null || argument.length < 1) ? null : argument[0];\n        final String qName = (qNameExpression == null) ? null : qNameExpression.evaluateAsString(xpathContext);\n\n        final Expression valueExpression = (argument == null || argument.length < 2) ? null : argument[1];\n        final Item item = (valueExpression == null) ? null : valueExpression.evaluateItem(xpathContext);\n        final String value = (item != null) ? item.getStringValue() : \"\";\n\n        final int colonIndex = qName.indexOf(':');\n        final Attribute attribute;\n        if (colonIndex == -1) {\n            // NCName\n            attribute = Dom4jUtils.createAttribute(new QName(qName), value);\n        } else {\n            // QName-but-not-NCName\n            final String prefix = qName.substring(0, colonIndex);\n\n            final XFormsContextStack contextStack = getContextStack(xpathContext);\n            final Map namespaceMappings = getContainingDocument(xpathContext).getNamespaceMappings(contextStack.getCurrentBindingContext().getControlElement());\n\n            final String uri = (String) namespaceMappings.get(prefix);\n            if (uri == null)\n                throw new OXFException(\"Namespace prefix not in space for QName: \" + qName);\n\n            attribute = Dom4jUtils.createAttribute(new QName(qName.substring(colonIndex + 1), new Namespace(prefix, uri)), value);\n        }\n\n        return XXFormsElement.DOCUMENT_WRAPPER.wrap(attribute);\n    }","commit_id":"e2f055e4212303d58f7e91a473df27c35fa90ef2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Item evaluateItem(XPathContext xpathContext) throws XPathException {\n\n        final Expression qNameExpression = (argument == null || argument.length < 1) ? null : argument[0];\n        final String qName = (qNameExpression == null) ? null : qNameExpression.evaluateAsString(xpathContext);\n\n        final Expression contextExpression = (argument == null || argument.length < 2) ? null : argument[1];\n        final SequenceIterator content = (contextExpression == null) ? null : contextExpression.iterate(xpathContext);\n\n        final int colonIndex = qName.indexOf(':');\n        final Element element;\n        if (colonIndex == -1) {\n            // NCName\n            element = Dom4jUtils.createElement(qName);\n        } else {\n            // QName-but-not-NCName\n            final String prefix = qName.substring(0, colonIndex);\n\n            final XFormsContextStack contextStack = getContextStack(xpathContext);\n            final Map namespaceMappings = getContainingDocument(xpathContext).getNamespaceMappings(contextStack.getCurrentBindingContext().getControlElement());\n\n            final String uri = (String) namespaceMappings.get(prefix);\n            if (uri == null)\n                throw new OXFException(\"Namespace prefix not in space for QName: \" + qName);\n\n            element = Dom4jUtils.createElement(qName, uri);\n        }\n\n        // Iterate over content if passed\n        if (content != null) {\n            boolean hasNewText = false;\n            while (true) {\n                final Item currentItem = content.next();\n                if (currentItem == null) {\n                    break;\n                }\n                if (currentItem instanceof AtomicValue) {\n                    // Insert as text\n                    element.addText(currentItem.getStringValue());\n                    hasNewText = true;\n                } else if (currentItem instanceof NodeInfo) {\n                    // Insert nodes\n\n                    if (currentItem instanceof NodeWrapper) {\n                        // dom4j node\n\n                        // Copy node before using it\n                        final Node newNode; {\n                        final Node currentNode = (Node) ((NodeWrapper) currentItem).getUnderlyingNode();\n                            newNode = Dom4jUtils.createCopy(currentNode);\n                        }\n\n                        if (newNode instanceof Attribute) {\n                            // Add attribute\n                            element.add((Attribute) newNode);\n                        } else {\n                            // Append node\n                            element.content().add(newNode);\n                        }\n\n                    } else {\n                        // Other type of node\n                        // TODO: read and convert\n                    }\n                }\n            }\n\n            // Make sure we are normalized if we added text \n            if (hasNewText)\n                Dom4jUtils.normalizeTextNodes(element);\n        }\n\n        return documentWrapper.wrap(element);\n    }","id":86209,"modified_method":"public Item evaluateItem(XPathContext xpathContext) throws XPathException {\n\n        final Expression qNameExpression = (argument == null || argument.length < 1) ? null : argument[0];\n        final String qName = (qNameExpression == null) ? null : qNameExpression.evaluateAsString(xpathContext);\n\n        final Expression contextExpression = (argument == null || argument.length < 2) ? null : argument[1];\n        final SequenceIterator content = (contextExpression == null) ? null : contextExpression.iterate(xpathContext);\n\n        final int colonIndex = qName.indexOf(':');\n        final Element element;\n        if (colonIndex == -1) {\n            // NCName\n            element = Dom4jUtils.createElement(qName);\n        } else {\n            // QName-but-not-NCName\n            final String prefix = qName.substring(0, colonIndex);\n\n            final XFormsContextStack contextStack = getContextStack(xpathContext);\n            final Map namespaceMappings = getContainingDocument(xpathContext).getNamespaceMappings(contextStack.getCurrentBindingContext().getControlElement());\n\n            final String uri = (String) namespaceMappings.get(prefix);\n            if (uri == null)\n                throw new OXFException(\"Namespace prefix not in space for QName: \" + qName);\n\n            element = Dom4jUtils.createElement(qName, uri);\n        }\n\n        // Iterate over content if passed\n        if (content != null) {\n            boolean hasNewText = false;\n            while (true) {\n                final Item currentItem = content.next();\n                if (currentItem == null) {\n                    break;\n                }\n                if (currentItem instanceof AtomicValue) {\n                    // Insert as text\n                    element.addText(currentItem.getStringValue());\n                    hasNewText = true;\n                } else if (currentItem instanceof NodeInfo) {\n                    // Insert nodes\n\n                    if (currentItem instanceof NodeWrapper) {\n                        // dom4j node\n\n                        // Copy node before using it\n                        final Node newNode; {\n                        final Node currentNode = (Node) ((NodeWrapper) currentItem).getUnderlyingNode();\n                            newNode = Dom4jUtils.createCopy(currentNode);\n                        }\n\n                        if (newNode instanceof Attribute) {\n                            // Add attribute\n                            element.add((Attribute) newNode);\n                        } else {\n                            // Append node\n                            element.content().add(newNode);\n                        }\n\n                    } else {\n                        // Other type of node\n                        // TODO: read and convert\n                    }\n                }\n            }\n\n            // Make sure we are normalized if we added text \n            if (hasNewText)\n                Dom4jUtils.normalizeTextNodes(element);\n        }\n\n        return DOCUMENT_WRAPPER.wrap(element);\n    }","commit_id":"e2f055e4212303d58f7e91a473df27c35fa90ef2","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static <T extends IModule> T showDialogModuleChooser(final Component parent, String entityString, final List<T> modules, @Nullable List<T> nonProjectModules) {\n    Window window = SwingUtilities.getWindowAncestor(parent);\n    ModuleChooserDialog<T> dialog;\n    if (window instanceof Frame) {\n      dialog = new ModuleChooserDialog<T>((Frame) window, modules, nonProjectModules, entityString);\n    } else {\n      dialog = new ModuleChooserDialog<T>((Dialog) window, modules, nonProjectModules, entityString);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","id":86210,"modified_method":"public static <T extends IModule> T showDialogModuleChooser(final Component parent, String entityString, final List<T> modules, @Nullable List<T> nonProjectModules) {\n    Window window = parent instanceof Window?(Window)parent:SwingUtilities.getWindowAncestor(parent);\n    ModuleChooserDialog<T> dialog;\n    if (window instanceof Frame) {\n      dialog = new ModuleChooserDialog<T>((Frame) window, modules, nonProjectModules, entityString);\n    } else {\n      dialog = new ModuleChooserDialog<T>((Dialog) window, modules, nonProjectModules, entityString);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","commit_id":"8c54860f5af3e1a93b8cfb5ae65b141b5919caff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static String showDialogStringChooser(final Component parent, String entityString, final List<String> values) {\n    Window window = SwingUtilities.getWindowAncestor(parent);\n    StringChooserDialog dialog;\n    if (window instanceof Frame) {\n      dialog = new StringChooserDialog((Frame) window, values,entityString);\n    } else {\n      dialog = new StringChooserDialog((Dialog) window, values,  entityString);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","id":86211,"modified_method":"public static String showDialogStringChooser(final Component parent, String entityString, final List<String> values) {\n    Window window = parent instanceof Window?(Window)parent:SwingUtilities.getWindowAncestor(parent);\n    StringChooserDialog dialog;\n    if (window instanceof Frame) {\n      dialog = new StringChooserDialog((Frame) window, values,entityString);\n    } else {\n      dialog = new StringChooserDialog((Dialog) window, values,  entityString);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","commit_id":"8c54860f5af3e1a93b8cfb5ae65b141b5919caff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode showDialogNodeChooser(final Component parent, final List<SNode> values) {\n    Window window = SwingUtilities.getWindowAncestor(parent);\n    NodeChooserDialog dialog;\n    if (window instanceof Frame) {\n      dialog = new NodeChooserDialog((Frame) window, values);\n    } else {\n      dialog = new NodeChooserDialog((Dialog) window, values);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","id":86212,"modified_method":"public static SNode showDialogNodeChooser(final Component parent, final List<SNode> values) {\n    Window window = parent instanceof Window?(Window)parent:SwingUtilities.getWindowAncestor(parent);\n    NodeChooserDialog dialog;\n    if (window instanceof Frame) {\n      dialog = new NodeChooserDialog((Frame) window, values);\n    } else {\n      dialog = new NodeChooserDialog((Dialog) window, values);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","commit_id":"8c54860f5af3e1a93b8cfb5ae65b141b5919caff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SModelDescriptor showDialogModelChooser(final Component parent, final List<SModelDescriptor> models, @Nullable List<SModelDescriptor> nonProjectModels) {\n    Window window = SwingUtilities.getWindowAncestor(parent);\n    ModelChooserDialog dialog;\n    if (window instanceof Frame) {\n      dialog = new ModelChooserDialog((Frame) window, models, nonProjectModels);\n    } else {\n      dialog = new ModelChooserDialog((Dialog) window, models, nonProjectModels);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","id":86213,"modified_method":"public static SModelDescriptor showDialogModelChooser(final Component parent, final List<SModelDescriptor> models, @Nullable List<SModelDescriptor> nonProjectModels) {\n    Window window = parent instanceof Window?(Window)parent:SwingUtilities.getWindowAncestor(parent);\n    ModelChooserDialog dialog;\n    if (window instanceof Frame) {\n      dialog = new ModelChooserDialog((Frame) window, models, nonProjectModels);\n    } else {\n      dialog = new ModelChooserDialog((Dialog) window, models, nonProjectModels);\n    }\n    dialog.showDialog();\n    return dialog.getResult();\n  }","commit_id":"8c54860f5af3e1a93b8cfb5ae65b141b5919caff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void onStopFlushOk(Address address)\n   {\n\n      boolean stopFlushOkCompleted = false;\n      synchronized (sharedLock)\n      {\n         stopFlushOkSet.add(address);\n         TreeSet membersCopy = new TreeSet(currentView.getMembers());\n         membersCopy.removeAll(suspected);\n         stopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address + \",completed \" + stopFlushOkCompleted\n               + \",  stopFlushOkSet \" + stopFlushOkSet.toString());\n\n      if (stopFlushOkCompleted)\n      {         \n         synchronized (sharedLock)\n         {\n            flushCompletedSet.clear();\n            flushOkSet.clear();   \n            stopFlushOkSet.clear();\n            flushMembers.clear();\n            suspected.clear();\n            flushCoordinator = null;\n         }\n         flushPhase.lock();\n         flushPhase.setSecondPhase(false);\n         flushPhase.release();\n         \n         if (log.isDebugEnabled())\n            log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n         \n         synchronized (blockMutex)\n         {\n            isBlockingFlushDown = false;\n            blockMutex.notifyAll();\n         }\n         up_prot.up(new Event(Event.UNBLOCK));\n      }     \n   }","id":86214,"modified_method":"private void onStopFlushOk(Address address)\n   {\n\n      boolean stopFlushOkCompleted = false;\n      synchronized (sharedLock)\n      {\n         stopFlushOkSet.add(address);\n         TreeSet membersCopy = new TreeSet(currentView.getMembers());\n         membersCopy.removeAll(suspected);\n         stopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address + \",completed \" + stopFlushOkCompleted\n               + \",  stopFlushOkSet \" + stopFlushOkSet.toString());\n\n      if (stopFlushOkCompleted)\n      {         \n         synchronized (sharedLock)\n         {\n            flushCompletedMap.clear();\n            flushOkSet.clear();   \n            stopFlushOkSet.clear();\n            flushMembers.clear();\n            suspected.clear();\n            flushCoordinator = null;\n         }\n         flushPhase.lock();\n         flushPhase.setSecondPhase(false);\n         flushPhase.release();\n         \n         if (log.isDebugEnabled())\n            log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n         \n         synchronized (blockMutex)\n         {\n            isBlockingFlushDown = false;\n            blockMutex.notifyAll();\n         }\n         up_prot.up(new Event(Event.UNBLOCK));\n      }     \n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         out.writeObject(flushParticipants);\n      }","id":86215,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         out.writeObject(flushParticipants);\n         out.writeObject(digest);\n      }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushCompleted(Address address)\n   {\n      boolean flushCompleted = false;\n      synchronized (sharedLock)\n      {\n         flushCompletedSet.add(address);\n         flushCompleted = flushCompletedSet.containsAll(flushMembers);\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address \n               + \",completed \" + flushCompleted + \",flushCompleted \"\n               + flushCompletedSet.toString());\n\n      if (flushCompleted)\n      {\n         //needed for jmx operation startFlush(timeout);\n         flush_promise.setResult(Boolean.TRUE);\n         up_prot.up(new Event(Event.SUSPEND_OK));\n         down_prot.down(new Event(Event.SUSPEND_OK));\n         if (log.isDebugEnabled())\n            log.debug(\"All FLUSH_COMPLETED received at \" + localAddress + \" sent SUSPEND_OK down/up\");\n      }\n   }","id":86216,"modified_method":"private void onFlushCompleted(Address address,Digest digest)\n   {\n      boolean flushCompleted = false;\n      synchronized (sharedLock)\n      {\n         flushCompletedMap.put(address,digest);\n         if (flushCompletedMap.size() >= flushMembers.size())\n         {\n            flushCompleted = flushCompletedMap.keySet().containsAll(flushMembers);\n         }\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address \n               + \",completed \" + flushCompleted + \",flushCompleted \"\n               + flushCompletedMap.keySet());\n      \n      if (flushCompleted)\n      {         \n         List<Digest> gaps = findVirtualSynchronyGaps();\n         if(!gaps.isEmpty())\n         {\n            requestRetransmissions(gaps);\n            \n            //restart FLUSH\n            Message msg = new Message();\n            synchronized (sharedLock)\n            {\n               msg.putHeader(getName(), new FlushHeader(FlushHeader.START_FLUSH, currentViewId(), flushMembers));\n            }\n            if (log.isDebugEnabled())\n               log.debug(\"Repeating FLUSH due to virtual synchrony gap\");\n            \n            down_prot.down(new Event(Event.MSG, msg));            \n         }\n         else\n         {\n            //needed for jmx operation startFlush(timeout);\n            flush_promise.setResult(Boolean.TRUE);\n            up_prot.up(new Event(Event.SUSPEND_OK));\n            down_prot.down(new Event(Event.SUSPEND_OK));\n            if (log.isDebugEnabled())\n               log.debug(\"All FLUSH_COMPLETED received at \" + localAddress + \" sent SUSPEND_OK down/up\");   \n         }                             \n      }\n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushOk(Address address, long viewID)\n   {\n\n      boolean flushOkCompleted = false;\n      Message m = null;\n      synchronized (sharedLock)\n      {\n         flushOkSet.add(address);\n         flushOkCompleted = flushOkSet.containsAll(flushMembers);\n         if (flushOkCompleted)\n         {\n            m = new Message(flushCoordinator, localAddress, null);\n         }\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address + \",completed \" \n               + flushOkCompleted + \",  flushOkSet \" + flushOkSet.toString());\n\n      if (flushOkCompleted)\n      {\n         synchronized(blockMutex)\n         {\n            isBlockingFlushDown = true;\n         }\n         m.putHeader(getName(), new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID));\n         down_prot.down(new Event(Event.MSG, m));\n         if (log.isDebugEnabled())\n            log.debug(localAddress + \" is blocking FLUSH.down(). Sent FLUSH_COMPLETED message to \" + flushCoordinator);\n      }\n   }","id":86217,"modified_method":"private void onFlushOk(Address address, long viewID)\n   {\n\n      boolean flushOkCompleted = false;\n      boolean amIParticipant = false;\n      Message m = null;\n      synchronized (sharedLock)\n      {\n         amIParticipant = flushMembers.contains(address);\n         flushOkSet.add(address);\n         flushOkCompleted = flushOkSet.containsAll(flushMembers);\n         if (flushOkCompleted)\n         {\n            m = new Message(flushCoordinator);\n         }\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address + \",completed \" \n               + flushOkCompleted + \",  flushOkSet \" + flushOkSet.toString());\n\n      if (flushOkCompleted && amIParticipant)\n      {\n         synchronized(blockMutex)\n         {\n            isBlockingFlushDown = true;\n         }\n         Digest digest = (Digest)down_prot.down(new Event(Event.GET_DIGEST));\n         FlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID);\n         fh.addDigest(digest);         \n         m.putHeader(getName(),fh);\n         down_prot.down(new Event(Event.MSG, m));\n         if (log.isDebugEnabled())\n            log.debug(localAddress + \" is blocking FLUSH.down(). Sent FLUSH_COMPLETED message to \" + flushCoordinator);\n      }\n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         flushParticipants = (Collection) in.readObject();\n      }","id":86218,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         flushParticipants = (Collection) in.readObject();\n         digest = (Digest)in.readObject();\n      }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop()\n   {\n      synchronized (sharedLock)\n      {\n         currentView = new View(new ViewId(), new Vector());\n         flushCompletedSet.clear();\n         flushOkSet.clear();\n         stopFlushOkSet.clear();\n         flushMembers.clear();\n         suspected.clear();\n         flushCoordinator = null;\n      }\n   }","id":86219,"modified_method":"public void stop()\n   {\n      synchronized (sharedLock)\n      {\n         currentView = new View(new ViewId(), new Vector());\n         flushCompletedMap.clear();\n         flushOkSet.clear();\n         stopFlushOkSet.clear();\n         flushMembers.clear();\n         suspected.clear();\n         flushCoordinator = null;\n      }\n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         if (flushParticipants != null && !flushParticipants.isEmpty())\n         {\n            out.writeShort(flushParticipants.size());\n            for (Iterator iter = flushParticipants.iterator(); iter.hasNext();)\n            {\n               Address address = (Address) iter.next();\n               Util.writeAddress(address, out);\n            }\n         }\n         else\n         {\n            out.writeShort(0);\n         }\n      }","id":86220,"modified_method":"public void writeTo(DataOutputStream out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         if (flushParticipants != null && !flushParticipants.isEmpty())\n         {\n            out.writeShort(flushParticipants.size());\n            for (Iterator iter = flushParticipants.iterator(); iter.hasNext();)\n            {\n               Address address = (Address) iter.next();\n               Util.writeAddress(address, out);\n            }\n         }\n         else\n         {\n            out.writeShort(0);\n         }\n         if(digest != null)\n         {\n            out.writeBoolean(true);\n            Util.writeStreamable(digest, out);\n         }\n         else\n         {\n            out.writeBoolean(false);\n         }\n      }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt)\n   {\n\n      switch (evt.getType())\n      {\n         case Event.MSG :\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if (fh != null)\n            {\n               if(fh.type == FlushHeader.FLUSH_BYPASS)\n               {\n                  break;\n                  //propel this msg up\n               }\n               flushPhase.lock();\n               if (fh.type == FlushHeader.START_FLUSH)\n               {                             \n                  if (!flushPhase.isFlushInProgress())\n                  {\n                     flushPhase.setFirstPhase(true);\n                     flushPhase.release();\n                     sendBlockUpToChannel();                     \n                     onStartFlush(msg.getSrc(), fh);\n                  }\n                  else if (flushPhase.isInFirstPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     Address coordinator = null;\n                     synchronized(sharedLock)\n                     {\n                        coordinator = flushCoordinator;\n                     }\n                     \n                     if(flushRequester.compareTo(coordinator)<0)\n                     {                        \n                        rejectFlush(fh.viewID, coordinator);\n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to current flush coordinator \" + coordinator + \" and switching flush coordinator to \" + flushRequester);\n                        }\n                        synchronized(sharedLock)\n                        {\n                           flushCoordinator = flushRequester;\n                        }                        \n                     }\n                     else\n                     {                        \n                        rejectFlush(fh.viewID, flushRequester); \n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to flush requester \" + flushRequester);\n                        }\n                     }                      \n                  }\n                  else if (flushPhase.isInSecondPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     rejectFlush(fh.viewID, flushRequester);  \n                     if(log.isDebugEnabled())\n                     {\n                        log.debug(\"Rejecting flush in second phase at \" + localAddress + \" to flush requester \" + flushRequester);\n                     }\n                  }\n               }\n               else if (fh.type == FlushHeader.STOP_FLUSH)\n               {\n                  flushPhase.setPhases(false, true); \n                  flushPhase.release();\n                  onStopFlush();\n               }\n               else if (fh.type == FlushHeader.ABORT_FLUSH)\n               {\n                  //abort current flush  \n                  flushPhase.release();\n                  up_prot.up(new Event(Event.SUSPEND_FAILED));\n                  down_prot.down(new Event(Event.SUSPEND_FAILED));\n\n               }\n               else if (isCurrentFlushMessage(fh))\n               {\n                  flushPhase.release();\n                  if (fh.type == FlushHeader.FLUSH_OK)\n                  {\n                     onFlushOk(msg.getSrc(), fh.viewID);\n                  }\n                  else if (fh.type == FlushHeader.STOP_FLUSH_OK)\n                  {\n                     onStopFlushOk(msg.getSrc());\n                  }\n                  else if (fh.type == FlushHeader.FLUSH_COMPLETED)\n                  {\n                     onFlushCompleted(msg.getSrc());\n                  }\n               }\n               else\n               {\n                  flushPhase.release();\n                  if (log.isDebugEnabled())\n                     log.debug(localAddress + \" received outdated FLUSH message \" + fh + \",ignoring it.\");\n               }\n               return null; //do not pass FLUSH msg up\n            }\n            break;\n\n         case Event.VIEW_CHANGE :\n            //if this is channel's first view and its the only member of the group then the\n            //goal is to pass BLOCK,VIEW,UNBLOCK to application space on the same thread as VIEW.\n            View newView = (View) evt.getArg();\n            boolean firstView = onViewChange(newView);\n            boolean singletonMember = newView.size()==1 && newView.containsMember(localAddress);\n            if(firstView && singletonMember){\n               up_prot.up(evt);\n               synchronized (blockMutex)\n               {\n                  isBlockingFlushDown = false;\n                  blockMutex.notifyAll();\n               }\n               if (log.isDebugEnabled())\n                  log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n               \n               up_prot.up(new Event(Event.UNBLOCK));\n               return null;\n            }\n            break;\n\n         case Event.SET_LOCAL_ADDRESS :\n            localAddress = (Address) evt.getArg();\n            break;\n\n         case Event.SUSPECT :\n            onSuspect((Address) evt.getArg());\n            break;\n\n         case Event.SUSPEND :           \n            attemptSuspend(evt);\n            return null;\n\n         case Event.RESUME :\n            onResume();\n            return null;\n\n      }\n\n      return up_prot.up(evt);\n   }","id":86221,"modified_method":"public Object up(Event evt)\n   {\n\n      switch (evt.getType())\n      {\n         case Event.MSG :\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if (fh != null)\n            {\n               if(fh.type == FlushHeader.FLUSH_BYPASS)\n               {\n                  break;\n                  //propel this msg up\n               }\n               flushPhase.lock();\n               if (fh.type == FlushHeader.START_FLUSH)\n               {                             \n                  if (!flushPhase.isFlushInProgress())\n                  {\n                     flushPhase.setFirstPhase(true);\n                     flushPhase.release();\n                     sendBlockUpToChannel();                     \n                     onStartFlush(msg.getSrc(), fh);\n                  }\n                  else if (flushPhase.isInFirstPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     Address coordinator = null;\n                     synchronized(sharedLock)\n                     {\n                        coordinator = flushCoordinator;\n                     }\n                     \n                     if(flushRequester.compareTo(coordinator)<0)\n                     {                        \n                        rejectFlush(fh.viewID, coordinator);\n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to current flush coordinator \" + coordinator + \" and switching flush coordinator to \" + flushRequester);\n                        }\n                        synchronized(sharedLock)\n                        {\n                           flushCoordinator = flushRequester;\n                        }                        \n                     }\n                     else\n                     {                        \n                        rejectFlush(fh.viewID, flushRequester); \n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to flush requester \" + flushRequester);\n                        }\n                     }                      \n                  }\n                  else if (flushPhase.isInSecondPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     rejectFlush(fh.viewID, flushRequester);  \n                     if(log.isDebugEnabled())\n                     {\n                        log.debug(\"Rejecting flush in second phase at \" + localAddress + \" to flush requester \" + flushRequester);\n                     }\n                  }\n               }\n               else if (fh.type == FlushHeader.STOP_FLUSH)\n               {\n                  flushPhase.setPhases(false, true); \n                  flushPhase.release();\n                  onStopFlush();\n               }\n               else if (fh.type == FlushHeader.ABORT_FLUSH)\n               {\n                  //abort current flush  \n                  flushPhase.release();\n                  up_prot.up(new Event(Event.SUSPEND_FAILED));\n                  down_prot.down(new Event(Event.SUSPEND_FAILED));\n\n               }\n               else if (isCurrentFlushMessage(fh))\n               {\n                  flushPhase.release();\n                  if (fh.type == FlushHeader.FLUSH_OK)\n                  {\n                     onFlushOk(msg.getSrc(), fh.viewID);\n                  }\n                  else if (fh.type == FlushHeader.STOP_FLUSH_OK)\n                  {\n                     onStopFlushOk(msg.getSrc());\n                  }\n                  else if (fh.type == FlushHeader.FLUSH_COMPLETED)\n                  {                     \n                     onFlushCompleted(msg.getSrc(),fh.digest);\n                  }\n               }\n               else\n               {\n                  flushPhase.release();\n                  if (log.isDebugEnabled())\n                     log.debug(localAddress + \" received outdated FLUSH message \" + fh + \",ignoring it.\");\n               }\n               return null; //do not pass FLUSH msg up\n            }\n            break;\n\n         case Event.VIEW_CHANGE :\n            //if this is channel's first view and its the only member of the group then the\n            //goal is to pass BLOCK,VIEW,UNBLOCK to application space on the same thread as VIEW.\n            View newView = (View) evt.getArg();\n            boolean firstView = onViewChange(newView);\n            boolean singletonMember = newView.size()==1 && newView.containsMember(localAddress);\n            if(firstView && singletonMember){\n               up_prot.up(evt);\n               synchronized (blockMutex)\n               {\n                  isBlockingFlushDown = false;\n                  blockMutex.notifyAll();\n               }\n               if (log.isDebugEnabled())\n                  log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n               \n               up_prot.up(new Event(Event.UNBLOCK));\n               return null;\n            }\n            break;\n\n         case Event.SET_LOCAL_ADDRESS :\n            localAddress = (Address) evt.getArg();\n            break;\n\n         case Event.SUSPECT :\n            onSuspect((Address) evt.getArg());\n            break;\n\n         case Event.SUSPEND :           \n            attemptSuspend(evt);\n            return null;\n\n         case Event.RESUME :\n            onResume();\n            return null;\n\n      }\n\n      return up_prot.up(evt);\n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         int flushParticipantsSize = in.readShort();\n         if (flushParticipantsSize > 0)\n         {\n            flushParticipants = new ArrayList(flushParticipantsSize);\n            for (int i = 0; i < flushParticipantsSize; i++)\n            {\n               flushParticipants.add(Util.readAddress(in));\n            }\n         }\n      }","id":86222,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         int flushParticipantsSize = in.readShort();\n         if (flushParticipantsSize > 0)\n         {\n            flushParticipants = new ArrayList(flushParticipantsSize);\n            for (int i = 0; i < flushParticipantsSize; i++)\n            {\n               flushParticipants.add(Util.readAddress(in));\n            }\n         }\n         boolean hasDigest = in.readBoolean();\n         if(hasDigest)\n         {\n            digest = (Digest) Util.readStreamable(Digest.class, in);\n         }\n      }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public FLUSH()\n   {\n      super();      \n      currentView = new View(new ViewId(), new Vector());\n      flushOkSet = new TreeSet();\n      flushCompletedSet = new TreeSet();\n      stopFlushOkSet = new TreeSet();\n      flushMembers = new ArrayList();\n      suspected = new TreeSet();      \n   }","id":86223,"modified_method":"public FLUSH()\n   {\n      super();      \n      currentView = new View(new ViewId(), new Vector());\n      flushOkSet = new TreeSet();\n      flushCompletedMap = new HashMap<Address, Digest>();\n      stopFlushOkSet = new TreeSet();\n      flushMembers = new ArrayList();\n      suspected = new TreeSet();      \n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStartFlush(Address flushStarter, FlushHeader fh)\n   {      \n      if (stats)\n      {\n         startFlushTime = System.currentTimeMillis();\n         numberOfFlushes += 1;\n      }            \n      synchronized (sharedLock)\n      {         \n         flushCoordinator = flushStarter;\n         flushMembers.clear();\n         if(fh.flushParticipants!=null)\n         {\n            flushMembers.addAll(fh.flushParticipants);\n         }        \n         flushMembers.removeAll(suspected);\n      }\n      Message msg = new Message(null, localAddress, null);\n      msg.putHeader(getName(), new FlushHeader(FlushHeader.FLUSH_OK, fh.viewID));\n      down_prot.down(new Event(Event.MSG, msg));\n      if (log.isDebugEnabled())\n         log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_OK\");\n   }","id":86224,"modified_method":"private void onStartFlush(Address flushStarter, FlushHeader fh)\n   {      \n      if (stats)\n      {\n         startFlushTime = System.currentTimeMillis();\n         numberOfFlushes += 1;\n      }\n      boolean amIParticipant = false;\n      synchronized (sharedLock)\n      {         \n         flushCoordinator = flushStarter;\n         flushMembers.clear();\n         if(fh.flushParticipants!=null)\n         {\n            flushMembers.addAll(fh.flushParticipants);\n         }        \n         flushMembers.removeAll(suspected);\n         amIParticipant = flushMembers.contains(localAddress);\n      }\n      if (amIParticipant)\n      {\n         Message msg = new Message(null);\n         msg.putHeader(getName(), new FlushHeader(FlushHeader.FLUSH_OK, fh.viewID));\n         down_prot.down(new Event(Event.MSG, msg));\n         if (log.isDebugEnabled())\n            log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_OK\");\n      }\n   }","commit_id":"bed36fff4ff92353d20582596f0eb7dcb4d79391","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.DISCONNECT:\n                stopViewConsistencyChecker();\n                stopInfoSender();\n                break;\n        \n            case Event.VIEW_CHANGE:\n                stopViewConsistencyChecker();\n                stopInfoSender();\n                Object ret=down_prot.down(evt);\n                view=(View)evt.getArg();\n                clearViews();\n\n                if(ergonomics && max_participants_in_merge > 0)\n                    max_participants_in_merge=Math.max(100, view.size() / 3);\n\n                startInfoSender();\n\n                List<Address> mbrs=view.getMembers();\n                Address coord=mbrs.isEmpty()? null : mbrs.get(0);\n                if(coord != null && coord.equals(local_addr)) {\n                    is_coord=true;\n                    startViewConsistencyChecker(); // start task if we became coordinator (doesn't start if already running)\n                }\n                else {\n                    // if we were coordinator, but are no longer, stop task. this happens e.g. when we merge and someone\n                    // else becomes the new coordinator of the merged group\n                    is_coord=false;\n                }\n                return ret;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n        }\n        return down_prot.down(evt);\n    }","id":86225,"modified_method":"public Object down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.CONNECT:\n            case Event.CONNECT_USE_FLUSH:\n            case Event.CONNECT_WITH_STATE_TRANSFER:\n            case Event.CONNECT_WITH_STATE_TRANSFER_USE_FLUSH:\n                cluster_name=(String)evt.getArg();\n                break;\n\n            case Event.DISCONNECT:\n                stopViewConsistencyChecker();\n                stopInfoSender();\n                break;\n        \n            case Event.VIEW_CHANGE:\n                stopViewConsistencyChecker();\n                stopInfoSender();\n                Object ret=down_prot.down(evt);\n                view=(View)evt.getArg();\n                clearViews();\n\n                if(ergonomics && max_participants_in_merge > 0)\n                    max_participants_in_merge=Math.max(100, view.size() / 3);\n\n                startInfoSender();\n\n                List<Address> mbrs=view.getMembers();\n                Address coord=mbrs.isEmpty()? null : mbrs.get(0);\n                if(coord != null && coord.equals(local_addr)) {\n                    is_coord=true;\n                    startViewConsistencyChecker(); // start task if we became coordinator (doesn't start if already running)\n                }\n                else {\n                    // if we were coordinator, but are no longer, stop task. this happens e.g. when we merge and someone\n                    // else becomes the new coordinator of the merged group\n                    is_coord=false;\n                }\n                return ret;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n        }\n        return down_prot.down(evt);\n    }","commit_id":"42e9fd6baee31022a76976bf005f0d1c95279199","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        timer=getTransport().getTimer();\n        if(timer == null)\n            throw new Exception(\"timer cannot be retrieved\");\n        if(min_interval >= max_interval)\n            throw new IllegalArgumentException(\"min_interval (\" + min_interval + \") has to be < max_interval (\" + max_interval + \")\");\n        if(check_interval == 0)\n            check_interval=computeCheckInterval();\n        else {\n            if(check_interval <= max_interval) {\n                log.warn(\"set check_interval=\" + computeCheckInterval() + \" as it is <= max_interval\");\n                check_interval=computeCheckInterval();\n            }\n        }\n        if(max_interval <= 0)\n            throw new Exception(\"max_interval must be > 0\");\n    }","id":86226,"modified_method":"public void init() throws Exception {\n        timer=getTransport().getTimer();\n        if(timer == null)\n            throw new Exception(\"timer cannot be retrieved\");\n        if(min_interval >= max_interval)\n            throw new IllegalArgumentException(\"min_interval (\" + min_interval + \") has to be < max_interval (\" + max_interval + \")\");\n        if(check_interval == 0)\n            check_interval=computeCheckInterval();\n        else {\n            if(check_interval <= max_interval) {\n                log.warn(\"set check_interval=\" + computeCheckInterval() + \" as it is <= max_interval\");\n                check_interval=computeCheckInterval();\n            }\n        }\n        if(max_interval <= 0)\n            throw new Exception(\"max_interval must be > 0\");\n        transport_supports_multicasting=getTransport().supportsMulticasting();\n    }","commit_id":"42e9fd6baee31022a76976bf005f0d1c95279199","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            if(view == null) {\n                log.warn(\"view is null, cannot send INFO message\");\n                return;\n            }\n            PhysicalAddress physical_addr=local_addr != null?\n              (PhysicalAddress)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr)) : null;\n            String logical_name=UUID.get(local_addr);\n            ViewId view_id=view.getViewId();\n            MergeHeader hdr=MergeHeader.createInfo(view_id, logical_name, Arrays.asList(physical_addr));\n            Message msg=new Message();\n            msg.putHeader(getId(), hdr);\n            down_prot.down(new Event(Event.MSG, msg));\n        }","id":86227,"modified_method":"public void run() {\n            if(view == null) {\n                log.warn(\"view is null, cannot send INFO message\");\n                return;\n            }\n            PhysicalAddress physical_addr=local_addr != null?\n              (PhysicalAddress)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESS, local_addr)) : null;\n            String logical_name=UUID.get(local_addr);\n            ViewId view_id=view.getViewId();\n            MergeHeader hdr=MergeHeader.createInfo(view_id, logical_name, Arrays.asList(physical_addr));\n\n            if(transport_supports_multicasting) {\n                Message msg=new Message();\n                msg.putHeader(getId(), hdr);\n                down_prot.down(new Event(Event.MSG, msg));\n                return;\n            }\n\n            Discovery discovery_protocol=(Discovery)stack.findProtocol(Discovery.class);\n            if(discovery_protocol == null) {\n                log.warn(\"no discovery protocol found, cannot ask for physical addresses to send INFO message\");\n                return;\n            }\n            Collection<PhysicalAddress> physical_addrs=discovery_protocol.fetchClusterMembers(cluster_name);\n            if(physical_addrs == null)\n                physical_addrs=(Collection<PhysicalAddress>)down_prot.down(new Event(Event.GET_PHYSICAL_ADDRESSES));\n\n            if(physical_addrs == null || physical_addrs.isEmpty()) {\n                log.trace(\"discovery protocol \" + discovery_protocol.getName() + \" returned 0 physical addresses\");\n                return;\n            }\n            if(log.isTraceEnabled())\n                log.trace(\"discovery protocol \" + discovery_protocol.getName() + \" returned \" + physical_addrs.size() +\n                            \" physical addresses: \" + Util.printListWithDelimiter(physical_addrs, \", \", 10));\n            for(Address addr: physical_addrs) {\n                Message info=new Message(addr);\n                info.putHeader(getId(), hdr);\n                down_prot.down(new Event(Event.MSG, info));\n            }\n        }","commit_id":"42e9fd6baee31022a76976bf005f0d1c95279199","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         int flushParticipantsSize = in.readShort();\n         if (flushParticipantsSize > 0)\n         {\n            flushParticipants = new ArrayList(flushParticipantsSize);\n            for (int i = 0; i < flushParticipantsSize; i++)\n            {\n               flushParticipants.add(Util.readAddress(in));\n            }\n         }\n      }","id":86228,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         int flushParticipantsSize = in.readShort();\n         if (flushParticipantsSize > 0)\n         {\n            flushParticipants = new ArrayList(flushParticipantsSize);\n            for (int i = 0; i < flushParticipantsSize; i++)\n            {\n               flushParticipants.add(Util.readAddress(in));\n            }\n         }\n         boolean hasDigest = in.readBoolean();\n         if(hasDigest)\n         {\n            digest = (Digest) Util.readStreamable(Digest.class, in);\n         }\n      }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop()\n   {\n      synchronized (sharedLock)\n      {\n         currentView = new View(new ViewId(), new Vector());\n         flushCompletedSet.clear();\n         flushOkSet.clear();\n         stopFlushOkSet.clear();\n         flushMembers.clear();\n         suspected.clear();\n         flushCoordinator = null;\n      }\n   }","id":86229,"modified_method":"public void stop()\n   {\n      synchronized (sharedLock)\n      {\n         currentView = new View(new ViewId(), new Vector());\n         flushCompletedMap.clear();\n         flushOkSet.clear();\n         stopFlushOkSet.clear();\n         flushMembers.clear();\n         suspected.clear();\n         flushCoordinator = null;\n      }\n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStartFlush(Address flushStarter, FlushHeader fh)\n   {      \n      if (stats)\n      {\n         startFlushTime = System.currentTimeMillis();\n         numberOfFlushes += 1;\n      }            \n      synchronized (sharedLock)\n      {         \n         flushCoordinator = flushStarter;\n         flushMembers.clear();\n         if(fh.flushParticipants!=null)\n         {\n            flushMembers.addAll(fh.flushParticipants);\n         }        \n         flushMembers.removeAll(suspected);\n      }\n      Message msg = new Message(null, localAddress, null);\n      msg.putHeader(getName(), new FlushHeader(FlushHeader.FLUSH_OK, fh.viewID));\n      down_prot.down(new Event(Event.MSG, msg));\n      if (log.isDebugEnabled())\n         log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_OK\");\n   }","id":86230,"modified_method":"private void onStartFlush(Address flushStarter, FlushHeader fh)\n   {      \n      if (stats)\n      {\n         startFlushTime = System.currentTimeMillis();\n         numberOfFlushes += 1;\n      }\n      boolean amIParticipant = false;\n      synchronized (sharedLock)\n      {         \n         flushCoordinator = flushStarter;\n         flushMembers.clear();\n         if(fh.flushParticipants!=null)\n         {\n            flushMembers.addAll(fh.flushParticipants);\n         }        \n         flushMembers.removeAll(suspected);\n         amIParticipant = flushMembers.contains(localAddress);\n      }\n      if (amIParticipant)\n      {\n         Message msg = new Message(null);\n         msg.putHeader(getName(), new FlushHeader(FlushHeader.FLUSH_OK, fh.viewID));\n         down_prot.down(new Event(Event.MSG, msg));\n         if (log.isDebugEnabled())\n            log.debug(\"Received START_FLUSH at \" + localAddress + \" responded with FLUSH_OK\");\n      }\n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         if (flushParticipants != null && !flushParticipants.isEmpty())\n         {\n            out.writeShort(flushParticipants.size());\n            for (Iterator iter = flushParticipants.iterator(); iter.hasNext();)\n            {\n               Address address = (Address) iter.next();\n               Util.writeAddress(address, out);\n            }\n         }\n         else\n         {\n            out.writeShort(0);\n         }\n      }","id":86231,"modified_method":"public void writeTo(DataOutputStream out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         if (flushParticipants != null && !flushParticipants.isEmpty())\n         {\n            out.writeShort(flushParticipants.size());\n            for (Iterator iter = flushParticipants.iterator(); iter.hasNext();)\n            {\n               Address address = (Address) iter.next();\n               Util.writeAddress(address, out);\n            }\n         }\n         else\n         {\n            out.writeShort(0);\n         }\n         if(digest != null)\n         {\n            out.writeBoolean(true);\n            Util.writeStreamable(digest, out);\n         }\n         else\n         {\n            out.writeBoolean(false);\n         }\n      }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"public FLUSH()\n   {\n      super();      \n      currentView = new View(new ViewId(), new Vector());\n      flushOkSet = new TreeSet();\n      flushCompletedSet = new TreeSet();\n      stopFlushOkSet = new TreeSet();\n      flushMembers = new ArrayList();\n      suspected = new TreeSet();      \n   }","id":86232,"modified_method":"public FLUSH()\n   {\n      super();      \n      currentView = new View(new ViewId(), new Vector());\n      flushOkSet = new TreeSet();\n      flushCompletedMap = new HashMap<Address, Digest>();\n      stopFlushOkSet = new TreeSet();\n      flushMembers = new ArrayList();\n      suspected = new TreeSet();      \n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushCompleted(Address address)\n   {\n      boolean flushCompleted = false;\n      synchronized (sharedLock)\n      {\n         flushCompletedSet.add(address);\n         flushCompleted = flushCompletedSet.containsAll(flushMembers);\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address \n               + \",completed \" + flushCompleted + \",flushCompleted \"\n               + flushCompletedSet.toString());\n\n      if (flushCompleted)\n      {\n         //needed for jmx operation startFlush(timeout);\n         flush_promise.setResult(Boolean.TRUE);\n         up_prot.up(new Event(Event.SUSPEND_OK));\n         down_prot.down(new Event(Event.SUSPEND_OK));\n         if (log.isDebugEnabled())\n            log.debug(\"All FLUSH_COMPLETED received at \" + localAddress + \" sent SUSPEND_OK down/up\");\n      }\n   }","id":86233,"modified_method":"private void onFlushCompleted(Address address,Digest digest)\n   {\n      boolean flushCompleted = false;\n      synchronized (sharedLock)\n      {\n         flushCompletedMap.put(address,digest);\n         if (flushCompletedMap.size() >= flushMembers.size())\n         {\n            flushCompleted = flushCompletedMap.keySet().containsAll(flushMembers);\n         }\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address \n               + \",completed \" + flushCompleted + \",flushCompleted \"\n               + flushCompletedMap.keySet());\n      \n      if (flushCompleted)\n      {         \n         List<Digest> gaps = findVirtualSynchronyGaps();\n         if(!gaps.isEmpty())\n         {\n            requestRetransmissions(gaps);\n            \n            //restart FLUSH\n            Message msg = new Message();\n            synchronized (sharedLock)\n            {\n               msg.putHeader(getName(), new FlushHeader(FlushHeader.START_FLUSH, currentViewId(), flushMembers));\n            }\n            if (log.isDebugEnabled())\n               log.debug(\"Repeating FLUSH due to virtual synchrony gap\");\n            \n            down_prot.down(new Event(Event.MSG, msg));            \n         }\n         else\n         {\n            //needed for jmx operation startFlush(timeout);\n            flush_promise.setResult(Boolean.TRUE);\n            up_prot.up(new Event(Event.SUSPEND_OK));\n            down_prot.down(new Event(Event.SUSPEND_OK));\n            if (log.isDebugEnabled())\n               log.debug(\"All FLUSH_COMPLETED received at \" + localAddress + \" sent SUSPEND_OK down/up\");   \n         }                             \n      }\n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         out.writeObject(flushParticipants);\n      }","id":86234,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException\n      {\n         out.writeByte(type);\n         out.writeLong(viewID);\n         out.writeObject(flushParticipants);\n         out.writeObject(digest);\n      }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStopFlushOk(Address address)\n   {\n\n      boolean stopFlushOkCompleted = false;\n      synchronized (sharedLock)\n      {\n         stopFlushOkSet.add(address);\n         TreeSet membersCopy = new TreeSet(currentView.getMembers());\n         membersCopy.removeAll(suspected);\n         stopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address + \",completed \" + stopFlushOkCompleted\n               + \",  stopFlushOkSet \" + stopFlushOkSet.toString());\n\n      if (stopFlushOkCompleted)\n      {         \n         synchronized (sharedLock)\n         {\n            flushCompletedSet.clear();\n            flushOkSet.clear();   \n            stopFlushOkSet.clear();\n            flushMembers.clear();\n            suspected.clear();\n            flushCoordinator = null;\n         }\n         flushPhase.lock();\n         flushPhase.setSecondPhase(false);\n         flushPhase.release();\n         \n         if (log.isDebugEnabled())\n            log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n         \n         synchronized (blockMutex)\n         {\n            isBlockingFlushDown = false;\n            blockMutex.notifyAll();\n         }\n         up_prot.up(new Event(Event.UNBLOCK));\n      }     \n   }","id":86235,"modified_method":"private void onStopFlushOk(Address address)\n   {\n\n      boolean stopFlushOkCompleted = false;\n      synchronized (sharedLock)\n      {\n         stopFlushOkSet.add(address);\n         TreeSet membersCopy = new TreeSet(currentView.getMembers());\n         membersCopy.removeAll(suspected);\n         stopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address + \",completed \" + stopFlushOkCompleted\n               + \",  stopFlushOkSet \" + stopFlushOkSet.toString());\n\n      if (stopFlushOkCompleted)\n      {         \n         synchronized (sharedLock)\n         {\n            flushCompletedMap.clear();\n            flushOkSet.clear();   \n            stopFlushOkSet.clear();\n            flushMembers.clear();\n            suspected.clear();\n            flushCoordinator = null;\n         }\n         flushPhase.lock();\n         flushPhase.setSecondPhase(false);\n         flushPhase.release();\n         \n         if (log.isDebugEnabled())\n            log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n         \n         synchronized (blockMutex)\n         {\n            isBlockingFlushDown = false;\n            blockMutex.notifyAll();\n         }\n         up_prot.up(new Event(Event.UNBLOCK));\n      }     \n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         flushParticipants = (Collection) in.readObject();\n      }","id":86236,"modified_method":"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException\n      {\n         type = in.readByte();\n         viewID = in.readLong();\n         flushParticipants = (Collection) in.readObject();\n         digest = (Digest)in.readObject();\n      }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushOk(Address address, long viewID)\n   {\n\n      boolean flushOkCompleted = false;\n      Message m = null;\n      synchronized (sharedLock)\n      {\n         flushOkSet.add(address);\n         flushOkCompleted = flushOkSet.containsAll(flushMembers);\n         if (flushOkCompleted)\n         {\n            m = new Message(flushCoordinator, localAddress, null);\n         }\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address + \",completed \" \n               + flushOkCompleted + \",  flushOkSet \" + flushOkSet.toString());\n\n      if (flushOkCompleted)\n      {\n         synchronized(blockMutex)\n         {\n            isBlockingFlushDown = true;\n         }\n         m.putHeader(getName(), new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID));\n         down_prot.down(new Event(Event.MSG, m));\n         if (log.isDebugEnabled())\n            log.debug(localAddress + \" is blocking FLUSH.down(). Sent FLUSH_COMPLETED message to \" + flushCoordinator);\n      }\n   }","id":86237,"modified_method":"private void onFlushOk(Address address, long viewID)\n   {\n\n      boolean flushOkCompleted = false;\n      boolean amIParticipant = false;\n      Message m = null;\n      synchronized (sharedLock)\n      {\n         amIParticipant = flushMembers.contains(address);\n         flushOkSet.add(address);\n         flushOkCompleted = flushOkSet.containsAll(flushMembers);\n         if (flushOkCompleted)\n         {\n            m = new Message(flushCoordinator);\n         }\n      }\n\n      if (log.isDebugEnabled())\n         log.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address + \",completed \" \n               + flushOkCompleted + \",  flushOkSet \" + flushOkSet.toString());\n\n      if (flushOkCompleted && amIParticipant)\n      {\n         synchronized(blockMutex)\n         {\n            isBlockingFlushDown = true;\n         }\n         Digest digest = (Digest)down_prot.down(new Event(Event.GET_DIGEST));\n         FlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED, viewID);\n         fh.addDigest(digest);         \n         m.putHeader(getName(),fh);\n         down_prot.down(new Event(Event.MSG, m));\n         if (log.isDebugEnabled())\n            log.debug(localAddress + \" is blocking FLUSH.down(). Sent FLUSH_COMPLETED message to \" + flushCoordinator);\n      }\n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt)\n   {\n\n      switch (evt.getType())\n      {\n         case Event.MSG :\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if (fh != null)\n            {\n               if(fh.type == FlushHeader.FLUSH_BYPASS)\n               {\n                  break;\n                  //propel this msg up\n               }\n               flushPhase.lock();\n               if (fh.type == FlushHeader.START_FLUSH)\n               {                             \n                  if (!flushPhase.isFlushInProgress())\n                  {\n                     flushPhase.setFirstPhase(true);\n                     flushPhase.release();\n                     sendBlockUpToChannel();                     \n                     onStartFlush(msg.getSrc(), fh);\n                  }\n                  else if (flushPhase.isInFirstPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     Address coordinator = null;\n                     synchronized(sharedLock)\n                     {\n                        coordinator = flushCoordinator;\n                     }\n                     \n                     if(flushRequester.compareTo(coordinator)<0)\n                     {                        \n                        rejectFlush(fh.viewID, coordinator);\n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to current flush coordinator \" + coordinator + \" and switching flush coordinator to \" + flushRequester);\n                        }\n                        synchronized(sharedLock)\n                        {\n                           flushCoordinator = flushRequester;\n                        }                        \n                     }\n                     else\n                     {                        \n                        rejectFlush(fh.viewID, flushRequester); \n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to flush requester \" + flushRequester);\n                        }\n                     }                      \n                  }\n                  else if (flushPhase.isInSecondPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     rejectFlush(fh.viewID, flushRequester);  \n                     if(log.isDebugEnabled())\n                     {\n                        log.debug(\"Rejecting flush in second phase at \" + localAddress + \" to flush requester \" + flushRequester);\n                     }\n                  }\n               }\n               else if (fh.type == FlushHeader.STOP_FLUSH)\n               {\n                  flushPhase.setPhases(false, true); \n                  flushPhase.release();\n                  onStopFlush();\n               }\n               else if (fh.type == FlushHeader.ABORT_FLUSH)\n               {\n                  //abort current flush  \n                  flushPhase.release();\n                  up_prot.up(new Event(Event.SUSPEND_FAILED));\n                  down_prot.down(new Event(Event.SUSPEND_FAILED));\n\n               }\n               else if (isCurrentFlushMessage(fh))\n               {\n                  flushPhase.release();\n                  if (fh.type == FlushHeader.FLUSH_OK)\n                  {\n                     onFlushOk(msg.getSrc(), fh.viewID);\n                  }\n                  else if (fh.type == FlushHeader.STOP_FLUSH_OK)\n                  {\n                     onStopFlushOk(msg.getSrc());\n                  }\n                  else if (fh.type == FlushHeader.FLUSH_COMPLETED)\n                  {\n                     onFlushCompleted(msg.getSrc());\n                  }\n               }\n               else\n               {\n                  flushPhase.release();\n                  if (log.isDebugEnabled())\n                     log.debug(localAddress + \" received outdated FLUSH message \" + fh + \",ignoring it.\");\n               }\n               return null; //do not pass FLUSH msg up\n            }\n            break;\n\n         case Event.VIEW_CHANGE :\n            //if this is channel's first view and its the only member of the group then the\n            //goal is to pass BLOCK,VIEW,UNBLOCK to application space on the same thread as VIEW.\n            View newView = (View) evt.getArg();\n            boolean firstView = onViewChange(newView);\n            boolean singletonMember = newView.size()==1 && newView.containsMember(localAddress);\n            if(firstView && singletonMember){\n               up_prot.up(evt);\n               synchronized (blockMutex)\n               {\n                  isBlockingFlushDown = false;\n                  blockMutex.notifyAll();\n               }\n               if (log.isDebugEnabled())\n                  log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n               \n               up_prot.up(new Event(Event.UNBLOCK));\n               return null;\n            }\n            break;\n\n         case Event.SET_LOCAL_ADDRESS :\n            localAddress = (Address) evt.getArg();\n            break;\n\n         case Event.SUSPECT :\n            onSuspect((Address) evt.getArg());\n            break;\n\n         case Event.SUSPEND :           \n            attemptSuspend(evt);\n            return null;\n\n         case Event.RESUME :\n            onResume();\n            return null;\n\n      }\n\n      return up_prot.up(evt);\n   }","id":86238,"modified_method":"public Object up(Event evt)\n   {\n\n      switch (evt.getType())\n      {\n         case Event.MSG :\n            Message msg = (Message) evt.getArg();\n            FlushHeader fh = (FlushHeader) msg.getHeader(getName());\n            if (fh != null)\n            {\n               if(fh.type == FlushHeader.FLUSH_BYPASS)\n               {\n                  break;\n                  //propel this msg up\n               }\n               flushPhase.lock();\n               if (fh.type == FlushHeader.START_FLUSH)\n               {                             \n                  if (!flushPhase.isFlushInProgress())\n                  {\n                     flushPhase.setFirstPhase(true);\n                     flushPhase.release();\n                     sendBlockUpToChannel();                     \n                     onStartFlush(msg.getSrc(), fh);\n                  }\n                  else if (flushPhase.isInFirstPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     Address coordinator = null;\n                     synchronized(sharedLock)\n                     {\n                        coordinator = flushCoordinator;\n                     }\n                     \n                     if(flushRequester.compareTo(coordinator)<0)\n                     {                        \n                        rejectFlush(fh.viewID, coordinator);\n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to current flush coordinator \" + coordinator + \" and switching flush coordinator to \" + flushRequester);\n                        }\n                        synchronized(sharedLock)\n                        {\n                           flushCoordinator = flushRequester;\n                        }                        \n                     }\n                     else\n                     {                        \n                        rejectFlush(fh.viewID, flushRequester); \n                        if(log.isDebugEnabled())\n                        {\n                           log.debug(\"Rejecting flush at \" + localAddress + \" to flush requester \" + flushRequester);\n                        }\n                     }                      \n                  }\n                  else if (flushPhase.isInSecondPhase())\n                  {\n                     flushPhase.release();\n                     Address flushRequester = msg.getSrc();\n                     rejectFlush(fh.viewID, flushRequester);  \n                     if(log.isDebugEnabled())\n                     {\n                        log.debug(\"Rejecting flush in second phase at \" + localAddress + \" to flush requester \" + flushRequester);\n                     }\n                  }\n               }\n               else if (fh.type == FlushHeader.STOP_FLUSH)\n               {\n                  flushPhase.setPhases(false, true); \n                  flushPhase.release();\n                  onStopFlush();\n               }\n               else if (fh.type == FlushHeader.ABORT_FLUSH)\n               {\n                  //abort current flush  \n                  flushPhase.release();\n                  up_prot.up(new Event(Event.SUSPEND_FAILED));\n                  down_prot.down(new Event(Event.SUSPEND_FAILED));\n\n               }\n               else if (isCurrentFlushMessage(fh))\n               {\n                  flushPhase.release();\n                  if (fh.type == FlushHeader.FLUSH_OK)\n                  {\n                     onFlushOk(msg.getSrc(), fh.viewID);\n                  }\n                  else if (fh.type == FlushHeader.STOP_FLUSH_OK)\n                  {\n                     onStopFlushOk(msg.getSrc());\n                  }\n                  else if (fh.type == FlushHeader.FLUSH_COMPLETED)\n                  {                     \n                     onFlushCompleted(msg.getSrc(),fh.digest);\n                  }\n               }\n               else\n               {\n                  flushPhase.release();\n                  if (log.isDebugEnabled())\n                     log.debug(localAddress + \" received outdated FLUSH message \" + fh + \",ignoring it.\");\n               }\n               return null; //do not pass FLUSH msg up\n            }\n            break;\n\n         case Event.VIEW_CHANGE :\n            //if this is channel's first view and its the only member of the group then the\n            //goal is to pass BLOCK,VIEW,UNBLOCK to application space on the same thread as VIEW.\n            View newView = (View) evt.getArg();\n            boolean firstView = onViewChange(newView);\n            boolean singletonMember = newView.size()==1 && newView.containsMember(localAddress);\n            if(firstView && singletonMember){\n               up_prot.up(evt);\n               synchronized (blockMutex)\n               {\n                  isBlockingFlushDown = false;\n                  blockMutex.notifyAll();\n               }\n               if (log.isDebugEnabled())\n                  log.debug(\"At \" + localAddress + \" unblocking FLUSH.down() and sending UNBLOCK up\");\n               \n               up_prot.up(new Event(Event.UNBLOCK));\n               return null;\n            }\n            break;\n\n         case Event.SET_LOCAL_ADDRESS :\n            localAddress = (Address) evt.getArg();\n            break;\n\n         case Event.SUSPECT :\n            onSuspect((Address) evt.getArg());\n            break;\n\n         case Event.SUSPEND :           \n            attemptSuspend(evt);\n            return null;\n\n         case Event.RESUME :\n            onResume();\n            return null;\n\n      }\n\n      return up_prot.up(evt);\n   }","commit_id":"199095ec4f9edcbe2b84c332c7964485d0f7d98f","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean startFlush(Event evt, long timeout, int numberOfAttempts) {\n\t\tboolean successfulFlush = false;\n\t\tif (!flushPhase.isFlushInProgress()) {\n\t\t\tflush_promise.reset();\n\t\t\tView v = (View) evt.getArg();\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received SUSPEND at \" + localAddress + \", view is \"+ v);\n\n\t\t\tonSuspend(v);\n\t\t\ttry {\n\t\t\t\tBoolean r = (Boolean) flush_promise.getResultWithTimeout(timeout);\n\t\t\t\tsuccessfulFlush = r.booleanValue();\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"At \" + localAddress\n\t\t\t\t\t\t\t+ \" timed out waiting for flush responses after \"\n\t\t\t\t\t\t\t+ timeout + \" msec\");\n\t\t\t}\n\t\t}\n\n\t\tif (!successfulFlush && numberOfAttempts > 0) {\n\t\t\tlong backOffSleepTime = Util.random(5);\n\t\t\tbackOffSleepTime = backOffSleepTime < 2 ? backOffSleepTime + 2: backOffSleepTime;\n\t\t\tif (log.isInfoEnabled())\n\t\t\t\tlog.info(\"At \" + localAddress + \". Backing off for \"\n\t\t\t\t\t\t+ backOffSleepTime + \" sec. Attempts left \"\n\t\t\t\t\t\t+ numberOfAttempts);\n\n\t\t\tUtil.sleep(backOffSleepTime * 1000);\n\t\t\tsuccessfulFlush = startFlush(evt, timeout, --numberOfAttempts);\n\t\t}\n\t\treturn successfulFlush;\n\t}","id":86239,"modified_method":"private boolean startFlush(Event evt, long timeout, int numberOfAttempts, boolean isRetry) {\n\t\tboolean successfulFlush = false;\n\t\tif (!flushPhase.isFlushInProgress() || isRetry) {\n\t\t\tflush_promise.reset();\n\t\t\tView v = (View) evt.getArg();\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received SUSPEND at \" + localAddress + \", view is \"+ v);\n\n\t\t\tonSuspend(v);\n\t\t\ttry {\n\t\t\t\tBoolean r = (Boolean) flush_promise.getResultWithTimeout(timeout);\n\t\t\t\tsuccessfulFlush = r.booleanValue();\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"At \" + localAddress\n\t\t\t\t\t\t\t+ \" timed out waiting for flush responses after \"\n\t\t\t\t\t\t\t+ timeout + \" msec\");\n\t\t\t}\n\t\t}\n\n\t\tif (!successfulFlush && numberOfAttempts > 0) {\n\t\t\tlong backOffSleepTime = Util.random(5);\n\t\t\tbackOffSleepTime = backOffSleepTime < 2 ? backOffSleepTime + 2: backOffSleepTime;\n\t\t\tif (log.isInfoEnabled())\n\t\t\t\tlog.info(\"At \" + localAddress + \". Backing off for \"\n\t\t\t\t\t\t+ backOffSleepTime + \" sec. Attempts left \"\n\t\t\t\t\t\t+ numberOfAttempts);\n\n\t\t\tUtil.sleep(backOffSleepTime * 1000);\n\t\t\tsuccessfulFlush = startFlush(evt, timeout, --numberOfAttempts, true);\n\t\t}\n\t\treturn successfulFlush;\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStartFlush(Message msg, FlushHeader fh) {\n\t\tbyte oldPhase = flushPhase.transitionToFirstPhase();\n\t\tif (oldPhase == FlushPhase.START_PHASE) {\n\t\t\tsendBlockUpToChannel();\n\t\t\tonStartFlush(msg.getSrc(), fh);\n\t\t} else if (oldPhase == FlushPhase.FIRST_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\tAddress coordinator = null;\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tcoordinator = flushCoordinator;\n\t\t\t}\n\n\t\t\tif (coordinator == null || flushRequester.compareTo(coordinator) < 0) {\n\t\t\t\trejectFlush(fh.viewID, coordinator);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to current flush coordinator \" + coordinator\n\t\t\t\t\t\t\t+ \" and switching flush coordinator to \"\n\t\t\t\t\t\t\t+ flushRequester);\n\t\t\t\t}\n\t\t\t\tsynchronized (sharedLock) {\n\t\t\t\t\tflushCoordinator = flushRequester;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to flush requester \" + flushRequester);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (oldPhase == FlushPhase.SECOND_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Rejecting flush in second phase at \" + localAddress\n\t\t\t\t\t\t+ \" to flush requester \" + flushRequester);\n\t\t\t}\n\t\t}\n\t}","id":86240,"modified_method":"private void handleStartFlush(Message msg, FlushHeader fh) {\n\t\tbyte oldPhase = flushPhase.transitionToFirstPhase();\n\t\tif (oldPhase == FlushPhase.START_PHASE) {\n\t\t\tsendBlockUpToChannel();\n\t\t\tonStartFlush(msg.getSrc(), fh);\n\t\t} else if (oldPhase == FlushPhase.FIRST_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\tAddress coordinator = null;\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tif(flushCoordinator != null)\n\t\t\t\t\tcoordinator = flushCoordinator;\n\t\t\t\telse\n\t\t\t\t\tcoordinator = flushRequester;\n\t\t\t}\n\n\t\t\tif (flushRequester.compareTo(coordinator) < 0) {\n\t\t\t\trejectFlush(fh.viewID, coordinator);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to current flush coordinator \" + coordinator\n\t\t\t\t\t\t\t+ \" and switching flush coordinator to \"\n\t\t\t\t\t\t\t+ flushRequester);\n\t\t\t\t}\n\t\t\t\tsynchronized (sharedLock) {\n\t\t\t\t\tflushCoordinator = flushRequester;\n\t\t\t\t}\n\t\t\t} else if (flushRequester.compareTo(coordinator) > 0)  {\n\t\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to flush requester \" + flushRequester + \" coordinator is \" + coordinator);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flushRequester.equals(coordinator)){\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Accepting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \", proceeding with flush\");\n\t\t\t\t}\n\t\t\t\tonStartFlush(msg.getSrc(), fh);\n\t\t\t}\n\t\t} else if (oldPhase == FlushPhase.SECOND_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Rejecting flush in second phase at \" + localAddress\n\t\t\t\t\t\t+ \" to flush requester \" + flushRequester);\n\t\t\t}\n\t\t}\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void transitionToStart() {\n\t\t\tphase = START_PHASE;\n\t\t}","id":86241,"modified_method":"public void transitionToStart() {\n\t\t\tsynchronized(sharedLock){\n\t\t\t\tphase = START_PHASE;\n\t\t\t}\n\t\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public FlushPhase() {\n\t\t}","id":86242,"modified_method":"FlushPhase() {\n\t\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized boolean isFlushInProgress() {\n\t\t\treturn phase != START_PHASE;\n\t\t}","id":86243,"modified_method":"public boolean isFlushInProgress() {\n\t\t\tsynchronized(sharedLock){\n\t\t\t\treturn phase != START_PHASE;\n\t\t\t}\n\t\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized byte transitionToFirstPhase() {\n\t\t\tbyte oldPhase = phase;\n\t\t\tif (oldPhase == START_PHASE) {\n\t\t\t\tphase = FIRST_PHASE;\n\t\t\t}\n\t\t\treturn oldPhase;\n\t\t}","id":86244,"modified_method":"public byte transitionToFirstPhase() {\n\t\t\tbyte oldPhase = -1;\n\t\t\tsynchronized(sharedLock){\n\t\t\t\toldPhase = phase;\n\t\t\t\tif(oldPhase == START_PHASE){\n\t\t\t\t\tphase = FIRST_PHASE;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn oldPhase;\n\t\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onSuspect(Address address) {\n\t\tboolean flushOkCompleted = false;\n\t\tMessage m = null;\n\t\tlong viewID = 0;\n\t\tsynchronized (sharedLock) {\n\t\t\tsuspected.add(address);\n\t\t\tflushMembers.removeAll(suspected);\n\t\t\tviewID = currentViewId();\n\t\t\tflushOkCompleted = !flushOkSet.isEmpty() && flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator, localAddress, null);\n\t\t\t}\n\t\t}\n\t\tif (flushOkCompleted) {\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress + \" sent FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t}\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Suspect is \" + address + \",completed \"\n\t\t\t\t\t+ flushOkCompleted + \",  flushOkSet \" + flushOkSet\n\t\t\t\t\t+ \" flushMembers \" + flushMembers);\n\t}","id":86245,"modified_method":"private void onSuspect(Address address) {\n\t\tboolean flushOkCompleted = false;\n\t\tMessage m = null;\n\t\tlong viewID = 0;\n\t\tsynchronized (sharedLock) {\n\t\t\tsuspected.add(address);\n\t\t\tflushMembers.removeAll(suspected);\n\t\t\tviewID = currentViewId();\n\t\t\tflushOkCompleted = !flushOkSet.isEmpty() && flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator, localAddress, null);\n\t\t\t}\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Suspect is \" + address + \",completed \"\n\t\t\t\t\t\t+ flushOkCompleted + \",  flushOkSet \" + flushOkSet\n\t\t\t\t\t\t+ \" flushMembers \" + flushMembers);\n\t\t}\n\t\tif (flushOkCompleted) {\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress + \" sent FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t}\t\t\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushCompleted(Address address, Digest digest) {\n\t\tboolean flushCompleted = false;\n\t\tsynchronized (sharedLock) {\n\t\t\tflushCompletedMap.put(address, digest);\n\t\t\tif (flushCompletedMap.size() >= flushMembers.size()) {\n\t\t\t\tflushCompleted = flushCompletedMap.keySet().containsAll(\n\t\t\t\t\t\tflushMembers);\n\t\t\t}\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address\n\t\t\t\t\t+ \",completed \" + flushCompleted + \",flushCompleted \"\n\t\t\t\t\t+ flushCompletedMap.keySet());\n\n\t\tif (flushCompleted) {\n\t\t\tif (hasVirtualSynchronyGaps()) {\n\t\t\t\tDigest d = findHighestSequences();\n\t\t\t\tMessage msg = new Message();\n\t\t\t\tmsg.setFlag(Message.OOB);\n\t\t\t\tsynchronized (sharedLock) {\n\t\t\t\t\tFlushHeader fh = new FlushHeader(\n\t\t\t\t\t\t\tFlushHeader.FLUSH_RECONCILE, currentViewId(),\n\t\t\t\t\t\t\tflushMembers);\n\t\t\t\t\treconcileOks.clear();\n\t\t\t\t\tfh.addDigest(d);\n\t\t\t\t\tmsg.putHeader(getName(), fh);\n\t\t\t\t}\n\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"Reconciling flush mebers due to virtual synchrony gap, digest is \"\n\t\t\t\t\t\t\t\t\t+ d + \" flush members are \" + flushMembers);\n\n\t\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\t} else {\n\t\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"All FLUSH_COMPLETED received at \"\n\t\t\t\t\t\t\t\t\t+ localAddress);\n\t\t\t}\n\t\t}\n\t}","id":86246,"modified_method":"private void onFlushCompleted(Address address, Digest digest) {\n\t\tboolean flushCompleted = false;\n\t\tMessage msg = null;\n\t\tboolean needsReconciliationPhase = false;\t\t\n\t\tsynchronized (sharedLock) {\n\t\t\tflushCompletedMap.put(address, digest);\n\t\t\tif (flushCompletedMap.size() >= flushMembers.size()) {\n\t\t\t\tflushCompleted = flushCompletedMap.keySet().containsAll(\n\t\t\t\t\t\tflushMembers);\n\t\t\t}\n\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address\n\t\t\t\t\t\t+ \",completed \" + flushCompleted + \",flushCompleted \"\n\t\t\t\t\t\t+ flushCompletedMap.keySet());\n\t\t\t\n\t\t\tneedsReconciliationPhase = flushCompleted && hasVirtualSynchronyGaps();\n\t\t\tif (needsReconciliationPhase){\n\t\t\t\t\n\t\t\t\tDigest d = findHighestSequences();\t\t\t\n\t\t\t\tmsg = new Message();\n\t\t\t\tmsg.setFlag(Message.OOB);\t\t\t\t\n\t\t\t\tFlushHeader fh = new FlushHeader(\n\t\t\t\t\t\tFlushHeader.FLUSH_RECONCILE, currentViewId(),\n\t\t\t\t\t\tflushMembers);\n\t\t\t\treconcileOks.clear();\n\t\t\t\tfh.addDigest(d);\n\t\t\t\tmsg.putHeader(getName(), fh);\n\t\t\t\t\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"Reconciling flush mebers due to virtual synchrony gap, digest is \"\n\t\t\t\t\t\t\t\t\t+ d + \" flush members are \" + flushMembers);\n\t\t\t\t\n\t\t\t\tflushCompletedMap.clear();\n\t\t\t}\n\t\t}\t\n\t\tif(needsReconciliationPhase){\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t}else if(flushCompleted){\n\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"All FLUSH_COMPLETED received at \"\n\t\t\t\t\t\t\t\t+ localAddress);\n\t\t}\t\t\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStopFlushOk(Address address) {\n\n\t\tboolean stopFlushOkCompleted = false;\n\t\tsynchronized (sharedLock) {\n\t\t\tstopFlushOkSet.add(address);\n\t\t\tTreeSet<Address> membersCopy = new TreeSet<Address>(currentView.getMembers());\n\t\t\tmembersCopy.removeAll(suspected);\n\t\t\tstopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address\n\t\t\t\t\t+ \",completed \" + stopFlushOkCompleted\n\t\t\t\t\t+ \",  stopFlushOkSet \" + stopFlushOkSet.toString());\n\n\t\tif (stopFlushOkCompleted) {\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tflushCompletedMap.clear();\n\t\t\t\tflushOkSet.clear();\n\t\t\t\tstopFlushOkSet.clear();\n\t\t\t\tflushMembers.clear();\n\t\t\t\tsuspected.clear();\n\t\t\t\tflushCoordinator = null;\n\t\t\t}\n\t\t\tflushPhase.transitionToStart();\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress\n\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\tblockMutex.notifyAll();\n\t\t\t}\n\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t}\n\t}","id":86247,"modified_method":"private void onStopFlushOk(Address address) {\n\n\t\tboolean stopFlushOkCompleted = false;\n\t\tsynchronized (sharedLock) {\n\t\t\tstopFlushOkSet.add(address);\n\t\t\tTreeSet<Address> membersCopy = new TreeSet<Address>(currentView.getMembers());\n\t\t\tmembersCopy.removeAll(suspected);\n\t\t\tstopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address\n\t\t\t\t\t\t+ \",completed \" + stopFlushOkCompleted\n\t\t\t\t\t\t+ \",  stopFlushOkSet \" + stopFlushOkSet);\n\t\t}\t\t\n\n\t\tif (stopFlushOkCompleted) {\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tflushPhase.transitionToStart();\n\t\t\t\tflushCompletedMap.clear();\n\t\t\t\tflushOkSet.clear();\n\t\t\t\tstopFlushOkSet.clear();\n\t\t\t\tflushMembers.clear();\n\t\t\t\tsuspected.clear();\n\t\t\t\tflushCoordinator = null;\t\t\t\n\t\t\t}\t\t\t\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress\n\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\tblockMutex.notifyAll();\n\t\t\t}\n\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t}\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushOk(Address address, long viewID) {\n\n\t\tboolean flushOkCompleted = false;\n\t\tboolean amIParticipant = false;\n\t\tMessage m = null;\n\t\tsynchronized (sharedLock) {\n\t\t\tamIParticipant = flushMembers.contains(address);\n\t\t\tflushOkSet.add(address);\n\t\t\tflushOkCompleted = flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator);\n\t\t\t}\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address\n\t\t\t\t\t+ \",completed \" + flushOkCompleted + \",  flushOkSet \"\n\t\t\t\t\t+ flushOkSet.toString());\n\n\t\tif (flushOkCompleted && amIParticipant) {\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = true;\n\t\t\t}\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t+ \" is blocking FLUSH.down(). Sent FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t}\n\t}","id":86248,"modified_method":"private void onFlushOk(Address address, long viewID) {\n\n\t\tboolean flushOkCompleted = false;\n\t\tboolean amIParticipant = false;\n\t\tMessage m = null;\n\t\tsynchronized (sharedLock) {\n\t\t\tamIParticipant = flushMembers.contains(address);\n\t\t\tflushOkSet.add(address);\n\t\t\tflushOkCompleted = flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator);\n\t\t\t}\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address\n\t\t\t\t\t\t+ \",completed \" + flushOkCompleted + \",  flushOkSet \"\n\t\t\t\t\t\t+ flushOkSet);\t\n\t\t}\t\t\n\n\t\tif (flushOkCompleted && amIParticipant) {\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = true;\n\t\t\t}\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t+ \" is blocking FLUSH.down(). Sending FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\t\n\t\t}\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void transitionToSecondPhase() {\n\t\t\tphase = SECOND_PHASE;\n\t\t}","id":86249,"modified_method":"public void transitionToSecondPhase() {\n\t\t\tsynchronized(sharedLock){\n\t\t\t\tphase = SECOND_PHASE;\n\t\t\t}\n\t\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null && fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\treturn down_prot.down(evt);\n\t\t\t} else {\n\t\t\t\tblockMessageDuringFlush();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Event.GET_STATE:\n\t\t\tblockMessageDuringFlush();\n\t\t\tbreak;\n\n\t\tcase Event.CONNECT:\n\t\t\tsendBlockUpToChannel();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\t\t}\n\t\treturn down_prot.down(evt);\n\t}","id":86250,"modified_method":"public Object down(Event evt) {\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null && fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\treturn down_prot.down(evt);\n\t\t\t} else {\n\t\t\t\tblockMessageDuringFlush();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Event.GET_STATE:\n\t\t\tblockMessageDuringFlush();\n\t\t\tbreak;\n\n\t\tcase Event.CONNECT:\n\t\t\tsendBlockUpToChannel();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5, false);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\t\t}\n\t\treturn down_prot.down(evt);\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null) {\n\t\t\t\tif (fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\t\treturn up_prot.up(evt);\n\t\t\t\t} else if (fh.type == FlushHeader.START_FLUSH) {\n\t\t\t\t\thandleStartFlush(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE) {\n\t\t\t\t\thandleFlushReconcile(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE_OK) {\n\t\t\t\t\tonFlushReconcileOK(msg);\n\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH) {\t\t\t\t\t\n\t\t\t\t\tonStopFlush();\n\t\t\t\t} else if (fh.type == FlushHeader.ABORT_FLUSH) {\n\t\t\t\t\t// abort current flush\n\t\t\t\t\tflush_promise.setResult(Boolean.FALSE);\n\t\t\t\t} else if (isCurrentFlushMessage(fh)) {\n\t\t\t\t\tif (fh.type == FlushHeader.FLUSH_OK) {\n\t\t\t\t\t\tonFlushOk(msg.getSrc(), fh.viewID);\n\t\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH_OK) {\n\t\t\t\t\t\tonStopFlushOk(msg.getSrc());\n\t\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_COMPLETED) {\n\t\t\t\t\t\tonFlushCompleted(msg.getSrc(), fh.digest);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t\t\t+ \" received outdated FLUSH message \" + fh\n\t\t\t\t\t\t\t\t+ \",ignoring it.\");\n\t\t\t\t}\n\t\t\t\treturn null; // do not pass FLUSH msg up\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Event.VIEW_CHANGE:\n\t\t\t// if this is channel's first view and its the only member of the\n\t\t\t// group then the\n\t\t\t// goal is to pass BLOCK,VIEW,UNBLOCK to application space on the\n\t\t\t// same thread as VIEW.\n\t\t\tView newView = (View) evt.getArg();\n\t\t\tboolean firstView = onViewChange(newView);\n\t\t\tboolean singletonMember = newView.size() == 1\n\t\t\t\t\t&& newView.containsMember(localAddress);\n\t\t\tif (firstView && singletonMember) {\n\t\t\t\tup_prot.up(evt);\n\t\t\t\tsynchronized (blockMutex) {\n\t\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\t\tblockMutex.notifyAll();\n\t\t\t\t}\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"At \"\n\t\t\t\t\t\t\t+ localAddress\n\t\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Event.SET_LOCAL_ADDRESS:\n\t\t\tlocalAddress = (Address) evt.getArg();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPECT:\n\t\t\tonSuspect((Address) evt.getArg());\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn up_prot.up(evt);\n\t}","id":86251,"modified_method":"public Object up(Event evt) {\n\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null) {\n\t\t\t\tif (fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\t\treturn up_prot.up(evt);\n\t\t\t\t} else if (fh.type == FlushHeader.START_FLUSH) {\n\t\t\t\t\thandleStartFlush(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE) {\n\t\t\t\t\thandleFlushReconcile(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE_OK) {\n\t\t\t\t\tonFlushReconcileOK(msg);\n\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH) {\t\t\t\t\t\n\t\t\t\t\tonStopFlush();\n\t\t\t\t} else if (fh.type == FlushHeader.ABORT_FLUSH) {\n\t\t\t\t\t// abort current flush\n\t\t\t\t\tflush_promise.setResult(Boolean.FALSE);\n\t\t\t\t} else if (isCurrentFlushMessage(fh)) {\n\t\t\t\t\tif (fh.type == FlushHeader.FLUSH_OK) {\n\t\t\t\t\t\tonFlushOk(msg.getSrc(), fh.viewID);\n\t\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH_OK) {\n\t\t\t\t\t\tonStopFlushOk(msg.getSrc());\n\t\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_COMPLETED) {\n\t\t\t\t\t\tonFlushCompleted(msg.getSrc(), fh.digest);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t\t\t+ \" received outdated FLUSH message \" + fh\n\t\t\t\t\t\t\t\t+ \",ignoring it.\");\n\t\t\t\t}\n\t\t\t\treturn null; // do not pass FLUSH msg up\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Event.VIEW_CHANGE:\n\t\t\t// if this is channel's first view and its the only member of the\n\t\t\t// group then the\n\t\t\t// goal is to pass BLOCK,VIEW,UNBLOCK to application space on the\n\t\t\t// same thread as VIEW.\n\t\t\tView newView = (View) evt.getArg();\n\t\t\tboolean firstView = onViewChange(newView);\n\t\t\tboolean singletonMember = newView.size() == 1\n\t\t\t\t\t&& newView.containsMember(localAddress);\n\t\t\tif (firstView && singletonMember) {\n\t\t\t\tup_prot.up(evt);\n\t\t\t\tsynchronized (blockMutex) {\n\t\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\t\tblockMutex.notifyAll();\n\t\t\t\t}\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"At \"\n\t\t\t\t\t\t\t+ localAddress\n\t\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Event.TMP_VIEW:\t\t\t\t\t\n\t\t\t/*\n\t\t\t * April 25, 2007\n\t\t\t * \n\t\t\t * Accomodating current NAKACK (1.127)\n\t\t\t * \n\t\t\t * Updates field currentView of a leaving coordinator.\n\t\t\t * Leaving coordinator, after it sends out the view,\n\t\t\t * does not need to participate in second flush phase.\n\t\t\t * \n\t\t\t * see onStopFlush();\n\t\t\t * \n\t\t\t * TODO: revisit if still needed post NAKACK 1.127\n\t\t\t *  \n\t\t\t */\n\t\t\tView tmpView = (View) evt.getArg();\n\t\t\tif(!tmpView.containsMember(localAddress)){\n\t\t\t\tonViewChange(tmpView);\n\t\t\t}\n\t\t\tbreak;\t\t\t\t\t\n\n\t\tcase Event.SET_LOCAL_ADDRESS:\n\t\t\tlocalAddress = (Address) evt.getArg();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPECT:\n\t\t\tonSuspect((Address) evt.getArg());\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5, false);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn up_prot.up(evt);\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean startFlush(long timeout) {\n\t\treturn startFlush(new Event(Event.SUSPEND), timeout, 5);\n\t}","id":86252,"modified_method":"public boolean startFlush(long timeout) {\n\t\treturn startFlush(new Event(Event.SUSPEND), timeout, 5, false);\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean hasVirtualSynchronyGaps() {\n\t\tArrayList <Digest> digests = new ArrayList<Digest>();\n\t\tsynchronized (sharedLock) {\n\t\t\tdigests.addAll(flushCompletedMap.values());\t\t\t\n\t\t}\n\t\tDigest firstDigest = digests.get(0);\n\t\tfor (Digest digest : digests) {\n\t\t\tDigest diff = firstDigest.difference(digest);\n\t\t\tif (diff != Digest.EMPTY_DIGEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\t\n\t}","id":86253,"modified_method":"private boolean hasVirtualSynchronyGaps() {\n\t\tArrayList <Digest> digests = new ArrayList<Digest>();\n\t\tdigests.addAll(flushCompletedMap.values());\t\t\t\t\t\n\t\tDigest firstDigest = digests.get(0);\n\t\tList<Digest> remainingDigests = digests.subList(1, digests.size());\n\t\tfor (Digest digest : remainingDigests) {\n\t\t\tDigest diff = firstDigest.difference(digest);\n\t\t\tif (diff != Digest.EMPTY_DIGEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\t\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onSuspend(View view) {\n\t\tMessage msg = null;\n\t\tCollection<Address> participantsInFlush = null;\n\t\tsynchronized (sharedLock) {\n\t\t\t// start FLUSH only on group members that we need to flush\n\t\t\tif (view != null) {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(view.getMembers());\n\t\t\t\tparticipantsInFlush.retainAll(currentView.getMembers());\n\t\t\t} else {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(currentView.getMembers());\n\t\t\t}\n\t\t\tmsg = new Message(null, localAddress, null);\n\t\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.START_FLUSH,\n\t\t\t\t\tcurrentViewId(), participantsInFlush));\n\t\t}\n\t\tif (participantsInFlush.isEmpty()) {\n\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t} else {\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received SUSPEND at \" + localAddress\n\t\t\t\t\t\t+ \", sent START_FLUSH to \" + participantsInFlush);\n\t\t}\n\t}","id":86254,"modified_method":"private void onSuspend(View view) {\n\t\tMessage msg = null;\n\t\tCollection<Address> participantsInFlush = null;\n\t\tsynchronized (sharedLock) {\n\t\t\t// start FLUSH only on group members that we need to flush\n\t\t\tif (view != null) {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(view.getMembers());\n\t\t\t\tparticipantsInFlush.retainAll(currentView.getMembers());\n\t\t\t} else {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(currentView.getMembers());\n\t\t\t}\n\t\t\tmsg = new Message(null, localAddress, null);\n\t\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.START_FLUSH,\n\t\t\t\t\tcurrentViewId(), participantsInFlush));\n\t\t}\n\t\tif (participantsInFlush.isEmpty()) {\n\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t} else {\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Flush coordinator \" + localAddress\n\t\t\t\t\t\t+ \" is starting FLUSH with participants \" + participantsInFlush);\n\t\t}\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStopFlush() {\n\t\tflushPhase.transitionToSecondPhase();\n\t\tif (stats) {\n\t\t\tlong stopFlushTime = System.currentTimeMillis();\n\t\t\ttotalTimeInFlush += (stopFlushTime - startFlushTime);\n\t\t\tif (numberOfFlushes > 0) {\n\t\t\t\taverageFlushDuration = totalTimeInFlush / (double) numberOfFlushes;\n\t\t\t}\n\t\t}\n\t\t// ack this STOP_FLUSH\n\t\tMessage msg = new Message(null, localAddress, null);\n\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH_OK,currentViewId()));\n\t\tdown_prot.down(new Event(Event.MSG, msg));\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Received STOP_FLUSH and sent STOP_FLUSH_OK from \"\n\t\t\t\t\t+ localAddress);\n\t}","id":86255,"modified_method":"private void onStopFlush() {\n\t\tflushPhase.transitionToSecondPhase();\n\t\tif (stats) {\n\t\t\tlong stopFlushTime = System.currentTimeMillis();\n\t\t\ttotalTimeInFlush += (stopFlushTime - startFlushTime);\n\t\t\tif (numberOfFlushes > 0) {\n\t\t\t\taverageFlushDuration = totalTimeInFlush / (double) numberOfFlushes;\n\t\t\t}\n\t\t}\t\n\t\t\n\t\t/*\n\t\t * April 25, 2007\n\t\t * \n\t\t * Accomodating current NAKACK (1.127)\n\t\t *\n\t\t * ack this STOP_FLUSH only if we are surviving member\n\t\t * otherwise we get runtime exception from NAKACK\n\t\t * \n\t\t * TODO: revisit if still needed post NAKACK 1.127 \n\t\t *  \n\t\t */\n\t\tboolean amISurvivingMember = false;\t\t\n\t\tsynchronized(sharedLock){\n\t\t\tamISurvivingMember = currentView.containsMember(localAddress);\t\t\t\t\t\n\t\t}\n\t\tif(amISurvivingMember){\n\t\t\tMessage msg = new Message(null, localAddress, null);\n\t\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH_OK,currentViewId()));\t\t\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received STOP_FLUSH and sent STOP_FLUSH_OK from \"\n\t\t\t\t\t\t+ localAddress);\n\t\t}\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private Digest findHighestSequences() {\n\t\tDigest result = null;\n\t\tsynchronized (sharedLock) {\n\t\t\tList<Digest> digests = new ArrayList<Digest>(flushCompletedMap.values());\n\n            result =digests.get(0);\n\t\t\tList<Digest> remainingDigests = digests.subList(1, digests.size());\n\n\t\t\tfor (Digest digestG : remainingDigests) {\n\t\t\t\tresult = result.highestSequence(digestG);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":86256,"modified_method":"private Digest findHighestSequences() {\n\t\tDigest result = null;\t\t\n\t\tList<Digest> digests = new ArrayList<Digest>(flushCompletedMap.values());\n\n        result =digests.get(0);\n\t\tList<Digest> remainingDigests = digests.subList(1, digests.size());\n\n\t\tfor (Digest digestG : remainingDigests) {\n\t\t\tresult = result.highestSequence(digestG);\n\t\t}\t\t\n\t\treturn result;\n\t}","commit_id":"8e8db73d3539530d460448124eb228f99c66da85","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushOk(Address address, long viewID) {\n\n\t\tboolean flushOkCompleted = false;\n\t\tboolean amIParticipant = false;\n\t\tMessage m = null;\n\t\tsynchronized (sharedLock) {\n\t\t\tamIParticipant = flushMembers.contains(address);\n\t\t\tflushOkSet.add(address);\n\t\t\tflushOkCompleted = flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator);\n\t\t\t}\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address\n\t\t\t\t\t+ \",completed \" + flushOkCompleted + \",  flushOkSet \"\n\t\t\t\t\t+ flushOkSet.toString());\n\n\t\tif (flushOkCompleted && amIParticipant) {\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = true;\n\t\t\t}\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t+ \" is blocking FLUSH.down(). Sent FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t}\n\t}","id":86257,"modified_method":"private void onFlushOk(Address address, long viewID) {\n\n\t\tboolean flushOkCompleted = false;\n\t\tboolean amIParticipant = false;\n\t\tMessage m = null;\n\t\tsynchronized (sharedLock) {\n\t\t\tamIParticipant = flushMembers.contains(address);\n\t\t\tflushOkSet.add(address);\n\t\t\tflushOkCompleted = flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator);\n\t\t\t}\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_OK from \" + address\n\t\t\t\t\t\t+ \",completed \" + flushOkCompleted + \",  flushOkSet \"\n\t\t\t\t\t\t+ flushOkSet);\t\n\t\t}\t\t\n\n\t\tif (flushOkCompleted && amIParticipant) {\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = true;\n\t\t\t}\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t+ \" is blocking FLUSH.down(). Sending FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\t\n\t\t}\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStopFlushOk(Address address) {\n\n\t\tboolean stopFlushOkCompleted = false;\n\t\tsynchronized (sharedLock) {\n\t\t\tstopFlushOkSet.add(address);\n\t\t\tTreeSet<Address> membersCopy = new TreeSet<Address>(currentView.getMembers());\n\t\t\tmembersCopy.removeAll(suspected);\n\t\t\tstopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address\n\t\t\t\t\t+ \",completed \" + stopFlushOkCompleted\n\t\t\t\t\t+ \",  stopFlushOkSet \" + stopFlushOkSet.toString());\n\n\t\tif (stopFlushOkCompleted) {\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tflushCompletedMap.clear();\n\t\t\t\tflushOkSet.clear();\n\t\t\t\tstopFlushOkSet.clear();\n\t\t\t\tflushMembers.clear();\n\t\t\t\tsuspected.clear();\n\t\t\t\tflushCoordinator = null;\n\t\t\t}\n\t\t\tflushPhase.transitionToStart();\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress\n\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\tblockMutex.notifyAll();\n\t\t\t}\n\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t}\n\t}","id":86258,"modified_method":"private void onStopFlushOk(Address address) {\n\n\t\tboolean stopFlushOkCompleted = false;\n\t\tsynchronized (sharedLock) {\n\t\t\tstopFlushOkSet.add(address);\n\t\t\tTreeSet<Address> membersCopy = new TreeSet<Address>(currentView.getMembers());\n\t\t\tmembersCopy.removeAll(suspected);\n\t\t\tstopFlushOkCompleted = stopFlushOkSet.containsAll(membersCopy);\n\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress + \" STOP_FLUSH_OK from \" + address\n\t\t\t\t\t\t+ \",completed \" + stopFlushOkCompleted\n\t\t\t\t\t\t+ \",  stopFlushOkSet \" + stopFlushOkSet);\n\t\t}\t\t\n\n\t\tif (stopFlushOkCompleted) {\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tflushPhase.transitionToStart();\n\t\t\t\tflushCompletedMap.clear();\n\t\t\t\tflushOkSet.clear();\n\t\t\t\tstopFlushOkSet.clear();\n\t\t\t\tflushMembers.clear();\n\t\t\t\tsuspected.clear();\n\t\t\t\tflushCoordinator = null;\t\t\t\n\t\t\t}\t\t\t\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress\n\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\tsynchronized (blockMutex) {\n\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\tblockMutex.notifyAll();\n\t\t\t}\n\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t}\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized byte transitionToFirstPhase() {\n\t\t\tbyte oldPhase = phase;\n\t\t\tif (oldPhase == START_PHASE) {\n\t\t\t\tphase = FIRST_PHASE;\n\t\t\t}\n\t\t\treturn oldPhase;\n\t\t}","id":86259,"modified_method":"public byte transitionToFirstPhase() {\n\t\t\tbyte oldPhase = -1;\n\t\t\tsynchronized(sharedLock){\n\t\t\t\toldPhase = phase;\n\t\t\t\tif(oldPhase == START_PHASE){\n\t\t\t\t\tphase = FIRST_PHASE;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn oldPhase;\n\t\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean hasVirtualSynchronyGaps() {\n\t\tArrayList <Digest> digests = new ArrayList<Digest>();\n\t\tsynchronized (sharedLock) {\n\t\t\tdigests.addAll(flushCompletedMap.values());\t\t\t\n\t\t}\n\t\tDigest firstDigest = digests.get(0);\n\t\tfor (Digest digest : digests) {\n\t\t\tDigest diff = firstDigest.difference(digest);\n\t\t\tif (diff != Digest.EMPTY_DIGEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\t\n\t}","id":86260,"modified_method":"private boolean hasVirtualSynchronyGaps() {\n\t\tArrayList <Digest> digests = new ArrayList<Digest>();\n\t\tdigests.addAll(flushCompletedMap.values());\t\t\t\t\t\n\t\tDigest firstDigest = digests.get(0);\n\t\tList<Digest> remainingDigests = digests.subList(1, digests.size());\n\t\tfor (Digest digest : remainingDigests) {\n\t\t\tDigest diff = firstDigest.difference(digest);\n\t\t\tif (diff != Digest.EMPTY_DIGEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\t\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onSuspend(View view) {\n\t\tMessage msg = null;\n\t\tCollection<Address> participantsInFlush = null;\n\t\tsynchronized (sharedLock) {\n\t\t\t// start FLUSH only on group members that we need to flush\n\t\t\tif (view != null) {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(view.getMembers());\n\t\t\t\tparticipantsInFlush.retainAll(currentView.getMembers());\n\t\t\t} else {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(currentView.getMembers());\n\t\t\t}\n\t\t\tmsg = new Message(null, localAddress, null);\n\t\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.START_FLUSH,\n\t\t\t\t\tcurrentViewId(), participantsInFlush));\n\t\t}\n\t\tif (participantsInFlush.isEmpty()) {\n\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t} else {\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received SUSPEND at \" + localAddress\n\t\t\t\t\t\t+ \", sent START_FLUSH to \" + participantsInFlush);\n\t\t}\n\t}","id":86261,"modified_method":"private void onSuspend(View view) {\n\t\tMessage msg = null;\n\t\tCollection<Address> participantsInFlush = null;\n\t\tsynchronized (sharedLock) {\n\t\t\t// start FLUSH only on group members that we need to flush\n\t\t\tif (view != null) {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(view.getMembers());\n\t\t\t\tparticipantsInFlush.retainAll(currentView.getMembers());\n\t\t\t} else {\n\t\t\t\tparticipantsInFlush = new ArrayList<Address>(currentView.getMembers());\n\t\t\t}\n\t\t\tmsg = new Message(null, localAddress, null);\n\t\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.START_FLUSH,\n\t\t\t\t\tcurrentViewId(), participantsInFlush));\n\t\t}\n\t\tif (participantsInFlush.isEmpty()) {\n\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t} else {\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Flush coordinator \" + localAddress\n\t\t\t\t\t\t+ \" is starting FLUSH with participants \" + participantsInFlush);\n\t\t}\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public FlushPhase() {\n\t\t}","id":86262,"modified_method":"FlushPhase() {\n\t\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object down(Event evt) {\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null && fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\treturn down_prot.down(evt);\n\t\t\t} else {\n\t\t\t\tblockMessageDuringFlush();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Event.GET_STATE:\n\t\t\tblockMessageDuringFlush();\n\t\t\tbreak;\n\n\t\tcase Event.CONNECT:\n\t\t\tsendBlockUpToChannel();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\t\t}\n\t\treturn down_prot.down(evt);\n\t}","id":86263,"modified_method":"public Object down(Event evt) {\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null && fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\treturn down_prot.down(evt);\n\t\t\t} else {\n\t\t\t\tblockMessageDuringFlush();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Event.GET_STATE:\n\t\t\tblockMessageDuringFlush();\n\t\t\tbreak;\n\n\t\tcase Event.CONNECT:\n\t\t\tsendBlockUpToChannel();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5, false);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\t\t}\n\t\treturn down_prot.down(evt);\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null) {\n\t\t\t\tif (fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\t\treturn up_prot.up(evt);\n\t\t\t\t} else if (fh.type == FlushHeader.START_FLUSH) {\n\t\t\t\t\thandleStartFlush(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE) {\n\t\t\t\t\thandleFlushReconcile(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE_OK) {\n\t\t\t\t\tonFlushReconcileOK(msg);\n\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH) {\t\t\t\t\t\n\t\t\t\t\tonStopFlush();\n\t\t\t\t} else if (fh.type == FlushHeader.ABORT_FLUSH) {\n\t\t\t\t\t// abort current flush\n\t\t\t\t\tflush_promise.setResult(Boolean.FALSE);\n\t\t\t\t} else if (isCurrentFlushMessage(fh)) {\n\t\t\t\t\tif (fh.type == FlushHeader.FLUSH_OK) {\n\t\t\t\t\t\tonFlushOk(msg.getSrc(), fh.viewID);\n\t\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH_OK) {\n\t\t\t\t\t\tonStopFlushOk(msg.getSrc());\n\t\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_COMPLETED) {\n\t\t\t\t\t\tonFlushCompleted(msg.getSrc(), fh.digest);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t\t\t+ \" received outdated FLUSH message \" + fh\n\t\t\t\t\t\t\t\t+ \",ignoring it.\");\n\t\t\t\t}\n\t\t\t\treturn null; // do not pass FLUSH msg up\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Event.VIEW_CHANGE:\n\t\t\t// if this is channel's first view and its the only member of the\n\t\t\t// group then the\n\t\t\t// goal is to pass BLOCK,VIEW,UNBLOCK to application space on the\n\t\t\t// same thread as VIEW.\n\t\t\tView newView = (View) evt.getArg();\n\t\t\tboolean firstView = onViewChange(newView);\n\t\t\tboolean singletonMember = newView.size() == 1\n\t\t\t\t\t&& newView.containsMember(localAddress);\n\t\t\tif (firstView && singletonMember) {\n\t\t\t\tup_prot.up(evt);\n\t\t\t\tsynchronized (blockMutex) {\n\t\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\t\tblockMutex.notifyAll();\n\t\t\t\t}\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"At \"\n\t\t\t\t\t\t\t+ localAddress\n\t\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Event.SET_LOCAL_ADDRESS:\n\t\t\tlocalAddress = (Address) evt.getArg();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPECT:\n\t\t\tonSuspect((Address) evt.getArg());\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn up_prot.up(evt);\n\t}","id":86264,"modified_method":"public Object up(Event evt) {\n\n\t\tswitch (evt.getType()) {\n\t\tcase Event.MSG:\n\t\t\tMessage msg = (Message) evt.getArg();\n\t\t\tFlushHeader fh = (FlushHeader) msg.getHeader(getName());\n\t\t\tif (fh != null) {\n\t\t\t\tif (fh.type == FlushHeader.FLUSH_BYPASS) {\n\t\t\t\t\treturn up_prot.up(evt);\n\t\t\t\t} else if (fh.type == FlushHeader.START_FLUSH) {\n\t\t\t\t\thandleStartFlush(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE) {\n\t\t\t\t\thandleFlushReconcile(msg, fh);\n\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_RECONCILE_OK) {\n\t\t\t\t\tonFlushReconcileOK(msg);\n\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH) {\t\t\t\t\t\n\t\t\t\t\tonStopFlush();\n\t\t\t\t} else if (fh.type == FlushHeader.ABORT_FLUSH) {\n\t\t\t\t\t// abort current flush\n\t\t\t\t\tflush_promise.setResult(Boolean.FALSE);\n\t\t\t\t} else if (isCurrentFlushMessage(fh)) {\n\t\t\t\t\tif (fh.type == FlushHeader.FLUSH_OK) {\n\t\t\t\t\t\tonFlushOk(msg.getSrc(), fh.viewID);\n\t\t\t\t\t} else if (fh.type == FlushHeader.STOP_FLUSH_OK) {\n\t\t\t\t\t\tonStopFlushOk(msg.getSrc());\n\t\t\t\t\t} else if (fh.type == FlushHeader.FLUSH_COMPLETED) {\n\t\t\t\t\t\tonFlushCompleted(msg.getSrc(), fh.digest);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t\tlog.debug(localAddress\n\t\t\t\t\t\t\t\t+ \" received outdated FLUSH message \" + fh\n\t\t\t\t\t\t\t\t+ \",ignoring it.\");\n\t\t\t\t}\n\t\t\t\treturn null; // do not pass FLUSH msg up\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Event.VIEW_CHANGE:\n\t\t\t// if this is channel's first view and its the only member of the\n\t\t\t// group then the\n\t\t\t// goal is to pass BLOCK,VIEW,UNBLOCK to application space on the\n\t\t\t// same thread as VIEW.\n\t\t\tView newView = (View) evt.getArg();\n\t\t\tboolean firstView = onViewChange(newView);\n\t\t\tboolean singletonMember = newView.size() == 1\n\t\t\t\t\t&& newView.containsMember(localAddress);\n\t\t\tif (firstView && singletonMember) {\n\t\t\t\tup_prot.up(evt);\n\t\t\t\tsynchronized (blockMutex) {\n\t\t\t\t\tisBlockingFlushDown = false;\n\t\t\t\t\tblockMutex.notifyAll();\n\t\t\t\t}\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"At \"\n\t\t\t\t\t\t\t+ localAddress\n\t\t\t\t\t\t\t+ \" unblocking FLUSH.down() and sending UNBLOCK up\");\n\n\t\t\t\tup_prot.up(new Event(Event.UNBLOCK));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Event.TMP_VIEW:\t\t\t\t\t\n\t\t\t/*\n\t\t\t * April 25, 2007\n\t\t\t * \n\t\t\t * Accomodating current NAKACK (1.127)\n\t\t\t * \n\t\t\t * Updates field currentView of a leaving coordinator.\n\t\t\t * Leaving coordinator, after it sends out the view,\n\t\t\t * does not need to participate in second flush phase.\n\t\t\t * \n\t\t\t * see onStopFlush();\n\t\t\t * \n\t\t\t * TODO: revisit if still needed post NAKACK 1.127\n\t\t\t *  \n\t\t\t */\n\t\t\tView tmpView = (View) evt.getArg();\n\t\t\tif(!tmpView.containsMember(localAddress)){\n\t\t\t\tonViewChange(tmpView);\n\t\t\t}\n\t\t\tbreak;\t\t\t\t\t\n\n\t\tcase Event.SET_LOCAL_ADDRESS:\n\t\t\tlocalAddress = (Address) evt.getArg();\n\t\t\tbreak;\n\n\t\tcase Event.SUSPECT:\n\t\t\tonSuspect((Address) evt.getArg());\n\t\t\tbreak;\n\n\t\tcase Event.SUSPEND:\n\t\t\treturn startFlush(evt, 4000, 5, false);\n\n\t\tcase Event.RESUME:\n\t\t\tonResume();\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn up_prot.up(evt);\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void transitionToStart() {\n\t\t\tphase = START_PHASE;\n\t\t}","id":86265,"modified_method":"public void transitionToStart() {\n\t\t\tsynchronized(sharedLock){\n\t\t\t\tphase = START_PHASE;\n\t\t\t}\n\t\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleStartFlush(Message msg, FlushHeader fh) {\n\t\tbyte oldPhase = flushPhase.transitionToFirstPhase();\n\t\tif (oldPhase == FlushPhase.START_PHASE) {\n\t\t\tsendBlockUpToChannel();\n\t\t\tonStartFlush(msg.getSrc(), fh);\n\t\t} else if (oldPhase == FlushPhase.FIRST_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\tAddress coordinator = null;\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tcoordinator = flushCoordinator;\n\t\t\t}\n\n\t\t\tif (coordinator == null || flushRequester.compareTo(coordinator) < 0) {\n\t\t\t\trejectFlush(fh.viewID, coordinator);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to current flush coordinator \" + coordinator\n\t\t\t\t\t\t\t+ \" and switching flush coordinator to \"\n\t\t\t\t\t\t\t+ flushRequester);\n\t\t\t\t}\n\t\t\t\tsynchronized (sharedLock) {\n\t\t\t\t\tflushCoordinator = flushRequester;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to flush requester \" + flushRequester);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (oldPhase == FlushPhase.SECOND_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Rejecting flush in second phase at \" + localAddress\n\t\t\t\t\t\t+ \" to flush requester \" + flushRequester);\n\t\t\t}\n\t\t}\n\t}","id":86266,"modified_method":"private void handleStartFlush(Message msg, FlushHeader fh) {\n\t\tbyte oldPhase = flushPhase.transitionToFirstPhase();\n\t\tif (oldPhase == FlushPhase.START_PHASE) {\n\t\t\tsendBlockUpToChannel();\n\t\t\tonStartFlush(msg.getSrc(), fh);\n\t\t} else if (oldPhase == FlushPhase.FIRST_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\tAddress coordinator = null;\n\t\t\tsynchronized (sharedLock) {\n\t\t\t\tif(flushCoordinator != null)\n\t\t\t\t\tcoordinator = flushCoordinator;\n\t\t\t\telse\n\t\t\t\t\tcoordinator = flushRequester;\n\t\t\t}\n\n\t\t\tif (flushRequester.compareTo(coordinator) < 0) {\n\t\t\t\trejectFlush(fh.viewID, coordinator);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to current flush coordinator \" + coordinator\n\t\t\t\t\t\t\t+ \" and switching flush coordinator to \"\n\t\t\t\t\t\t\t+ flushRequester);\n\t\t\t\t}\n\t\t\t\tsynchronized (sharedLock) {\n\t\t\t\t\tflushCoordinator = flushRequester;\n\t\t\t\t}\n\t\t\t} else if (flushRequester.compareTo(coordinator) > 0)  {\n\t\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Rejecting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \" to flush requester \" + flushRequester + \" coordinator is \" + coordinator);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flushRequester.equals(coordinator)){\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"Accepting flush at \" + localAddress\n\t\t\t\t\t\t\t+ \", proceeding with flush\");\n\t\t\t\t}\n\t\t\t\tonStartFlush(msg.getSrc(), fh);\n\t\t\t}\n\t\t} else if (oldPhase == FlushPhase.SECOND_PHASE) {\n\t\t\tAddress flushRequester = msg.getSrc();\n\t\t\trejectFlush(fh.viewID, flushRequester);\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Rejecting flush in second phase at \" + localAddress\n\t\t\t\t\t\t+ \" to flush requester \" + flushRequester);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private Digest findHighestSequences() {\n\t\tDigest result = null;\n\t\tsynchronized (sharedLock) {\n\t\t\tList<Digest> digests = new ArrayList<Digest>(flushCompletedMap.values());\n\n            result =digests.get(0);\n\t\t\tList<Digest> remainingDigests = digests.subList(1, digests.size());\n\n\t\t\tfor (Digest digestG : remainingDigests) {\n\t\t\t\tresult = result.highestSequence(digestG);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":86267,"modified_method":"private Digest findHighestSequences() {\n\t\tDigest result = null;\t\t\n\t\tList<Digest> digests = new ArrayList<Digest>(flushCompletedMap.values());\n\n        result =digests.get(0);\n\t\tList<Digest> remainingDigests = digests.subList(1, digests.size());\n\n\t\tfor (Digest digestG : remainingDigests) {\n\t\t\tresult = result.highestSequence(digestG);\n\t\t}\t\t\n\t\treturn result;\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onSuspect(Address address) {\n\t\tboolean flushOkCompleted = false;\n\t\tMessage m = null;\n\t\tlong viewID = 0;\n\t\tsynchronized (sharedLock) {\n\t\t\tsuspected.add(address);\n\t\t\tflushMembers.removeAll(suspected);\n\t\t\tviewID = currentViewId();\n\t\t\tflushOkCompleted = !flushOkSet.isEmpty() && flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator, localAddress, null);\n\t\t\t}\n\t\t}\n\t\tif (flushOkCompleted) {\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress + \" sent FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t}\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Suspect is \" + address + \",completed \"\n\t\t\t\t\t+ flushOkCompleted + \",  flushOkSet \" + flushOkSet\n\t\t\t\t\t+ \" flushMembers \" + flushMembers);\n\t}","id":86268,"modified_method":"private void onSuspect(Address address) {\n\t\tboolean flushOkCompleted = false;\n\t\tMessage m = null;\n\t\tlong viewID = 0;\n\t\tsynchronized (sharedLock) {\n\t\t\tsuspected.add(address);\n\t\t\tflushMembers.removeAll(suspected);\n\t\t\tviewID = currentViewId();\n\t\t\tflushOkCompleted = !flushOkSet.isEmpty() && flushOkSet.containsAll(flushMembers);\n\t\t\tif (flushOkCompleted) {\n\t\t\t\tm = new Message(flushCoordinator, localAddress, null);\n\t\t\t}\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Suspect is \" + address + \",completed \"\n\t\t\t\t\t\t+ flushOkCompleted + \",  flushOkSet \" + flushOkSet\n\t\t\t\t\t\t+ \" flushMembers \" + flushMembers);\n\t\t}\n\t\tif (flushOkCompleted) {\n\t\t\tDigest digest = (Digest) down_prot.down(new Event(Event.GET_DIGEST));\n\t\t\tFlushHeader fh = new FlushHeader(FlushHeader.FLUSH_COMPLETED,viewID);\n\t\t\tfh.addDigest(digest);\n\t\t\tm.putHeader(getName(), fh);\n\t\t\tdown_prot.down(new Event(Event.MSG, m));\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(localAddress + \" sent FLUSH_COMPLETED message to \"\n\t\t\t\t\t\t+ flushCoordinator);\n\t\t}\t\t\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void transitionToSecondPhase() {\n\t\t\tphase = SECOND_PHASE;\n\t\t}","id":86269,"modified_method":"public void transitionToSecondPhase() {\n\t\t\tsynchronized(sharedLock){\n\t\t\t\tphase = SECOND_PHASE;\n\t\t\t}\n\t\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onStopFlush() {\n\t\tflushPhase.transitionToSecondPhase();\n\t\tif (stats) {\n\t\t\tlong stopFlushTime = System.currentTimeMillis();\n\t\t\ttotalTimeInFlush += (stopFlushTime - startFlushTime);\n\t\t\tif (numberOfFlushes > 0) {\n\t\t\t\taverageFlushDuration = totalTimeInFlush / (double) numberOfFlushes;\n\t\t\t}\n\t\t}\n\t\t// ack this STOP_FLUSH\n\t\tMessage msg = new Message(null, localAddress, null);\n\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH_OK,currentViewId()));\n\t\tdown_prot.down(new Event(Event.MSG, msg));\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"Received STOP_FLUSH and sent STOP_FLUSH_OK from \"\n\t\t\t\t\t+ localAddress);\n\t}","id":86270,"modified_method":"private void onStopFlush() {\n\t\tflushPhase.transitionToSecondPhase();\n\t\tif (stats) {\n\t\t\tlong stopFlushTime = System.currentTimeMillis();\n\t\t\ttotalTimeInFlush += (stopFlushTime - startFlushTime);\n\t\t\tif (numberOfFlushes > 0) {\n\t\t\t\taverageFlushDuration = totalTimeInFlush / (double) numberOfFlushes;\n\t\t\t}\n\t\t}\t\n\t\t\n\t\t/*\n\t\t * April 25, 2007\n\t\t * \n\t\t * Accomodating current NAKACK (1.127)\n\t\t *\n\t\t * ack this STOP_FLUSH only if we are surviving member\n\t\t * otherwise we get runtime exception from NAKACK\n\t\t * \n\t\t * TODO: revisit if still needed post NAKACK 1.127 \n\t\t *  \n\t\t */\n\t\tboolean amISurvivingMember = false;\t\t\n\t\tsynchronized(sharedLock){\n\t\t\tamISurvivingMember = currentView.containsMember(localAddress);\t\t\t\t\t\n\t\t}\n\t\tif(amISurvivingMember){\n\t\t\tMessage msg = new Message(null, localAddress, null);\n\t\t\tmsg.putHeader(getName(), new FlushHeader(FlushHeader.STOP_FLUSH_OK,currentViewId()));\t\t\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received STOP_FLUSH and sent STOP_FLUSH_OK from \"\n\t\t\t\t\t\t+ localAddress);\n\t\t}\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized boolean isFlushInProgress() {\n\t\t\treturn phase != START_PHASE;\n\t\t}","id":86271,"modified_method":"public boolean isFlushInProgress() {\n\t\t\tsynchronized(sharedLock){\n\t\t\t\treturn phase != START_PHASE;\n\t\t\t}\n\t\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean startFlush(Event evt, long timeout, int numberOfAttempts) {\n\t\tboolean successfulFlush = false;\n\t\tif (!flushPhase.isFlushInProgress()) {\n\t\t\tflush_promise.reset();\n\t\t\tView v = (View) evt.getArg();\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received SUSPEND at \" + localAddress + \", view is \"+ v);\n\n\t\t\tonSuspend(v);\n\t\t\ttry {\n\t\t\t\tBoolean r = (Boolean) flush_promise.getResultWithTimeout(timeout);\n\t\t\t\tsuccessfulFlush = r.booleanValue();\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"At \" + localAddress\n\t\t\t\t\t\t\t+ \" timed out waiting for flush responses after \"\n\t\t\t\t\t\t\t+ timeout + \" msec\");\n\t\t\t}\n\t\t}\n\n\t\tif (!successfulFlush && numberOfAttempts > 0) {\n\t\t\tlong backOffSleepTime = Util.random(5);\n\t\t\tbackOffSleepTime = backOffSleepTime < 2 ? backOffSleepTime + 2: backOffSleepTime;\n\t\t\tif (log.isInfoEnabled())\n\t\t\t\tlog.info(\"At \" + localAddress + \". Backing off for \"\n\t\t\t\t\t\t+ backOffSleepTime + \" sec. Attempts left \"\n\t\t\t\t\t\t+ numberOfAttempts);\n\n\t\t\tUtil.sleep(backOffSleepTime * 1000);\n\t\t\tsuccessfulFlush = startFlush(evt, timeout, --numberOfAttempts);\n\t\t}\n\t\treturn successfulFlush;\n\t}","id":86272,"modified_method":"private boolean startFlush(Event evt, long timeout, int numberOfAttempts, boolean isRetry) {\n\t\tboolean successfulFlush = false;\n\t\tif (!flushPhase.isFlushInProgress() || isRetry) {\n\t\t\tflush_promise.reset();\n\t\t\tView v = (View) evt.getArg();\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Received SUSPEND at \" + localAddress + \", view is \"+ v);\n\n\t\t\tonSuspend(v);\n\t\t\ttry {\n\t\t\t\tBoolean r = (Boolean) flush_promise.getResultWithTimeout(timeout);\n\t\t\t\tsuccessfulFlush = r.booleanValue();\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"At \" + localAddress\n\t\t\t\t\t\t\t+ \" timed out waiting for flush responses after \"\n\t\t\t\t\t\t\t+ timeout + \" msec\");\n\t\t\t}\n\t\t}\n\n\t\tif (!successfulFlush && numberOfAttempts > 0) {\n\t\t\tlong backOffSleepTime = Util.random(5);\n\t\t\tbackOffSleepTime = backOffSleepTime < 2 ? backOffSleepTime + 2: backOffSleepTime;\n\t\t\tif (log.isInfoEnabled())\n\t\t\t\tlog.info(\"At \" + localAddress + \". Backing off for \"\n\t\t\t\t\t\t+ backOffSleepTime + \" sec. Attempts left \"\n\t\t\t\t\t\t+ numberOfAttempts);\n\n\t\t\tUtil.sleep(backOffSleepTime * 1000);\n\t\t\tsuccessfulFlush = startFlush(evt, timeout, --numberOfAttempts, true);\n\t\t}\n\t\treturn successfulFlush;\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean startFlush(long timeout) {\n\t\treturn startFlush(new Event(Event.SUSPEND), timeout, 5);\n\t}","id":86273,"modified_method":"public boolean startFlush(long timeout) {\n\t\treturn startFlush(new Event(Event.SUSPEND), timeout, 5, false);\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private void onFlushCompleted(Address address, Digest digest) {\n\t\tboolean flushCompleted = false;\n\t\tsynchronized (sharedLock) {\n\t\t\tflushCompletedMap.put(address, digest);\n\t\t\tif (flushCompletedMap.size() >= flushMembers.size()) {\n\t\t\t\tflushCompleted = flushCompletedMap.keySet().containsAll(\n\t\t\t\t\t\tflushMembers);\n\t\t\t}\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address\n\t\t\t\t\t+ \",completed \" + flushCompleted + \",flushCompleted \"\n\t\t\t\t\t+ flushCompletedMap.keySet());\n\n\t\tif (flushCompleted) {\n\t\t\tif (hasVirtualSynchronyGaps()) {\n\t\t\t\tDigest d = findHighestSequences();\n\t\t\t\tMessage msg = new Message();\n\t\t\t\tmsg.setFlag(Message.OOB);\n\t\t\t\tsynchronized (sharedLock) {\n\t\t\t\t\tFlushHeader fh = new FlushHeader(\n\t\t\t\t\t\t\tFlushHeader.FLUSH_RECONCILE, currentViewId(),\n\t\t\t\t\t\t\tflushMembers);\n\t\t\t\t\treconcileOks.clear();\n\t\t\t\t\tfh.addDigest(d);\n\t\t\t\t\tmsg.putHeader(getName(), fh);\n\t\t\t\t}\n\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"Reconciling flush mebers due to virtual synchrony gap, digest is \"\n\t\t\t\t\t\t\t\t\t+ d + \" flush members are \" + flushMembers);\n\n\t\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t\t} else {\n\t\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"All FLUSH_COMPLETED received at \"\n\t\t\t\t\t\t\t\t\t+ localAddress);\n\t\t\t}\n\t\t}\n\t}","id":86274,"modified_method":"private void onFlushCompleted(Address address, Digest digest) {\n\t\tboolean flushCompleted = false;\n\t\tMessage msg = null;\n\t\tboolean needsReconciliationPhase = false;\t\t\n\t\tsynchronized (sharedLock) {\n\t\t\tflushCompletedMap.put(address, digest);\n\t\t\tif (flushCompletedMap.size() >= flushMembers.size()) {\n\t\t\t\tflushCompleted = flushCompletedMap.keySet().containsAll(\n\t\t\t\t\t\tflushMembers);\n\t\t\t}\n\t\t\t\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"At \" + localAddress + \" FLUSH_COMPLETED from \" + address\n\t\t\t\t\t\t+ \",completed \" + flushCompleted + \",flushCompleted \"\n\t\t\t\t\t\t+ flushCompletedMap.keySet());\n\t\t\t\n\t\t\tneedsReconciliationPhase = flushCompleted && hasVirtualSynchronyGaps();\n\t\t\tif (needsReconciliationPhase){\n\t\t\t\t\n\t\t\t\tDigest d = findHighestSequences();\t\t\t\n\t\t\t\tmsg = new Message();\n\t\t\t\tmsg.setFlag(Message.OOB);\t\t\t\t\n\t\t\t\tFlushHeader fh = new FlushHeader(\n\t\t\t\t\t\tFlushHeader.FLUSH_RECONCILE, currentViewId(),\n\t\t\t\t\t\tflushMembers);\n\t\t\t\treconcileOks.clear();\n\t\t\t\tfh.addDigest(d);\n\t\t\t\tmsg.putHeader(getName(), fh);\n\t\t\t\t\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"Reconciling flush mebers due to virtual synchrony gap, digest is \"\n\t\t\t\t\t\t\t\t\t+ d + \" flush members are \" + flushMembers);\n\t\t\t\t\n\t\t\t\tflushCompletedMap.clear();\n\t\t\t}\n\t\t}\t\n\t\tif(needsReconciliationPhase){\n\t\t\tdown_prot.down(new Event(Event.MSG, msg));\n\t\t}else if(flushCompleted){\n\t\t\tflush_promise.setResult(Boolean.TRUE);\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"All FLUSH_COMPLETED received at \"\n\t\t\t\t\t\t\t\t+ localAddress);\n\t\t}\t\t\n\t}","commit_id":"e2d07e2612a47f660ef9f73fcc09e03d219ddce9","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean writeRowToFile(Row r)\r\n\t{\r\n\t\tValue v;\r\n\t\t\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\tif (first)\r\n\t\t\t{\r\n\t\t\t\tfirst=false;\r\n\t\t\t\tif (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) // See if we have to write a header-line)\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.headerrow=new Row(r); // copy the row for the footer!\r\n\t\t\t\t\tif (meta.isHeaderEnabled())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (writeHeader()) return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tdata.fieldnrs=new int[meta.getOutputFields().length];\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.fieldnrs[i]=r.searchValueIndex(meta.getOutputFields()[i].getName());\r\n\t\t\t\t\tif (data.fieldnrs[i]<0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlogError(\"Field [\"+meta.getOutputFields()[i].getName()+\"] couldn't be found in the input stream!\");\r\n\t\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\t\tstopAll();\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (meta.getOutputFields()==null || meta.getOutputFields().length==0)\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Write all values in stream to text file.\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<r.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0) data.writer.write(meta.getSeparator().toCharArray());\r\n\t\t\t\t\tv=r.getValue(i);\r\n\t\t\t\t\tif(!writeField(v, -1)) return false;\r\n\t\t\t\t}\r\n                data.writer.write(meta.getNewline().toCharArray());\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Only write the fields specified!\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0) data.writer.write(meta.getSeparator().toCharArray());\r\n\t\r\n\t\t\t\t\tv=r.getValue(data.fieldnrs[i]);\r\n\t\t\t\t\tv.setLength(meta.getOutputFields()[i].getLength(), meta.getOutputFields()[i].getPrecision());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(!writeField(v, i)) return false;\r\n\t\t\t\t}\r\n                data.writer.write(meta.getNewline().toCharArray());\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing line :\"+e.toString());\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlinesOutput++;\r\n\t\t\r\n\t\treturn true;\r\n\t}","id":86275,"modified_method":"private boolean writeRowToFile(Row r)\r\n\t{\r\n\t\tValue v;\r\n\t\t\r\n\t\ttry\r\n\t\t{\t\r\n\t\t\tif (first)\r\n\t\t\t{\r\n\t\t\t\tfirst=false;\r\n\t\t\t\tif (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) // See if we have to write a header-line)\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.headerrow=new Row(r); // copy the row for the footer!\r\n\t\t\t\t\tif (meta.isHeaderEnabled() && data.headerrow!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (writeHeader() )\r\n                        {\r\n\t\t\t\t\t\t\treturn false;\r\n                        }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tdata.fieldnrs=new int[meta.getOutputFields().length];\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.fieldnrs[i]=r.searchValueIndex(meta.getOutputFields()[i].getName());\r\n\t\t\t\t\tif (data.fieldnrs[i]<0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlogError(\"Field [\"+meta.getOutputFields()[i].getName()+\"] couldn't be found in the input stream!\");\r\n\t\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\t\tstopAll();\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (meta.getOutputFields()==null || meta.getOutputFields().length==0)\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Write all values in stream to text file.\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<r.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0) data.writer.write(meta.getSeparator().toCharArray());\r\n\t\t\t\t\tv=r.getValue(i);\r\n\t\t\t\t\tif(!writeField(v, -1)) return false;\r\n\t\t\t\t}\r\n                data.writer.write(meta.getNewline().toCharArray());\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t/*\r\n\t\t\t\t * Only write the fields specified!\r\n\t\t\t\t */\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0) data.writer.write(meta.getSeparator().toCharArray());\r\n\t\r\n\t\t\t\t\tv=r.getValue(data.fieldnrs[i]);\r\n\t\t\t\t\tv.setLength(meta.getOutputFields()[i].getLength(), meta.getOutputFields()[i].getPrecision());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(!writeField(v, i)) return false;\r\n\t\t\t\t}\r\n                data.writer.write(meta.getNewline().toCharArray());\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing line :\"+e.toString());\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlinesOutput++;\r\n\t\t\r\n\t\treturn true;\r\n\t}","commit_id":"c0b0e2c51b624ad2b2c54ac3468dd26220d7d073","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tRow r;\r\n\t\tboolean result=true;\r\n\t\tboolean bEndedLineWrote=false;\r\n\t\tr=getRow();       // This also waits for a row to be finished.\r\n\t\t\r\n\t\tif ( ( r==null && data.headerrow!=null && meta.isFooterEnabled() ) ||\r\n\t\t     ( r!=null && linesOutput>0 && meta.getSplitEvery()>0 && (linesOutput%meta.getSplitEvery())==0)\r\n\t\t   )\r\n\t\t{\r\n\t\t\tif (writeHeader()) linesOutput++;\r\n\t\t\t\r\n\t\t\tif (r==null)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t// Done with this part or with everything.\r\n\t\t\tcloseFile();\r\n\t\t\t\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (meta.isHeaderEnabled() && data.headerrow!=null) if (writeHeader()) linesOutput++;\r\n\t\t\t}\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tif (false==bEndedLineWrote)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tresult=writeRowToFile(r);\r\n\t\tif (!result)\r\n\t\t{\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tputRow(r);       // in case we want it to go further...\r\n\t\t\r\n\t\tif ((linesOutput>0) && (linesOutput%Const.ROWS_UPDATE)==0)logBasic(\"linenr \"+linesOutput);\r\n\t\t\r\n\t\treturn result;\r\n\t}","id":86276,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tRow r;\r\n\t\tboolean result=true;\r\n\t\tboolean bEndedLineWrote=false;\r\n\t\tr=getRow();       // This also waits for a row to be finished.\r\n\t\t\r\n\t\tif ( ( r==null && data.headerrow!=null && meta.isFooterEnabled() ) ||\r\n\t\t     ( r!=null && linesOutput>0 && meta.getSplitEvery()>0 && ((linesOutput+1)%meta.getSplitEvery())==0)\r\n\t\t   )\r\n\t\t{\r\n\t\t\tif (data.headerrow!=null) \r\n\t\t\t{\r\n\t\t\t   if ( meta.isFooterEnabled() )\r\n\t\t\t   {\r\n\t\t\t      writeHeader();\r\n\t\t\t   }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (r==null)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t// Done with this part or with everything.\r\n\t\t\tcloseFile();\r\n\t\t\t\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (meta.isHeaderEnabled() && data.headerrow!=null) if (writeHeader()) linesOutput++;\r\n\t\t\t}\r\n\t\t\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tif (false==bEndedLineWrote)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tresult=writeRowToFile(r);\r\n\t\tif (!result)\r\n\t\t{\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tputRow(r);       // in case we want it to go further...\r\n\t\t\r\n\t\tif ((linesOutput>0) && (linesOutput%Const.ROWS_UPDATE)==0)logBasic(\"linenr \"+linesOutput);\r\n\t\t\r\n\t\treturn result;\r\n\t}","commit_id":"c0b0e2c51b624ad2b2c54ac3468dd26220d7d073","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/** Puts a header given a key into the hashmap. Overwrites potential existing entry. */\n    public void putHeader(String key, Header hdr) {\n        headers.put(key, hdr);\n    }","id":86277,"modified_method":"/** Puts a header given a key into the hashmap. Overwrites potential existing entry. */\n    public void putHeader(String key, Header hdr) {\n        headers.putHeader(key, hdr);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers) to the output stream.\n     * @param out\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        byte leading=0;\n\n        if(src_addr != null) {\n            leading+=SRC_SET;\n            if(src_addr instanceof IpAddress) {\n                leading+=IPADDR_SRC;\n                if(((IpAddress)src_addr).getIpAddress() == null) {\n                    leading+=SRC_HOST_NULL;\n                }\n            }\n        }\n        if(buf != null)\n            leading+=BUF_SET;\n\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr\n        if(src_addr != null) {\n            if(src_addr instanceof IpAddress) {\n                src_addr.writeTo(out);\n            }\n            else {\n                Util.writeAddress(src_addr, out);\n            }\n        }\n\n        // 4. buf\n        if(buf != null) {\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 5. headers\n        int size=headers.size();\n        out.writeShort(size);\n        Map.Entry        entry;\n        for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            out.writeUTF((String)entry.getKey());\n            writeHeader((Header)entry.getValue(), out);\n        }\n    }","id":86278,"modified_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers) to the output stream.\n     * @param out\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        byte leading=0;\n\n        if(src_addr != null) {\n            leading+=SRC_SET;\n            if(src_addr instanceof IpAddress) {\n                leading+=IPADDR_SRC;\n                if(((IpAddress)src_addr).getIpAddress() == null) {\n                    leading+=SRC_HOST_NULL;\n                }\n            }\n        }\n        if(buf != null)\n            leading+=BUF_SET;\n\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr\n        if(src_addr != null) {\n            if(src_addr instanceof IpAddress) {\n                src_addr.writeTo(out);\n            }\n            else {\n                Util.writeAddress(src_addr, out);\n            }\n        }\n\n        // 4. buf\n        if(buf != null) {\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 5. headers\n        int size=headers.size();\n        out.writeShort(size);\n        final Object[] data=headers.getRawData();\n        for(int i=0; i < data.length; i+=2) {\n            if(data[i] != null) {\n                out.writeUTF((String)data[i]);\n                writeHeader((Header)data[i+1], out);\n            }\n        }\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Public constructor\n     *  @param dest Address of receiver. If it is <em>null<\/em> then the message sent to the group.\n     *              Otherwise, it contains a single destination and is sent to that member.<p>\n     */\n    public Message(Address dest) {\n        setDest(dest);\n        headers=createHeaders(7);\n    }","id":86279,"modified_method":"/** Public constructor\n     *  @param dest Address of receiver. If it is <em>null<\/em> then the message sent to the group.\n     *              Otherwise, it contains a single destination and is sent to that member.<p>\n     */\n    public Message(Address dest) {\n        setDest(dest);\n        headers=createHeaders(3);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public Message() {\n        headers=createHeaders(7);\n    }","id":86280,"modified_method":"public Message() {\n        headers=createHeaders(3);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Returns a reference to the headers hashmap, which is <em>immutable<\/em>. Any attempt to\n     * modify the returned map will cause a runtime exception */\n    public Map<String,Header> getHeaders() {\n        return createHeaders(headers);\n    }","id":86281,"modified_method":"/** Returns a reference to the headers hashmap, which is <em>immutable<\/em>. Any attempt to\n     * modify the returned map will cause a runtime exception */\n    public Map<String,Header> getHeaders() {\n        return headers.getHeaders();\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public String printHeaders() {\n        return headers.toString();\n    }","id":86282,"modified_method":"public String printHeaders() {\n        return headers.printHeaders();\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int len, leading;\n        String hdr_name;\n        Header hdr;\n\n\n        // 1. read the leading byte first\n        leading=in.readByte();\n\n        flags=in.readByte();\n\n        // 2. src_addr\n        if((leading & SRC_SET) == SRC_SET) {\n            if((leading & IPADDR_SRC) == IPADDR_SRC) {\n                src_addr=new IpAddress();\n                src_addr.readFrom(in);\n            }\n            else {\n                src_addr=Util.readAddress(in);\n            }\n            if(!DISABLE_CANONICALIZATION)\n                src_addr=canonicalAddress(src_addr);\n        }\n\n        // 3. buf\n        if((leading & BUF_SET) == BUF_SET) {\n            len=in.readInt();\n            buf=new byte[len];\n            in.read(buf, 0, len);\n            length=len;\n        }\n\n        // 4. headers\n        len=in.readShort();\n        headers=createHeaders(len);\n        for(int i=0; i < len; i++) {\n            hdr_name=in.readUTF();\n            hdr=readHeader(in);\n            headers.put(hdr_name, hdr);\n        }\n    }","id":86283,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int len, leading;\n        String hdr_name;\n        Header hdr;\n\n\n        // 1. read the leading byte first\n        leading=in.readByte();\n\n        flags=in.readByte();\n\n        // 2. src_addr\n        if((leading & SRC_SET) == SRC_SET) {\n            if((leading & IPADDR_SRC) == IPADDR_SRC) {\n                src_addr=new IpAddress();\n                src_addr.readFrom(in);\n            }\n            else {\n                src_addr=Util.readAddress(in);\n            }\n            if(!DISABLE_CANONICALIZATION)\n                src_addr=canonicalAddress(src_addr);\n        }\n\n        // 3. buf\n        if((leading & BUF_SET) == BUF_SET) {\n            len=in.readInt();\n            buf=new byte[len];\n            in.read(buf, 0, len);\n            length=len;\n        }\n\n        // 4. headers\n        len=in.readShort();\n        headers=createHeaders(len);\n        Object[] data=headers.getRawData();\n        int index=0;\n        for(int i=0; i < len; i++) {\n            hdr_name=in.readUTF();\n            data[index++]=hdr_name;\n            hdr=readHeader(in);\n            data[index++]=hdr;\n            // headers.putHeader(hdr_name, hdr);\n        }\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Puts a header given a key into the map, only if the key doesn't exist yet\n     * @param key\n     * @param hdr\n     * @return the previous value associated with the specified key, or\n     *         <tt>null<\/tt> if there was no mapping for the key.\n     *         (A <tt>null<\/tt> return can also indicate that the map\n     *         previously associated <tt>null<\/tt> with the key,\n     *         if the implementation supports null values.)\n     */\n    public Header putHeaderIfAbsent(String key, Header hdr) {\n        if(!headers.containsKey(key))\n            return headers.put(key, hdr);\n        else\n            return headers.get(key);\n    }","id":86284,"modified_method":"/**\n     * Puts a header given a key into the map, only if the key doesn't exist yet\n     * @param key\n     * @param hdr\n     * @return the previous value associated with the specified key, or\n     *         <tt>null<\/tt> if there was no mapping for the key.\n     *         (A <tt>null<\/tt> return can also indicate that the map\n     *         previously associated <tt>null<\/tt> with the key,\n     *         if the implementation supports null values.)\n     */\n    public Header putHeaderIfAbsent(String key, Header hdr) {\n        return headers.putHeaderIfAbsent(key, hdr);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public Header getHeader(String key) {\n        return headers.get(key);\n    }","id":86285,"modified_method":"public Header getHeader(String key) {\n        return headers.getHeader(key);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public Message(boolean create_headers) {\n        if(create_headers)\n            headers=createHeaders(7);\n    }","id":86286,"modified_method":"public Message(boolean create_headers) {\n        if(create_headers)\n            headers=createHeaders(3);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getNumHeaders() {\n        return headers != null? headers.size() : 0;\n    }","id":86287,"modified_method":"public int getNumHeaders() {\n        return headers.size();\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the exact size of the marshalled message. Uses method size() of each header to compute the size, so if\n     * a Header subclass doesn't implement size() we will use an approximation. However, most relevant header subclasses\n     * have size() implemented correctly. (See org.jgroups.tests.SizeTest).\n     * @return The number of bytes for the marshalled message\n     */\n    public long size() {\n        long retval=Global.BYTE_SIZE                  // leading byte\n                + Global.BYTE_SIZE                    // flags\n                + length                              // buffer\n                + (buf != null? Global.INT_SIZE : 0); // if buf != null 4 bytes for length\n\n        // if(dest_addr != null)\n        // retval+=dest_addr.size();\n        if(src_addr != null)\n            retval+=(src_addr).size();\n\n        Map.Entry entry;\n        String key;\n        Header hdr;\n        retval+=Global.SHORT_SIZE; // size (short)\n\n        for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            key=(String)entry.getKey();\n            retval+=key.length() +2; // not the same as writeUTF(), but almost\n            hdr=(Header)entry.getValue();\n            retval+=(Global.SHORT_SIZE *2); // 2 for magic number, 2 for size (short)\n            retval+=hdr.size();\n        }\n        return retval;\n    }","id":86288,"modified_method":"/**\n     * Returns the exact size of the marshalled message. Uses method size() of each header to compute the size, so if\n     * a Header subclass doesn't implement size() we will use an approximation. However, most relevant header subclasses\n     * have size() implemented correctly. (See org.jgroups.tests.SizeTest).\n     * @return The number of bytes for the marshalled message\n     */\n    public long size() {\n        long retval=Global.BYTE_SIZE                  // leading byte\n                + Global.BYTE_SIZE                    // flags\n                + length                              // buffer\n                + (buf != null? Global.INT_SIZE : 0); // if buf != null 4 bytes for length\n\n        // if(dest_addr != null)\n        // retval+=dest_addr.size();\n        if(src_addr != null)\n            retval+=(src_addr).size();\n\n        retval+=Global.SHORT_SIZE; // size (short)\n        retval+=headers.marshalledSize();\n        return retval;\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public String printObjectHeaders() {\n        StringBuilder sb=new StringBuilder();\n        Map.Entry entry;\n\n\n        if(headers != null) {\n            for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append('\\n');\n            }\n        }\n        return sb.toString();\n    }","id":86289,"modified_method":"public String printObjectHeaders() {\n        return headers.printObjectHeaders();\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"private static Map<String,Header> createHeaders(int size) {\n        return size > 0? new HashMap<String,Header>(size) : new HashMap<String,Header>(5);\n    }","id":86290,"modified_method":"private static Headers createHeaders(int size) {\n        return size > 0? new Headers(size) : new Headers(3);\n    }","commit_id":"d805909849f5c155680c4c88e343b1e094f59689","url":"https://github.com/belaban/JGroups"},{"original_method":"public void onTraversalDone( CountedData reduceSum ) {\n        double ppv = 100 * ((double) reduceSum.numTP /( reduceSum.numTP + reduceSum.numFP));\n        double npv = 100 * ((double) reduceSum.numTN /( reduceSum.numTN + reduceSum.numFN));\n        logger.info(String.format(\"Resulting Truth Table Output\\n\\n\" +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"\\t\\t|\\tT\\t|\\tF\\t\\n\"  +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"called alt\\t|\\t%d\\t|\\t%d\\n\" +\n                                  \"called ref\\t|\\t%d\\t|\\t%d\\n\" +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"positive predictive value: %f%%\\n\" +\n                                  \"negative predictive value: %f%%\\n\" +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"uncovered: %d\\n\" +\n                                  \"---------------------------------------------------\\n\", reduceSum.numTP, reduceSum.numFP, reduceSum.numFN, reduceSum.numTN, ppv, npv, reduceSum.numUncovered));\n\n        /*\n\n        logger.info(\"called / true      = \" + reduceSum.numTP);\n        logger.info(\"not called / false = \" + reduceSum.numTN);\n        logger.info(\"called /false      = \" + reduceSum.numFP);\n        logger.info(\"not called / true = \" + reduceSum.numFN);\n        logger.info(\"PPV = \" + 100 * ((double) reduceSum.numTP /( reduceSum.numTP + reduceSum.numFP)) + \"%\");\n        logger.info(\"NPV = \" + 100 * ((double) reduceSum.numTN /( reduceSum.numTN + reduceSum.numFN)) + \"%\");\n        logger.info(\"confidently called = \" + reduceSum.numConfidentCalls);\n        logger.info(\"not confidently called = \" + reduceSum.numNotConfidentCalls );\n        logger.info(\"Uncovered = \" + reduceSum.numUncovered);\n        */\n    }","id":86291,"modified_method":"public void onTraversalDone( CountedData reduceSum ) {\n        double ppv = 100 * ((double) reduceSum.nAltCalledAlt /( reduceSum.nAltCalledAlt + reduceSum.nRefCalledAlt));\n        double npv = 100 * ((double) reduceSum.nRefCalledRef /( reduceSum.nRefCalledRef + reduceSum.nAltCalledRef));\n        logger.info(String.format(\"Resulting Truth Table Output\\n\\n\" +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"\\t\\t|\\tALT\\t|\\tREF\\t\\n\"  +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"called alt\\t|\\t%d\\t|\\t%d\\n\" +\n                                  \"called ref\\t|\\t%d\\t|\\t%d\\n\" +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"positive predictive value: %f%%\\n\" +\n                                  \"negative predictive value: %f%%\\n\" +\n                                  \"---------------------------------------------------\\n\" +\n                                  \"not confident: %d\\n\" +\n                                  \"not covered: %d\\n\" +\n                                  \"---------------------------------------------------\\n\", reduceSum.nAltCalledAlt, reduceSum.nRefCalledAlt, reduceSum.nAltCalledRef, reduceSum.nRefCalledRef, ppv, npv, reduceSum.nNotConfidentCalls, reduceSum.nUncovered));\n    }","commit_id":"28149e5c5eb017e9943d826b5711eb09b20a951e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n\n        List<ReferenceOrderedDataSource> rodList = this.getToolkit().getRodDataSources();\n        if ( rodList.size() != 1 )\n            throw new UserException.BadInput(\"You should provide exactly one genotype VCF\");\n        if ( !rodList.get(0).getName().equals(compName))\n            throw new UserException.BadInput(\"The ROD track has to be named \\\"\"+ compName +\"\\\". Not \" + rodList.get(0).getName());\n\n\n        // Initialize VCF header\n        Map<String, VCFHeader> header = VCFUtils.getVCFHeadersFromRodPrefix(getToolkit(), compName);\n        Set<String> samples = SampleUtils.getSampleList(header, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE);\n        Set<VCFHeaderLine> headerLines = VCFUtils.smartMergeHeaders(header.values(), logger);\n        headerLines.add(new VCFHeaderLine(\"source\", \"GenotypeAndValidate\"));\n        vcfWriter.writeHeader(new VCFHeader(headerLines, samples));\n\n\n        // Filling in SNP calling arguments for UG\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.OutputMode = UnifiedGenotyperEngine.OUTPUT_MODE.EMIT_ALL_SITES;\n        uac.GenotypingMode = GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES;\n        if (mbq >= 0) uac.MIN_BASE_QUALTY_SCORE = mbq;\n        if (deletions >= 0) uac.MAX_DELETION_FRACTION = deletions;\n        if (callConf >= 0) uac.STANDARD_CONFIDENCE_FOR_CALLING = callConf;\n        if (emitConf >= 0) uac.STANDARD_CONFIDENCE_FOR_EMITTING = emitConf;\n\n\n        snpEngine = new UnifiedGenotyperEngine(getToolkit(), uac);\n\n        // Adding the INDEL calling arguments for UG\n        uac.GLmodel = GenotypeLikelihoodsCalculationModel.Model.DINDEL;\n        indelEngine = new UnifiedGenotyperEngine(getToolkit(), uac);\n    }","id":86292,"modified_method":"public void initialize() {\n\n        List<ReferenceOrderedDataSource> rodList = this.getToolkit().getRodDataSources();\n        if ( rodList.size() != 1 )\n            throw new UserException.BadInput(\"You should provide exactly one genotype VCF\");\n        if ( !rodList.get(0).getName().equals(compName))\n            throw new UserException.BadInput(\"The ROD track has to be named \\\"\"+ compName +\"\\\". Not \" + rodList.get(0).getName());\n\n\n        // Initialize VCF header\n        if (vcfWriter != null) {\n            Map<String, VCFHeader> header = VCFUtils.getVCFHeadersFromRodPrefix(getToolkit(), compName);\n            Set<String> samples = SampleUtils.getSampleList(header, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE);\n            Set<VCFHeaderLine> headerLines = VCFUtils.smartMergeHeaders(header.values(), logger);\n            headerLines.add(new VCFHeaderLine(\"source\", \"GenotypeAndValidate\"));\n            vcfWriter.writeHeader(new VCFHeader(headerLines, samples));\n        }\n\n        // Filling in SNP calling arguments for UG\n        UnifiedArgumentCollection uac = new UnifiedArgumentCollection();\n        uac.OutputMode = UnifiedGenotyperEngine.OUTPUT_MODE.EMIT_ALL_SITES;\n        if (!bamIsTruth) uac.GenotypingMode = GenotypeLikelihoodsCalculationModel.GENOTYPING_MODE.GENOTYPE_GIVEN_ALLELES;\n        if (mbq >= 0) uac.MIN_BASE_QUALTY_SCORE = mbq;\n        if (deletions >= 0) uac.MAX_DELETION_FRACTION = deletions;\n        if (emitConf >= 0) uac.STANDARD_CONFIDENCE_FOR_EMITTING = emitConf;\n        if (callConf >= 0) uac.STANDARD_CONFIDENCE_FOR_CALLING = callConf;\n\n        snpEngine = new UnifiedGenotyperEngine(getToolkit(), uac);\n\n        // Adding the INDEL calling arguments for UG\n        uac.GLmodel = GenotypeLikelihoodsCalculationModel.Model.DINDEL;\n        indelEngine = new UnifiedGenotyperEngine(getToolkit(), uac);\n\n        // make sure we have callConf set to the threshold set by the UAC so we can use it later.\n        callConf = uac.STANDARD_CONFIDENCE_FOR_CALLING;\n    }","commit_id":"28149e5c5eb017e9943d826b5711eb09b20a951e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public CountedData map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        final CountedData counter = new CountedData();\n\n        // For some reason RodWalkers get map calls with null trackers\n        if( tracker == null )\n            return counter;\n\n        VariantContext vcComp = tracker.getVariantContext(ref, compName, null, context.getLocation(), false);\n        if( vcComp == null )\n            return counter;\n\n        //todo - not sure I want this, may be misleading to filter extended indel events.\n        if (isInsideExtendedIndel(vcComp,  ref))\n            return counter;\n\n        // Do not operate on variants that are not covered to the optional minimum depth\n        if (!context.hasReads() || (minDepth > 0 && context.getBasePileup().getBases().length < minDepth)) {\n            counter.numUncovered = 1L;\n            return counter;\n        }\n\n        if (!vcComp.hasAttribute(\"GV\"))\n            throw new UserException.BadInput(\"Variant has no GV annotation in the INFO field. \" + vcComp.getChr() + \":\" + vcComp.getStart());\n\n        VariantCallContext call;\n        if ( vcComp.isSNP() )\n            call = snpEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n        else if ( vcComp.isIndel() ) {\n            call = indelEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n//            if (call.vc == null) // variant context will be null on an extended indel event and I just want to call it one event.\n//                return counter;\n        }\n        else {\n            logger.info(\"Not SNP or INDEL \" + vcComp.getChr() + \":\" + vcComp.getStart() + \" \" + vcComp.getAlleles());\n            return counter;\n        }\n\n        if (!call.confidentlyCalled) {\n            counter.numNotConfidentCalls = 1L;\n            if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                counter.numFN = 1L;\n            else\n                counter.numTN = 1L;\n        }\n        else {\n            counter.numConfidentCalls = 1L;\n            if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                counter.numTP = 1L;\n            else\n                counter.numFP = 1L;\n        }\n        if (!vcComp.hasAttribute(\"callStatus\")) {\n            MutableVariantContext mvc = new MutableVariantContext(vcComp);\n            mvc.putAttribute(\"callStatus\", call.confidentlyCalled ? \"confident\" : \"notConfident\" );\n            vcfWriter.add(mvc, ref.getBase());\n        }\n        else\n            vcfWriter.add(vcComp, ref.getBase());\n        return counter;\n    }","id":86293,"modified_method":"public CountedData map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        final CountedData counter = new CountedData();\n\n        // For some reason RodWalkers get map calls with null trackers\n        if( tracker == null )\n            return counter;\n\n        VariantContext vcComp = tracker.getVariantContext(ref, compName, null, context.getLocation(), false);\n        if( vcComp == null )\n            return counter;\n\n        //todo - not sure I want this, may be misleading to filter extended indel events.\n        if (isInsideExtendedIndel(vcComp,  ref))\n            return counter;\n\n        // Do not operate on variants that are not covered to the optional minimum depth\n        if (!context.hasReads() || (minDepth > 0 && context.getBasePileup().getBases().length < minDepth)) {\n            counter.nUncovered = 1L;\n            return counter;\n        }\n\n        VariantCallContext call;\n        if ( vcComp.isSNP() )\n            call = snpEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n        else if ( vcComp.isIndel() ) {\n            call = indelEngine.calculateLikelihoodsAndGenotypes(tracker, ref, context);\n        }\n        else {\n            logger.info(\"Not SNP or INDEL \" + vcComp.getChr() + \":\" + vcComp.getStart() + \" \" + vcComp.getAlleles());\n            return counter;\n        }\n\n        if (bamIsTruth) {\n            if (call.confidentlyCalled) {\n                // If truth is a confident REF call\n                if (call.isVariant()) {\n                    if (vcComp.isVariant())\n                        counter.nAltCalledAlt = 1L;  // todo -- may wanna check if the alts called are the same?\n                    else\n                        counter.nAltCalledRef = 1L;\n                }\n                // If truth is a confident ALT call\n                else {\n                    if (vcComp.isVariant())\n                        counter.nRefCalledAlt = 1L;\n                    else\n                        counter.nRefCalledRef = 1L;\n                }\n            }\n            else {\n                counter.nNotConfidentCalls = 1L;\n            }\n        }\n        else {\n            if (!vcComp.hasAttribute(\"GV\"))\n                throw new UserException.BadInput(\"Variant has no GV annotation in the INFO field. \" + vcComp.getChr() + \":\" + vcComp.getStart());\n\n\n\n            if (call.isCalledAlt(callConf)) {\n                if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                    counter.nAltCalledAlt = 1L;\n                else\n                    counter.nRefCalledAlt = 1L;\n            }\n            else if (call.isCalledRef(callConf)) {\n                if (vcComp.getAttribute(\"GV\").equals(\"T\"))\n                    counter.nAltCalledRef = 1L;\n                else\n                    counter.nRefCalledRef = 1L;\n            }\n            else {\n                counter.nNotConfidentCalls = 1L;\n            }\n        }\n\n        if (vcfWriter != null) {\n            if (!vcComp.hasAttribute(\"callStatus\")) {\n                MutableVariantContext mvc = new MutableVariantContext(vcComp);\n                mvc.putAttribute(\"callStatus\", call.isCalledAlt(callConf) ? \"ALT\" : \"REF\" );\n                vcfWriter.add(mvc, ref.getBase());\n            }\n            else\n                vcfWriter.add(vcComp, ref.getBase());\n        }\n        return counter;\n    }","commit_id":"28149e5c5eb017e9943d826b5711eb09b20a951e","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n         * Adds the values of other to this, returning this\n         * @param other the other object\n         */\n        public void add(CountedData other) {\n            numTP += other.numTP;\n            numTN += other.numTN;\n            numFP += other.numFP;\n            numFN += other.numFN;\n            numUncovered += other.numUncovered;\n            numNotConfidentCalls += other.numNotConfidentCalls;\n            numConfidentCalls    += other.numConfidentCalls;\n        }","id":86294,"modified_method":"/**\n         * Adds the values of other to this, returning this\n         * @param other the other object\n         */\n        public void add(CountedData other) {\n            nAltCalledAlt += other.nAltCalledAlt;\n            nAltCalledRef += other.nAltCalledRef;\n            nRefCalledAlt += other.nRefCalledAlt;\n            nRefCalledRef += other.nRefCalledRef;\n            nUncovered += other.nUncovered;\n            nNotConfidentCalls += other.nNotConfidentCalls;\n        }","commit_id":"28149e5c5eb017e9943d826b5711eb09b20a951e","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Message(boolean create_headers) {\n        if(create_headers)\n            headers=createHeaders(7);\n    }","id":86295,"modified_method":"public Message(boolean create_headers) {\n        if(create_headers)\n            headers=createHeaders(3);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers) to the output stream.\n     * @param out\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        byte leading=0;\n\n        if(src_addr != null) {\n            leading+=SRC_SET;\n            if(src_addr instanceof IpAddress) {\n                leading+=IPADDR_SRC;\n                if(((IpAddress)src_addr).getIpAddress() == null) {\n                    leading+=SRC_HOST_NULL;\n                }\n            }\n        }\n        if(buf != null)\n            leading+=BUF_SET;\n\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr\n        if(src_addr != null) {\n            if(src_addr instanceof IpAddress) {\n                src_addr.writeTo(out);\n            }\n            else {\n                Util.writeAddress(src_addr, out);\n            }\n        }\n\n        // 4. buf\n        if(buf != null) {\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 5. headers\n        int size=headers.size();\n        out.writeShort(size);\n        Map.Entry        entry;\n        for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            out.writeUTF((String)entry.getKey());\n            writeHeader((Header)entry.getValue(), out);\n        }\n    }","id":86296,"modified_method":"/**\n     * Streams all members (dest and src addresses, buffer and headers) to the output stream.\n     * @param out\n     * @throws IOException\n     */\n    public void writeTo(DataOutputStream out) throws IOException {\n        byte leading=0;\n\n        if(src_addr != null) {\n            leading+=SRC_SET;\n            if(src_addr instanceof IpAddress) {\n                leading+=IPADDR_SRC;\n                if(((IpAddress)src_addr).getIpAddress() == null) {\n                    leading+=SRC_HOST_NULL;\n                }\n            }\n        }\n        if(buf != null)\n            leading+=BUF_SET;\n\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr\n        if(src_addr != null) {\n            if(src_addr instanceof IpAddress) {\n                src_addr.writeTo(out);\n            }\n            else {\n                Util.writeAddress(src_addr, out);\n            }\n        }\n\n        // 4. buf\n        if(buf != null) {\n            out.writeInt(length);\n            out.write(buf, offset, length);\n        }\n\n        // 5. headers\n        int size=headers.size();\n        out.writeShort(size);\n        final Object[] data=headers.getRawData();\n        for(int i=0; i < data.length; i+=2) {\n            if(data[i] != null) {\n                out.writeUTF((String)data[i]);\n                writeHeader((Header)data[i+1], out);\n            }\n        }\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"private static Map<String,Header> createHeaders(int size) {\n        return size > 0? new HashMap<String,Header>(size) : new HashMap<String,Header>(5);\n    }","id":86297,"modified_method":"private static Headers createHeaders(int size) {\n        return size > 0? new Headers(size) : new Headers(3);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the exact size of the marshalled message. Uses method size() of each header to compute the size, so if\n     * a Header subclass doesn't implement size() we will use an approximation. However, most relevant header subclasses\n     * have size() implemented correctly. (See org.jgroups.tests.SizeTest).\n     * @return The number of bytes for the marshalled message\n     */\n    public long size() {\n        long retval=Global.BYTE_SIZE                  // leading byte\n                + Global.BYTE_SIZE                    // flags\n                + length                              // buffer\n                + (buf != null? Global.INT_SIZE : 0); // if buf != null 4 bytes for length\n\n        // if(dest_addr != null)\n        // retval+=dest_addr.size();\n        if(src_addr != null)\n            retval+=(src_addr).size();\n\n        Map.Entry entry;\n        String key;\n        Header hdr;\n        retval+=Global.SHORT_SIZE; // size (short)\n\n        for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            key=(String)entry.getKey();\n            retval+=key.length() +2; // not the same as writeUTF(), but almost\n            hdr=(Header)entry.getValue();\n            retval+=(Global.SHORT_SIZE *2); // 2 for magic number, 2 for size (short)\n            retval+=hdr.size();\n        }\n        return retval;\n    }","id":86298,"modified_method":"/**\n     * Returns the exact size of the marshalled message. Uses method size() of each header to compute the size, so if\n     * a Header subclass doesn't implement size() we will use an approximation. However, most relevant header subclasses\n     * have size() implemented correctly. (See org.jgroups.tests.SizeTest).\n     * @return The number of bytes for the marshalled message\n     */\n    public long size() {\n        long retval=Global.BYTE_SIZE                  // leading byte\n                + Global.BYTE_SIZE                    // flags\n                + length                              // buffer\n                + (buf != null? Global.INT_SIZE : 0); // if buf != null 4 bytes for length\n\n        // if(dest_addr != null)\n        // retval+=dest_addr.size();\n        if(src_addr != null)\n            retval+=(src_addr).size();\n\n        retval+=Global.SHORT_SIZE; // size (short)\n        retval+=headers.marshalledSize();\n        return retval;\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Returns a reference to the headers hashmap, which is <em>immutable<\/em>. Any attempt to\n     * modify the returned map will cause a runtime exception */\n    public Map<String,Header> getHeaders() {\n        return createHeaders(headers);\n    }","id":86299,"modified_method":"/** Returns a reference to the headers hashmap, which is <em>immutable<\/em>. Any attempt to\n     * modify the returned map will cause a runtime exception */\n    public Map<String,Header> getHeaders() {\n        return headers.getHeaders();\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public String printObjectHeaders() {\n        StringBuilder sb=new StringBuilder();\n        Map.Entry entry;\n\n\n        if(headers != null) {\n            for(Iterator it=headers.entrySet().iterator(); it.hasNext();) {\n                entry=(Map.Entry)it.next();\n                sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append('\\n');\n            }\n        }\n        return sb.toString();\n    }","id":86300,"modified_method":"public String printObjectHeaders() {\n        return headers.printObjectHeaders();\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public int getNumHeaders() {\n        return headers != null? headers.size() : 0;\n    }","id":86301,"modified_method":"public int getNumHeaders() {\n        return headers.size();\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Public constructor\n     *  @param dest Address of receiver. If it is <em>null<\/em> then the message sent to the group.\n     *              Otherwise, it contains a single destination and is sent to that member.<p>\n     */\n    public Message(Address dest) {\n        setDest(dest);\n        headers=createHeaders(7);\n    }","id":86302,"modified_method":"/** Public constructor\n     *  @param dest Address of receiver. If it is <em>null<\/em> then the message sent to the group.\n     *              Otherwise, it contains a single destination and is sent to that member.<p>\n     */\n    public Message(Address dest) {\n        setDest(dest);\n        headers=createHeaders(3);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Puts a header given a key into the hashmap. Overwrites potential existing entry. */\n    public void putHeader(String key, Header hdr) {\n        headers.put(key, hdr);\n    }","id":86303,"modified_method":"/** Puts a header given a key into the hashmap. Overwrites potential existing entry. */\n    public void putHeader(String key, Header hdr) {\n        headers.putHeader(key, hdr);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Header getHeader(String key) {\n        return headers.get(key);\n    }","id":86304,"modified_method":"public Header getHeader(String key) {\n        return headers.getHeader(key);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int len, leading;\n        String hdr_name;\n        Header hdr;\n\n\n        // 1. read the leading byte first\n        leading=in.readByte();\n\n        flags=in.readByte();\n\n        // 2. src_addr\n        if((leading & SRC_SET) == SRC_SET) {\n            if((leading & IPADDR_SRC) == IPADDR_SRC) {\n                src_addr=new IpAddress();\n                src_addr.readFrom(in);\n            }\n            else {\n                src_addr=Util.readAddress(in);\n            }\n            if(!DISABLE_CANONICALIZATION)\n                src_addr=canonicalAddress(src_addr);\n        }\n\n        // 3. buf\n        if((leading & BUF_SET) == BUF_SET) {\n            len=in.readInt();\n            buf=new byte[len];\n            in.read(buf, 0, len);\n            length=len;\n        }\n\n        // 4. headers\n        len=in.readShort();\n        headers=createHeaders(len);\n        for(int i=0; i < len; i++) {\n            hdr_name=in.readUTF();\n            hdr=readHeader(in);\n            headers.put(hdr_name, hdr);\n        }\n    }","id":86305,"modified_method":"public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n        int len, leading;\n        String hdr_name;\n        Header hdr;\n\n\n        // 1. read the leading byte first\n        leading=in.readByte();\n\n        flags=in.readByte();\n\n        // 2. src_addr\n        if((leading & SRC_SET) == SRC_SET) {\n            if((leading & IPADDR_SRC) == IPADDR_SRC) {\n                src_addr=new IpAddress();\n                src_addr.readFrom(in);\n            }\n            else {\n                src_addr=Util.readAddress(in);\n            }\n            if(!DISABLE_CANONICALIZATION)\n                src_addr=canonicalAddress(src_addr);\n        }\n\n        // 3. buf\n        if((leading & BUF_SET) == BUF_SET) {\n            len=in.readInt();\n            buf=new byte[len];\n            in.read(buf, 0, len);\n            length=len;\n        }\n\n        // 4. headers\n        len=in.readShort();\n        headers=createHeaders(len);\n        Object[] data=headers.getRawData();\n        int index=0;\n        for(int i=0; i < len; i++) {\n            hdr_name=in.readUTF();\n            data[index++]=hdr_name;\n            hdr=readHeader(in);\n            data[index++]=hdr;\n            // headers.putHeader(hdr_name, hdr);\n        }\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public Message() {\n        headers=createHeaders(7);\n    }","id":86306,"modified_method":"public Message() {\n        headers=createHeaders(3);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Puts a header given a key into the map, only if the key doesn't exist yet\n     * @param key\n     * @param hdr\n     * @return the previous value associated with the specified key, or\n     *         <tt>null<\/tt> if there was no mapping for the key.\n     *         (A <tt>null<\/tt> return can also indicate that the map\n     *         previously associated <tt>null<\/tt> with the key,\n     *         if the implementation supports null values.)\n     */\n    public Header putHeaderIfAbsent(String key, Header hdr) {\n        if(!headers.containsKey(key))\n            return headers.put(key, hdr);\n        else\n            return headers.get(key);\n    }","id":86307,"modified_method":"/**\n     * Puts a header given a key into the map, only if the key doesn't exist yet\n     * @param key\n     * @param hdr\n     * @return the previous value associated with the specified key, or\n     *         <tt>null<\/tt> if there was no mapping for the key.\n     *         (A <tt>null<\/tt> return can also indicate that the map\n     *         previously associated <tt>null<\/tt> with the key,\n     *         if the implementation supports null values.)\n     */\n    public Header putHeaderIfAbsent(String key, Header hdr) {\n        return headers.putHeaderIfAbsent(key, hdr);\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public String printHeaders() {\n        return headers.toString();\n    }","id":86308,"modified_method":"public String printHeaders() {\n        return headers.printHeaders();\n    }","commit_id":"b6c61b1a35d1c7cdead0eb4999e2833e49c9993e","url":"https://github.com/belaban/JGroups"},{"original_method":"public SensorPanel drawSensorPanel() {\n        SensorPanel sensorPanel_1 = new SensorPanel( gameData );\n        FlowLayout fl_sensorPanel_1 = (FlowLayout) sensorPanel_1.getLayout();\n        fl_sensorPanel_1.setVgap( 10 );\n        sensorPanel_1.setBackground( Color.WHITE );\n        return sensorPanel_1;\n    }","id":86309,"modified_method":"public SensorPanel drawSensorPanel() {\n        SensorPanel sensorPanel_1 = new SensorPanel( this );\n        FlowLayout fl_sensorPanel_1 = (FlowLayout) sensorPanel_1.getLayout();\n        fl_sensorPanel_1.setVgap( 10 );\n        sensorPanel_1.setBackground( Color.WHITE );\n        return sensorPanel_1;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JPanel drawMovePanel() {\n        JPanel movePanel = new JPanel();\n        movePanel.setBackground( Color.WHITE );\n        movePanel.setLayout( new GridLayout( 0, 3, 0, 0 ) );\n\n        JPanel panel_2 = new JPanel();\n        panel_2.setBackground( Color.WHITE );\n        movePanel.add( panel_2 );\n\n        JButton btnNewButton = new JButton( \"\" );\n        btnNewButton.setForeground( Color.WHITE );\n        btnNewButton.setBackground( Color.WHITE );\n        btnNewButton.setIcon( new ImageIcon( getClass().getResource( \"up.png\" ) ) );\n        btnNewButton.addMouseListener( new MoveButtonPressed(Move.MOVE_FORWARD) );\n        \n        movePanel.add( btnNewButton );\n\n        JPanel panel_7 = new JPanel();\n        panel_7.setBackground( Color.WHITE );\n        movePanel.add( panel_7 );\n\n        JButton btnNewButton_3 = new JButton( \"\" );\n        btnNewButton_3.setForeground( Color.WHITE );\n        btnNewButton_3.setBackground( Color.WHITE );\n        btnNewButton_3.setIcon( new ImageIcon( getClass().getResource( \"left.png\" ) ) );\n        btnNewButton_3.addMouseListener( new MoveButtonPressed(Move.TURN_LEFT) );\n        movePanel.add( btnNewButton_3 );\n\n        JPanel panel_8 = new JPanel();\n        panel_8.setBackground( Color.WHITE );\n        movePanel.add( panel_8 );\n\n        JButton btnNewButton_2 = new JButton( \"\" );\n        btnNewButton_2.setForeground( Color.WHITE );\n        btnNewButton_2.setBackground( Color.WHITE );\n        btnNewButton_2.setIcon( new ImageIcon( getClass().getResource( \"right.png\" ) ) );\n        btnNewButton_2.addMouseListener( new MoveButtonPressed(Move.TURN_RIGHT) );\n        movePanel.add( btnNewButton_2 );\n\n        JPanel panel_9 = new JPanel();\n        panel_9.setBackground( Color.WHITE );\n        movePanel.add( panel_9 );\n\n        JButton btnNewButton_1 = new JButton( \"\" );\n        btnNewButton_1.setForeground( Color.WHITE );\n        btnNewButton_1.setBackground( Color.WHITE );\n        btnNewButton_1.setIcon( new ImageIcon( getClass().getResource( \"down.png\" ) ) );\n        btnNewButton_1.addMouseListener(new MoveButtonPressed(Move.MOVE_BACKWARD));\n        movePanel.add( btnNewButton_1 );\n\n        JPanel panel_10 = new JPanel();\n        panel_10.setBackground( Color.WHITE );\n        movePanel.add( panel_10 );\n\n        return movePanel;\n    }","id":86310,"modified_method":"public JPanel drawMovePanel() {\n        JPanel movePanel = new JPanel();\n        movePanel.setBackground( Color.WHITE );\n        movePanel.setLayout( new GridLayout( 0, 3, 0, 0 ) );\n\n        JPanel panel_2 = new JPanel();\n        panel_2.setBackground( Color.WHITE );\n        movePanel.add( panel_2 );\n\n        JButton btnNewButton = new JButton( \"\" );\n        btnNewButton.setForeground( Color.WHITE );\n        btnNewButton.setBackground( Color.WHITE );\n        btnNewButton.setIcon( new ImageIcon( getClass().getResource( \"up.png\" ) ) );\n        btnNewButton.setToolTipText( \"move forward\" );\n        btnNewButton.addMouseListener( new MoveButtonPressed( Move.MOVE_FORWARD ) );\n\n        movePanel.add( btnNewButton );\n\n        JPanel panel_7 = new JPanel();\n        panel_7.setBackground( Color.WHITE );\n        movePanel.add( panel_7 );\n\n        JButton btnNewButton_3 = new JButton( \"\" );\n        btnNewButton_3.setForeground( Color.WHITE );\n        btnNewButton_3.setBackground( Color.WHITE );\n        btnNewButton_3.setIcon( new ImageIcon( getClass().getResource( \"rotate_left.png\" ) ) );\n        btnNewButton_3.addMouseListener( new MoveButtonPressed( Move.TURN_LEFT ) );\n        btnNewButton_3.setToolTipText( \"rotate left\" );\n        movePanel.add( btnNewButton_3 );\n\n        JPanel panel_8 = new JPanel();\n        panel_8.setBackground( Color.WHITE );\n        movePanel.add( panel_8 );\n\n        JButton btnNewButton_2 = new JButton( \"\" );\n        btnNewButton_2.setForeground( Color.WHITE );\n        btnNewButton_2.setBackground( Color.WHITE );\n        btnNewButton_2.setIcon( new ImageIcon( getClass().getResource( \"rotate_right.png\" ) ) );\n        btnNewButton_2.addMouseListener( new MoveButtonPressed( Move.TURN_RIGHT ) );\n        btnNewButton_2.setToolTipText( \"rotate right\" );\n        movePanel.add( btnNewButton_2 );\n\n        JPanel panel_9 = new JPanel();\n        panel_9.setBackground( Color.WHITE );\n        movePanel.add( panel_9 );\n\n        JButton btnNewButton_1 = new JButton( \"\" );\n        btnNewButton_1.setForeground( Color.WHITE );\n        btnNewButton_1.setBackground( Color.WHITE );\n        btnNewButton_1.setIcon( new ImageIcon( getClass().getResource( \"down.png\" ) ) );\n        btnNewButton_1.addMouseListener( new MoveButtonPressed( Move.MOVE_BACKWARD ) );\n        btnNewButton_1.setToolTipText( \"move backward\" );\n        movePanel.add( btnNewButton_1 );\n\n        JPanel panel_10 = new JPanel();\n        panel_10.setBackground( Color.WHITE );\n        movePanel.add( panel_10 );\n\n        return movePanel;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public GameUI() {\n        this.gameData = new GameView();\n        this.gameData.init( new Cell[5][5], new SensorsView(), new ArrayList<Pitt>(), new Wumpus( 2, 1 ), new Gold( 3, 1 ), new Hero( 0, 0 ) );\n    }","id":86311,"modified_method":"public GameUI() {\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static final void run(final GameView gameData) {\n        GameUI window = new GameUI(gameData);\n        window.initialize();        \n    }","id":86312,"modified_method":"public void setGameView(GameView gameView) {\n        this.gameView = gameView;\n        if ( frame == null ) {\n            initialize();\n        }\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void paint(Graphics g) {\n            super.paintComponent( g );\n            try {\n                SensorsView sensor = gameData.getSensorsview();\n                if ( sensor.isFeelBreeze() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"breeze.png\" ) );\n                    g.drawImage( image, 0, 0, 150, 150, this );\n                  }\n\n                  if ( sensor.isSmellStench() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"stench.png\" ) );\n                    g.drawImage( image, 153, 0, 150, 150, this );\n                  }\n\n                  if ( sensor.isSeeGlitter() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"glitter.png\" ) );\n                    g.drawImage( image, 306, 0, 150, 150, this );\n                  }\n \n                  if ( sensor.isFeelBump() ) {\n                      BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"bump.png\" ) );\n                      g.drawImage( image, 459, 0, 150, 150, this );\n                  }                  \n                  \n                  if ( sensor.isHearScream() ) {\n                      BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"scream.png\" ) );\n                      g.drawImage( image, 612, 0, 150, 150, this );\n                  }                  \n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","id":86313,"modified_method":"public void paint(Graphics g) {\n            super.paintComponent( g );\n            GameView gameView = gameUI.getGameView();\n            try {\n                SensorsView sensor = gameView.getSensorsview();\n                if ( sensor.isFeelBreeze() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"breeze.png\" ) );\n                    g.drawImage( image, 0, 0, 150, 150, this );\n                }\n\n                if ( sensor.isSmellStench() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"stench.png\" ) );\n                    g.drawImage( image, 153, 0, 150, 150, this );\n                }\n\n                if ( sensor.isSeeGlitter() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"glitter.png\" ) );\n                    g.drawImage( image, 306, 0, 150, 150, this );\n                }\n\n                if ( sensor.isFeelBump() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"bump.png\" ) );\n                    g.drawImage( image, 459, 0, 150, 150, this );\n                }\n\n                if ( sensor.isHearScream() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"scream.png\" ) );\n                    g.drawImage( image, 612, 0, 150, 150, this );\n                }\n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public SensorPanel(GameView gameData) {\n            this.gameData = gameData;\n        }","id":86314,"modified_method":"public SensorPanel(GameUI gameUI) {\n            this.gameUI = gameUI;\n        }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mousePressed(MouseEvent e) {                                    \n            gameData.getKsession().insert( new MoveCommand( move ) );\n            \n            gameData.getKsession().fireAllRules();\n            if ( gameData.isPittDeath() || gameData.isWumpusDeath() ) {\n                gameData.getKlogger().close();\n                gameData.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog(null,\n                                                           \"Play Again1?\", \"DEAD\", JOptionPane.OK_OPTION);\n                gameData.getWumpusWorld().setData( gameData );                            \n                updateCave();\n                updateSensors();                    \n            } else if ( gameData.isGoldWin() ) {\n                gameData.getKlogger().close();\n                gameData.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog(null,\n                                                           \"Play Again1?\", \"WIN\", JOptionPane.OK_OPTION);\n                gameData.getWumpusWorld().setData( gameData );                            \n                updateCave();\n                updateSensors();                    \n            } \n            else {\n                updateCave();\n                updateSensors();\n            }              \n        }","id":86315,"modified_method":"public void mousePressed(MouseEvent e) {\n            gameView.getKsession().insert( new MoveCommand( move ) );\n\n            gameView.getKsession().fireAllRules();\n            if ( gameView.isPitDeath() || gameView.isWumpusDeath() ) {\n                gameView.getKlogger().close();\n                gameView.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog( null,\n                                                            \"Play Again1?\", \"DEAD\", JOptionPane.OK_OPTION );\n                gameView.getWumpusWorld().setData( gameView );\n                updateCave();\n                updateSensors();\n            } else if ( gameView.isGoldWin() ) {\n                gameView.getKlogger().close();\n                gameView.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog( null,\n                                                            \"Play Again1?\", \"WIN\", JOptionPane.OK_OPTION );\n                gameView.getWumpusWorld().setData( gameView );\n                updateCave();\n                updateSensors();\n            }\n            else {\n                updateCave();\n                updateSensors();\n            }\n        }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public GameUI(GameView gameData) {\n        this.gameData = gameData;\n    }","id":86316,"modified_method":"public GameUI(GameView gameView) {\n        this.gameView = gameView;\n        initialize();\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JPanel drawActionPanel() {\n        JPanel actionPanel = new JPanel();\n        actionPanel.setBackground( Color.WHITE );\n        actionPanel.setLayout( new GridLayout( 0, 2, 0, 0 ) );\n\n        JButton btnNewButton_4 = new JButton( \"START\" );\n        btnNewButton_4.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_4.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameData.getWumpusWorld().setData( gameData );                            \n                updateCave();\n                updateSensors();\n            }\n        } );         \n        actionPanel.add( btnNewButton_4 );\n\n        JButton btnNewButton_5 = new JButton( \"SHOOT\" );\n        btnNewButton_5.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_5.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameData.getKsession().insert( new ShootCommand() );\n                gameData.getKsession().fireAllRules();\n                updateCave();\n                updateSensors();\n            }\n        } );             \n        actionPanel.add( btnNewButton_5 );\n\n//        JButton btnNewButton_6 = new JButton( \"GRAB\" );\n//        btnNewButton_6.setBackground( Color.LIGHT_GRAY );\n//        actionPanel.add( btnNewButton_6 );\n\n//        JButton btnNewButton_7 = new JButton( \"CLIMB\" );\n//        btnNewButton_7.setBackground( Color.LIGHT_GRAY );\n//        actionPanel.add( btnNewButton_7 );\n\n        JButton btnNewButton_8 = new JButton( \"CAVE?\" );\n        btnNewButton_8.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_8.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                if ( gameData.isShowAllCells() ) {\n                    gameData.setShowAllCells( false );    \n                } else {\n                    gameData.setShowAllCells( true );\n                }                \n                updateCave();\n            }\n        } );        \n        actionPanel.add( btnNewButton_8 );\n\n//        JButton btnNewButton_9 = new JButton( \"WUMPUS?\" );\n//        btnNewButton_9.setBackground( Color.LIGHT_GRAY );\n//        actionPanel.add( btnNewButton_9 );\n\n        return actionPanel;\n    }","id":86317,"modified_method":"public JPanel drawActionPanel() {\n        JPanel actionPanel = new JPanel();\n        actionPanel.setBackground( Color.WHITE );\n        actionPanel.setLayout( new GridLayout( 0, 2, 0, 0 ) );\n\n        JButton btnNewButton_4 = new JButton( \"START\" );\n        btnNewButton_4.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_4.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameView.getKsession().insert( new Reset() );\n                gameView.getKsession().fireAllRules();\n                updateCave();\n                updateSensors();\n            }\n        } );\n        actionPanel.add( btnNewButton_4 );\n\n        JButton btnNewButton_5 = new JButton( \"SHOOT\" );\n        btnNewButton_5.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_5.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameView.getKsession().insert( new ShootCommand() );\n                gameView.getKsession().fireAllRules();\n                updateCave();\n                updateSensors();\n            }\n        } );\n        actionPanel.add( btnNewButton_5 );\n\n        //        JButton btnNewButton_6 = new JButton( \"GRAB\" );\n        //        btnNewButton_6.setBackground( Color.LIGHT_GRAY );\n        //        actionPanel.add( btnNewButton_6 );\n\n        //        JButton btnNewButton_7 = new JButton( \"CLIMB\" );\n        //        btnNewButton_7.setBackground( Color.LIGHT_GRAY );\n        //        actionPanel.add( btnNewButton_7 );\n\n        JButton btnNewButton_8 = new JButton( \"CAVE?\" );\n        btnNewButton_8.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_8.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                if ( gameView.isShowAllCells() ) {\n                    gameView.setShowAllCells( false );\n                } else {\n                    gameView.setShowAllCells( true );\n                }\n                updateCave();\n            }\n        } );\n        actionPanel.add( btnNewButton_8 );\n\n        //        JButton btnNewButton_9 = new JButton( \"WUMPUS?\" );\n        //        btnNewButton_9.setBackground( Color.LIGHT_GRAY );\n        //        actionPanel.add( btnNewButton_9 );\n\n        return actionPanel;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void paint(Graphics g) {\n            super.paintComponent( g );\n            try {\n                int rowIndent = 20;\n                int colIndent = 5;\n                int rowPad = 0;\n                for ( int row = 0; row < 5; row++ ) {\n                    int colPad = 0;\n                    for ( int col = 0; col < 5; col++ ) {\n                        int x = (4 - row) * 50 - rowPad + rowIndent;\n                        int y = col * 50 + colPad + colIndent;\n\n                        BufferedImage image = null;\n                        if ( !gameData.isShowAllCells() && ( gameData.getCells() != null && gameData.getCells()[row][col].isHidden() ) ) {\n                            image = javax.imageio.ImageIO.read( getClass().getResource( \"hidden_room.png\" ) );\n                        } else {                                                \n                            if ( gameData.getPits().contains( new Pitt( row, col ) ) ) {\n                                image = javax.imageio.ImageIO.read( getClass().getResource( \"pitt.png\" ) );\n                            } else if ( row == gameData.getWumpus().getRow() && col == gameData.getWumpus().getCol() ) {\n                                if ( gameData.getWumpus().isAlive() ) {\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( \"alive_wumpus.png\" ) );\n                                } else {\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( \"dead_wumpus.png\" ) );\n                                }\n                            } else if ( row == gameData.getGold().getRow() && col == gameData.getGold().getCol() ) {\n                                image = javax.imageio.ImageIO.read( getClass().getResource( \"g.png\" ) );\n                            } else if ( row == gameData.getHero().getRow() && col == gameData.getHero().getCol() ) {\n                                Hero hero = gameData.getHero();\n                                switch( hero.getDirection() ) {\n                                    case UP:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_up.png\" ) );\n                                        break;\n                                    case DOWN:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_down.png\" ) );\n                                        break;                                        \n                                    case LEFT:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_left.png\" ) );\n                                        break;                                        \n                                    case RIGHT:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_right.png\" ) );\n                                        break;                                        \n                                }\n                            } else {\n                                image = javax.imageio.ImageIO.read( getClass().getResource( \"empty_room.png\" ) );\n                            }\n                        }\n                        g.drawImage( image, y, x, 50, 50, this );\n                        colPad = colPad + 3;\n                    }\n                    rowPad = rowPad + 3;\n                }\n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","id":86318,"modified_method":"public void paint(Graphics g) {\n            GameView gameView = gameUI.getGameView();\n            super.paintComponent( g );\n            try {\n                int rowIndent = 20;\n                int colIndent = 5;\n                int rowPad = 0;\n                for ( int row = 0; row < 5; row++ ) {\n                    int colPad = 0;\n                    for ( int col = 0; col < 5; col++ ) {\n                        int x = (4 - row) * 50 - rowPad + rowIndent;\n                        int y = col * 50 + colPad + colIndent;\n\n                        BufferedImage image;\n                        if ( !gameView.isShowAllCells() && (gameView.getCells() != null && gameView.getCells()[row][col].isHidden()) ) {\n                            image = javax.imageio.ImageIO.read( getClass().getResource( \"hidden_room.png\" ) );\n                        } else {\n                            if ( row == gameView.getHero().getRow() && col == gameView.getHero().getCol() ) {\n                                Hero hero = gameView.getHero();\n                                switch ( hero.getDirection() ) {\n                                    case UP :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_up.png\" ) );\n                                        break;\n                                    case DOWN :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_down.png\" ) );\n                                        break;\n                                    case LEFT :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_left.png\" ) );\n                                        break;\n                                    case RIGHT :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_right.png\" ) );\n                                        break;\n                                    default:\n                                        throw new IllegalStateException( \"invalid direction: \" + hero.getDirection() );\n                                }\n                            } else {\n                                boolean containsPit = gameView.getPits().contains( new Pit( row, col ) );\n                                boolean containsAliveWumpus = false;\n                                boolean containsDeadWumpus = false;\n                                if ( row == gameView.getWumpus().getRow() && col == gameView.getWumpus().getCol() ) {\n                                    if ( gameView.getWumpus().isAlive() ) {\n                                        containsAliveWumpus = true;\n                                    } else {\n                                        containsDeadWumpus = true;\n                                    }\n                                }\n                                boolean containsGold = (row == gameView.getGold().getRow() && col == gameView.getGold().getCol());\n\n                                if ( !containsPit && !containsAliveWumpus && !containsDeadWumpus && !containsGold ) {\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( \"empty_room.png\" ) );\n                                } else {\n\n                                    String pit = \"\";\n                                    String wumpus = \"\";\n                                    String gold = \"\";\n\n                                    if ( containsPit ) {\n                                        pit = \"pit\";\n                                    }\n\n                                    if ( containsAliveWumpus ) {\n                                        wumpus = \"alive_wumpus\";\n                                    } else if ( containsDeadWumpus ) {\n                                        wumpus = \"dead_wumpus\";\n                                    }\n\n                                    if ( containsGold ) {\n                                        gold = \"gold\";\n                                    }\n\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( pit + wumpus + gold + \".png\" ) );\n                                }\n                            }\n                        }\n                        g.drawImage( image, y, x, 50, 50, this );\n                        colPad = colPad + 3;\n                    }\n                    rowPad = rowPad + 3;\n                }\n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public CavePanel(GameView gameData) {\n            this.gameData = gameData;\n        }","id":86319,"modified_method":"public CavePanel(GameUI gameUI) {\n            this.gameUI = gameUI;\n        }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public CavePanel drawCave() {\n        CavePanel cavelPanel = new CavePanel( gameData );\n        FlowLayout flowLayout = (FlowLayout) cavelPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        cavelPanel.setBackground( Color.WHITE );\n        return cavelPanel;\n    }","id":86320,"modified_method":"public CavePanel drawCave() {\n        CavePanel cavelPanel = new CavePanel( this );\n        FlowLayout flowLayout = (FlowLayout) cavelPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        cavelPanel.setBackground( Color.WHITE );\n        return cavelPanel;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setPits(List<Pitt> pits) {\n        this.pits = pits;\n    }","id":86321,"modified_method":"public void setPits(List<Pit> pits) {\n        this.pits = pits;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public List<Pitt> getPits() {\n        return pits;\n    }","id":86322,"modified_method":"public List<Pit> getPits() {\n        return pits;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setPittDeath(boolean pittDeath) {\n        this.pittDeath = pittDeath;\n    }","id":86323,"modified_method":"public void setPitDeath(boolean pitDeath) {\n        this.pitDeath = pitDeath;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean isPittDeath() {\n        return pittDeath;\n    }","id":86324,"modified_method":"public boolean isPitDeath() {\n        return pitDeath;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init(Cell[][] cells,\n                     SensorsView sensors,\n                     List<Pitt> pits,\n                     Wumpus wumpus,\n                     Gold gold,\n                     Hero hero) {\n        this.showAllCells = false;\n        this.pittDeath = false;\n        this.goldWin = false;\n        this.wumpusDeath = false;\n        this.cells = cells;\n        this.sensors = sensors;\n        this.pits = pits;\n        this.wumpus = wumpus;\n        this.gold = gold;\n        this.hero = hero;\n    }","id":86325,"modified_method":"public void init(Cell[][] cells,\n                     SensorsView sensors,\n                     List<Pit> pits,\n                     Wumpus wumpus,\n                     Gold gold,\n                     Hero hero,\n                     int cellheight,\n                     int cellWidth,\n                     int cellPadding,\n                     int pittPercentage,\n                     int rows,\n                     int cols) {\n        this.showAllCells = false;\n        this.pitDeath = false;\n        this.goldWin = false;\n        this.wumpusDeath = false;\n        this.cells = cells;\n        this.sensors = sensors;\n        this.pits = pits;\n        this.wumpus = wumpus;\n        this.gold = gold;\n        this.hero = hero;\n        this.cellheight = cellheight;\n        this.cellWidth = cellWidth;\n        this.cellPadding = cellPadding;\n        this.pittPercentage = pittPercentage;\n        this.rows = rows;\n        this.cols = cols;\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setData(GameView data) {\n        KnowledgeBase kbase = data.getKbase();\n\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();        \n        KnowledgeRuntimeLogger klogger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/wumpus\");   \n        data.setKlogger( klogger );\n\n        List<Pitt> pitts = new ArrayList<Pitt>();\n        java.util.Random gen = new java.util.Random();\n        Cell[][] cells = new Cell[5][5];\n        for ( int i = 0; i < 5; i++ ) {\n            for ( int j = 0; j < 5; j++ ) {\n                Cell cell = new Cell( i, j );\n                cells[i][j] = cell;\n                if ( i == 0 && j == 0 ) {\n                    cell.setHidden( false );\n                }\n                ksession.insert( cell );\n                if ( j != 0 && i != 0 && gen.nextInt( 99 ) <= 19 ) {\n                    // 20% chance of pitt\n                    Pitt pitt = new Pitt( i, j );\n                    ksession.insert( pitt );\n                    pitts.add( pitt );\n                }\n            }\n        }\n\n        int row = 0;\n        int col = 0;\n        while ( (row == 0 && col == 0) || pitts.contains( new Pitt( row, col ) ) ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Wumpus wumpus = new Wumpus( row, col );\n\n        row = 0;\n        col = 0;\n        while ( (row == 0 && col == 0) || (wumpus.getRow() == row && wumpus.getCol() == col) || pitts.contains( new Pitt( row, col ) ) ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Gold gold = new Gold( row, col );\n        Hero hero = new Hero( 0, 0 );\n\n        SensorsView sensors = new SensorsView();\n        \n        ksession.insert( wumpus );\n        ksession.insert( gold );\n        ksession.insert( hero );\n        ksession.insert( sensors );\n        ksession.insert( data );\n        \n        ksession.fireAllRules();    \n        data.init(cells, sensors, pitts, wumpus, gold, hero );\n        data.setKsession( ksession );\n    }","id":86326,"modified_method":"public void setData(GameView view) {\n        KnowledgeBase kbase = view.getKbase();\n\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();        \n        KnowledgeRuntimeLogger klogger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/wumpus\");   \n        view.setKlogger( klogger );\n\n        List<Pit> pitts = new ArrayList<Pit>();\n        java.util.Random gen = new java.util.Random();\n        Cell[][] cells = new Cell[5][5];\n        for ( int i = 0; i < 5; i++ ) {\n            for ( int j = 0; j < 5; j++ ) {\n                Cell cell = new Cell( i, j );\n                cells[i][j] = cell;\n                if ( i == 0 && j == 0 ) {\n                    cell.setHidden( false );\n                }\n                ksession.insert( cell );\n                if ( j != 0 && i != 0 && gen.nextInt( 99 ) <= 19 ) {\n                    // 20% chance of pitt\n                    Pit pitt = new Pit( i, j );\n                    ksession.insert( pitt );\n                    pitts.add( pitt );\n                }\n            }\n        }\n\n        int row = 0;\n        int col = 0;\n        while ( row == 0 && col == 0 ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Wumpus wumpus = new Wumpus( row, col );\n\n        row = 0;\n        col = 0;\n        while ( row == 0 && col == 0 ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Gold gold = new Gold( row, col );\n        Hero hero = new Hero( 0, 0 );\n\n        SensorsView sensors = new SensorsView();\n        \n        ksession.insert( wumpus );\n        ksession.insert( gold );\n        ksession.insert( hero );\n        ksession.insert( sensors );\n        ksession.insert( view );\n        \n        ksession.fireAllRules();    \n        view.init(cells, sensors, pitts, wumpus, gold, hero, 50, 50, 3, 20, 5, 5 );\n        view.setKsession( ksession );\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init() throws InterruptedException {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"commands.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"sensors.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"collision.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"ui.drl\", GameView.class ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }      \n        \n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n\n\n        \n        GameView data = new GameView();\n        data.setKbase( kbase );\n        data.setWumpusWorld( this );\n        setData(data);\n        GameUI.run(data );\n        //Thread.sleep( 10 * 10000 );\n    }","id":86327,"modified_method":"public void init() throws InterruptedException {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"init.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }        \n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"commands.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"sensors.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"collision.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"ui.drl\", GameView.class ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }      \n        \n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();\n        ksession.setGlobal(\"randomInteger\",new java.util.Random() );\n        ksession.fireAllRules();\n    }","commit_id":"8512bf05eb75739172ef44059030f65ef0fa88ab","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public SensorPanel drawSensorPanel() {\n        SensorPanel sensorPanel_1 = new SensorPanel( gameData );\n        FlowLayout fl_sensorPanel_1 = (FlowLayout) sensorPanel_1.getLayout();\n        fl_sensorPanel_1.setVgap( 10 );\n        sensorPanel_1.setBackground( Color.WHITE );\n        return sensorPanel_1;\n    }","id":86328,"modified_method":"public SensorPanel drawSensorPanel() {\n        SensorPanel sensorPanel_1 = new SensorPanel( this );\n        FlowLayout fl_sensorPanel_1 = (FlowLayout) sensorPanel_1.getLayout();\n        fl_sensorPanel_1.setVgap( 10 );\n        sensorPanel_1.setBackground( Color.WHITE );\n        return sensorPanel_1;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public CavePanel drawCave() {\n        CavePanel cavelPanel = new CavePanel( gameData );\n        FlowLayout flowLayout = (FlowLayout) cavelPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        cavelPanel.setBackground( Color.WHITE );\n        return cavelPanel;\n    }","id":86329,"modified_method":"public CavePanel drawCave() {\n        CavePanel cavelPanel = new CavePanel( this );\n        FlowLayout flowLayout = (FlowLayout) cavelPanel.getLayout();\n        flowLayout.setVgap( 10 );\n        cavelPanel.setBackground( Color.WHITE );\n        return cavelPanel;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void paint(Graphics g) {\n            super.paintComponent( g );\n            try {\n                int rowIndent = 20;\n                int colIndent = 5;\n                int rowPad = 0;\n                for ( int row = 0; row < 5; row++ ) {\n                    int colPad = 0;\n                    for ( int col = 0; col < 5; col++ ) {\n                        int x = (4 - row) * 50 - rowPad + rowIndent;\n                        int y = col * 50 + colPad + colIndent;\n\n                        BufferedImage image = null;\n                        if ( !gameData.isShowAllCells() && ( gameData.getCells() != null && gameData.getCells()[row][col].isHidden() ) ) {\n                            image = javax.imageio.ImageIO.read( getClass().getResource( \"hidden_room.png\" ) );\n                        } else {                                                \n                            if ( gameData.getPits().contains( new Pitt( row, col ) ) ) {\n                                image = javax.imageio.ImageIO.read( getClass().getResource( \"pitt.png\" ) );\n                            } else if ( row == gameData.getWumpus().getRow() && col == gameData.getWumpus().getCol() ) {\n                                if ( gameData.getWumpus().isAlive() ) {\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( \"alive_wumpus.png\" ) );\n                                } else {\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( \"dead_wumpus.png\" ) );\n                                }\n                            } else if ( row == gameData.getGold().getRow() && col == gameData.getGold().getCol() ) {\n                                image = javax.imageio.ImageIO.read( getClass().getResource( \"g.png\" ) );\n                            } else if ( row == gameData.getHero().getRow() && col == gameData.getHero().getCol() ) {\n                                Hero hero = gameData.getHero();\n                                switch( hero.getDirection() ) {\n                                    case UP:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_up.png\" ) );\n                                        break;\n                                    case DOWN:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_down.png\" ) );\n                                        break;                                        \n                                    case LEFT:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_left.png\" ) );\n                                        break;                                        \n                                    case RIGHT:\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_right.png\" ) );\n                                        break;                                        \n                                }\n                            } else {\n                                image = javax.imageio.ImageIO.read( getClass().getResource( \"empty_room.png\" ) );\n                            }\n                        }\n                        g.drawImage( image, y, x, 50, 50, this );\n                        colPad = colPad + 3;\n                    }\n                    rowPad = rowPad + 3;\n                }\n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","id":86330,"modified_method":"public void paint(Graphics g) {\n            GameView gameView = gameUI.getGameView();\n            super.paintComponent( g );\n            try {\n                int rowIndent = 20;\n                int colIndent = 5;\n                int rowPad = 0;\n                for ( int row = 0; row < 5; row++ ) {\n                    int colPad = 0;\n                    for ( int col = 0; col < 5; col++ ) {\n                        int x = (4 - row) * 50 - rowPad + rowIndent;\n                        int y = col * 50 + colPad + colIndent;\n\n                        BufferedImage image;\n                        if ( !gameView.isShowAllCells() && (gameView.getCells() != null && gameView.getCells()[row][col].isHidden()) ) {\n                            image = javax.imageio.ImageIO.read( getClass().getResource( \"hidden_room.png\" ) );\n                        } else {\n                            if ( row == gameView.getHero().getRow() && col == gameView.getHero().getCol() ) {\n                                Hero hero = gameView.getHero();\n                                switch ( hero.getDirection() ) {\n                                    case UP :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_up.png\" ) );\n                                        break;\n                                    case DOWN :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_down.png\" ) );\n                                        break;\n                                    case LEFT :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_left.png\" ) );\n                                        break;\n                                    case RIGHT :\n                                        image = javax.imageio.ImageIO.read( getClass().getResource( \"hero_right.png\" ) );\n                                        break;\n                                    default:\n                                        throw new IllegalStateException( \"invalid direction: \" + hero.getDirection() );\n                                }\n                            } else {\n                                boolean containsPit = gameView.getPits().contains( new Pit( row, col ) );\n                                boolean containsAliveWumpus = false;\n                                boolean containsDeadWumpus = false;\n                                if ( row == gameView.getWumpus().getRow() && col == gameView.getWumpus().getCol() ) {\n                                    if ( gameView.getWumpus().isAlive() ) {\n                                        containsAliveWumpus = true;\n                                    } else {\n                                        containsDeadWumpus = true;\n                                    }\n                                }\n                                boolean containsGold = (row == gameView.getGold().getRow() && col == gameView.getGold().getCol());\n\n                                if ( !containsPit && !containsAliveWumpus && !containsDeadWumpus && !containsGold ) {\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( \"empty_room.png\" ) );\n                                } else {\n\n                                    String pit = \"\";\n                                    String wumpus = \"\";\n                                    String gold = \"\";\n\n                                    if ( containsPit ) {\n                                        pit = \"pit\";\n                                    }\n\n                                    if ( containsAliveWumpus ) {\n                                        wumpus = \"alive_wumpus\";\n                                    } else if ( containsDeadWumpus ) {\n                                        wumpus = \"dead_wumpus\";\n                                    }\n\n                                    if ( containsGold ) {\n                                        gold = \"gold\";\n                                    }\n\n                                    image = javax.imageio.ImageIO.read( getClass().getResource( pit + wumpus + gold + \".png\" ) );\n                                }\n                            }\n                        }\n                        g.drawImage( image, y, x, 50, 50, this );\n                        colPad = colPad + 3;\n                    }\n                    rowPad = rowPad + 3;\n                }\n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JPanel drawActionPanel() {\n        JPanel actionPanel = new JPanel();\n        actionPanel.setBackground( Color.WHITE );\n        actionPanel.setLayout( new GridLayout( 0, 2, 0, 0 ) );\n\n        JButton btnNewButton_4 = new JButton( \"START\" );\n        btnNewButton_4.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_4.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameData.getWumpusWorld().setData( gameData );                            \n                updateCave();\n                updateSensors();\n            }\n        } );         \n        actionPanel.add( btnNewButton_4 );\n\n        JButton btnNewButton_5 = new JButton( \"SHOOT\" );\n        btnNewButton_5.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_5.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameData.getKsession().insert( new ShootCommand() );\n                gameData.getKsession().fireAllRules();\n                updateCave();\n                updateSensors();\n            }\n        } );             \n        actionPanel.add( btnNewButton_5 );\n\n//        JButton btnNewButton_6 = new JButton( \"GRAB\" );\n//        btnNewButton_6.setBackground( Color.LIGHT_GRAY );\n//        actionPanel.add( btnNewButton_6 );\n\n//        JButton btnNewButton_7 = new JButton( \"CLIMB\" );\n//        btnNewButton_7.setBackground( Color.LIGHT_GRAY );\n//        actionPanel.add( btnNewButton_7 );\n\n        JButton btnNewButton_8 = new JButton( \"CAVE?\" );\n        btnNewButton_8.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_8.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                if ( gameData.isShowAllCells() ) {\n                    gameData.setShowAllCells( false );    \n                } else {\n                    gameData.setShowAllCells( true );\n                }                \n                updateCave();\n            }\n        } );        \n        actionPanel.add( btnNewButton_8 );\n\n//        JButton btnNewButton_9 = new JButton( \"WUMPUS?\" );\n//        btnNewButton_9.setBackground( Color.LIGHT_GRAY );\n//        actionPanel.add( btnNewButton_9 );\n\n        return actionPanel;\n    }","id":86331,"modified_method":"public JPanel drawActionPanel() {\n        JPanel actionPanel = new JPanel();\n        actionPanel.setBackground( Color.WHITE );\n        actionPanel.setLayout( new GridLayout( 0, 2, 0, 0 ) );\n\n        JButton btnNewButton_4 = new JButton( \"START\" );\n        btnNewButton_4.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_4.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameView.getKsession().insert( new Reset() );\n                gameView.getKsession().fireAllRules();\n                updateCave();\n                updateSensors();\n            }\n        } );\n        actionPanel.add( btnNewButton_4 );\n\n        JButton btnNewButton_5 = new JButton( \"SHOOT\" );\n        btnNewButton_5.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_5.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                gameView.getKsession().insert( new ShootCommand() );\n                gameView.getKsession().fireAllRules();\n                updateCave();\n                updateSensors();\n            }\n        } );\n        actionPanel.add( btnNewButton_5 );\n\n        //        JButton btnNewButton_6 = new JButton( \"GRAB\" );\n        //        btnNewButton_6.setBackground( Color.LIGHT_GRAY );\n        //        actionPanel.add( btnNewButton_6 );\n\n        //        JButton btnNewButton_7 = new JButton( \"CLIMB\" );\n        //        btnNewButton_7.setBackground( Color.LIGHT_GRAY );\n        //        actionPanel.add( btnNewButton_7 );\n\n        JButton btnNewButton_8 = new JButton( \"CAVE?\" );\n        btnNewButton_8.setBackground( Color.LIGHT_GRAY );\n        btnNewButton_8.addMouseListener( new MouseAdapter() {\n            public void mousePressed(MouseEvent e) {\n                if ( gameView.isShowAllCells() ) {\n                    gameView.setShowAllCells( false );\n                } else {\n                    gameView.setShowAllCells( true );\n                }\n                updateCave();\n            }\n        } );\n        actionPanel.add( btnNewButton_8 );\n\n        //        JButton btnNewButton_9 = new JButton( \"WUMPUS?\" );\n        //        btnNewButton_9.setBackground( Color.LIGHT_GRAY );\n        //        actionPanel.add( btnNewButton_9 );\n\n        return actionPanel;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public SensorPanel(GameView gameData) {\n            this.gameData = gameData;\n        }","id":86332,"modified_method":"public SensorPanel(GameUI gameUI) {\n            this.gameUI = gameUI;\n        }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public CavePanel(GameView gameData) {\n            this.gameData = gameData;\n        }","id":86333,"modified_method":"public CavePanel(GameUI gameUI) {\n            this.gameUI = gameUI;\n        }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public GameUI(GameView gameData) {\n        this.gameData = gameData;\n    }","id":86334,"modified_method":"public GameUI(GameView gameView) {\n        this.gameView = gameView;\n        initialize();\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public GameUI() {\n        this.gameData = new GameView();\n        this.gameData.init( new Cell[5][5], new SensorsView(), new ArrayList<Pitt>(), new Wumpus( 2, 1 ), new Gold( 3, 1 ), new Hero( 0, 0 ) );\n    }","id":86335,"modified_method":"public GameUI() {\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JPanel drawMovePanel() {\n        JPanel movePanel = new JPanel();\n        movePanel.setBackground( Color.WHITE );\n        movePanel.setLayout( new GridLayout( 0, 3, 0, 0 ) );\n\n        JPanel panel_2 = new JPanel();\n        panel_2.setBackground( Color.WHITE );\n        movePanel.add( panel_2 );\n\n        JButton btnNewButton = new JButton( \"\" );\n        btnNewButton.setForeground( Color.WHITE );\n        btnNewButton.setBackground( Color.WHITE );\n        btnNewButton.setIcon( new ImageIcon( getClass().getResource( \"up.png\" ) ) );\n        btnNewButton.addMouseListener( new MoveButtonPressed(Move.MOVE_FORWARD) );\n        \n        movePanel.add( btnNewButton );\n\n        JPanel panel_7 = new JPanel();\n        panel_7.setBackground( Color.WHITE );\n        movePanel.add( panel_7 );\n\n        JButton btnNewButton_3 = new JButton( \"\" );\n        btnNewButton_3.setForeground( Color.WHITE );\n        btnNewButton_3.setBackground( Color.WHITE );\n        btnNewButton_3.setIcon( new ImageIcon( getClass().getResource( \"left.png\" ) ) );\n        btnNewButton_3.addMouseListener( new MoveButtonPressed(Move.TURN_LEFT) );\n        movePanel.add( btnNewButton_3 );\n\n        JPanel panel_8 = new JPanel();\n        panel_8.setBackground( Color.WHITE );\n        movePanel.add( panel_8 );\n\n        JButton btnNewButton_2 = new JButton( \"\" );\n        btnNewButton_2.setForeground( Color.WHITE );\n        btnNewButton_2.setBackground( Color.WHITE );\n        btnNewButton_2.setIcon( new ImageIcon( getClass().getResource( \"right.png\" ) ) );\n        btnNewButton_2.addMouseListener( new MoveButtonPressed(Move.TURN_RIGHT) );\n        movePanel.add( btnNewButton_2 );\n\n        JPanel panel_9 = new JPanel();\n        panel_9.setBackground( Color.WHITE );\n        movePanel.add( panel_9 );\n\n        JButton btnNewButton_1 = new JButton( \"\" );\n        btnNewButton_1.setForeground( Color.WHITE );\n        btnNewButton_1.setBackground( Color.WHITE );\n        btnNewButton_1.setIcon( new ImageIcon( getClass().getResource( \"down.png\" ) ) );\n        btnNewButton_1.addMouseListener(new MoveButtonPressed(Move.MOVE_BACKWARD));\n        movePanel.add( btnNewButton_1 );\n\n        JPanel panel_10 = new JPanel();\n        panel_10.setBackground( Color.WHITE );\n        movePanel.add( panel_10 );\n\n        return movePanel;\n    }","id":86336,"modified_method":"public JPanel drawMovePanel() {\n        JPanel movePanel = new JPanel();\n        movePanel.setBackground( Color.WHITE );\n        movePanel.setLayout( new GridLayout( 0, 3, 0, 0 ) );\n\n        JPanel panel_2 = new JPanel();\n        panel_2.setBackground( Color.WHITE );\n        movePanel.add( panel_2 );\n\n        JButton btnNewButton = new JButton( \"\" );\n        btnNewButton.setForeground( Color.WHITE );\n        btnNewButton.setBackground( Color.WHITE );\n        btnNewButton.setIcon( new ImageIcon( getClass().getResource( \"up.png\" ) ) );\n        btnNewButton.setToolTipText( \"move forward\" );\n        btnNewButton.addMouseListener( new MoveButtonPressed( Move.MOVE_FORWARD ) );\n\n        movePanel.add( btnNewButton );\n\n        JPanel panel_7 = new JPanel();\n        panel_7.setBackground( Color.WHITE );\n        movePanel.add( panel_7 );\n\n        JButton btnNewButton_3 = new JButton( \"\" );\n        btnNewButton_3.setForeground( Color.WHITE );\n        btnNewButton_3.setBackground( Color.WHITE );\n        btnNewButton_3.setIcon( new ImageIcon( getClass().getResource( \"rotate_left.png\" ) ) );\n        btnNewButton_3.addMouseListener( new MoveButtonPressed( Move.TURN_LEFT ) );\n        btnNewButton_3.setToolTipText( \"rotate left\" );\n        movePanel.add( btnNewButton_3 );\n\n        JPanel panel_8 = new JPanel();\n        panel_8.setBackground( Color.WHITE );\n        movePanel.add( panel_8 );\n\n        JButton btnNewButton_2 = new JButton( \"\" );\n        btnNewButton_2.setForeground( Color.WHITE );\n        btnNewButton_2.setBackground( Color.WHITE );\n        btnNewButton_2.setIcon( new ImageIcon( getClass().getResource( \"rotate_right.png\" ) ) );\n        btnNewButton_2.addMouseListener( new MoveButtonPressed( Move.TURN_RIGHT ) );\n        btnNewButton_2.setToolTipText( \"rotate right\" );\n        movePanel.add( btnNewButton_2 );\n\n        JPanel panel_9 = new JPanel();\n        panel_9.setBackground( Color.WHITE );\n        movePanel.add( panel_9 );\n\n        JButton btnNewButton_1 = new JButton( \"\" );\n        btnNewButton_1.setForeground( Color.WHITE );\n        btnNewButton_1.setBackground( Color.WHITE );\n        btnNewButton_1.setIcon( new ImageIcon( getClass().getResource( \"down.png\" ) ) );\n        btnNewButton_1.addMouseListener( new MoveButtonPressed( Move.MOVE_BACKWARD ) );\n        btnNewButton_1.setToolTipText( \"move backward\" );\n        movePanel.add( btnNewButton_1 );\n\n        JPanel panel_10 = new JPanel();\n        panel_10.setBackground( Color.WHITE );\n        movePanel.add( panel_10 );\n\n        return movePanel;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void mousePressed(MouseEvent e) {                                    \n            gameData.getKsession().insert( new MoveCommand( move ) );\n            \n            gameData.getKsession().fireAllRules();\n            if ( gameData.isPittDeath() || gameData.isWumpusDeath() ) {\n                gameData.getKlogger().close();\n                gameData.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog(null,\n                                                           \"Play Again1?\", \"DEAD\", JOptionPane.OK_OPTION);\n                gameData.getWumpusWorld().setData( gameData );                            \n                updateCave();\n                updateSensors();                    \n            } else if ( gameData.isGoldWin() ) {\n                gameData.getKlogger().close();\n                gameData.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog(null,\n                                                           \"Play Again1?\", \"WIN\", JOptionPane.OK_OPTION);\n                gameData.getWumpusWorld().setData( gameData );                            \n                updateCave();\n                updateSensors();                    \n            } \n            else {\n                updateCave();\n                updateSensors();\n            }              \n        }","id":86337,"modified_method":"public void mousePressed(MouseEvent e) {\n            gameView.getKsession().insert( new MoveCommand( move ) );\n\n            gameView.getKsession().fireAllRules();\n            if ( gameView.isPitDeath() || gameView.isWumpusDeath() ) {\n                gameView.getKlogger().close();\n                gameView.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog( null,\n                                                            \"Play Again1?\", \"DEAD\", JOptionPane.OK_OPTION );\n                gameView.getWumpusWorld().setData( gameView );\n                updateCave();\n                updateSensors();\n            } else if ( gameView.isGoldWin() ) {\n                gameView.getKlogger().close();\n                gameView.setShowAllCells( true );\n                updateCave();\n                updateSensors();\n                int answre = JOptionPane.showConfirmDialog( null,\n                                                            \"Play Again1?\", \"WIN\", JOptionPane.OK_OPTION );\n                gameView.getWumpusWorld().setData( gameView );\n                updateCave();\n                updateSensors();\n            }\n            else {\n                updateCave();\n                updateSensors();\n            }\n        }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void paint(Graphics g) {\n            super.paintComponent( g );\n            try {\n                SensorsView sensor = gameData.getSensorsview();\n                if ( sensor.isFeelBreeze() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"breeze.png\" ) );\n                    g.drawImage( image, 0, 0, 150, 150, this );\n                  }\n\n                  if ( sensor.isSmellStench() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"stench.png\" ) );\n                    g.drawImage( image, 153, 0, 150, 150, this );\n                  }\n\n                  if ( sensor.isSeeGlitter() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"glitter.png\" ) );\n                    g.drawImage( image, 306, 0, 150, 150, this );\n                  }\n \n                  if ( sensor.isFeelBump() ) {\n                      BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"bump.png\" ) );\n                      g.drawImage( image, 459, 0, 150, 150, this );\n                  }                  \n                  \n                  if ( sensor.isHearScream() ) {\n                      BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"scream.png\" ) );\n                      g.drawImage( image, 612, 0, 150, 150, this );\n                  }                  \n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","id":86338,"modified_method":"public void paint(Graphics g) {\n            super.paintComponent( g );\n            GameView gameView = gameUI.getGameView();\n            try {\n                SensorsView sensor = gameView.getSensorsview();\n                if ( sensor.isFeelBreeze() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"breeze.png\" ) );\n                    g.drawImage( image, 0, 0, 150, 150, this );\n                }\n\n                if ( sensor.isSmellStench() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"stench.png\" ) );\n                    g.drawImage( image, 153, 0, 150, 150, this );\n                }\n\n                if ( sensor.isSeeGlitter() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"glitter.png\" ) );\n                    g.drawImage( image, 306, 0, 150, 150, this );\n                }\n\n                if ( sensor.isFeelBump() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"bump.png\" ) );\n                    g.drawImage( image, 459, 0, 150, 150, this );\n                }\n\n                if ( sensor.isHearScream() ) {\n                    BufferedImage image = javax.imageio.ImageIO.read( getClass().getResource( \"scream.png\" ) );\n                    g.drawImage( image, 612, 0, 150, 150, this );\n                }\n            } catch ( Exception e ) {\n                e.printStackTrace();\n                throw new RuntimeException( e );\n            }\n        }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static final void run(final GameView gameData) {\n        GameUI window = new GameUI(gameData);\n        window.initialize();        \n    }","id":86339,"modified_method":"public void setGameView(GameView gameView) {\n        this.gameView = gameView;\n        if ( frame == null ) {\n            initialize();\n        }\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setPits(List<Pitt> pits) {\n        this.pits = pits;\n    }","id":86340,"modified_method":"public void setPits(List<Pit> pits) {\n        this.pits = pits;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setPittDeath(boolean pittDeath) {\n        this.pittDeath = pittDeath;\n    }","id":86341,"modified_method":"public void setPitDeath(boolean pitDeath) {\n        this.pitDeath = pitDeath;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public List<Pitt> getPits() {\n        return pits;\n    }","id":86342,"modified_method":"public List<Pit> getPits() {\n        return pits;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean isPittDeath() {\n        return pittDeath;\n    }","id":86343,"modified_method":"public boolean isPitDeath() {\n        return pitDeath;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init(Cell[][] cells,\n                     SensorsView sensors,\n                     List<Pitt> pits,\n                     Wumpus wumpus,\n                     Gold gold,\n                     Hero hero) {\n        this.showAllCells = false;\n        this.pittDeath = false;\n        this.goldWin = false;\n        this.wumpusDeath = false;\n        this.cells = cells;\n        this.sensors = sensors;\n        this.pits = pits;\n        this.wumpus = wumpus;\n        this.gold = gold;\n        this.hero = hero;\n    }","id":86344,"modified_method":"public void init(Cell[][] cells,\n                     SensorsView sensors,\n                     List<Pit> pits,\n                     Wumpus wumpus,\n                     Gold gold,\n                     Hero hero,\n                     int cellheight,\n                     int cellWidth,\n                     int cellPadding,\n                     int pittPercentage,\n                     int rows,\n                     int cols) {\n        this.showAllCells = false;\n        this.pitDeath = false;\n        this.goldWin = false;\n        this.wumpusDeath = false;\n        this.cells = cells;\n        this.sensors = sensors;\n        this.pits = pits;\n        this.wumpus = wumpus;\n        this.gold = gold;\n        this.hero = hero;\n        this.cellheight = cellheight;\n        this.cellWidth = cellWidth;\n        this.cellPadding = cellPadding;\n        this.pittPercentage = pittPercentage;\n        this.rows = rows;\n        this.cols = cols;\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setData(GameView data) {\n        KnowledgeBase kbase = data.getKbase();\n\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();        \n        KnowledgeRuntimeLogger klogger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/wumpus\");   \n        data.setKlogger( klogger );\n\n        List<Pitt> pitts = new ArrayList<Pitt>();\n        java.util.Random gen = new java.util.Random();\n        Cell[][] cells = new Cell[5][5];\n        for ( int i = 0; i < 5; i++ ) {\n            for ( int j = 0; j < 5; j++ ) {\n                Cell cell = new Cell( i, j );\n                cells[i][j] = cell;\n                if ( i == 0 && j == 0 ) {\n                    cell.setHidden( false );\n                }\n                ksession.insert( cell );\n                if ( j != 0 && i != 0 && gen.nextInt( 99 ) <= 19 ) {\n                    // 20% chance of pitt\n                    Pitt pitt = new Pitt( i, j );\n                    ksession.insert( pitt );\n                    pitts.add( pitt );\n                }\n            }\n        }\n\n        int row = 0;\n        int col = 0;\n        while ( (row == 0 && col == 0) || pitts.contains( new Pitt( row, col ) ) ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Wumpus wumpus = new Wumpus( row, col );\n\n        row = 0;\n        col = 0;\n        while ( (row == 0 && col == 0) || (wumpus.getRow() == row && wumpus.getCol() == col) || pitts.contains( new Pitt( row, col ) ) ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Gold gold = new Gold( row, col );\n        Hero hero = new Hero( 0, 0 );\n\n        SensorsView sensors = new SensorsView();\n        \n        ksession.insert( wumpus );\n        ksession.insert( gold );\n        ksession.insert( hero );\n        ksession.insert( sensors );\n        ksession.insert( data );\n        \n        ksession.fireAllRules();    \n        data.init(cells, sensors, pitts, wumpus, gold, hero );\n        data.setKsession( ksession );\n    }","id":86345,"modified_method":"public void setData(GameView view) {\n        KnowledgeBase kbase = view.getKbase();\n\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();        \n        KnowledgeRuntimeLogger klogger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, \"log/wumpus\");   \n        view.setKlogger( klogger );\n\n        List<Pit> pitts = new ArrayList<Pit>();\n        java.util.Random gen = new java.util.Random();\n        Cell[][] cells = new Cell[5][5];\n        for ( int i = 0; i < 5; i++ ) {\n            for ( int j = 0; j < 5; j++ ) {\n                Cell cell = new Cell( i, j );\n                cells[i][j] = cell;\n                if ( i == 0 && j == 0 ) {\n                    cell.setHidden( false );\n                }\n                ksession.insert( cell );\n                if ( j != 0 && i != 0 && gen.nextInt( 99 ) <= 19 ) {\n                    // 20% chance of pitt\n                    Pit pitt = new Pit( i, j );\n                    ksession.insert( pitt );\n                    pitts.add( pitt );\n                }\n            }\n        }\n\n        int row = 0;\n        int col = 0;\n        while ( row == 0 && col == 0 ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Wumpus wumpus = new Wumpus( row, col );\n\n        row = 0;\n        col = 0;\n        while ( row == 0 && col == 0 ) {\n            row = gen.nextInt( 4 );\n            col = gen.nextInt( 4 );\n        }\n        Gold gold = new Gold( row, col );\n        Hero hero = new Hero( 0, 0 );\n\n        SensorsView sensors = new SensorsView();\n        \n        ksession.insert( wumpus );\n        ksession.insert( gold );\n        ksession.insert( hero );\n        ksession.insert( sensors );\n        ksession.insert( view );\n        \n        ksession.fireAllRules();    \n        view.init(cells, sensors, pitts, wumpus, gold, hero, 50, 50, 3, 20, 5, 5 );\n        view.setKsession( ksession );\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void init() throws InterruptedException {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add( ResourceFactory.newClassPathResource( \"commands.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"sensors.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"collision.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"ui.drl\", GameView.class ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }      \n        \n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n\n\n        \n        GameView data = new GameView();\n        data.setKbase( kbase );\n        data.setWumpusWorld( this );\n        setData(data);\n        GameUI.run(data );\n        //Thread.sleep( 10 * 10000 );\n    }","id":86346,"modified_method":"public void init() throws InterruptedException {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"init.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }        \n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"commands.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"sensors.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n\n        kbuilder.add( ResourceFactory.newClassPathResource( \"collision.drl\", getClass() ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }\n        \n        kbuilder.add( ResourceFactory.newClassPathResource( \"ui.drl\", GameView.class ), ResourceType.DRL );\n\n        if ( kbuilder.hasErrors() ) {\n            throw new RuntimeException( \"failed to build:\\n\" + kbuilder.getErrors().toString() );\n        }      \n        \n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\n\n        StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();\n        ksession.setGlobal(\"randomInteger\",new java.util.Random() );\n        ksession.fireAllRules();\n    }","commit_id":"b9370e6e99fe63ef0f3b43bd150d7ed4588af5d8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n  public void testMergeRegions() throws Exception {\n    TableName tableName = TableName.valueOf(\"testMergeWithFullRegionName\");\n    HColumnDescriptor cd = new HColumnDescriptor(\"d\");\n    HTableDescriptor td = new HTableDescriptor(tableName);\n    td.addFamily(cd);\n    byte[][] splitRows = new byte[2][];\n    splitRows[0] = new byte[]{(byte)'3'};\n    splitRows[1] = new byte[]{(byte)'6'};\n    try {\n      TEST_UTIL.createTable(td, splitRows);\n      TEST_UTIL.waitTableAvailable(tableName);\n\n      List<HRegionInfo> tableRegions;\n      HRegionInfo regionA;\n      HRegionInfo regionB;\n\n      // merge with full name\n      tableRegions = admin.getTableRegions(tableName);\n      assertEquals(3, admin.getTableRegions(tableName).size());\n      regionA = tableRegions.get(0);\n      regionB = tableRegions.get(1);\n      admin.mergeRegionsAsync(regionA.getRegionName(), regionB.getRegionName(), false);\n      Thread.sleep(1000);\n      assertEquals(2, admin.getTableRegions(tableName).size());\n\n      // merge with encoded name\n      tableRegions = admin.getTableRegions(tableName);\n      regionA = tableRegions.get(0);\n      regionB = tableRegions.get(1);\n      admin.mergeRegionsAsync(\n        regionA.getEncodedNameAsBytes(), regionB.getEncodedNameAsBytes(), false);\n      Thread.sleep(1000);\n      assertEquals(1, admin.getTableRegions(tableName).size());\n    } finally {\n      this.admin.disableTable(tableName);\n      this.admin.deleteTable(tableName);\n    }\n  }","id":86347,"modified_method":"@Test (timeout=300000)\n  public void testMergeRegions() throws Exception {\n    TableName tableName = TableName.valueOf(\"testMergeWithFullRegionName\");\n    HColumnDescriptor cd = new HColumnDescriptor(\"d\");\n    HTableDescriptor td = new HTableDescriptor(tableName);\n    td.addFamily(cd);\n    byte[][] splitRows = new byte[2][];\n    splitRows[0] = new byte[]{(byte)'3'};\n    splitRows[1] = new byte[]{(byte)'6'};\n    try {\n      TEST_UTIL.createTable(td, splitRows);\n      TEST_UTIL.waitTableAvailable(tableName);\n\n      List<HRegionInfo> tableRegions;\n      HRegionInfo regionA;\n      HRegionInfo regionB;\n\n      // merge with full name\n      tableRegions = admin.getTableRegions(tableName);\n      assertEquals(3, admin.getTableRegions(tableName).size());\n      regionA = tableRegions.get(0);\n      regionB = tableRegions.get(1);\n      // TODO convert this to version that is synchronous (See HBASE-16668)\n      admin.mergeRegionsAsync(regionA.getRegionName(), regionB.getRegionName(), false)\n          .get(60, TimeUnit.SECONDS);\n\n      assertEquals(2, admin.getTableRegions(tableName).size());\n\n      // merge with encoded name\n      tableRegions = admin.getTableRegions(tableName);\n      regionA = tableRegions.get(0);\n      regionB = tableRegions.get(1);\n      // TODO convert this to version that is synchronous (See HBASE-16668)\n      admin.mergeRegionsAsync(\n        regionA.getEncodedNameAsBytes(), regionB.getEncodedNameAsBytes(), false)\n          .get(60, TimeUnit.SECONDS);\n\n      assertEquals(1, admin.getTableRegions(tableName).size());\n    } finally {\n      this.admin.disableTable(tableName);\n      this.admin.deleteTable(tableName);\n    }\n  }","commit_id":"055dde7dfc15ff3de66a78b621844ad6f8c68174","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testSplitAndMergeWithReplicaTable() throws Exception {\n    // The test tries to directly split replica regions and directly merge replica regions. These\n    // are not allowed. The test validates that. Then the test does a valid split/merge of allowed\n    // regions.\n    // Set up a table with 3 regions and replication set to 3\n    TableName tableName = TableName.valueOf(\"testSplitAndMergeWithReplicaTable\");\n    HTableDescriptor desc = new HTableDescriptor(tableName);\n    desc.setRegionReplication(3);\n    byte[] cf = \"f\".getBytes();\n    HColumnDescriptor hcd = new HColumnDescriptor(cf);\n    desc.addFamily(hcd);\n    byte[][] splitRows = new byte[2][];\n    splitRows[0] = new byte[]{(byte)'4'};\n    splitRows[1] = new byte[]{(byte)'7'};\n    TEST_UTIL.getAdmin().createTable(desc, splitRows);\n    List<HRegion> oldRegions;\n    do {\n      oldRegions = TEST_UTIL.getHBaseCluster().getRegions(tableName);\n      Thread.sleep(10);\n    } while (oldRegions.size() != 9); //3 regions * 3 replicas\n    // write some data to the table\n    Table ht = TEST_UTIL.getConnection().getTable(tableName);\n    List<Put> puts = new ArrayList<Put>();\n    byte[] qualifier = \"c\".getBytes();\n    Put put = new Put(new byte[]{(byte)'1'});\n    put.addColumn(cf, qualifier, \"100\".getBytes());\n    puts.add(put);\n    put = new Put(new byte[]{(byte)'6'});\n    put.addColumn(cf, qualifier, \"100\".getBytes());\n    puts.add(put);\n    put = new Put(new byte[]{(byte)'8'});\n    put.addColumn(cf, qualifier, \"100\".getBytes());\n    puts.add(put);\n    ht.put(puts);\n    ht.close();\n    List<Pair<HRegionInfo, ServerName>> regions =\n        MetaTableAccessor.getTableRegionsAndLocations(TEST_UTIL.getConnection(), tableName);\n    boolean gotException = false;\n    // the element at index 1 would be a replica (since the metareader gives us ordered\n    // regions). Try splitting that region via the split API . Should fail\n    try {\n      TEST_UTIL.getAdmin().splitRegion(regions.get(1).getFirst().getRegionName());\n    } catch (IllegalArgumentException ex) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    gotException = false;\n    // the element at index 1 would be a replica (since the metareader gives us ordered\n    // regions). Try splitting that region via a different split API (the difference is\n    // this API goes direct to the regionserver skipping any checks in the admin). Should fail\n    try {\n      TEST_UTIL.getHBaseAdmin().split(regions.get(1).getSecond(), regions.get(1).getFirst(),\n          new byte[]{(byte)'1'});\n    } catch (IOException ex) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    gotException = false;\n    // Try merging a replica with another. Should fail.\n    try {\n      TEST_UTIL.getAdmin().mergeRegionsAsync(regions.get(1).getFirst().getEncodedNameAsBytes(),\n          regions.get(2).getFirst().getEncodedNameAsBytes(), true);\n    } catch (IllegalArgumentException m) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    // Try going to the master directly (that will skip the check in admin)\n    try {\n      DispatchMergingRegionsRequest request = RequestConverter\n          .buildDispatchMergingRegionsRequest(\n            regions.get(1).getFirst().getEncodedNameAsBytes(),\n            regions.get(2).getFirst().getEncodedNameAsBytes(),\n            true,\n            HConstants.NO_NONCE,\n            HConstants.NO_NONCE);\n      ((ClusterConnection) TEST_UTIL.getAdmin().getConnection()).getMaster()\n        .dispatchMergingRegions(null, request);\n    } catch (ServiceException m) {\n      Throwable t = m.getCause();\n      do {\n        if (t instanceof MergeRegionException) {\n          gotException = true;\n          break;\n        }\n        t = t.getCause();\n      } while (t != null);\n    }\n    assertTrue(gotException);\n    gotException = false;\n    // Try going to the regionservers directly\n    // first move the region to the same regionserver\n    if (!regions.get(2).getSecond().equals(regions.get(1).getSecond())) {\n      moveRegionAndWait(regions.get(2).getFirst(), regions.get(1).getSecond());\n    }\n    try {\n      AdminService.BlockingInterface admin = ((ClusterConnection) TEST_UTIL.getAdmin()\n        .getConnection()).getAdmin(regions.get(1).getSecond());\n      ProtobufUtil.mergeRegions(null, admin, regions.get(1).getFirst(), regions.get(2).getFirst(),\n        true, null);\n    } catch (MergeRegionException mm) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n  }","id":86348,"modified_method":"@Test\n  public void testSplitAndMergeWithReplicaTable() throws Exception {\n    // The test tries to directly split replica regions and directly merge replica regions. These\n    // are not allowed. The test validates that. Then the test does a valid split/merge of allowed\n    // regions.\n    // Set up a table with 3 regions and replication set to 3\n    TableName tableName = TableName.valueOf(\"testSplitAndMergeWithReplicaTable\");\n    HTableDescriptor desc = new HTableDescriptor(tableName);\n    desc.setRegionReplication(3);\n    byte[] cf = \"f\".getBytes();\n    HColumnDescriptor hcd = new HColumnDescriptor(cf);\n    desc.addFamily(hcd);\n    byte[][] splitRows = new byte[2][];\n    splitRows[0] = new byte[]{(byte)'4'};\n    splitRows[1] = new byte[]{(byte)'7'};\n    TEST_UTIL.getAdmin().createTable(desc, splitRows);\n    List<HRegion> oldRegions;\n    do {\n      oldRegions = TEST_UTIL.getHBaseCluster().getRegions(tableName);\n      Thread.sleep(10);\n    } while (oldRegions.size() != 9); //3 regions * 3 replicas\n    // write some data to the table\n    Table ht = TEST_UTIL.getConnection().getTable(tableName);\n    List<Put> puts = new ArrayList<Put>();\n    byte[] qualifier = \"c\".getBytes();\n    Put put = new Put(new byte[]{(byte)'1'});\n    put.addColumn(cf, qualifier, \"100\".getBytes());\n    puts.add(put);\n    put = new Put(new byte[]{(byte)'6'});\n    put.addColumn(cf, qualifier, \"100\".getBytes());\n    puts.add(put);\n    put = new Put(new byte[]{(byte)'8'});\n    put.addColumn(cf, qualifier, \"100\".getBytes());\n    puts.add(put);\n    ht.put(puts);\n    ht.close();\n    List<Pair<HRegionInfo, ServerName>> regions =\n        MetaTableAccessor.getTableRegionsAndLocations(TEST_UTIL.getConnection(), tableName);\n    boolean gotException = false;\n    // the element at index 1 would be a replica (since the metareader gives us ordered\n    // regions). Try splitting that region via the split API . Should fail\n    try {\n      TEST_UTIL.getAdmin().splitRegion(regions.get(1).getFirst().getRegionName());\n    } catch (IllegalArgumentException ex) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    gotException = false;\n    // the element at index 1 would be a replica (since the metareader gives us ordered\n    // regions). Try splitting that region via a different split API (the difference is\n    // this API goes direct to the regionserver skipping any checks in the admin). Should fail\n    try {\n      TEST_UTIL.getHBaseAdmin().split(regions.get(1).getSecond(), regions.get(1).getFirst(),\n          new byte[]{(byte)'1'});\n    } catch (IOException ex) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    gotException = false;\n    // Try merging a replica with another. Should fail.\n    try {\n      // TODO convert this to version that is synchronous (See HBASE-16668)\n      TEST_UTIL.getAdmin().mergeRegionsAsync(regions.get(1).getFirst().getEncodedNameAsBytes(),\n          regions.get(2).getFirst().getEncodedNameAsBytes(), true)\n          .get(60, TimeUnit.SECONDS);\n    } catch (IllegalArgumentException m) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    // Try going to the master directly (that will skip the check in admin)\n    try {\n      DispatchMergingRegionsRequest request = RequestConverter\n          .buildDispatchMergingRegionsRequest(\n            regions.get(1).getFirst().getEncodedNameAsBytes(),\n            regions.get(2).getFirst().getEncodedNameAsBytes(),\n            true,\n            HConstants.NO_NONCE,\n            HConstants.NO_NONCE);\n      ((ClusterConnection) TEST_UTIL.getAdmin().getConnection()).getMaster()\n        .dispatchMergingRegions(null, request);\n    } catch (ServiceException m) {\n      Throwable t = m.getCause();\n      do {\n        if (t instanceof MergeRegionException) {\n          gotException = true;\n          break;\n        }\n        t = t.getCause();\n      } while (t != null);\n    }\n    assertTrue(gotException);\n    gotException = false;\n    // Try going to the regionservers directly\n    // first move the region to the same regionserver\n    if (!regions.get(2).getSecond().equals(regions.get(1).getSecond())) {\n      moveRegionAndWait(regions.get(2).getFirst(), regions.get(1).getSecond());\n    }\n    try {\n      AdminService.BlockingInterface admin = ((ClusterConnection) TEST_UTIL.getAdmin()\n        .getConnection()).getAdmin(regions.get(1).getSecond());\n      ProtobufUtil.mergeRegions(null, admin, regions.get(1).getFirst(), regions.get(2).getFirst(),\n        true, null);\n    } catch (MergeRegionException mm) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n  }","commit_id":"055dde7dfc15ff3de66a78b621844ad6f8c68174","url":"https://github.com/apache/hbase"},{"original_method":"public List getReleases( List issues )\n    {\n        List releases = new ArrayList();\n\n        Release release = new Release();\n\n\n        for ( int i = 0; i < issues.size(); i++ )\n        {\n            JiraAnnouncement issue = (JiraAnnouncement) issues.get( i );\n\n            Action action = createAction( issue );\n            \n            release.addAction( action );\n\n            release.setDescription( issue.getSummary() );\n\n            release.setVersion( issue.getFixVersion() );\n\n            releases.add( release );\n        }\n        return releases;\n    }","id":86349,"modified_method":"public List getReleases( List issues )\n    {\n        // A Map of releases keyed by fixVersion\n        Map releasesMap = new HashMap();\n\n        // Loop through all issues looking for fixVersions\n        for ( int i = 0; i < issues.size(); i++ )\n        {\n            JiraAnnouncement issue = (JiraAnnouncement) issues.get( i );\n            // Do NOT create a release for issues that lack a fixVersion\n            if ( issue.getFixVersion() != null )\n            {\n                // Try to get a matching Release from the map\n                Release release = (Release) releasesMap.get( issue.getFixVersion() );\n                if ( release == null )\n                {\n                    // Add a new Release to the Map if it wasn't there\n                    release = new Release();\n                    release.setVersion( issue.getFixVersion() );\n                    releasesMap.put( issue.getFixVersion(), release );\n                }\n\n                // Add this issue as an Action to this release\n                Action action = createAction( issue );\n                release.addAction( action );\n            }\n        }\n\n        // Extract the releases from the Map to a List\n        List releasesList = new ArrayList();\n        for ( Iterator iterator = releasesMap.entrySet().iterator(); iterator.hasNext(); )\n        {\n            Release o = (Release) ( (Map.Entry) iterator.next() ).getValue();\n            releasesList.add( o );\n        }\n        return releasesList;\n    }","commit_id":"40547ec3b7b3027380658723ae5a495551ade26a","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected com.xpn.xwiki.api.Object getExtensionVersionObject(Document extensionDocument, String version)\n    {\n        if (version == null) {\n            Vector<com.xpn.xwiki.api.Object> objects = extensionDocument.getObjects(\"XWiki.ExtensionVersionClass\");\n\n            if (objects.isEmpty()) {\n                return null;\n            } else {\n                return objects.lastElement();\n            }\n        }\n\n        return extensionDocument.getObject(\"XWiki.ExtensionVersionClass\", \"version\", version, false);\n    }","id":86350,"modified_method":"protected com.xpn.xwiki.api.Object getExtensionVersionObject(Document extensionDocument, String version)\n    {\n        if (version == null) {\n            Vector<com.xpn.xwiki.api.Object> objects = extensionDocument.getObjects(EXTENSIONVERSION_CLASSNAME);\n\n            if (objects.isEmpty()) {\n                return null;\n            } else {\n                return objects.lastElement();\n            }\n        }\n\n        return extensionDocument.getObject(EXTENSIONVERSION_CLASSNAME, \"version\", version, false);\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected com.xpn.xwiki.api.Object getExtensionObject(Document extensionDocument)\n    {\n        return extensionDocument.getObject(\"XWiki.ExtensionClass\");\n    }","id":86351,"modified_method":"protected com.xpn.xwiki.api.Object getExtensionObject(Document extensionDocument)\n    {\n        return extensionDocument.getObject(EXTENSION_CLASSNAME);\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Extension createExtension(Document extensionDocument, String version)\n    {\n        com.xpn.xwiki.api.Object extensionObject = getExtensionObject(extensionDocument);\n\n        if (extensionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        com.xpn.xwiki.api.Object extensionVersionObject = getExtensionVersionObject(extensionDocument, version);\n\n        if (extensionVersionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        Extension extension = this.objectFactory.createExtension();\n        extension.setId((String) getValue(extensionObject, \"id\"));\n        extension.setVersion((String) getValue(extensionVersionObject, \"version\"));\n        extension.setType((String) getValue(extensionObject, \"type\"));\n\n        extension.getAuthors().addAll((List<String>) getValue(extensionObject, \"authors\"));\n        extension.setDescription((String) getValue(extensionObject, \"description\"));\n        extension.setName((String) getValue(extensionObject, \"name\"));\n        extension.setWebsite((String) getValue(extensionObject, \"website\"));\n        extension.getFeatures().addAll((List<String>) getValue(extensionObject, \"features\"));\n\n        for (com.xpn.xwiki.api.Object dependencyObject : extensionDocument.getObjects(\"XWiki.ExtensionDependencyClass\",\n            \"extensionversion\", version)) {\n            ExtensionDependency dependency = new ExtensionDependency();\n            dependency.setId((String) getValue(dependencyObject, \"id\"));\n            dependency.setVersion((String) getValue(dependencyObject, \"version\"));\n\n            extension.getDependencies().add(dependency);\n        }\n\n        return extension;\n    }","id":86352,"modified_method":"protected Extension createExtension(Document extensionDocument, String version)\n    {\n        com.xpn.xwiki.api.Object extensionObject = getExtensionObject(extensionDocument);\n\n        if (extensionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        com.xpn.xwiki.api.Object extensionVersionObject = getExtensionVersionObject(extensionDocument, version);\n\n        if (extensionVersionObject == null) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        Extension extension;\n        ExtensionVersion extensionVersion;\n        if (version == null) {\n            extension = this.objectFactory.createExtension();\n            extensionVersion = null;\n        } else {\n            extension = extensionVersion = this.objectFactory.createExtensionVersion();\n            extensionVersion.setVersion((String) getValue(extensionVersionObject, \"version\"));\n        }\n\n        extension.setId((String) getValue(extensionObject, \"id\"));\n        extension.setType((String) getValue(extensionObject, \"type\"));\n\n        extension.getAuthors().addAll((List<String>) getValue(extensionObject, \"authors\"));\n        extension.setDescription((String) getValue(extensionObject, \"description\"));\n        extension.setName((String) getValue(extensionObject, \"name\"));\n        extension.setWebsite((String) getValue(extensionObject, \"website\"));\n        extension.getFeatures().addAll((List<String>) getValue(extensionObject, \"features\"));\n\n        if (extensionVersion != null) {\n            for (com.xpn.xwiki.api.Object dependencyObject : extensionDocument.getObjects(\n                EXTENSIONDEPENDENCY_CLASSNAME, \"extensionversion\", version)) {\n                ExtensionDependency dependency = new ExtensionDependency();\n                dependency.setId((String) getValue(dependencyObject, \"id\"));\n                dependency.setVersion((String) getValue(dependencyObject, \"version\"));\n\n                extensionVersion.getDependencies().add(dependency);\n            }\n        }\n\n        return extension;\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected Document getExtensionDocument(String extensionId) throws XWikiException, QueryException\n    {\n        String query = \"from doc.object(XWiki.ExtensionClass) as extension where extension.id = :extensionId\";\n\n        List<String> documentNames =\n            this.queryManager.createQuery(query, Query.XWQL).bindValue(\"extensionId\", extensionId).execute();\n\n        if (documentNames.isEmpty()) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        return Utils.getXWikiApi(this.componentManager).getDocument(documentNames.get(0));\n    }","id":86353,"modified_method":"protected Document getExtensionDocument(String extensionId) throws XWikiException, QueryException\n    {\n        Query query =\n            this.queryManager.createQuery(\"from doc.object(\" + EXTENSION_CLASSNAME\n                + \") where extension.id = :extensionId\", Query.XWQL);\n\n        query.bindValue(\"extensionId\", extensionId);\n\n        List<String> documentNames = query.execute();\n\n        if (documentNames.isEmpty()) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        return Utils.getXWikiApi(this.componentManager).getDocument(documentNames.get(0));\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public XWikiExtension(XWikiExtensionRepository repository, Extension extension)\n    {\n        super(repository, new ExtensionId(extension.getId(), extension.getVersion()), extension.getType());\n\n        setName(extension.getName());\n        setDescription(extension.getDescription());\n        setAuthors(extension.getAuthors());\n        setWebsite(extension.getWebsite());\n        setFeatures(extension.getFeatures());\n\n        for (ExtensionDependency dependency : extension.getDependencies()) {\n            addDependency(new XWikiExtensionDependency(dependency));\n        }\n    }","id":86354,"modified_method":"public XWikiExtension(XWikiExtensionRepository repository, ExtensionVersion extension)\n    {\n        super(repository, new ExtensionId(extension.getId(), extension.getVersion()), extension.getType());\n\n        setName(extension.getName());\n        setDescription(extension.getDescription());\n        setAuthors(extension.getAuthors());\n        setWebsite(extension.getWebsite());\n        setFeatures(extension.getFeatures());\n\n        for (ExtensionDependency dependency : extension.getDependencies()) {\n            addDependency(new XWikiExtensionDependency(dependency));\n        }\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        try {\n            return new XWikiExtension(\n                this,\n                (org.xwiki.extension.repository.xwiki.model.jaxb.Extension) this.repositoryFactory\n                    .getUnmarshaller()\n                    .unmarshal(\n                        getRESTResourceAsStream(this.extensionUriBuider, extensionId.getId(), extensionId.getVersion())));\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to create extension object for extension [\" + extensionId + \"]\", e);\n        }\n    }","id":86355,"modified_method":"public Extension resolve(ExtensionId extensionId) throws ResolveException\n    {\n        try {\n            return new XWikiExtension(this, (ExtensionVersion) this.repositoryFactory.getUnmarshaller().unmarshal(\n                getRESTResourceAsStream(this.extensionUriBuider, extensionId.getId(), extensionId.getVersion())));\n        } catch (Exception e) {\n            throw new ResolveException(\"Failed to create extension object for extension [\" + extensionId + \"]\", e);\n        }\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<Extension> search(String pattern, int offset, int nb) throws SearchException\n    {\n        Extensions restExtensions;\n        try {\n            restExtensions =\n                (Extensions) this.repositoryFactory.getUnmarshaller().unmarshal(\n                    getRESTResourceAsStream(this.simplesearchUriBuider, pattern));\n        } catch (Exception e) {\n            throw new SearchException(\"Failed to search extensions based on pattern [\" + pattern + \"]\", e);\n        }\n\n        List<Extension> extensions = new ArrayList<Extension>(restExtensions.getExtensions().size());\n        for (org.xwiki.extension.repository.xwiki.model.jaxb.Extension restExtension : restExtensions.getExtensions()) {\n            extensions.add(new XWikiExtension(this, restExtension));\n        }\n\n        return extensions;\n    }","id":86356,"modified_method":"public List<Extension> search(String pattern, int offset, int nb) throws SearchException\n    {\n        SearchResult restExtensions;\n        try {\n            restExtensions =\n                (SearchResult) this.repositoryFactory.getUnmarshaller().unmarshal(\n                    getRESTResourceAsStream(this.simplesearchUriBuider, pattern));\n        } catch (Exception e) {\n            throw new SearchException(\"Failed to search extensions based on pattern [\" + pattern + \"]\", e);\n        }\n\n        List<Extension> extensions = new ArrayList<Extension>(restExtensions.getExtensions().size());\n        for (ExtensionVersion restExtension : restExtensions.getExtensions()) {\n            extensions.add(new XWikiExtension(this, restExtension));\n        }\n\n        return extensions;\n    }","commit_id":"aa86cdae4d0f3aea78471c196db2ffe6161d0291","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Handle an incoming syslog message: Output if in debug mode, store in MongoDB, ReceiveHooks\n     *\n     * @param syslogServer The syslog server\n     * @param event        The event to handle\n     */\n    @Override\n    public void event(SyslogServerIF syslogServer, SocketAddress socketAddress, SyslogServerEventIF event) {\n\n        GELFMessage gelf = new GELFMessage();\n\n        // Print out debug information.\n        if (event instanceof GraylogSyslogServerEvent) {\n            GraylogSyslogServerEvent glEvent = (GraylogSyslogServerEvent) event;\n            LOG.debug(\"Received syslog message (via AMQP): \" + event.getMessage());\n            LOG.debug(\"AMQP queue: \" + glEvent.getAmqpReceiverQueue());\n\n            gelf.addAdditionalData(\"_amqp_queue\", glEvent.getAmqpReceiverQueue());\n        } else {\n            LOG.debug(\"Received syslog message: \" + event.getMessage());\n        }\n        LOG.debug(\"Host: \" + event.getHost());\n        LOG.debug(\"Facility: \" + event.getFacility() + \" (\" + Tools.syslogFacilityToReadable(event.getFacility()) + \")\");\n        LOG.debug(\"Level: \" + event.getLevel() + \" (\" + Tools.syslogLevelToReadable(event.getLevel()) + \")\");\n        LOG.debug(\"Raw: \" + new String(event.getRaw()));\n\n        gelf.setCreatedAt(Tools.getUTCTimestampWithMilliseconds(event.getDate().getTime()));\n        gelf.setConvertedFromSyslog(true);\n        gelf.setVersion(\"0\");\n        gelf.setShortMessage(event.getMessage());\n\n        gelf.setHost(event.getHost());\n        gelf.setFacility(Tools.syslogFacilityToReadable(event.getFacility()));\n        gelf.setLevel(event.getLevel());\n        gelf.setRaw(event.getRaw());\n\n        try {\n            SimpleGELFClientHandler gelfHandler = new SimpleGELFClientHandler(gelf);\n            gelfHandler.handle();\n        } catch (Exception e) {\n            LOG.debug(\"Couldn't process message with GELF handler\", e);\n        }\n    }","id":86357,"modified_method":"/**\n     * Handle an incoming syslog message: Output if in debug mode, store in MongoDB, ReceiveHooks\n     *\n     * @param syslogServer The syslog server\n     * @param event        The event to handle\n     */\n    @Override\n    public void event(SyslogServerIF syslogServer, SocketAddress socketAddress, SyslogServerEventIF event) {\n\n        GELFMessage gelf = new GELFMessage();\n\n        // Print out debug information.\n        if (event instanceof GraylogSyslogServerEvent) {\n            GraylogSyslogServerEvent glEvent = (GraylogSyslogServerEvent) event;\n            LOG.debug(\"Received syslog message (via AMQP): \" + event.getMessage());\n            LOG.debug(\"AMQP queue: \" + glEvent.getAmqpReceiverQueue());\n\n            gelf.addAdditionalData(\"_amqp_queue\", glEvent.getAmqpReceiverQueue());\n        } else {\n            LOG.debug(\"Received syslog message: \" + event.getMessage());\n        }\n        LOG.debug(\"Host: \" + event.getHost());\n        LOG.debug(\"Facility: \" + event.getFacility() + \" (\" + Tools.syslogFacilityToReadable(event.getFacility()) + \")\");\n        LOG.debug(\"Level: \" + event.getLevel() + \" (\" + Tools.syslogLevelToReadable(event.getLevel()) + \")\");\n        LOG.debug(\"Raw: \" + new String(event.getRaw()));\n\n        // Manually check for provided date because it's necessary to parse the GELF message. Second check for completness later.\n        if (event.getDate() == null) {\n            LOG.info(\"Syslog message is missing date or could not be parsed. Not further handling. Message was: \" + event.getRaw());\n            return;\n        }\n        \n        try {\n            gelf.setCreatedAt(Tools.getUTCTimestampWithMilliseconds(event.getDate().getTime()));\n            gelf.setConvertedFromSyslog(true);\n            gelf.setVersion(\"0\");\n            gelf.setShortMessage(event.getMessage());\n            gelf.setHost(event.getHost());\n            gelf.setFacility(Tools.syslogFacilityToReadable(event.getFacility()));\n            gelf.setLevel(event.getLevel());\n            gelf.setRaw(event.getRaw());\n        } catch (Exception e) {\n            LOG.info(\"Could not parse syslog message to GELF: \" + e.toString(), e);\n            return;\n        }\n        \n        if (gelf.allRequiredFieldsSet()) {\n            try {\n                SimpleGELFClientHandler gelfHandler = new SimpleGELFClientHandler(gelf);\n                gelfHandler.handle();\n            } catch (Exception e) {\n                LOG.debug(\"Couldn't process message with GELF handler\", e);\n            }\n        } else {\n            LOG.info(\"Broken or incomplete syslog message. Not further handling. Message was: \" + event.getRaw());\n        }\n    }","commit_id":"01b32811b11d37d873fa418c1f2dbaa715b6bbbf","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected void sendTextContent(final int iCode, final String iReason, String iHeaders, final String iContentType,\r\n\t\t\tfinal String iContent) throws IOException {\r\n\t\tfinal boolean empty = iContent == null || iContent.length() == 0;\r\n\r\n\t\tsendStatus(empty && iCode == 200 ? 204 : iCode, iReason);\r\n\t\tsendResponseHeaders(iContentType);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iHeaders);\r\n\r\n\t\twriteLine(OHttpUtils.CONTENT_LENGTH + (empty ? 0 : iContent.length()));\r\n\r\n\t\twriteLine(null);\r\n\r\n\t\tif (!empty)\r\n\t\t\twriteLine(iContent);\r\n\r\n\t\tchannel.flush();\r\n\t}","id":86358,"modified_method":"protected void sendTextContent(final int iCode, final String iReason, String iHeaders, final String iContentType,\r\n\t\t\tfinal String iContent) throws IOException {\r\n\t\tfinal boolean empty = iContent == null || iContent.length() == 0;\r\n\r\n\t\tsendStatus(empty && iCode == 200 ? 204 : iCode, iReason);\r\n\t\tsendResponseHeaders(iContentType);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iHeaders);\r\n\r\n\t\twriteLine(OHttpUtils.HEADER_CONTENT_LENGTH + (empty ? 0 : iContent.length()));\r\n\r\n\t\twriteLine(null);\r\n\r\n\t\tif (!empty)\r\n\t\t\twriteLine(iContent);\r\n\r\n\t\tchannel.flush();\r\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void readAllContent(final OHttpRequest iRequest) throws IOException {\r\n\t\tiRequest.content = null;\r\n\r\n\t\tint in;\r\n\t\tchar currChar;\r\n\t\tint contentLength = -1;\r\n\t\tboolean endOfHeaders = false;\r\n\r\n\t\tfinal StringBuilder request = new StringBuilder();\r\n\r\n\t\twhile (!channel.socket.isInputShutdown()) {\r\n\t\t\tin = channel.inStream.read();\r\n\t\t\tif (in == -1)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\tif (currChar == '\\r') {\r\n\t\t\t\tif (request.length() > 0 && !endOfHeaders) {\r\n\t\t\t\t\tString line = request.toString();\r\n\t\t\t\t\tif (line.startsWith(OHttpUtils.AUTHORIZATION)) {\r\n\t\t\t\t\t\t// STORE AUTHORIZATION INFORMATION INTO THE REQUEST\r\n\t\t\t\t\t\tString auth = line.substring(OHttpUtils.AUTHORIZATION.length() + 2);\r\n\t\t\t\t\t\tif (!auth.startsWith(OHttpUtils.AUTHORIZATION_BASIC))\r\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Only HTTP Basic authorization is supported\");\r\n\r\n\t\t\t\t\t\tiRequest.authorization = auth.substring(OHttpUtils.AUTHORIZATION_BASIC.length() + 1);\r\n\r\n\t\t\t\t\t\tiRequest.authorization = new String(OBase64Utils.decode(iRequest.authorization));\r\n\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.COOKIE)) {\r\n\t\t\t\t\t\tString sessionPair = line.substring(OHttpUtils.COOKIE.length() + 1);\r\n\t\t\t\t\t\tString[] sessionPairItems = sessionPair.split(\"=\");\r\n\t\t\t\t\t\tif (sessionPairItems.length == 2 && OHttpUtils.OSESSIONID.equals(sessionPairItems[0]))\r\n\t\t\t\t\t\t\tiRequest.sessionId = sessionPairItems[1];\r\n\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.CONTENT_LENGTH)) {\r\n\t\t\t\t\t\tcontentLength = Integer.parseInt(line.substring(OHttpUtils.CONTENT_LENGTH.length()));\r\n\t\t\t\t\t\tif (contentLength > requestMaxContentLength)\r\n\t\t\t\t\t\t\tOLogManager.instance().warn(\r\n\t\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\t\t\"->\" + channel.socket.getInetAddress().getHostAddress() + \": Error on content size \" + contentLength\r\n\t\t\t\t\t\t\t\t\t\t\t+ \": the maximum allowed is \" + requestMaxContentLength);\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.CONTENT_TYPE)) {\r\n\t\t\t\t\t\tString contentType = line.substring(OHttpUtils.CONTENT_TYPE.length());\r\n\t\t\t\t\t\tif (contentType.startsWith(OHttpUtils.CONTENT_TYPE_MULTIPART)) {\r\n\t\t\t\t\t\t\tiRequest.isMultipart = true;\r\n\t\t\t\t\t\t\tiRequest.boundary = new String(line.substring(OHttpUtils.CONTENT_TYPE.length()\r\n\t\t\t\t\t\t\t\t\t+ OHttpUtils.CONTENT_TYPE_MULTIPART.length() + 2 + OHttpUtils.BOUNDARY.length() + 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.X_FORWARDED_FOR)) {\r\n\t\t\t\t\t\tgetData().caller = line.substring(OHttpUtils.X_FORWARDED_FOR.length());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// CONSUME /r or /n\r\n\t\t\t\tin = channel.inStream.read();\r\n\t\t\t\tif (in == -1)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\t\tif (!endOfHeaders && request.length() == 0) {\r\n\t\t\t\t\tif (contentLength <= 0)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// FIRST BLANK LINE: END OF HEADERS\r\n\t\t\t\t\tendOfHeaders = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\trequest.setLength(0);\r\n\t\t\t} else if (endOfHeaders && request.length() == 0 && currChar != '\\r' && currChar != '\\n') {\r\n\t\t\t\t// END OF HEADERS\r\n\t\t\t\tif (iRequest.isMultipart) {\r\n\t\t\t\t\tiRequest.content = \"\";\r\n\t\t\t\t\tiRequest.multipartStream = new OHttpMultipartBaseInputStream(channel.inStream, currChar, contentLength);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbyte[] buffer = new byte[contentLength];\r\n\t\t\t\t\tbuffer[0] = (byte) currChar;\r\n\r\n\t\t\t\t\tchannel.read(buffer, 1, contentLength - 1);\r\n\r\n\t\t\t\t\tiRequest.content = new String(buffer);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\trequest.append(currChar);\r\n\t\t}\r\n\r\n\t\tif (OLogManager.instance().isDebugEnabled())\r\n\t\t\tOLogManager.instance().debug(this,\r\n\t\t\t\t\t\"Error on parsing HTTP content from client \" + channel.socket.getInetAddress().getHostAddress() + \":\\n\" + request);\r\n\r\n\t\treturn;\r\n\t}","id":86359,"modified_method":"protected void readAllContent(final OHttpRequest iRequest) throws IOException {\r\n\t\tiRequest.content = null;\r\n\r\n\t\tint in;\r\n\t\tchar currChar;\r\n\t\tint contentLength = -1;\r\n\t\tboolean endOfHeaders = false;\r\n\r\n\t\tfinal StringBuilder request = new StringBuilder();\r\n\r\n\t\twhile (!channel.socket.isInputShutdown()) {\r\n\t\t\tin = channel.inStream.read();\r\n\t\t\tif (in == -1)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\tif (currChar == '\\r') {\r\n\t\t\t\tif (request.length() > 0 && !endOfHeaders) {\r\n\t\t\t\t\tfinal String line = request.toString();\r\n\t\t\t\t\tif (line.startsWith(OHttpUtils.HEADER_AUTHORIZATION)) {\r\n\t\t\t\t\t\t// STORE AUTHORIZATION INFORMATION INTO THE REQUEST\r\n\t\t\t\t\t\tfinal String auth = line.substring(OHttpUtils.HEADER_AUTHORIZATION.length());\r\n\t\t\t\t\t\tif (!auth.startsWith(OHttpUtils.AUTHORIZATION_BASIC))\r\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"Only HTTP Basic authorization is supported\");\r\n\r\n\t\t\t\t\t\tiRequest.authorization = auth.substring(OHttpUtils.AUTHORIZATION_BASIC.length() + 1);\r\n\r\n\t\t\t\t\t\tiRequest.authorization = new String(OBase64Utils.decode(iRequest.authorization));\r\n\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.HEADER_COOKIE)) {\r\n\t\t\t\t\t\tString sessionPair = line.substring(OHttpUtils.HEADER_COOKIE.length());\r\n\t\t\t\t\t\tString[] sessionPairItems = sessionPair.split(\"=\");\r\n\t\t\t\t\t\tif (sessionPairItems.length == 2 && OHttpUtils.OSESSIONID.equals(sessionPairItems[0]))\r\n\t\t\t\t\t\t\tiRequest.sessionId = sessionPairItems[1];\r\n\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.HEADER_CONTENT_LENGTH)) {\r\n\t\t\t\t\t\tcontentLength = Integer.parseInt(line.substring(OHttpUtils.HEADER_CONTENT_LENGTH.length()));\r\n\t\t\t\t\t\tif (contentLength > requestMaxContentLength)\r\n\t\t\t\t\t\t\tOLogManager.instance().warn(\r\n\t\t\t\t\t\t\t\t\tthis,\r\n\t\t\t\t\t\t\t\t\t\"->\" + channel.socket.getInetAddress().getHostAddress() + \": Error on content size \" + contentLength\r\n\t\t\t\t\t\t\t\t\t\t\t+ \": the maximum allowed is \" + requestMaxContentLength);\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.HEADER_CONTENT_TYPE)) {\r\n\t\t\t\t\t\tfinal String contentType = line.substring(OHttpUtils.HEADER_CONTENT_TYPE.length());\r\n\t\t\t\t\t\tif (contentType.startsWith(OHttpUtils.CONTENT_TYPE_MULTIPART)) {\r\n\t\t\t\t\t\t\tiRequest.isMultipart = true;\r\n\t\t\t\t\t\t\tiRequest.boundary = new String(line.substring(OHttpUtils.HEADER_CONTENT_TYPE.length()\r\n\t\t\t\t\t\t\t\t\t+ OHttpUtils.CONTENT_TYPE_MULTIPART.length() + 2 + OHttpUtils.BOUNDARY.length() + 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (line.startsWith(OHttpUtils.HEADER_IF_MATCH))\r\n\t\t\t\t\t\tiRequest.ifMatch = line.substring(OHttpUtils.HEADER_IF_MATCH.length());\r\n\t\t\t\t\t\r\n\t\t\t\t\telse if (line.startsWith(OHttpUtils.HEADER_X_FORWARDED_FOR))\r\n\t\t\t\t\t\tgetData().caller = line.substring(OHttpUtils.HEADER_X_FORWARDED_FOR.length());\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// CONSUME /r or /n\r\n\t\t\t\tin = channel.inStream.read();\r\n\t\t\t\tif (in == -1)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcurrChar = (char) in;\r\n\r\n\t\t\t\tif (!endOfHeaders && request.length() == 0) {\r\n\t\t\t\t\tif (contentLength <= 0)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t// FIRST BLANK LINE: END OF HEADERS\r\n\t\t\t\t\tendOfHeaders = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\trequest.setLength(0);\r\n\t\t\t} else if (endOfHeaders && request.length() == 0 && currChar != '\\r' && currChar != '\\n') {\r\n\t\t\t\t// END OF HEADERS\r\n\t\t\t\tif (iRequest.isMultipart) {\r\n\t\t\t\t\tiRequest.content = \"\";\r\n\t\t\t\t\tiRequest.multipartStream = new OHttpMultipartBaseInputStream(channel.inStream, currChar, contentLength);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbyte[] buffer = new byte[contentLength];\r\n\t\t\t\t\tbuffer[0] = (byte) currChar;\r\n\r\n\t\t\t\t\tchannel.read(buffer, 1, contentLength - 1);\r\n\r\n\t\t\t\t\tiRequest.content = new String(buffer);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t} else\r\n\t\t\t\trequest.append(currChar);\r\n\t\t}\r\n\r\n\t\tif (OLogManager.instance().isDebugEnabled())\r\n\t\t\tOLogManager.instance().debug(this,\r\n\t\t\t\t\t\"Error on parsing HTTP content from client \" + channel.socket.getInetAddress().getHostAddress() + \":\\n\" + request);\r\n\r\n\t\treturn;\r\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void sendTextContent(final OHttpRequest iRequest, final int iCode, final String iReason, final String iHeaders,\r\n\t\t\tfinal String iContentType, final Object iContent, final boolean iKeepAlive) throws IOException {\r\n\t\tfinal String content = iContent != null ? iContent.toString() : null;\r\n\r\n\t\tfinal boolean empty = content == null || content.length() == 0;\r\n\r\n\t\tsendStatus(iRequest, empty && iCode == 200 ? 204 : iCode, iReason);\r\n\t\tsendResponseHeaders(iRequest, iContentType, iKeepAlive);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iRequest, iHeaders);\r\n\r\n\t\tfinal String sessId = iRequest.sessionId != null ? iRequest.sessionId : \"-\";\r\n\r\n\t\twriteLine(iRequest, \"Set-Cookie: OSESSIONID=\" + sessId + \"; Path=/; HttpOnly\");\r\n\r\n\t\twriteLine(iRequest, OHttpUtils.CONTENT_LENGTH + (empty ? 0 : content.length()));\r\n\r\n\t\twriteLine(iRequest, null);\r\n\r\n\t\tif (!empty)\r\n\t\t\twriteContent(iRequest, content);\r\n\r\n\t\tiRequest.channel.flush();\r\n\t}","id":86360,"modified_method":"protected void sendTextContent(final OHttpRequest iRequest, final int iCode, final String iReason, final String iHeaders,\r\n\t\t\tfinal String iContentType, final Object iContent, final boolean iKeepAlive) throws IOException {\r\n\t\tfinal String content = iContent != null ? iContent.toString() : null;\r\n\r\n\t\tfinal boolean empty = content == null || content.length() == 0;\r\n\r\n\t\tsendStatus(iRequest, empty && iCode == 200 ? 204 : iCode, iReason);\r\n\t\tsendResponseHeaders(iRequest, iContentType, iKeepAlive);\r\n\t\tif (iHeaders != null)\r\n\t\t\twriteLine(iRequest, iHeaders);\r\n\r\n\t\tfinal String sessId = iRequest.sessionId != null ? iRequest.sessionId : \"-\";\r\n\r\n\t\twriteLine(iRequest, \"Set-Cookie: OSESSIONID=\" + sessId + \"; Path=/; HttpOnly\");\r\n\r\n\t\twriteLine(iRequest, OHttpUtils.HEADER_CONTENT_LENGTH + (empty ? 0 : content.length()));\r\n\r\n\t\twriteLine(iRequest, null);\r\n\r\n\t\tif (!empty)\r\n\t\t\twriteContent(iRequest, content);\r\n\r\n\t\tiRequest.channel.flush();\r\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void sendBinaryContent(final OHttpRequest iRequest, final int iCode, final String iReason, final String iContentType,\r\n\t\t\tfinal InputStream iContent, final long iSize) throws IOException {\r\n\t\tsendStatus(iRequest, iCode, iReason);\r\n\t\tsendResponseHeaders(iRequest, iContentType);\r\n\t\twriteLine(iRequest, OHttpUtils.CONTENT_LENGTH + (iSize));\r\n\t\twriteLine(iRequest, null);\r\n\r\n\t\twhile (iContent != null && iContent.available() > 0)\r\n\t\t\tiRequest.channel.outStream.write((byte) iContent.read());\r\n\r\n\t\tiRequest.channel.flush();\r\n\t}","id":86361,"modified_method":"protected void sendBinaryContent(final OHttpRequest iRequest, final int iCode, final String iReason, final String iContentType,\r\n\t\t\tfinal InputStream iContent, final long iSize) throws IOException {\r\n\t\tsendStatus(iRequest, iCode, iReason);\r\n\t\tsendResponseHeaders(iRequest, iContentType);\r\n\t\twriteLine(iRequest, OHttpUtils.HEADER_CONTENT_LENGTH + (iSize));\r\n\t\twriteLine(iRequest, null);\r\n\r\n\t\twhile (iContent != null && iContent.available() > 0)\r\n\t\t\tiRequest.channel.outStream.write((byte) iContent.read());\r\n\r\n\t\tiRequest.channel.flush();\r\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void sendRecordsContent(final OHttpRequest iRequest, final List<ORecord<?>> iRecords, String iFetchPlan)\r\n\t\t\tthrows IOException {\r\n\t\tfinal StringWriter buffer = new StringWriter();\r\n\t\tfinal OJSONWriter json = new OJSONWriter(buffer, JSON_FORMAT);\r\n\t\tjson.beginObject();\r\n\r\n\t\t// WRITE ENTITY SCHEMA IF ANY\r\n\t\tif (iRecords != null && iRecords.size() > 0) {\r\n\t\t\tORecord<?> first = iRecords.get(0);\r\n\t\t\tif (first != null && first instanceof ODocument) {\r\n\t\t\t\tODatabaseRecord db = ((ODocument) first).getDatabase();\r\n\r\n\t\t\t\tString className = ((ODocument) first).getClassName();\r\n\t\t\t\texportClassSchema(db, json, db.getMetadata().getSchema().getClass(className));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfinal String format = iFetchPlan != null ? JSON_FORMAT + \",fetchPlan:\" + iFetchPlan : JSON_FORMAT;\r\n\r\n\t\t// WRITE RECORDS\r\n\t\tjson.beginCollection(1, true, \"result\");\r\n\t\tif (iRecords != null) {\r\n\t\t\tint counter = 0;\r\n\t\t\tString objectJson;\r\n\t\t\tfor (ORecord<?> rec : iRecords) {\r\n\t\t\t\tif (rec != null)\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tobjectJson = rec.toJSON(format);\r\n\r\n\t\t\t\t\t\tif (counter++ > 0)\r\n\t\t\t\t\t\t\tbuffer.append(\", \");\r\n\r\n\t\t\t\t\t\tbuffer.append(objectJson);\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\tOLogManager.instance().error(this, \"Error transforming record \" + rec.getIdentity() + \" to JSON\", e);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tjson.endCollection(1, true);\r\n\r\n\t\tjson.endObject();\r\n\r\n\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_JSON, buffer.toString());\r\n\t}","id":86362,"modified_method":"protected void sendRecordsContent(final OHttpRequest iRequest, final List<ORecord<?>> iRecords, final String iFetchPlan)\r\n\t\t\tthrows IOException {\r\n\t\tfinal StringWriter buffer = new StringWriter();\r\n\t\tfinal OJSONWriter json = new OJSONWriter(buffer, JSON_FORMAT);\r\n\t\tjson.beginObject();\r\n\r\n\t\t// WRITE ENTITY SCHEMA IF ANY\r\n\t\tif (iRecords != null && iRecords.size() > 0) {\r\n\t\t\tORecord<?> first = iRecords.get(0);\r\n\t\t\tif (first != null && first instanceof ODocument) {\r\n\t\t\t\tODatabaseRecord db = ((ODocument) first).getDatabase();\r\n\r\n\t\t\t\tfinal String className = ((ODocument) first).getClassName();\r\n\t\t\t\texportClassSchema(db, json, db.getMetadata().getSchema().getClass(className));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfinal String format = iFetchPlan != null ? JSON_FORMAT + \",fetchPlan:\" + iFetchPlan : JSON_FORMAT;\r\n\r\n\t\t// WRITE RECORDS\r\n\t\tjson.beginCollection(1, true, \"result\");\r\n\t\tif (iRecords != null) {\r\n\t\t\tint counter = 0;\r\n\t\t\tString objectJson;\r\n\t\t\tfor (ORecord<?> rec : iRecords) {\r\n\t\t\t\tif (rec != null)\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tobjectJson = rec.toJSON(format);\r\n\r\n\t\t\t\t\t\tif (counter++ > 0)\r\n\t\t\t\t\t\t\tbuffer.append(\", \");\r\n\r\n\t\t\t\t\t\tbuffer.append(objectJson);\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\tOLogManager.instance().error(this, \"Error transforming record \" + rec.getIdentity() + \" to JSON\", e);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tjson.endCollection(1, true);\r\n\r\n\t\tjson.endObject();\r\n\r\n\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_JSON, buffer.toString());\r\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tpublic boolean execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\ttry {\r\n\t\t\tfinal String[] urlParts = checkSyntax(iRequest.url, 3, \"Syntax error: document/<database>/<record-id>\");\r\n\r\n\t\t\tiRequest.data.commandInfo = \"Delete document\";\r\n\r\n\t\t\tdb = getProfiledDatabaseInstance(iRequest);\r\n\r\n\t\t\t// PARSE PARAMETERS\r\n\t\t\tfinal int parametersPos = urlParts[2].indexOf('?');\r\n\t\t\tfinal String rid = parametersPos > -1 ? urlParts[2].substring(0, parametersPos) : urlParts[2];\r\n\t\t\tfinal ORecordId recordId = new ORecordId(rid);\r\n\r\n\t\t\tif (!recordId.isValid())\r\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid Record ID in request: \" + urlParts[2]);\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, recordId);\r\n\t\t\tdoc.setVersion(-1);\r\n\t\t\tdoc.delete();\r\n\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, null);\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.release(db);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","id":86363,"modified_method":"@Override\r\n\tpublic boolean execute(final OHttpRequest iRequest) throws Exception {\r\n\t\tODatabaseDocumentTx db = null;\r\n\r\n\t\ttry {\r\n\t\t\tfinal String[] urlParts = checkSyntax(iRequest.url, 3, \"Syntax error: document/<database>/<record-id>\");\r\n\r\n\t\t\tiRequest.data.commandInfo = \"Delete document\";\r\n\r\n\t\t\tdb = getProfiledDatabaseInstance(iRequest);\r\n\r\n\t\t\t// PARSE PARAMETERS\r\n\t\t\tfinal int parametersPos = urlParts[2].indexOf('?');\r\n\t\t\tfinal String rid = parametersPos > -1 ? urlParts[2].substring(0, parametersPos) : urlParts[2];\r\n\t\t\tfinal ORecordId recordId = new ORecordId(rid);\r\n\r\n\t\t\tif (!recordId.isValid())\r\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid Record ID in request: \" + urlParts[2]);\r\n\r\n\t\t\tfinal ODocument doc = new ODocument(db, recordId);\r\n\r\n\t\t\t// UNMARSHALL DOCUMENT WITH REQUEST CONTENT\r\n\t\t\tif (iRequest.content != null)\r\n\t\t\t\t// GET THE VERSION FROM THE DOCUMENT\r\n\t\t\t\tdoc.fromJSON(iRequest.content);\r\n\t\t\telse {\r\n\t\t\t\tif (iRequest.ifMatch != null)\r\n\t\t\t\t\t// USE THE IF-MATCH HTTP HEADER AS VERSION\r\n\t\t\t\t\tdoc.setVersion(Integer.parseInt(iRequest.ifMatch));\r\n\t\t\t\telse\r\n\t\t\t\t\t// IGNORE THE VERSION\r\n\t\t\t\t\tdoc.setVersion(-1);\r\n\t\t\t}\r\n\t\t\tdoc.delete();\r\n\r\n\t\t\tsendTextContent(iRequest, OHttpUtils.STATUS_OK_CODE, \"OK\", null, OHttpUtils.CONTENT_TEXT_PLAIN, null);\r\n\r\n\t\t} finally {\r\n\t\t\tif (db != null)\r\n\t\t\t\tOSharedDocumentDatabase.release(db);\r\n\t\t}\r\n\t\treturn false;\r\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void sendBinaryFileContent(final OHttpRequest iRequest, final int iCode, final String iReason,\n\t\t\tfinal String iContentType, final ORecordBytes record, final String iFileName) throws IOException {\n\t\tsendStatus(iRequest, iCode, iReason);\n\t\tsendResponseHeaders(iRequest, iContentType);\n\t\twriteLine(iRequest, \"Content-Disposition: attachment; filename=\" + iFileName);\n\t\twriteLine(iRequest, \"Date: \" + new Date());\n\t\twriteLine(iRequest, OHttpUtils.CONTENT_LENGTH + (record.getSize()));\n\t\twriteLine(iRequest, null);\n\n\t\trecord.toOutputStream(iRequest.channel.outStream);\n\n\t\tiRequest.channel.flush();\n\t}","id":86364,"modified_method":"protected void sendBinaryFileContent(final OHttpRequest iRequest, final int iCode, final String iReason,\n\t\t\tfinal String iContentType, final ORecordBytes record, final String iFileName) throws IOException {\n\t\tsendStatus(iRequest, iCode, iReason);\n\t\tsendResponseHeaders(iRequest, iContentType);\n\t\twriteLine(iRequest, \"Content-Disposition: attachment; filename=\" + iFileName);\n\t\twriteLine(iRequest, \"Date: \" + new Date());\n\t\twriteLine(iRequest, OHttpUtils.HEADER_CONTENT_LENGTH + (record.getSize()));\n\t\twriteLine(iRequest, null);\n\n\t\trecord.toOutputStream(iRequest.channel.outStream);\n\n\t\tiRequest.channel.flush();\n\t}","commit_id":"fe7703681312fe4b28d9f725311e2f00d1f2a155","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Migrate TLD metadata to Catalina. This is separate, and is not subject to\n     * the order defined.\n     */\n    @Override\n    protected void applicationTldConfig() {\n        final TldsMetaData tldsMetaData = deploymentUnitContext.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        if (tldsMetaData == null) {\n            return;\n        }\n        Map<String, TldMetaData> localTlds = tldsMetaData.getTlds();\n        List<TldMetaData> sharedTlds = tldsMetaData.getSharedTlds();\n        ArrayList<TagLibraryInfo> tagLibraries = new ArrayList<TagLibraryInfo>();\n\n        for (String location : localTlds.keySet()) {\n            processTld(tagLibraries, location, localTlds.get(location));\n        }\n        for (TldMetaData sharedTld : sharedTlds) {\n            processTld(tagLibraries, null, sharedTld);\n        }\n\n        // Add additional TLDs URIs from explicit web config\n        String[] taglibs = context.findTaglibs();\n        for (int i = 0; i < taglibs.length; i++) {\n            String uri = taglibs[i];\n            String path = context.findTaglib(taglibs[i]);\n            String location = \"\";\n            if (path.indexOf(':') == -1 && !path.startsWith(\"/\")) {\n                path = \"/WEB-INF/\" + path;\n            }\n            if (path.endsWith(\".jar\")) {\n                location = path;\n                path = \"META-INF/taglib.tld\";\n            }\n            for (int j = 0; j < tagLibraries.size(); j++) {\n                TagLibraryInfo tagLibraryInfo = tagLibraries.get(j);\n                if (tagLibraryInfo.getLocation().equals(location) && tagLibraryInfo.getPath().equals(path)) {\n                    context.addJspTagLibrary(uri, tagLibraryInfo);\n                }\n            }\n        }\n\n    }","id":86365,"modified_method":"/**\n     * Migrate TLD metadata to Catalina. This is separate, and is not subject to\n     * the order defined.\n     */\n    @Override\n    protected void applicationTldConfig() {\n        final TldsMetaData tldsMetaData = deploymentUnitContext.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        if (tldsMetaData == null) {\n            return;\n        }\n        Map<String, TldMetaData> localTlds = tldsMetaData.getTlds();\n        List<TldMetaData> sharedTlds = tldsMetaData.getSharedTlds(deploymentUnitContext);\n        ArrayList<TagLibraryInfo> tagLibraries = new ArrayList<TagLibraryInfo>();\n\n        for (String location : localTlds.keySet()) {\n            processTld(tagLibraries, location, localTlds.get(location));\n        }\n        for (TldMetaData sharedTld : sharedTlds) {\n            processTld(tagLibraries, null, sharedTld);\n        }\n\n        // Add additional TLDs URIs from explicit web config\n        String[] taglibs = context.findTaglibs();\n        for (int i = 0; i < taglibs.length; i++) {\n            String uri = taglibs[i];\n            String path = context.findTaglib(taglibs[i]);\n            String location = \"\";\n            if (path.indexOf(':') == -1 && !path.startsWith(\"/\")) {\n                path = \"/WEB-INF/\" + path;\n            }\n            if (path.endsWith(\".jar\")) {\n                location = path;\n                path = \"META-INF/taglib.tld\";\n            }\n            for (int j = 0; j < tagLibraries.size(); j++) {\n                TagLibraryInfo tagLibraryInfo = tagLibraries.get(j);\n                if (tagLibraryInfo.getLocation().equals(location) && tagLibraryInfo.getPath().equals(path)) {\n                    context.addJspTagLibrary(uri, tagLibraryInfo);\n                }\n            }\n        }\n\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit topLevelDeployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();\n        final WarMetaData metaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);\n\n        if (metaData == null) {\n            return;\n        }\n\n        if (metaData.getMergedJBossWebMetaData() == null) {\n            return;\n        }\n\n        List<ParamValueMetaData> contextParams = metaData.getMergedJBossWebMetaData().getContextParams();\n        if(contextParams == null) {\n            return;\n        }\n\n        //we need to set the JSF version for the whole deployment\n        //as otherwise linkage errors can occur\n        //if the user does have an ear with two wars with two different\n        //JSF versions they are going to need to use deployment descriptors\n        //to manually sort out the dependencies\n        for(final ParamValueMetaData param : contextParams) {\n            if(param.getParamName().equals(CONTEXT_PARAM)) {\n                JsfVersionMarker.setVersion(topLevelDeployment, param.getParamValue());\n                break;\n            }\n        }\n    }","id":86366,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit topLevelDeployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();\n        final WarMetaData metaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);\n\n        if (metaData == null) {\n            return;\n        }\n\n        List<ParamValueMetaData> contextParams = new ArrayList<ParamValueMetaData>();\n\n        if ((metaData.getWebMetaData() != null) && (metaData.getWebMetaData().getContextParams() != null)) {\n            contextParams.addAll(metaData.getWebMetaData().getContextParams());\n        }\n\n        if (metaData.getWebFragmentsMetaData() != null) {\n            for (WebFragmentMetaData fragmentMetaData : metaData.getWebFragmentsMetaData().values()) {\n                contextParams.addAll(fragmentMetaData.getContextParams());\n            }\n        }\n\n        //we need to set the JSF version for the whole deployment\n        //as otherwise linkage errors can occur\n        //if the user does have an ear with two wars with two different\n        //JSF versions they are going to need to use deployment descriptors\n        //to manually sort out the dependencies\n        for(final ParamValueMetaData param : contextParams) {\n            if ((param.getParamName().equals(WAR_BUNDLES_JSF_IMPL_PARAM) &&\n                (param.getParamValue() != null) &&\n                (param.getParamValue().toLowerCase().equals(\"true\")))) {\n                JsfVersionMarker.setVersion(topLevelDeployment, JsfVersionMarker.WAR_BUNDLES_JSF_IMPL);\n                break; // WAR_BUNDLES_JSF_IMPL always wins\n            }\n\n            if(param.getParamName().equals(JSF_CONFIG_NAME_PARAM)) {\n                JsfVersionMarker.setVersion(topLevelDeployment, param.getParamValue());\n            }\n        }\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void init() {\n        try {\n            ModuleClassLoader jsf = Module.getModuleFromCallerModuleLoader(ModuleIdentifier.create(\"com.sun.jsf-impl\")).getClassLoader();\n            for (String tld : JSF_TAGLIBS) {\n                InputStream is = jsf.getResourceAsStream(\"META-INF/\" + tld);\n                if (is != null) {\n                    TldMetaData tldMetaData = parseTLD(tld, is);\n                    tlds.add(tldMetaData);\n                }\n            }\n        } catch (ModuleLoadException e) {\n            // Ignore\n        } catch (Exception e) {\n            // Ignore\n        }\n        try {\n            ModuleClassLoader jstl = Module.getModuleFromCallerModuleLoader(ModuleIdentifier.create(\"javax.servlet.jstl.api\")).getClassLoader();\n            for (String tld : JSTL_TAGLIBS) {\n                InputStream is = jstl.getResourceAsStream(\"META-INF/\" + tld);\n                if (is != null) {\n                    TldMetaData tldMetaData = parseTLD(tld, is);\n                    tlds.add(tldMetaData);\n                }\n            }\n        } catch (ModuleLoadException e) {\n            // Ignore\n        } catch (Exception e) {\n            // Ignore\n        }\n    }","id":86367,"modified_method":"private void init() {\n        try {\n            ModuleClassLoader jsf = Module.getModuleFromCallerModuleLoader(ModuleIdentifier.create(\"com.sun.jsf-impl\")).getClassLoader();\n            for (String tld : JSF_TAGLIBS) {\n                InputStream is = jsf.getResourceAsStream(\"META-INF/\" + tld);\n                if (is != null) {\n                    TldMetaData tldMetaData = parseTLD(tld, is);\n                    jsfTlds.add(tldMetaData);\n                }\n            }\n        } catch (ModuleLoadException e) {\n            // Ignore\n        } catch (Exception e) {\n            // Ignore\n        }\n        try {\n            ModuleClassLoader jstl = Module.getModuleFromCallerModuleLoader(ModuleIdentifier.create(\"javax.servlet.jstl.api\")).getClassLoader();\n            for (String tld : JSTL_TAGLIBS) {\n                InputStream is = jstl.getResourceAsStream(\"META-INF/\" + tld);\n                if (is != null) {\n                    TldMetaData tldMetaData = parseTLD(tld, is);\n                    jstlTlds.add(tldMetaData);\n                }\n            }\n        } catch (ModuleLoadException e) {\n            // Ignore\n        } catch (Exception e) {\n            // Ignore\n        }\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void setSharedTlds(List<TldMetaData> sharedTlds) {\n        this.sharedTlds = sharedTlds;\n    }","id":86368,"modified_method":"public void setSharedTlds(SharedTldsMetaDataBuilder sharedTlds) {\n        this.sharedTlds = sharedTlds;\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"public List<TldMetaData> getSharedTlds() {\n        return sharedTlds;\n    }","id":86369,"modified_method":"public List<TldMetaData> getSharedTlds(DeploymentUnit deploymentUnit) {\n        return sharedTlds.getSharedTlds(deploymentUnit);\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final DeploymentUnit topLevelDeployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        //we always make the JSF api available\n        final String jsfVersion = JsfVersionMarker.getVersion(topLevelDeployment);\n\n        if(jsfVersion.equals(JsfVersionMarker.JSF_1_2)) {\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSF_1_2_API, false, false, false));\n        } else {\n            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSF_API, false, false, false));\n        }\n\n        // Add module dependencies on Java EE apis\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAX_EE_API, false, false, false));\n\n        // Add modules for JSF\n\n        if(jsfVersion.equals(JsfVersionMarker.JSF_1_2)) {\n            ModuleDependency jsf = new ModuleDependency(moduleLoader, JSF_1_2_IMPL, false, false, true);\n            jsf.addImportFilter(PathFilters.getMetaInfFilter(), true);\n            moduleSpecification.addSystemDependency(jsf);\n        } else {\n            if(!jsfVersion.equals(JsfVersionMarker.JSF_2_0)) {\n                logger.warn(\"Ukown JSF version \" + jsfVersion + \" \" + JsfVersionMarker.JSF_2_0 + \" will be used instead\");\n            }\n            ModuleDependency jsf = new ModuleDependency(moduleLoader, JSF_IMPL, false, false, true);\n            jsf.addImportFilter(PathFilters.getMetaInfFilter(), true);\n            moduleSpecification.addSystemDependency(jsf);\n        }\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, BEAN_VALIDATION, false, false, true));\n\n        // FIXME we need to revise the exports of the web module, so that we\n        // don't export our internals\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JBOSS_WEB, false, false, true));\n\n    }","id":86370,"modified_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final DeploymentUnit topLevelDeployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        final ModuleLoader moduleLoader = Module.getBootModuleLoader();\n\n        final String jsfVersion = JsfVersionMarker.getVersion(topLevelDeployment);\n\n        addJSFAPI(jsfVersion, moduleSpecification, moduleLoader);\n\n        // Add module dependencies on Java EE apis\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAVAX_EE_API, false, false, false));\n\n        addJSFImpl(jsfVersion, moduleSpecification, moduleLoader);\n\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JSTL, false, false, false));\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, BEAN_VALIDATION, false, false, true));\n\n        // FIXME we need to revise the exports of the web module, so that we\n        // don't export our internals\n        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JBOSS_WEB, false, false, true));\n\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"public WarStructureDeploymentProcessor(final WebMetaData sharedWebMetaData, final List<TldMetaData> sharedTldsMetaData) {\n        this.sharedWebMetaData = sharedWebMetaData;\n        this.sharedTldsMetaData = sharedTldsMetaData;\n    }","id":86371,"modified_method":"public WarStructureDeploymentProcessor(final WebMetaData sharedWebMetaData, final SharedTldsMetaDataBuilder sharedTldsMetaData) {\n        this.sharedWebMetaData = sharedWebMetaData;\n        this.sharedTldsMetaData = sharedTldsMetaData;\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return;\n        }\n\n        final Map<String, ComponentDescription> componentByClass = new HashMap<String, ComponentDescription>();\n        final Map<String, ComponentInstantiator> webComponents = new HashMap<String, ComponentInstantiator>();\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationClasses applicationClassesDescription = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final CompositeIndex compositeIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPOSITE_ANNOTATION_INDEX);\n        final String applicationName = deploymentUnit.getParent() == null ? deploymentUnit.getName() : deploymentUnit.getParent().getName();\n        if (moduleDescription == null) {\n            return; //not an ee deployment\n        }\n        for (ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            componentByClass.put(component.getComponentClassName(), component);\n        }\n\n        final WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        final TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        final Set<String> classes = getAllComponentClasses(warMetaData, tldsMetaData);\n        for (String clazz : classes) {\n            if (clazz == null || clazz.trim().isEmpty()) {\n                continue;\n            }\n            ComponentDescription description = componentByClass.get(clazz);\n            if (description != null) {\n                //for now just make sure it has a single view\n                //this will generally be a managed bean, but it could also be an EJB\n                //TODO: make sure the component is a managed bean\n                if (!(description.getViews().size() == 1)) {\n                    throw new RuntimeException(clazz + \" has the wrong component type, is cannot be used as a web component\");\n                }\n                ManagedBeanComponentInstantiator instantiator = new ManagedBeanComponentInstantiator(deploymentUnit, description);\n                webComponents.put(clazz, instantiator);\n            } else {\n                //we do not make the standard tags into components, as there is no need\n                if (compositeIndex.getClassByName(DotName.createSimple(clazz)) == null) {\n                    boolean found = false;\n                    for (String pack : BUILTIN_TAGLIBS) {\n                        if (clazz.startsWith(pack)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if(found) {\n                        continue;\n                    }\n                }\n                description = new WebComponentDescription(clazz, clazz, moduleDescription, deploymentUnit.getServiceName(), applicationClassesDescription);\n                moduleDescription.addComponent(description);\n                webComponents.put(clazz, new WebComponentInstantiator(deploymentUnit, description));\n            }\n        }\n        deploymentUnit.putAttachment(WebAttachments.WEB_COMPONENT_INSTANTIATORS, webComponents);\n    }","id":86372,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return;\n        }\n\n        final Map<String, ComponentDescription> componentByClass = new HashMap<String, ComponentDescription>();\n        final Map<String, ComponentInstantiator> webComponents = new HashMap<String, ComponentInstantiator>();\n        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationClasses applicationClassesDescription = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final CompositeIndex compositeIndex = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPOSITE_ANNOTATION_INDEX);\n        final String applicationName = deploymentUnit.getParent() == null ? deploymentUnit.getName() : deploymentUnit.getParent().getName();\n        if (moduleDescription == null) {\n            return; //not an ee deployment\n        }\n        for (ComponentDescription component : moduleDescription.getComponentDescriptions()) {\n            componentByClass.put(component.getComponentClassName(), component);\n        }\n\n        final WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        final TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        final Set<String> classes = getAllComponentClasses(deploymentUnit, warMetaData, tldsMetaData);\n        for (String clazz : classes) {\n            if (clazz == null || clazz.trim().isEmpty()) {\n                continue;\n            }\n            ComponentDescription description = componentByClass.get(clazz);\n            if (description != null) {\n                //for now just make sure it has a single view\n                //this will generally be a managed bean, but it could also be an EJB\n                //TODO: make sure the component is a managed bean\n                if (!(description.getViews().size() == 1)) {\n                    throw new RuntimeException(clazz + \" has the wrong component type, is cannot be used as a web component\");\n                }\n                ManagedBeanComponentInstantiator instantiator = new ManagedBeanComponentInstantiator(deploymentUnit, description);\n                webComponents.put(clazz, instantiator);\n            } else {\n                //we do not make the standard tags into components, as there is no need\n                if (compositeIndex.getClassByName(DotName.createSimple(clazz)) == null) {\n                    boolean found = false;\n                    for (String pack : BUILTIN_TAGLIBS) {\n                        if (clazz.startsWith(pack)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if(found) {\n                        continue;\n                    }\n                }\n                description = new WebComponentDescription(clazz, clazz, moduleDescription, deploymentUnit.getServiceName(), applicationClassesDescription);\n                moduleDescription.addComponent(description);\n                webComponents.put(clazz, new WebComponentInstantiator(deploymentUnit, description));\n            }\n        }\n        deploymentUnit.putAttachment(WebAttachments.WEB_COMPONENT_INSTANTIATORS, webComponents);\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Gets all classes that are eligible for injection etc\n     *\n     * @param metaData\n     * @return\n     */\n    private Set<String> getAllComponentClasses(WarMetaData metaData, TldsMetaData tldsMetaData) {\n        final Set<String> classes = new HashSet<String>();\n        if (metaData.getAnnotationsMetaData() != null)\n            for (Map.Entry<String, WebMetaData> webMetaData : metaData.getAnnotationsMetaData().entrySet()) {\n                getAllComponentClasses(webMetaData.getValue(), classes);\n            }\n        if (metaData.getSharedWebMetaData() != null)\n            getAllComponentClasses(metaData.getSharedWebMetaData(), classes);\n        if (metaData.getWebFragmentsMetaData() != null)\n            for (Map.Entry<String, WebFragmentMetaData> webMetaData : metaData.getWebFragmentsMetaData().entrySet()) {\n                getAllComponentClasses(webMetaData.getValue(), classes);\n            }\n        if (metaData.getWebMetaData() != null)\n            getAllComponentClasses(metaData.getWebMetaData(), classes);\n        if (tldsMetaData == null)\n            return classes;\n        if (tldsMetaData.getSharedTlds() != null)\n            for (TldMetaData tldMetaData : tldsMetaData.getSharedTlds()) {\n                getAllComponentClasses(tldMetaData, classes);\n            }\n        if (tldsMetaData.getTlds() != null)\n            for (Map.Entry<String, TldMetaData> tldMetaData : tldsMetaData.getTlds().entrySet()) {\n                getAllComponentClasses(tldMetaData.getValue(), classes);\n            }\n        return classes;\n    }","id":86373,"modified_method":"/**\n     * Gets all classes that are eligible for injection etc\n     *\n     * @param metaData\n     * @return\n     */\n    private Set<String> getAllComponentClasses(DeploymentUnit deploymentUnit, WarMetaData metaData, TldsMetaData tldsMetaData) {\n        final Set<String> classes = new HashSet<String>();\n        if (metaData.getAnnotationsMetaData() != null)\n            for (Map.Entry<String, WebMetaData> webMetaData : metaData.getAnnotationsMetaData().entrySet()) {\n                getAllComponentClasses(webMetaData.getValue(), classes);\n            }\n        if (metaData.getSharedWebMetaData() != null)\n            getAllComponentClasses(metaData.getSharedWebMetaData(), classes);\n        if (metaData.getWebFragmentsMetaData() != null)\n            for (Map.Entry<String, WebFragmentMetaData> webMetaData : metaData.getWebFragmentsMetaData().entrySet()) {\n                getAllComponentClasses(webMetaData.getValue(), classes);\n            }\n        if (metaData.getWebMetaData() != null)\n            getAllComponentClasses(metaData.getWebMetaData(), classes);\n        if (tldsMetaData == null)\n            return classes;\n        if (tldsMetaData.getSharedTlds(deploymentUnit) != null)\n            for (TldMetaData tldMetaData : tldsMetaData.getSharedTlds(deploymentUnit)) {\n                getAllComponentClasses(tldMetaData, classes);\n            }\n        if (tldsMetaData.getTlds() != null)\n            for (Map.Entry<String, TldMetaData> tldMetaData : tldsMetaData.getTlds().entrySet()) {\n                getAllComponentClasses(tldMetaData.getValue(), classes);\n            }\n        return classes;\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model,\n                                   ServiceVerificationHandler verificationHandler,\n                                   List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final ModelNode config = operation.get(Constants.CONTAINER_CONFIG);\n        final String defaultVirtualServer = operation.hasDefined(Constants.DEFAULT_VIRTUAL_SERVER) ?\n                operation.get(Constants.DEFAULT_VIRTUAL_SERVER).asString() : DEFAULT_VIRTUAL_SERVER;\n        final boolean useNative = operation.hasDefined(Constants.NATIVE) ?\n                operation.get(Constants.NATIVE).asBoolean() : DEFAULT_NATIVE;\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                final SharedWebMetaDataBuilder sharedWebBuilder = new SharedWebMetaDataBuilder(config.clone());\n                final SharedTldsMetaDataBuilder sharedTldsBuilder = new SharedTldsMetaDataBuilder(config.clone());\n\n                processorTarget.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT_INIT, new WarDeploymentInitializingProcessor());\n                processorTarget.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR, new WarStructureDeploymentProcessor(sharedWebBuilder.create(), sharedTldsBuilder.create()));\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT, new WebParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT_FRAGMENT, new WebFragmentParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEB_DEPLOYMENT, new JBossWebParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TLD_DEPLOYMENT, new TldParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_ANNOTATION_WAR, new WarAnnotationDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_COMPONENTS, new WebComponentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EAR_CONTEXT_ROOT, new EarContextRootProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_MERGE_METADATA, new WarMetaDataProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JSF_VERSION, new JsfVersionProcessor());\n                processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WAR_MODULE, new WarClassloadingDependencyProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_JSF_MANAGED_BEANS, new JsfManagedBeanProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.POST_MODULE_JSF_MANAGED_BEANS, new JsfManagedBeanProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_SERVLET_INIT_DEPLOYMENT, new ServletContainerInitializerDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JSF_ANNOTATIONS, new JsfAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_DEPLOYMENT, new WarDeploymentProcessor(defaultVirtualServer));\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final WebServerService service = new WebServerService(defaultVirtualServer, useNative);\n        newControllers.add(context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB, service)\n                .addDependency(AbstractPathService.pathNameOf(TEMP_DIR), String.class, service.getPathInjector())\n                .addDependency(DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"mbean\", \"server\"), MBeanServer.class, service.getMbeanServer())\n                .setInitialMode(Mode.ON_DEMAND)\n                .install());\n\n    }","id":86374,"modified_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model,\n                                   ServiceVerificationHandler verificationHandler,\n                                   List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final ModelNode config = operation.get(Constants.CONTAINER_CONFIG);\n        final String defaultVirtualServer = operation.hasDefined(Constants.DEFAULT_VIRTUAL_SERVER) ?\n                operation.get(Constants.DEFAULT_VIRTUAL_SERVER).asString() : DEFAULT_VIRTUAL_SERVER;\n        final boolean useNative = operation.hasDefined(Constants.NATIVE) ?\n                operation.get(Constants.NATIVE).asBoolean() : DEFAULT_NATIVE;\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                final SharedWebMetaDataBuilder sharedWebBuilder = new SharedWebMetaDataBuilder(config.clone());\n                final SharedTldsMetaDataBuilder sharedTldsBuilder = new SharedTldsMetaDataBuilder(config.clone());\n\n                processorTarget.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR_DEPLOYMENT_INIT, new WarDeploymentInitializingProcessor());\n                processorTarget.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_WAR, new WarStructureDeploymentProcessor(sharedWebBuilder.create(), sharedTldsBuilder));\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT, new WebParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_DEPLOYMENT_FRAGMENT, new WebFragmentParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JSF_VERSION, new JsfVersionProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_JBOSS_WEB_DEPLOYMENT, new JBossWebParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_TLD_DEPLOYMENT, new TldParsingDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_ANNOTATION_WAR, new WarAnnotationDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_COMPONENTS, new WebComponentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EAR_CONTEXT_ROOT, new EarContextRootProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_MERGE_METADATA, new WarMetaDataProcessor());\n                processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WAR_MODULE, new WarClassloadingDependencyProcessor());\n                processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_JSF_MANAGED_BEANS, new JsfManagedBeanProcessor());\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.POST_MODULE_JSF_MANAGED_BEANS, new JsfManagedBeanProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_SERVLET_INIT_DEPLOYMENT, new ServletContainerInitializerDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_JSF_ANNOTATIONS, new JsfAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WAR_DEPLOYMENT, new WarDeploymentProcessor(defaultVirtualServer));\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        final WebServerService service = new WebServerService(defaultVirtualServer, useNative);\n        newControllers.add(context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB, service)\n                .addDependency(AbstractPathService.pathNameOf(TEMP_DIR), String.class, service.getPathInjector())\n                .addDependency(DependencyType.OPTIONAL, ServiceName.JBOSS.append(\"mbean\", \"server\"), MBeanServer.class, service.getMbeanServer())\n                .setInitialMode(Mode.ON_DEMAND)\n                .install());\n\n    }","commit_id":"306dd8a2bea822458718f1a901440bd9ed19e2fa","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void autoDeploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tList<String> wars = new ArrayList<String>();\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\twars.add(file.getName());\n\n\t\tthis.wars = wars;\n\n\t\ttry {\n\t\t\tdeployFile(autoDeploymentContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AutoDeployException(e);\n\t\t}\n\t}","id":86375,"modified_method":"public int autoDeploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tList<String> wars = new ArrayList<String>();\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\twars.add(file.getName());\n\n\t\tthis.wars = wars;\n\n\t\ttry {\n\t\t\treturn deployFile(autoDeploymentContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AutoDeployException(e);\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deployFile(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows Exception {\n\n\t\tFile srcFile = autoDeploymentContext.getFile();\n\n\t\tPluginPackage pluginPackage = readPluginPackage(srcFile);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Deploying \" + srcFile.getName());\n\t\t}\n\n\t\tString specifiedContext = autoDeploymentContext.getContext();\n\n\t\tString displayName = specifiedContext;\n\t\tboolean overwrite = false;\n\t\tString preliminaryContext = specifiedContext;\n\n\t\t// The order of priority of the context is: 1.) the specified context,\n\t\t// 2.) if the file name starts with DEPLOY_TO_PREFIX, use the file name\n\t\t// after the prefix, or 3.) the recommended deployment context as\n\t\t// specified in liferay-plugin-package.properties, or 4.) the file name.\n\n\t\tif (Validator.isNull(specifiedContext) &&\n\t\t\tsrcFile.getName().startsWith(DEPLOY_TO_PREFIX)) {\n\n\t\t\tdisplayName = srcFile.getName().substring(\n\t\t\t\tDEPLOY_TO_PREFIX.length(), srcFile.getName().length() - 4);\n\n\t\t\toverwrite = true;\n\t\t\tpreliminaryContext = displayName;\n\t\t}\n\n\t\tif (preliminaryContext == null) {\n\t\t\tpreliminaryContext = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (pluginPackage != null) {\n\t\t\tif (!PluginPackageUtil.isCurrentVersionSupported(\n\t\t\t\t\tpluginPackage.getLiferayVersions())) {\n\n\t\t\t\tthrow new AutoDeployException(\n\t\t\t\t\tsrcFile.getName() +\n\t\t\t\t\t\t\" does not support this version of Liferay\");\n\t\t\t}\n\n\t\t\tif (displayName == null) {\n\t\t\t\tdisplayName = pluginPackage.getRecommendedDeploymentContext();\n\t\t\t}\n\n\t\t\tif (Validator.isNull(displayName)) {\n\t\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t\t}\n\n\t\t\tpluginPackage.setContext(displayName);\n\n\t\t\tPluginPackageUtil.updateInstallingPluginPackage(\n\t\t\t\tpreliminaryContext, pluginPackage);\n\t\t}\n\n\t\tString deployDir = null;\n\n\t\tif (Validator.isNotNull(displayName)) {\n\t\t\tdeployDir = displayName + \".war\";\n\t\t}\n\t\telse {\n\t\t\tdeployDir = srcFile.getName();\n\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JBOSS_ID)) {\n\t\t\tdeployDir = jbossPrefix + deployDir;\n\t\t}\n\t\telse if (appServerType.equals(ServerDetector.GERONIMO_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.GLASSFISH_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.JETTY_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.JONAS_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.OC4J_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.RESIN_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.TOMCAT_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.WEBLOGIC_ID)) {\n\n\t\t\tif (unpackWar) {\n\t\t\t\tdeployDir = deployDir.substring(0, deployDir.length() - 4);\n\t\t\t}\n\t\t}\n\n\t\tString destDir = this.destDir;\n\n\t\tif (autoDeploymentContext.getDestDir() != null) {\n\t\t\tdestDir = autoDeploymentContext.getDestDir();\n\t\t}\n\n\t\tFile deployDirFile = new File(destDir + \"/\" + deployDir);\n\n\t\ttry {\n\t\t\tPluginPackage previousPluginPackage = readPluginPackage(\n\t\t\t\tdeployDirFile);\n\n\t\t\tif ((pluginPackage != null) && (previousPluginPackage != null)) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tString name = pluginPackage.getName();\n\t\t\t\t\tString previousVersion = previousPluginPackage.getVersion();\n\t\t\t\t\tString version = pluginPackage.getVersion();\n\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Updating \" + name + \" from version \" +\n\t\t\t\t\t\t\tpreviousVersion + \" to version \" + version);\n\t\t\t\t}\n\n\t\t\t\tif (pluginPackage.isLaterVersionThan(previousPluginPackage)) {\n\t\t\t\t\toverwrite = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFile mergeDirFile = new File(\n\t\t\t\tsrcFile.getParent() + \"/merge/\" + srcFile.getName());\n\n\t\t\tif (srcFile.isDirectory()) {\n\t\t\t\tdeployDirectory(\n\t\t\t\t\tsrcFile, mergeDirFile, deployDirFile, displayName,\n\t\t\t\t\toverwrite, pluginPackage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean deployed = deployFile(\n\t\t\t\t\tsrcFile, mergeDirFile, deployDirFile, displayName,\n\t\t\t\t\toverwrite, pluginPackage);\n\n\t\t\t\tif (!deployed) {\n\t\t\t\t\tString context = preliminaryContext;\n\n\t\t\t\t\tif (pluginPackage != null) {\n\t\t\t\t\t\tcontext = pluginPackage.getContext();\n\t\t\t\t\t}\n\n\t\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(context);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpostDeploy(destDir, deployDir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (pluginPackage != null) {\n\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(\n\t\t\t\t\tpluginPackage.getContext());\n\t\t\t}\n\n\t\t\tthrow e;\n\t\t}\n\t}","id":86376,"modified_method":"public int deployFile(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows Exception {\n\n\t\tFile srcFile = autoDeploymentContext.getFile();\n\n\t\tPluginPackage pluginPackage = readPluginPackage(srcFile);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Deploying \" + srcFile.getName());\n\t\t}\n\n\t\tString specifiedContext = autoDeploymentContext.getContext();\n\n\t\tString displayName = specifiedContext;\n\t\tboolean overwrite = false;\n\t\tString preliminaryContext = specifiedContext;\n\n\t\t// The order of priority of the context is: 1.) the specified context,\n\t\t// 2.) if the file name starts with DEPLOY_TO_PREFIX, use the file name\n\t\t// after the prefix, or 3.) the recommended deployment context as\n\t\t// specified in liferay-plugin-package.properties, or 4.) the file name.\n\n\t\tif (Validator.isNull(specifiedContext) &&\n\t\t\tsrcFile.getName().startsWith(DEPLOY_TO_PREFIX)) {\n\n\t\t\tdisplayName = srcFile.getName().substring(\n\t\t\t\tDEPLOY_TO_PREFIX.length(), srcFile.getName().length() - 4);\n\n\t\t\toverwrite = true;\n\t\t\tpreliminaryContext = displayName;\n\t\t}\n\n\t\tif (preliminaryContext == null) {\n\t\t\tpreliminaryContext = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (pluginPackage != null) {\n\t\t\tif (!PluginPackageUtil.isCurrentVersionSupported(\n\t\t\t\t\tpluginPackage.getLiferayVersions())) {\n\n\t\t\t\tthrow new AutoDeployException(\n\t\t\t\t\tsrcFile.getName() +\n\t\t\t\t\t\t\" does not support this version of Liferay\");\n\t\t\t}\n\n\t\t\tif (displayName == null) {\n\t\t\t\tdisplayName = pluginPackage.getRecommendedDeploymentContext();\n\t\t\t}\n\n\t\t\tif (Validator.isNull(displayName)) {\n\t\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t\t}\n\n\t\t\tpluginPackage.setContext(displayName);\n\n\t\t\tPluginPackageUtil.updateInstallingPluginPackage(\n\t\t\t\tpreliminaryContext, pluginPackage);\n\t\t}\n\n\t\tString deployDir = null;\n\n\t\tif (Validator.isNotNull(displayName)) {\n\t\t\tdeployDir = displayName + \".war\";\n\t\t}\n\t\telse {\n\t\t\tdeployDir = srcFile.getName();\n\t\t\tdisplayName = getDisplayName(srcFile);\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JBOSS_ID)) {\n\t\t\tdeployDir = jbossPrefix + deployDir;\n\t\t}\n\t\telse if (appServerType.equals(ServerDetector.GERONIMO_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.GLASSFISH_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.JETTY_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.JONAS_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.OC4J_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.RESIN_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.TOMCAT_ID) ||\n\t\t\t\t appServerType.equals(ServerDetector.WEBLOGIC_ID)) {\n\n\t\t\tif (unpackWar) {\n\t\t\t\tdeployDir = deployDir.substring(0, deployDir.length() - 4);\n\t\t\t}\n\t\t}\n\n\t\tString destDir = this.destDir;\n\n\t\tif (autoDeploymentContext.getDestDir() != null) {\n\t\t\tdestDir = autoDeploymentContext.getDestDir();\n\t\t}\n\n\t\tFile deployDirFile = new File(destDir + \"/\" + deployDir);\n\n\t\ttry {\n\t\t\tPluginPackage previousPluginPackage = readPluginPackage(\n\t\t\t\tdeployDirFile);\n\n\t\t\tif ((pluginPackage != null) && (previousPluginPackage != null)) {\n\t\t\t\tString name = pluginPackage.getName();\n\t\t\t\tString previousVersion = previousPluginPackage.getVersion();\n\t\t\t\tString version = pluginPackage.getVersion();\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Updating \" + name + \" from version \" +\n\t\t\t\t\t\t\tpreviousVersion + \" to version \" + version);\n\t\t\t\t}\n\n\t\t\t\tif (pluginPackage.isLaterVersionThan(previousPluginPackage)) {\n\t\t\t\t\toverwrite = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\t\"Not updating \" + name + \" because version \" +\n\t\t\t\t\t\t\t\tpreviousVersion + \" is newer than version \" +\n\t\t\t\t\t\t\t\t\tversion);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn AutoDeployer.CODE_SKIP_NEWER_VERSION;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFile mergeDirFile = new File(\n\t\t\t\tsrcFile.getParent() + \"/merge/\" + srcFile.getName());\n\n\t\t\tif (srcFile.isDirectory()) {\n\t\t\t\tdeployDirectory(\n\t\t\t\t\tsrcFile, mergeDirFile, deployDirFile, displayName,\n\t\t\t\t\toverwrite, pluginPackage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean deployed = deployFile(\n\t\t\t\t\tsrcFile, mergeDirFile, deployDirFile, displayName,\n\t\t\t\t\toverwrite, pluginPackage);\n\n\t\t\t\tif (!deployed) {\n\t\t\t\t\tString context = preliminaryContext;\n\n\t\t\t\t\tif (pluginPackage != null) {\n\t\t\t\t\t\tcontext = pluginPackage.getContext();\n\t\t\t\t\t}\n\n\t\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(context);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpostDeploy(destDir, deployDir);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn AutoDeployer.CODE_DEFAULT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (pluginPackage != null) {\n\t\t\t\tPluginPackageUtil.endPluginPackageInstallation(\n\t\t\t\t\tpluginPackage.getContext());\n\t\t\t}\n\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isExtPlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Copying extension environment plugin for \" + file.getPath());\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Extension environment for \" + file.getPath() +\n\t\t\t\t\t\" copied successfully. Deployment will start in a few \" +\n\t\t\t\t\t\t\"seconds.\");\n\t\t}\n\t}","id":86377,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isExtPlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Copying extension environment plugin for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Extension environment for \" + file.getPath() +\n\t\t\t\t\t\" copied successfully. Deployment will start in a few \" +\n\t\t\t\t\t\t\"seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isHookPlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying hook plugin for \" + file.getPath());\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","id":86378,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isHookPlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying hook plugin for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Hook for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, \"WEB-INF/liferay-layout-templates.xml\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying layout templates for \" + file.getPath());\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Layout templates for \" + file.getPath() +\n\t\t\t\t\t\" copied successfully. Deployment will start in a few \" +\n\t\t\t\t\t\t\"seconds.\");\n\t\t}\n\t}","id":86379,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isMatchingFile(file, \"WEB-INF/liferay-layout-templates.xml\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying layout templates for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Layout templates for \" + file.getPath() +\n\t\t\t\t\t\" copied successfully. Deployment will start in a few \" +\n\t\t\t\t\t\t\"seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isLiferayPackage(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Extracting Liferay package for \" + file.getPath());\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Liferay package for \" + file.getPath() +\" extracted \" +\n\t\t\t\t\t\"successfully. Deployment will start in a few seconds.\");\n\t\t}\n\t}","id":86380,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isLiferayPackage(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Extracting Liferay package for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Liferay package for \" + file.getPath() +\" extracted \" +\n\t\t\t\t\t\"successfully. Deployment will start in a few seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void autoDeploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tZipFile zipFile = null;\n\n\t\ttry {\n\t\t\tFile file = autoDeploymentContext.getFile();\n\n\t\t\tzipFile = new ZipFile(file);\n\n\t\t\tList<String> fileNames = new ArrayList<String>(zipFile.size());\n\t\t\tString propertiesString = null;\n\n\t\t\tEnumeration<? extends ZipEntry> enu = zipFile.entries();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tZipEntry zipEntry = enu.nextElement();\n\n\t\t\t\tString zipEntryFileName = zipEntry.getName();\n\n\t\t\t\tif (!zipEntryFileName.endsWith(\".war\") &&\n\t\t\t\t\t!zipEntryFileName.endsWith(\".xml\") &&\n\t\t\t\t\t!zipEntryFileName.endsWith(\".zip\") &&\n\t\t\t\t\t!zipEntryFileName.equals(\n\t\t\t\t\t\t\"liferay-marketplace.properties\")) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Extracting \" + zipEntryFileName + \" from \" +\n\t\t\t\t\t\t\tfile.getName());\n\t\t\t\t}\n\n\t\t\t\tInputStream inputStream = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tinputStream = zipFile.getInputStream(zipEntry);\n\n\t\t\t\t\tif (zipEntryFileName.equals(\n\t\t\t\t\t\t\t\"liferay-marketplace.properties\")) {\n\n\t\t\t\t\t\tinputStream = zipFile.getInputStream(zipEntry);\n\n\t\t\t\t\t\tpropertiesString = StringUtil.read(inputStream);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfileNames.add(zipEntryFileName);\n\n\t\t\t\t\t\tFileUtil.write(\n\t\t\t\t\t\t\tbaseDir + StringPool.SLASH + zipEntryFileName,\n\t\t\t\t\t\t\tinputStream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (propertiesString != null) {\n\t\t\t\tMessage message = new Message();\n\n\t\t\t\tmessage.put(\"command\", \"deploy\");\n\t\t\t\tmessage.put(\"fileNames\", fileNames);\n\t\t\t\tmessage.put(\"properties\", propertiesString);\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.MARKETPLACE, message);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AutoDeployException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (zipFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipFile.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":86381,"modified_method":"public int autoDeploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tZipFile zipFile = null;\n\n\t\ttry {\n\t\t\tFile file = autoDeploymentContext.getFile();\n\n\t\t\tzipFile = new ZipFile(file);\n\n\t\t\tList<String> fileNames = new ArrayList<String>(zipFile.size());\n\t\t\tString propertiesString = null;\n\n\t\t\tEnumeration<? extends ZipEntry> enu = zipFile.entries();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tZipEntry zipEntry = enu.nextElement();\n\n\t\t\t\tString zipEntryFileName = zipEntry.getName();\n\n\t\t\t\tif (!zipEntryFileName.endsWith(\".war\") &&\n\t\t\t\t\t!zipEntryFileName.endsWith(\".xml\") &&\n\t\t\t\t\t!zipEntryFileName.endsWith(\".zip\") &&\n\t\t\t\t\t!zipEntryFileName.equals(\n\t\t\t\t\t\t\"liferay-marketplace.properties\")) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Extracting \" + zipEntryFileName + \" from \" +\n\t\t\t\t\t\t\tfile.getName());\n\t\t\t\t}\n\n\t\t\t\tInputStream inputStream = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tinputStream = zipFile.getInputStream(zipEntry);\n\n\t\t\t\t\tif (zipEntryFileName.equals(\n\t\t\t\t\t\t\t\"liferay-marketplace.properties\")) {\n\n\t\t\t\t\t\tinputStream = zipFile.getInputStream(zipEntry);\n\n\t\t\t\t\t\tpropertiesString = StringUtil.read(inputStream);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfileNames.add(zipEntryFileName);\n\n\t\t\t\t\t\tFileUtil.write(\n\t\t\t\t\t\t\tbaseDir + StringPool.SLASH + zipEntryFileName,\n\t\t\t\t\t\t\tinputStream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (propertiesString != null) {\n\t\t\t\tMessage message = new Message();\n\n\t\t\t\tmessage.put(\"command\", \"deploy\");\n\t\t\t\tmessage.put(\"fileNames\", fileNames);\n\t\t\t\tmessage.put(\"properties\", propertiesString);\n\n\t\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\t\tDestinationNames.MARKETPLACE, message);\n\t\t\t}\n\n\t\t\treturn AutoDeployer.CODE_DEFAULT;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AutoDeployException(e);\n\t\t}\n\t\tfinally {\n\t\t\tif (zipFile != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipFile.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tAutoDeployer deployer = null;\n\n\t\tif (isMatchingFile(\n\t\t\t\tfile, \"WEB-INF/\" + Portal.PORTLET_XML_FILE_NAME_STANDARD)) {\n\n\t\t\tdeployer = _autoDeployer;\n\t\t}\n\t\telse if (isMatchingFile(file, \"index_mvc.jsp\")) {\n\t\t\tdeployer = getMvcDeployer();\n\t\t}\n\t\telse if (isMatchingFile(file, \"index.php\")) {\n\t\t\tdeployer = getPhpDeployer();\n\t\t}\n\t\telse if (!isExtPlugin(file) && !isHookPlugin(file) &&\n\t\t\t\t !isMatchingFile(\n\t\t\t\t\tfile, \"WEB-INF/liferay-layout-templates.xml\") &&\n\t\t\t\t !isThemePlugin(file) && !isWebPlugin(file) &&\n\t\t\t\t file.getName().endsWith(\".war\")) {\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Deploying package as a web application\");\n\t\t\t}\n\n\t\t\tdeployer = getWaiDeployer();\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying portlets for \" + file.getPath());\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Using deployer \" + deployer.getClass().getName());\n\t\t}\n\n\t\tdeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Portlets for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","id":86382,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tAutoDeployer deployer = null;\n\n\t\tif (isMatchingFile(\n\t\t\t\tfile, \"WEB-INF/\" + Portal.PORTLET_XML_FILE_NAME_STANDARD)) {\n\n\t\t\tdeployer = _autoDeployer;\n\t\t}\n\t\telse if (isMatchingFile(file, \"index_mvc.jsp\")) {\n\t\t\tdeployer = getMvcDeployer();\n\t\t}\n\t\telse if (isMatchingFile(file, \"index.php\")) {\n\t\t\tdeployer = getPhpDeployer();\n\t\t}\n\t\telse if (!isExtPlugin(file) && !isHookPlugin(file) &&\n\t\t\t\t !isMatchingFile(\n\t\t\t\t\tfile, \"WEB-INF/liferay-layout-templates.xml\") &&\n\t\t\t\t !isThemePlugin(file) && !isWebPlugin(file) &&\n\t\t\t\t file.getName().endsWith(\".war\")) {\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Deploying package as a web application\");\n\t\t\t}\n\n\t\t\tdeployer = getWaiDeployer();\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying portlets for \" + file.getPath());\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Using deployer \" + deployer.getClass().getName());\n\t\t}\n\n\t\tint code = deployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Portlets for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isThemePlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying themes for \" + file.getPath());\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Themes for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","id":86383,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isThemePlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying themes for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Themes for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isWebPlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying web plugin for \" + file.getPath());\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Web plugin for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","id":86384,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isWebPlugin(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copying web plugin for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Web plugin for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","commit_id":"80b75f5e1ec652ef447249ecf3fb28b394a96685","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean isModule(File file) throws AutoDeployException {\n\t\tInputStream inputStream = null;\n\t\tManifest manifest = null;\n\n\t\ttry {\n\t\t\tinputStream = new FileInputStream(file);\n\t\t\tmanifest = new JarInputStream(inputStream).getManifest();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new AutoDeployException(ioe);\n\t\t}\n\n\t\tAttributes attributes = manifest.getMainAttributes();\n\n\t\tString bundleSymbolicNameAttributeValue = attributes.getValue(\n\t\t\tConstants.BUNDLE_SYMBOLICNAME);\n\n\t\tMap<String, Map<String, String>> bundleSymbolicNameMap =\n\t\t\tOSGiHeader.parseHeader(bundleSymbolicNameAttributeValue);\n\n\t\tSet<String> bundleSymbolicNameSet = bundleSymbolicNameMap.keySet();\n\n\t\tIterator<String> bundleSymbolicNameIterator =\n\t\t\tbundleSymbolicNameSet.iterator();\n\n\t\tString bundleSymbolicName = bundleSymbolicNameIterator.next();\n\n\t\tif (bundleSymbolicName != null) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":86385,"modified_method":"protected boolean isModule(File file) throws AutoDeployException {\n\t\tManifest manifest = null;\n\n\t\ttry {\n\t\t\tJarInputStream jarInputStream = new JarInputStream(\n\t\t\t\tnew FileInputStream(file));\n\n\t\t\tmanifest = jarInputStream.getManifest();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new AutoDeployException(ioe);\n\t\t}\n\n\t\tAttributes attributes = manifest.getMainAttributes();\n\n\t\tString bundleSymbolicNameAttributeValue = attributes.getValue(\n\t\t\tConstants.BUNDLE_SYMBOLICNAME);\n\n\t\tMap<String, Map<String, String>> bundleSymbolicNameMap =\n\t\t\tOSGiHeader.parseHeader(bundleSymbolicNameAttributeValue);\n\n\t\tSet<String> bundleSymbolicNameSet = bundleSymbolicNameMap.keySet();\n\n\t\tif (bundleSymbolicNameSet.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tIterator<String> bundleSymbolicNameIterator =\n\t\t\tbundleSymbolicNameSet.iterator();\n\n\t\tString bundleSymbolicName = bundleSymbolicNameIterator.next();\n\n\t\treturn Validator.isNotNull(bundleSymbolicName);\n\t}","commit_id":"d2f51c02b309766ba13441a1f2b481de7fc8a45c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isModule(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\t_autoDeployer.autoDeploy(autoDeploymentContext);\n\t}","id":86386,"modified_method":"public void deploy(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows AutoDeployException {\n\n\t\tFile file = autoDeploymentContext.getFile();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Invoking deploy for \" + file.getPath());\n\t\t}\n\n\t\tif (!isModule(file)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Copied module for \" + file.getPath());\n\t\t}\n\n\t\tint code = _autoDeployer.autoDeploy(autoDeploymentContext);\n\n\t\tif ((code == AutoDeployer.CODE_DEFAULT) && _log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Module for \" + file.getPath() + \" copied successfully. \" +\n\t\t\t\t\t\"Deployment will start in a few seconds.\");\n\t\t}\n\t}","commit_id":"d2f51c02b309766ba13441a1f2b481de7fc8a45c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int deployFile(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows Exception {\n\n\t\tcopyToModuleFolder(autoDeploymentContext);\n\n\t\treturn AutoDeployer.CODE_DEFAULT;\n\t}","id":86387,"modified_method":"@Override\n\tpublic int deployFile(AutoDeploymentContext autoDeploymentContext)\n\t\tthrows Exception {\n\n\t\tString destDir = PropsValues.MODULE_FRAMEWORK_AUTO_DEPLOY_DIRS[0];\n\n\t\tif (!FileUtil.exists(destDir)) {\n\t\t\tFileUtil.mkdirs(destDir);\n\t\t}\n\n\t\ttry {\n\t\t\tFileUtils.copyFileToDirectory(\n\t\t\t\tautoDeploymentContext.getFile(), new File(destDir));\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new AutoDeployException(ioe);\n\t\t}\n\n\t\treturn AutoDeployer.CODE_DEFAULT;\n\t}","commit_id":"d2f51c02b309766ba13441a1f2b481de7fc8a45c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n    public void testRestletProducer2() throws Exception {\n        final Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"id\", 123);\n        headers.put(\"beverage.beer\", \"Carlsberg\");\n\n        Exchange out = template.request(\"direct:start\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeaders(headers);\n            }\n        });\n        assertNotNull(out);\n        assertEquals(\"text/xml\", out.getOut().getHeader(Exchange.CONTENT_TYPE));\n        assertEquals(200, out.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE));\n        assertEquals(\"<response>Beer is Good<\/response>\", out.getOut().getBody());\n\n        // the restlet response should be accessible if neeeded\n        Response response = out.getOut().getHeader(RestletConstants.RESTLET_RESPONSE, Response.class);\n        assertNotNull(response);\n        assertEquals(200, response.getStatus().getCode());\n    }","id":86388,"modified_method":"@Test\n    public void testRestletProducer2() throws Exception {\n        final Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"id\", 123);\n        headers.put(\"beverage.beer\", \"Carlsberg\");\n\n        Exchange out = template.request(\"direct:start\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeaders(headers);\n            }\n        });\n        assertNotNull(out);\n        assertEquals(\"text/xml\", out.getOut().getHeader(Exchange.CONTENT_TYPE));\n        assertEquals(200, out.getOut().getHeader(Exchange.HTTP_RESPONSE_CODE));\n        assertEquals(\"<response>Beer is Good<\/response>\", out.getOut().getBody(String.class));\n\n        // the restlet response should be accessible if needed\n        Response response = out.getOut().getHeader(RestletConstants.RESTLET_RESPONSE, Response.class);\n        assertNotNull(response);\n        assertEquals(200, response.getStatus().getCode());\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testRestletProducer() throws Exception {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"id\", 123);\n        headers.put(\"beverage.beer\", \"Carlsberg\");\n\n        Object out = template.requestBodyAndHeaders(\"direct:start\", null, headers);\n        assertEquals(\"<response>Beer is Good<\/response>\", out);\n    }","id":86389,"modified_method":"@Test\n    public void testRestletProducer() throws Exception {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(\"id\", 123);\n        headers.put(\"beverage.beer\", \"Carlsberg\");\n\n        String out = template.requestBodyAndHeaders(\"direct:start\", null, headers, String.class);\n        assertEquals(\"<response>Beer is Good<\/response>\", out);\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testBasicAuth() throws IOException {\n        \n        // START SNIPPET: auth_request\n        final String id = \"89531\";\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.RESTLET_LOGIN, \"admin\");\n        headers.put(RestletConstants.RESTLET_PASSWORD, \"foo\");\n        headers.put(\"id\", id);\n        \n        String response = (String)template.requestBodyAndHeaders(\n            \"direct:start-auth\", \"<order foo='1'/>\", headers);\n        // END SNIPPET: auth_request\n\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + id, response);\n    }","id":86390,"modified_method":"@Test\n    public void testBasicAuth() throws IOException {\n        \n        // START SNIPPET: auth_request\n        final String id = \"89531\";\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.RESTLET_LOGIN, \"admin\");\n        headers.put(RestletConstants.RESTLET_PASSWORD, \"foo\");\n        headers.put(\"id\", id);\n        \n        String response = template.requestBodyAndHeaders(\n            \"direct:start-auth\", \"<order foo='1'/>\", headers, String.class);\n        // END SNIPPET: auth_request\n\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + id, response);\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testProducer() throws IOException {\n        String response = (String)template.requestBody(\"direct:start\", \"<order foo='1'/>\");\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n        \n        response = (String)template.sendBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post&foo=bar\", \n            ExchangePattern.InOut,\n            \"<order foo='1'/>\", \"id\", \"89531\");\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n    }","id":86391,"modified_method":"@Test\n    public void testProducer() throws IOException {\n        String response = template.requestBody(\"direct:start\", \"<order foo='1'/>\", String.class);\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n        \n        response = template.requestBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/orders?restletMethod=post&foo=bar\", \n            \"<order foo='1'/>\", \"id\", \"89531\", String.class);\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + ID, response);\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testProducerJSON() throws IOException {\n        String response = (String)template.sendBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/ordersJSON?restletMethod=post&foo=bar\", \n            ExchangePattern.InOut,\n            JSON,\n            Exchange.CONTENT_TYPE,\n            MediaType.APPLICATION_JSON);\n           \n        assertEquals(JSON, response);\n    }","id":86392,"modified_method":"@Test\n    public void testProducerJSON() throws IOException {\n        String response = template.requestBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/ordersJSON?restletMethod=post&foo=bar\", \n            JSON,\n            Exchange.CONTENT_TYPE,\n            MediaType.APPLICATION_JSON,\n            String.class);\n           \n        assertEquals(JSON, response);\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testProducerJSONFailure() throws IOException {\n        String response = (String)template.sendBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/ordersJSON?restletMethod=post&foo=bar\", \n            ExchangePattern.InOut,\n            \"{'JSON'}\",\n            Exchange.CONTENT_TYPE,\n            MediaType.APPLICATION_JSON);\n           \n        assertEquals(\"{'JSON'}\", response);\n    }","id":86393,"modified_method":"@Test\n    public void testProducerJSONFailure() throws IOException {\n        String response = template.requestBodyAndHeader(\n            \"restlet:http://localhost:\" + portNum + \"/ordersJSON?restletMethod=post&foo=bar\", \n            \"{'JSON'}\",\n            Exchange.CONTENT_TYPE,\n            MediaType.APPLICATION_JSON, String.class);\n           \n        assertEquals(\"{'JSON'}\", response);\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"restlet:http://0.0.0.0:\" + portNum + \"/stock/{symbol}?restletMethods=get\")\n                    .to(\"http://127.0.0.1:\" + portNum2 + \"/test?bridgeEndpoint=true\")\n                    //.removeHeader(\"Transfer-Encoding\")\n                    .setBody().constant(\"110\");\n                \n                from(\"jetty:http://0.0.0.0:\" + portNum2 + \"/test\").setBody().constant(\"response is back\");\n\n                // create ByteArrayRepresentation for response\n                byte[] image = new byte[10];\n                for (int i = 0; i < 10; i++) {\n                    image[i] = (byte)(i + 1);\n                }\n                ByteArrayInputStream inputStream = new ByteArrayInputStream(image);\n\n                from(\"restlet:http://0.0.0.0:\" + portNum + \"/images/{symbol}?restletMethods=get\")\n                    .setBody().constant(new InputRepresentation(inputStream, MediaType.IMAGE_PNG, 10));\n                \n                from(\"restlet:http://0.0.0.0:\" + portNum + \"/gzip/data?restletMethods=get\")\n                    .setBody().constant(new EncodeRepresentation(Encoding.GZIP, new StringRepresentation(\"Hello World!\", MediaType.TEXT_XML)));\n            }\n        };\n    }","id":86394,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"restlet:http://localhost:\" + portNum + \"/stock/{symbol}?restletMethods=get\")\n                    .to(\"http://localhost:\" + portNum2 + \"/test?bridgeEndpoint=true\")\n                    //.removeHeader(\"Transfer-Encoding\")\n                    .setBody().constant(\"110\");\n                \n                from(\"jetty:http://localhost:\" + portNum2 + \"/test\").setBody().constant(\"response is back\");\n\n                // create ByteArrayRepresentation for response\n                byte[] image = new byte[10];\n                for (int i = 0; i < 10; i++) {\n                    image[i] = (byte)(i + 1);\n                }\n                ByteArrayInputStream inputStream = new ByteArrayInputStream(image);\n\n                from(\"restlet:http://localhost:\" + portNum + \"/images/{symbol}?restletMethods=get\")\n                    .setBody().constant(new InputRepresentation(inputStream, MediaType.IMAGE_PNG, 10));\n                \n                from(\"restlet:http://localhost:\" + portNum + \"/gzip/data?restletMethods=get\")\n                    .setBody().constant(new EncodeRepresentation(Encoding.GZIP, new StringRepresentation(\"Hello World!\", MediaType.TEXT_XML)));\n            }\n        };\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testSetBody() throws Exception {\n        String response = template.requestBody(\"restlet:http://0.0.0.0:\" + portNum + \"/stock/ORCL?restletMethod=get\", null, String.class);\n        assertEquals(\"110\", response);\n       \n    }","id":86395,"modified_method":"@Test\n    public void testSetBody() throws Exception {\n        String response = template.requestBody(\"restlet:http://localhost:\" + portNum + \"/stock/ORCL?restletMethod=get\", null, String.class);\n        assertEquals(\"110\", response);\n       \n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testGzipEntity() {\n        String response = template.requestBody(\"restlet:http://0.0.0.0:\" + portNum + \"/gzip/data?restletMethod=get\", null, String.class);\n        assertEquals(\"Hello World!\", response);\n    }","id":86396,"modified_method":"@Test\n    public void testGzipEntity() {\n        String response = template.requestBody(\"restlet:http://localhost:\" + portNum + \"/gzip/data?restletMethod=get\", null, String.class);\n        assertEquals(\"Hello World!\", response);\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testSetBodyRepresentation() throws Exception {\n        HttpGet get = new HttpGet(\"http://0.0.0.0:\" + portNum + \"/images/123\");\n        CloseableHttpClient httpclient = HttpClientBuilder.create().build();\n        InputStream is = null;\n        try {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"image/png\", response.getEntity().getContentType().getValue());\n            is = response.getEntity().getContent();\n            assertEquals(\"Get wrong available size\", 10, response.getEntity().getContentLength());\n            byte[] buffer = new byte[10];\n            is.read(buffer);\n            for (int i = 0; i < 10; i++) {\n                assertEquals(i + 1, buffer[i]);\n            }\n        } finally {\n            httpclient.close();\n            if (is != null) {\n                is.close();\n            }\n        }\n    }","id":86397,"modified_method":"@Test\n    public void testSetBodyRepresentation() throws Exception {\n        HttpGet get = new HttpGet(\"http://localhost:\" + portNum + \"/images/123\");\n        CloseableHttpClient httpclient = HttpClientBuilder.create().build();\n        InputStream is = null;\n        try {\n            HttpResponse response = httpclient.execute(get);\n            assertEquals(200, response.getStatusLine().getStatusCode());\n            assertEquals(\"image/png\", response.getEntity().getContentType().getValue());\n            is = response.getEntity().getContent();\n            assertEquals(\"Get wrong available size\", 10, response.getEntity().getContentLength());\n            byte[] buffer = new byte[10];\n            is.read(buffer);\n            for (int i = 0; i < 10; i++) {\n                assertEquals(i + 1, buffer[i]);\n            }\n        } finally {\n            httpclient.close();\n            if (is != null) {\n                is.close();\n            }\n        }\n    }","commit_id":"5d2fec5396471734e8c1d2ef798652279961fde3","url":"https://github.com/apache/camel"},{"original_method":"private void createMessageSelectorAndSubscribe() {\n        // Subscribe to eventd\n        getEventManager().addEventListener(this, m_config.getUEIList());\n    }","id":86398,"modified_method":"private void createMessageSelectorAndSubscribe() {\n        // Subscribe to eventd\n        List<String> ueiList = m_config.getUEIList();\n        ueiList.add(EventConstants.RELOAD_DAEMON_CONFIG_UEI);\n        getEventManager().addEventListener(this, ueiList);\n    }","commit_id":"3ec10d7041f7ff1623f2fc514f5715c184c23e2b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onEvent(Event e) {\n    \t\n    \t\tif (getName().equals(e.getSource())) {\n    \t\t\tlog().debug(\"onEvent: ignoring event with EventTranslator as source\");\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif (!m_config.isTranslationEvent(e)) {\n    \t\t\tlog().debug(\"onEvent: received event that matches no translations: \\n\"+EventUtils.toString(e));\n    \t\t\treturn;\n    \t\t}\n        \n    \t\tlog().debug(\"onEvent: received valid registered translation event: \\n\"+EventUtils.toString(e));\n    \t\tList translated = m_config.translateEvent(e);\n    \t\tif (translated != null) {\n    \t\t\tLog log = new Log();\n    \t\t\tEvents events = new Events();\n    \t\t\tfor (Iterator iter = translated.iterator(); iter.hasNext();) {\n    \t\t\t\tEvent event = (Event) iter.next();\n    \t\t\t\tevents.addEvent(event);\n    \t\t\t\tlog().debug(\"onEvent: sended translated event: \\n\"+EventUtils.toString(event));\n    \t\t\t}\n    \t\t\tlog.setEvents(events);\n    \t\t\tgetEventManager().sendNow(log);\n    \t\t}\n    }","id":86399,"modified_method":"public void onEvent(Event e) {\n\n        if (isReloadConfigEvent(e)) {\n            handleReloadEvent(e);\n            return;\n        }\n\n        if (getName().equals(e.getSource())) {\n            log().debug(\"onEvent: ignoring event with EventTranslator as source\");\n            return;\n        }\n\n        if (!m_config.isTranslationEvent(e)) {\n            log().debug(\"onEvent: received event that matches no translations: \\n\"+EventUtils.toString(e));\n            return;\n        }\n\n        log().debug(\"onEvent: received valid registered translation event: \\n\"+EventUtils.toString(e));\n        \n        List<Event> translated = m_config.translateEvent(e);\n        if (translated != null) {\n            Log log = new Log();\n            Events events = new Events();\n            for (Iterator<Event> iter = translated.iterator(); iter.hasNext();) {\n                Event event = iter.next();\n                events.addEvent(event);\n                log().debug(\"onEvent: sended translated event: \\n\"+EventUtils.toString(event));\n            }\n            log.setEvents(events);\n            getEventManager().sendNow(log);\n        }\n    }","commit_id":"3ec10d7041f7ff1623f2fc514f5715c184c23e2b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void createMessageSelectorAndSubscribe() {\n        // Subscribe to eventd\n        getEventManager().addEventListener(this, m_config.getUEIList());\n    }","id":86400,"modified_method":"private void createMessageSelectorAndSubscribe() {\n        // Subscribe to eventd\n        List<String> ueiList = m_config.getUEIList();\n        ueiList.add(EventConstants.RELOAD_DAEMON_CONFIG_UEI);\n        getEventManager().addEventListener(this, ueiList);\n    }","commit_id":"81b76f14d1b9dca9b2ee6e4a84ad66ea850b72ff","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onEvent(Event e) {\n    \t\n    \t\tif (getName().equals(e.getSource())) {\n    \t\t\tlog().debug(\"onEvent: ignoring event with EventTranslator as source\");\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif (!m_config.isTranslationEvent(e)) {\n    \t\t\tlog().debug(\"onEvent: received event that matches no translations: \\n\"+EventUtils.toString(e));\n    \t\t\treturn;\n    \t\t}\n        \n    \t\tlog().debug(\"onEvent: received valid registered translation event: \\n\"+EventUtils.toString(e));\n    \t\tList translated = m_config.translateEvent(e);\n    \t\tif (translated != null) {\n    \t\t\tLog log = new Log();\n    \t\t\tEvents events = new Events();\n    \t\t\tfor (Iterator iter = translated.iterator(); iter.hasNext();) {\n    \t\t\t\tEvent event = (Event) iter.next();\n    \t\t\t\tevents.addEvent(event);\n    \t\t\t\tlog().debug(\"onEvent: sended translated event: \\n\"+EventUtils.toString(event));\n    \t\t\t}\n    \t\t\tlog.setEvents(events);\n    \t\t\tgetEventManager().sendNow(log);\n    \t\t}\n    }","id":86401,"modified_method":"public void onEvent(Event e) {\n\n        if (isReloadConfigEvent(e)) {\n            handleReloadEvent(e);\n            return;\n        }\n\n        if (getName().equals(e.getSource())) {\n            log().debug(\"onEvent: ignoring event with EventTranslator as source\");\n            return;\n        }\n\n        if (!m_config.isTranslationEvent(e)) {\n            log().debug(\"onEvent: received event that matches no translations: \\n\"+EventUtils.toString(e));\n            return;\n        }\n\n        log().debug(\"onEvent: received valid registered translation event: \\n\"+EventUtils.toString(e));\n        \n        List<Event> translated = m_config.translateEvent(e);\n        if (translated != null) {\n            Log log = new Log();\n            Events events = new Events();\n            for (Iterator<Event> iter = translated.iterator(); iter.hasNext();) {\n                Event event = iter.next();\n                events.addEvent(event);\n                log().debug(\"onEvent: sended translated event: \\n\"+EventUtils.toString(event));\n            }\n            log.setEvents(events);\n            getEventManager().sendNow(log);\n        }\n    }","commit_id":"81b76f14d1b9dca9b2ee6e4a84ad66ea850b72ff","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void createMessageSelectorAndSubscribe() {\n        // Subscribe to eventd\n        getEventManager().addEventListener(this, m_config.getUEIList());\n    }","id":86402,"modified_method":"private void createMessageSelectorAndSubscribe() {\n        // Subscribe to eventd\n        List<String> ueiList = m_config.getUEIList();\n        ueiList.add(EventConstants.RELOAD_DAEMON_CONFIG_UEI);\n        getEventManager().addEventListener(this, ueiList);\n    }","commit_id":"955d3ffd2186097b99430cd481f13e6064266f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onEvent(Event e) {\n    \t\n    \t\tif (getName().equals(e.getSource())) {\n    \t\t\tlog().debug(\"onEvent: ignoring event with EventTranslator as source\");\n    \t\t\treturn;\n    \t\t}\n    \t\t\n    \t\tif (!m_config.isTranslationEvent(e)) {\n    \t\t\tlog().debug(\"onEvent: received event that matches no translations: \\n\"+EventUtils.toString(e));\n    \t\t\treturn;\n    \t\t}\n        \n    \t\tlog().debug(\"onEvent: received valid registered translation event: \\n\"+EventUtils.toString(e));\n    \t\tList translated = m_config.translateEvent(e);\n    \t\tif (translated != null) {\n    \t\t\tLog log = new Log();\n    \t\t\tEvents events = new Events();\n    \t\t\tfor (Iterator iter = translated.iterator(); iter.hasNext();) {\n    \t\t\t\tEvent event = (Event) iter.next();\n    \t\t\t\tevents.addEvent(event);\n    \t\t\t\tlog().debug(\"onEvent: sended translated event: \\n\"+EventUtils.toString(event));\n    \t\t\t}\n    \t\t\tlog.setEvents(events);\n    \t\t\tgetEventManager().sendNow(log);\n    \t\t}\n    }","id":86403,"modified_method":"public void onEvent(Event e) {\n\n        if (isReloadConfigEvent(e)) {\n            handleReloadEvent(e);\n            return;\n        }\n\n        if (getName().equals(e.getSource())) {\n            log().debug(\"onEvent: ignoring event with EventTranslator as source\");\n            return;\n        }\n\n        if (!m_config.isTranslationEvent(e)) {\n            log().debug(\"onEvent: received event that matches no translations: \\n\"+EventUtils.toString(e));\n            return;\n        }\n\n        log().debug(\"onEvent: received valid registered translation event: \\n\"+EventUtils.toString(e));\n        \n        List<Event> translated = m_config.translateEvent(e);\n        if (translated != null) {\n            Log log = new Log();\n            Events events = new Events();\n            for (Iterator<Event> iter = translated.iterator(); iter.hasNext();) {\n                Event event = iter.next();\n                events.addEvent(event);\n                log().debug(\"onEvent: sended translated event: \\n\"+EventUtils.toString(event));\n            }\n            log.setEvents(events);\n            getEventManager().sendNow(log);\n        }\n    }","commit_id":"955d3ffd2186097b99430cd481f13e6064266f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static HazelcastInstance createInstance(final FilterConfig filterConfig, final Properties properties)\n            throws ServletException {\n        final String instanceName = properties.getProperty(INSTANCE_NAME);\n        final String configLocation = properties.getProperty(CONFIG_LOCATION);\n        final String useClientProp = properties.getProperty(USE_CLIENT);\n        final String clientConfigLocation = properties.getProperty(CLIENT_CONFIG_LOCATION);\n        final boolean useClient = !isEmpty(useClientProp) && Boolean.parseBoolean(useClientProp);\n\n        URL configUrl = null;\n        if (useClient && !isEmpty(clientConfigLocation)) {\n            configUrl = getConfigURL(filterConfig, clientConfigLocation);\n        } else if(!isEmpty(configLocation)) {\n            configUrl = getConfigURL(filterConfig, configLocation);\n        }\n\n        if(useClient) {\n            logger.warning(\n                    \"Creating HazelcastClient, make sure this node has access to an already running cluster...\");\n            ClientConfig clientConfig ;\n            if (configUrl == null) {\n                clientConfig = new ClientConfig();\n                clientConfig.setConnectionAttemptLimit(3);\n            } else {\n                try {\n                    clientConfig = new XmlClientConfigBuilder(configUrl).build();\n                } catch (IOException e) {\n                    throw new ServletException(e);\n                }\n            }\n            return HazelcastClient.newHazelcastClient(clientConfig);\n        }\n\n        Config config;\n        if (configUrl == null) {\n            config = new XmlConfigBuilder().build();\n        } else {\n            try {\n                config = new UrlXmlConfig(configUrl);\n            } catch (IOException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        if (!isEmpty(instanceName)) {\n            config.setInstanceName(instanceName);\n            return Hazelcast.getOrCreateHazelcastInstance(config);\n        } else {\n            return Hazelcast.newHazelcastInstance(config);\n        }\n    }","id":86404,"modified_method":"public static HazelcastInstance createInstance(final FilterConfig filterConfig, final Properties properties)\n            throws ServletException {\n        final String instanceName = properties.getProperty(INSTANCE_NAME);\n        final String configLocation = properties.getProperty(CONFIG_LOCATION);\n        final String useClientProp = properties.getProperty(USE_CLIENT);\n        final String clientConfigLocation = properties.getProperty(CLIENT_CONFIG_LOCATION);\n        final boolean useClient = !isEmpty(useClientProp) && Boolean.parseBoolean(useClientProp);\n\n        URL configUrl = null;\n        if (useClient && !isEmpty(clientConfigLocation)) {\n            configUrl = getConfigURL(filterConfig, clientConfigLocation);\n        } else if(!isEmpty(configLocation)) {\n            configUrl = getConfigURL(filterConfig, configLocation);\n        }\n\n        if(useClient) {\n            logger.info(\n                    \"Creating HazelcastClient for session replication, make sure this client has access to an already running cluster...\");\n            ClientConfig clientConfig ;\n            if (configUrl == null) {\n                clientConfig = new ClientConfig();\n                clientConfig.setConnectionAttemptLimit(3);\n            } else {\n                try {\n                    clientConfig = new XmlClientConfigBuilder(configUrl).build();\n                } catch (IOException e) {\n                    throw new ServletException(e);\n                }\n            }\n            return HazelcastClient.newHazelcastClient(clientConfig);\n        }\n\n        Config config;\n        if (configUrl == null) {\n            config = new XmlConfigBuilder().build();\n        } else {\n            try {\n                config = new UrlXmlConfig(configUrl);\n            } catch (IOException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        if (!isEmpty(instanceName)) {\n            if(logger.isLoggable(Level.INFO)){\n                logger.info(format(\"Getting an existing or creating a new HazelcastInstance with name %s for session replication\",instanceName));\n            }\n            config.setInstanceName(instanceName);\n            return Hazelcast.getOrCreateHazelcastInstance(config);\n        } else {\n            logger.info(\"Creating a new HazelcastInstance for session replication\");\n            return Hazelcast.newHazelcastInstance(config);\n        }\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public HazelcastHttpSession getSession(final boolean create) {\n            if (hazelcastSession != null && !hazelcastSession.isValid()) {\n                log(\"Session is invalid!\");\n                destroySession(hazelcastSession, true);\n                hazelcastSession = null;\n            }\n            if (hazelcastSession == null) {\n                HttpSession originalSession = getOriginalSession(false);\n                if (originalSession != null) {\n                    String hazelcastSessionId = mapOriginalSessions.get(originalSession.getId());\n                    if (hazelcastSessionId != null) {\n                        hazelcastSession = mapSessions.get(hazelcastSessionId);\n                    }\n                    if (hazelcastSession == null) {\n                        mapOriginalSessions.remove(originalSession.getId());\n                        originalSession.invalidate();\n                    }\n                }\n            }\n            if (hazelcastSession != null)\n                return hazelcastSession;\n            final String requestedSessionId = fetchHazelcastSessionId();\n            if (requestedSessionId != null) {\n                hazelcastSession = getSessionWithId(requestedSessionId);\n                if (hazelcastSession == null) {\n                    final Boolean existing = (Boolean) getClusterMap().get(requestedSessionId);\n                    if (existing != null && existing) {\n                        // we already have the session in the cluster loading it...\n                        hazelcastSession = createNewSession(RequestWrapper.this, requestedSessionId);\n                    }\n                }\n            }\n            if (hazelcastSession == null && create) {\n                hazelcastSession = createNewSession(RequestWrapper.this, null);\n            }\n            if (deferredWrite) {\n                prepareReloadingSession(hazelcastSession);\n            }\n            return hazelcastSession;\n        }","id":86405,"modified_method":"@Override\n        public HazelcastHttpSession getSession(final boolean create) {\n            if (hazelcastSession != null && !hazelcastSession.isValid()) {\n                logger.finest(\"Session is invalid!\");\n                destroySession(hazelcastSession, true);\n                hazelcastSession = null;\n            }\n            if (hazelcastSession == null) {\n                HttpSession originalSession = getOriginalSession(false);\n                if (originalSession != null) {\n                    String hazelcastSessionId = mapOriginalSessions.get(originalSession.getId());\n                    if (hazelcastSessionId != null) {\n                        hazelcastSession = mapSessions.get(hazelcastSessionId);\n                    }\n                    if (hazelcastSession == null) {\n                        mapOriginalSessions.remove(originalSession.getId());\n                        originalSession.invalidate();\n                    }\n                }\n            }\n            if (hazelcastSession != null)\n                return hazelcastSession;\n            final String requestedSessionId = fetchHazelcastSessionId();\n            if (requestedSessionId != null) {\n                hazelcastSession = getSessionWithId(requestedSessionId);\n                if (hazelcastSession == null) {\n                    final Boolean existing = (Boolean) getClusterMap().get(requestedSessionId);\n                    if (existing != null && existing) {\n                        // we already have the session in the cluster loading it...\n                        hazelcastSession = createNewSession(RequestWrapper.this, requestedSessionId);\n                    }\n                }\n            }\n            if (hazelcastSession == null && create) {\n                hazelcastSession = createNewSession(RequestWrapper.this, null);\n            }\n            if (deferredWrite) {\n                prepareReloadingSession(hazelcastSession);\n            }\n            return hazelcastSession;\n        }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void doFilter(ServletRequest req, ServletResponse res, final FilterChain chain)\n            throws IOException, ServletException {\n        if (!(req instanceof HttpServletRequest)) {\n            chain.doFilter(req, res);\n        } else {\n            if (req instanceof RequestWrapper) {\n                log(\"Request is instance of RequestWrapper! Continue...\");\n                chain.doFilter(req, res);\n                return;\n            }\n            HttpServletRequest httpReq = (HttpServletRequest) req;\n            RequestWrapper existingReq = (RequestWrapper) req.getAttribute(HAZELCAST_REQUEST);\n            final ResponseWrapper resWrapper = new ResponseWrapper((HttpServletResponse) res);\n            final RequestWrapper reqWrapper = new RequestWrapper(httpReq, resWrapper);\n            if (existingReq != null) {\n                reqWrapper.setHazelcastSession(existingReq.hazelcastSession, existingReq.requestedSessionId);\n            }\n            chain.doFilter(reqWrapper, resWrapper);\n            if (existingReq != null) return;\n            HazelcastHttpSession session = reqWrapper.getSession(false);\n            if (session != null && session.isValid()) {\n                if (session.sessionChanged() || !deferredWrite) {\n                    log(\"PUTTING SESSION \" + session.getId());\n                    session.sessionDeferredWrite();\n                }\n            }\n        }\n    }","id":86406,"modified_method":"public final void doFilter(ServletRequest req, ServletResponse res, final FilterChain chain)\n            throws IOException, ServletException {\n        if (!(req instanceof HttpServletRequest)) {\n            chain.doFilter(req, res);\n        } else {\n            if (req instanceof RequestWrapper) {\n                logger.finest(\"Request is instance of RequestWrapper! Continue...\");\n                chain.doFilter(req, res);\n                return;\n            }\n            HttpServletRequest httpReq = (HttpServletRequest) req;\n            RequestWrapper existingReq = (RequestWrapper) req.getAttribute(HAZELCAST_REQUEST);\n            final ResponseWrapper resWrapper = new ResponseWrapper((HttpServletResponse) res);\n            final RequestWrapper reqWrapper = new RequestWrapper(httpReq, resWrapper);\n            if (existingReq != null) {\n                reqWrapper.setHazelcastSession(existingReq.hazelcastSession, existingReq.requestedSessionId);\n            }\n            chain.doFilter(reqWrapper, resWrapper);\n            if (existingReq != null) return;\n            HazelcastHttpSession session = reqWrapper.getSession(false);\n            if (session != null && session.isValid()) {\n                if (session.sessionChanged() || !deferredWrite) {\n                    if(logger.isFinestEnabled()){\n                        logger.finest(\"PUTTING SESSION \" + session.getId());\n                    }\n                    session.sessionDeferredWrite();\n                }\n            }\n        }\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void init(final FilterConfig config) throws ServletException {\n        filterConfig = config;\n        servletContext = config.getServletContext();\n        initInstance();\n        String debugParam = getParam(\"debug\");\n        if (debugParam != null) {\n            debug = Boolean.valueOf(debugParam);\n        }\n        String mapName = getParam(\"map-name\");\n        if (mapName != null) {\n            clusterMapName = mapName;\n        } else {\n            clusterMapName = \"_web_\" + servletContext.getServletContextName();\n        }\n        try {\n            Config hzConfig = hazelcastInstance.getConfig();\n            String sessionTTL = getParam(\"session-ttl-seconds\");\n            if (sessionTTL != null) {\n                MapConfig mapConfig = hzConfig.getMapConfig(clusterMapName);\n                mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));\n                hzConfig.addMapConfig(mapConfig);\n            }\n        } catch (UnsupportedOperationException ignored) {\n            // client cannot access Config.\n        }\n        String cookieName = getParam(\"cookie-name\");\n        if (cookieName != null) {\n            sessionCookieName = cookieName;\n        }\n        String cookieDomain = getParam(\"cookie-domain\");\n        if (cookieDomain != null) {\n            sessionCookieDomain = cookieDomain;\n        }\n        String cookieSecure = getParam(\"cookie-secure\");\n        if (cookieSecure != null) {\n            sessionCookieSecure = Boolean.valueOf(cookieSecure);\n        }\n        String cookieHttpOnly = getParam(\"cookie-http-only\");\n        if (cookieHttpOnly != null) {\n            sessionCookieHttpOnly = Boolean.valueOf(cookieHttpOnly);\n        }\n        String stickySessionParam = getParam(\"sticky-session\");\n        if (stickySessionParam != null) {\n            stickySession = Boolean.valueOf(stickySessionParam);\n        }\n        String shutdownOnDestroyParam = getParam(\"shutdown-on-destroy\");\n        if (shutdownOnDestroyParam != null) {\n            shutdownOnDestroy = Boolean.valueOf(shutdownOnDestroyParam);\n        }\n        String deferredWriteParam = getParam(\"deferred-write\");\n        if (deferredWriteParam != null) {\n            deferredWrite = Boolean.parseBoolean(deferredWriteParam);\n        }\n        if (!stickySession) {\n            getClusterMap().addEntryListener(new EntryListener<String, Object>() {\n                public void entryAdded(EntryEvent<String, Object> entryEvent) {\n                }\n\n                public void entryRemoved(EntryEvent<String, Object> entryEvent) {\n                    if (entryEvent.getMember() == null || // client events has no owner member\n                            !entryEvent.getMember().localMember()) {\n                        removeSessionLocally((String) entryEvent.getKey());\n                    }\n                }\n\n                public void entryUpdated(EntryEvent<String, Object> entryEvent) {\n                }\n\n                public void entryEvicted(EntryEvent<String, Object> entryEvent) {\n                    entryRemoved(entryEvent);\n                }\n            }, false);\n        }\n        log(\"sticky:\" + stickySession + \", debug: \" + debug + \", shutdown-on-destroy: \" + shutdownOnDestroy\n                + \", map-name: \" + clusterMapName);\n    }","id":86407,"modified_method":"public final void init(final FilterConfig config) throws ServletException {\n        filterConfig = config;\n        servletContext = config.getServletContext();\n        initInstance();\n        String mapName = getParam(\"map-name\");\n        if (mapName != null) {\n            clusterMapName = mapName;\n        } else {\n            clusterMapName = \"_web_\" + servletContext.getServletContextName();\n        }\n        try {\n            Config hzConfig = hazelcastInstance.getConfig();\n            String sessionTTL = getParam(\"session-ttl-seconds\");\n            if (sessionTTL != null) {\n                MapConfig mapConfig = hzConfig.getMapConfig(clusterMapName);\n                mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));\n                hzConfig.addMapConfig(mapConfig);\n            }\n        } catch (UnsupportedOperationException ignored) {\n            // client cannot access Config.\n        }\n        String cookieName = getParam(\"cookie-name\");\n        if (cookieName != null) {\n            sessionCookieName = cookieName;\n        }\n        String cookieDomain = getParam(\"cookie-domain\");\n        if (cookieDomain != null) {\n            sessionCookieDomain = cookieDomain;\n        }\n        String cookieSecure = getParam(\"cookie-secure\");\n        if (cookieSecure != null) {\n            sessionCookieSecure = Boolean.valueOf(cookieSecure);\n        }\n        String cookieHttpOnly = getParam(\"cookie-http-only\");\n        if (cookieHttpOnly != null) {\n            sessionCookieHttpOnly = Boolean.valueOf(cookieHttpOnly);\n        }\n        String stickySessionParam = getParam(\"sticky-session\");\n        if (stickySessionParam != null) {\n            stickySession = Boolean.valueOf(stickySessionParam);\n        }\n        String shutdownOnDestroyParam = getParam(\"shutdown-on-destroy\");\n        if (shutdownOnDestroyParam != null) {\n            shutdownOnDestroy = Boolean.valueOf(shutdownOnDestroyParam);\n        }\n        String deferredWriteParam = getParam(\"deferred-write\");\n        if (deferredWriteParam != null) {\n            deferredWrite = Boolean.parseBoolean(deferredWriteParam);\n        }\n        if (!stickySession) {\n            getClusterMap().addEntryListener(new EntryListener<String, Object>() {\n                public void entryAdded(EntryEvent<String, Object> entryEvent) {\n                }\n\n                public void entryRemoved(EntryEvent<String, Object> entryEvent) {\n                    if (entryEvent.getMember() == null || // client events has no owner member\n                            !entryEvent.getMember().localMember()) {\n                        removeSessionLocally(entryEvent.getKey());\n                    }\n                }\n\n                public void entryUpdated(EntryEvent<String, Object> entryEvent) {\n                }\n\n                public void entryEvicted(EntryEvent<String, Object> entryEvent) {\n                    entryRemoved(entryEvent);\n                }\n            }, false);\n        }\n\n        if(logger.isLoggable(Level.FINEST)){\n            logger.finest(\"sticky:\" + stickySession + \", shutdown-on-destroy: \" + shutdownOnDestroy\n                    + \", map-name: \" + clusterMapName);\n        }\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Destroys a session, determining if it should be destroyed clusterwide automatically or via expiry.\n     *\n     * @param session             The session to be destroyed\n     * @param removeGlobalSession boolean value - true if the session should be destroyed irrespective of active time\n     */\n    private void destroySession(HazelcastHttpSession session, boolean removeGlobalSession) {\n        log(\"Destroying local session: \" + session.getId());\n        mapSessions.remove(session.getId());\n        mapOriginalSessions.remove(session.originalSession.getId());\n        session.destroy();\n        if (removeGlobalSession) {\n            log(\"Destroying cluster session: \" + session.getId() + \" => Ignore-timeout: true\");\n            IMap<String, Object> clusterMap = getClusterMap();\n            clusterMap.delete(session.getId());\n            clusterMap.executeOnEntries(new InvalidateEntryProcessor(session.getId()));\n        }\n    }","id":86408,"modified_method":"/**\n     * Destroys a session, determining if it should be destroyed clusterwide automatically or via expiry.\n     *\n     * @param session             The session to be destroyed\n     * @param removeGlobalSession boolean value - true if the session should be destroyed irrespective of active time\n     */\n    private void destroySession(HazelcastHttpSession session, boolean removeGlobalSession) {\n        if(logger.isFinestEnabled()){\n            logger.finest(\"Destroying local session: \" + session.getId());\n        }\n        mapSessions.remove(session.getId());\n        mapOriginalSessions.remove(session.originalSession.getId());\n        session.destroy();\n        if (removeGlobalSession) {\n            if(logger.isFinestEnabled()){\n                logger.finest(\"Destroying cluster session: \" + session.getId() + \" => Ignore-timeout: true\");\n            }\n            IMap<String, Object> clusterMap = getClusterMap();\n            clusterMap.delete(session.getId());\n            clusterMap.executeOnEntries(new InvalidateEntryProcessor(session.getId()));\n        }\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void loadHazelcastSession(HazelcastHttpSession hazelcastSession) {\n        Set<Entry<String, Object>> entrySet = getClusterMap().entrySet(new SessionAttributePredicate(hazelcastSession.getId()));\n        Map<String, LocalCacheEntry> cache = hazelcastSession.localCache;\n        for (Entry<String, Object> entry : entrySet) {\n            String attributeKey = extractAttributeKey(entry.getKey());\n            LocalCacheEntry cacheEntry = cache.get(attributeKey);\n            if (cacheEntry == null) {\n                cacheEntry = new LocalCacheEntry();\n                cache.put(attributeKey, cacheEntry);\n            }\n            log(\"Storing \" + attributeKey + \" on session \" + hazelcastSession.getId());\n            cacheEntry.value = entry.getValue();\n            cacheEntry.dirty = false;\n        }\n    }","id":86409,"modified_method":"private void loadHazelcastSession(HazelcastHttpSession hazelcastSession) {\n        Set<Entry<String, Object>> entrySet = getClusterMap().entrySet(new SessionAttributePredicate(hazelcastSession.getId()));\n        Map<String, LocalCacheEntry> cache = hazelcastSession.localCache;\n        for (Entry<String, Object> entry : entrySet) {\n            String attributeKey = extractAttributeKey(entry.getKey());\n            LocalCacheEntry cacheEntry = cache.get(attributeKey);\n            if (cacheEntry == null) {\n                cacheEntry = new LocalCacheEntry();\n                cache.put(attributeKey, cacheEntry);\n            }\n            if(logger.isFinestEnabled()){\n                logger.finest(\"Storing \" + attributeKey + \" on session \" + hazelcastSession.getId());\n            }\n            cacheEntry.value = entry.getValue();\n            cacheEntry.dirty = false;\n        }\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void removeSessionLocally(String sessionId) {\n        HazelcastHttpSession hazelSession = mapSessions.remove(sessionId);\n        if (hazelSession != null) {\n            mapOriginalSessions.remove(hazelSession.originalSession.getId());\n            log(\"Destroying session locally \" + hazelSession);\n            hazelSession.destroy();\n        }\n    }","id":86410,"modified_method":"private void removeSessionLocally(String sessionId) {\n        HazelcastHttpSession hazelSession = mapSessions.remove(sessionId);\n        if (hazelSession != null) {\n            mapOriginalSessions.remove(hazelSession.originalSession.getId());\n            if(logger.isLoggable(Level.FINEST)){\n                logger.finest(\"Destroying session locally \" + hazelSession);\n            }\n            hazelSession.destroy();\n        }\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private HazelcastHttpSession createNewSession(RequestWrapper requestWrapper, String existingSessionId) {\n        String id = existingSessionId != null ? existingSessionId : generateSessionId();\n        if (requestWrapper.getOriginalSession(false) != null) {\n            log(\"Original session exists!!!\");\n        }\n        HttpSession originalSession = requestWrapper.getOriginalSession(true);\n        HazelcastHttpSession hazelcastSession = new HazelcastHttpSession(WebFilter.this, id, originalSession, deferredWrite);\n        mapSessions.put(hazelcastSession.getId(), hazelcastSession);\n        String oldHazelcastSessionId = mapOriginalSessions.put(originalSession.getId(), hazelcastSession.getId());\n        if (oldHazelcastSessionId != null) {\n            log(\"!!! Overriding an existing hazelcastSessionId \" + oldHazelcastSessionId);\n        }\n        log(\"Created new session with id: \" + id);\n        log(mapSessions.size() + \" is sessions.size and originalSessions.size: \" + mapOriginalSessions.size());\n        addSessionCookie(requestWrapper, id);\n        if (deferredWrite) {\n            loadHazelcastSession(hazelcastSession);\n        }\n        return hazelcastSession;\n    }","id":86411,"modified_method":"private HazelcastHttpSession createNewSession(RequestWrapper requestWrapper, String existingSessionId) {\n        String id = existingSessionId != null ? existingSessionId : generateSessionId();\n        if (requestWrapper.getOriginalSession(false) != null) {\n            logger.finest(\"Original session exists!!!\");\n        }\n        HttpSession originalSession = requestWrapper.getOriginalSession(true);\n        HazelcastHttpSession hazelcastSession = new HazelcastHttpSession(WebFilter.this, id, originalSession, deferredWrite);\n        mapSessions.put(hazelcastSession.getId(), hazelcastSession);\n        String oldHazelcastSessionId = mapOriginalSessions.put(originalSession.getId(), hazelcastSession.getId());\n        if (oldHazelcastSessionId != null) {\n            if(logger.isFinestEnabled()){\n                logger.finest(\"!!! Overriding an existing hazelcastSessionId \" + oldHazelcastSessionId);\n            }\n        }\n        if(logger.isFinestEnabled()){\n            logger.finest(\"Created new session with id: \" + id);\n            logger.finest(mapSessions.size() + \" is sessions.size and originalSessions.size: \" + mapOriginalSessions.size());\n        }\n        addSessionCookie(requestWrapper, id);\n        if (deferredWrite) {\n            loadHazelcastSession(hazelcastSession);\n        }\n        return hazelcastSession;\n    }","commit_id":"cfb4388955c9e727b7ee310de8d4463bcbd70259","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void advance(long totalJob, long elapsedJob) {\n      double fraction = ((double) elapsedJob) / ((double) totalJob);\n      if (fraction > 1) {\n        fraction = 1;\n      }\n      if (myProgress != null) {\n        myProgress.setFraction(fraction);\n      }\n      myGenerationController.setText2(myGenerationController.getText2(), myTotalJob, myStartJobTime);\n    }","id":86412,"modified_method":"private void advance(long totalJob, long elapsedJob) {\n      double fraction = ((double) elapsedJob) / ((double) totalJob);\n      if (fraction > 1) {\n        fraction = 1;\n      }\n      myProgress.setFraction(fraction);\n      myGenerationController.setText2(myGenerationController.getText2(), myTotalJob, myStartJobTime);\n    }","commit_id":"8742452a667a8e9d1a0286ba10dba75acf82fdd6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void update(AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    e.getPresentation().setEnabled(project != null);\n  }","id":86413,"modified_method":"public void update(AnActionEvent e) {\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    e.getPresentation().setEnabled(project != null);\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project != null) {\n      MavenArtifactDownloader.download(project);\n    }\n  }","id":86414,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    Project project = e.getData(PlatformDataKeys.PROJECT);\n    try {\n      MavenArtifactDownloader.download(project);\n    }\n    catch (CanceledException ex) {\n    }\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void download(final Project project) {\n    final MavenProjectsState projectsState = project.getComponent(MavenProjectsState.class);\n    final MavenImporter importer = project.getComponent(MavenImporter.class);\n\n    final Map<MavenProject, Collection<String>> mavenProjects = new HashMap<MavenProject, Collection<String>>();\n\n    for (VirtualFile file : projectsState.getFiles()) {\n      if (!projectsState.isIgnored(file)) {\n        MavenProject mavenProject = projectsState.getMavenProject(file);\n        if (mavenProject != null) {\n          mavenProjects.put(mavenProject, projectsState.getProfiles(file));\n        }\n      }\n    }\n\n    final Map<MavenProject, Module> projectsToModules = new HashMap<MavenProject, Module>();\n\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      VirtualFile pomFile = importer.findPomForModule(module);\n      if (pomFile != null && !projectsState.isIgnored(pomFile)) {\n        MavenProject mavenProject = projectsState.getMavenProject(pomFile);\n        if (mavenProject != null) {\n          projectsToModules.put(mavenProject, module);\n        }\n      }\n    }\n\n    try {\n      final MavenEmbedder mavenEmbedder = project.getComponent(MavenCore.class).getState().createEmbedder();\n\n      ProgressManager.getInstance().run(new Task.Modal(project, ProjectBundle.message(\"maven.title.downloading\"), true) {\n        public void run(ProgressIndicator indicator) {\n          Collection<MavenId> moduleIds = new ArrayList<MavenId>();\n          for (MavenProject mavenProject : projectsToModules.keySet()) {\n            moduleIds.add(new MavenId(mavenProject.getArtifact()));\n          }\n          new MavenArtifactDownloader(importer.getArtifactPreferences(), mavenEmbedder, indicator)\n            .download(project, mavenProjects, moduleIds, true);\n        }\n      });\n\n      MavenEnv.releaseEmbedder(mavenEmbedder);\n    }\n    catch (MavenException e) {\n      LOG.info(\"Maven Embedder initialization failed: \" + e.getMessage());\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        for (Map.Entry<MavenProject, Module> entry : projectsToModules.entrySet()) {\n          MavenToIdeaConverter.updateModel(entry.getValue(), entry.getKey());\n        }\n      }\n    });\n\n    VirtualFileManager.getInstance().refresh(false);\n  }","id":86415,"modified_method":"public static void download(final Project project) throws CanceledException {\n    final MavenProjectsState projectsState = project.getComponent(MavenProjectsState.class);\n    final MavenImporter importer = project.getComponent(MavenImporter.class);\n\n    final Map<MavenProject, Collection<String>> mavenProjects = new HashMap<MavenProject, Collection<String>>();\n\n    for (VirtualFile file : projectsState.getFiles()) {\n      if (!projectsState.isIgnored(file)) {\n        MavenProject mavenProject = projectsState.getMavenProject(file);\n        if (mavenProject != null) {\n          mavenProjects.put(mavenProject, projectsState.getProfiles(file));\n        }\n      }\n    }\n\n    final Map<MavenProject, Module> projectsToModules = new HashMap<MavenProject, Module>();\n\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      VirtualFile pomFile = importer.findPomForModule(module);\n      if (pomFile != null && !projectsState.isIgnored(pomFile)) {\n        MavenProject mavenProject = projectsState.getMavenProject(pomFile);\n        if (mavenProject != null) {\n          projectsToModules.put(mavenProject, module);\n        }\n      }\n    }\n\n    try {\n      final MavenEmbedder mavenEmbedder = project.getComponent(MavenCore.class).getState().createEmbedder();\n\n      try {\n        Progress.run(project, ProjectBundle.message(\"maven.title.downloading\"), new Progress.Process() {\n          public void run(Progress p) throws MavenException, CanceledException {\n            Collection<MavenId> moduleIds = new ArrayList<MavenId>();\n            for (MavenProject mavenProject : projectsToModules.keySet()) {\n              moduleIds.add(new MavenId(mavenProject.getArtifact()));\n            }\n            new MavenArtifactDownloader(importer.getArtifactPreferences(), mavenEmbedder, p)\n              .download(project, mavenProjects, moduleIds, true);\n          }\n        });\n      } finally {\n        MavenEnv.releaseEmbedder(mavenEmbedder);\n      }\n    }\n    catch (MavenException e) {\n      LOG.info(\"Maven Embedder initialization failed: \" + e.getMessage());\n    }\n\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        for (Map.Entry<MavenProject, Module> entry : projectsToModules.entrySet()) {\n          MavenToIdeaConverter.updateModel(entry.getValue(), entry.getKey());\n        }\n      }\n    });\n\n    VirtualFileManager.getInstance().refresh(false);\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MavenArtifactDownloader(MavenArtifactPreferences preferences, MavenEmbedder embedder, ProgressIndicator progressIndicator) {\n    myPreferences = preferences;\n    myEmbedder = embedder;\n    myProgressIndicator = progressIndicator;\n  }","id":86416,"modified_method":"public MavenArtifactDownloader(MavenArtifactPreferences preferences, MavenEmbedder embedder, Progress p) {\n    myPreferences = preferences;\n    myEmbedder = embedder;\n    myProgress = p;\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static Map<MavenId, Set<ArtifactRepository>> collectLibraryArtifacts(MavenProjectsState projectsState,\n                                                                       Collection<MavenProject> mavenProjects,\n                                                                       Collection<MavenId> mappedToModules) {\n    final Map<MavenId, Set<ArtifactRepository>> repositoryArtifacts = new TreeMap<MavenId, Set<ArtifactRepository>>();\n\n    for (MavenProject mavenProject : mavenProjects) {\n      VirtualFile file = projectsState.getFile(mavenProject);\n      if (file != null) {\n        Collection<Artifact> artifacts = projectsState.getArtifacts(file);\n        if (artifacts != null) {\n          final List remoteRepositories = mavenProject.getRemoteArtifactRepositories();\n          for (Artifact artifact : artifacts) {\n            if (artifact.getType().equalsIgnoreCase(MavenToIdeaConverter.JAR_TYPE) &&\n                !artifact.getScope().equalsIgnoreCase(Artifact.SCOPE_SYSTEM)) {\n              MavenId id = new MavenId(artifact);\n              if (!mappedToModules.contains(id)) {\n                Set<ArtifactRepository> repos = repositoryArtifacts.get(id);\n                if (repos == null) {\n                  repos = new HashSet<ArtifactRepository>();\n                  repositoryArtifacts.put(id, repos);\n                }\n                //noinspection unchecked\n                repos.addAll(remoteRepositories);\n              }\n            }\n          }\n        }\n      }\n    }\n    return repositoryArtifacts;\n  }","id":86417,"modified_method":"private static Map<MavenId, Set<ArtifactRepository>> collectLibraryArtifacts(MavenProjectsState projectsState,\n                                                                       Collection<MavenProject> mavenProjects,\n                                                                       Collection<MavenId> mappedToModules) {\n    final Map<MavenId, Set<ArtifactRepository>> repositoryArtifacts = new TreeMap<MavenId, Set<ArtifactRepository>>();\n\n    for (MavenProject mavenProject : mavenProjects) {\n      VirtualFile file = projectsState.getFile(mavenProject);\n      if (file != null) {\n        Collection<Artifact> artifacts = projectsState.getArtifacts(file);\n        if (artifacts != null) {\n          final List remoteRepositories = mavenProject.getRemoteArtifactRepositories();\n          for (Artifact artifact : artifacts) {\n            if (artifact.getType().equalsIgnoreCase(MavenToIdeaConverter.JAR_TYPE) &&\n                !artifact.getScope().equalsIgnoreCase(Artifact.SCOPE_SYSTEM)) {\n              MavenId id = new MavenId(artifact);\n              if (!mappedToModules.contains(id)) {\n                Set<ArtifactRepository> repos = repositoryArtifacts.get(id);\n                if (repos == null) {\n                  repos = new HashSet<ArtifactRepository>();\n                  repositoryArtifacts.put(id, repos);\n                }\n                //noinspection unchecked\n                repos.addAll(remoteRepositories);\n              }\n            }\n          }\n        }\n      }\n    }\n    return repositoryArtifacts;\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void downloadPlugins(final Map<Plugin, MavenProject> plugins) {\n    if (myProgressIndicator != null) myProgressIndicator.setText(ProjectBundle.message(\"maven.progress.downloading\", \"plugins\"));\n\n    int step = 0;\n\n    for (Map.Entry<Plugin, MavenProject> entry : plugins.entrySet()) {\n      final Plugin plugin = entry.getKey();\n      if (myProgressIndicator != null){\n        myProgressIndicator.setFraction(((double)step++) / plugins.size());\n        if (myProgressIndicator.isCanceled()) {\n          return;\n        }\n        myProgressIndicator.setText2(plugin.getKey());\n      }\n      MavenEmbedderAdapter.verifyPlugin(plugin, entry.getValue(), myEmbedder);\n    }\n  }","id":86418,"modified_method":"private void downloadPlugins(final Map<Plugin, MavenProject> plugins) throws CanceledException {\n    myProgress.setText(ProjectBundle.message(\"maven.progress.downloading\", \"plugins\"));\n\n    int step = 0;\n\n    for (Map.Entry<Plugin, MavenProject> entry : plugins.entrySet()) {\n      final Plugin plugin = entry.getKey();\n\n      myProgress.check();\n      myProgress.setFraction(((double)step++) / plugins.size());\n      myProgress.setText2(plugin.getKey());\n\n      MavenEmbedderAdapter.verifyPlugin(plugin, entry.getValue(), myEmbedder);\n    }\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void download(final Map<MavenId, Set<ArtifactRepository>> libraryArtifacts, final String classifier) {\n    if (myProgressIndicator != null) myProgressIndicator.setText(ProjectBundle.message(\"maven.progress.downloading\", classifier));\n    int step = 0;\n    for (Map.Entry<MavenId, Set<ArtifactRepository>> entry : libraryArtifacts.entrySet()) {\n      if (myProgressIndicator != null && myProgressIndicator.isCanceled()) return;\n      final MavenId id = entry.getKey();\n      if (myProgressIndicator != null) {\n        myProgressIndicator.setFraction(((double)step++) / libraryArtifacts.size());\n        myProgressIndicator.setText2(id.toString());\n      }\n      try {\n        myEmbedder.resolve(\n          myEmbedder.createArtifactWithClassifier(id.groupId, id.artifactId, id.version, MavenToIdeaConverter.JAR_TYPE, classifier),\n          new ArrayList<ArtifactRepository>(entry.getValue()), myEmbedder.getLocalRepository());\n      }\n      catch (ArtifactResolutionException ignore) {\n      }\n      catch (ArtifactNotFoundException ignore) {\n      }\n      catch (Exception e) {\n        LOG.warn(\"Exception during artifact resolution\", e);\n      }\n    }\n  }","id":86419,"modified_method":"private void download(final Map<MavenId, Set<ArtifactRepository>> libraryArtifacts, final String classifier) throws CanceledException {\n    myProgress.setText(ProjectBundle.message(\"maven.progress.downloading\", classifier));\n    int step = 0;\n    for (Map.Entry<MavenId, Set<ArtifactRepository>> entry : libraryArtifacts.entrySet()) {\n      myProgress.check();\n\n      final MavenId id = entry.getKey();\n\n      myProgress.setFraction(((double)step++) / libraryArtifacts.size());\n      myProgress.setText2(id.toString());\n\n      try {\n        Artifact a = myEmbedder.createArtifactWithClassifier(id.groupId,\n                                                             id.artifactId,\n                                                             id.version,\n                                                             MavenToIdeaConverter.JAR_TYPE,\n                                                             classifier);\n        List<ArtifactRepository> remoteRepos = new ArrayList<ArtifactRepository>(entry.getValue());\n        myEmbedder.resolve(a, remoteRepos, myEmbedder.getLocalRepository());\n      }\n      catch (ArtifactResolutionException ignore) {\n      }\n      catch (ArtifactNotFoundException ignore) {\n      }\n      catch (Exception e) {\n        LOG.warn(\"Exception during artifact resolution\", e);\n      }\n    }\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void download(Project project,\n                Map<MavenProject, Collection<String>> mavenProjects,\n                Collection<MavenId> mappedToModules,\n                boolean demand) {\n    final MavenProjectsState projectsState = project.getComponent(MavenProjectsState.class);\n    final Map<MavenId, Set<ArtifactRepository>> libraryArtifacts = collectLibraryArtifacts(projectsState, mavenProjects.keySet(), mappedToModules);\n\n    if (myProgressIndicator != null && myProgressIndicator.isCanceled()) return;\n\n    if (isEnabled(myPreferences.getDownloadSources(), demand)) {\n      download(libraryArtifacts, MavenToIdeaConverter.SOURCES_CLASSIFIER);\n    }\n\n    if (myProgressIndicator != null && myProgressIndicator.isCanceled()) return;\n\n    if (isEnabled(myPreferences.getDownloadJavadoc(), demand)) {\n      download(libraryArtifacts, MavenToIdeaConverter.JAVADOC_CLASSIFIER);\n    }\n\n    if (myProgressIndicator != null && myProgressIndicator.isCanceled()) return;\n\n    if (isEnabled(myPreferences.getDownloadPlugins(), demand)) {\n      final Map<Plugin, MavenProject> plugins = ProjectUtil.collectPlugins(mavenProjects);\n      collectAttachedPlugins(projectsState, plugins);\n      downloadPlugins(plugins);\n      projectsState.updateAllFiles();\n    }\n\n    if (myProgressIndicator != null && myProgressIndicator.isCanceled()) return;\n\n    if (isEnabled(myPreferences.getGenerateSources(), demand)) {\n      generateSources(project, createGenerateCommand(mavenProjects));\n    }\n  }","id":86420,"modified_method":"public void download(Project project,\n                Map<MavenProject, Collection<String>> mavenProjects,\n                Collection<MavenId> mappedToModules,\n                boolean demand) throws CanceledException {\n    final MavenProjectsState projectsState = project.getComponent(MavenProjectsState.class);\n    final Map<MavenId, Set<ArtifactRepository>> libraryArtifacts = collectLibraryArtifacts(projectsState, mavenProjects.keySet(), mappedToModules);\n\n    myProgress.check();\n\n    if (isEnabled(myPreferences.getDownloadSources(), demand)) {\n      download(libraryArtifacts, MavenToIdeaConverter.SOURCES_CLASSIFIER);\n    }\n\n    myProgress.check();\n\n    if (isEnabled(myPreferences.getDownloadJavadoc(), demand)) {\n      download(libraryArtifacts, MavenToIdeaConverter.JAVADOC_CLASSIFIER);\n    }\n\n    myProgress.check();\n\n    if (isEnabled(myPreferences.getDownloadPlugins(), demand)) {\n      final Map<Plugin, MavenProject> plugins = ProjectUtil.collectPlugins(mavenProjects);\n      collectAttachedPlugins(projectsState, plugins);\n      downloadPlugins(plugins);\n      projectsState.updateAllFiles();\n    }\n\n    myProgress.check();\n\n    if (isEnabled(myPreferences.getGenerateSources(), demand)) {\n      generateSources(project, createGenerateCommand(mavenProjects));\n    }\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean runConfigurationProcess(String message, Progress.Process p) throws ConfigurationException {\n    try {\n      new Progress().run(null, message, p);\n    }\n    catch (MavenException e) {\n      throw new ConfigurationException(e.getMessage());\n    }\n    catch (CanceledException e) {\n      return false;\n    }\n\n    return true;\n  }","id":86421,"modified_method":"private boolean runConfigurationProcess(String message, Progress.Process p) throws ConfigurationException {\n    try {\n      Progress.run(null, message, p);\n    }\n    catch (MavenException e) {\n      throw new ConfigurationException(e.getMessage());\n    }\n    catch (CanceledException e) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run(Project p, String title, final Process t) throws MavenException, CanceledException {\n    final MavenException[] mavenEx = new MavenException[1];\n    final CanceledException[] canceledEx = new CanceledException[1];\n\n    ProgressManager.getInstance().run(new Task.Modal(p, title, true) {\n      public void run(ProgressIndicator i) {\n        try {\n          t.run(Progress.this);\n        }\n        catch (MavenException e) {\n          mavenEx[0] = e;\n        }\n        catch (CanceledException e) {\n          canceledEx[0] = e;\n        }\n      }\n    });\n\n    if (mavenEx[0] != null) throw mavenEx[0];\n    if (canceledEx[0] != null) throw canceledEx[0];\n  }","id":86422,"modified_method":"public static void run(Project project, String title, final Process t) throws MavenException, CanceledException {\n    final MavenException[] mavenEx = new MavenException[1];\n    final CanceledException[] canceledEx = new CanceledException[1];\n\n    ProgressManager.getInstance().run(new Task.Modal(project, title, true) {\n      public void run(ProgressIndicator i) {\n        Progress progress = new Progress();\n        try {\n          t.run(progress);\n        }\n        catch (MavenException e) {\n          mavenEx[0] = e;\n        }\n        catch (CanceledException e) {\n          canceledEx[0] = e;\n        }\n      }\n    });\n\n    if (mavenEx[0] != null) throw mavenEx[0];\n    if (canceledEx[0] != null) throw canceledEx[0];\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project != null) {\n      try {\n        new MavenImportProcessor(project).synchronize(true);\n      }\n      catch (MavenException e1) {\n        // TODO temporary catch block\n        throw new RuntimeException(e1);\n      }\n      catch (CanceledException e1) {\n      }\n    }\n  }","id":86423,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project != null) {\n      try {\n        new MavenImportProcessor(project).synchronize(true);\n      }\n      catch (MavenException ex) {\n        // TODO temporary catch block\n        throw new RuntimeException(ex);\n      }\n      catch (CanceledException ex) {\n      }\n    }\n  }","commit_id":"c156957d319fe0226ea23215998a00e0c9c42896","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void infer(final EObject entity, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    if (entity instanceof Entity) {\n      _infer((Entity)entity, acceptor, prelinkingPhase);\n    } else if (entity != null) {\n      _infer(entity, acceptor, prelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(entity, acceptor, prelinkingPhase).toString());\n    }\n  }","id":86424,"modified_method":"public void infer(final EObject entity, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    if (entity instanceof Entity) {\n      _infer((Entity)entity, acceptor, prelinkingPhase);\n      return;\n    } else if (entity != null) {\n      _infer(entity, acceptor, prelinkingPhase);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(entity, acceptor, prelinkingPhase).toString());\n    }\n  }","commit_id":"84f49419d72e0818318277bc86c8a6b24de18875","url":"https://github.com/eclipse/xtext"},{"original_method":"public void toJavaLiteral(final JvmAnnotationValue it, final ITreeAppendable appendable) {\n    if (it instanceof JvmAnnotationAnnotationValue) {\n      _toJavaLiteral((JvmAnnotationAnnotationValue)it, appendable);\n    } else if (it instanceof JvmBooleanAnnotationValue) {\n      _toJavaLiteral((JvmBooleanAnnotationValue)it, appendable);\n    } else if (it instanceof JvmByteAnnotationValue) {\n      _toJavaLiteral((JvmByteAnnotationValue)it, appendable);\n    } else if (it instanceof JvmCharAnnotationValue) {\n      _toJavaLiteral((JvmCharAnnotationValue)it, appendable);\n    } else if (it instanceof JvmCustomAnnotationValue) {\n      _toJavaLiteral((JvmCustomAnnotationValue)it, appendable);\n    } else if (it instanceof JvmDoubleAnnotationValue) {\n      _toJavaLiteral((JvmDoubleAnnotationValue)it, appendable);\n    } else if (it instanceof JvmEnumAnnotationValue) {\n      _toJavaLiteral((JvmEnumAnnotationValue)it, appendable);\n    } else if (it instanceof JvmFloatAnnotationValue) {\n      _toJavaLiteral((JvmFloatAnnotationValue)it, appendable);\n    } else if (it instanceof JvmIntAnnotationValue) {\n      _toJavaLiteral((JvmIntAnnotationValue)it, appendable);\n    } else if (it instanceof JvmLongAnnotationValue) {\n      _toJavaLiteral((JvmLongAnnotationValue)it, appendable);\n    } else if (it instanceof JvmShortAnnotationValue) {\n      _toJavaLiteral((JvmShortAnnotationValue)it, appendable);\n    } else if (it instanceof JvmStringAnnotationValue) {\n      _toJavaLiteral((JvmStringAnnotationValue)it, appendable);\n    } else if (it instanceof JvmTypeAnnotationValue) {\n      _toJavaLiteral((JvmTypeAnnotationValue)it, appendable);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(it, appendable).toString());\n    }\n  }","id":86425,"modified_method":"public void toJavaLiteral(final JvmAnnotationValue it, final ITreeAppendable appendable) {\n    if (it instanceof JvmAnnotationAnnotationValue) {\n      _toJavaLiteral((JvmAnnotationAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmBooleanAnnotationValue) {\n      _toJavaLiteral((JvmBooleanAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmByteAnnotationValue) {\n      _toJavaLiteral((JvmByteAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmCharAnnotationValue) {\n      _toJavaLiteral((JvmCharAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmCustomAnnotationValue) {\n      _toJavaLiteral((JvmCustomAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmDoubleAnnotationValue) {\n      _toJavaLiteral((JvmDoubleAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmEnumAnnotationValue) {\n      _toJavaLiteral((JvmEnumAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmFloatAnnotationValue) {\n      _toJavaLiteral((JvmFloatAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmIntAnnotationValue) {\n      _toJavaLiteral((JvmIntAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmLongAnnotationValue) {\n      _toJavaLiteral((JvmLongAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmShortAnnotationValue) {\n      _toJavaLiteral((JvmShortAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmStringAnnotationValue) {\n      _toJavaLiteral((JvmStringAnnotationValue)it, appendable);\n      return;\n    } else if (it instanceof JvmTypeAnnotationValue) {\n      _toJavaLiteral((JvmTypeAnnotationValue)it, appendable);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(it, appendable).toString());\n    }\n  }","commit_id":"84f49419d72e0818318277bc86c8a6b24de18875","url":"https://github.com/eclipse/xtext"},{"original_method":"public void internalDoGenerate(final EObject type, final IFileSystemAccess fsa) {\n    if (type instanceof JvmEnumerationType) {\n      _internalDoGenerate((JvmEnumerationType)type, fsa);\n    } else if (type instanceof JvmGenericType) {\n      _internalDoGenerate((JvmGenericType)type, fsa);\n    } else if (type != null) {\n      _internalDoGenerate(type, fsa);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(type, fsa).toString());\n    }\n  }","id":86426,"modified_method":"public void internalDoGenerate(final EObject type, final IFileSystemAccess fsa) {\n    if (type instanceof JvmEnumerationType) {\n      _internalDoGenerate((JvmEnumerationType)type, fsa);\n      return;\n    } else if (type instanceof JvmGenericType) {\n      _internalDoGenerate((JvmGenericType)type, fsa);\n      return;\n    } else if (type != null) {\n      _internalDoGenerate(type, fsa);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(type, fsa).toString());\n    }\n  }","commit_id":"84f49419d72e0818318277bc86c8a6b24de18875","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testEnumeration() {\n    try {\n      final XExpression expression = this.expression(\"null\", false);\n      final Procedure1<JvmEnumerationType> _function = new Procedure1<JvmEnumerationType>() {\n          public void apply(final JvmEnumerationType it) {\n            EList<JvmMember> _members = it.getMembers();\n            JvmEnumerationLiteral _enumerationLiteral = JvmModelGeneratorTest.this.builder.toEnumerationLiteral(expression, \"BAR\");\n            JvmModelGeneratorTest.this.builder.<JvmEnumerationLiteral>operator_add(_members, _enumerationLiteral);\n            EList<JvmMember> _members_1 = it.getMembers();\n            JvmEnumerationLiteral _enumerationLiteral_1 = JvmModelGeneratorTest.this.builder.toEnumerationLiteral(expression, \"BAZ\");\n            JvmModelGeneratorTest.this.builder.<JvmEnumerationLiteral>operator_add(_members_1, _enumerationLiteral_1);\n          }\n        };\n      final JvmEnumerationType enumeration = this.builder.toEnumerationType(expression, \"my.test.Foo\", _function);\n      Resource _eResource = expression.eResource();\n      final Class<?> compiled = this.compile(_eResource, enumeration);\n      final Method valuesMethod = compiled.getMethod(\"values\");\n      Object _invoke = valuesMethod.invoke(null);\n      final Object[] values = ((Object[]) _invoke);\n      final Object[] _converted_values = (Object[])values;\n      Object _get = ((List<Object>)Conversions.doWrapArray(_converted_values)).get(0);\n      String _string = _get.toString();\n      Assert.assertEquals(\"BAR\", _string);\n      final Object[] _converted_values_1 = (Object[])values;\n      Object _get_1 = ((List<Object>)Conversions.doWrapArray(_converted_values_1)).get(1);\n      String _string_1 = _get_1.toString();\n      Assert.assertEquals(\"BAZ\", _string_1);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":86427,"modified_method":"@Test\n  public void testEnumeration() {\n    try {\n      final XExpression expression = this.expression(\"null\", false);\n      final Procedure1<JvmEnumerationType> _function = new Procedure1<JvmEnumerationType>() {\n          public void apply(final JvmEnumerationType it) {\n            EList<JvmMember> _members = it.getMembers();\n            JvmEnumerationLiteral _enumerationLiteral = JvmModelGeneratorTest.this.builder.toEnumerationLiteral(expression, \"BAR\");\n            JvmModelGeneratorTest.this.builder.<JvmEnumerationLiteral>operator_add(_members, _enumerationLiteral);\n            EList<JvmMember> _members_1 = it.getMembers();\n            JvmEnumerationLiteral _enumerationLiteral_1 = JvmModelGeneratorTest.this.builder.toEnumerationLiteral(expression, \"BAZ\");\n            JvmModelGeneratorTest.this.builder.<JvmEnumerationLiteral>operator_add(_members_1, _enumerationLiteral_1);\n          }\n        };\n      final JvmEnumerationType enumeration = this.builder.toEnumerationType(expression, \"my.test.Foo\", _function);\n      Resource _eResource = expression.eResource();\n      final Class<?> compiled = this.compile(_eResource, enumeration);\n      final Method valuesMethod = compiled.getMethod(\"values\");\n      Object _invoke = valuesMethod.invoke(null);\n      final Object[] values = ((Object[]) _invoke);\n      Object _get = ((List<Object>)Conversions.doWrapArray(values)).get(0);\n      String _string = _get.toString();\n      Assert.assertEquals(\"BAR\", _string);\n      Object _get_1 = ((List<Object>)Conversions.doWrapArray(values)).get(1);\n      String _string_1 = _get_1.toString();\n      Assert.assertEquals(\"BAZ\", _string_1);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"84f49419d72e0818318277bc86c8a6b24de18875","url":"https://github.com/eclipse/xtext"},{"original_method":"public void infer(final EObject m, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    if (m instanceof Model) {\n      _infer((Model)m, acceptor, prelinkingPhase);\n    } else if (m != null) {\n      _infer(m, acceptor, prelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(m, acceptor, prelinkingPhase).toString());\n    }\n  }","id":86428,"modified_method":"public void infer(final EObject m, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    if (m instanceof Model) {\n      _infer((Model)m, acceptor, prelinkingPhase);\n      return;\n    } else if (m != null) {\n      _infer(m, acceptor, prelinkingPhase);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(m, acceptor, prelinkingPhase).toString());\n    }\n  }","commit_id":"84f49419d72e0818318277bc86c8a6b24de18875","url":"https://github.com/eclipse/xtext"},{"original_method":"public void infer(final EObject element, final Object acceptor, final boolean isPrelinkingPhase) {\n    if (element instanceof DomainModelTutorial\n         && acceptor instanceof IAcceptor) {\n      _infer((DomainModelTutorial)element, (IAcceptor<JvmDeclaredType>)acceptor, isPrelinkingPhase);\n    } else if (element != null\n         && acceptor instanceof IJvmDeclaredTypeAcceptor) {\n      _infer(element, (IJvmDeclaredTypeAcceptor)acceptor, isPrelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(element, acceptor, isPrelinkingPhase).toString());\n    }\n  }","id":86429,"modified_method":"public void infer(final EObject element, final Object acceptor, final boolean isPrelinkingPhase) {\n    if (element instanceof DomainModelTutorial\n         && acceptor instanceof IAcceptor) {\n      _infer((DomainModelTutorial)element, (IAcceptor<JvmDeclaredType>)acceptor, isPrelinkingPhase);\n      return;\n    } else if (element != null\n         && acceptor instanceof IJvmDeclaredTypeAcceptor) {\n      _infer(element, (IJvmDeclaredTypeAcceptor)acceptor, isPrelinkingPhase);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(element, acceptor, isPrelinkingPhase).toString());\n    }\n  }","commit_id":"84f49419d72e0818318277bc86c8a6b24de18875","url":"https://github.com/eclipse/xtext"},{"original_method":"protected CharSequence internalToHtmlParagraph(final Object it) {\n    CharSequence _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (it instanceof TextOrMarkup) {\n        final TextOrMarkup _textOrMarkup = (TextOrMarkup)it;\n        _matched=true;\n        EList<EObject> _contents = _textOrMarkup.getContents();\n        CharSequence _internalToHtmlParagraph = this.internalToHtmlParagraph(_contents);\n        _switchResult = _internalToHtmlParagraph;\n      }\n    }\n    if (!_matched) {\n      if (it instanceof List) {\n        final List<EObject> _list = (List<EObject>)it;\n        _matched=true;\n        final Function1<EObject,CharSequence> _function = new Function1<EObject,CharSequence>() {\n            public CharSequence apply(final EObject it) {\n              CharSequence _internalToHtmlParagraph = HtmlExtensions.this.internalToHtmlParagraph(it);\n              return _internalToHtmlParagraph;\n            }\n          };\n        List<CharSequence> _map = ListExtensions.<EObject, CharSequence>map(_list, _function);\n        String _join = IterableExtensions.join(_map);\n        _switchResult = _join;\n      }\n    }\n    if (!_matched) {\n      if (it instanceof TextPart) {\n        final TextPart _textPart = (TextPart)it;\n        _matched=true;\n        String _xblockexpression = null;\n        {\n          String _text = _textPart.getText();\n          String _quote = this.quote(_text);\n          final String[] paragraphs = _quote.split(\"^\\\\s*$\");\n          final String[] _converted_paragraphs = (String[])paragraphs;\n          final Function1<String,Boolean> _function = new Function1<String,Boolean>() {\n              public Boolean apply(final String it) {\n                boolean _isEmpty = it.isEmpty();\n                boolean _not = (!_isEmpty);\n                return Boolean.valueOf(_not);\n              }\n            };\n          Iterable<String> _filter = IterableExtensions.<String>filter(((Iterable<String>)Conversions.doWrapArray(_converted_paragraphs)), _function);\n          StringConcatenation _builder = new StringConcatenation();\n          _builder.append(\"<\/p>\");\n          _builder.newLine();\n          _builder.append(\"<p>\");\n          _builder.newLine();\n          String _join = IterableExtensions.join(_filter, _builder);\n          _xblockexpression = (_join);\n        }\n        _switchResult = _xblockexpression;\n      }\n    }\n    if (!_matched) {\n      if (it instanceof CodeBlock) {\n        final CodeBlock _codeBlock = (CodeBlock)it;\n        _matched=true;\n        CharSequence _internalToHtml = this.internalToHtml(_codeBlock, true);\n        _switchResult = _internalToHtml;\n      }\n    }\n    if (!_matched) {\n      CharSequence _html = this.toHtml(it);\n      _switchResult = _html;\n    }\n    return _switchResult;\n  }","id":86430,"modified_method":"protected CharSequence internalToHtmlParagraph(final Object it) {\n    CharSequence _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (it instanceof TextOrMarkup) {\n        final TextOrMarkup _textOrMarkup = (TextOrMarkup)it;\n        _matched=true;\n        EList<EObject> _contents = _textOrMarkup.getContents();\n        CharSequence _internalToHtmlParagraph = this.internalToHtmlParagraph(_contents);\n        _switchResult = _internalToHtmlParagraph;\n      }\n    }\n    if (!_matched) {\n      if (it instanceof List) {\n        final List<EObject> _list = (List<EObject>)it;\n        _matched=true;\n        final Function1<EObject,CharSequence> _function = new Function1<EObject,CharSequence>() {\n            public CharSequence apply(final EObject it) {\n              CharSequence _internalToHtmlParagraph = HtmlExtensions.this.internalToHtmlParagraph(it);\n              return _internalToHtmlParagraph;\n            }\n          };\n        List<CharSequence> _map = ListExtensions.<EObject, CharSequence>map(_list, _function);\n        String _join = IterableExtensions.join(_map);\n        _switchResult = _join;\n      }\n    }\n    if (!_matched) {\n      if (it instanceof TextPart) {\n        final TextPart _textPart = (TextPart)it;\n        _matched=true;\n        String _xblockexpression = null;\n        {\n          String _text = _textPart.getText();\n          String _quote = this.quote(_text);\n          final String[] paragraphs = _quote.split(\"^\\\\s*$\");\n          final Function1<String,Boolean> _function = new Function1<String,Boolean>() {\n              public Boolean apply(final String it) {\n                boolean _isEmpty = it.isEmpty();\n                boolean _not = (!_isEmpty);\n                return Boolean.valueOf(_not);\n              }\n            };\n          Iterable<String> _filter = IterableExtensions.<String>filter(((Iterable<String>)Conversions.doWrapArray(paragraphs)), _function);\n          StringConcatenation _builder = new StringConcatenation();\n          _builder.append(\"<\/p>\");\n          _builder.newLine();\n          _builder.append(\"<p>\");\n          _builder.newLine();\n          String _join = IterableExtensions.join(_filter, _builder);\n          _xblockexpression = (_join);\n        }\n        _switchResult = _xblockexpression;\n      }\n    }\n    if (!_matched) {\n      if (it instanceof CodeBlock) {\n        final CodeBlock _codeBlock = (CodeBlock)it;\n        _matched=true;\n        CharSequence _internalToHtml = this.internalToHtml(_codeBlock, true);\n        _switchResult = _internalToHtml;\n      }\n    }\n    if (!_matched) {\n      CharSequence _html = this.toHtml(it);\n      _switchResult = _html;\n    }\n    return _switchResult;\n  }","commit_id":"f1a9329cf5ab32bd5772c3c1f0d3e612802ff470","url":"https://github.com/eclipse/xtext"},{"original_method":"public void assertLineNumbers(final CharSequence xtendCodeWithLineNumbers) {\n    final AbstractTraceRegion region = this.getTraceRegion(xtendCodeWithLineNumbers);\n    final LinkedHashSet<LineMapping> lineMappings = CollectionLiterals.<LineMapping>newLinkedHashSet();\n    this.smapSupport.createSmapInfo(region, lineMappings);\n    final List<LineMapping> normalizedMappings = this.smapSupport.normalizeLineInfo(lineMappings);\n    String _string = xtendCodeWithLineNumbers.toString();\n    final String[] lines = _string.split(\"\\n\");\n    final String[] _converted_lines = (String[])lines;\n    int _size = ((List<String>)Conversions.doWrapArray(_converted_lines)).size();\n    int _minus = (_size - 1);\n    Iterable<Integer> _upTo = IntegerExtensions.upTo(0, _minus);\n    for (final Integer lineNumber : _upTo) {\n      {\n        final LineMapping mapping = this.findMapping(normalizedMappings, lineNumber);\n        final String[] _converted_lines_1 = (String[])lines;\n        final String line = ((List<String>)Conversions.doWrapArray(_converted_lines_1)).get((lineNumber).intValue());\n        boolean _notEquals = (!Objects.equal(mapping, null));\n        if (_notEquals) {\n          int _indexOf = line.indexOf(\"//\");\n          int _minus_1 = (-1);\n          boolean _equals = (_indexOf == _minus_1);\n          if (_equals) {\n            StringConcatenation _builder = new StringConcatenation();\n            _builder.append(\"Line \");\n            _builder.append(lineNumber, \"\");\n            _builder.append(\" is mapped to \");\n            _builder.append(mapping.targetStartLine, \"\");\n            _builder.append(\"(\\'\");\n            _builder.append(line, \"\");\n            _builder.append(\"\\')\");\n            String _string_1 = _builder.toString();\n            Assert.fail(_string_1);\n          }\n          int _indexOf_1 = line.indexOf(\"//\");\n          int _plus = (_indexOf_1 + 2);\n          String _substring = line.substring(_plus);\n          final String expectation = _substring.trim();\n          int expTargetStart = (-1);\n          int expTargetEnd = (-1);\n          int _indexOf_2 = expectation.indexOf(\"..\");\n          int _minus_2 = (-1);\n          boolean _notEquals_1 = (_indexOf_2 != _minus_2);\n          if (_notEquals_1) {\n            final int idx = expectation.indexOf(\"..\");\n            String _substring_1 = expectation.substring(0, idx);\n            int _parseInt = Integer.parseInt(_substring_1);\n            expTargetStart = _parseInt;\n            int _plus_1 = (idx + 2);\n            String _substring_2 = expectation.substring(_plus_1);\n            int _parseInt_1 = Integer.parseInt(_substring_2);\n            expTargetEnd = _parseInt_1;\n          } else {\n            int _parseInt_2 = Integer.parseInt(expectation);\n            int _expTargetEnd = expTargetEnd = _parseInt_2;\n            expTargetStart = _expTargetEnd;\n          }\n          Assert.assertEquals(line, expTargetStart, mapping.targetStartLine);\n          String _plus_2 = (\"unexpected end in line : \" + line);\n          Assert.assertEquals(_plus_2, expTargetEnd, mapping.targetEndLine);\n        } else {\n          int _indexOf_3 = line.indexOf(\"//\");\n          int _minus_3 = (-1);\n          boolean _notEquals_2 = (_indexOf_3 != _minus_3);\n          if (_notEquals_2) {\n            String _plus_3 = (\"Unmatched expectation : \" + line);\n            Assert.fail(_plus_3);\n          }\n        }\n      }\n    }\n  }","id":86431,"modified_method":"public void assertLineNumbers(final CharSequence xtendCodeWithLineNumbers) {\n    final AbstractTraceRegion region = this.getTraceRegion(xtendCodeWithLineNumbers);\n    final LinkedHashSet<LineMapping> lineMappings = CollectionLiterals.<LineMapping>newLinkedHashSet();\n    this.smapSupport.createSmapInfo(region, lineMappings);\n    final List<LineMapping> normalizedMappings = this.smapSupport.normalizeLineInfo(lineMappings);\n    String _string = xtendCodeWithLineNumbers.toString();\n    final String[] lines = _string.split(\"\\n\");\n    int _size = ((List<String>)Conversions.doWrapArray(lines)).size();\n    int _minus = (_size - 1);\n    Iterable<Integer> _upTo = IntegerExtensions.upTo(0, _minus);\n    for (final Integer lineNumber : _upTo) {\n      {\n        final LineMapping mapping = this.findMapping(normalizedMappings, lineNumber);\n        final String line = ((List<String>)Conversions.doWrapArray(lines)).get((lineNumber).intValue());\n        boolean _notEquals = (!Objects.equal(mapping, null));\n        if (_notEquals) {\n          int _indexOf = line.indexOf(\"//\");\n          int _minus_1 = (-1);\n          boolean _equals = (_indexOf == _minus_1);\n          if (_equals) {\n            StringConcatenation _builder = new StringConcatenation();\n            _builder.append(\"Line \");\n            _builder.append(lineNumber, \"\");\n            _builder.append(\" is mapped to \");\n            _builder.append(mapping.targetStartLine, \"\");\n            _builder.append(\"(\\'\");\n            _builder.append(line, \"\");\n            _builder.append(\"\\')\");\n            String _string_1 = _builder.toString();\n            Assert.fail(_string_1);\n          }\n          int _indexOf_1 = line.indexOf(\"//\");\n          int _plus = (_indexOf_1 + 2);\n          String _substring = line.substring(_plus);\n          final String expectation = _substring.trim();\n          int expTargetStart = (-1);\n          int expTargetEnd = (-1);\n          int _indexOf_2 = expectation.indexOf(\"..\");\n          int _minus_2 = (-1);\n          boolean _notEquals_1 = (_indexOf_2 != _minus_2);\n          if (_notEquals_1) {\n            final int idx = expectation.indexOf(\"..\");\n            String _substring_1 = expectation.substring(0, idx);\n            int _parseInt = Integer.parseInt(_substring_1);\n            expTargetStart = _parseInt;\n            int _plus_1 = (idx + 2);\n            String _substring_2 = expectation.substring(_plus_1);\n            int _parseInt_1 = Integer.parseInt(_substring_2);\n            expTargetEnd = _parseInt_1;\n          } else {\n            int _parseInt_2 = Integer.parseInt(expectation);\n            int _expTargetEnd = expTargetEnd = _parseInt_2;\n            expTargetStart = _expTargetEnd;\n          }\n          Assert.assertEquals(line, expTargetStart, mapping.targetStartLine);\n          String _plus_2 = (\"unexpected end in line : \" + line);\n          Assert.assertEquals(_plus_2, expTargetEnd, mapping.targetEndLine);\n        } else {\n          int _indexOf_3 = line.indexOf(\"//\");\n          int _minus_3 = (-1);\n          boolean _notEquals_2 = (_indexOf_3 != _minus_3);\n          if (_notEquals_2) {\n            String _plus_3 = (\"Unmatched expectation : \" + line);\n            Assert.fail(_plus_3);\n          }\n        }\n      }\n    }\n  }","commit_id":"f1a9329cf5ab32bd5772c3c1f0d3e612802ff470","url":"https://github.com/eclipse/xtext"},{"original_method":"public SourceSetOutput getClasses() {\n        DeprecationLogger.nagUserOfReplacedMethod(\"sourceSet.classes\", \"sourceSet.output\");\n        return getOutput();\n    }","id":86432,"modified_method":"public SourceSetOutput getClasses() {\n        DeprecationLogger.nagUserOfReplacedMethod(\"SourceSet.getClasses()\", \"getOutput()\");\n        return getOutput();\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"public File getClassesDir() {\n        DeprecationLogger.nagUserOfReplacedMethod(\"sourceSet.classesDir\", \"sourceSet.output.classesDir\");\n        return output.getClassesDir();\n    }","id":86433,"modified_method":"public File getClassesDir() {\n        DeprecationLogger.nagUserOfReplacedMethod(\"SourceSet.getClassesDir()\", \"getOutput().getClassesDir()\");\n        return output.getClassesDir();\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"public void setClassesDir(File classesDir) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"sourceSet.classesDir\", \"sourceSet.output.classesDir\");\n        this.output.setClassesDir(classesDir);\n    }","id":86434,"modified_method":"public void setClassesDir(File classesDir) {\n        DeprecationLogger.nagUserOfReplacedMethod(\"SourceSet.setClassesDir()\", \"getOutput().setClassesDir()\");\n        this.output.setClassesDir(classesDir);\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultSourceSet(String name, FileResolver fileResolver, TaskResolver taskResolver) {\n        this.name = name;\n        displayName = GUtil.toWords(this.name);\n\n        String javaSrcDisplayName = String.format(\"%s Java source\", displayName);\n\n        javaSource = new DefaultSourceDirectorySet(javaSrcDisplayName, fileResolver);\n        javaSource.getFilter().include(\"**/*.java\");\n\n        allJavaSource = new DefaultSourceDirectorySet(javaSrcDisplayName, fileResolver);\n        allJavaSource.getFilter().include(\"**/*.java\");\n        allJavaSource.source(javaSource);\n\n        String resourcesDisplayName = String.format(\"%s resources\", displayName);\n        resources = new DefaultSourceDirectorySet(resourcesDisplayName, fileResolver);\n        resources.getFilter().exclude(new Spec<FileTreeElement>() {\n            public boolean isSatisfiedBy(FileTreeElement element) {\n                return javaSource.contains(element.getFile());\n            }\n        });\n\n        String allSourceDisplayName = String.format(\"%s source\", displayName);\n        allSource = new DefaultSourceDirectorySet(allSourceDisplayName, fileResolver);\n        allSource.source(resources);\n        allSource.source(javaSource);\n    }","id":86435,"modified_method":"public DefaultSourceSet(String name, FileResolver fileResolver) {\n        this.name = name;\n        displayName = GUtil.toWords(this.name);\n\n        String javaSrcDisplayName = String.format(\"%s Java source\", displayName);\n\n        javaSource = new DefaultSourceDirectorySet(javaSrcDisplayName, fileResolver);\n        javaSource.getFilter().include(\"**/*.java\");\n\n        allJavaSource = new DefaultSourceDirectorySet(javaSrcDisplayName, fileResolver);\n        allJavaSource.getFilter().include(\"**/*.java\");\n        allJavaSource.source(javaSource);\n\n        String resourcesDisplayName = String.format(\"%s resources\", displayName);\n        resources = new DefaultSourceDirectorySet(resourcesDisplayName, fileResolver);\n        resources.getFilter().exclude(new Spec<FileTreeElement>() {\n            public boolean isSatisfiedBy(FileTreeElement element) {\n                return javaSource.contains(element.getFile());\n            }\n        });\n\n        String allSourceDisplayName = String.format(\"%s source\", displayName);\n        allSource = new DefaultSourceDirectorySet(allSourceDisplayName, fileResolver);\n        allSource.source(resources);\n        allSource.source(javaSource);\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected SourceSet doCreate(String name) {\n        DefaultSourceSet sourceSet = instantiator.newInstance(DefaultSourceSet.class, name, fileResolver, taskResolver);\n        sourceSet.setClasses(instantiator.newInstance(DefaultSourceSetOutput.class, sourceSet.getDisplayName(), fileResolver, taskResolver));\n\n        return sourceSet;\n    }","id":86436,"modified_method":"@Override\n    protected SourceSet doCreate(String name) {\n        DefaultSourceSet sourceSet = instantiator.newInstance(DefaultSourceSet.class, name, fileResolver);\n        sourceSet.setClasses(instantiator.newInstance(DefaultSourceSetOutput.class, sourceSet.getDisplayName(), fileResolver, taskResolver));\n\n        return sourceSet;\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureSourceSetDefaults(final JavaPluginConvention pluginConvention) {\n        pluginConvention.getSourceSets().all(new Action<SourceSet>() {\n            public void execute(final SourceSet sourceSet) {\n                final Project project = pluginConvention.getProject();\n\n                ConventionMapping outputConventionMapping = ((IConventionAware) sourceSet.getOutput()).getConventionMapping();\n\n                outputConventionMapping.map(\"classesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        String classesDirName = String.format(\"classes/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n                outputConventionMapping.map(\"resourcesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        String classesDirName = String.format(\"resources/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n\n                sourceSet.getJava().srcDir(String.format(\"src/%s/java\", sourceSet.getName()));\n                sourceSet.getResources().srcDir(String.format(\"src/%s/resources\", sourceSet.getName()));\n\n                Copy processResources = project.getTasks().add(sourceSet.getProcessResourcesTaskName(), ProcessResources.class);\n                processResources.setDescription(String.format(\"Processes the %s.\", sourceSet.getResources()));\n                ConventionMapping conventionMapping = processResources.getConventionMapping();\n                conventionMapping.map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getResources();\n                    }\n                });\n                conventionMapping.map(\"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getOutput().getResourcesDir();\n                    }\n                });\n\n                String compileTaskName = sourceSet.getCompileJavaTaskName();\n                Compile compileJava = project.getTasks().add(compileTaskName, Compile.class);\n                configureForSourceSet(sourceSet, compileJava);\n\n                Task classes = project.getTasks().add(sourceSet.getClassesTaskName());\n                classes.dependsOn(sourceSet.getProcessResourcesTaskName(), compileTaskName);\n                classes.setDescription(String.format(\"Assembles the %s classes.\", sourceSet.getName()));\n                classes.setGroup(BasePlugin.BUILD_GROUP);\n                classes.dependsOn(sourceSet.getOutput().getDirs());\n\n                sourceSet.compiledBy(sourceSet.getClassesTaskName());\n            }\n        });\n    }","id":86437,"modified_method":"private void configureSourceSetDefaults(final JavaPluginConvention pluginConvention) {\n        pluginConvention.getSourceSets().all(new Action<SourceSet>() {\n            public void execute(final SourceSet sourceSet) {\n                final Project project = pluginConvention.getProject();\n\n                ConventionMapping outputConventionMapping = ((IConventionAware) sourceSet.getOutput()).getConventionMapping();\n\n                ConfigurationContainer configurations = project.getConfigurations();\n                Configuration compileConfiguration = configurations.add(sourceSet.getCompileConfigurationName()).setVisible(false).\n                        setDescription(String.format(\"Classpath for compiling the %s sources.\", sourceSet.getName()));\n                Configuration runtimeConfiguration = configurations.add(sourceSet.getRuntimeConfigurationName()).setVisible(false)\n                        .extendsFrom(compileConfiguration).\n                                setDescription(String.format(\"Classpath for running the compiled %s classes.\", sourceSet.getName()));\n\n                sourceSet.setCompileClasspath(compileConfiguration);\n                sourceSet.setRuntimeClasspath(sourceSet.getOutput().plus(runtimeConfiguration));\n\n                outputConventionMapping.map(\"classesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        String classesDirName = String.format(\"classes/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n                outputConventionMapping.map(\"resourcesDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        String classesDirName = String.format(\"resources/%s\", sourceSet.getName());\n                        return new File(project.getBuildDir(), classesDirName);\n                    }\n                });\n\n                sourceSet.getJava().srcDir(String.format(\"src/%s/java\", sourceSet.getName()));\n                sourceSet.getResources().srcDir(String.format(\"src/%s/resources\", sourceSet.getName()));\n\n                Copy processResources = project.getTasks().add(sourceSet.getProcessResourcesTaskName(), ProcessResources.class);\n                processResources.setDescription(String.format(\"Processes the %s.\", sourceSet.getResources()));\n                ConventionMapping conventionMapping = processResources.getConventionMapping();\n                conventionMapping.map(\"defaultSource\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getResources();\n                    }\n                });\n                conventionMapping.map(\"destinationDir\", new ConventionValue() {\n                    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {\n                        return sourceSet.getOutput().getResourcesDir();\n                    }\n                });\n\n                String compileTaskName = sourceSet.getCompileJavaTaskName();\n                Compile compileJava = project.getTasks().add(compileTaskName, Compile.class);\n                configureForSourceSet(sourceSet, compileJava);\n\n                Task classes = project.getTasks().add(sourceSet.getClassesTaskName());\n                classes.dependsOn(sourceSet.getProcessResourcesTaskName(), compileTaskName);\n                classes.setDescription(String.format(\"Assembles the %s classes.\", sourceSet.getName()));\n                classes.setGroup(BasePlugin.BUILD_GROUP);\n                classes.dependsOn(sourceSet.getOutput().getDirs());\n\n                sourceSet.compiledBy(sourceSet.getClassesTaskName());\n            }\n        });\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"void configureConfigurations(final Project project) {\n        ConfigurationContainer configurations = project.getConfigurations();\n        Configuration compileConfiguration = configurations.add(COMPILE_CONFIGURATION_NAME).setVisible(false).\n                setDescription(\"Classpath for compiling the sources.\");\n        Configuration runtimeConfiguration = configurations.add(RUNTIME_CONFIGURATION_NAME).setVisible(false)\n                .extendsFrom(compileConfiguration).\n                        setDescription(\"Classpath for running the compiled sources.\");\n\n        Configuration compileTestsConfiguration = configurations.add(TEST_COMPILE_CONFIGURATION_NAME).setVisible(false)\n                .extendsFrom(compileConfiguration).setDescription(\"Classpath for compiling the test sources.\");\n\n        configurations.add(TEST_RUNTIME_CONFIGURATION_NAME).setVisible(false).extendsFrom(runtimeConfiguration,\n                compileTestsConfiguration).\n                setDescription(\"Classpath for running the test sources.\");\n\n        configurations.getByName(Dependency.DEFAULT_CONFIGURATION).extendsFrom(runtimeConfiguration);\n    }","id":86438,"modified_method":"void configureConfigurations(Project project) {\n        ConfigurationContainer configurations = project.getConfigurations();\n        Configuration compileConfiguration = configurations.getByName(COMPILE_CONFIGURATION_NAME);\n        Configuration runtimeConfiguration = configurations.getByName(RUNTIME_CONFIGURATION_NAME);\n\n        Configuration compileTestsConfiguration = configurations.getByName(TEST_COMPILE_CONFIGURATION_NAME);\n        compileTestsConfiguration.extendsFrom(compileConfiguration);\n\n        configurations.getByName(TEST_RUNTIME_CONFIGURATION_NAME).extendsFrom(runtimeConfiguration, compileTestsConfiguration);\n\n        configurations.getByName(Dependency.DEFAULT_CONFIGURATION).extendsFrom(runtimeConfiguration);\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"private void configureSourceSets(final JavaPluginConvention pluginConvention) {\n        final Project project = pluginConvention.getProject();\n\n        pluginConvention.getSourceSets().all(new Action<SourceSet>() {\n            public void execute(SourceSet sourceSet) {\n                sourceSet.setCompileClasspath(project.getConfigurations().getByName(COMPILE_CONFIGURATION_NAME));\n                sourceSet.setRuntimeClasspath(sourceSet.getOutput().plus(project.getConfigurations().getByName(\n                        RUNTIME_CONFIGURATION_NAME)));\n            }\n        });\n        SourceSet main = pluginConvention.getSourceSets().add(SourceSet.MAIN_SOURCE_SET_NAME);\n\n        SourceSet test = pluginConvention.getSourceSets().add(SourceSet.TEST_SOURCE_SET_NAME);\n        test.setCompileClasspath(project.files(main.getOutput(), project.getConfigurations().getByName(\n                TEST_COMPILE_CONFIGURATION_NAME)));\n        test.setRuntimeClasspath(project.files(test.getOutput(), main.getOutput(),\n                project.getConfigurations().getByName(TEST_RUNTIME_CONFIGURATION_NAME)));\n    }","id":86439,"modified_method":"private void configureSourceSets(final JavaPluginConvention pluginConvention) {\n        final Project project = pluginConvention.getProject();\n\n        SourceSet main = pluginConvention.getSourceSets().add(SourceSet.MAIN_SOURCE_SET_NAME);\n\n        SourceSet test = pluginConvention.getSourceSets().add(SourceSet.TEST_SOURCE_SET_NAME);\n        test.setCompileClasspath(project.files(main.getOutput(), project.getConfigurations().getByName(TEST_COMPILE_CONFIGURATION_NAME)));\n        test.setRuntimeClasspath(project.files(test.getOutput(), main.getOutput(), project.getConfigurations().getByName(TEST_RUNTIME_CONFIGURATION_NAME)));\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        project.getPlugins().apply(JavaBasePlugin.class);\n\n        JavaPluginConvention javaConvention = (JavaPluginConvention) project.getConvention().getPlugins().get(\"java\");\n        project.getConvention().getPlugins().put(\"embeddedJavaProject\", new EmbeddableJavaProjectImpl(javaConvention));\n\n        configureConfigurations(project);\n\n        configureSourceSets(javaConvention);\n\n        configureJavaDoc(javaConvention);\n        configureTest(project, javaConvention);\n        configureArchives(project, javaConvention);\n        configureBuild(project);\n    }","id":86440,"modified_method":"public void apply(Project project) {\n        project.getPlugins().apply(JavaBasePlugin.class);\n\n        JavaPluginConvention javaConvention = project.getConvention().getPlugin(JavaPluginConvention.class);\n        project.getConvention().getPlugins().put(\"embeddedJavaProject\", new EmbeddableJavaProjectImpl(javaConvention));\n\n        configureSourceSets(javaConvention);\n        configureConfigurations(project);\n\n        configureJavaDoc(javaConvention);\n        configureTest(project, javaConvention);\n        configureArchives(project, javaConvention);\n        configureBuild(project);\n    }","commit_id":"6e06be29b078e1cf9e686157e8d57518a1b5e1ca","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mServer.getServer().getConnectors()[0].getHost();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","id":86441,"modified_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mAddress.getHostString();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","commit_id":"b8095179fdc77139efef800396514da66e9abb04","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Starts the web server.\n   */\n  public void startWebServer() {\n    try {\n      mServer.getConnectors()[0].close();\n      mServer.getConnectors()[0].open();\n      mServer.start();\n      if (mAddress.getPort() == 0) {\n        int webPort = mServer.getConnectors()[0].getLocalPort();\n        mAddress = new InetSocketAddress(mAddress.getHostName(), webPort);\n        // reset web service port\n        mConfiguration.set(mService.getPortKey(), Integer.toString(webPort));\n      }\n      LOG.info(\"{} started @ {}\", mService.getServiceName(), mAddress);\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":86442,"modified_method":"/**\n   * Starts the web server.\n   */\n  public void startWebServer() {\n    try {\n      if (mAddress.getPort() == 0) {\n        int webPort = mAddress.getPort();\n        mAddress = new InetSocketAddress(mAddress.getHostName(), webPort);\n        // reset web service port\n        mConfiguration.set(mService.getPortKey(), Integer.toString(webPort));\n      }\n      mServer.start();\n      while (!mServer.isStarted()) {\n        Thread.sleep(10);\n      }\n      LOG.info(\"{} started @ {}\", mService.getServiceName(), mAddress);\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"b8095179fdc77139efef800396514da66e9abb04","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mServer.getServer().getConnectors()[0].getLocalPort();\n  }","id":86443,"modified_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mAddress.getPort();\n  }","commit_id":"b8095179fdc77139efef800396514da66e9abb04","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   * @param conf Alluxio configuration\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address, Configuration conf) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n    Preconditions.checkNotNull(conf, \"Configuration cannot be null\");\n\n    mAddress = address;\n    mService = service;\n    mConfiguration = conf;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = mConfiguration.getInt(Constants.WEB_THREAD_COUNT);\n\n    mServer = new Server();\n    SelectChannelConnector connector = new SelectChannelConnector();\n    connector.setHost(address.getHostName());\n    connector.setPort(address.getPort());\n    connector.setAcceptors(webThreadCount);\n    mServer.setConnectors(new Connector[] {connector});\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n    mServer.setThreadPool(threadPool);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(mConfiguration.get(Constants.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","id":86444,"modified_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   * @param conf Alluxio configuration\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address, Configuration conf) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n    Preconditions.checkNotNull(conf, \"Configuration cannot be null\");\n\n    mAddress = address;\n    mService = service;\n    mConfiguration = conf;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = mConfiguration.getInt(Constants.WEB_THREAD_COUNT);\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n\n    mServer = new Server(threadPool);\n\n    ServerConnector serverConnector = new ServerConnector(mServer);\n    serverConnector.setPort(mAddress.getPort());\n    serverConnector.setHost(mAddress.getAddress().getHostAddress());\n\n    mServer.addConnector(serverConnector);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(mConfiguration.get(Constants.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","commit_id":"b8095179fdc77139efef800396514da66e9abb04","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.close();\n    }\n\n    mServer.stop();\n  }","id":86445,"modified_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.stop();\n    }\n\n    mServer.stop();\n  }","commit_id":"b8095179fdc77139efef800396514da66e9abb04","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mServer.getServer().getConnectors()[0].getHost();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","id":86446,"modified_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mAddress.getHostString();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","commit_id":"5e902035ec28ad9c0cf6a4c307072eb50c6ab979","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mServer.getServer().getConnectors()[0].getLocalPort();\n  }","id":86447,"modified_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mAddress.getPort();\n  }","commit_id":"5e902035ec28ad9c0cf6a4c307072eb50c6ab979","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Starts the web server.\n   */\n  public void startWebServer() {\n    try {\n      mServer.getConnectors()[0].close();\n      mServer.getConnectors()[0].open();\n      mServer.start();\n      if (mAddress.getPort() == 0) {\n        int webPort = mServer.getConnectors()[0].getLocalPort();\n        mAddress = new InetSocketAddress(mAddress.getHostName(), webPort);\n        // reset web service port\n        mConfiguration.set(mService.getPortKey(), Integer.toString(webPort));\n      }\n      LOG.info(\"{} started @ {}\", mService.getServiceName(), mAddress);\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":86448,"modified_method":"/**\n   * Starts the web server.\n   */\n  public void startWebServer() {\n    try {\n      if (mAddress.getPort() == 0) {\n        int webPort = mAddress.getPort();\n        mAddress = new InetSocketAddress(mAddress.getHostName(), webPort);\n        // reset web service port\n        mConfiguration.set(mService.getPortKey(), Integer.toString(webPort));\n      }\n      mServer.start();\n      while (!mServer.isStarted()) {\n        Thread.sleep(10);\n      }\n      LOG.info(\"{} started @ {}\", mService.getServiceName(), mAddress);\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"5e902035ec28ad9c0cf6a4c307072eb50c6ab979","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   * @param conf Alluxio configuration\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address, Configuration conf) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n    Preconditions.checkNotNull(conf, \"Configuration cannot be null\");\n\n    mAddress = address;\n    mService = service;\n    mConfiguration = conf;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = mConfiguration.getInt(Constants.WEB_THREAD_COUNT);\n\n    mServer = new Server();\n    SelectChannelConnector connector = new SelectChannelConnector();\n    connector.setHost(address.getHostName());\n    connector.setPort(address.getPort());\n    connector.setAcceptors(webThreadCount);\n    mServer.setConnectors(new Connector[] {connector});\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n    mServer.setThreadPool(threadPool);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(mConfiguration.get(Constants.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","id":86449,"modified_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   * @param conf Alluxio configuration\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address, Configuration conf) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n    Preconditions.checkNotNull(conf, \"Configuration cannot be null\");\n\n    mAddress = address;\n    mService = service;\n    mConfiguration = conf;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = mConfiguration.getInt(Constants.WEB_THREAD_COUNT);\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n\n    mServer = new Server(threadPool);\n\n    ServerConnector serverConnector = new ServerConnector(mServer);\n    serverConnector.setPort(mAddress.getPort());\n    serverConnector.setHost(mAddress.getAddress().getHostAddress());\n\n    mServer.addConnector(serverConnector);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(mConfiguration.get(Constants.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","commit_id":"5e902035ec28ad9c0cf6a4c307072eb50c6ab979","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.close();\n    }\n\n    mServer.stop();\n  }","id":86450,"modified_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.stop();\n    }\n\n    mServer.stop();\n  }","commit_id":"5e902035ec28ad9c0cf6a4c307072eb50c6ab979","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n\n    mAddress = address;\n    mService = service;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = Configuration.getInt(PropertyKey.WEB_THREADS);\n\n    mServer = new Server();\n    SelectChannelConnector connector = new SelectChannelConnector();\n    connector.setHost(address.getHostName());\n    connector.setPort(address.getPort());\n    connector.setAcceptors(webThreadCount);\n    mServer.setConnectors(new Connector[] {connector});\n\n    try {\n      mServer.getConnectors()[0].close();\n      mServer.getConnectors()[0].open();\n    } catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n    mServer.setThreadPool(threadPool);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(Configuration.get(PropertyKey.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","id":86451,"modified_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n\n    mAddress = address;\n    mService = service;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = Configuration.getInt(PropertyKey.WEB_THREADS);\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n\n    mServer = new Server(threadPool);\n\n    mServerConnector = new ServerConnector(mServer);\n    mServerConnector.setPort(mAddress.getPort());\n    mServerConnector.setHost(mAddress.getAddress().getHostAddress());\n\n    mServer.addConnector(mServerConnector);\n\n    System.setProperty(\"org.apache.jasper.compiler.disablejsr199\", \"false\");\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(Configuration.get(PropertyKey.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n\n    mWebAppContext.setAttribute(\"org.eclipse.jetty.containerInitializers\", jspInitializers());\n\n    // Set the ContainerIncludeJarPattern so that jetty examines these\n    // container-path jars for tlds, web-fragments etc.\n    // If you omit the jar that contains the jstl .tlds, the jsp engine will\n    // scan for them instead.\n    mWebAppContext.setAttribute(\n        \"org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern\",\n        \".*/[^/]*servlet-api-[^/]*\\\\.jar$|.*/javax.servlet.jsp.jstl-.*\\\\.jar$\"\n         + \"|.*/[^/]*taglibs.*\\\\.jar$\");\n\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","commit_id":"55539f5825a84e1099775751dfd512e3ff5c4089","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mServer.getServer().getConnectors()[0].getLocalPort();\n  }","id":86452,"modified_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mServerConnector.getLocalPort();\n  }","commit_id":"55539f5825a84e1099775751dfd512e3ff5c4089","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mServer.getServer().getConnectors()[0].getHost();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","id":86453,"modified_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mServerConnector.getHost();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","commit_id":"55539f5825a84e1099775751dfd512e3ff5c4089","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.close();\n    }\n\n    mServer.stop();\n  }","id":86454,"modified_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.stop();\n    }\n\n    mServer.stop();\n  }","commit_id":"55539f5825a84e1099775751dfd512e3ff5c4089","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mServer.getServer().getConnectors()[0].getLocalPort();\n  }","id":86455,"modified_method":"/**\n   * Gets the actual port that the web server is listening on.\n   *\n   * @return the local port\n   */\n  public int getLocalPort() {\n    return mAddress.getPort();\n  }","commit_id":"c52688356dbc1c411e75239cd9262358ac83146f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   * @param conf Alluxio configuration\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address, Configuration conf) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n    Preconditions.checkNotNull(conf, \"Configuration cannot be null\");\n\n    mAddress = address;\n    mService = service;\n    mConfiguration = conf;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = mConfiguration.getInt(Constants.WEB_THREAD_COUNT);\n\n    mServer = new Server();\n    SelectChannelConnector connector = new SelectChannelConnector();\n    connector.setHost(address.getHostName());\n    connector.setPort(address.getPort());\n    connector.setAcceptors(webThreadCount);\n    mServer.setConnectors(new Connector[] {connector});\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n    mServer.setThreadPool(threadPool);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(mConfiguration.get(Constants.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","id":86456,"modified_method":"/**\n   * Creates a new instance of {@link UIWebServer}. It pairs URLs with servlets and sets the webapp\n   * folder.\n   *\n   * @param service name of the web service\n   * @param address address of the server\n   * @param conf Alluxio configuration\n   */\n  public UIWebServer(ServiceType service, InetSocketAddress address, Configuration conf) {\n    Preconditions.checkNotNull(service, \"Service type cannot be null\");\n    Preconditions.checkNotNull(address, \"Server address cannot be null\");\n    Preconditions.checkNotNull(conf, \"Configuration cannot be null\");\n\n    mAddress = address;\n    mService = service;\n    mConfiguration = conf;\n\n    QueuedThreadPool threadPool = new QueuedThreadPool();\n    int webThreadCount = mConfiguration.getInt(Constants.WEB_THREAD_COUNT);\n\n    // Jetty needs at least (1 + selectors + acceptors) threads.\n    threadPool.setMinThreads(webThreadCount * 2 + 1);\n    threadPool.setMaxThreads(webThreadCount * 2 + 100);\n\n    mServer = new Server(threadPool);\n\n    ServerConnector serverConnector = new ServerConnector(mServer);\n    serverConnector.setPort(mAddress.getPort());\n    serverConnector.setHost(mAddress.getAddress().getHostAddress());\n\n    mServer.addConnector(serverConnector);\n\n    mWebAppContext = new WebAppContext();\n    mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);\n    File warPath = new File(mConfiguration.get(Constants.WEB_RESOURCES));\n    mWebAppContext.setWar(warPath.getAbsolutePath());\n    HandlerList handlers = new HandlerList();\n    handlers.setHandlers(new Handler[] {mWebAppContext, new DefaultHandler()});\n    mServer.setHandler(handlers);\n  }","commit_id":"c52688356dbc1c411e75239cd9262358ac83146f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.close();\n    }\n\n    mServer.stop();\n  }","id":86457,"modified_method":"/**\n   * Shuts down the web server.\n   *\n   * @throws Exception if the underlying jetty server throws an exception\n   */\n  public void shutdownWebServer() throws Exception {\n    // close all connectors and release all binding ports\n    for (Connector connector : mServer.getConnectors()) {\n      connector.stop();\n    }\n\n    mServer.stop();\n  }","commit_id":"c52688356dbc1c411e75239cd9262358ac83146f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Starts the web server.\n   */\n  public void startWebServer() {\n    try {\n      mServer.getConnectors()[0].close();\n      mServer.getConnectors()[0].open();\n      mServer.start();\n      if (mAddress.getPort() == 0) {\n        int webPort = mServer.getConnectors()[0].getLocalPort();\n        mAddress = new InetSocketAddress(mAddress.getHostName(), webPort);\n        // reset web service port\n        mConfiguration.set(mService.getPortKey(), Integer.toString(webPort));\n      }\n      LOG.info(\"{} started @ {}\", mService.getServiceName(), mAddress);\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":86458,"modified_method":"/**\n   * Starts the web server.\n   */\n  public void startWebServer() {\n    try {\n      if (mAddress.getPort() == 0) {\n        int webPort = mAddress.getPort();\n        mAddress = new InetSocketAddress(mAddress.getHostName(), webPort);\n        // reset web service port\n        mConfiguration.set(mService.getPortKey(), Integer.toString(webPort));\n      }\n      mServer.start();\n      while (!mServer.isStarted()) {\n        Thread.sleep(10);\n      }\n      LOG.info(\"{} started @ {}\", mService.getServiceName(), mAddress);\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"c52688356dbc1c411e75239cd9262358ac83146f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mServer.getServer().getConnectors()[0].getHost();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","id":86459,"modified_method":"/**\n   * Gets the actual bind hostname.\n   *\n   * @return the bind host\n   */\n  public String getBindHost() {\n    String bindHost = mAddress.getHostString();\n    return bindHost == null ? \"0.0.0.0\" : bindHost;\n  }","commit_id":"c52688356dbc1c411e75239cd9262358ac83146f","url":"https://github.com/amplab/tachyon"},{"original_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        List errorMapList = FastList.newInstance();\n            \n        GenericValue userLogin =null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"os:CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"of:CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"of:AUTHID\"); // of\n\n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"ns:DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"ns:SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"of:DOCUMENTID\"); // of           \n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"receivedDate\", nowTimestamp);\n        oagisMsgInfoCtx.put(\"shipmentId\", shipmentId);\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        \n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                // errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        GenericValue shipment = null;\n        try {\n            shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error getting Shipment from database: \"+ e.toString();\n            Debug.logInfo(e, errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n        }\n        \n        if (shipment == null) {\n            String errMsg = \"Could not find Shipment id ID [\" + shipmentId + \"]\";\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ShipmentIdNotValid\"));\n        }\n        \n        if (errorMapList.size() > 0) {\n            result.putAll(ServiceUtil.returnError(\"Errors found getting shipment information for incoming Show Shipment message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n\n        String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n        String originFacilityId = shipment.getString(\"originFacilityId\");                              \n          \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"ns:SHIPUNIT\"); // n\n        if(UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                Element shipUnitElement = (Element) shipUnitElementItr.next();\n                String trackingNum = UtilXml.childElementValue(shipUnitElement, \"of:TRACKINGID\"); // of\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"of:SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"ns:INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    Iterator invItemElementItr = invItemElementList.iterator();\n                    while(invItemElementItr.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementItr.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of                \n                        try {                                    \n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if(requireInventory == null) {\n                                requireInventory = \"N\";\n                            }                    \n                            GenericValue orderItemShipGrpInvReservation = EntityUtil.getFirst(delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId)));               \n                            Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId, \"quantity\", orderItemShipGrpInvReservation.get(\"quantity\"));                \n                            isitspastCtx.put(\"productId\", productId);\n                            isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                            isitspastCtx.put(\"requireInventory\", requireInventory);\n                            isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                            isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                            isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                            isitspastCtx.put(\"userLogin\", userLogin);            \n                            isitspastCtx.put(\"trackingNum\", trackingNum);\n                            isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                            isitspastCtx.put(\"shipmentId\", shipmentId);      \n                            isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                            isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));                    \n                            Element invDetailElement = UtilXml.firstChildElement(invItemElement, \"ns:INVDETAIL\"); //n                            \n                            if(UtilValidate.isNotEmpty(invDetailElement)) {\n                                    String serialNumber = UtilXml.childElementValue(invDetailElement, \"os:SERIALNUM\"); // os                                                                                   \n                                    isitspastCtx.put(\"serialNumber\", serialNumber);                                        \n                                    isitspastCtx.remove(\"itemIssuanceId\");                            \n                                    try {\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }\n                            } else {\n                                try {//TODO: I think this else part is for NON Serialized Inv item. So it will be different service that we need to call here.                    \n                                    Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                    if (ServiceUtil.isError(resultMap)){\n                                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                        Debug.logError(errMsg, module);\n                                    }\n                                } catch(GenericServiceException e) {\n                                    Debug.logInfo(e, module);\n                                    String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                }            \n                            }\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, module);\n                        }\n                    }\n                }\n            }\n            try {\n                Map resultMap = dispatcher.runSync(\"setShipmentStatusPackedAndShipped\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"userLogin\", userLogin));               \n                if (ServiceUtil.isError(resultMap)){\n                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SetShipmentStatusPackedAndShippedError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch(GenericServiceException e) {\n                Debug.logInfo(e, module);\n                String errMsg = \"Error executing setShipmentStatusPackedAndShipped Service: \"+e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            }   \n        }  \n        \n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        try {\n            dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n        } catch (GenericServiceException e){\n            String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n        \n        if (errorMapList.size() > 0) {\n            //result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","id":86460,"modified_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        Document doc = (Document) context.get(\"document\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        List errorMapList = FastList.newInstance();\n            \n        GenericValue userLogin =null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"os:CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"os:BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"of:VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"of:NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"of:REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"os:SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"of:LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"of:COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"of:TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"of:REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"of:CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"of:AUTHID\"); // of\n\n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"ns:DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"ns:SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"ns:SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"of:DOCUMENTID\"); // of           \n\n        Map result = FastMap.newInstance();\n        result.put(\"logicalId\", logicalId);\n        result.put(\"component\", component);\n        result.put(\"task\", task);\n        result.put(\"referenceId\", referenceId);\n        result.put(\"userLogin\", userLogin);\n\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"receivedDate\", nowTimestamp);\n        oagisMsgInfoCtx.put(\"shipmentId\", shipmentId);\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        if (OagisServices.debugSaveXmlIn) {\n            try {\n                oagisMsgInfoCtx.put(\"fullMessageXml\", UtilXml.writeXmlDocument(doc));\n            } catch (IOException e) {\n                // this is just for debug info, so just log and otherwise ignore error\n                String errMsg = \"Warning: error creating text from XML Document for saving to database: \" + e.toString();\n                Debug.logWarning(errMsg, module);\n            }\n        }\n        \n        try {\n            dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n            /* running async for better error handling\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                // errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n            */\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        GenericValue shipment = null;\n        try {\n            shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));\n        } catch (GenericEntityException e) {\n            String errMsg = \"Error getting Shipment from database: \"+ e.toString();\n            Debug.logInfo(e, errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n        }\n        \n        if (shipment == null) {\n            String errMsg = \"Could not find Shipment id ID [\" + shipmentId + \"]\";\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ShipmentIdNotValid\"));\n        }\n        \n        if (errorMapList.size() > 0) {\n            result.putAll(ServiceUtil.returnError(\"Errors found getting shipment information for incoming Show Shipment message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n\n        String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n        String originFacilityId = shipment.getString(\"originFacilityId\");                              \n          \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"ns:SHIPUNIT\"); // n\n        if(UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                Element shipUnitElement = (Element) shipUnitElementItr.next();\n                String trackingNum = UtilXml.childElementValue(shipUnitElement, \"of:TRACKINGID\"); // of\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"of:SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"ns:INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    Iterator invItemElementItr = invItemElementList.iterator();\n                    while(invItemElementItr.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementItr.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"of:ITEM\"); // of                \n                        try {                                    \n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if(requireInventory == null) {\n                                requireInventory = \"N\";\n                            }                    \n                            GenericValue orderItemShipGrpInvReservation = EntityUtil.getFirst(delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId)));               \n                            Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId, \"quantity\", orderItemShipGrpInvReservation.get(\"quantity\"));                \n                            isitspastCtx.put(\"productId\", productId);\n                            isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                            isitspastCtx.put(\"requireInventory\", requireInventory);\n                            isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                            isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                            isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                            isitspastCtx.put(\"userLogin\", userLogin);            \n                            isitspastCtx.put(\"trackingNum\", trackingNum);\n                            isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                            isitspastCtx.put(\"shipmentId\", shipmentId);      \n                            isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                            isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));                    \n                            List invDetailElementList = UtilXml.childElementList(invItemElement, \"ns:INVDETAIL\"); //n                            \n                            if(UtilValidate.isNotEmpty(invDetailElementList)) {\n                                Iterator invDetailElementItr = invDetailElementList.iterator();\n                                while(invDetailElementItr.hasNext()) {\n                                    Element invDetailElement = (Element) invDetailElementItr.next();\n                                    String serialNumber = UtilXml.childElementValue(invDetailElement, \"os:SERIALNUM\"); // os                                                                                   \n                                    isitspastCtx.put(\"serialNumber\", serialNumber);                                        \n                                    isitspastCtx.remove(\"itemIssuanceId\");                            \n                                    try {\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }\n                                }\n                            } else {\n                                try {//TODO: I think this else part is for NON Serialized Inv item. So it will be different service that we need to call here.                    \n                                    Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                    if (ServiceUtil.isError(resultMap)){\n                                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                        Debug.logError(errMsg, module);\n                                    }\n                                } catch(GenericServiceException e) {\n                                    Debug.logInfo(e, module);\n                                    String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                }            \n                            }\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, module);\n                        }\n                    }\n                }\n            }\n            try {\n                Map resultMap = dispatcher.runSync(\"setShipmentStatusPackedAndShipped\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"userLogin\", userLogin));               \n                if (ServiceUtil.isError(resultMap)){\n                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SetShipmentStatusPackedAndShippedError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch(GenericServiceException e) {\n                Debug.logInfo(e, module);\n                String errMsg = \"Error executing setShipmentStatusPackedAndShipped Service: \"+e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            }   \n        }  \n        \n        oagisMsgInfoCtx.put(\"processingStatusId\", \"OAGMP_RECEIVED\");\n        try {\n            dispatcher.runSync(\"updateOagisMessageInfo\", oagisMsgInfoCtx, 60, true);\n        } catch (GenericServiceException e){\n            String errMsg = \"Error updating OagisMessageInfo for the Incoming Message: \" + e.toString();\n            // don't pass this back, nothing they can do about it: errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n        \n        if (errorMapList.size() > 0) {\n            //result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"f1f1846dd1387e1b5f1bee05e890e8dd114e666b","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map oagisSendConfirmBod(DispatchContext ctx, Map context) {\n        \n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n\n        String sendToUrl = (String) context.get(\"sendToUrl\");\n        String saveToFilename = (String) context.get(\"saveToFilename\");\n        String saveToDirectory = (String) context.get(\"saveToDirectory\");\n        OutputStream out = (OutputStream) context.get(\"outputStream\");\n        \n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"admin\"));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, \"Error getting userLogin\", module);\n        }\n        \n        String logicalId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.LOGICALID\");\n        String authId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.AUTHID\");\n        \n        MapStack bodyParameters =  MapStack.create();\n        bodyParameters.put(\"logicalId\", logicalId);\n        bodyParameters.put(\"authId\", authId);\n\n        String referenceId = delegator.getNextSeqId(\"OagisMessageInfo\");\n        bodyParameters.put(\"referenceId\", referenceId);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSS'Z'Z\");\n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        String sentDate = dateFormat.format(timestamp);\n        bodyParameters.put(\"sentDate\", sentDate);\n        \n        bodyParameters.put(\"errorLogicalId\", context.get(\"logicalId\"));\n        bodyParameters.put(\"errorComponent\", context.get(\"component\"));\n        bodyParameters.put(\"errorTask\", context.get(\"task\"));\n        bodyParameters.put(\"errorReferenceId\", context.get(\"referenceId\"));\n        //bodyParameters.put(\"errorDescription\", context.get(\"description\"));\n        //bodyParameters.put(\"errorReasonCode\", context.get(\"reasonCode\"));\n        bodyParameters.put(\"errorMapList\",(List) context.get(\"errorMapList\"));\n        bodyParameters.put(\"origRef\", context.get(\"origRefId\"));\n        String bodyScreenUri = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Template.ConfirmBod\");\n        \n        Writer writer = null;\n        if (out != null) {\n            writer = new OutputStreamWriter(out);\n        } else if (UtilValidate.isNotEmpty(saveToFilename)) {\n            try {\n                File outdir = new File(saveToDirectory);\n                if (!outdir.exists()) {\n                    outdir.mkdir();\n                }\n                writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(outdir, saveToFilename)), \"UTF-8\")));\n            } catch (Exception e) {\n                String errMsg = \"Error opening file to save message to [\" + saveToFilename + \"]: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else if (UtilValidate.isNotEmpty(sendToUrl)) {\n            writer = new StringWriter();\n        }\n\n        ScreenRenderer screens = new ScreenRenderer(writer, bodyParameters, new HtmlScreenRenderer());\n        try {\n            screens.render(bodyScreenUri);\n            writer.close();\n        } catch (Exception e) {\n            String errMsg = \"Error rendering message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        // TODO: call service with require-new-transaction=true to save the OagisMessageInfo data (to make sure it saves before)\n\n        if (UtilValidate.isNotEmpty(sendToUrl)) {\n            HttpClient http = new HttpClient(sendToUrl);\n\n            // test parameters\n            http.setHostVerificationLevel(SSLUtil.HOSTCERT_NO_CHECK);\n            http.setAllowUntrusted(true);\n            http.setDebug(true);\n              \n            // needed XML post parameters\n            if (UtilValidate.isNotEmpty(certAlias)) {\n                http.setClientCertificateAlias(certAlias);\n            }\n            if (UtilValidate.isNotEmpty(basicAuthUsername)) {\n                http.setBasicAuthInfo(basicAuthUsername, basicAuthPassword);\n            }\n            http.setContentType(\"text/xml\");\n            http.setKeepAlive(true);\n\n            try {\n                String resp = http.post(writer.toString());\n            } catch (Exception e) {\n                String errMsg = \"Error posting message to server with UTL [\" + sendToUrl + \"]: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n        \n        \n        \n        Map oagisMsgInfoContext = new HashMap();\n        oagisMsgInfoContext.put(\"logicalId\", logicalId);\n        oagisMsgInfoContext.put(\"component\", \"EXCEPTION\");\n        oagisMsgInfoContext.put(\"task\", \"RECIEPT\");\n        oagisMsgInfoContext.put(\"referenceId\", referenceId);\n        oagisMsgInfoContext.put(\"authId\", authId);\n        oagisMsgInfoContext.put(\"sentDate\", timestamp);\n        oagisMsgInfoContext.put(\"confirmation\", \"0\");\n        oagisMsgInfoContext.put(\"bsrVerb\", \"CONFIRM\");\n        oagisMsgInfoContext.put(\"bsrNoun\", \"BOD\");\n        oagisMsgInfoContext.put(\"bsrRevision\", \"004\");\n        oagisMsgInfoContext.put(\"userLogin\", userLogin);\n        try\n        {\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoContext);\n            if (ServiceUtil.isError(oagisMsgInfoResult)) return ServiceUtil.returnError(\"Error creating OagisMessageInfo\");\n            \n        } catch (GenericServiceException e) {\n            Debug.logError(e, \"Saving message to database failed\", module);\n        }\n        \n        return ServiceUtil.returnSuccess(\"Service Completed Successfully\");\n    }","id":86461,"modified_method":"public static Map oagisSendConfirmBod(DispatchContext ctx, Map context) {\n        \n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n\n        String sendToUrl = (String) context.get(\"sendToUrl\");\n        String saveToFilename = (String) context.get(\"saveToFilename\");\n        String saveToDirectory = (String) context.get(\"saveToDirectory\");\n        OutputStream out = (OutputStream) context.get(\"outputStream\");\n        \n        GenericValue userLogin = null;\n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"admin\"));\n        } catch (GenericEntityException e) {\n            Debug.logError(e, \"Error getting userLogin\", module);\n        }\n        \n        String logicalId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.LOGICALID\");\n        String authId = UtilProperties.getPropertyValue(\"oagis.properties\", \"CNTROLAREA.SENDER.AUTHID\");\n        \n        MapStack bodyParameters =  MapStack.create();\n        bodyParameters.put(\"logicalId\", logicalId);\n        bodyParameters.put(\"authId\", authId);\n\n        String referenceId = delegator.getNextSeqId(\"OagisMessageInfo\");\n        bodyParameters.put(\"referenceId\", referenceId);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSS'Z'Z\");\n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        String sentDate = dateFormat.format(timestamp);\n        bodyParameters.put(\"sentDate\", sentDate);\n        \n        bodyParameters.put(\"errorLogicalId\", context.get(\"logicalId\"));\n        bodyParameters.put(\"errorComponent\", context.get(\"component\"));\n        bodyParameters.put(\"errorTask\", context.get(\"task\"));\n        bodyParameters.put(\"errorReferenceId\", context.get(\"referenceId\"));\n        bodyParameters.put(\"errorMapList\",(List) context.get(\"errorMapList\"));\n        bodyParameters.put(\"origRef\", context.get(\"origRefId\"));\n        String bodyScreenUri = UtilProperties.getPropertyValue(\"oagis.properties\", \"Oagis.Template.ConfirmBod\");\n        \n        Writer writer = null;\n        if (out != null) {\n            writer = new OutputStreamWriter(out);\n        } else if (UtilValidate.isNotEmpty(saveToFilename)) {\n            try {\n                File outdir = new File(saveToDirectory);\n                if (!outdir.exists()) {\n                    outdir.mkdir();\n                }\n                writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(outdir, saveToFilename)), \"UTF-8\")));\n            } catch (Exception e) {\n                String errMsg = \"Error opening file to save message to [\" + saveToFilename + \"]: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else if (UtilValidate.isNotEmpty(sendToUrl)) {\n            writer = new StringWriter();\n        }\n\n        ScreenRenderer screens = new ScreenRenderer(writer, bodyParameters, new HtmlScreenRenderer());\n        try {\n            screens.render(bodyScreenUri);\n            writer.close();\n        } catch (Exception e) {\n            String errMsg = \"Error rendering message: \" + e.toString();\n            Debug.logError(e, errMsg, module);\n            return ServiceUtil.returnError(errMsg);\n        }\n        \n        // TODO: call service with require-new-transaction=true to save the OagisMessageInfo data (to make sure it saves before)\n        Map oagisMsgInfoContext = new HashMap();\n        oagisMsgInfoContext.put(\"logicalId\", logicalId);\n        oagisMsgInfoContext.put(\"component\", \"EXCEPTION\");\n        oagisMsgInfoContext.put(\"task\", \"RECIEPT\");\n        oagisMsgInfoContext.put(\"referenceId\", referenceId);\n        oagisMsgInfoContext.put(\"authId\", authId);\n        oagisMsgInfoContext.put(\"sentDate\", timestamp);\n        oagisMsgInfoContext.put(\"confirmation\", \"0\");\n        oagisMsgInfoContext.put(\"bsrVerb\", \"CONFIRM\");\n        oagisMsgInfoContext.put(\"bsrNoun\", \"BOD\");\n        oagisMsgInfoContext.put(\"bsrRevision\", \"004\");\n        oagisMsgInfoContext.put(\"userLogin\", userLogin);\n        try\n        {\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoContext);\n            if (ServiceUtil.isError(oagisMsgInfoResult)) return ServiceUtil.returnError(\"Error creating OagisMessageInfo\");\n            \n        } catch (GenericServiceException e) {\n            Debug.logError(e, \"Saving message to database failed\", module);\n        }\n\n        if (UtilValidate.isNotEmpty(sendToUrl)) {\n            HttpClient http = new HttpClient(sendToUrl);\n\n            // test parameters\n            http.setHostVerificationLevel(SSLUtil.HOSTCERT_NO_CHECK);\n            http.setAllowUntrusted(true);\n            http.setDebug(true);\n              \n            // needed XML post parameters\n            if (UtilValidate.isNotEmpty(certAlias)) {\n                http.setClientCertificateAlias(certAlias);\n            }\n            if (UtilValidate.isNotEmpty(basicAuthUsername)) {\n                http.setBasicAuthInfo(basicAuthUsername, basicAuthPassword);\n            }\n            http.setContentType(\"text/xml\");\n            http.setKeepAlive(true);\n\n            try {\n                String resp = http.post(writer.toString());\n            } catch (Exception e) {\n                String errMsg = \"Error posting message to server with UTL [\" + sendToUrl + \"]: \" + e.toString();\n                Debug.logError(e, errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n        \n        return ServiceUtil.returnSuccess(\"Service Completed Successfully\");\n    }","commit_id":"2df87dc2baace80e43576bd1eb74853f57ccfed0","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map receiveConfirmBod(DispatchContext ctx, Map context) {\n        \n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\",UtilMisc.toMap(\"userLoginId\",\"admin\"));\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId 'admin':\"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Document doc = null;\n        try {\n            doc = UtilXml.readXmlDocument(in, true, \"RecieveConfirmBod\");\n        } catch (SAXException e) {\n            String errMsg = \"Error parsing the ConfirmBodResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Error parsing the ConfirmBodResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"Error parsing the ConfirmBodResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        Element confirmBodElement = doc.getDocumentElement();\n        confirmBodElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(confirmBodElement, \"N1:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"N2:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"N2:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"N2:REVISION\");\n            \n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:SENDER\");\n        String logicalId = UtilXml.childElementValue(docSenderElement, \"N2:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"N2:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"N2:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"N2:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"N2:CONFIRMATION\");\n        String language = UtilXml.childElementValue(docSenderElement, \"N2:LANGUAGE\");\n        String codepage = UtilXml.childElementValue(docSenderElement, \"N2:CODEPAGE\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"N2:AUTHID\");\n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"N1:DATETIMEANY\");\n          \n        Element dataAreaElement = UtilXml.firstChildElement(confirmBodElement, \"n:DATAAREA\");\n        Element dataAreaConfirmBodElement = UtilXml.firstChildElement(dataAreaElement, \"n:CONFIRM_BOD\");\n        Element dataAreaConfirmElement = UtilXml.firstChildElement(dataAreaConfirmBodElement, \"n:CONFIRM\");\n        Element dataAreaCtrlElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"N1:CNTROLAREA\");\n        Element dataAreaSenderElement = UtilXml.firstChildElement(dataAreaCtrlElement, \"N1:SENDER\");\n        String dataAreaLogicalId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:LOGICALID\");\n        String dataAreaComponent = UtilXml.childElementValue(dataAreaSenderElement, \"N2:COMPONENT\");\n        String dataAreaTask = UtilXml.childElementValue(dataAreaSenderElement, \"N2:TASK\");\n        String dataAreaReferenceId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:REFERENCEID\");\n        String dataAreaDate = UtilXml.childElementValue(dataAreaCtrlElement, \"N1:DATETIMEANY\");\n        String origRef = UtilXml.childElementValue(dataAreaConfirmElement, \"N2:ORIGREF\");\n         \n        Element dataAreaConfirmMsgElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"n:CONFIRMMSG\");\n        String description = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:DESCRIPTN\");\n        String reasonCode = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:REASONCODE\");\n          \n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        Map oagisMsgInfoCtx = new HashMap();\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"receivedDate\", timestamp);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"bsrVerb\", bsrVerb);\n        oagisMsgInfoCtx.put(\"bsrNoun\", bsrNoun);\n        oagisMsgInfoCtx.put(\"bsrRevision\", bsrRevision);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        try {\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx);\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        Map oagisMsgErrorCtx = new HashMap();\n        oagisMsgErrorCtx.put(\"logicalId\", dataAreaLogicalId);\n        oagisMsgErrorCtx.put(\"component\", dataAreaComponent);\n        oagisMsgErrorCtx.put(\"task\", dataAreaTask);\n        oagisMsgErrorCtx.put(\"referenceId\", dataAreaReferenceId);\n          \n        GenericValue oagisMsgInfo = null;\n        try {\n            oagisMsgInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", oagisMsgErrorCtx);\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n            Debug.logError(e, errMsg, module);\n        }\n        \n        if (oagisMsgInfo != null){\n            oagisMsgErrorCtx.put(\"reasonCode\", reasonCode);\n            oagisMsgErrorCtx.put(\"description\", description);\n            oagisMsgErrorCtx.put(\"userLogin\", userLogin);\n            try {\n                Map oagisMsgErrorInfoResult = dispatcher.runSync(\"createOagisMessageErrorInfo\", oagisMsgErrorCtx);\n                if (ServiceUtil.isError(oagisMsgErrorInfoResult)){\n                    String errMsg = \"Error creating OagisMessageErrorInfo: \"+ServiceUtil.getErrorMessage(oagisMsgErrorInfoResult);\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageErrorInfoServiceError\"));\n                    Debug.logError(errMsg, module);\n                }\n            } catch (GenericServiceException e){\n                String errMsg = \"Error creating OagisMessageErrorInfo: \"+e.toString();\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                Debug.logError(e, errMsg, module);\n            }\n        } else{\n            String errMsg = \"No such message with an error was found in OagisMessageInfo Entity ; Not creating OagisMessageErrorInfo\";\n            Debug.logWarning(errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"OagisMessageInfoNotFoundError\"));\n        }\n        \n        Map result = new HashMap();\n        result.put(\"contentType\", \"text/plain\");\n        \n        if (errorMapList.size()>0){\n            result.putAll(oagisMsgInfoCtx);\n            String errMsg = \"Error Processing Received Message\";\n            result.put(\"errorMapList\", errorMapList);\n            //result.putAll(ServiceUtil.returnError(errMsg));\n            return result;\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","id":86462,"modified_method":"public static Map receiveConfirmBod(DispatchContext ctx, Map context) {\n        \n        GenericDelegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        List errorMapList = FastList.newInstance();\n        \n        GenericValue userLogin = null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\",UtilMisc.toMap(\"userLoginId\",\"admin\"));\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId 'admin':\"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n        \n        Document doc = null;\n        try {\n            doc = UtilXml.readXmlDocument(in, true, \"RecieveConfirmBod\");\n        } catch (SAXException e) {\n            String errMsg = \"Error parsing the ConfirmBodResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Error parsing the ConfirmBodResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"Error parsing the ConfirmBodResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        Element confirmBodElement = doc.getDocumentElement();\n        confirmBodElement.normalize();\n        Element docCtrlAreaElement = UtilXml.firstChildElement(confirmBodElement, \"N1:CNTROLAREA\");\n        Element bsrElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:BSR\");\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"N2:VERB\");\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"N2:NOUN\");\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"N2:REVISION\");\n            \n        Element docSenderElement = UtilXml.firstChildElement(docCtrlAreaElement, \"N1:SENDER\");\n        String logicalId = UtilXml.childElementValue(docSenderElement, \"N2:LOGICALID\");\n        String component = UtilXml.childElementValue(docSenderElement, \"N2:COMPONENT\");\n        String task = UtilXml.childElementValue(docSenderElement, \"N2:TASK\");\n        String referenceId = UtilXml.childElementValue(docSenderElement, \"N2:REFERENCEID\");\n        String confirmation = UtilXml.childElementValue(docSenderElement, \"N2:CONFIRMATION\");\n        String language = UtilXml.childElementValue(docSenderElement, \"N2:LANGUAGE\");\n        String codepage = UtilXml.childElementValue(docSenderElement, \"N2:CODEPAGE\");\n        String authId = UtilXml.childElementValue(docSenderElement, \"N2:AUTHID\");\n        String sentDate = UtilXml.childElementValue(docCtrlAreaElement, \"N1:DATETIMEANY\");\n          \n        Element dataAreaElement = UtilXml.firstChildElement(confirmBodElement, \"n:DATAAREA\");\n        Element dataAreaConfirmBodElement = UtilXml.firstChildElement(dataAreaElement, \"n:CONFIRM_BOD\");\n        Element dataAreaConfirmElement = UtilXml.firstChildElement(dataAreaConfirmBodElement, \"n:CONFIRM\");\n        Element dataAreaCtrlElement = UtilXml.firstChildElement(dataAreaConfirmElement, \"N1:CNTROLAREA\");\n        Element dataAreaSenderElement = UtilXml.firstChildElement(dataAreaCtrlElement, \"N1:SENDER\");\n        String dataAreaLogicalId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:LOGICALID\");\n        String dataAreaComponent = UtilXml.childElementValue(dataAreaSenderElement, \"N2:COMPONENT\");\n        String dataAreaTask = UtilXml.childElementValue(dataAreaSenderElement, \"N2:TASK\");\n        String dataAreaReferenceId = UtilXml.childElementValue(dataAreaSenderElement, \"N2:REFERENCEID\");\n        String dataAreaDate = UtilXml.childElementValue(dataAreaCtrlElement, \"N1:DATETIMEANY\");\n        String origRef = UtilXml.childElementValue(dataAreaConfirmElement, \"N2:ORIGREF\");\n          \n        Timestamp timestamp = UtilDateTime.nowTimestamp();\n        Map oagisMsgInfoCtx = new HashMap();\n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"receivedDate\", timestamp);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"bsrVerb\", bsrVerb);\n        oagisMsgInfoCtx.put(\"bsrNoun\", bsrNoun);\n        oagisMsgInfoCtx.put(\"bsrRevision\", bsrRevision);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        try {\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx);\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n\n        Map oagisMsgErrorCtx = new HashMap();\n        oagisMsgErrorCtx.put(\"logicalId\", dataAreaLogicalId);\n        oagisMsgErrorCtx.put(\"component\", dataAreaComponent);\n        oagisMsgErrorCtx.put(\"task\", dataAreaTask);\n        oagisMsgErrorCtx.put(\"referenceId\", dataAreaReferenceId);\n          \n        GenericValue oagisMsgInfo = null;\n        try {\n            oagisMsgInfo = delegator.findByPrimaryKey(\"OagisMessageInfo\", oagisMsgErrorCtx);\n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting Entity OagisMessageInfo: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n            Debug.logError(e, errMsg, module);\n        }\n        \n        oagisMsgErrorCtx.put(\"userLogin\", userLogin);\n        \n        List dataAreaConfirmMsgList = UtilXml.childElementList(dataAreaConfirmElement, \"n:CONFIRMMSG\");\n        Iterator dataAreaConfirmMsgListItr = dataAreaConfirmMsgList.iterator();\n        \n        if (oagisMsgInfo != null){\n            while (dataAreaConfirmMsgListItr.hasNext()){\n                Element dataAreaConfirmMsgElement = (Element) dataAreaConfirmMsgListItr.next();\n                String description = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:DESCRIPTN\");\n                String reasonCode = UtilXml.childElementValue(dataAreaConfirmMsgElement, \"N2:REASONCODE\");\n                oagisMsgErrorCtx.put(\"reasonCode\", reasonCode);\n                oagisMsgErrorCtx.put(\"description\", description);\n            \n                try {\n                    Map oagisMsgErrorInfoResult = dispatcher.runSync(\"createOagisMessageErrorInfo\", oagisMsgErrorCtx);\n                    if (ServiceUtil.isError(oagisMsgErrorInfoResult)){\n                        String errMsg = \"Error creating OagisMessageErrorInfo: \"+ServiceUtil.getErrorMessage(oagisMsgErrorInfoResult);\n                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageErrorInfoServiceError\"));\n                        Debug.logError(errMsg, module);\n                    }\n                } catch (GenericServiceException e){\n                    String errMsg = \"Error creating OagisMessageErrorInfo: \"+e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                    Debug.logError(e, errMsg, module);\n                }\n            }\n        } else{\n            String errMsg = \"No such message with an error was found in OagisMessageInfo Entity ; Not creating OagisMessageErrorInfo\";\n            Debug.logWarning(errMsg, module);\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"OagisMessageInfoNotFoundError\"));\n        }\n        \n        Map result = new HashMap();\n        result.put(\"contentType\", \"text/plain\");\n        \n        if (errorMapList.size()>0){\n            result.putAll(oagisMsgInfoCtx);\n            String errMsg = \"Error Processing Received Message\";\n            result.put(\"errorMapList\", errorMapList);\n            //result.putAll(ServiceUtil.returnError(errMsg));\n            return result;\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"2df87dc2baace80e43576bd1eb74853f57ccfed0","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        \n        List errorMapList = FastList.newInstance();\n        Document doc = null;\n        try {\n            doc = UtilXml.readXmlDocument(in, true, \"ShowShipment\");\n        } catch (SAXException e) {\n            String errMsg = \"Error parsing the ShowShipmentResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Error parsing the ShowShipmentResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"Error parsing the ShowShipmentResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n            \n        GenericValue userLogin =null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"REVISION\"); // of\n          \n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"AUTHID\"); // of\n          \n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        \n        try {\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx);\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"DOCUMENTID\"); // of           \n           \n        Element shipUnitElement = UtilXml.firstChildElement(daShowShipmentElement, \"SHIPUNIT\"); // n\n        String trackingNum = UtilXml.childElementValue(shipUnitElement, \"TRACKINGID\"); // of            \n        List invItemElementList = UtilXml.childElementList(shipUnitElement, \"INVITEM\");\n        if(UtilValidate.isNotEmpty(invItemElementList)) {\n            Iterator invItemElementItr = invItemElementList.iterator();\n            while(invItemElementItr.hasNext()) {                 \n                Element invItemElement = (Element) invItemElementItr.next();\n                String productId = UtilXml.childElementValue(invItemElement, \"ITEM\"); // of                \n                try {                                    \n                    GenericValue shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));                    \n                    String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n                    String originFacilityId = shipment.getString(\"originFacilityId\");                              \n                    GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                    String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                    GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                    String orderId = orderShipment.getString(\"orderId\");                \n                    String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                    GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                    String requireInventory = product.getString(\"requireInventory\");                    \n                    if(requireInventory == null) {\n                        requireInventory = \"N\";\n                    }                    \n                    GenericValue orderItemShipGrpInvReservation = EntityUtil.getFirst(delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId)));               \n                    Map isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId, \"quantity\", orderItemShipGrpInvReservation.get(\"quantity\"), \"quantityNotReserved\", orderItemShipGrpInvReservation.get(\"quantity\"));                \n                    isitspastCtx.put(\"productId\", productId);\n                    isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                    isitspastCtx.put(\"requireInventory\", requireInventory);\n                    isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                    isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                    isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                    isitspastCtx.put(\"userLogin\", userLogin);            \n                    isitspastCtx.put(\"trackingNum\", trackingNum);\n                    isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                    isitspastCtx.put(\"shipmentId\", shipmentId);      \n                    isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));                    \n                    List invDetailElementList = UtilXml.childElementList(invItemElement, \"INVDETAIL\");                \n                    if(UtilValidate.isNotEmpty(invDetailElementList)) {\n                        Iterator invDetailElementItr = invDetailElementList.iterator();\n                        while(invDetailElementItr.hasNext()) {\n                            Element invDetailElement = (Element) invDetailElementItr.next();\n                            String serialNumber = UtilXml.childElementValue(invDetailElement, \"SERIALNUM\"); // os                                                                                   \n                            isitspastCtx.put(\"serialNumber\", serialNumber);                                        \n                            isitspastCtx.remove(\"itemIssuanceId\");                            \n                            try {\n                                Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                if (ServiceUtil.isError(resultMap)){\n                                    String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                    Debug.logError(errMsg, module);\n                                }\n                            } catch(GenericServiceException e) {\n                                Debug.logInfo(e, module);\n                                String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                            }\n                        }\n                    } else {\n                        try {                    \n                            Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                            if (ServiceUtil.isError(resultMap)){\n                                String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                Debug.logError(errMsg, module);\n                            }\n                        } catch(GenericServiceException e) {\n                            Debug.logInfo(e, module);\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                        }\n            \n                    }\n                } catch (GenericEntityException e) {\n                    String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                    Debug.logInfo(e, module);\n                }\n            }\n        }\n        \n        Map result = new HashMap();\n        result.put(\"contentType\",\"text/plain\");\n        if (errorMapList.size() > 0) {\n            //result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"logicalId\", logicalId);\n            result.put(\"component\", component);\n            result.put(\"task\", task);\n            result.put(\"referenceId\", referenceId);\n            result.put(\"userLogin\", userLogin);\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","id":86463,"modified_method":"public static Map showShipment(DispatchContext ctx, Map context) {\n        InputStream in = (InputStream) context.get(\"inputStream\");\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        GenericDelegator delegator = ctx.getDelegator();\n        \n        List errorMapList = FastList.newInstance();\n        Document doc = null;\n        try {\n            doc = UtilXml.readXmlDocument(in, true, \"ShowShipment\");\n        } catch (SAXException e) {\n            String errMsg = \"Error parsing the ShowShipmentResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"SAXException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (ParserConfigurationException e) {\n            String errMsg = \"Error parsing the ShowShipmentResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"ParserConfigurationException\"));\n            Debug.logError(e, errMsg, module);\n        } catch (IOException e) {\n            String errMsg = \"Error parsing the ShowShipmentResponse: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IOException\"));\n            Debug.logError(e, errMsg, module);\n        }\n            \n        GenericValue userLogin =null; \n        try {\n            userLogin = delegator.findByPrimaryKey(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", \"system\"));    \n        } catch (GenericEntityException e){\n            String errMsg = \"Error Getting UserLogin with userLoginId system: \"+e.toString();\n            Debug.logError(e, errMsg, module);\n        }\n                    \n        Element showShipmentElement = doc.getDocumentElement();\n        showShipmentElement.normalize();\n          \n        Element controlAreaElement = UtilXml.firstChildElement(showShipmentElement, \"CNTROLAREA\"); // os\n        Element bsrElement = UtilXml.firstChildElement(controlAreaElement, \"BSR\"); // os\n        String bsrVerb = UtilXml.childElementValue(bsrElement, \"VERB\"); // of\n        String bsrNoun = UtilXml.childElementValue(bsrElement, \"NOUN\"); // of\n        String bsrRevision = UtilXml.childElementValue(bsrElement, \"REVISION\"); // of\n        Map oagisMsgInfoCtx = UtilMisc.toMap(\"bsrVerb\", bsrVerb, \"bsrNoun\", bsrNoun, \"bsrRevision\", bsrRevision);\n            \n        Element senderElement = UtilXml.firstChildElement(controlAreaElement, \"SENDER\"); // os\n        String logicalId = UtilXml.childElementValue(senderElement, \"LOGICALID\"); // of\n        String component = UtilXml.childElementValue(senderElement, \"COMPONENT\"); // of\n        String task = UtilXml.childElementValue(senderElement, \"TASK\"); // of\n        String referenceId = UtilXml.childElementValue(senderElement, \"REFERENCEID\"); // of\n        String confirmation = UtilXml.childElementValue(senderElement, \"CONFIRMATION\"); // of\n        String authId = UtilXml.childElementValue(senderElement, \"AUTHID\"); // of\n          \n        oagisMsgInfoCtx.put(\"logicalId\", logicalId);\n        oagisMsgInfoCtx.put(\"component\", component);\n        oagisMsgInfoCtx.put(\"task\", task);\n        oagisMsgInfoCtx.put(\"referenceId\", referenceId);\n        oagisMsgInfoCtx.put(\"confirmation\", confirmation);\n        oagisMsgInfoCtx.put(\"authId\", authId);\n        oagisMsgInfoCtx.put(\"outgoingMessage\", \"N\");\n        oagisMsgInfoCtx.put(\"userLogin\", userLogin);\n        \n        try {\n            Map oagisMsgInfoResult = dispatcher.runSync(\"createOagisMessageInfo\", oagisMsgInfoCtx);\n            if (ServiceUtil.isError(oagisMsgInfoResult)){\n                String errMsg = ServiceUtil.getErrorMessage(oagisMsgInfoResult);\n                errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"CreateOagisMessageInfoServiceError\"));\n                Debug.logError(errMsg, module);\n            }\n        } catch (GenericServiceException e){\n            String errMsg = \"Error creating OagisMessageInfo for the Incoming Message: \"+e.toString();\n            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n            Debug.logError(e, errMsg, module);\n        }\n           \n        Element dataAreaElement = UtilXml.firstChildElement(showShipmentElement, \"DATAAREA\"); // n\n        Element daShowShipmentElement = UtilXml.firstChildElement(dataAreaElement, \"SHOW_SHIPMENT\"); // n\n        Element shipmentElement = UtilXml.firstChildElement(daShowShipmentElement, \"SHIPMENT\"); // n                               \n        String shipmentId = UtilXml.childElementValue(shipmentElement, \"DOCUMENTID\"); // of           \n          \n        List shipUnitElementList = UtilXml.childElementList(daShowShipmentElement, \"SHIPUNIT\"); // n\n        if(UtilValidate.isNotEmpty(shipUnitElementList)) {\n            Iterator shipUnitElementItr = shipUnitElementList.iterator();\n            while(shipUnitElementItr.hasNext()) {                 \n                Element shipUnitElement = (Element) shipUnitElementItr.next();\n                String trackingNum = UtilXml.childElementValue(shipUnitElement, \"TRACKINGID\"); // of\n                String shipmentPackageSeqId = UtilXml.childElementValue(shipUnitElement, \"SHPUNITSEQ\"); // of\n                List invItemElementList = UtilXml.childElementList(shipUnitElement, \"INVITEM\"); //n\n                if(UtilValidate.isNotEmpty(invItemElementList)) {\n                    Iterator invItemElementItr = invItemElementList.iterator();\n                    while(invItemElementItr.hasNext()) {                 \n                        Element invItemElement = (Element) invItemElementItr.next();\n                        String productId = UtilXml.childElementValue(invItemElement, \"ITEM\"); // of                \n                        try {                                    \n                            GenericValue shipment = delegator.findByPrimaryKey(\"Shipment\", UtilMisc.toMap(\"shipmentId\", shipmentId));                    \n                            String shipGroupSeqId = shipment.getString(\"primaryShipGroupSeqId\");                \n                            String originFacilityId = shipment.getString(\"originFacilityId\");                              \n                            GenericValue shipmentItem = EntityUtil.getFirst(delegator.findByAnd(\"ShipmentItem\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"productId\",productId)));                    \n                            String shipmentItemSeqId = shipmentItem.getString(\"shipmentItemSeqId\");                      \n                            GenericValue orderShipment = EntityUtil.getFirst(delegator.findByAnd(\"OrderShipment\", UtilMisc.toMap(\"shipmentId\", shipmentId, \"shipmentItemSeqId\", shipmentItemSeqId)));                    \n                            String orderId = orderShipment.getString(\"orderId\");                \n                            String orderItemSeqId = orderShipment.getString(\"orderItemSeqId\");                \n                            GenericValue product = delegator.findByPrimaryKey(\"Product\",UtilMisc.toMap(\"productId\",productId));                    \n                            String requireInventory = product.getString(\"requireInventory\");                    \n                            if(requireInventory == null) {\n                                requireInventory = \"N\";\n                            }                    \n                            GenericValue orderItemShipGrpInvReservation = EntityUtil.getFirst(delegator.findByAnd(\"OrderItemShipGrpInvRes\", UtilMisc.toMap(\"orderId\", orderId, \"orderItemSeqId\", orderItemSeqId,\"shipGroupSeqId\",shipGroupSeqId)));               \n                            Map isitspastCtx = FastMap.newInstance();\n                            isitspastCtx = UtilMisc.toMap(\"orderId\", orderId, \"shipGroupSeqId\", shipGroupSeqId, \"orderItemSeqId\", orderItemSeqId, \"quantity\", orderItemShipGrpInvReservation.get(\"quantity\"), \"quantityNotReserved\", orderItemShipGrpInvReservation.get(\"quantity\"));                \n                            isitspastCtx.put(\"productId\", productId);\n                            isitspastCtx.put(\"reservedDatetime\", orderItemShipGrpInvReservation.get(\"reservedDatetime\"));\n                            isitspastCtx.put(\"requireInventory\", requireInventory);\n                            isitspastCtx.put(\"reserveOrderEnumId\", orderItemShipGrpInvReservation.get(\"reserveOrderEnumId\"));\n                            isitspastCtx.put(\"sequenceId\", orderItemShipGrpInvReservation.get(\"sequenceId\"));\n                            isitspastCtx.put(\"originFacilityId\", originFacilityId);\n                            isitspastCtx.put(\"userLogin\", userLogin);            \n                            isitspastCtx.put(\"trackingNum\", trackingNum);\n                            isitspastCtx.put(\"inventoryItemId\", orderItemShipGrpInvReservation.get(\"inventoryItemId\"));                \n                            isitspastCtx.put(\"shipmentId\", shipmentId);      \n                            isitspastCtx.put(\"shipmentPackageSeqId\", shipmentPackageSeqId);\n                            isitspastCtx.put(\"promisedDatetime\", orderItemShipGrpInvReservation.get(\"promisedDatetime\"));                    \n                            List invDetailElementList = UtilXml.childElementList(invItemElement, \"n:INVDETAIL\"); //n                            \n                            if(UtilValidate.isNotEmpty(invDetailElementList)) {\n                                Iterator invDetailElementItr = invDetailElementList.iterator();\n                                while(invDetailElementItr.hasNext()) {\n                                    Element invDetailElement = (Element) invDetailElementItr.next();\n                                    String serialNumber = UtilXml.childElementValue(invDetailElement, \"SERIALNUM\"); // os                                                                                   \n                                    isitspastCtx.put(\"serialNumber\", serialNumber);                                        \n                                    isitspastCtx.remove(\"itemIssuanceId\");                            \n                                    try {\n                                        Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                        if (ServiceUtil.isError(resultMap)){\n                                            String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                            Debug.logError(errMsg, module);\n                                        }\n                                    } catch(GenericServiceException e) {\n                                        Debug.logInfo(e, module);\n                                        String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                    }\n                                }\n                            } else {\n                                try {                    \n                                    Map resultMap = dispatcher.runSync(\"issueSerializedInvToShipmentPackageAndSetTracking\", isitspastCtx);\n                                    if (ServiceUtil.isError(resultMap)){\n                                        String errMsg = ServiceUtil.getErrorMessage(resultMap);\n                                        errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"IssueSerializedInvServiceError\"));\n                                        Debug.logError(errMsg, module);\n                                    }\n                                } catch(GenericServiceException e) {\n                                    Debug.logInfo(e, module);\n                                    String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                                    errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericServiceException\"));\n                                }            \n                            }\n                        } catch (GenericEntityException e) {\n                            String errMsg = \"Error executing issueSerializedInvToShipmentPackageAndSetTracking Service: \"+e.toString();\n                            errorMapList.add(UtilMisc.toMap(\"description\", errMsg, \"reasonCode\", \"GenericEntityException\"));\n                            Debug.logInfo(e, module);\n                        }\n                    }\n                }\n            }\n        }  \n        \n        Map result = new HashMap();\n        result.put(\"contentType\",\"text/plain\");\n        if (errorMapList.size() > 0) {\n            //result.putAll(ServiceUtil.returnError(\"Errors found processing message\"));\n            result.put(\"logicalId\", logicalId);\n            result.put(\"component\", component);\n            result.put(\"task\", task);\n            result.put(\"referenceId\", referenceId);\n            result.put(\"userLogin\", userLogin);\n            result.put(\"errorMapList\", errorMapList);\n            return result;\n        }\n        \n        result.putAll(ServiceUtil.returnSuccess(\"Service Completed Successfully\"));\n        return result;\n    }","commit_id":"f2e75b984b2bceceb4c3df693e0cc3a22ba8addb","url":"https://github.com/apache/ofbiz"},{"original_method":"@Override public boolean hasNext()\n    {\n        return this.iteratorSize != position;\n    }","id":86464,"modified_method":"@Override\n    public boolean hasNext()\n    {\n        return this.iteratorSize != this.position;\n    }","commit_id":"ef5822ece632ce1300dc9f35c7cfd83ff342c48f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override public MimeMessage next()\n    {\n        MimeMessage mimeMessage = null;\n        try {\n            mimeMessage = createMessage();\n        } catch (MessagingException e) {\n            this.logger.error(\"Failed to create mime message. \"\n                + \"Root reason: [{}]\", ExceptionUtils.getRootCauseMessage(e));\n            //TODO We need to save all the errors and display them in the status of all emails in the admin UI.\n        }\n        position++;\n        return mimeMessage;\n    }","id":86465,"modified_method":"@Override\n    public MimeMessage next()\n    {\n        MimeMessage mimeMessage;\n        try {\n            mimeMessage = createMessage();\n        } catch (Exception e) {\n            //TODO We need to save all the errors and display them in the status of all emails in the admin UI.\n            getLogger().error(\"Failed to create Mime Message.\", e);\n            mimeMessage = null;\n        }\n        this.position++;\n        return mimeMessage;\n    }","commit_id":"ef5822ece632ce1300dc9f35c7cfd83ff342c48f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Send the mail.\n     *\n     * @param item the queue item containing all the data for sending the mail\n     */\n    private void sendMailInternal(MailSenderQueueItem item)\n    {\n        Iterator<? extends MimeMessage> messages = item.getMessages().iterator();\n        MailListener listener = item.getListener();\n        UUID batchId = item.getBatchId();\n\n        // TODO: VMA: this is not correct I think, we need to prepare all the mails before sending them as otherwise\n        // they'll be in memory till they are sent... and if XWiki crashes they're lost and in any case we won't have\n        // any status for them till their turn comes which isn't good!\n        // ==> we need to serialize them all and reload them when their turn comes...\n\n        while (messages.hasNext()) {\n            MimeMessage mimeMessage = messages.next();\n            sendSingleMail(mimeMessage, listener, batchId, item);\n\n            // Email throttling: Wait before sending the next mail.\n            // Only wait here if there are more messages to send as otherwise when we send a single message\n            // synchronously the user would have to wait the wait time...\n            if (messages.hasNext()) {\n                waitSendWaitTime();\n            }\n        }\n    }","id":86466,"modified_method":"/**\n     * Send the mail.\n     *\n     * @param item the queue item containing all the data for sending the mail\n     */\n    private void sendMailInternal(MailSenderQueueItem item)\n    {\n        Iterator<? extends MimeMessage> messages = item.getMessages().iterator();\n        MailListener listener = item.getListener();\n        UUID batchId = item.getBatchId();\n\n        // TODO: VMA: this is not correct I think, we need to prepare all the mails before sending them as otherwise\n        // they'll be in memory till they are sent... and if XWiki crashes they're lost and in any case we won't have\n        // any status for them till their turn comes which isn't good!\n        // ==> we need to serialize them all and reload them when their turn comes...\n\n        while (messages.hasNext()) {\n            MimeMessage mimeMessage = messages.next();\n            // Skip message is message has failed to be created.\n            if (mimeMessage != null) {\n                sendSingleMail(mimeMessage, listener, batchId, item);\n\n                // Email throttling: Wait before sending the next mail.\n                // Only wait here if there are more messages to send as otherwise when we send a single message\n                // synchronously the user would have to wait the wait time...\n                if (messages.hasNext()) {\n                    waitSendWaitTime();\n                }\n            }\n        }\n    }","commit_id":"ef5822ece632ce1300dc9f35c7cfd83ff342c48f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override protected MimeMessage createMessage() throws MessagingException\n    {\n        DocumentReference groupsClassReference = this.stringResolver.resolve(USER_SPACE + \".XWikiGroups\");\n\n        String userFullName = this.documentAccessBridge\n            .getProperty(this.groupReference, groupsClassReference, this.position, \"member\").toString();\n\n        DocumentReference userReference = this.stringResolver.resolve(userFullName);\n\n        String email = this.documentAccessBridge.getProperty(userReference, new DocumentReference(userReference\n            .getWikiReference().getName(), USER_SPACE, \"XWikiUsers\"), \"email\").toString();\n\n\n        Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(\"parameters\");\n        Session session = (Session) this.parameters.get(\"session\");\n\n        MimeMessage mimeMessage = this.factory.createMessage(session, this.parameters.get(\"source\"), parameters);\n        mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]);\n\n        return mimeMessage;\n    }","id":86467,"modified_method":"@Override\n    protected MimeMessage createMessage() throws MessagingException\n    {\n        MimeMessage mimeMessage;\n\n        DocumentReference groupsClassReference = this.stringResolver.resolve(USER_SPACE + \".XWikiGroups\");\n\n        String userFullName = this.documentAccessBridge.getProperty(this.groupReference, groupsClassReference,\n            this.position, \"member\").toString();\n\n        DocumentReference userReference = this.stringResolver.resolve(userFullName);\n\n        // If the user has no email address then return a null Mime Message so that it's skipped\n        Object emailObject = this.documentAccessBridge.getProperty(userReference, new DocumentReference(userReference\n            .getWikiReference().getName(), USER_SPACE, \"XWikiUsers\"), \"email\");\n        if (emailObject != null) {\n            String email = emailObject.toString();\n\n            Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(\"parameters\");\n            Session session = (Session) this.parameters.get(\"session\");\n\n            mimeMessage = this.factory.createMessage(session, this.parameters.get(\"source\"), parameters);\n            mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]);\n        } else {\n            getLogger().warn(\"User [{}] has no email defined. Email has not been sent to that user.\", userReference);\n            mimeMessage = null;\n        }\n\n        return mimeMessage;\n    }","commit_id":"ef5822ece632ce1300dc9f35c7cfd83ff342c48f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private ActionForward handleDispatch(\n            ActionMapping mapping,\n            DynaActionForm formIn,\n            HttpServletRequest request) {\n        RequestContext context = new RequestContext(request);\n        User user = context.getCurrentUser();\n\n        Date earliest = getStrutsDelegate().readDatePicker(formIn,\n                \"date\", DatePicker.YEAR_RANGE_POSITIVE);\n        ActionChain actionChain = ActionChainHelper.readActionChain(formIn, user);\n\n        List<SystemOverview> systems = SystemManager.inSet(user, SetLabels.SYSTEM_LIST);\n        List<Long> serverIds = new ArrayList<Long>(systems.size());\n        for (SystemOverview s : systems) {\n            serverIds.add(s.getId());\n        }\n\n        RhnSet erratas = getSetDecl().get(context.getCurrentUser());\n        List<Long> errataIds = new ArrayList<Long>(erratas.size());\n        errataIds.addAll(erratas.getElementValues());\n\n        MessageQueue.publish(new SsmErrataEvent(\n                user.getId(),\n                earliest,\n                actionChain,\n                errataIds,\n                serverIds)\n        );\n\n        createMessage(request, \"ssm.errata.message.scheduled\",\n                new String[] {LocalizationService.getInstance().formatDate(\n                        earliest, request.getLocale())});\n\n        RhnSet set = getSetDecl().get(context.getCurrentUser());\n        set.clear();\n        RhnSetManager.store(set);\n\n        return mapping.findForward(\"confirm\");\n    }","id":86468,"modified_method":"private ActionForward handleDispatch(\n            ActionMapping mapping,\n            DynaActionForm formIn,\n            HttpServletRequest request) {\n        RequestContext context = new RequestContext(request);\n        User user = context.getCurrentUser();\n\n        Date earliest = getStrutsDelegate().readDatePicker(formIn,\n                \"date\", DatePicker.YEAR_RANGE_POSITIVE);\n        ActionChain actionChain = ActionChainHelper.readActionChain(formIn, user);\n\n        List<SystemOverview> systems = SystemManager.inSet(user, SetLabels.SYSTEM_LIST);\n        List<Long> serverIds = new ArrayList<Long>(systems.size());\n        for (SystemOverview s : systems) {\n            serverIds.add(s.getId());\n        }\n\n        RhnSet erratas = getSetDecl().get(context.getCurrentUser());\n        List<Long> errataIds = new ArrayList<Long>(erratas.size());\n        errataIds.addAll(erratas.getElementValues());\n\n        MessageQueue.publish(new SsmErrataEvent(\n                user.getId(),\n                earliest,\n                actionChain,\n                errataIds,\n                serverIds)\n        );\n\n        if (actionChain == null) {\n            createMessage(\n                request,\n                \"ssm.errata.message.scheduled\",\n                new String[] {LocalizationService.getInstance().formatDate(earliest,\n                    request.getLocale())});\n        }\n        else {\n            createMessage(request, \"ssm.errata.message.queued\", new String[] {\n                actionChain.getId().toString(), actionChain.getLabel()});\n        }\n\n        RhnSet set = getSetDecl().get(context.getCurrentUser());\n        set.clear();\n        RhnSetManager.store(set);\n\n        return mapping.findForward(\"confirm\");\n    }","commit_id":"980a2b76550cf5e2f38cc858520f194e68884f94","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private static void sendMessagesToOneDC(MessageOut message, Collection<InetAddress> targets, boolean localDC, AbstractWriteResponseHandler handler)\n    {\n        Iterator<InetAddress> iter = targets.iterator();\n        InetAddress target = iter.next();\n\n        // direct writes to local DC or old Cassandra versions\n        // (1.1 knows how to forward old-style String message IDs; updated to int in 2.0)\n        if (localDC || MessagingService.instance().getVersion(target) < MessagingService.VERSION_20)\n        {\n            // yes, the loop and non-loop code here are the same; this is clunky but we want to avoid\n            // creating a second iterator since we already have a perfectly good one\n            MessagingService.instance().sendRR(message, target, handler);\n            while (iter.hasNext())\n            {\n                target = iter.next();\n                MessagingService.instance().sendRR(message, target, handler);\n            }\n            return;\n        }\n\n        // Add all the other destinations of the same message as a FORWARD_HEADER entry\n        DataOutputBuffer out = new DataOutputBuffer();\n        try\n        {\n            out.writeInt(targets.size() - 1);\n            while (iter.hasNext())\n            {\n                InetAddress destination = iter.next();\n                CompactEndpointSerializationHelper.serialize(destination, out);\n                int id = MessagingService.instance().addCallback(handler, message, destination, message.getTimeout());\n                out.writeInt(id);\n                logger.trace(\"Adding FWD message to {}@{}\", id, destination);\n            }\n            message = message.withParameter(RowMutation.FORWARD_TO, out.getData());\n            // send the combined message + forward headers\n            int id = MessagingService.instance().sendRR(message, target, handler);\n            logger.trace(\"Sending message to {}@{}\", id, target);\n        }\n        catch (IOException e)\n        {\n            // DataOutputBuffer is in-memory, doesn't throw IOException\n            throw new AssertionError(e);\n        }\n    }","id":86469,"modified_method":"private static void sendMessagesToNonlocalDC(MessageOut message, Collection<InetAddress> targets, AbstractWriteResponseHandler handler)\n    {\n        Iterator<InetAddress> iter = targets.iterator();\n        InetAddress target = iter.next();\n\n        // Add the other destinations of the same message as a FORWARD_HEADER entry\n        DataOutputBuffer out = new DataOutputBuffer();\n        try\n        {\n            out.writeInt(targets.size() - 1);\n            while (iter.hasNext())\n            {\n                InetAddress destination = iter.next();\n                CompactEndpointSerializationHelper.serialize(destination, out);\n                int id = MessagingService.instance().addCallback(handler, message, destination, message.getTimeout());\n                out.writeInt(id);\n                logger.trace(\"Adding FWD message to {}@{}\", id, destination);\n            }\n            message = message.withParameter(RowMutation.FORWARD_TO, out.getData());\n            // send the combined message + forward headers\n            int id = MessagingService.instance().sendRR(message, target, handler);\n            logger.trace(\"Sending message to {}@{}\", id, target);\n        }\n        catch (IOException e)\n        {\n            // DataOutputBuffer is in-memory, doesn't throw IOException\n            throw new AssertionError(e);\n        }\n    }","commit_id":"d0dc597261b0b9949ecd26150cd30ef89ecc7a21","url":"https://github.com/apache/cassandra"},{"original_method":"private static void updateBatchlog(RowMutation rm, Collection<InetAddress> endpoints, AbstractWriteResponseHandler handler)\n    {\n        if (endpoints.contains(FBUtilities.getBroadcastAddress()))\n        {\n            assert endpoints.size() == 1;\n            insertLocal(rm, handler);\n        }\n        else\n        {\n            sendMessagesToOneDC(rm.createMessage(), endpoints, true, handler);\n        }\n    }","id":86470,"modified_method":"private static void updateBatchlog(RowMutation rm, Collection<InetAddress> endpoints, AbstractWriteResponseHandler handler)\n    {\n        if (endpoints.contains(FBUtilities.getBroadcastAddress()))\n        {\n            assert endpoints.size() == 1;\n            insertLocal(rm, handler);\n        }\n        else\n        {\n            MessageOut<RowMutation> message = rm.createMessage();\n            for (InetAddress target : endpoints)\n                MessagingService.instance().sendRR(message, target, handler);\n        }\n    }","commit_id":"d0dc597261b0b9949ecd26150cd30ef89ecc7a21","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Send the mutations to the right targets, write it locally if it corresponds or writes a hint when the node\n     * is not available.\n     *\n     * Note about hints:\n     *\n     * | Hinted Handoff | Consist. Level |\n     * | on             |       >=1      | --> wait for hints. We DO NOT notify the handler with handler.response() for hints;\n     * | on             |       ANY      | --> wait for hints. Responses count towards consistency.\n     * | off            |       >=1      | --> DO NOT fire hints. And DO NOT wait for them to complete.\n     * | off            |       ANY      | --> DO NOT fire hints. And DO NOT wait for them to complete.\n     *\n     * @throws TimeoutException if the hints cannot be written/enqueued\n     */\n    public static void sendToHintedEndpoints(final RowMutation rm,\n                                             Iterable<InetAddress> targets,\n                                             AbstractWriteResponseHandler responseHandler,\n                                             String localDataCenter,\n                                             ConsistencyLevel consistency_level)\n    throws OverloadedException\n    {\n        // replicas grouped by datacenter\n        Map<String, Collection<InetAddress>> dcGroups = null;\n\n        for (InetAddress destination : targets)\n        {\n            // avoid OOMing due to excess hints.  we need to do this check even for \"live\" nodes, since we can\n            // still generate hints for those if it's overloaded or simply dead but not yet known-to-be-dead.\n            // The idea is that if we have over maxHintsInProgress hints in flight, this is probably due to\n            // a small number of nodes causing problems, so we should avoid shutting down writes completely to\n            // healthy nodes.  Any node with no hintsInProgress is considered healthy.\n            if (totalHintsInProgress.get() > maxHintsInProgress\n                && (hintsInProgress.get(destination).get() > 0 && shouldHint(destination)))\n            {\n                throw new OverloadedException(\"Too many in flight hints: \" + totalHintsInProgress.get());\n            }\n\n            if (FailureDetector.instance.isAlive(destination))\n            {\n                if (destination.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)\n                {\n                    insertLocal(rm, responseHandler);\n                }\n                else\n                {\n                    // belongs on a different server\n                    String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);\n                    Collection<InetAddress> messages = (dcGroups != null) ? dcGroups.get(dc) : null;\n                    if (messages == null)\n                    {\n                        messages = new ArrayList<InetAddress>(3); // most DCs will have <= 3 replicas\n                        if (dcGroups == null)\n                            dcGroups = new HashMap<String, Collection<InetAddress>>();\n                        dcGroups.put(dc, messages);\n                    }\n\n                    messages.add(destination);\n                }\n            }\n            else\n            {\n                if (!shouldHint(destination))\n                    continue;\n\n                // Schedule a local hint\n                submitHint(rm, destination, responseHandler, consistency_level);\n            }\n        }\n\n        if (dcGroups != null)\n        {\n            MessageOut<RowMutation> message = rm.createMessage();\n            // for each datacenter, send the message to one node to relay the write to other replicas\n            for (Map.Entry<String, Collection<InetAddress>> entry: dcGroups.entrySet())\n            {\n                boolean isLocalDC = entry.getKey().equals(localDataCenter);\n                Collection<InetAddress> dcTargets = entry.getValue();\n                // a single message object is used for unhinted writes, so clean out any forwards\n                // from previous loop iterations\n                message = message.withHeaderRemoved(RowMutation.FORWARD_TO);\n                sendMessagesToOneDC(message, dcTargets, isLocalDC, responseHandler);\n            }\n        }\n    }","id":86471,"modified_method":"/**\n     * Send the mutations to the right targets, write it locally if it corresponds or writes a hint when the node\n     * is not available.\n     *\n     * Note about hints:\n     *\n     * | Hinted Handoff | Consist. Level |\n     * | on             |       >=1      | --> wait for hints. We DO NOT notify the handler with handler.response() for hints;\n     * | on             |       ANY      | --> wait for hints. Responses count towards consistency.\n     * | off            |       >=1      | --> DO NOT fire hints. And DO NOT wait for them to complete.\n     * | off            |       ANY      | --> DO NOT fire hints. And DO NOT wait for them to complete.\n     *\n     * @throws TimeoutException if the hints cannot be written/enqueued\n     */\n    public static void sendToHintedEndpoints(final RowMutation rm,\n                                             Iterable<InetAddress> targets,\n                                             AbstractWriteResponseHandler responseHandler,\n                                             String localDataCenter,\n                                             ConsistencyLevel consistency_level)\n    throws OverloadedException\n    {\n        // extra-datacenter replicas, grouped by dc\n        Map<String, Collection<InetAddress>> dcGroups = null;\n        // only need to create a Message for non-local writes\n        MessageOut<RowMutation> message = null;\n\n        for (InetAddress destination : targets)\n        {\n            // avoid OOMing due to excess hints.  we need to do this check even for \"live\" nodes, since we can\n            // still generate hints for those if it's overloaded or simply dead but not yet known-to-be-dead.\n            // The idea is that if we have over maxHintsInProgress hints in flight, this is probably due to\n            // a small number of nodes causing problems, so we should avoid shutting down writes completely to\n            // healthy nodes.  Any node with no hintsInProgress is considered healthy.\n            if (totalHintsInProgress.get() > maxHintsInProgress\n                && (hintsInProgress.get(destination).get() > 0 && shouldHint(destination)))\n            {\n                throw new OverloadedException(\"Too many in flight hints: \" + totalHintsInProgress.get());\n            }\n\n            if (FailureDetector.instance.isAlive(destination))\n            {\n                if (destination.equals(FBUtilities.getBroadcastAddress()) && OPTIMIZE_LOCAL_REQUESTS)\n                {\n                    insertLocal(rm, responseHandler);\n                }\n                else\n                {\n                    // belongs on a different server\n                    if (message == null)\n                        message = rm.createMessage();\n\n                    String dc = DatabaseDescriptor.getEndpointSnitch().getDatacenter(destination);\n                    // direct writes to local DC or old Cassandra versions\n                    // (1.1 knows how to forward old-style String message IDs; updated to int in 2.0)\n                    if (localDataCenter.equals(dc) || MessagingService.instance().getVersion(destination) < MessagingService.VERSION_20)\n                    {\n                        MessagingService.instance().sendRR(message, destination, responseHandler);\n                    }\n                    else\n                    {\n                        Collection<InetAddress> messages = (dcGroups != null) ? dcGroups.get(dc) : null;\n                        if (messages == null)\n                        {\n                            messages = new ArrayList<InetAddress>(3); // most DCs will have <= 3 replicas\n                            if (dcGroups == null)\n                                dcGroups = new HashMap<String, Collection<InetAddress>>();\n                            dcGroups.put(dc, messages);\n                        }\n                        messages.add(destination);\n                    }\n                }\n            }\n            else\n            {\n                if (!shouldHint(destination))\n                    continue;\n\n                // Schedule a local hint\n                submitHint(rm, destination, responseHandler, consistency_level);\n            }\n        }\n\n        if (dcGroups != null)\n        {\n            // for each datacenter, send the message to one node to relay the write to other replicas\n            if (message == null)\n                message = rm.createMessage();\n\n            for (Collection<InetAddress> dcTargets : dcGroups.values())\n            {\n                // clean out any forwards from previous loop iterations\n                message = message.withHeaderRemoved(RowMutation.FORWARD_TO);\n\n                sendMessagesToNonlocalDC(message, dcTargets, responseHandler);\n            }\n        }\n    }","commit_id":"d0dc597261b0b9949ecd26150cd30ef89ecc7a21","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n    protected MimeMessage createMessage() throws MessagingException\n    {\n        DocumentReference userReference = users.get(this.position);\n\n        String email = this.documentAccessBridge.getProperty(userReference, new DocumentReference(userReference\n            .getWikiReference().getName(), \"XWiki\", \"XWikiUsers\"), \"email\").toString();\n\n        Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(\"parameters\");\n        Session session = (Session) this.parameters.get(\"session\");\n\n        MimeMessage mimeMessage = this.factory.createMessage(session, this.parameters.get(\"source\"), parameters);\n        mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]);\n\n        return mimeMessage;\n    }","id":86472,"modified_method":"@Override\n    protected MimeMessage createMessage() throws MessagingException\n    {\n        MimeMessage mimeMessage;\n\n        DocumentReference userReference = users.get(this.position);\n\n        // If the user has no email address then return a null Mime Message so that it's skipped\n        Object emailObject = this.documentAccessBridge.getProperty(userReference, new DocumentReference(userReference\n            .getWikiReference().getName(), \"XWiki\", \"XWikiUsers\"), \"email\");\n        if (emailObject != null) {\n            String email = emailObject.toString();\n\n            Map<String, Object> parameters = (Map<String, Object>) this.parameters.get(\"parameters\");\n            Session session = (Session) this.parameters.get(\"session\");\n\n            mimeMessage = this.factory.createMessage(session, this.parameters.get(\"source\"), parameters);\n            mimeMessage.addRecipient(Message.RecipientType.TO, InternetAddress.parse(email)[0]);\n        } else {\n            getLogger().warn(\"User [{}] has no email defined. Email has not been sent to that user.\", userReference);\n            mimeMessage = null;\n        }\n\n        return mimeMessage;\n    }","commit_id":"6e57862da504bd146397f4ed48b60d53ac20cbc3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ActionForward execute(ActionMapping mapping, ActionForm formIn,\n        HttpServletRequest request, HttpServletResponse response) {\n\n        DynaActionForm form = (DynaActionForm) formIn;\n        RequestContext context = new RequestContext(request);\n        User user = context.getCurrentUser();\n        Map<String, Object> params = makeParamMap(request);\n        String forward = RhnHelper.DEFAULT_FORWARD;\n\n        Long sid = context.getRequiredParam(RequestContext.SID);\n        Server server = SystemManager.lookupByIdAndUser(sid, user);\n\n        if (isSubmitted(form)) {\n            Date earliest = getStrutsDelegate().readDatePicker(form, \"date\",\n                DatePicker.YEAR_RANGE_POSITIVE);\n            ActionChain actionChain = ActionChainHelper.readActionChain(form, user);\n            Action action = ActionChainManager.scheduleRebootAction(user, server, earliest,\n                actionChain);\n            ActionFactory.save(action);\n\n            String[] messageParams = new String[3];\n            messageParams[0] = server.getName();\n            messageParams[1] = earliest.toString();\n            messageParams[2] = action.getId().toString();\n            createMessage(request, \"system.reboot.scheduled\", messageParams);\n\n            // goes to sdc/overview.jsp\n            params.put(RequestContext.SID, sid);\n            forward = CONFIRM_FORWARD;\n        }\n\n        DatePicker picker = getStrutsDelegate().prepopulateDatePicker(request, form,\n            \"date\", DatePicker.YEAR_RANGE_POSITIVE);\n        request.setAttribute(\"date\", picker);\n        ActionChainHelper.prepopulateActionChains(request);\n\n        request.setAttribute(RequestContext.SID, sid);\n        request.setAttribute(\"system\", server);\n\n        SdcHelper.ssmCheck(request, server.getId(), user);\n\n        return getStrutsDelegate().forwardParams(mapping.findForward(forward), params);\n    }","id":86473,"modified_method":"/** {@inheritDoc} */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ActionForward execute(ActionMapping mapping, ActionForm formIn,\n        HttpServletRequest request, HttpServletResponse response) {\n\n        DynaActionForm form = (DynaActionForm) formIn;\n        RequestContext context = new RequestContext(request);\n        User user = context.getCurrentUser();\n        Map<String, Object> params = makeParamMap(request);\n        String forward = RhnHelper.DEFAULT_FORWARD;\n\n        Long sid = context.getRequiredParam(RequestContext.SID);\n        Server server = SystemManager.lookupByIdAndUser(sid, user);\n\n        if (isSubmitted(form)) {\n            Date earliest = getStrutsDelegate().readDatePicker(form, \"date\",\n                DatePicker.YEAR_RANGE_POSITIVE);\n            ActionChain actionChain = ActionChainHelper.readActionChain(form, user);\n            Action action = ActionChainManager.scheduleRebootAction(user, server, earliest,\n                actionChain);\n            ActionFactory.save(action);\n\n            if (actionChain == null) {\n                String[] messageParams = new String[3];\n                messageParams[0] = server.getName();\n                messageParams[1] = earliest.toString();\n                messageParams[2] = action.getId().toString();\n                createMessage(request, \"system.reboot.scheduled\", messageParams);\n            }\n            else {\n                String[] messageParams = new String[2];\n                messageParams[0] = actionChain.getId().toString();\n                messageParams[1] = actionChain.getLabel();\n                createMessage(request, \"message.addedtoactionchain\", messageParams);\n            }\n\n            // goes to sdc/overview.jsp\n            params.put(RequestContext.SID, sid);\n            forward = CONFIRM_FORWARD;\n        }\n\n        DatePicker picker = getStrutsDelegate().prepopulateDatePicker(request, form,\n            \"date\", DatePicker.YEAR_RANGE_POSITIVE);\n        request.setAttribute(\"date\", picker);\n        ActionChainHelper.prepopulateActionChains(request);\n\n        request.setAttribute(RequestContext.SID, sid);\n        request.setAttribute(\"system\", server);\n\n        SdcHelper.ssmCheck(request, server.getId(), user);\n\n        return getStrutsDelegate().forwardParams(mapping.findForward(forward), params);\n    }","commit_id":"731bb99418ec5e8b12c3566629191928df893986","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n  {\n    meta=(IngresVectorwiseLoaderMeta)smi;\n    data=(IngresVectorwiseLoaderData)sdi;\n\n    if (super.init(smi, sdi))\n    {     \n      if (Const.isEmpty(meta.getDelimiter())) {\n        data.separator = data.getBytes( \"|\" );\n       } else {\n        data.separator = data.getBytes( meta.getDelimiter() );\n      } \n\n        data.newline = data.getBytes( \"\\n\" );\n      \n      // Schema-table combination...\n      data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(null, environmentSubstitute(meta.getTablename()));\n      \n      data.encoding = environmentSubstitute(meta.getEncoding());\n      data.isEncoding = !Const.isEmpty(environmentSubstitute(meta.getEncoding()));\n      \n      data.byteBuffer  = ByteBuffer.allocateDirect(10000);\n      \n      return true;\n    }\n    return false;\n  }","id":86474,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n  {\n    meta=(IngresVectorwiseLoaderMeta)smi;\n    data=(IngresVectorwiseLoaderData)sdi;\n\n    if (super.init(smi, sdi))\n    {     \n      if (Const.isEmpty(meta.getDelimiter())) {\n        data.separator = data.getBytes( \"|\" );\n       } else {\n        data.separator = data.getBytes( meta.getDelimiter() );\n      } \n\n        data.newline = data.getBytes( \"\\n\" );\n      \n      // Schema-table combination...\n      data.schemaTable = meta.getDatabaseMeta().getQuotedSchemaTableCombination(null, environmentSubstitute(meta.getTablename()));\n      \n      data.encoding = environmentSubstitute(meta.getEncoding());\n      data.isEncoding = !Const.isEmpty(environmentSubstitute(meta.getEncoding()));\n      \n      data.byteBuffer  = null;\n      \n      return true;\n    }\n    return false;\n  }","commit_id":"cc70bc308d42289128b956cb9f99f10cea727482","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void write(byte[] content) throws IOException {\n    if (data.fileChannel==null) {\n      data.fileChannel = data.fifoOpener.getFileChannel();\n    }\n    \n    ByteBuffer buf = ByteBuffer.allocateDirect(content.length);\n    buf.put(content);\n    data.fileChannel.write(buf);\n  }","id":86475,"modified_method":"private void write(byte[] content) throws IOException {\n    if (data.fileChannel==null) {\n      data.fileChannel = data.fifoOpener.getFileChannel();\n    }\n\n    if (data.byteBuffer!=null) {\n      if (data.byteBuffer.capacity()<content.length) {\n        data.byteBuffer.limit(content.length);\n      }\n      data.byteBuffer.clear();\n    } else {\n      data.byteBuffer = ByteBuffer.allocateDirect(content.length);\n    }\n    \n    data.byteBuffer.put(content);\n    data.fileChannel.write(data.byteBuffer);\n  }","commit_id":"cc70bc308d42289128b956cb9f99f10cea727482","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void fillFromIndexedMesh( VertexAttribute position, Mesh mesh )\r\n\t{\r\n\t\tint idx = 0;\r\n\t\tint offset = position.offset / 4;\r\n\t\tint stride = mesh.getVertexSize() / 4;\r\n\t\tfloat[] vertices = new float[mesh.getVerticesBuffer().limit()/4];\r\n\t\tmesh.getVerticesBuffer().asFloatBuffer().get(vertices);\r\n\t\tshort[] indices = new short[mesh.getIndicesBuffer().limit() / 4];\r\n\t\tmesh.getIndicesBuffer().get(indices);\r\n\t\t\r\n\t\tfor( int i = 0; i < mesh.getNumIndices(); i+=3 )\r\n\t\t{\t\t\t\r\n\t\t\tint idx1 = indices[i] * stride + offset;\r\n\t\t\tint idx2 = indices[i+1] * stride + offset;\r\n\t\t\tint idx3 = indices[i+2] * stride + offset;\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx1]; \r\n\t\t\ttriangles[idx++] = vertices[idx1+1];\r\n\t\t\ttriangles[idx++] = vertices[idx1+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx2]; \r\n\t\t\ttriangles[idx++] = vertices[idx2+1];\r\n\t\t\ttriangles[idx++] = vertices[idx2+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx3]; \r\n\t\t\ttriangles[idx++] = vertices[idx3+1];\r\n\t\t\ttriangles[idx++] = vertices[idx3+2];\r\n\t\t}\r\n\t}","id":86476,"modified_method":"private void fillFromIndexedMesh( VertexAttribute position, Mesh mesh )\r\n\t{\r\n\t\tint idx = 0;\r\n\t\tint offset = position.offset / 4;\r\n\t\tint stride = mesh.getVertexSize() / 4;\r\n\t\tfloat[] vertices = new float[mesh.getNumVertices() * (mesh.getVertexSize() / 4)];\r\n\t\tmesh.getVertices(vertices);\r\n\t\tshort[] indices = new short[mesh.getNumIndices()];\r\n\t\tmesh.getIndices(indices);\r\n\t\t\r\n\t\tfor( int i = 0; i < mesh.getNumIndices(); i+=3 )\r\n\t\t{\t\t\t\r\n\t\t\tint idx1 = indices[i] * stride + offset;\r\n\t\t\tint idx2 = indices[i+1] * stride + offset;\r\n\t\t\tint idx3 = indices[i+2] * stride + offset;\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx1]; \r\n\t\t\ttriangles[idx++] = vertices[idx1+1];\r\n\t\t\ttriangles[idx++] = vertices[idx1+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx2]; \r\n\t\t\ttriangles[idx++] = vertices[idx2+1];\r\n\t\t\ttriangles[idx++] = vertices[idx2+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx3]; \r\n\t\t\ttriangles[idx++] = vertices[idx3+1];\r\n\t\t\ttriangles[idx++] = vertices[idx3+2];\r\n\t\t}\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void fillFromMesh( VertexAttribute position, Mesh mesh )\r\n\t{\r\n\t\tint idx = 0;\r\n\t\tint offset = position.offset / 4;\r\n\t\tint stride = mesh.getVertexSize() / 4;\r\n\t\tfloat[] vertices = new float[mesh.getVerticesBuffer().limit()/4];\r\n\t\tmesh.getVerticesBuffer().asFloatBuffer().get(vertices);\r\n\t\tfor( int i = 0; i < mesh.getNumVertices(); i+=3 )\r\n\t\t{\t\t\t\r\n\t\t\tint idx1 = (i) * stride + offset;\r\n\t\t\tint idx2 = (i+1) * stride + offset;\r\n\t\t\tint idx3 = (i+2) * stride + offset;\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx1]; \r\n\t\t\ttriangles[idx++] = vertices[idx1+1];\r\n\t\t\ttriangles[idx++] = vertices[idx1+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx2]; \r\n\t\t\ttriangles[idx++] = vertices[idx2+1];\r\n\t\t\ttriangles[idx++] = vertices[idx2+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx3]; \r\n\t\t\ttriangles[idx++] = vertices[idx3+1];\r\n\t\t\ttriangles[idx++] = vertices[idx3+2];\r\n\t\t}\r\n\t}","id":86477,"modified_method":"private void fillFromMesh( VertexAttribute position, Mesh mesh )\r\n\t{\r\n\t\tint idx = 0;\r\n\t\tint offset = position.offset / 4;\r\n\t\tint stride = mesh.getVertexSize() / 4;\r\n\t\tfloat[] vertices = new float[mesh.getNumVertices() * (mesh.getVertexSize() / 4)];\r\n\t\tmesh.getVertices(vertices);\r\n\t\tfor( int i = 0; i < mesh.getNumVertices(); i+=3 )\r\n\t\t{\t\t\t\r\n\t\t\tint idx1 = (i) * stride + offset;\r\n\t\t\tint idx2 = (i+1) * stride + offset;\r\n\t\t\tint idx3 = (i+2) * stride + offset;\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx1]; \r\n\t\t\ttriangles[idx++] = vertices[idx1+1];\r\n\t\t\ttriangles[idx++] = vertices[idx1+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx2]; \r\n\t\t\ttriangles[idx++] = vertices[idx2+1];\r\n\t\t\ttriangles[idx++] = vertices[idx2+2];\r\n\t\t\t\r\n\t\t\ttriangles[idx++] = vertices[idx3]; \r\n\t\t\ttriangles[idx++] = vertices[idx3+1];\r\n\t\t\ttriangles[idx++] = vertices[idx3+2];\r\n\t\t}\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void constructBufferObjects( GL20 gl )\r\n\t{\r\n\t\tByteBuffer tmp = ByteBuffer.allocateDirect( 4 );\r\n\t\ttmp.order( ByteOrder.nativeOrder() );\r\n\t\tIntBuffer handle = tmp.asIntBuffer();\r\n\t\t\r\n\t\tgl.glGenBuffers( 1, handle );\r\n\t\tvertexBufferObjectHandle = handle.get(0);\r\n\t\t\r\n\t\tif( maxIndices > 0 )\r\n\t\t{\r\n\t\t\tgl.glGenBuffers( 1, handle );\r\n\t\t\tindexBufferObjectHandle = handle.get(0);\r\n\t\t}\r\n\t\t\r\n//\t\tfilledOnce = false;\r\n\t}","id":86478,"modified_method":"private void constructBufferObjects( GL20 gl )\r\n\t{\r\n\t\tByteBuffer tmp = ByteBuffer.allocateDirect( 4 );\r\n\t\ttmp.order( ByteOrder.nativeOrder() );\r\n\t\tIntBuffer handle = tmp.asIntBuffer();\r\n\t\t\r\n\t\tgl.glGenBuffers( 1, handle );\r\n\t\tvertexBufferObjectHandle = handle.get(0);\r\n\t\t\r\n\t\tif( maxIndices > 0 )\r\n\t\t{\r\n\t\t\tgl.glGenBuffers( 1, handle );\r\n\t\t\tindexBufferObjectHandle = handle.get(0);\r\n\t\t}\r\n\t\t\r\n\t\tfilledOnce = false;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void fillBuffers( GL11 gl )\r\n\t{\t\t\t\t\r\n\t\t// FIXME potential bug? if subdata is bigger than first uploaded data, do we get into trouble?\r\n\t\t// FIXME disabled at the moment. per documentation this produces a bug.\r\n//\t\tif( filledOnce == false )\r\n//\t\t{\r\n\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n\t\t\tgl.glBufferData( GL11.GL_ARRAY_BUFFER, vertices.limit(), vertices, isStatic?GL11.GL_STATIC_DRAW:GL11.GL_DYNAMIC_DRAW );\r\n\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, 0 );\r\n\t\t\t\r\n\t\t\tif( maxIndices > 0 )\r\n\t\t\t{\r\n\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n\t\t\t\tgl.glBufferData( GL11.GL_ELEMENT_ARRAY_BUFFER, indices.limit() * 2, indices, isStatic?GL11.GL_STATIC_DRAW: GL11.GL_DYNAMIC_DRAW );\r\n\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n\t\t\t}\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n//\t\t\tgl.glBufferSubData( GL11.GL_ARRAY_BUFFER, 0, vertices.limit(), vertices );\r\n//\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, 0 );\r\n//\t\t\t\r\n//\t\t\tif( maxIndices > 0 )\r\n//\t\t\t{\r\n//\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n//\t\t\t\tgl.glBufferSubData( GL11.GL_ELEMENT_ARRAY_BUFFER, 0, indices.limit() * 2, indices );\t\t\t\t\r\n//\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n//\t\t\t}\r\n//\t\t}\r\n\t}","id":86479,"modified_method":"private void fillBuffers( GL11 gl )\r\n\t{\t\t\t\t\r\n\t\t// FIXME potential bug? if subdata is bigger than first uploaded data, do we get into trouble?\r\n\t\t// FIXME disabled at the moment. per documentation this produces a bug.\r\n//\t\tif( filledOnce == false )\r\n//\t\t{\t\t\t\r\n\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n\t\t\tgl.glBufferData( GL11.GL_ARRAY_BUFFER, getNumVertices() * attributes.vertexSize, vertices, isStatic?GL11.GL_STATIC_DRAW:GL11.GL_DYNAMIC_DRAW );\r\n\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, 0 );\r\n\t\t\t\r\n\t\t\tif( maxIndices > 0 )\r\n\t\t\t{\r\n\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n\t\t\t\tgl.glBufferData( GL11.GL_ELEMENT_ARRAY_BUFFER, indices.limit() * 2, indices, isStatic?GL11.GL_STATIC_DRAW: GL11.GL_DYNAMIC_DRAW );\r\n\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n\t\t\t}\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n//\t\t\tgl.glBufferSubData( GL11.GL_ARRAY_BUFFER, 0, vertices.limit(), vertices );\r\n//\t\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, 0 );\r\n//\t\t\t\r\n//\t\t\tif( maxIndices > 0 )\r\n//\t\t\t{\r\n//\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n//\t\t\t\tgl.glBufferSubData( GL11.GL_ELEMENT_ARRAY_BUFFER, 0, indices.limit() * 2, indices );\t\t\t\t\r\n//\t\t\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n//\t\t\t}\r\n//\t\t}\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in fixed point format. If this mesh is configured to use floats an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t * @param offset the offset into the vertices array\r\n\t * @param count the number of floats to use\r\n\t */\r\n\tpublic void setVertices( int[] vertices, int offset, int count )\r\n\t{\r\n\t\tif( !useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set fixed point vertices for float mesh\" );\r\n\t\t\r\n\t\tverticesFixed.clear();\r\n\t\tverticesFixed.put( vertices, offset, count );\r\n\t\tverticesFixed.limit(count);\r\n\t\tverticesFixed.position(0);\r\n\t\tthis.vertices.limit(verticesFixed.limit()*4);\r\n\t\tthis.vertices.position(0);\r\n\t\tdirty = true;\r\n\t}","id":86480,"modified_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in fixed point format. If this mesh is configured to use floats an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t * @param offset the offset into the vertices array\r\n\t * @param count the number of floats to use\r\n\t */\r\n\tpublic void setVertices( int[] vertices, int offset, int count )\r\n\t{\r\n\t\tif( !useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set fixed point vertices for float mesh\" );\r\n\t\t\r\n\t\tverticesFixed.clear();\r\n\t\tverticesFixed.put( vertices, offset, count );\r\n\t\tverticesFixed.limit(count);\r\n\t\tverticesFixed.position(0);\r\n\t\tif( usesDirectBuffers )\r\n\t\t{\r\n\t\t\tthis.vertices.limit(verticesFixed.limit()*4);\r\n\t\t\tthis.vertices.position(0);\r\n\t\t}\r\n\t\tdirty = true;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void fillBuffers( )\r\n\t{\r\n\t\tdirty = false;\r\n\t\tif( graphics.isGL11Available() == false && graphics.isGL20Available() == false )\r\n\t\t\treturn;\r\n\t\t\r\n\t\tif( graphics.isGL20Available() )\r\n\t\t\tfillBuffers( graphics.getGL20() );\r\n\t\telse\r\n\t\t\tfillBuffers( graphics.getGL11() );\r\n\t\t\r\n//\t\tfilledOnce = true;\r\n\t}","id":86481,"modified_method":"private void fillBuffers( )\r\n\t{\r\n\t\tdirty = false;\r\n\t\tif( graphics.isGL11Available() == false && graphics.isGL20Available() == false )\r\n\t\t\treturn;\r\n\t\t\r\n\t\tif( graphics.isGL20Available() )\r\n\t\t\tfillBuffers( graphics.getGL20() );\r\n\t\telse\r\n\t\t\tfillBuffers( graphics.getGL11() );\r\n\t\t\r\n\t\tfilledOnce = true;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Creates a new Mesh with the given attributes\r\n\t * \r\n\t * @param graphics the graphics instance\r\n\t * @param managed whether this mesh should be managed or not.\r\n\t * @param useFixedPoint whether to use fixed point or floats\r\n\t * @param maxVertices the maximum number of vertices this mesh can hold\r\n\t * @param maxIndices the maximum number of indices this mesh can hold\r\n\t * @param attributes the {@link VertexAttribute}s.\r\n\t */\r\n\tpublic Mesh( Graphics graphics, boolean managed, boolean isStatic, boolean useFixedPoint, int maxVertices, int maxIndices, VertexAttribute ... attributes )\r\n\t{\r\n\t\tthis.graphics = graphics;\r\n\t\tthis.managed = managed;\r\n\t\tthis.isStatic = isStatic;\r\n\t\tthis.useFixedPoint = useFixedPoint;\r\n\t\tthis.maxVertices = maxVertices;\r\n\t\tthis.maxIndices = maxIndices;\r\n\t\tthis.attributes = new VertexAttributes( attributes );\r\n\t\t\r\n\t\tvertices = ByteBuffer.allocateDirect( maxVertices * this.attributes.vertexSize );\r\n\t\tvertices.order(ByteOrder.nativeOrder());\r\n\t\r\n\t\tverticesFixed = vertices.asIntBuffer();\r\n\t\tverticesFloat = vertices.asFloatBuffer();\r\n\t\t\r\n\t\tByteBuffer buffer = ByteBuffer.allocateDirect( maxIndices * 2 );\r\n\t\tbuffer.order( ByteOrder.nativeOrder() );\r\n\t\tindices = buffer.asShortBuffer();\r\n\t\t\r\n\t\tcreateBuffers( );\r\n\t}","id":86482,"modified_method":"/**\r\n\t * Creates a new Mesh with the given attributes\r\n\t * \r\n\t * @param graphics the graphics instance\r\n\t * @param managed whether this mesh should be managed or not.\r\n\t * @param useFixedPoint whether to use fixed point or floats\r\n\t * @param maxVertices the maximum number of vertices this mesh can hold\r\n\t * @param maxIndices the maximum number of indices this mesh can hold\r\n\t * @param attributes the {@link VertexAttribute}s.\r\n\t */\r\n\tpublic Mesh( Graphics graphics, boolean managed, boolean isStatic, boolean useFixedPoint, int maxVertices, int maxIndices, VertexAttribute ... attributes )\r\n\t{\r\n\t\tthis.graphics = graphics;\r\n\t\tthis.managed = managed;\r\n\t\tthis.isStatic = isStatic;\r\n\t\tthis.useFixedPoint = useFixedPoint;\r\n\t\tthis.maxVertices = maxVertices;\r\n\t\tthis.maxIndices = maxIndices;\r\n\t\tthis.attributes = new VertexAttributes( attributes );\r\n\t\t\r\n\t\tif( graphics instanceof JoglGraphics )\r\n\t\t\tusesDirectBuffers = true;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( graphics.isGL11Available() || graphics.isGL20Available() )\r\n\t\t\t\tusesDirectBuffers = false;\r\n\t\t\telse\r\n\t\t\t\tusesDirectBuffers = true;\r\n\t\t}\r\n\t\t\r\n\t\tif( usesDirectBuffers == false )\r\n\t\t{\r\n\t\t\tvertices = useFixedPoint?IntBuffer.wrap( new int[maxVertices * this.attributes.vertexSize/4] ):FloatBuffer.wrap( new float[maxVertices * this.attributes.vertexSize/4] );\r\n\t\t\tif( useFixedPoint )\r\n\t\t\t{\r\n\t\t\t\tverticesFixed = (IntBuffer)vertices;\r\n\t\t\t\tverticesFloat = null;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tverticesFloat = (FloatBuffer)vertices;\r\n\t\t\t\tverticesFixed = null;\r\n\t\t\t}\r\n\t\t\tindices = ShortBuffer.wrap( new short[maxIndices] );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocateDirect( maxVertices * this.attributes.vertexSize );\r\n\t\t\tbuffer.order(ByteOrder.nativeOrder());\r\n\t\t\tvertices = buffer;\r\n\t\t\tverticesFixed = buffer.asIntBuffer();\r\n\t\t\tverticesFloat = buffer.asFloatBuffer();\r\n\t\t\tbuffer = ByteBuffer.allocateDirect( maxIndices * 2 );\r\n\t\t\tbuffer.order( ByteOrder.nativeOrder() );\r\n\t\t\tindices = buffer.asShortBuffer();\r\n\t\t}\t\t\t\t\t\t\t\t\t\r\n\t\t\r\n\t\tcreateBuffers( );\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void fillBuffers( GL20 gl )\r\n\t{\t\t\t\t\r\n//\t\tif( filledOnce == false )\r\n//\t\t{\r\n\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n\t\t\tgl.glBufferData( GL20.GL_ARRAY_BUFFER, vertices.limit(), vertices, isStatic?GL20.GL_STATIC_DRAW:GL20.GL_DYNAMIC_DRAW );\r\n\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, 0 );\r\n\t\t\t\r\n\t\t\tif( maxIndices > 0 )\r\n\t\t\t{\r\n\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n\t\t\t\tgl.glBufferData( GL20.GL_ELEMENT_ARRAY_BUFFER, indices.limit() * 2, indices, isStatic?GL20.GL_STATIC_DRAW: GL20.GL_DYNAMIC_DRAW );\r\n\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n\t\t\t}\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n//\t\t\tgl.glBufferSubData( GL20.GL_ARRAY_BUFFER, 0, vertices.limit(), vertices );\r\n//\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, 0 );\r\n//\t\t\t\r\n//\t\t\tif( maxIndices > 0 )\r\n//\t\t\t{\r\n//\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n//\t\t\t\tgl.glBufferSubData( GL20.GL_ELEMENT_ARRAY_BUFFER, 0, indices.limit() * 2, indices );\t\t\t\t\r\n//\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n//\t\t\t}\r\n//\t\t}\r\n\t}","id":86483,"modified_method":"private void fillBuffers( GL20 gl )\r\n\t{\t\t\t\t\r\n//\t\tif( filledOnce == false )\r\n//\t\t{\r\n\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n\t\t\tgl.glBufferData( GL20.GL_ARRAY_BUFFER, getNumVertices() * attributes.vertexSize, vertices, isStatic?GL20.GL_STATIC_DRAW:GL20.GL_DYNAMIC_DRAW );\r\n\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, 0 );\r\n\t\t\t\r\n\t\t\tif( maxIndices > 0 )\r\n\t\t\t{\r\n\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n\t\t\t\tgl.glBufferData( GL20.GL_ELEMENT_ARRAY_BUFFER, getNumIndices() * 2, indices, isStatic?GL20.GL_STATIC_DRAW: GL20.GL_DYNAMIC_DRAW );\r\n\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n\t\t\t}\r\n//\t\t}\r\n//\t\telse\r\n//\t\t{\r\n//\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, vertexBufferObjectHandle );\r\n//\t\t\tgl.glBufferSubData( GL20.GL_ARRAY_BUFFER, 0, vertices.limit(), vertices );\r\n//\t\t\tgl.glBindBuffer( GL20.GL_ARRAY_BUFFER, 0 );\r\n//\t\t\t\r\n//\t\t\tif( maxIndices > 0 )\r\n//\t\t\t{\r\n//\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, indexBufferObjectHandle );\r\n//\t\t\t\tgl.glBufferSubData( GL20.GL_ELEMENT_ARRAY_BUFFER, 0, indices.limit() * 2, indices );\t\t\t\t\r\n//\t\t\t\tgl.glBindBuffer( GL20.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n//\t\t\t}\r\n//\t\t}\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in float format. If this mesh is configured to use fixed point an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t */\r\n\tpublic void setVertices( float[] vertices )\r\n\t{\r\n\t\tif( useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set float vertices for fixed point mesh\" );\r\n\t\t\r\n\t\tverticesFloat.clear();\r\n\t\tverticesFloat.put( vertices );\r\n\t\tverticesFloat.limit(vertices.length);\r\n\t\tverticesFloat.position(0);\r\n\t\tthis.vertices.limit(verticesFloat.limit()*4);\r\n\t\tthis.vertices.position(0);\r\n\t\tdirty = true;\r\n\t}","id":86484,"modified_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in float format. If this mesh is configured to use fixed point an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t */\r\n\tpublic void setVertices( float[] vertices )\r\n\t{\r\n\t\tif( useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set float vertices for fixed point mesh\" );\r\n\t\t\t\t\r\n\t\tverticesFloat.clear();\t\t\t\r\n\t\tverticesFloat.put( vertices );\t\t\t\r\n\t\tverticesFloat.limit(vertices.length);\t\t\t\r\n\t\tverticesFloat.position(0);\t\t\r\n\t\t\r\n\t\tif( usesDirectBuffers )\r\n\t\t{ \t\t\t\r\n\t\t\tthis.vertices.limit(verticesFloat.limit()*4);\t\t\t\t\t\t\t\t\t\r\n\t\t\tthis.vertices.position(0);\t\t\t\r\n\t\t}\r\n\t\tdirty = true;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * @return the number of defined vertices\r\n\t */\r\n\tpublic int getNumVertices( )\r\n\t{\r\n\t\treturn vertices.limit() / attributes.vertexSize;\r\n\t}","id":86485,"modified_method":"/**\r\n\t * @return the number of defined vertices\r\n\t */\r\n\tpublic int getNumVertices( )\r\n\t{\r\n\t\treturn vertices.limit() / (attributes.vertexSize / (usesDirectBuffers?1:4));\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Returns the first {@link VertexAttribute} having the given\r\n\t * {@link Usage}.\r\n\t * \r\n\t * @param usage the Usage.\r\n\t * @return the VertexAttribute or null if no attribute with that usage was found.\r\n\t */\r\n\tpublic VertexAttribute getVertexAttribute(Usage usage) \r\n\t{\t\r\n\t\tfor( int i = 0; i < attributes.size(); i++ )\r\n\t\t\tif( attributes.get(i).usage == usage )\r\n\t\t\t\treturn attributes.get(i);\r\n\t\t\r\n\t\treturn null;\r\n\t}","id":86486,"modified_method":"/**\r\n\t * Returns the first {@link VertexAttribute} having the given\r\n\t * {@link Usage}.\r\n\t * \r\n\t * @param usage the Usage.\r\n\t * @return the VertexAttribute or null if no attribute with that usage was found.\r\n\t */\r\n\tpublic VertexAttribute getVertexAttribute(int usage) \r\n\t{\t\r\n\t\tfor( int i = 0; i < attributes.size(); i++ )\r\n\t\t\tif( attributes.get(i).usage == usage )\r\n\t\t\t\treturn attributes.get(i);\r\n\t\t\r\n\t\treturn null;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in float format. If this mesh is configured to use fixed point an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t * @param offset the offset into the vertices array\r\n\t * @param count the number of floats to use\r\n\t */\r\n\tpublic void setVertices(float[] vertices, int offset, int count) \r\n\t{\t\r\n\t\tif( useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set float vertices for fixed point mesh\" );\r\n\t\t\r\n\t\tverticesFloat.clear();\r\n\t\tverticesFloat.put( vertices, offset, count );\r\n\t\tverticesFloat.limit( count );\r\n\t\tverticesFloat.position(0);\r\n\t\tthis.vertices.limit(verticesFloat.limit()*4);\r\n\t\tthis.vertices.position(0);\r\n\t\tdirty = true;\r\n\t}","id":86487,"modified_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in float format. If this mesh is configured to use fixed point an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t * @param offset the offset into the vertices array\r\n\t * @param count the number of floats to use\r\n\t */\r\n\tpublic void setVertices(float[] vertices, int offset, int count) \r\n\t{\t\r\n\t\tif( useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set float vertices for fixed point mesh\" );\r\n\t\t\r\n\t\tverticesFloat.clear();\r\n\t\tverticesFloat.put( vertices, offset, count );\r\n\t\tverticesFloat.limit( count );\r\n\t\tverticesFloat.position(0);\r\n\t\tif( usesDirectBuffers )\r\n\t\t{\r\n\t\t\tthis.vertices.limit(verticesFloat.limit()*4);\r\n\t\t\tthis.vertices.position(0);\r\n\t\t}\r\n\t\tdirty = true;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * @return the backing ByteBuffer holding the vertices\r\n\t */\r\n\tpublic ByteBuffer getVerticesBuffer( )\r\n\t{\r\n\t\treturn vertices;\r\n\t}","id":86488,"modified_method":"/**\r\n\t * @return the backing ByteBuffer holding the vertices\r\n\t */\r\n\tpublic Buffer getVerticesBuffer( )\r\n\t{\r\n\t\treturn vertices;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in fixed point format. If this mesh is configured to use floats an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t */\r\n\tpublic void setVertices( int[] vertices )\r\n\t{\r\n\t\tif( !useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set fixed point vertices for float mesh\" );\r\n\t\t\r\n\t\tverticesFixed.clear();\r\n\t\tverticesFixed.put( vertices );\r\n\t\tverticesFixed.limit( vertices.length );\r\n\t\tverticesFixed.position(0);\r\n\t\tthis.vertices.limit(verticesFixed.limit()*4);\r\n\t\tthis.vertices.position(0);\r\n\t\tdirty = true;\r\n\t}","id":86489,"modified_method":"/**\r\n\t * Sets the vertices of this Mesh. The attributes are assumed to be given\r\n\t * in fixed point format. If this mesh is configured to use floats an\r\n\t * IllegalArgumentException will be thrown.\r\n\t * \r\n\t * @param vertices the vertices.\r\n\t */\r\n\tpublic void setVertices( int[] vertices )\r\n\t{\r\n\t\tif( !useFixedPoint )\r\n\t\t\tthrow new IllegalArgumentException( \"can't set fixed point vertices for float mesh\" );\r\n\t\t\r\n\t\tverticesFixed.clear();\r\n\t\tverticesFixed.put( vertices );\r\n\t\tverticesFixed.limit( vertices.length );\r\n\t\tverticesFixed.position(0);\r\n\t\tif( usesDirectBuffers )\r\n\t\t{\r\n\t\t\tthis.vertices.limit(verticesFixed.limit()*4);\r\n\t\t\tthis.vertices.position(0);\r\n\t\t}\r\n\t\tdirty = true;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Draws a rectangle with the top left corner at x,y having\r\n\t * the given width and height in pixels. The portion of the {@link Texture}\r\n\t * given by srcX, srcY and srcWidth, srcHeight are used. These coordinates and\r\n\t * sizes are given in texels. The rectangle will have the given tint {@link Color}.\r\n\t *  \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels\r\n\t * @param tint the tint Color\r\n\t */\r\n\tpublic void draw( Texture texture, int x, int y, int srcX, int srcY, int srcWidth, int srcHeight, Color tint )\r\n\t{\t\t\r\n\t\tif( !drawing )\r\n\t\t\tthrow new IllegalStateException( \"you have to call SpriteBatch.begin() first\" );\r\n\t\t\r\n\t\tif( texture != lastTexture )\r\n\t\t{\t\t\r\n\t\t\trenderMesh( );\r\n\t\t\tlastTexture = texture;\r\n\t\t\tinvTexWidth = 1.0f / texture.getWidth();\r\n\t\t\tinvTexHeight = 1.0f / texture.getHeight();\r\n\t\t}\r\n\t\t\r\n\t\tfloat u = srcX / (float)texture.getWidth();\r\n\t\tfloat v = srcY / (float)texture.getHeight();\r\n\t\tfloat u2 = (srcX + srcWidth) / (float)texture.getWidth();\r\n\t\tfloat v2 = (srcY + srcHeight) / (float)texture.getHeight();\r\n\t\tfloat fx = (float)x;\r\n\t\tfloat fy = (float)y;\r\n\t\tfloat fx2 = (float)(x + srcWidth);\r\n\t\tfloat fy2 = (float)(y - srcHeight);\r\n\t\t\r\n\t\tvertices[idx++] = fx;\r\n\t\tvertices[idx++] = fy;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u; vertices[idx++] = v; \r\n\t\t\r\n\t\tvertices[idx++] = fx;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u; vertices[idx++] = v2;\r\n\t\t\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u2; vertices[idx++] = v2;\r\n\t\t\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u2; vertices[idx++] = v2;\r\n\t\t\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u2; vertices[idx++] = v;\r\n\t\t\r\n\t\tvertices[idx++] = fx;\r\n\t\tvertices[idx++] = fy;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u; vertices[idx++] = v; \r\n\t\t\r\n\t\tif( idx == vertices.length )\r\n\t\t\trenderMesh();\r\n\t}","id":86490,"modified_method":"/**\r\n\t * Draws a rectangle with the top left corner at x,y having\r\n\t * the given width and height in pixels. The portion of the {@link Texture}\r\n\t * given by srcX, srcY and srcWidth, srcHeight are used. These coordinates and\r\n\t * sizes are given in texels. The rectangle will have the given tint {@link Color}.\r\n\t *  \r\n\t * @param texture the Texture\r\n\t * @param x the x-coordinate in screen space\r\n\t * @param y the y-coordinate in screen space\r\n\t * @param width the width in pixels\r\n\t * @param height the height in pixels\r\n\t * @param srcX the x-coordinate in texel space\r\n\t * @param srcY the y-coordinate in texel space\r\n\t * @param srcWidth the source with in texels\r\n\t * @param srcHeight the source height in texels\r\n\t * @param tint the tint Color\r\n\t */\r\n\tpublic void draw( Texture texture, int x, int y, int srcX, int srcY, int srcWidth, int srcHeight, Color tint )\r\n\t{\t\t\r\n\t\tif( !drawing )\r\n\t\t\tthrow new IllegalStateException( \"you have to call SpriteBatch.begin() first\" );\r\n\t\t\r\n\t\tif( texture != lastTexture )\r\n\t\t{\t\t\r\n\t\t\trenderMesh( );\r\n\t\t\tlastTexture = texture;\r\n\t\t\tinvTexWidth = 1.0f / texture.getWidth();\r\n\t\t\tinvTexHeight = 1.0f / texture.getHeight();\r\n\t\t}\r\n\t\t\r\n\t\tfloat u = srcX * invTexWidth;\r\n\t\tfloat v = srcY * invTexHeight;\r\n\t\tfloat u2 = (srcX + srcWidth) * invTexWidth;\r\n\t\tfloat v2 = (srcY + srcHeight) * invTexHeight;\r\n\t\tfloat fx = (float)x;\r\n\t\tfloat fy = (float)y;\r\n\t\tfloat fx2 = (float)(x + srcWidth);\r\n\t\tfloat fy2 = (float)(y - srcHeight);\t\t\r\n\t\t\r\n\t\tvertices[idx++] = fx;\r\n\t\tvertices[idx++] = fy;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u; vertices[idx++] = v; \r\n\t\t\r\n\t\tvertices[idx++] = fx;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u; vertices[idx++] = v2;\r\n\t\t\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u2; vertices[idx++] = v2;\r\n\t\t\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy2;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u2; vertices[idx++] = v2;\r\n\t\t\r\n\t\tvertices[idx++] = fx2;\r\n\t\tvertices[idx++] = fy;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u2; vertices[idx++] = v;\r\n\t\t\r\n\t\tvertices[idx++] = fx;\r\n\t\tvertices[idx++] = fy;\r\n\t\tvertices[idx++] = tint.r; vertices[idx++] = tint.g; vertices[idx++] = tint.b; vertices[idx++] = tint.a;\r\n\t\tvertices[idx++] = u; vertices[idx++] = v; \r\n\t\t\r\n\t\tif( idx == vertices.length )\r\n\t\t\trenderMesh();\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void surfaceCreated(Application app) \r\n\t{\t\r\n\t\tspriteBatch = new SpriteBatch( app.getGraphics() );\r\n\t\t\r\n\t\tPixmap pixmap = app.getGraphics().newPixmap(32, 32, Format.RGBA8888 );\r\n\t\tpixmap.setColor(1, 0, 0, 1 );\r\n\t\tpixmap.fill();\r\n\t\tpixmap.setColor(0, 1, 0, 1 );\r\n\t\tpixmap.drawLine(0, 0, 32, 32);\r\n\t\tpixmap.drawLine(32, 0, 0, 32);\r\n\t\tpixmap.setColor(0, 0, 1, 1 );\r\n\t\tpixmap.drawLine(0, 0, 31, 0 );\r\n\t\tpixmap.drawLine(0, 0, 0, 31 );\r\n\t\tpixmap.drawLine(31, 0, 31, 31 );\r\n\t\tpixmap.drawLine(0, 31, 31, 31 );\t\t\r\n\t\ttexture = app.getGraphics().newTexture( pixmap, TextureFilter.Nearest, TextureFilter.Nearest, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge, true );\r\n\t\t\r\n\t\tpixmap = app.getGraphics().newPixmap(32, 32, Format.RGBA8888 );\r\n\t\tpixmap.setColor(1, 1, 0, 1 );\r\n\t\tpixmap.fill();\r\n\t\ttexture2 = app.getGraphics().newTexture( pixmap, TextureFilter.Nearest, TextureFilter.Nearest, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge, true );\r\n\t\t\r\n\t\tfont = app.getGraphics().newFont( \"Arial\", 12, FontStyle.Plain, true );\r\n\t\t\r\n\t\tfor( int i = 0; i < coords.length; i+=2 )\r\n\t\t{\r\n\t\t\tcoords[i] = (int)(Math.random() * app.getGraphics().getWidth());\r\n\t\t\tcoords[i+1] = (int)(Math.random() * app.getGraphics().getHeight());\r\n\t\t\tcoords2[i] = (int)(Math.random() * app.getGraphics().getWidth());\r\n\t\t\tcoords2[i+1] = (int)(Math.random() * app.getGraphics().getHeight());\r\n\t\t}\r\n\t}","id":86491,"modified_method":"@Override\r\n\tpublic void surfaceCreated(Application app) \r\n\t{\t\t\t\t\t\r\n\t\tspriteBatch = new SpriteBatch( app.getGraphics() );\r\n\t\t\r\n\t\tPixmap pixmap = app.getGraphics().newPixmap(32, 32, Format.RGBA8888 );\r\n\t\tpixmap.setColor(1, 0, 0, 1 );\r\n\t\tpixmap.fill();\r\n\t\tpixmap.setColor(0, 1, 0, 1 );\r\n\t\tpixmap.drawLine(0, 0, 32, 32);\r\n\t\tpixmap.drawLine(32, 0, 0, 32);\r\n\t\tpixmap.setColor(0, 0, 1, 1 );\r\n\t\tpixmap.drawLine(0, 0, 31, 0 );\r\n\t\tpixmap.drawLine(0, 0, 0, 31 );\r\n\t\tpixmap.drawLine(31, 0, 31, 31 );\r\n\t\tpixmap.drawLine(0, 31, 31, 31 );\t\t\r\n\t\ttexture = app.getGraphics().newTexture( pixmap, TextureFilter.Linear, TextureFilter.Linear, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge, true );\r\n\t\t\r\n\t\tpixmap = app.getGraphics().newPixmap(32, 32, Format.RGBA8888 );\r\n\t\tpixmap.setColor(1, 1, 0, 1 );\r\n\t\tpixmap.fill();\r\n\t\ttexture2 = app.getGraphics().newTexture( pixmap, TextureFilter.Nearest, TextureFilter.Nearest, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge, true );\r\n\t\t\r\n\t\tfont = app.getGraphics().newFont( \"Arial\", 44, FontStyle.Plain, true );\r\n\t\t\r\n\t\tfor( int i = 0; i < coords.length; i+=2 )\r\n\t\t{\r\n\t\t\tcoords[i] = (int)(Math.random() * app.getGraphics().getWidth());\r\n\t\t\tcoords[i+1] = (int)(Math.random() * app.getGraphics().getHeight());\r\n\t\t\tcoords2[i] = (int)(Math.random() * app.getGraphics().getWidth());\r\n\t\t\tcoords2[i+1] = (int)(Math.random() * app.getGraphics().getHeight());\r\n\t\t}\r\n\t\t\r\n\t\tmesh = new Mesh( app.getGraphics(), true, false, false, 6 * SPRITES, 0, new VertexAttribute( Usage.Position, 2, \"a_position\" ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew VertexAttribute( Usage.Color, 4, \"a_color\" ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew VertexAttribute( Usage.TextureCoordinates, 2, \"a_texCoords\" ) );\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void render(Application app) \r\n\t{\t\r\n\t\tGL10 gl = app.getGraphics().getGL10();\r\n\t\tgl.glClear( GL.GL_COLOR_BUFFER_BIT );\r\n\t\t\r\n\t\tspriteBatch.begin();\t\t\r\n\t\tfor( int i = 0; i < coords.length; i+=2 )\t\t\r\n\t\t\tspriteBatch.draw( texture, coords[i], coords[i+1], 0, 0, 16, 16, Color.WHITE );\r\n\t\tfor( int i = 0; i < coords2.length; i+=2 )\t\t\r\n\t\t\tspriteBatch.draw( texture2, coords2[i], coords2[i+1], 0, 0, 16, 16, Color.WHITE );\r\n\t\t\r\n\t\tspriteBatch.drawText( font, \"this is a test\", 100, 100, Color.RED );\r\n\t\t\r\n\t\tspriteBatch.end();\r\n\t\t\r\n\t\tif( System.nanoTime() - startTime > 1000000000 )\r\n\t\t{\r\n\t\t\tapp.log( \"SpriteBatch\", \"fps: \" + frames );\r\n\t\t\tframes = 0;\r\n\t\t\tstartTime = System.nanoTime();\r\n\t\t}\r\n\t\tframes++;\r\n\t}","id":86492,"modified_method":"@Override\r\n\tpublic void render(Application app) \r\n\t{\t\r\n\t\tGL10 gl = app.getGraphics().getGL10();\r\n\t\tgl.glClear( GL.GL_COLOR_BUFFER_BIT );\r\n\t\t\r\n\t\tspriteBatch.begin();\t\t\t\t\r\n\t\t\trenderSpriteBatch();\r\n\t\tspriteBatch.end();\t\t\t\r\n\t\t\r\n\t\tif( System.nanoTime() - startTime > 1000000000 )\r\n\t\t{\r\n\t\t\tapp.log( \"SpriteBatch\", \"fps: \" + frames );\r\n\t\t\tframes = 0;\r\n\t\t\tstartTime = System.nanoTime();\r\n\t\t}\r\n\t\tframes++;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Constructs a new VertexAttribute. \r\n\t * \r\n\t * @param usage the usage, used for the fixed function pipeline. Generic attributes are not supported in the fixed function pipeline.\r\n\t * @param numComponents the number of components of this attribute, must be between 1 and 4.\r\n\t * @param alias the alias used in a shader for this attribute. Can be changed after construction.\r\n\t */\r\n\tpublic VertexAttribute( Usage usage, int numComponents, String alias )\r\n\t{\r\n\t\tthis.usage = usage;\r\n\t\tthis.numComponents = numComponents;\r\n\t\tthis.alias = alias;\r\n\t}","id":86493,"modified_method":"/**\r\n\t * Constructs a new VertexAttribute. \r\n\t * \r\n\t * @param usage the usage, used for the fixed function pipeline. Generic attributes are not supported in the fixed function pipeline.\r\n\t * @param numComponents the number of components of this attribute, must be between 1 and 4.\r\n\t * @param alias the alias used in a shader for this attribute. Can be changed after construction.\r\n\t */\r\n\tpublic VertexAttribute( int usage, int numComponents, String alias )\r\n\t{\r\n\t\tthis.usage = usage;\r\n\t\tthis.numComponents = numComponents;\r\n\t\tthis.alias = alias;\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void surfaceCreated(Application app) \r\n\t{\r\n\t\tByteBuffer buffer = ByteBuffer.allocateDirect( 3 * 7 * 4 );\r\n\t\tbuffer.order(ByteOrder.nativeOrder());\r\n\t\tFloatBuffer vertices = buffer.asFloatBuffer();\r\n\t\tvertices.put( new float[] {\r\n\t\t\t\t\t-0.5f, -0.5f, 0, 1, 0, 0, 1,\r\n\t\t\t\t\t 0.5f, -0.5f, 0, 0, 1, 0, 1,\r\n\t\t\t\t\t 0.0f,  0.5f, 0, 0, 0, 1, 1\r\n\t\t});\r\n\t\tvertices.flip();\r\n\t\t\r\n\t\tGL11 gl = app.getGraphics().getGL11();\r\n\t\tint[] handle = new int[1];\r\n\t\tgl.glGenBuffers( 1, handle, 0 );\r\n\t\tvboHandle = handle[0];\r\n\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, vboHandle );\r\n\t\tgl.glBufferData( GL11.GL_ARRAY_BUFFER, 3 * 7 * 4, vertices, GL11.GL_STATIC_DRAW );\r\n\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, 0 );\t\t\r\n\t\t\r\n\t\tbuffer = ByteBuffer.allocateDirect( 3 * 4 );\r\n\t\tbuffer.order(ByteOrder.nativeOrder());\r\n\t\tShortBuffer indices = buffer.asShortBuffer();\r\n\t\tindices.put( new short[ ] { 0, 1, 2 } );\r\n\t\tindices.flip();\r\n\t\tgl.glGenBuffers( 1, handle, 0 );\r\n\t\tvboIndexHandle = handle[0];\r\n\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, vboIndexHandle );\r\n\t\tgl.glBufferData( GL11.GL_ELEMENT_ARRAY_BUFFER, 3 * 2, indices, GL11.GL_STATIC_DRAW );\r\n\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n\t}","id":86494,"modified_method":"@Override\r\n\tpublic void surfaceCreated(Application app) \r\n\t{\r\n\t\tFloatBuffer vertices = FloatBuffer.wrap( new float[3 * 7] );\r\n\t\tvertices.put( new float[] {\r\n\t\t\t\t\t-0.5f, -0.5f, 0, 1, 0, 0, 1,\r\n\t\t\t\t\t 0.5f, -0.5f, 0, 0, 1, 0, 1,\r\n\t\t\t\t\t 0.0f,  0.5f, 0, 0, 0, 1, 1\r\n\t\t});\r\n\t\tvertices.flip();\r\n\t\t\r\n\t\tGL11 gl = app.getGraphics().getGL11();\r\n\t\tint[] handle = new int[1];\r\n\t\tgl.glGenBuffers( 1, handle, 0 );\r\n\t\tvboHandle = handle[0];\r\n\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, vboHandle );\r\n\t\tgl.glBufferData( GL11.GL_ARRAY_BUFFER, 3 * 7 * 4, vertices, GL11.GL_STATIC_DRAW );\r\n\t\tgl.glBindBuffer( GL11.GL_ARRAY_BUFFER, 0 );\t\t\r\n\t\t\r\n\t\tShortBuffer indices = ShortBuffer.wrap( new short[3] );\r\n\t\tindices.put( new short[ ] { 0, 1, 2 } );\r\n\t\tindices.flip();\r\n\t\tgl.glGenBuffers( 1, handle, 0 );\r\n\t\tvboIndexHandle = handle[0];\r\n\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, vboIndexHandle );\r\n\t\tgl.glBufferData( GL11.GL_ELEMENT_ARRAY_BUFFER, 3 * 2, indices, GL11.GL_STATIC_DRAW );\r\n\t\tgl.glBindBuffer( GL11.GL_ELEMENT_ARRAY_BUFFER, 0 );\r\n\t}","commit_id":"bc885bc7451c1628940ee35600560d40ac7b197e","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Insert the following node(s) <b>after<\/b> the matched node(s)\n     *\n     * @return the builder to build the nodes.\n     */\n    public ProcessorDefinition after() {\n        PipelineDefinition answer = new PipelineDefinition();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.afterById(builder.getOriginalRoute(), id, answer));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.afterByToString(builder.getOriginalRoute(), toString, answer));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.afterByType(builder.getOriginalRoute(), type, answer));\n        }\n        return answer;\n    }","id":86495,"modified_method":"/**\n     * Insert the following node(s) <b>after<\/b> the matched node(s)\n     *\n     * @return the builder to build the nodes.\n     */\n    public ProcessorDefinition after() {\n        RouteDefinition route = builder.getOriginalRoute();\n        PipelineDefinition answer = new PipelineDefinition();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.afterById(route, id, answer, selectFirst, selectLast, selectFrom, selectTo));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.afterByToString(route, toString, answer, selectLast, selectFirst, selectFrom, selectTo));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.afterByType(route, type, answer, selectFirst, selectLast, selectFrom, selectTo));\n        }\n        return answer;\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Removes the matched node(s)\n     */\n    public void remove() {\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.removeById(builder.getOriginalRoute(), id));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.removeByToString(builder.getOriginalRoute(), toString));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.removeByType(builder.getOriginalRoute(), type));\n        }\n    }","id":86496,"modified_method":"/**\n     * Removes the matched node(s)\n     */\n    public void remove() {\n        RouteDefinition route = builder.getOriginalRoute();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.removeById(route, id, selectFirst, selectLast, selectFrom, selectTo));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.removeByToString(route, toString, selectLast, selectFirst, selectFrom, selectTo));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.removeByType(route, type, selectFirst, selectFirst, selectFrom, selectTo));\n        }\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Insert the following node(s) <b>before<\/b> the matched node(s)\n     *\n     * @return the builder to build the nodes.\n     */\n    public ProcessorDefinition before() {\n        PipelineDefinition answer = new PipelineDefinition();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.beforeById(builder.getOriginalRoute(), id, answer));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByToString(builder.getOriginalRoute(), toString, answer));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByType(builder.getOriginalRoute(), type, answer));\n        }\n        return answer;\n    }","id":86497,"modified_method":"/**\n     * Insert the following node(s) <b>before<\/b> the matched node(s)\n     *\n     * @return the builder to build the nodes.\n     */\n    public ProcessorDefinition before() {\n        RouteDefinition route = builder.getOriginalRoute();\n        PipelineDefinition answer = new PipelineDefinition();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.beforeById(route, id, answer, selectFirst, selectLast, selectFrom, selectTo));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByToString(route, toString, answer, selectLast, selectFirst, selectFrom, selectTo));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByType(route, type, answer, selectFirst, selectLast, selectFrom, selectTo));\n        }\n        return answer;\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Replaces the matched node(s) with the following nodes.\n     *\n     * @return the builder to build the nodes.\n     */\n    public ProcessorDefinition replace() {\n        PipelineDefinition answer = new PipelineDefinition();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.replaceById(builder.getOriginalRoute(), id, answer));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByToString(builder.getOriginalRoute(), toString, answer));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByType(builder.getOriginalRoute(), type, answer));\n        }\n        return answer;\n    }","id":86498,"modified_method":"/**\n     * Replaces the matched node(s) with the following nodes.\n     *\n     * @return the builder to build the nodes.\n     */\n    public ProcessorDefinition replace() {\n        RouteDefinition route = builder.getOriginalRoute();\n        PipelineDefinition answer = new PipelineDefinition();\n        if (id != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.replaceById(route, id, answer, selectFirst, selectLast, selectFrom, selectTo));\n        } else if (toString != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByToString(route, toString, answer, selectFirst, selectLast, selectFrom, selectTo));\n        } else if (type != null) {\n            builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByType(route, type, answer, selectFirst, selectLast, selectFrom, selectTo));\n        }\n        return answer;\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask replaceByToString(final RouteDefinition route, final String toString, final ProcessorDefinition replace) {\n        return doReplace(route, new MatchByToString(toString), replace);\n    }","id":86499,"modified_method":"public static AdviceWithTask replaceByToString(final RouteDefinition route, final String toString, final ProcessorDefinition replace,\n                                                   boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByToString(toString);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doReplace(route, new MatchByToString(toString), replace, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask afterByType(final RouteDefinition route, final Class type, final ProcessorDefinition after) {\n        return doAfter(route, new MatchByType(type), after);\n    }","id":86500,"modified_method":"public static AdviceWithTask afterByType(final RouteDefinition route, final Class type, final ProcessorDefinition after,\n                                             boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByType(type);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doAfter(route, matchBy, after, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask beforeById(final RouteDefinition route, final String id, final ProcessorDefinition before) {\n        return doBefore(route, new MatchById(id), before);\n    }","id":86501,"modified_method":"public static AdviceWithTask beforeById(final RouteDefinition route, final String id, final ProcessorDefinition before,\n                                            boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchById(id);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doBefore(route, matchBy, before, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask beforeByType(final RouteDefinition route, final Class type, final ProcessorDefinition before) {\n        return doBefore(route, new MatchByType(type), before);\n    }","id":86502,"modified_method":"public static AdviceWithTask beforeByType(final RouteDefinition route, final Class type, final ProcessorDefinition before,\n                                              boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByType(type);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doBefore(route, matchBy, before, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask afterByToString(final RouteDefinition route, final String toString, final ProcessorDefinition after) {\n        return doAfter(route, new MatchByToString(toString), after);\n    }","id":86503,"modified_method":"public static AdviceWithTask afterByToString(final RouteDefinition route, final String toString, final ProcessorDefinition after,\n                                                 boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByToString(toString);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doAfter(route, matchBy, after, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private static AdviceWithTask doAfter(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition after) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                Iterator<ProcessorDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(route.getOutputs(), ProcessorDefinition.class);\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                Object existing = parent.getOutputs().get(index);\n                                parent.getOutputs().add(index + 1, after);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + existing + \"] --> after [\" + after + \"]\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","id":86504,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private static AdviceWithTask doAfter(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition after,\n                                          final Iterator<ProcessorDefinition> it) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                Object existing = parent.getOutputs().get(index);\n                                parent.getOutputs().add(index + 1, after);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + existing + \"] --> after [\" + after + \"]\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask replaceByType(final RouteDefinition route, final Class type, final ProcessorDefinition replace) {\n        return doReplace(route, new MatchByType(type), replace);\n    }","id":86505,"modified_method":"public static AdviceWithTask replaceByType(final RouteDefinition route, final Class type, final ProcessorDefinition replace,\n                                               boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByType(type);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doReplace(route, matchBy, replace, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask removeByToString(final RouteDefinition route, final String toString) {\n        return doRemove(route, new MatchByToString(toString));\n    }","id":86506,"modified_method":"public static AdviceWithTask removeByToString(final RouteDefinition route, final String toString,\n                                                  boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByToString(toString);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doRemove(route, matchBy, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private static AdviceWithTask doReplace(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition replace) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                Iterator<ProcessorDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(route.getOutputs(), ProcessorDefinition.class);\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                parent.getOutputs().add(index + 1, replace);\n                                Object old = parent.getOutputs().remove(index);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + old + \"] --> replace [\" + replace + \"]\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","id":86507,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private static AdviceWithTask doReplace(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition replace,\n                                            final Iterator<ProcessorDefinition> it) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                parent.getOutputs().add(index + 1, replace);\n                                Object old = parent.getOutputs().remove(index);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + old + \"] --> replace [\" + replace + \"]\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    private static AdviceWithTask doBefore(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition before) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                Iterator<ProcessorDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(route.getOutputs(), ProcessorDefinition.class);\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                Object existing = parent.getOutputs().get(index);\n                                parent.getOutputs().add(index, before);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + existing + \"] --> before [\" + before + \"]\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","id":86508,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private static AdviceWithTask doBefore(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition before,\n                                           final Iterator<ProcessorDefinition> it) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                Object existing = parent.getOutputs().get(index);\n                                parent.getOutputs().add(index, before);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + existing + \"] --> before [\" + before + \"]\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask beforeByToString(final RouteDefinition route, final String toString, final ProcessorDefinition before) {\n        return doBefore(route, new MatchByToString(toString), before);\n    }","id":86509,"modified_method":"public static AdviceWithTask beforeByToString(final RouteDefinition route, final String toString, final ProcessorDefinition before,\n                                                  boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByToString(toString);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doBefore(route, matchBy, before, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask removeByType(final RouteDefinition route, final Class type) {\n        return doRemove(route, new MatchByType(type));\n    }","id":86510,"modified_method":"public static AdviceWithTask removeByType(final RouteDefinition route, final Class type,\n                                              boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchByType(type);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doRemove(route, matchBy, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask removeById(final RouteDefinition route, final String id) {\n        return doRemove(route, new MatchById(id));\n    }","id":86511,"modified_method":"public static AdviceWithTask removeById(final RouteDefinition route, final String id,\n                                            boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchById(id);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doRemove(route, matchBy, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask afterById(final RouteDefinition route, final String id, final ProcessorDefinition after) {\n        return doAfter(route, new MatchById(id), after);\n    }","id":86512,"modified_method":"public static AdviceWithTask afterById(final RouteDefinition route, final String id, final ProcessorDefinition after,\n                                           boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchById(id);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doAfter(route, matchBy, after, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"public static AdviceWithTask replaceById(final RouteDefinition route, final String id, final ProcessorDefinition replace) {\n        return doReplace(route, new MatchById(id), replace);\n    }","id":86513,"modified_method":"public static AdviceWithTask replaceById(final RouteDefinition route, final String id, final ProcessorDefinition replace,\n                                             boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {\n        MatchBy matchBy = new MatchById(id);\n        Iterator<ProcessorDefinition> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);\n        return doReplace(route, matchBy, replace, it);\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"private static AdviceWithTask doRemove(final RouteDefinition route, final MatchBy matchBy) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                Iterator<ProcessorDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(route.getOutputs(), ProcessorDefinition.class);\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                Object old = parent.getOutputs().remove(index);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + old + \"] --> remove\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","id":86514,"modified_method":"private static AdviceWithTask doRemove(final RouteDefinition route, final MatchBy matchBy,\n                                           final Iterator<ProcessorDefinition> it) {\n        return new AdviceWithTask() {\n            public void task() throws Exception {\n                boolean match = false;\n                while (it.hasNext()) {\n                    ProcessorDefinition output = it.next();\n                    if (matchBy.match(output)) {\n                        ProcessorDefinition parent = output.getParent();\n                        if (parent != null) {\n                            int index = parent.getOutputs().indexOf(output);\n                            if (index != -1) {\n                                match = true;\n                                Object old = parent.getOutputs().remove(index);\n                                LOG.info(\"AdviceWith (\" + matchBy.getId() + \") : [\" + old + \"] --> remove\");\n                            }\n                        }\n                    }\n                }\n\n                if (!match) {\n                    throw new IllegalArgumentException(\"There are no outputs which matches: \" + matchBy.getId() + \" in the route: \" + route);\n                }\n            }\n        };\n    }","commit_id":"44f214a1f2617dc289bf81f26f3772d02d61e89c","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win=null;\n        Message msg_to_deliver;\n        Address sender;\n\n        if(msg == null || hdr == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"msg or header is null\");\n            }\n            return;\n        }\n        sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender of message is null\");\n            }\n            return;\n        }\n\n        if(log.isTraceEnabled()) {\n            log.trace(\"[\" + local_addr + \"] received \" + sender + '#' + hdr.seqno);\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving) {\n                return;\n            }\n            if(log.isWarnEnabled()) {\n                log.warn(\"[\" + local_addr + \"] discarded message from non-member \" + sender);\n            }\n            return;\n        }\n        win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n        msg=null;\n\n        while((msg_to_deliver=win.remove()) != null) {\n\n            // Changed by bela Jan 29 2003: not needed (see above)\n            //msg_to_deliver.removeHeader(getName());\n\n            passUp(new Event(Event.MSG, msg_to_deliver));\n            msg_to_deliver=null;\n        }\n    }","id":86515,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win;\n        Message msg_to_deliver;\n        Address sender=msg.getSrc();\n\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled()) {\n            StringBuffer sb=new StringBuffer('[');\n            sb.append(local_addr).append(\"] received \").append(sender).append('#').append(hdr.seqno);\n            log.trace(sb.toString());\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled()) {\n                StringBuffer sb=new StringBuffer('[');\n                sb.append(local_addr).append(\"] discarded message from non-member \").append(sender);\n                if(log.isWarnEnabled())\n                    log.warn(sb.toString());\n            }\n            return;\n        }\n        win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n\n        while((msg_to_deliver=win.remove()) != null) {\n\n            // Changed by bela Jan 29 2003: not needed (see above)\n            //msg_to_deliver.removeHeader(getName());\n            passUp(new Event(Event.MSG, msg_to_deliver));\n        }\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        Object obj;\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch(evt.getType()) {\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.GET_DIGEST:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_OK, digest));\n            return;\n\n        case Event.GET_DIGEST_STABLE:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n            return;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return;\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            obj=msg.getHeader(name);\n            if(obj == null || !(obj instanceof NakAckHeader)) {\n                break;  // pass up (e.g. unicast msg)\n            }\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(log.isDebugEnabled()) {\n                    log.debug(\"message was discarded (not yet server)\");\n                }\n                return;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n            hdr=(NakAckHeader)obj;\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                return;\n\n            case NakAckHeader.XMIT_RSP:\n                if(log.isTraceEnabled())\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return;\n            }\n        }\n        passUp(evt);\n    }","id":86516,"modified_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch(evt.getType()) {\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.GET_DIGEST:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_OK, digest));\n            return;\n\n        case Event.GET_DIGEST_STABLE:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n            return;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return;\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            hdr=(NakAckHeader)msg.getHeader(name);\n            if(hdr == null)\n                break;  // pass up (e.g. unicast msg)\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(log.isTraceEnabled())\n                    log.trace(\"message was discarded (not yet server)\");\n                return;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                return;\n\n            case NakAckHeader.XMIT_RSP:\n                if(log.isTraceEnabled())\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return;\n            }\n        }\n        passUp(evt);\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Causes the event to be forwarded to the next layer up in the hierarchy. Typically called\n     * by the implementation of <code>Up<\/code> (when done).\n     */\n    public void passUp(Event evt) {\n        if(observer != null) {                   // call debugger hook (if installed)\n            if(observer.passUp(evt) == false) {  // false means don't pass up (=discard) event\n                return;\n            }\n        }\n\n        if(up_prot != null) {\n            up_prot.receiveUpEvent(evt);\n            evt=null; // give the garbage collector a hand\n        }\n        else\n            if(log.isErrorEnabled()) log.error(\"no upper layer available\");\n    }","id":86517,"modified_method":"/**\n     * Causes the event to be forwarded to the next layer up in the hierarchy. Typically called\n     * by the implementation of <code>Up<\/code> (when done).\n     */\n    public void passUp(Event evt) {\n        if(observer != null) {                   // call debugger hook (if installed)\n            if(observer.passUp(evt) == false) {  // false means don't pass up (=discard) event\n                return;\n            }\n        }\n\n        if(up_prot != null) {\n            up_prot.receiveUpEvent(evt);\n        }\n        else\n            if(log.isErrorEnabled()) log.error(\"no upper layer available\");\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the up_handler thread\n     * is not available (down_thread == false), then directly call the up() method: we will run on the\n     * caller's thread (e.g. the protocol layer below us).\n     */\n    protected void receiveUpEvent(Event evt) {\n        if(up_handler == null) {\n            if(observer != null) {                               // call debugger hook (if installed)\n                if(observer.up(evt, up_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            up(evt);\n            return;\n        }\n        try {\n            up_queue.add(evt);\n            evt=null;\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","id":86518,"modified_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the up_handler thread\n     * is not available (down_thread == false), then directly call the up() method: we will run on the\n     * caller's thread (e.g. the protocol layer below us).\n     */\n    protected void receiveUpEvent(Event evt) {\n        if(up_handler == null) {\n            if(observer != null) {                               // call debugger hook (if installed)\n                if(observer.up(evt, up_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            up(evt);\n            return;\n        }\n        try {\n            up_queue.add(evt);\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Removes events from mq and calls handler.up(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                          // call debugger hook (if installed)\n                    if(observer.up(evt, mq.size()) == false) {  // false means discard event\n                        return;\n                    }\n                }\n                handler.up(evt);\n                evt=null;\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception: \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","id":86519,"modified_method":"/** Removes events from mq and calls handler.up(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                          // call debugger hook (if installed)\n                    if(observer.up(evt, mq.size()) == false) {  // false means discard event\n                        return;\n                    }\n                }\n                handler.up(evt);\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception: \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Removes events from mq and calls handler.down(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                            // call debugger hook (if installed)\n                    if(observer.down(evt, mq.size()) == false) {  // false means discard event\n                        continue;\n                    }\n                }\n\n                int type=evt.getType();\n                if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                    if(handler.handleSpecialDownEvent(evt) == false)\n                        continue;\n                }\n                handler.down(evt);\n                evt=null;\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception is \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","id":86520,"modified_method":"/** Removes events from mq and calls handler.down(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                            // call debugger hook (if installed)\n                    if(observer.down(evt, mq.size()) == false) {  // false means discard event\n                        continue;\n                    }\n                }\n\n                int type=evt.getType();\n                if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                    if(handler.handleSpecialDownEvent(evt) == false)\n                        continue;\n                }\n                handler.down(evt);\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception is \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the down_handler thread\n     * is not available (down_thread == false), then directly call the down() method: we will run on the\n     * caller's thread (e.g. the protocol layer above us).\n     */\n    protected void receiveDownEvent(Event evt) {\n        if(down_handler == null) {\n            if(observer != null) {                                    // call debugger hook (if installed)\n                if(observer.down(evt, down_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            int type=evt.getType();\n            if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                if(handleSpecialDownEvent(evt) == false)\n                    return;\n            }\n            down(evt);\n            return;\n        }\n        try {\n            down_queue.add(evt);\n            evt=null;\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","id":86521,"modified_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the down_handler thread\n     * is not available (down_thread == false), then directly call the down() method: we will run on the\n     * caller's thread (e.g. the protocol layer above us).\n     */\n    protected void receiveDownEvent(Event evt) {\n        if(down_handler == null) {\n            if(observer != null) {                                    // call debugger hook (if installed)\n                if(observer.down(evt, down_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            int type=evt.getType();\n            if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                if(handleSpecialDownEvent(evt) == false)\n                    return;\n            }\n            down(evt);\n            return;\n        }\n        try {\n            down_queue.add(evt);\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","commit_id":"2596c019c122f3efeae08d1fe89280a4a9f55b60","url":"https://github.com/belaban/JGroups"},{"original_method":"@AfterMethod\n    public void tearDown() throws Exception {\n\n        // stop the simulators\n        for(int i=0; i < NUM_PEERS; i++)\n            simulators[i].stop();\n    }","id":86522,"modified_method":"@AfterMethod\n    public void tearDown() throws Exception {\n        for(int i=0; i < NUM_PEERS; i++)\n            channels[i].close();\n    }","commit_id":"fd4949fb4cff133984e08d243c8986aab21c1471","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n\n            // senders send NUM_MSGS messages to all peers, beginning with seqno 1\n            if(sender) {\n\n                Address address=s.getLocalAddress();\n\n                // send a collection of dummy messages by mcast to the stack under test\n                for(int i=1; i <= NUM_MSGS; i++) {\n\n                    Message msg=new Message(null, address, new Long(i));\n                    Event evt=new Event(Event.MSG, msg);\n\n                    // call Simulator.send() to introduce the event into the stack under test\n                    s.send(evt);\n\n                    // status indicator\n                    if(i % MSGS_PER_STATUS_LINE == 0)\n                        System.out.println(\"<\" + address + \">:\" + \" ==> \" + i);\n                }\n            }\n\n            if(!sender) {\n                // wait for the receiver callback to signal that it has received messages, or timeout\n                // this just causes this thread to block until its receiver has finished\n                synchronized(all_msgs_recd) {\n                    try {\n                        all_msgs_recd.wait(WAIT_TIMEOUT * 1000);\n                    }\n                    catch(InterruptedException e) {\n                        System.out.println(\"main thread interrupted\");\n                    }\n                }\n            }\n        }","id":86523,"modified_method":"public void run() {\n\n            // senders send NUM_MSGS messages to all peers, beginning with seqno 1\n            if(sender) {\n                Address address=ch.getAddress();\n                for(int i=1; i <= NUM_MSGS; i++) {\n                    try {\n                        Message msg=new Message(null, address, new Long(i));\n                        ch.send(msg);\n                        if(i % MSGS_PER_STATUS_LINE == 0) // status indicator\n                            System.out.println(\"<\" + address + \">:\" + \" ==> \" + i);\n                    }\n                    catch(Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }","commit_id":"fd4949fb4cff133984e08d243c8986aab21c1471","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Set up a number of simulator instances wrapping NAKACK\n     */\n    @BeforeMethod\n    public void setUp() throws Exception {\n\n        // define the senders and the receivers\n        isSender[0]=false;\n        isSender[1]=true;\n        isSender[2]=true;\n\n        // dummy IP addresses and ports\n        for(int i=0; i < addresses.length; i++) {\n            UUID uuid=UUID.randomUUID();\n            UUID.add(uuid, \"node-\" + i);\n            addresses[i]=uuid;\n        }\n\n        // dummy set of members which works for all three simulators\n        members=new Vector<Address>();\n        members.addAll(Arrays.asList(addresses).subList(0, NUM_PEERS));\n\n        // create a dummy View(creator, timestamp, member set)\n        view=new View(addresses[0], 1, members);\n\n        // create new simulator instances\n        for(int i=0; i < NUM_PEERS; i++) {\n\n            // create the simulator instance\n\n            // at this stage, the ProtocolAdapter should be created and the timer present\n            simulators[i]=new Simulator();\n            simulators[i].setLocalAddress(addresses[i]);\n            simulators[i].setView(view);\n\n            // set up the protocol under test\n            layers[i]=new NAKACK();\n\n            // set up its properties\n            layers[i].setUseMcastXmit(true);\n\n            // our protocol stack under test consists of one protocol\n            stacks[i]=new Protocol[]{layers[i]};\n\n            // initalise the protocol stack\n            simulators[i].setProtocolStack(stacks[i]);\n        }\n\n        // describe the configuration of the three simulators\n        for(int i=0; i < NUM_PEERS; i++) {\n            for(int j=0; j < NUM_PEERS; j++) {\n                if(i == j)\n                    simulators[i].addMember(addresses[j]);\n                else\n                    simulators[i].addMember(addresses[j], simulators[j]);\n            }\n        }\n\n        // set up the receiver callbacks for each simulator\n        Simulator.Receiver[] receivers=new Simulator.Receiver[NUM_PEERS];\n\n        // set up the sender and the receiver callbacks, according to whether\n        // the peer is a sender or a receiver\n        for(int i=0; i < NUM_PEERS; i++) {\n\n            if(isSender[i])\n                receivers[i]=new SenderPeer(simulators[i]);\n            else\n                receivers[i]=new ReceiverPeer(simulators[i]);\n\n            simulators[i].setReceiver(receivers[i]);\n        }\n\n        // start the simulators\n        for(int i=0; i < NUM_PEERS; i++)\n            simulators[i].start();\n\n        MutableDigest digest=new MutableDigest(NUM_PEERS);\n        for(Address addr: addresses)\n            digest.add(new Digest(addr, 0, 0));\n        for(int i=0; i < NUM_PEERS; i++) {\n            layers[i].down(new Event(Event.SET_DIGEST, digest));\n        }\n\n    }","id":86524,"modified_method":"/**\n     * Set up a number of simulator instances wrapping NAKACK\n     */\n    @BeforeMethod\n    public void setUp() throws Exception {\n\n        // create new simulator instances\n        for(int i=0; i < NUM_PEERS; i++) {\n            channels[i]=createChannel();\n            channels[i].setName(Character.toString((char)(i + 'A')));\n            channels[i].connect(\"NakackTest\");\n        }\n\n        // set up the receiver callbacks for each simulator\n        Receiver[] receivers=new Receiver[NUM_PEERS];\n\n        // set up the sender and the receiver callbacks, according to whether the peer is a sender or a receiver\n        for(int i=0; i < NUM_PEERS; i++) {\n            if(isSender[i])\n                receivers[i]=new ReceiverPeer(channels[i]);\n            else\n                receivers[i]=new ReceiverPeer(channels[i]);\n            channels[i].setReceiver(receivers[i]);\n        }\n    }","commit_id":"fd4949fb4cff133984e08d243c8986aab21c1471","url":"https://github.com/belaban/JGroups"},{"original_method":"public MyNAKACKPeer(Simulator s, boolean sender) {\n            this.s=s;\n            this.sender=sender;\n        }","id":86525,"modified_method":"public MyNAKACKPeer(JChannel ch, boolean sender) {\n            this.ch=ch;\n            this.sender=sender;\n        }","commit_id":"fd4949fb4cff133984e08d243c8986aab21c1471","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Test to see thyat NAKACK delivery is reliable and FIFO.\n     */\n    public void testReceptionOfAllMessages() {\n\n\n        // start the NAKACK peers and let them exchange messages\n        for(int i=0; i < NUM_PEERS; i++) {\n\n            threads[i]=new MyNAKACKPeer(simulators[i], isSender[i]);\n            threads[i].start();\n        }\n\n        // wait for the receiver peer to signal that it has received messages, or timeout\n        synchronized(all_msgs_recd) {\n            try {\n                all_msgs_recd.wait(WAIT_TIMEOUT * 1000);\n            }\n            catch(InterruptedException e) {\n                System.out.println(\"main thread interrupted\");\n            }\n        }\n\n        // wait for the threads to terminate\n        try {\n            for(int i=0; i < NUM_PEERS; i++) {\n                threads[i].join();\n            }\n        }\n        catch(InterruptedException e) {\n        }\n\n        // the test fails if:\n        // - a seqno is received out of order (not FIFO), or\n        // - not all messages are received in time allotted (allMsgsReceived)\n        Assert.assertTrue(allMsgsReceived, \"Incorrect number of messages received by the receiver thread\");\n        Assert.assertFalse(notFIFO, \"Sequenece numbers for a peer not in correct order\");\n    }","id":86526,"modified_method":"/**\n     * Test to see thyat NAKACK delivery is reliable and FIFO.\n     */\n    public void testReceptionOfAllMessages() {\n        for(JChannel ch: channels)\n          assert ch.getView().size() == NUM_PEERS;\n\n        // start the NAKACK peers and let them exchange messages\n        for(int i=0; i < NUM_PEERS; i++) {\n            threads[i]=new MyNAKACKPeer(channels[i], isSender[i]);\n            threads[i].start();\n        }\n\n        // wait for the receiver peer to signal that it has received messages, or timeout\n        synchronized(all_msgs_recd) {\n            try {\n                all_msgs_recd.wait(WAIT_TIMEOUT * 1000);\n            }\n            catch(InterruptedException e) {\n                System.out.println(\"main thread interrupted\");\n            }\n        }\n\n        // wait for the threads to terminate\n        try {\n            for(int i=0; i < NUM_PEERS; i++) {\n                threads[i].join();\n            }\n        }\n        catch(InterruptedException e) {\n        }\n\n        // the test fails if:\n        // - a seqno is received out of order (not FIFO), or\n        // - not all messages are received in time allotted (allMsgsReceived)\n        Assert.assertTrue(allMsgsReceived, \"Incorrect number of messages received by the receiver thread\");\n        Assert.assertFalse(notFIFO, \"Sequenece numbers for a peer not in correct order\");\n    }","commit_id":"fd4949fb4cff133984e08d243c8986aab21c1471","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        Object obj;\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch(evt.getType()) {\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.GET_DIGEST:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_OK, digest));\n            return;\n\n        case Event.GET_DIGEST_STABLE:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n            return;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return;\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            obj=msg.getHeader(name);\n            if(obj == null || !(obj instanceof NakAckHeader)) {\n                break;  // pass up (e.g. unicast msg)\n            }\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(log.isDebugEnabled()) {\n                    log.debug(\"message was discarded (not yet server)\");\n                }\n                return;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n            hdr=(NakAckHeader)obj;\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                return;\n\n            case NakAckHeader.XMIT_RSP:\n                if(log.isTraceEnabled())\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return;\n            }\n        }\n        passUp(evt);\n    }","id":86527,"modified_method":"/**\n     * <b>Callback<\/b>. Called by superclass when event may be handled.<p> <b>Do not use <code>PassUp<\/code> in this\n     * method as the event is passed up by default by the superclass after this method returns !<\/b>\n     */\n    public void up(Event evt) {\n        NakAckHeader hdr;\n        Message msg;\n        Digest digest;\n\n        switch(evt.getType()) {\n\n        case Event.STABLE:  // generated by STABLE layer. Delete stable messages passed in arg\n            stable((Digest)evt.getArg());\n            return;  // do not pass up further (Bela Aug 7 2001)\n\n        case Event.GET_DIGEST:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_OK, digest));\n            return;\n\n        case Event.GET_DIGEST_STABLE:\n            digest=getDigestHighestDeliveredMsgs();\n            passDown(new Event(Event.GET_DIGEST_STABLE_OK, digest));\n            return;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.CONFIG:\n            passUp(evt);\n            if(log.isDebugEnabled()) {\n                log.debug(\"received CONFIG event: \" + evt.getArg());\n            }\n            handleConfigEvent((HashMap)evt.getArg());\n            return;\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            hdr=(NakAckHeader)msg.getHeader(name);\n            if(hdr == null)\n                break;  // pass up (e.g. unicast msg)\n\n            // discard messages while not yet server (i.e., until JOIN has returned)\n            if(!is_server) {\n                if(log.isTraceEnabled())\n                    log.trace(\"message was discarded (not yet server)\");\n                return;\n            }\n\n            // Changed by bela Jan 29 2003: we must not remove the header, otherwise\n            // further xmit requests will fail !\n            //hdr=(NakAckHeader)msg.removeHeader(getName());\n\n            switch(hdr.type) {\n\n            case NakAckHeader.MSG:\n                handleMessage(msg, hdr);\n                return;        // transmitter passes message up for us !\n\n            case NakAckHeader.XMIT_REQ:\n                if(hdr.range == null) {\n                    if(log.isErrorEnabled()) {\n                        log.error(\"XMIT_REQ: range of xmit msg is null; discarding request from \" + msg.getSrc());\n                    }\n                    return;\n                }\n                handleXmitReq(msg.getSrc(), hdr.range.low, hdr.range.high);\n                return;\n\n            case NakAckHeader.XMIT_RSP:\n                if(log.isTraceEnabled())\n                    log.trace(\"received missing messages \" + hdr.range);\n                handleXmitRsp(msg);\n                return;\n\n            default:\n                if(log.isErrorEnabled()) {\n                    log.error(\"NakAck header type \" + hdr.type + \" not known !\");\n                }\n                return;\n            }\n        }\n        passUp(evt);\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win=null;\n        Message msg_to_deliver;\n        Address sender;\n\n        if(msg == null || hdr == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"msg or header is null\");\n            }\n            return;\n        }\n        sender=msg.getSrc();\n        if(sender == null) {\n            if(log.isErrorEnabled()) {\n                log.error(\"sender of message is null\");\n            }\n            return;\n        }\n\n        if(log.isTraceEnabled()) {\n            log.trace(\"[\" + local_addr + \"] received \" + sender + '#' + hdr.seqno);\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving) {\n                return;\n            }\n            if(log.isWarnEnabled()) {\n                log.warn(\"[\" + local_addr + \"] discarded message from non-member \" + sender);\n            }\n            return;\n        }\n        win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n        msg=null;\n\n        while((msg_to_deliver=win.remove()) != null) {\n\n            // Changed by bela Jan 29 2003: not needed (see above)\n            //msg_to_deliver.removeHeader(getName());\n\n            passUp(new Event(Event.MSG, msg_to_deliver));\n            msg_to_deliver=null;\n        }\n    }","id":86528,"modified_method":"/**\n     * Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes as many\n     * messages as possible from the NRW and passes them up the stack. Discards messages from non-members.\n     */\n    void handleMessage(Message msg, NakAckHeader hdr) {\n        NakReceiverWindow win;\n        Message msg_to_deliver;\n        Address sender=msg.getSrc();\n\n        if(sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"sender of message is null\");\n            return;\n        }\n\n        if(log.isTraceEnabled()) {\n            StringBuffer sb=new StringBuffer('[');\n            sb.append(local_addr).append(\"] received \").append(sender).append('#').append(hdr.seqno);\n            log.trace(sb.toString());\n        }\n\n        // msg is potentially re-sent later as result of XMIT_REQ reception; that's why hdr is added !\n\n        // Changed by bela Jan 29 2003: we currently don't resend from received msgs, just from sent_msgs !\n        // msg.putHeader(getName(), hdr);\n\n        synchronized(received_msgs) {\n            win=(NakReceiverWindow)received_msgs.get(sender);\n        }\n        if(win == null) {  // discard message if there is no entry for sender\n            if(leaving)\n                return;\n            if(log.isWarnEnabled()) {\n                StringBuffer sb=new StringBuffer('[');\n                sb.append(local_addr).append(\"] discarded message from non-member \").append(sender);\n                if(log.isWarnEnabled())\n                    log.warn(sb.toString());\n            }\n            return;\n        }\n        win.add(hdr.seqno, msg);  // add in order, then remove and pass up as many msgs as possible\n\n        while((msg_to_deliver=win.remove()) != null) {\n\n            // Changed by bela Jan 29 2003: not needed (see above)\n            //msg_to_deliver.removeHeader(getName());\n            passUp(new Event(Event.MSG, msg_to_deliver));\n        }\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Causes the event to be forwarded to the next layer up in the hierarchy. Typically called\n     * by the implementation of <code>Up<\/code> (when done).\n     */\n    public void passUp(Event evt) {\n        if(observer != null) {                   // call debugger hook (if installed)\n            if(observer.passUp(evt) == false) {  // false means don't pass up (=discard) event\n                return;\n            }\n        }\n\n        if(up_prot != null) {\n            up_prot.receiveUpEvent(evt);\n            evt=null; // give the garbage collector a hand\n        }\n        else\n            if(log.isErrorEnabled()) log.error(\"no upper layer available\");\n    }","id":86529,"modified_method":"/**\n     * Causes the event to be forwarded to the next layer up in the hierarchy. Typically called\n     * by the implementation of <code>Up<\/code> (when done).\n     */\n    public void passUp(Event evt) {\n        if(observer != null) {                   // call debugger hook (if installed)\n            if(observer.passUp(evt) == false) {  // false means don't pass up (=discard) event\n                return;\n            }\n        }\n\n        if(up_prot != null) {\n            up_prot.receiveUpEvent(evt);\n        }\n        else\n            if(log.isErrorEnabled()) log.error(\"no upper layer available\");\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Removes events from mq and calls handler.down(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                            // call debugger hook (if installed)\n                    if(observer.down(evt, mq.size()) == false) {  // false means discard event\n                        continue;\n                    }\n                }\n\n                int type=evt.getType();\n                if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                    if(handler.handleSpecialDownEvent(evt) == false)\n                        continue;\n                }\n                handler.down(evt);\n                evt=null;\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception is \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","id":86530,"modified_method":"/** Removes events from mq and calls handler.down(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                            // call debugger hook (if installed)\n                    if(observer.down(evt, mq.size()) == false) {  // false means discard event\n                        continue;\n                    }\n                }\n\n                int type=evt.getType();\n                if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                    if(handler.handleSpecialDownEvent(evt) == false)\n                        continue;\n                }\n                handler.down(evt);\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception is \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the up_handler thread\n     * is not available (down_thread == false), then directly call the up() method: we will run on the\n     * caller's thread (e.g. the protocol layer below us).\n     */\n    protected void receiveUpEvent(Event evt) {\n        if(up_handler == null) {\n            if(observer != null) {                               // call debugger hook (if installed)\n                if(observer.up(evt, up_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            up(evt);\n            return;\n        }\n        try {\n            up_queue.add(evt);\n            evt=null;\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","id":86531,"modified_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the up_handler thread\n     * is not available (down_thread == false), then directly call the up() method: we will run on the\n     * caller's thread (e.g. the protocol layer below us).\n     */\n    protected void receiveUpEvent(Event evt) {\n        if(up_handler == null) {\n            if(observer != null) {                               // call debugger hook (if installed)\n                if(observer.up(evt, up_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            up(evt);\n            return;\n        }\n        try {\n            up_queue.add(evt);\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Removes events from mq and calls handler.up(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                          // call debugger hook (if installed)\n                    if(observer.up(evt, mq.size()) == false) {  // false means discard event\n                        return;\n                    }\n                }\n                handler.up(evt);\n                evt=null;\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception: \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","id":86532,"modified_method":"/** Removes events from mq and calls handler.up(evt) */\n    public void run() {\n        Event evt;\n        while(!mq.closed()) {\n            try {\n                evt=(Event)mq.remove();\n                if(evt == null) {\n                    if(log.isWarnEnabled()) log.warn(\"removed null event\");\n                    continue;\n                }\n\n                if(observer != null) {                          // call debugger hook (if installed)\n                    if(observer.up(evt, mq.size()) == false) {  // false means discard event\n                        return;\n                    }\n                }\n                handler.up(evt);\n            }\n            catch(QueueClosedException queue_closed) {\n                break;\n            }\n            catch(Throwable e) {\n                if(log.isWarnEnabled()) log.warn(getName() + \" exception: \" + e);\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the down_handler thread\n     * is not available (down_thread == false), then directly call the down() method: we will run on the\n     * caller's thread (e.g. the protocol layer above us).\n     */\n    protected void receiveDownEvent(Event evt) {\n        if(down_handler == null) {\n            if(observer != null) {                                    // call debugger hook (if installed)\n                if(observer.down(evt, down_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            int type=evt.getType();\n            if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                if(handleSpecialDownEvent(evt) == false)\n                    return;\n            }\n            down(evt);\n            return;\n        }\n        try {\n            down_queue.add(evt);\n            evt=null;\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","id":86533,"modified_method":"/**\n     * Internal method, should not be called by clients. Used by ProtocolStack. I would have\n     * used the 'friends' modifier, but this is available only in C++ ... If the down_handler thread\n     * is not available (down_thread == false), then directly call the down() method: we will run on the\n     * caller's thread (e.g. the protocol layer above us).\n     */\n    protected void receiveDownEvent(Event evt) {\n        if(down_handler == null) {\n            if(observer != null) {                                    // call debugger hook (if installed)\n                if(observer.down(evt, down_queue.size()) == false) {  // false means discard event\n                    return;\n                }\n            }\n            int type=evt.getType();\n            if(type == Event.ACK || type == Event.START || type == Event.STOP) {\n                if(handleSpecialDownEvent(evt) == false)\n                    return;\n            }\n            down(evt);\n            return;\n        }\n        try {\n            down_queue.add(evt);\n        }\n        catch(Exception e) {\n            if(log.isWarnEnabled()) log.warn(\"exception: \" + e);\n        }\n    }","commit_id":"479f9fb75757aac6a7cc677a70d8bbd1f1672cad","url":"https://github.com/belaban/JGroups"},{"original_method":"public Tab() {\n\t\tsetMoldSclass(\"z-tab\");\n\t\tUtils.updateMoldByTheme(this);\n\t}","id":86534,"modified_method":"public Tab() {\n\t\tsetMoldSclass(\"z-tab\");\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns the style class. Note: 1) if not specified (or\n\t * setSclass(null))<br/> 1.1) if not disabled ,\"tab\" is assumed; <br/> 1.2)\n\t * if disabled ,\"tabdis\" is assumed; <br/> 2) if selected, it appends \"sel\"\n\t * to step 1. <br/>\n\t */\n\tpublic String getRealSclass() {\n\t\tfinal String mold = super.getMold();\n\t\tString scls = null;\n\t\tif (mold.equals(\"v30\")) {\n\t\t\tscls = super.getSclass();\n\t\t\tif (scls == null)\n\t\t\t\tscls = \"tab\";\n\t\t\tif (isDisabled())\n\t\t\t\tscls = scls + \"dis\";\n\t\t\treturn isSelected() ? scls + \"sel\" : scls;\n\t\t} else {\n\t\t\tscls = super.getMoldSclass();\n\t\t\tif (scls == null)\n\t\t\t\tscls = \"z-tab\";\n\t\t\tif (isDisabled())\n\t\t\t\tscls = scls + \"dis\";\n\t\t\treturn isSelected() ? scls + \"sel\" : scls;\n\t\t}\n\t}","id":86535,"modified_method":"/**\n\t * Returns the style class. Note: 1) if not specified (or\n\t * setSclass(null))<br/> 1.1) if not disabled ,\"tab\" is assumed; <br/> 1.2)\n\t * if disabled ,\"tabdis\" is assumed; <br/> 2) if selected, it appends \"sel\"\n\t * to step 1. <br/>\n\t */\n\tpublic String getRealSclass() {\n\t\tfinal String mold = super.getMold();\n\t\tString scls = super.getMoldSclass();\n\t\tif (scls == null)\n\t\t\tscls = \"z-tab\";\n\t\tif (isDisabled())\n\t\t\tscls = scls + \"dis\";\n\t\treturn isSelected() ? scls + \"sel\" : scls;\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"public void invalidate() {\n\t\tfinal Tabbox tabbox = getTabbox();\n\t\tif (tabbox != null && \n\t\t\t\t(\"accordion\".equals(tabbox.getMold())||\"accordion-lite\".equals(tabbox.getMold()))) {\n\t\t\ttabbox.invalidate();\t\t\t\n\t\t} else {\t\t\t\n\t\t\tsuper.invalidate();\n\t\t}\n\t}","id":86536,"modified_method":"public void invalidate() {\n\t\tfinal Tabbox tabbox = getTabbox();\n\t\tif (tabbox != null && tabbox.inAccordionMold()) {\n\t\t\ttabbox.invalidate();\t\t\t\n\t\t} else {\t\t\t\n\t\t\tsuper.invalidate();\n\t\t}\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns the look of the {@link Tab} and {@link Tabbox}. It is, in fact, a\n\t * portion of the style class that are used to generate the style of\n\t * {@link Tabs} and {@link Tab}.\n\t * \n\t * <p>\n\t * If the style class ({@link #getSclass}) of this tab box is not defined\n\t * and the mold is default, \"tab-3d\" and \"tab-v3d\" are returned for\n\t * horizontal and vertical orient, respectively. If the style class not\n\t * defined and the mold is accordion, \"tabaccd-3d\" and \"tabaccd-v3d\"\n\t * returned (note: accordion doesn't support vertical yet).\n\t * \n\t * <p>\n\t * If the style class is defined, say \"lite\", then this method return\n\t * \"tab-lite\" and \"tab-vlite\" for horizontal and vertical orient,\n\t * respectively, and \"tabacc-lite\" for horizontal accordion.\n\t * \n\t * <p>\n\t * If the mold is not \"default\" nor \"accordion\", this method returns \"tab\" +\n\t * getMold() + \"-\" + (vertical ? 'v': '') + getSclass().\n\t * \n\t * <p>\n\t * With this method, {@link Tab} and {@link Tabpanel} generate the style\n\t * class accordingly. For example, if the mold is \"default\" and the style\n\t * class not defined, then \"tab-3d-tl-sel\" for the top-left corner of the\n\t * selected tab, \"tab-3d-tm-uns\" for the top-middle border of the\n\t * non-selected tab, and so on.\n\t * \n\t * @since 3.0,0\n\t */\n\tpublic String getTabLook() {\n\t\tfinal String mold = getMold();\n\t\tString prefix = \"\";\n\t\tString scls = \"\";\n\t\tif (mold.equals(\"v30\")) {\n\t\t\tprefix = \"v30\".equals(mold) ? \"tab-\"\n\t\t\t\t\t: \"v30-accordion\".equals(mold) ? \"tabaccd-\" : \"tab\" + mold\n\t\t\t\t\t\t\t+ '-';\n\t\t\tif (\"v30-vertical\".equals(_orient))\n\t\t\t\tprefix += 'v';\n\t\t\tscls = getSclass();\n\t\t\treturn scls != null && scls.length() > 0 ? prefix + scls : prefix\n\t\t\t\t\t+ \"3d\";\n\t\t} else {\n\t\t\tprefix = \"vertical\".equals(_orient) ? \"v\" : \"\"\n\t\t\t\t\t+ (\"default\".equals(mold) ? \"\" : \"accordion\".equals(mold)\n\t\t\t\t\t\t\t|| \"accordion-lite\".equals(mold) ? \"\" : \"tab\"\n\t\t\t\t\t\t\t+ mold + '-');\n\t\t\tscls = getMoldSclass();\n\t\t\treturn prefix + scls ;\n\t\t}\n\t\t\n\t\n\t}","id":86537,"modified_method":"/**\n\t * Returns the look of the {@link Tab} and {@link Tabbox}. It is, in fact, a\n\t * portion of the style class that are used to generate the style of\n\t * {@link Tabs} and {@link Tab}.\n\t * \n\t * <p>\n\t * If the style class ({@link #getSclass}) of this tab box is not defined\n\t * and the mold is default, \"tab-3d\" and \"tab-v3d\" are returned for\n\t * horizontal and vertical orient, respectively. If the style class not\n\t * defined and the mold is accordion, \"tabaccd-3d\" and \"tabaccd-v3d\"\n\t * returned (note: accordion doesn't support vertical yet).\n\t * \n\t * <p>\n\t * If the style class is defined, say \"lite\", then this method return\n\t * \"tab-lite\" and \"tab-vlite\" for horizontal and vertical orient,\n\t * respectively, and \"tabacc-lite\" for horizontal accordion.\n\t * \n\t * <p>\n\t * If the mold is not \"default\" nor \"accordion\", this method returns \"tab\" +\n\t * getMold() + \"-\" + (vertical ? 'v': '') + getSclass().\n\t * \n\t * <p>\n\t * With this method, {@link Tab} and {@link Tabpanel} generate the style\n\t * class accordingly. For example, if the mold is \"default\" and the style\n\t * class not defined, then \"tab-3d-tl-sel\" for the top-left corner of the\n\t * selected tab, \"tab-3d-tm-uns\" for the top-middle border of the\n\t * non-selected tab, and so on.\n\t * \n\t * @since 3.0.0\n\t */\n\tpublic String getTabLook() {\n\t\tfinal String mold = getMold();\n\t\tString prefix = \"vertical\".equals(_orient) ? \"v\" : \"\"\n\t\t\t+ (\"default\".equals(mold) ? \"\" :\n\t\t\t\tmold.startsWith(\"accordion\") ? \"\" : \"tab\" + mold + '-');\n\t\tString scls = getMoldSclass();\n\t\treturn scls != null ? prefix + scls: prefix;\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"private void init() {\n\t\tUtils.updateMoldByTheme(this);\n\t\t_listener = new Listener();\n\t}","id":86538,"modified_method":"private void init() {\n\t\t_listener = new Listener();\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb = new StringBuffer(64).append(super\n\t\t\t\t.getOuterAttrs());\n\t\tappendAsapAttr(sb, Events.ON_RIGHT_CLICK);\n\t\t// no z.dbclk/z.lfclk since it is covered by both Tab and Tabpanel\n\n\t\tif (isVertical())\n\t\t\tHTMLs.appendAttribute(sb, \"z.orient\", \"v\");\n\t\tif (_tabs != null && !inAccordionMold())\n\t\t\tHTMLs.appendAttribute(sb, \"z.tabs\", _tabs.getUuid());\n\t\tif (_tabscroll)\n\t\t\tHTMLs.appendAttribute(sb, \"z.tabscroll\", _tabscroll);\n\t\treturn sb.toString();\n\t}","id":86539,"modified_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb = new StringBuffer(64).append(super\n\t\t\t\t.getOuterAttrs());\n\t\tappendAsapAttr(sb, Events.ON_RIGHT_CLICK);\n\t\t// no z.dbclk/z.lfclk since it is covered by both Tab and Tabpanel\n\n\t\tif (isVertical())\n\t\t\tHTMLs.appendAttribute(sb, \"z.orient\", \"v\");\n\t\tif (_tabs != null && !inAccordionMold())\n\t\t\tHTMLs.appendAttribute(sb, \"z.tabs\", _tabs.getUuid());\n\t\tif (_tabscroll)\n\t\t\tHTMLs.appendAttribute(sb, \"z.tabscrl\", _tabscroll);\n\t\treturn sb.toString();\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Returns whether it is in the accordion mold.\n\t */\n\t/* package */boolean inAccordionMold() {\n\n\t\treturn (\"accordion\".equals(getMold())\n\t\t\t\t|| \"accordion-lite\".equals(getMold()) || \"v30-accordion\"\n\t\t\t\t.equals(getMold()));\n\t}","id":86540,"modified_method":"/**\n\t * Returns whether it is in the accordion mold.\n\t */\n\t/* package */boolean inAccordionMold() {\n\t\treturn getMold().startsWith(\"accordion\");\n\t}","commit_id":"55f06c43e7d36b1532ec4974de1a1e3ce83d0c1a","url":"https://github.com/zkoss/zk"},{"original_method":"private void setDegree(final HashSet<PsiTypeVariable> set, Map<PsiTypeVariable, Integer> result) {\n    for (final Iterator<PsiTypeVariable> v = set.iterator(); v.hasNext();) {\n      final PsiTypeVariable var = v.next();\n      final Integer deg = result.get(var);\n\n      if (deg == null) {\n        result.put(var, new Integer(1));\n      }\n      else {\n        result.put(var, new Integer(deg.intValue() + 1));\n      }\n    }\n  }","id":86541,"modified_method":"private void setDegree(final HashSet<PsiTypeVariable> set, TObjectIntHashMap<PsiTypeVariable> result) {\n    for (final Iterator<PsiTypeVariable> v = set.iterator(); v.hasNext();) {\n      final PsiTypeVariable var = v.next();\n      result.increment(var);\n    }\n  }","commit_id":"2213aadf945da1b98866ede2398e3216b509f804","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isBoundElseWhere(final PsiTypeVariable var) {\n    final Integer deg = myBindingDegree.get(var);\n\n    return deg == null || deg.intValue() > 1;\n  }","id":86542,"modified_method":"private boolean isBoundElseWhere(final PsiTypeVariable var) {\n    return myBindingDegree.get(var) > 1 ;\n  }","commit_id":"2213aadf945da1b98866ede2398e3216b509f804","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private HashMap<PsiTypeVariable, Integer> calculateDegree() {\n    final HashMap<PsiTypeVariable, Integer> result = new HashMap<PsiTypeVariable, Integer>();\n\n    for (final Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n\n      final PsiTypeVarCollector collector = new PsiTypeVarCollector();\n\n      setDegree(collector.getSet(constr.getRight()), result);\n    }\n\n    return result;\n  }","id":86543,"modified_method":"private TObjectIntHashMap<PsiTypeVariable> calculateDegree() {\n    final TObjectIntHashMap<PsiTypeVariable> result = new TObjectIntHashMap<PsiTypeVariable>();\n\n    for (final Iterator<Constraint> c = myConstraints.iterator(); c.hasNext();) {\n      final Constraint constr = c.next();\n\n      final PsiTypeVarCollector collector = new PsiTypeVarCollector();\n\n      setDegree(collector.getSet(constr.getRight()), result);\n    }\n\n    return result;\n  }","commit_id":"2213aadf945da1b98866ede2398e3216b509f804","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"unchecked\"})\r\n    private void showStats(HttpServletRequest req, HttpServletResponse resp, PersistenceManager pm)\r\n            throws IOException {\r\n        List<DbEvaluation> evals = (List<DbEvaluation>) pm.newQuery(\"select from \" + persistenceHelper.getDbEvaluationClass().getName()\r\n                    + \" order by when\").execute();\r\n        Map<String,Integer> totalCountByUser = new HashMap<String, Integer>();\r\n        Map<String,Integer> issueCountByUser = new HashMap<String, Integer>();\r\n        Multimap<String, String> issuesByUser = Multimaps.newSetMultimap(Maps.<String, Collection<String>>newHashMap(), new Supplier<Set<String>>() {\r\n            public Set<String> get() {\r\n                return Sets.newHashSet();\r\n            }\r\n        });\r\n        Map<Long,Integer> evalsByWeek = Maps.newHashMap();\r\n\r\n        for (DbEvaluation eval : evals) {\r\n            String email = eval.getEmail();\r\n            if (email == null)\r\n                continue;\r\n            issuesByUser.put(email, eval.getIssue().getHash());\r\n            Integer count = totalCountByUser.get(email);\r\n            if (count == null) count = 0;\r\n            totalCountByUser.put(email, count + 1);\r\n            issueCountByUser.put(email, issuesByUser.get(email).size());\r\n\r\n            long beginningOfWeek = getBeginningOfWeekInMillis(eval.getWhen());\r\n            Integer oldCount = evalsByWeek.get(beginningOfWeek);\r\n            evalsByWeek.put(beginningOfWeek, (oldCount == null ? 0 : oldCount) + 1);\r\n        }\r\n\r\n        BarChart issuesByUserChart = buildByUserChart(issueCountByUser);\r\n        issuesByUserChart.setTitle(\"Issues Evaluated by User\");\r\n        BarChart evalsByUserChart = buildByUserChart(totalCountByUser);\r\n        evalsByUserChart.setTitle(\"Total Evaluations by User\");\r\n\r\n        LineChart evalsOverTimeChart = createEvalsByWeekChart(evalsByWeek);\r\n        evalsOverTimeChart.setTitle(\"Evaluations Submitted\");\r\n\r\n        resp.setStatus(200);\r\n\r\n        resp.getOutputStream().print(\"<html>\" +\r\n                                     \"<head><title>FindBugs Cloud Stats<\/title><\/head>\" +\r\n                                     \"<body>\");\r\n        showChartImg(resp, evalsOverTimeChart.toURLString());\r\n        resp.getOutputStream().print(\"<br><br>\");\r\n        showChartImg(resp, evalsByUserChart.toURLString());\r\n        showChartImg(resp, issuesByUserChart.toURLString());\r\n    }","id":86544,"modified_method":"@SuppressWarnings({\"unchecked\"})\r\n    private void showStats(HttpServletRequest req, HttpServletResponse resp, PersistenceManager pm)\r\n            throws IOException {\r\n        List<DbEvaluation> evals = (List<DbEvaluation>) pm.newQuery(\"select from \" + persistenceHelper.getDbEvaluationClass().getName()\r\n                    + \" order by when\").execute();\r\n        Map<String,Integer> totalCountByUser = new HashMap<String, Integer>();\r\n        Map<String,Integer> issueCountByUser = new HashMap<String, Integer>();\r\n        Multimap<String, String> issuesByUser = Multimaps.newSetMultimap(Maps.<String, Collection<String>>newHashMap(), new Supplier<Set<String>>() {\r\n            public Set<String> get() {\r\n                return Sets.newHashSet();\r\n            }\r\n        });\r\n        Map<Long,Integer> evalsByWeek = Maps.newHashMap();\r\n\r\n        for (DbEvaluation eval : evals) {\r\n            String email = eval.getEmail();\r\n            if (email == null)\r\n                continue;\r\n\r\n            issuesByUser.put(email, eval.getIssue().getHash());\r\n            increment(totalCountByUser, email);\r\n            issueCountByUser.put(email, issuesByUser.get(email).size());\r\n\r\n            long beginningOfWeek = getBeginningOfWeekInMillis(eval.getWhen());\r\n            increment(evalsByWeek, beginningOfWeek);\r\n        }\r\n\r\n        BarChart evalsByUserChart = buildByUserChart(totalCountByUser, issueCountByUser);\r\n\r\n        LineChart evalsOverTimeChart = createEvalsByWeekChart(evalsByWeek);\r\n        evalsOverTimeChart.setTitle(\"Evaluations Submitted\");\r\n\r\n        resp.setStatus(200);\r\n\r\n        resp.getOutputStream().print(\"<html>\" +\r\n                                     \"<head><title>FindBugs Cloud Stats<\/title><\/head>\" +\r\n                                     \"<body>\");\r\n        showChartImg(resp, evalsOverTimeChart.toURLString());\r\n        resp.getOutputStream().print(\"<br><br>\");\r\n        showChartImg(resp, evalsByUserChart.toURLString());\r\n    }","commit_id":"a66c7b8772dc430b1277a8c7aff198c505f54bbe","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private LineChart createEvalsByWeekChart(Map<Long, Integer> evalsByWeek) {\r\n        long first = Collections.min(evalsByWeek.keySet());\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.setTimeInMillis(first);\r\n        long last = Collections.max(evalsByWeek.keySet());\r\n        List<Double> byWeekData = new ArrayList<Double>();\r\n        List<String> labels = Lists.newArrayList();\r\n        int maxPerWeek = Collections.max(evalsByWeek.values());\r\n        for (; cal.getTimeInMillis() <= last; cal.add(Calendar.DAY_OF_MONTH, 7)) {\r\n            Integer count = evalsByWeek.get(cal.getTimeInMillis());\r\n            count = count == null ? 0 : count;\r\n            byWeekData.add(count * 100.0 / maxPerWeek);\r\n            labels.add(DATE_FORMAT.format(new Date(cal.getTimeInMillis())));\r\n        }\r\n\r\n        Line line = Plots.newLine(Data.newData(byWeekData));\r\n        line.setFillAreaColor(Color.BEIGE);\r\n        LineChart evalsOverTimeChart = GCharts.newLineChart(line);\r\n        evalsOverTimeChart.setDataEncoding(DataEncoding.TEXT);\r\n        evalsOverTimeChart.setSize(600, 250);\r\n        evalsOverTimeChart.addYAxisLabels(AxisLabelsFactory.newNumericRangeAxisLabels(0, maxPerWeek));\r\n        evalsOverTimeChart.addXAxisLabels(AxisLabelsFactory.newAxisLabels(labels));\r\n        return evalsOverTimeChart;\r\n    }","id":86545,"modified_method":"private LineChart createEvalsByWeekChart(Map<Long, Integer> evalsByWeek) {\r\n        long first = Collections.min(evalsByWeek.keySet());\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.setTimeInMillis(first);\r\n        long last = Collections.max(evalsByWeek.keySet());\r\n        List<Double> byWeekData = new ArrayList<Double>();\r\n        List<String> labels = Lists.newArrayList();\r\n        int maxPerWeek = Collections.max(evalsByWeek.values());\r\n        for (; cal.getTimeInMillis() <= last; cal.add(Calendar.DAY_OF_MONTH, 7)) {\r\n            Integer count = evalsByWeek.get(cal.getTimeInMillis());\r\n            count = count == null ? 0 : count;\r\n            byWeekData.add(count * 100.0 / maxPerWeek);\r\n            labels.add(DATE_FORMAT.format(new Date(cal.getTimeInMillis())));\r\n        }\r\n\r\n        Line line = Plots.newLine(Data.newData(byWeekData));\r\n        line.setFillAreaColor(Color.BEIGE);\r\n        LineChart chart = GCharts.newLineChart(line);\r\n        chart.setDataEncoding(DataEncoding.TEXT);\r\n        chart.setSize(600, 250);\r\n        chart.setGrid(100, 10 / (maxPerWeek / 100.0), 4, 1);\r\n        chart.addYAxisLabels(AxisLabelsFactory.newNumericRangeAxisLabels(0, maxPerWeek));\r\n        chart.addXAxisLabels(AxisLabelsFactory.newAxisLabels(labels));\r\n        return chart;\r\n    }","commit_id":"a66c7b8772dc430b1277a8c7aff198c505f54bbe","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private BarChart buildByUserChart(Map<String, Integer> countByUser) {\r\n        List<String> labels = new ArrayList<String>();\r\n        List<Double> values = new ArrayList<Double>();\r\n        int max = Collections.max(countByUser.values());\r\n        for (Entry<String, Integer> entry : sortEntries(countByUser.entrySet())) {\r\n            String email = entry.getKey();\r\n            int count = entry.getValue();\r\n            labels.add(email + \" (\" + count + \")\");\r\n            values.add(count * 100.0 / max);\r\n        }\r\n\r\n        Collections.reverse(values);\r\n        BarChart chart = GCharts.newBarChart(Plots.newBarChartPlot(Data.newData(values)));\r\n        chart.addYAxisLabels(AxisLabelsFactory.newAxisLabels(labels));\r\n        chart.addXAxisLabels(AxisLabelsFactory.newNumericRangeAxisLabels(0, max));\r\n        chart.setBarWidth(BarChart.AUTO_RESIZE);\r\n        chart.setSize(600, 500);\r\n        chart.setHorizontal(true);\r\n        chart.setDataEncoding(DataEncoding.TEXT);\r\n        return chart;\r\n    }","id":86546,"modified_method":"private BarChart buildByUserChart(Map<String, Integer> totalCountByUser,\r\n                                      Map<String, Integer> issueCountByUser) {\r\n        List<String> labels = Lists.newArrayList();\r\n        List<Double> totals = Lists.newArrayList();\r\n        List<Double> issues = Lists.newArrayList();\r\n        int max = Collections.max(totalCountByUser.values());\r\n        for (Entry<String, Integer> entry : sortEntries(totalCountByUser.entrySet())) {\r\n            String email = entry.getKey();\r\n            int issueCount = issueCountByUser.get(email);\r\n            int evalCount = entry.getValue();\r\n            labels.add(email);\r\n            totals.add((evalCount - issueCount) * 100.0 / max);\r\n            issues.add(issueCount * 100.0 / max);\r\n        }\r\n\r\n        Collections.reverse(totals);\r\n        Collections.reverse(issues);\r\n        BarChart chart = GCharts.newBarChart(Plots.newBarChartPlot(Data.newData(issues), Color.DARKORCHID, \"New evals\"),\r\n                                             Plots.newBarChartPlot(Data.newData(totals), Color.ORCHID, \"Eval updates\"));\r\n\r\n        chart.setDataStacked(true);\r\n        chart.setGrid(20.0 / (max / 100.0), 100, 4, 1);\r\n        chart.addYAxisLabels(AxisLabelsFactory.newAxisLabels(labels));\r\n        chart.addXAxisLabels(AxisLabelsFactory.newNumericRangeAxisLabels(0, max));\r\n        chart.setBarWidth(BarChart.AUTO_RESIZE);\r\n        chart.setSize(600, 500);\r\n        chart.setHorizontal(true);\r\n        chart.setDataEncoding(DataEncoding.TEXT);\r\n        return chart;\r\n    }","commit_id":"a66c7b8772dc430b1277a8c7aff198c505f54bbe","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphEvalsByUser() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        createEvaluation(foundIssue, \"someone\", 100);\r\n        createEvaluation(foundIssue, \"someone-else\", 200);\r\n        createEvaluation(foundIssue, \"someone\", 300);\r\n        createEvaluation(foundIssue, \"someone3\", 300);\r\n        createEvaluation(foundIssue, \"someone3\", 300);\r\n        createEvaluation(foundIssue, \"someone3\", 300);\r\n        \r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(1);\r\n        checkParam(url, \"chxl\", \"0:|someone-else (1)|someone (2)|someone3 (3)\");\r\n        checkParam(url, \"chd\", \"t:100.0,66.7,33.3\");\r\n    }","id":86547,"modified_method":"public void testGraphEvalsByUser() throws Exception {\r\n        DbIssue foundIssue1 = createDbIssue(\"fad2\", persistenceHelper);\r\n        DbIssue foundIssue2 = createDbIssue(\"fad3\", persistenceHelper);\r\n        createEvaluation(foundIssue1, \"someone\", 100);\r\n        createEvaluation(foundIssue1, \"someone-else\", 200);\r\n        createEvaluation(foundIssue2, \"someone\", 300);\r\n        createEvaluation(foundIssue2, \"someone\", 300);\r\n        createEvaluation(foundIssue1, \"someone3\", 300);\r\n        createEvaluation(foundIssue1, \"someone3\", 300);\r\n        createEvaluation(foundIssue1, \"someone3\", 300);\r\n        createEvaluation(foundIssue2, \"someone3\", 300);\r\n\r\n        getPersistenceManager().makePersistentAll(foundIssue1, foundIssue2);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(1);\r\n        checkParam(url, \"chxl\", \"0:|someone-else|someone|someone3\");\r\n        checkParam(url, \"chd\", \"t:50.0,50.0,25.0|50.0,25.0,0.0\");\r\n    }","commit_id":"a66c7b8772dc430b1277a8c7aff198c505f54bbe","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testGraphEvalsByUserOver100() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        createEvaluation(foundIssue, \"someone\", 100);\r\n        createEvaluation(foundIssue, \"someone-else\", 200);\r\n        createEvaluation(foundIssue, \"someone\", 300);\r\n\r\n\r\n\r\n        for (int i = 0; i < 120; i++) {\r\n            foundIssue.addEvaluation(createEvaluation(foundIssue, \"lots\", 400));\r\n        }\r\n\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(1);\r\n        checkParam(url, \"chxl\", \"0:|someone-else (1)|someone (2)|lots (120)\");\r\n        checkParam(url, \"chd\", \"t:100.0,1.7,0.8\");\r\n    }","id":86548,"modified_method":"public void testGraphEvalsByUserOver100() throws Exception {\r\n        DbIssue foundIssue = createDbIssue(\"fad2\", persistenceHelper);\r\n        createEvaluation(foundIssue, \"someone\", 100);\r\n        createEvaluation(foundIssue, \"someone-else\", 200);\r\n        createEvaluation(foundIssue, \"someone\", 300);\r\n\r\n        for (int i = 0; i < 120; i++) {\r\n            foundIssue.addEvaluation(createEvaluation(foundIssue, \"lots\", 400));\r\n        }\r\n\r\n        getPersistenceManager().makePersistent(foundIssue);\r\n\r\n        executeGet(\"/stats\");\r\n\r\n        String url = generatedCharts.get(1);\r\n        checkParam(url, \"chxl\", \"0:|someone-else|someone|lots\");\r\n        checkParam(url, \"chd\", \"t:0.8,0.8,0.8|99.2,0.8,0.0\");\r\n    }","commit_id":"a66c7b8772dc430b1277a8c7aff198c505f54bbe","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public RepositoryAttachDialog(Project project, final @Nullable String initialFilter) {\n    super(project, true);\n    myProject = project;\n    myProgressIcon.suspend();\n    myCaptionLabel.setText(\n      XmlStringUtil.wrapInHtml(StringUtil.escapeXml(\"keyword or class name to search by or exact Maven coordinates, \" +\n                                                    \"i.e. 'spring', 'Logger' or 'ant:ant-junit:1.6.5'\")\n      ));\n    myInfoLabel.setPreferredSize(\n      new Dimension(myInfoLabel.getFontMetrics(myInfoLabel.getFont()).stringWidth(\"Showing: 1000\"), myInfoLabel.getPreferredSize().height));\n\n    myComboComponent.setButtonIcon(AllIcons.Actions.Menu_find);\n    myComboComponent.getButton().addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        performSearch();\n      }\n    });\n    myCombobox = myComboComponent.getComboBox();\n    myCombobox.setModel(new CollectionComboBoxModel(myShownItems, null));\n    myCombobox.setEditable(true);\n    final JTextField textField = (JTextField)myCombobox.getEditor().getEditorComponent();\n    textField.setColumns(20);\n    if (initialFilter != null) {\n      textField.setText(initialFilter);\n    }\n    textField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (myProgressIcon.isDisposed()) return;\n            updateComboboxSelection(false);\n          }\n        });\n      }\n    });\n    myCombobox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final boolean popupVisible = myCombobox.isPopupVisible();\n        if (!myInUpdate && (!popupVisible || myCoordinates.isEmpty())) {\n          performSearch();\n        }\n        else {\n          final String item = (String)myCombobox.getSelectedItem();\n          if (StringUtil.isNotEmpty(item)) {\n            ((JTextField)myCombobox.getEditor().getEditorComponent()).setText(item);\n          }\n        }\n      }\n    });\n    PropertiesComponent storage = PropertiesComponent.getInstance(myProject);\n    boolean pathValueSet = storage.isValueSet(PROPERTY_DOWNLOAD_TO_PATH);\n    if (pathValueSet) {\n      myDownloadToCheckBox.setSelected(true);\n      myDirectoryField.setText(storage.getValue(PROPERTY_DOWNLOAD_TO_PATH));\n    }\n    else {\n      myDownloadToCheckBox.setSelected(false);\n    }\n    myDownloadToCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myDirectoryField.setEnabled(myDownloadToCheckBox.isSelected());\n      }\n    });\n    myJavaDocCheckBox.setSelected(storage.isValueSet(PROPERTY_ATTACH_JAVADOC) && storage.isTrueValue(PROPERTY_ATTACH_JAVADOC));\n    mySourcesCheckBox.setSelected(storage.isValueSet(PROPERTY_ATTACH_SOURCES) && storage.isTrueValue(PROPERTY_ATTACH_SOURCES));\n    if (!pathValueSet && myProject != null && !myProject.isDefault()) {\n      final VirtualFile baseDir = myProject.getBaseDir();\n      if (baseDir != null) {\n        myDirectoryField.setText(FileUtil.toSystemDependentName(baseDir.getPath() + \"/lib\"));\n      }\n    }\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    descriptor.putUserData(FileChooserDialog.PREFER_LAST_OVER_TO_SELECT, Boolean.TRUE);\n    myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                             ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                             descriptor);\n    updateInfoLabel();\n    setOKActionEnabled(false);\n    init();\n  }","id":86549,"modified_method":"public RepositoryAttachDialog(@NotNull Project project, final @Nullable String initialFilter) {\n    super(project, true);\n    myProject = project;\n    myProgressIcon.suspend();\n    myCaptionLabel.setText(\n      XmlStringUtil.wrapInHtml(StringUtil.escapeXml(\"keyword or class name to search by or exact Maven coordinates, \" +\n                                                    \"i.e. 'spring', 'Logger' or 'ant:ant-junit:1.6.5'\")\n      ));\n    myInfoLabel.setPreferredSize(\n      new Dimension(myInfoLabel.getFontMetrics(myInfoLabel.getFont()).stringWidth(\"Showing: 1000\"), myInfoLabel.getPreferredSize().height));\n\n    myComboComponent.setButtonIcon(AllIcons.Actions.Menu_find);\n    myComboComponent.getButton().addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        performSearch();\n      }\n    });\n    myCombobox = myComboComponent.getComboBox();\n    myCombobox.setModel(new CollectionComboBoxModel(myShownItems, null));\n    myCombobox.setEditable(true);\n    final JTextField textField = (JTextField)myCombobox.getEditor().getEditorComponent();\n    textField.setColumns(20);\n    if (initialFilter != null) {\n      textField.setText(initialFilter);\n    }\n    textField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            if (myProgressIcon.isDisposed()) return;\n            updateComboboxSelection(false);\n          }\n        });\n      }\n    });\n    myCombobox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final boolean popupVisible = myCombobox.isPopupVisible();\n        if (!myInUpdate && (!popupVisible || myCoordinates.isEmpty())) {\n          performSearch();\n        }\n        else {\n          final String item = (String)myCombobox.getSelectedItem();\n          if (StringUtil.isNotEmpty(item)) {\n            ((JTextField)myCombobox.getEditor().getEditorComponent()).setText(item);\n          }\n        }\n      }\n    });\n    VirtualFile baseDir = !myProject.isDefault() ? myProject.getBaseDir() : null;\n    myDefaultDownloadFolder = baseDir != null ? FileUtil.toSystemDependentName(baseDir.getPath() + \"/lib\") : \"\";\n\n    PropertiesComponent storage = PropertiesComponent.getInstance(myProject);\n    myDownloadToCheckBox.setSelected(storage.isTrueValue(PROPERTY_DOWNLOAD_TO_PATH_ENABLED));\n    myDirectoryField.setText(StringUtil.notNullize(StringUtil.nullize(storage.getValue(PROPERTY_DOWNLOAD_TO_PATH)), myDefaultDownloadFolder));\n    myDirectoryField.setEnabled(myDownloadToCheckBox.isSelected());\n    myDownloadToCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myDirectoryField.setEnabled(myDownloadToCheckBox.isSelected());\n      }\n    });\n    myJavaDocCheckBox.setSelected(storage.isTrueValue(PROPERTY_ATTACH_JAVADOC));\n    mySourcesCheckBox.setSelected(storage.isTrueValue(PROPERTY_ATTACH_SOURCES));\n\n    final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    descriptor.putUserData(FileChooserDialog.PREFER_LAST_OVER_TO_SELECT, Boolean.TRUE);\n    myDirectoryField.addBrowseFolderListener(ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.title\"),\n                                             ProjectBundle.message(\"file.chooser.directory.for.downloaded.libraries.description\"), null,\n                                             descriptor);\n    updateInfoLabel();\n    setOKActionEnabled(false);\n    init();\n  }","commit_id":"13550c80624334bdae8cd13e3707448fb0a4624a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean performSearch() {\n    final String text = getCoordinateText();\n    if (myCoordinates.contains(text)) return false;\n    if (myProgressIcon.isRunning()) return false;\n    myProgressIcon.resume();\n    RepositoryAttachHandler.searchArtifacts(myProject, text, new PairProcessor<Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>>, Boolean>() {\n        public boolean process(Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>> artifacts, Boolean tooMany) {\n          if (myProgressIcon.isDisposed()) return false;\n          if (tooMany != null) myProgressIcon.suspend(); // finished\n          final int prevSize = myCoordinates.size();\n          for (Pair<MavenArtifactInfo, MavenRepositoryInfo> each : artifacts) {\n            myCoordinates.put(each.first.getGroupId() + \":\" + each.first.getArtifactId() + \":\" + each.first.getVersion(), each);\n            String url = each.second != null? each.second.getUrl() : null;\n            if (StringUtil.isNotEmpty(url) && !myRepositories.containsKey(url)) {\n              myRepositories.put(url, each.second);\n            }\n          }\n          String title = getTitle();\n          String tooManyMessage = \": too many results found\";\n          if (tooMany != null) {\n            boolean alreadyThere = title.endsWith(tooManyMessage);\n            if (tooMany.booleanValue() && !alreadyThere) {\n              setTitle(title + tooManyMessage);\n            }\n            else if (!tooMany.booleanValue() && alreadyThere) {\n              setTitle(title.substring(0, title.length() - tooManyMessage.length()));\n            }\n          }\n          updateComboboxSelection(prevSize != myCoordinates.size());\n          // tooMany != null on last call, so enable OK action to let\n          // local maven repo a chance even if all remote services failed\n          setOKActionEnabled(!myRepositories.isEmpty() || tooMany != null);\n          return true;\n        }\n      });\n    return true;\n  }","id":86550,"modified_method":"private boolean performSearch() {\n    final String text = getCoordinateText();\n    if (StringUtil.isEmptyOrSpaces(text)) return false;\n    if (myCoordinates.containsKey(text)) return false;\n    if (myProgressIcon.isRunning()) return false;\n    myProgressIcon.resume();\n    RepositoryAttachHandler.searchArtifacts(myProject, text, new PairProcessor<Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>>, Boolean>() {\n        public boolean process(Collection<Pair<MavenArtifactInfo, MavenRepositoryInfo>> artifacts, Boolean tooMany) {\n          if (myProgressIcon.isDisposed()) return false;\n          if (tooMany != null) myProgressIcon.suspend(); // finished\n          final int prevSize = myCoordinates.size();\n          for (Pair<MavenArtifactInfo, MavenRepositoryInfo> each : artifacts) {\n            myCoordinates.put(each.first.getGroupId() + \":\" + each.first.getArtifactId() + \":\" + each.first.getVersion(), each);\n            String url = each.second != null? each.second.getUrl() : null;\n            if (StringUtil.isNotEmpty(url) && !myRepositories.containsKey(url)) {\n              myRepositories.put(url, each.second);\n            }\n          }\n          String title = getTitle();\n          String tooManyMessage = \": too many results found\";\n          if (tooMany != null) {\n            boolean alreadyThere = title.endsWith(tooManyMessage);\n            if (tooMany.booleanValue() && !alreadyThere) {\n              setTitle(title + tooManyMessage);\n            }\n            else if (!tooMany.booleanValue() && alreadyThere) {\n              setTitle(title.substring(0, title.length() - tooManyMessage.length()));\n            }\n          }\n          updateComboboxSelection(prevSize != myCoordinates.size());\n          // tooMany != null on last call, so enable OK action to let\n          // local maven repo a chance even if all remote services failed\n          setOKActionEnabled(!myRepositories.isEmpty() || tooMany != null);\n          return true;\n        }\n      });\n    return true;\n  }","commit_id":"13550c80624334bdae8cd13e3707448fb0a4624a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void dispose() {\n    Disposer.dispose(myProgressIcon);\n    final PropertiesComponent storage = PropertiesComponent.getInstance(myProject);\n    if (myDownloadToCheckBox.isSelected()) {\n      storage.setValue(PROPERTY_DOWNLOAD_TO_PATH, myDirectoryField.getText());\n    }\n    storage.setValue(PROPERTY_ATTACH_JAVADOC, String.valueOf(myJavaDocCheckBox.isSelected()));\n    storage.setValue(PROPERTY_ATTACH_SOURCES, String.valueOf(mySourcesCheckBox.isSelected()));\n    super.dispose();\n  }","id":86551,"modified_method":"@Override\n  protected void dispose() {\n    Disposer.dispose(myProgressIcon);\n    PropertiesComponent storage = PropertiesComponent.getInstance(myProject);\n    storage.setValue(PROPERTY_DOWNLOAD_TO_PATH_ENABLED, String.valueOf(myDownloadToCheckBox.isSelected()));\n    String downloadPath = myDirectoryField.getText();\n    if (StringUtil.isEmptyOrSpaces(downloadPath)) downloadPath = myDefaultDownloadFolder;\n    storage.setValue(PROPERTY_DOWNLOAD_TO_PATH, downloadPath, myDefaultDownloadFolder);\n    storage.setValue(PROPERTY_ATTACH_JAVADOC, String.valueOf(myJavaDocCheckBox.isSelected()));\n    storage.setValue(PROPERTY_ATTACH_SOURCES, String.valueOf(mySourcesCheckBox.isSelected()));\n    super.dispose();\n  }","commit_id":"13550c80624334bdae8cd13e3707448fb0a4624a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateComboboxSelection(boolean force) {\n    final String prevFilter = myFilterString;\n    final JTextComponent field = (JTextComponent)myCombobox.getEditor().getEditorComponent();\n    final int caret = field.getCaretPosition();\n    myFilterString = field.getText();\n\n    if (!force && Comparing.equal(myFilterString, prevFilter)) return;\n    int prevSize = myShownItems.size();\n    myShownItems.clear();\n\n    myInUpdate = true;\n    final boolean itemSelected = myCoordinates.containsKey(myFilterString) &&\n                                 Comparing.strEqual((String)myCombobox.getSelectedItem(), myFilterString, false);\n    final boolean filtered;\n    if (itemSelected) {\n      myShownItems.addAll(myCoordinates.keySet());\n      filtered = false;\n    }\n    else {\n      final String[] parts = myFilterString.split(\" \");\n      main:\n      for (String coordinate : myCoordinates.keySet()) {\n        for (String part : parts) {\n          if (!StringUtil.containsIgnoreCase(coordinate, part)) continue main;\n        }\n        myShownItems.add(coordinate);\n      }\n      filtered = !myShownItems.isEmpty();\n      if (!filtered) {\n        myShownItems.addAll(myCoordinates.keySet());\n      }\n      myCombobox.setSelectedItem(null);\n    }\n\n    // use maven version sorter\n    ArrayList<Comparable> comparables = new ArrayList<Comparable>(myShownItems.size());\n    for (String item : myShownItems) {\n      comparables.add(new MavenVersionComparable(item));\n    }\n    Collections.sort(comparables);\n    myShownItems.clear();\n    for (Comparable comparable : comparables) {\n      myShownItems.add(comparable.toString());\n    }\n\n    ((CollectionComboBoxModel)myCombobox.getModel()).update();\n    myInUpdate = false;\n    field.setText(myFilterString);\n    field.setCaretPosition(caret);\n    updateInfoLabel();\n    if (filtered) {\n      if (prevSize < 10 && myShownItems.size() > prevSize && myCombobox.isPopupVisible()) {\n        myCombobox.setPopupVisible(false);\n      }\n      if (!myCombobox.isPopupVisible()) {\n        myCombobox.setPopupVisible(filtered);\n      }\n    }\n  }","id":86552,"modified_method":"private void updateComboboxSelection(boolean force) {\n    final String prevFilter = myFilterString;\n    final JTextComponent field = (JTextComponent)myCombobox.getEditor().getEditorComponent();\n    final int caret = field.getCaretPosition();\n    myFilterString = field.getText();\n\n    if (!force && Comparing.equal(myFilterString, prevFilter)) return;\n    int prevSize = myShownItems.size();\n    myShownItems.clear();\n\n    myInUpdate = true;\n    final boolean itemSelected = myCoordinates.containsKey(myFilterString) &&\n                                 Comparing.strEqual((String)myCombobox.getSelectedItem(), myFilterString, false);\n    final boolean filtered;\n    if (itemSelected) {\n      myShownItems.addAll(myCoordinates.keySet());\n      filtered = false;\n    }\n    else {\n      final String[] parts = myFilterString.split(\" \");\n      main:\n      for (String coordinate : myCoordinates.keySet()) {\n        for (String part : parts) {\n          if (!StringUtil.containsIgnoreCase(coordinate, part)) continue main;\n        }\n        myShownItems.add(coordinate);\n      }\n      filtered = !myShownItems.isEmpty();\n      if (!filtered) {\n        myShownItems.addAll(myCoordinates.keySet());\n      }\n      myCombobox.setSelectedItem(null);\n    }\n\n    // use maven version sorter\n    ArrayList<Comparable> comparables = new ArrayList<Comparable>(myShownItems.size());\n    for (String item : myShownItems) {\n      comparables.add(new MavenVersionComparable(item));\n    }\n    Collections.sort(comparables);\n    myShownItems.clear();\n    for (Comparable comparable : comparables) {\n      myShownItems.add(comparable.toString());\n    }\n\n    ((CollectionComboBoxModel)myCombobox.getModel()).update();\n    myInUpdate = false;\n    field.setText(myFilterString);\n    field.setCaretPosition(caret);\n    updateInfoLabel();\n    if (filtered) {\n      if (prevSize < 10 && myShownItems.size() > prevSize && myCombobox.isPopupVisible()) {\n        myCombobox.setPopupVisible(false);\n      }\n      if (!myCombobox.isPopupVisible()) {\n        myCombobox.setPopupVisible(true);\n      }\n    }\n  }","commit_id":"13550c80624334bdae8cd13e3707448fb0a4624a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getPresentableUrl() {\n    if (myProject.isDefault()) return null;\n    if (myPresentableUrl == null) {\n      final String url = myScheme == StorageScheme.DIRECTORY_BASED ? getProjectBasePath() : getProjectFilePath();\n      myPresentableUrl = url != null ? FileUtil.toSystemDependentName(url) : url;\n    }\n    return myPresentableUrl;\n  }","id":86553,"modified_method":"@Override\n  public String getPresentableUrl() {\n    if (myProject.isDefault()) {\n      return null;\n    }\n    if (myPresentableUrl == null) {\n      String url = myScheme == StorageScheme.DIRECTORY_BASED ? getProjectBasePath() : getProjectFilePath();\n      if (url != null) {\n        myPresentableUrl = FileUtil.toSystemDependentName(url);\n      }\n    }\n    return myPresentableUrl;\n  }","commit_id":"bf85e1b111d1b040eed94acd9eb74a3d234864aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void configureGenericGroovyRunner(@NotNull JavaParameters params,\n                                                  @NotNull Module module,\n                                                  @NotNull String mainClass,\n                                                  boolean useBundled,\n                                                  boolean tests) throws CantRunException {\n    final VirtualFile groovyJar = findGroovyJar(module);\n    if (useBundled) {\n      params.getClassPath().add(GroovyUtils.getBundledGroovyJar());\n    }\n    else if (groovyJar != null) {\n      params.getClassPath().add(groovyJar);\n    }\n\n    getClassPathFromRootModel(module, tests, params, true, params.getClassPath());\n\n    setToolsJar(params);\n\n    String groovyHome = useBundled ? FileUtil.toCanonicalPath(GroovyUtils.getBundledGroovyJar().getParentFile().getParent()) : LibrariesUtil.getGroovyHomePath(module);\n    if (groovyHome != null) {\n      groovyHome = FileUtil.toSystemDependentName(groovyHome);\n    }\n    if (groovyHome != null) {\n      setGroovyHome(params, groovyHome);\n    }\n\n    final String confPath = getConfPath(groovyHome);\n    params.getVMParametersList().add(\"-Dgroovy.starter.conf=\" + confPath);\n    params.getVMParametersList().addAll(HttpConfigurable.convertArguments(HttpConfigurable.getJvmPropertiesList(false, null)));\n\n    params.setMainClass(\"org.codehaus.groovy.tools.GroovyStarter\");\n\n    params.getProgramParametersList().add(\"--conf\");\n    params.getProgramParametersList().add(confPath);\n\n    params.getProgramParametersList().add(\"--main\");\n    params.getProgramParametersList().add(mainClass);\n\n    if (params.getVMParametersList().getPropertyValue(GroovycOSProcessHandler.GRAPE_ROOT) == null) {\n      String sysRoot = System.getProperty(GroovycOSProcessHandler.GRAPE_ROOT);\n      if (sysRoot != null) {\n        params.getVMParametersList().defineProperty(GroovycOSProcessHandler.GRAPE_ROOT, sysRoot);\n      }\n    }\n  }","id":86554,"modified_method":"public static void configureGenericGroovyRunner(@NotNull JavaParameters params,\n                                                  @NotNull Module module,\n                                                  @NotNull String mainClass,\n                                                  boolean useBundled,\n                                                  boolean tests) throws CantRunException {\n    final VirtualFile groovyJar = findGroovyJar(module);\n    if (useBundled) {\n      params.getClassPath().add(GroovyUtils.getBundledGroovyJar());\n    }\n    else if (groovyJar != null) {\n      params.getClassPath().add(groovyJar);\n    }\n\n    getClassPathFromRootModel(module, tests, params, true, params.getClassPath());\n\n    setToolsJar(params);\n\n    String groovyHome = useBundled ? FileUtil.toCanonicalPath(GroovyUtils.getBundledGroovyJar().getParentFile().getParent()) : LibrariesUtil.getGroovyHomePath(module);\n    String groovyHomeDependentName = groovyHome != null ? FileUtil.toSystemDependentName(groovyHome) : null;\n\n    if (groovyHomeDependentName != null) {\n      setGroovyHome(params, groovyHomeDependentName);\n    }\n\n    final String confPath = getConfPath(groovyHomeDependentName);\n    params.getVMParametersList().add(\"-Dgroovy.starter.conf=\" + confPath);\n    params.getVMParametersList().addAll(HttpConfigurable.convertArguments(HttpConfigurable.getJvmPropertiesList(false, null)));\n\n    params.setMainClass(\"org.codehaus.groovy.tools.GroovyStarter\");\n\n    params.getProgramParametersList().add(\"--conf\");\n    params.getProgramParametersList().add(confPath);\n\n    params.getProgramParametersList().add(\"--main\");\n    params.getProgramParametersList().add(mainClass);\n\n    if (params.getVMParametersList().getPropertyValue(GroovycOSProcessHandler.GRAPE_ROOT) == null) {\n      String sysRoot = System.getProperty(GroovycOSProcessHandler.GRAPE_ROOT);\n      if (sysRoot != null) {\n        params.getVMParametersList().defineProperty(GroovycOSProcessHandler.GRAPE_ROOT, sysRoot);\n      }\n    }\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getTitle(@NotNull Module module) {\n    String homePath = LibrariesUtil.getGroovyHomePath(module);\n    boolean bundled = !hasGroovyWithNeededJars(module);\n    if (bundled) {\n      homePath = GroovyUtils.getBundledGroovyJar().getParentFile().getParent();\n    }\n    else {\n      assert homePath != null;\n    }\n\n    String version = GroovyConfigUtils.getInstance().getSDKVersion(homePath);\n    return version == AbstractConfigUtils.UNDEFINED_VERSION ? \"\" : \" (\" + (bundled ? \"Bundled \" : \"\") + \"Groovy \" + version + \")\";\n  }","id":86555,"modified_method":"@NotNull\n  @Override\n  public String getTitle(@NotNull Module module) {\n    String homePath = LibrariesUtil.getGroovyHomePath(module);\n    assert homePath != null;\n\n    String version = GroovyConfigUtils.getInstance().getSDKVersion(homePath);\n    return version == AbstractConfigUtils.UNDEFINED_VERSION ? \"\" : \" (Groovy \" + version + \")\";\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean canRun(@NotNull Module module) {\n    VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n    return contentRoots.length > 0;\n  }","id":86556,"modified_method":"@Override\n  public boolean canRun(@NotNull Module module) {\n    VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n    return contentRoots.length > 0 && hasGroovyWithNeededJars(module);\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public JavaParameters createJavaParameters(@NotNull Module module) throws ExecutionException {\n    JavaParameters res = GroovyScriptRunConfiguration.createJavaParametersWithSdk(module);\n    boolean useBundled = !hasGroovyWithNeededJars(module);\n    DefaultGroovyScriptRunner.configureGenericGroovyRunner(res, module, \"org.codehaus.groovy.tools.shell.Main\", false, true);\n    if (useBundled) {\n      String libRoot = GroovyUtils.getBundledGroovyJar().getParent();\n      File libDir = new File(libRoot + \"/groovy/lib\");\n      assert libDir.isDirectory();\n      for (File file : libDir.listFiles()) {\n        res.getClassPath().add(file);\n      }\n\n      GroovyScriptRunner.setGroovyHome(res, FileUtil.toCanonicalPath(libRoot  + \"/groovy\"));\n    }\n    res.setWorkingDirectory(getWorkingDirectory(module));\n\n    return res;\n  }","id":86557,"modified_method":"@NotNull\n  @Override\n  public JavaParameters createJavaParameters(@NotNull Module module) throws ExecutionException {\n    JavaParameters res = GroovyScriptRunConfiguration.createJavaParametersWithSdk(module);\n    DefaultGroovyScriptRunner.configureGenericGroovyRunner(res, module, \"org.codehaus.groovy.tools.shell.Main\", false, true);\n    res.setWorkingDirectory(getWorkingDirectory(module));\n    return res;\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean hasGroovyWithNeededJars(Module module) {\n    GlobalSearchScope scope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n    JavaPsiFacade facade = JavaPsiFacade.getInstance(module.getProject());\n    return (facade.findClass(\"org.apache.commons.cli.CommandLineParser\", scope) != null ||\n            facade.findClass(\"groovyjarjarcommonscli.CommandLineParser\", scope) != null) &&\n           facade.findClass(\"groovy.ui.GroovyMain\", scope) != null  &&\n           facade.findClass(\"org.fusesource.jansi.AnsiConsole\", scope) != null;\n  }","id":86558,"modified_method":"static boolean hasGroovyWithNeededJars(Module module) {\n    GlobalSearchScope scope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n    JavaPsiFacade facade = JavaPsiFacade.getInstance(module.getProject());\n    return (facade.findClass(\"org.apache.commons.cli.CommandLineParser\", scope) != null || facade.findClass(\"groovyjarjarcommonscli.CommandLineParser\", scope) != null) &&\n           facade.findClass(\"groovy.ui.GroovyMain\", scope) != null  &&\n           facade.findClass(\"org.fusesource.jansi.AnsiConsole\", scope) != null;\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getTitle(@NotNull Module module) {\n    String homePath = LibrariesUtil.getGroovyHomePath(module);\n    boolean bundled = false;\n    if (homePath == null || !hasGroovyAll(module)) {\n      homePath = GroovyUtils.getBundledGroovyJar().getParentFile().getParent();\n      bundled = true;\n    }\n    String version = GroovyConfigUtils.getInstance().getSDKVersion(homePath);\n    return version == AbstractConfigUtils.UNDEFINED_VERSION ? \"\" : \" (\" + (bundled ? \"Bundled \" : \"\") + \"Groovy \" + version + \")\";\n  }","id":86559,"modified_method":"@NotNull\n  @Override\n  public String getTitle(@NotNull Module module) {\n    String moduleGroovyHomePath = LibrariesUtil.getGroovyHomePath(module);\n    boolean bundled = moduleGroovyHomePath == null || !hasGroovyAll(module);\n    String homePathToUse = bundled ? GroovyUtils.getBundledGroovyJar().getParentFile().getParent() : moduleGroovyHomePath;\n\n    String version = GroovyConfigUtils.getInstance().getSDKVersion(homePathToUse);\n    return version == AbstractConfigUtils.UNDEFINED_VERSION ? \"\" : \" (\" + (bundled ? \"Bundled \" : \"\") + \"Groovy \" + version + \")\";\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected GroovyShellConsoleImpl createConsole(Project project, String title) {\n    final GroovyShellConsoleImpl console = new GroovyShellConsoleImpl(project, title);\n\n    /*UiNotifyConnector.doWhenFirstShown(console.getComponent(), new Runnable() {\n      @Override\n      public void run() {\n        final String key = \"groovy.shell.is.really.groovy.shell\";\n        if (!PropertiesComponent.getInstance().isTrueValue(key)) {\n          final Alarm alarm = new Alarm();\n          alarm.addRequest(new Runnable() {\n            @Override\n            public void run() {\n              GotItMessage.createMessage(\"Groovy Shell & Groovy Console\", \"<html><div align='left'>Use 'Groovy Console' action (Tools | Groovy Console...) to run <a href='http://'>Groovy Console<\/a><br>Use 'Groovy Shell' action (Tools | Groovy Shell...) to invoke <a href=\\\"http://groovy.codehaus.org/Groovy+Shell\\\">Groovy Shell<\/a><\/div><\/html>\")\n                .setDisposable(console)\n                .show(new RelativePoint(console.getComponent(), new Point(10, 0)), Balloon.Position.above);\n\n              PropertiesComponent.getInstance().setValue(key, String.valueOf(true));\n              Disposer.dispose(alarm);\n            }\n          }, 2000);\n        }\n\n      }\n    })*/;\n\n\n    return console;\n  }","id":86560,"modified_method":"@Override\n  protected GroovyShellConsoleImpl createConsole(Project project, String title) {\n    return new GroovyShellConsoleImpl(project, title);\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<Module> getGroovyCompatibleModules(Project project) {\n    ArrayList<Module> result = new ArrayList<Module>();\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      if (GroovyUtils.isSuitableModule(module)) {\n        Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n        if (sdk != null && sdk.getSdkType() instanceof JavaSdkType) {\n          result.add(module);\n        }\n      }\n    }\n    return result;\n  }","id":86561,"modified_method":"private List<Module> getGroovyCompatibleModules(Project project) {\n    ArrayList<Module> result = new ArrayList<Module>();\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      if (isSuitableModule(module)) {\n        Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n        if (sdk != null && sdk.getSdkType() instanceof JavaSdkType) {\n          result.add(module);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"0ac89c0d2ecafaa78d281fb266b01ecaab8493c1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void readJdomExternalizables(final ModuleImpl module) {\n    loadModuleComponentState(module, ModuleRootManager.getInstance(module));\n  }","id":86562,"modified_method":"protected void readJdomExternalizables(@NotNull Module module) {\n    loadModuleComponentState(module, ModuleRootManager.getInstance(module));\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void loadModuleComponentState(@NotNull Module module, @NotNull Object component) {\n    AccessToken token = WriteAction.start();\n    try {\n      ProjectImpl project = (ProjectImpl)myProject;\n      project.setOptimiseTestLoadSpeed(false);\n      ComponentsPackage.getStateStore(module).initComponent(component, false);\n      project.setOptimiseTestLoadSpeed(true);\n    }\n    finally {\n      token.finish();\n    }\n  }","id":86563,"modified_method":"protected final void loadModuleComponentState(@NotNull Module module, @NotNull Object component) {\n    AccessToken token = WriteAction.start();\n    try {\n      ProjectEx project = (ProjectEx)myProject;\n      project.setOptimiseTestLoadSpeed(false);\n      ComponentsPackage.getStateStore(module).initComponent(component, false);\n      project.setOptimiseTestLoadSpeed(true);\n    }\n    finally {\n      token.finish();\n    }\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setManifestPath(final String manifestPath) {\n    if (manifestPath == null || manifestPath.length() == 0){\n      myManifestFilePointer = null;\n    } else {\n\n      final VirtualFile manifest = LocalFileSystem.getInstance().findFileByPath(manifestPath);\n      if (manifest == null){\n        Messages.showErrorDialog(myModule.getProject(), DevKitBundle.message(\"error.file.not.found.message\", manifestPath), DevKitBundle.message(\"error.file.not.found\"));\n        ApplicationManager.getApplication().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            myManifestFilePointer = VirtualFilePointerManager.getInstance().create(\n              VfsUtilCore.pathToUrl(FileUtil.toSystemIndependentName(manifestPath)), myModule, null);\n          }\n        });\n      } else {\n        ApplicationManager.getApplication().runReadAction(new Runnable() {\n          @Override\n          public void run() {\n            myManifestFilePointer = VirtualFilePointerManager.getInstance().create(manifest, myModule, null);\n          }\n        });\n      }\n    }\n  }","id":86564,"modified_method":"public void setManifestPath(@Nullable String manifestPath) {\n    if (StringUtil.isEmpty(manifestPath)) {\n      myManifestFilePointer = null;\n      return;\n    }\n\n    VirtualFile manifest = LocalFileSystem.getInstance().findFileByPath(manifestPath);\n    if (manifest == null) {\n      Messages.showErrorDialog(myModule.getProject(), DevKitBundle.message(\"error.file.not.found.message\", manifestPath), DevKitBundle.message(\"error.file.not.found\"));\n      AccessToken token = ReadAction.start();\n      try {\n        myManifestFilePointer = VirtualFilePointerManager.getInstance().create(\n          VfsUtilCore.pathToUrl(FileUtil.toSystemIndependentName(manifestPath)), myModule, null);\n      }\n      finally {\n        token.finish();\n      }\n    }\n    else {\n      AccessToken token = ReadAction.start();\n      try {\n        myManifestFilePointer = VirtualFilePointerManager.getInstance().create(manifest, myModule, null);\n      }\n      finally {\n        token.finish();\n      }\n    }\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public VirtualFile getManifest(){\n    if (myManifestFilePointer != null){\n      return myManifestFilePointer.getFile();\n    }\n    return null;\n  }","id":86565,"modified_method":"@Nullable\n  public VirtualFile getManifest(){\n    return myManifestFilePointer != null ? myManifestFilePointer.getFile() : null;\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getManifestPath() {\n    if (myManifestFilePointer != null){\n      return FileUtil.toSystemDependentName(myManifestFilePointer.getPresentableUrl());\n    }\n    return null;\n  }","id":86566,"modified_method":"@Nullable\n  public String getManifestPath() {\n    return myManifestFilePointer != null ? FileUtil.toSystemDependentName(myManifestFilePointer.getPresentableUrl()) : null;\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Module setupPluginProjectWithJpsModule() {\n    copyToProject(\"plugins/devkit/testData/build/withJpsModule\");\n    Module module = loadModule(getProjectBasePath() + \"/pluginProject.iml\");\n    readJdomExternalizables((ModuleImpl)module);\n    loadModuleComponentState(module, PluginBuildConfiguration.getInstance(module));\n    Module jpsModule = loadModule(getProjectBasePath() + \"/jps-plugin/jps-plugin.iml\");\n    readJdomExternalizables((ModuleImpl)jpsModule);\n    ModuleRootModificationUtil.setModuleSdk(jpsModule, getTestProjectJdk());\n    return module;\n  }","id":86567,"modified_method":"private Module setupPluginProjectWithJpsModule() {\n    copyToProject(\"plugins/devkit/testData/build/withJpsModule\");\n    Module module = loadModule(getProjectBasePath() + \"/pluginProject.iml\");\n    readJdomExternalizables(module);\n    loadModuleComponentState(module, PluginBuildConfiguration.getInstance(module));\n    Module jpsModule = loadModule(getProjectBasePath() + \"/jps-plugin/jps-plugin.iml\");\n    readJdomExternalizables(jpsModule);\n    ModuleRootModificationUtil.setModuleSdk(jpsModule, getTestProjectJdk());\n    return module;\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Module setupSimplePluginProject() {\n    copyToProject(\"plugins/devkit/testData/build/simple\");\n    Module module = loadModule(getProjectBasePath() + \"/pluginProject.iml\");\n    readJdomExternalizables((ModuleImpl)module);\n    return module;\n  }","id":86568,"modified_method":"private Module setupSimplePluginProject() {\n    copyToProject(\"plugins/devkit/testData/build/simple\");\n    Module module = loadModule(getProjectBasePath() + \"/pluginProject.iml\");\n    readJdomExternalizables(module);\n    return module;\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void readJdomExternalizables(ModuleImpl module) {\n    super.readJdomExternalizables(module);\n    PluginBuildConfiguration buildConfiguration = PluginBuildConfiguration.getInstance(module);\n    if (buildConfiguration != null) {\n      loadModuleComponentState(module, buildConfiguration);\n    }\n  }","id":86569,"modified_method":"@Override\n  protected void readJdomExternalizables(@NotNull Module module) {\n    super.readJdomExternalizables(module);\n    PluginBuildConfiguration buildConfiguration = PluginBuildConfiguration.getInstance(module);\n    if (buildConfiguration != null) {\n      loadModuleComponentState(module, buildConfiguration);\n    }\n  }","commit_id":"bd5e55da5b4313d83afdedfde6305809110caff3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected String getProjectPath(final Project project) {\n    final ProjectBaseDirectory baseDir = ProjectBaseDirectory.getInstance(project);\n    VirtualFile baseDirVFile = baseDir.getBaseDir() != null ? baseDir.getBaseDir() : project.getBaseDir();   \n    if (baseDirVFile != null) {\n      return FileUtil.toSystemDependentName(baseDirVFile.getPath());\n    }\n    return null;\n  }","id":86570,"modified_method":"@Nullable\n  protected String getProjectPath(@NotNull Project project) {\n    final ProjectBaseDirectory baseDir = ProjectBaseDirectory.getInstance(project);\n    final VirtualFile baseDirVFile = baseDir.getBaseDir() != null ? baseDir.getBaseDir() : project.getBaseDir();\n    return baseDirVFile != null ? FileUtil.toSystemDependentName(baseDirVFile.getPath()) : null;\n  }","commit_id":"f4f4d1a60d9e0c75571edd2ec785695de4bb1a0b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isValidProjectPath(String projectPath) {\n    final File file = new File(projectPath);\n    return file.exists() && (!file.isDirectory() || new File(file, ProjectUtil.DIRECTORY_BASED_PROJECT_DIR).exists());\n  }","id":86571,"modified_method":"public static boolean isValidProjectPath(String projectPath) {\n    final File file = new File(projectPath);\n    return file.exists() && (!file.isDirectory() || new File(file, Project.DIRECTORY_STORE_FOLDER).exists());\n  }","commit_id":"f4f4d1a60d9e0c75571edd2ec785695de4bb1a0b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setVFileToEditor(VirtualFile file) {\n    if (file != null) {\n      myScratchPathField.getComponent().setText(FileUtil.toSystemDependentName(file.getPath()));\n    }\n    else {\n      myScratchPathField.setText(\"\");\n    }\n  }","id":86572,"modified_method":"private void setVFileToEditor(VirtualFile file) {\n    myScratchPathField.getComponent().setText(file != null? FileUtil.toSystemDependentName(file.getPath()): \"\");\n  }","commit_id":"2f0016251140fb1222bf97ef12880a7121f59683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaScratchConfigurable(final Project project) {\n    myMainClass = new LabeledComponent<JTextField>();\n    myMainClass.setLabelLocation(BorderLayout.WEST);\n    myMainClass.setText(\"Main &class:\");\n    myMainClass.setComponent(new JTextField());\n\n    myScratchPathField = new LabeledComponent<TextFieldWithBrowseButton>();\n    myScratchPathField.setLabelLocation(BorderLayout.WEST);\n    myScratchPathField.setText(\"&Path to scratch file:\");\n    myScratchPathField.setComponent(new TextFieldWithBrowseButton(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        VirtualFile toSelect = getVFileFromEditor();\n        if (toSelect == null) {\n          final String scratchesRoot = ScratchFileService.getInstance().getRootPath(ScratchRootType.getInstance());\n          toSelect = LocalFileSystem.getInstance().findFileByPath(scratchesRoot);\n        }\n        final VirtualFile file =\n          FileChooser.chooseFile(FileChooserDescriptorFactory.createSingleFileNoJarsDescriptor(), myScratchPathField, project, toSelect);\n        if (file != null) {\n          setVFileToEditor(file);\n        }\n      }\n    }, this));\n\n    myModule = new LabeledComponent<ModulesComboBox>();\n    myModule.setLabelLocation(BorderLayout.WEST);\n    myModule.setComponent(new ModulesComboBox());\n    myModule.setText(\"Use classpath of &module:\");\n    myModuleSelector = new ConfigurationModuleSelector(project, myModule.getComponent());\n\n    myCommonProgramParameters = new CommonJavaParametersPanel();\n    myCommonProgramParameters.setModuleContext(myModuleSelector.getModule());\n    myModule.getComponent().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myCommonProgramParameters.setModuleContext(myModuleSelector.getModule());\n      }\n    });\n    myJrePathEditor = new JrePathEditor(DefaultJreSelector.projectSdk(project));\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    myWholePanel.add(myMainClass, new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(6, 0, 0, 0),0, 0 ));\n    myWholePanel.add(myScratchPathField, new GridBagConstraints(GridBagConstraints.RELATIVE, 1, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(6, 0, 0, 0),0, 0 ));\n    myWholePanel.add(myCommonProgramParameters, new GridBagConstraints(GridBagConstraints.RELATIVE, 2, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(12, 0, 12, 0),0, 0 ));\n    myWholePanel.add(myModule, new GridBagConstraints(GridBagConstraints.RELATIVE, 3, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0),0, 0 ));\n    myWholePanel.add(myJrePathEditor, new GridBagConstraints(GridBagConstraints.RELATIVE, 4, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(6, 0, 0, 0),0, 0 ));\n\n    myAnchor = UIUtil.mergeComponentsWithAnchor(myMainClass, myScratchPathField, myCommonProgramParameters, myJrePathEditor, myModule);\n  }","id":86573,"modified_method":"public JavaScratchConfigurable(final Project project) {\n    myMainClass = new LabeledComponent<JTextField>();\n    myMainClass.setLabelLocation(BorderLayout.WEST);\n    myMainClass.setText(\"Main &class:\");\n    myMainClass.setComponent(new JTextField());\n\n    myScratchPathField = new LabeledComponent<TextFieldWithBrowseButton>();\n    myScratchPathField.setLabelLocation(BorderLayout.WEST);\n    myScratchPathField.setText(\"&Path to scratch file:\");\n    myScratchPathField.setComponent(new TextFieldWithBrowseButton(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        VirtualFile toSelect = getVFileFromEditor();\n        if (toSelect == null) {\n          final String scratchesRoot = ScratchFileService.getInstance().getRootPath(ScratchRootType.getInstance());\n          toSelect = LocalFileSystem.getInstance().findFileByPath(scratchesRoot);\n        }\n        final VirtualFile file =\n          FileChooser.chooseFile(FileChooserDescriptorFactory.createSingleFileNoJarsDescriptor(), myScratchPathField.getComponent(), project, toSelect);\n        if (file != null) {\n          setVFileToEditor(file);\n        }\n      }\n    }, this));\n\n    myModule = new LabeledComponent<ModulesComboBox>();\n    myModule.setLabelLocation(BorderLayout.WEST);\n    myModule.setComponent(new ModulesComboBox());\n    myModule.setText(\"Use classpath of &module:\");\n    myModuleSelector = new ConfigurationModuleSelector(project, myModule.getComponent());\n\n    myCommonProgramParameters = new CommonJavaParametersPanel();\n    myCommonProgramParameters.setModuleContext(myModuleSelector.getModule());\n    myModule.getComponent().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myCommonProgramParameters.setModuleContext(myModuleSelector.getModule());\n      }\n    });\n    myJrePathEditor = new JrePathEditor(DefaultJreSelector.projectSdk(project));\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    myWholePanel.add(myMainClass, new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(6, 0, 0, 0),0, 0 ));\n    myWholePanel.add(myScratchPathField, new GridBagConstraints(GridBagConstraints.RELATIVE, 1, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(6, 0, 0, 0),0, 0 ));\n    myWholePanel.add(myCommonProgramParameters, new GridBagConstraints(GridBagConstraints.RELATIVE, 2, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(12, 0, 12, 0),0, 0 ));\n    myWholePanel.add(myModule, new GridBagConstraints(GridBagConstraints.RELATIVE, 3, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0),0, 0 ));\n    myWholePanel.add(myJrePathEditor, new GridBagConstraints(GridBagConstraints.RELATIVE, 4, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(6, 0, 0, 0),0, 0 ));\n\n    myAnchor = UIUtil.mergeComponentsWithAnchor(myMainClass, myScratchPathField, myCommonProgramParameters, myJrePathEditor, myModule);\n  }","commit_id":"2f0016251140fb1222bf97ef12880a7121f59683","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DartGeneratorPeer() {\n    DartSdkUtil.initDartSdkPathTextFieldWithBrowseButton(null, mySdkPathTextWithBrowse, myVersionLabel);\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    if (sdk != null) {\n      mySdkPathTextWithBrowse.setText(FileUtil.toSystemDependentName(sdk.getHomePath()));\n    }\n  }","id":86574,"modified_method":"public DartGeneratorPeer() {\n    DartSdkUtil.initDartSdkPathTextFieldWithBrowseButton(null, mySdkPathTextWithBrowse, myVersionLabel);\n\n    final DartSdk sdk = DartSdk.getGlobalDartSdk();\n    mySdkPathTextWithBrowse.setText(sdk == null ? \"\" : FileUtil.toSystemDependentName(sdk.getHomePath()));\n  }","commit_id":"e507833097ec949654641c86bd28288173ef4643","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void readSettings(Element node) throws InvalidDataException {\n    myConfigurations.clear();\n    ConfigurationManager.readConfigurations(node, myConfigurations, new ArrayList<Configuration>());\n\n    Project project = ProjectManager.getInstance().getOpenProjects()[0];\n    StartupManager.getInstance(project).runWhenProjectIsInitialized(new Runnable() {\n      public void run() {\n        precompileConfigurations();\n      }\n    });\n  }","id":86575,"modified_method":"public void readSettings(Element node) throws InvalidDataException {\n    myConfigurations.clear();\n    ConfigurationManager.readConfigurations(node, myConfigurations, new ArrayList<Configuration>());\n\n    Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    if (projects.length == 0) {\n      ProjectManager.getInstance().addProjectManagerListener(new ProjectManagerAdapter() {\n        public void projectOpened(Project project) {\n          ProjectManager.getInstance().removeProjectManagerListener(this);\n          precompileConfigurations(project);\n        }\n      });\n    }\n    else {\n      final Project project = projects[0];\n      StartupManager.getInstance(project).runWhenProjectIsInitialized(new Runnable() {\n        public void run() {\n          precompileConfigurations(project);\n        }\n      });\n    }\n  }","commit_id":"e3cb350ba6e324f5d827818f17ea26fd08985676","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public JComponent createOptionsPanel() {\n    JPanel component = new SSBasedInspectionOptions(myConfigurations){\n      public void configurationsChanged() {\n        super.configurationsChanged();\n        precompileConfigurations();\n      }\n    }.getComponent();\n    return component;\n  }","id":86576,"modified_method":"@Nullable\n  public JComponent createOptionsPanel() {\n    JPanel component = new SSBasedInspectionOptions(myConfigurations){\n      public void configurationsChanged() {\n        super.configurationsChanged();\n        Project[] projects = ProjectManager.getInstance().getOpenProjects();\n        precompileConfigurations(projects[0]);\n      }\n    }.getComponent();\n    return component;\n  }","commit_id":"e3cb350ba6e324f5d827818f17ea26fd08985676","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void precompileConfigurations() {\n    Project project = ProjectManager.getInstance().getOpenProjects()[0];\n\n    compiledConfigurations = new Matcher(project).precompileOptions(myConfigurations);\n  }","id":86577,"modified_method":"public void precompileConfigurations(final Project project) {\n    compiledConfigurations = new Matcher(project).precompileOptions(myConfigurations);\n  }","commit_id":"e3cb350ba6e324f5d827818f17ea26fd08985676","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private SModelDescriptor recreateFileAndGetInstance(IModelRootManager manager, boolean createStub, String fileName, SModelUID modelUID, ModelOwner owner, SModelRoot root) {\n    SModelRepository modelRepository = SModelRepository.getInstance();\n    if (createStub) {\n      return getInstance(manager, createStub, fileName, modelUID, owner, false);\n    }\n    SModelDescriptor modelDescriptor = modelRepository.getModelDescriptor(modelUID);\n    if (modelDescriptor != null) {\n      LOG.error(\"can't recreate file for already loaded descriptor \" + modelUID);\n      return getInstance(manager, createStub, fileName, modelUID, owner, false);\n    }\n    IFile modelFile = FileSystem.getFile(fileName);\n    SModelUID newModelUID = ModelPersistence.upgradeModelUID(modelUID);\n    IFile newFile = createFileForModelUID(root, newModelUID);//ModelPersistence.upgradeFile(modelFile);\n    newFile.createNewFile();\n    FileUtil.copyFile(modelFile.toFile(), newFile.toFile());\n    modelFile.delete();\n    SModelDescriptor result = getInstance(manager, createStub, newFile.getAbsolutePath(), newModelUID, owner, true);\n    for (Project project : ProjectManagerEx.getInstance().getOpenProjects()) {\n      MPSVCSManager mpsvcsManager = MPSVCSManager.getInstance(project);\n      if (mpsvcsManager != null) {\n        mpsvcsManager.addFilesToVCS(Collections.singletonList(newFile.toFile()));\n      }\n    }\n    return result;\n  }","id":86578,"modified_method":"private SModelDescriptor recreateFileAndGetInstance(IModelRootManager manager, boolean createStub, String fileName, SModelUID modelUID, ModelOwner owner, SModelRoot root) {\n    SModelRepository modelRepository = SModelRepository.getInstance();\n    if (createStub) {\n      return getInstance(manager, createStub, fileName, modelUID, owner, false);\n    }\n    SModelDescriptor modelDescriptor = modelRepository.getModelDescriptor(modelUID);\n    if (modelDescriptor != null) {\n      LOG.error(\"can't recreate file for already loaded descriptor \" + modelUID);\n      return getInstance(manager, createStub, fileName, modelUID, owner, false);\n    }\n    IFile modelFile = FileSystem.getFile(fileName);\n    SModelUID newModelUID = ModelPersistence.upgradeModelUID(modelUID);\n    IFile newFile = createFileForModelUID(root, newModelUID);//ModelPersistence.upgradeFile(modelFile);\n    newFile.createNewFile();\n    FileUtil.copyFile(modelFile.toFile(), newFile.toFile());\n    modelFile.delete();\n    SModelDescriptor result = getInstance(manager, createStub, newFile.getAbsolutePath(), newModelUID, owner, true);\n    Project[] projects = ProjectManagerEx.getInstance().getOpenProjects();\n    if (projects.length == 0)  {\n      MPSVCSManager.addFileLater(newFile.toFile());\n    } else {\n      for (Project project : projects) {\n        MPSVCSManager mpsvcsManager = MPSVCSManager.getInstance(project);\n        if (mpsvcsManager != null) {\n          mpsvcsManager.addFilesToVCS(Collections.singletonList(newFile.toFile()));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"a804c21584ce427d777356b5c98c75f7f80c8b5f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeComponent() {\n    myProject.getComponent(GeneratorManager.class).removeGenerationListener(myGenerationListener);\n    myProject.getComponent(GeneratorManager.class).removeCompilationListener(myCompilationListener);\n    SModelRepository.getInstance().removeModelRepositoryListener(myModelRepositoryListener);\n    ModelChangesWatcher.instance().removeMetadataListener(myMetadataListener);\n    myChangeListManager.removeChangeListListener(myChangeListUpdateListener);\n\n    myTasksQueue.allowAccessAndProcessAllTasks();\n  }","id":86579,"modified_method":"public void disposeComponent() {\n    myProject.getComponent(GeneratorManager.class).removeGenerationListener(myGenerationListener);\n    myProject.getComponent(GeneratorManager.class).removeCompilationListener(myCompilationListener);\n    SModelRepository.getInstance().removeModelRepositoryListener(myModelRepositoryListener);\n    ModelChangesWatcher.instance().removeMetadataListener(myMetadataListener);\n    myChangeListManager.removeChangeListListener(myChangeListUpdateListener);\n\n    myTasksQueue.allowAccessAndProcessAllTasks();\n    addFilesScheduledToAddLater();\n  }","commit_id":"a804c21584ce427d777356b5c98c75f7f80c8b5f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean areContentChangesVersioned(VirtualFile f) {\n    if (!isVersioned(f) || f.isDirectory()) return false;\n    return areContentChangesVersioned(f.getName());\n  }","id":86580,"modified_method":"public boolean areContentChangesVersioned(@NotNull VirtualFile f) {\n    return isVersioned(f) && !f.isDirectory() && areContentChangesVersioned(f.getName());\n  }","commit_id":"452077f7df8983c5ccf846ad2309d75e5c40c805","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerUnsavedDocuments(final LocalHistoryFacade vcs) {\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        vcs.beginChangeSet();\n        for (Document d : FileDocumentManager.getInstance().getUnsavedDocuments()) {\n          VirtualFile f = getFile(d);\n          if (!shouldRegisterDocument(f)) continue;\n          registerDocumentContents(vcs, f, d);\n        }\n        vcs.endChangeSet(null);\n      }\n    });\n  }","id":86581,"modified_method":"public void registerUnsavedDocuments(@NotNull final LocalHistoryFacade vcs) {\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        vcs.beginChangeSet();\n        for (Document d : FileDocumentManager.getInstance().getUnsavedDocuments()) {\n          VirtualFile f = getFile(d);\n          if (!shouldRegisterDocument(f)) continue;\n          registerDocumentContents(vcs, f, d);\n        }\n        vcs.endChangeSet(null);\n      }\n    });\n  }","commit_id":"452077f7df8983c5ccf846ad2309d75e5c40c805","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doCreateChildren(DirectoryEntry parent, Collection<VirtualFile> children, final boolean forDeletion) {\n    List<Entry> entries = ContainerUtil.mapNotNull(children, new NullableFunction<VirtualFile, Entry>() {\n      @Override\n      public Entry fun(VirtualFile each) {\n        return doCreateEntry(each, forDeletion);\n      }\n    });\n    parent.addChildren(entries);\n  }","id":86582,"modified_method":"private void doCreateChildren(@NotNull DirectoryEntry parent, Collection<VirtualFile> children, final boolean forDeletion) {\n    List<Entry> entries = ContainerUtil.mapNotNull(children, new NullableFunction<VirtualFile, Entry>() {\n      @Override\n      public Entry fun(@NotNull VirtualFile each) {\n        return doCreateEntry(each, forDeletion);\n      }\n    });\n    parent.addChildren(entries);\n  }","commit_id":"452077f7df8983c5ccf846ad2309d75e5c40c805","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean shouldRegisterDocument(VirtualFile f) {\n    if (f == null || !f.isValid()) return false;\n    return areContentChangesVersioned(f);\n  }","id":86583,"modified_method":"private boolean shouldRegisterDocument(@Nullable VirtualFile f) {\n    return f != null && f.isValid() && areContentChangesVersioned(f);\n  }","commit_id":"452077f7df8983c5ccf846ad2309d75e5c40c805","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isVersioned(VirtualFile f) {\n    if (!f.isInLocalFileSystem()) return false;\n\n    String fileName = f.getName();\n    if (!f.isDirectory() && fileName.endsWith(\".class\")) return false;\n\n    for (Project each : ProjectManager.getInstance().getOpenProjects()) {\n      if (each.isDefault()) continue;\n      if (!each.isInitialized()) continue;\n      if (each.getWorkspaceFile() == f) return false;\n      if (ProjectRootManager.getInstance(each).getFileIndex().isIgnored(f)) return false;\n    }\n\n    return !FileTypeManager.getInstance().isFileIgnored(f);\n  }","id":86584,"modified_method":"public boolean isVersioned(@NotNull VirtualFile f) {\n    if (!f.isInLocalFileSystem()) return false;\n\n    String fileName = f.getName();\n    if (!f.isDirectory() && fileName.endsWith(\".class\")) return false;\n\n    Project[] openProjects = ProjectManager.getInstance().getOpenProjects();\n    for (Project each : openProjects) {\n      if (each.isDefault()) continue;\n      if (!each.isInitialized()) continue;\n      if (each.getWorkspaceFile() == f) return false;\n      if (ProjectRootManager.getInstance(each).getFileIndex().isIgnored(f)) return false;\n    }\n\n    // optimisation: FileTypeManager.isFileIgnored(f) already checked inside ProjectFileIndex.isIgnored()\n    return openProjects.length != 0 || !FileTypeManager.getInstance().isFileIgnored(f);\n  }","commit_id":"452077f7df8983c5ccf846ad2309d75e5c40c805","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAskingForReadOnlyStatusClearingOnlyForTheSpecifiedFile() throws Exception {\n    myRoot.createChildData(null, \"foo1.txt\");\n    f.setBinaryContent(\"one\".getBytes());\n    myRoot.createChildData(null, \"foo2.txt\");\n    f.setBinaryContent(\"two\".getBytes());\n    myRoot.createChildData(null, \"foo3.txt\");\n\n    final List<VirtualFile> files = new ArrayList<VirtualFile>();\n    myGateway = new IdeaGateway() {\n      @Override\n      public boolean ensureFilesAreWritable(Project p, List<VirtualFile> ff) {\n        files.addAll(ff);\n        return true;\n      }\n    };\n\n    List<String> errors = checkCanRevertToPreviousRevision();\n    assertTrue(errors.isEmpty());\n\n    assertEquals(1, files.size());\n    assertEquals(f, files.get(0));\n  }","id":86585,"modified_method":"public void testAskingForReadOnlyStatusClearingOnlyForTheSpecifiedFile() throws Exception {\n    myRoot.createChildData(null, \"foo1.txt\");\n    f.setBinaryContent(\"one\".getBytes());\n    myRoot.createChildData(null, \"foo2.txt\");\n    f.setBinaryContent(\"two\".getBytes());\n    myRoot.createChildData(null, \"foo3.txt\");\n\n    final List<VirtualFile> files = new ArrayList<VirtualFile>();\n    myGateway = new IdeaGateway() {\n      @Override\n      public boolean ensureFilesAreWritable(@NotNull Project p, @NotNull List<VirtualFile> ff) {\n        files.addAll(ff);\n        return true;\n      }\n    };\n\n    List<String> errors = checkCanRevertToPreviousRevision();\n    assertTrue(errors.isEmpty());\n\n    assertEquals(1, files.size());\n    assertEquals(f, files.get(0));\n  }","commit_id":"452077f7df8983c5ccf846ad2309d75e5c40c805","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private VirtualFile getSelectedFile(AnActionEvent e) {\n    return e.getData(PlatformDataKeys.VIRTUAL_FILE);\n  }","id":86586,"modified_method":"@Nullable\n  private static VirtualFile getSelectedFile(DataContext context) {\n    return PlatformDataKeys.VIRTUAL_FILE.getData(context);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isExistingProjectFile(AnActionEvent e, VirtualFile file) {\n    MavenProjectsManager manager = MavenActionUtil.getProjectsManager(e);\n    return manager.findProject(file) != null;\n  }","id":86587,"modified_method":"private static boolean isExistingProjectFile(DataContext context, VirtualFile file) {\n    MavenProjectsManager manager = MavenActionUtil.getProjectsManager(context);\n    return manager.findProject(file) != null;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    MavenProjectsManager manager = MavenActionUtil.getProjectsManager(e);\n    manager.addManagedFiles(Collections.singletonList(getSelectedFile(e)));\n  }","id":86588,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    MavenProjectsManager manager = MavenActionUtil.getProjectsManager(context);\n    manager.addManagedFiles(Collections.singletonList(getSelectedFile(context)));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    VirtualFile file = getSelectedFile(e);\n    return super.isAvailable(e)\n           && MavenActionUtil.isMavenProjectFile(file)\n           && !isExistingProjectFile(e, file);\n  }","id":86589,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    VirtualFile file = getSelectedFile(context);\n    return super.isAvailable(e)\n           && MavenActionUtil.isMavenProjectFile(file)\n           && !isExistingProjectFile(context, file);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final MavenProjectsManager manager = MavenActionUtil.getProjectsManager(e);\n    FileChooserDescriptor singlePomSelection = new FileChooserDescriptor(true, false, false, false, false, true) {\n      @Override\n      public boolean isFileSelectable(VirtualFile file) {\n        return super.isFileSelectable(file) && !manager.isManagedFile(file);\n      }\n\n      @Override\n      public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n        if (!file.isDirectory() && !MavenActionUtil.isMavenProjectFile(file)) return false;\n        return super.isFileVisible(file, showHiddenFiles);\n      }\n    };\n\n    Project project = MavenActionUtil.getProject(e);\n    VirtualFile fileToSelect = e.getData(PlatformDataKeys.VIRTUAL_FILE);\n\n    FileChooserDialog dialog = FileChooserFactory.getInstance().createFileChooser(singlePomSelection, project);\n    VirtualFile[] files = dialog.choose(fileToSelect, project);\n    if (files.length == 0) return;\n\n    manager.addManagedFiles(Arrays.asList(files));\n  }","id":86590,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final MavenProjectsManager manager = MavenActionUtil.getProjectsManager(e.getDataContext());\n    FileChooserDescriptor singlePomSelection = new FileChooserDescriptor(true, false, false, false, false, true) {\n      @Override\n      public boolean isFileSelectable(VirtualFile file) {\n        return super.isFileSelectable(file) && !manager.isManagedFile(file);\n      }\n\n      @Override\n      public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n        if (!file.isDirectory() && !MavenActionUtil.isMavenProjectFile(file)) return false;\n        return super.isFileVisible(file, showHiddenFiles);\n      }\n    };\n\n    Project project = MavenActionUtil.getProject(e.getDataContext());\n    VirtualFile fileToSelect = e.getData(PlatformDataKeys.VIRTUAL_FILE);\n\n    FileChooserDialog dialog = FileChooserFactory.getInstance().createFileChooser(singlePomSelection, project);\n    VirtualFile[] files = dialog.choose(fileToSelect, project);\n    if (files.length == 0) return;\n\n    manager.addManagedFiles(Arrays.asList(files));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected MavenShortcutsManager getShortcutsManager(AnActionEvent e) {\n    return MavenShortcutsManager.getInstance(MavenActionUtil.getProject(e));\n  }","id":86591,"modified_method":"protected static MavenShortcutsManager getShortcutsManager(DataContext context) {\n    return MavenShortcutsManager.getInstance(MavenActionUtil.getProject(context));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String getGoalActionId(AnActionEvent e) {\n    MavenProject project = MavenActionUtil.getMavenProject(e);\n    if (project == null) return null;\n\n    List<String> goals = e.getData(MavenDataKeys.MAVEN_GOALS);\n    String goal = (goals == null || goals.size() != 1) ? null : goals.get(0);\n\n    return getShortcutsManager(e).getActionId(project.getPath(), goal);\n  }","id":86592,"modified_method":"@Nullable\n  private static String getGoalActionId(DataContext context) {\n    MavenProject project = MavenActionUtil.getMavenProject(context);\n    if (project == null) return null;\n\n    final List<String> goals = MavenDataKeys.MAVEN_GOALS.getData(context);\n    String goal = (goals == null || goals.size() != 1) ? null : goals.get(0);\n\n    return getShortcutsManager(context).getActionId(project.getPath(), goal);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isIgnoredProject(AnActionEvent e) {\n    MavenProject project = MavenActionUtil.getMavenProject(e);\n    if (project == null) return false;\n    return MavenActionUtil.getProjectsManager(e).isIgnored(project);\n  }","id":86593,"modified_method":"private static boolean isIgnoredProject(DataContext context) {\n    final MavenProject project = MavenActionUtil.getMavenProject(context);\n    if (project == null) return false;\n    return MavenActionUtil.getProjectsManager(context).isIgnored(project);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    String actionId = getGoalActionId(e);\n    if (actionId != null) {\n      new EditKeymapsDialog(MavenActionUtil.getProject(e), actionId).show();\n    }\n  }","id":86594,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    String actionId = getGoalActionId(context);\n    if (actionId != null) {\n      new EditKeymapsDialog(MavenActionUtil.getProject(context), actionId).show();\n    }\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && !isIgnoredProject(e) && getGoalActionId(e) != null;\n  }","id":86595,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    return super.isAvailable(e) && !isIgnoredProject(context) && getGoalActionId(context) != null;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    showSettingsFor(MavenActionUtil.getProject(e));\n  }","id":86596,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    showSettingsFor(MavenActionUtil.getProject(e.getDataContext()));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isAvailable(AnActionEvent e) {\n    return MavenActionUtil.getProject(e) != null;\n  }","id":86597,"modified_method":"protected boolean isAvailable(AnActionEvent e) {\n    return MavenActionUtil.getProject(e.getDataContext()) != null;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isAvailable(AnActionEvent e) {\n    if (MavenActionUtil.getProject(e) == null) return false;\n    return !MavenActionUtil.getMavenProjects(e).isEmpty();\n  }","id":86598,"modified_method":"protected boolean isAvailable(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    if (MavenActionUtil.getProject(context) == null) return false;\n    return !MavenActionUtil.getMavenProjects(context).isEmpty();\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<VirtualFile> getFiles(AnActionEvent e) {\n    VirtualFile[] result = e.getData(PlatformDataKeys.VIRTUAL_FILE_ARRAY);\n    return result == null ? Collections.<VirtualFile>emptyList() : Arrays.asList(result);\n  }","id":86599,"modified_method":"public static List<VirtualFile> getMavenProjectsFiles(DataContext context) {\n    return MavenUtil.collectFiles(getMavenProjects(context));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isMavenProjectFile(VirtualFile file) {\n    return file != null && !file.isDirectory() && MavenConstants.POM_XML.equals(file.getName());\n  }","id":86600,"modified_method":"public static MavenProjectsManager getProjectsManager(DataContext context) {\n    return MavenProjectsManager.getInstance(getProject(context));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static MavenProject getMavenProject(AnActionEvent e) {\n    MavenProject result;\n    MavenProjectsManager manager = getProjectsManager(e);\n\n    VirtualFile file = e.getData(PlatformDataKeys.VIRTUAL_FILE);\n    if (file != null) {\n      result = manager.findProject(file);\n      if (result != null) return result;\n    }\n\n    Module module = getModule(e);\n    if (module != null) {\n      result = manager.findProject(module);\n      if (result != null) return result;\n    }\n\n    return null;\n  }","id":86601,"modified_method":"public static MavenProject getMavenProject(DataContext context) {\n    MavenProject result;\n    final MavenProjectsManager manager = getProjectsManager(context);\n\n    final VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(context);\n    if (file != null) {\n      result = manager.findProject(file);\n      if (result != null) return result;\n    }\n\n    Module module = getModule(context);\n    if (module != null) {\n      result = manager.findProject(module);\n      if (result != null) return result;\n    }\n\n    return null;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<MavenProject> getMavenProjects(AnActionEvent e) {\n    Set<MavenProject> result = new LinkedHashSet<MavenProject>();\n    for (VirtualFile each : getFiles(e)) {\n      MavenProject project = getProjectsManager(e).findProject(each);\n      if (project != null) result.add(project);\n    }\n    if (result.isEmpty()) {\n      for (Module each : getModules(e)) {\n        MavenProject project = getProjectsManager(e).findProject(each);\n        if (project != null) result.add(project);\n      }\n    }\n    return new ArrayList<MavenProject>(result);\n  }","id":86602,"modified_method":"public static List<MavenProject> getMavenProjects(DataContext context) {\n    Set<MavenProject> result = new LinkedHashSet<MavenProject>();\n    for (VirtualFile each : getFiles(context)) {\n      MavenProject project = getProjectsManager(context).findProject(each);\n      if (project != null) result.add(project);\n    }\n    if (result.isEmpty()) {\n      for (Module each : getModules(context)) {\n        MavenProject project = getProjectsManager(context).findProject(each);\n        if (project != null) result.add(project);\n      }\n    }\n    return new ArrayList<MavenProject>(result);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      MavenRunnerParameters params = new MavenRunnerParameters(true,\n                                                               myMavenProject.getDirectory(),\n                                                               Arrays.asList(myGoal),\n                                                               MavenActionUtil.getProjectsManager(e).getExplicitProfiles());\n      MavenRunConfigurationType.runConfiguration(MavenActionUtil.getProject(e), params, e.getDataContext(), null);\n    }","id":86603,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      final DataContext context = e.getDataContext();\n      MavenRunnerParameters params = new MavenRunnerParameters(true,\n                                                               myMavenProject.getDirectory(),\n                                                               Arrays.asList(myGoal),\n                                                               MavenActionUtil.getProjectsManager(context).getExplicitProfiles());\n      MavenRunConfigurationType.runConfiguration(MavenActionUtil.getProject(context), params, context, null);\n    }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = MavenActionUtil.getProject(e);\n    final List<File> files = getFiles(e);\n    final List<VirtualFile> virtualFiles = collectVirtualFiles(files);\n\n    if (files.size() == 1 && virtualFiles.isEmpty()) {\n      new WriteCommandAction(project, e.getPresentation().getText()) {\n        @Override\n        protected void run(Result result) throws Throwable {\n          File file = files.get(0);\n          try {\n            VirtualFile newFile = VfsUtil.createDirectoryIfMissing(file.getParent()).createChildData(this, file.getName());\n            virtualFiles.add(newFile);\n            MavenUtil.runFileTemplate(project, newFile, getFileTemplate());\n          }\n          catch (IOException ex) {\n            MavenUtil.showError(project, \"Cannot create \" + file.getName(), ex);\n          }\n        }\n      }.execute();\n      return;\n    }\n\n    for (VirtualFile each : virtualFiles) {\n      new OpenFileDescriptor(project, each).navigate(true);\n    }\n  }","id":86604,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final Project project = MavenActionUtil.getProject(e.getDataContext());\n    final List<File> files = getFiles(e);\n    final List<VirtualFile> virtualFiles = collectVirtualFiles(files);\n\n    if (files.size() == 1 && virtualFiles.isEmpty()) {\n      new WriteCommandAction(project, e.getPresentation().getText()) {\n        @Override\n        protected void run(Result result) throws Throwable {\n          File file = files.get(0);\n          try {\n            VirtualFile newFile = VfsUtil.createDirectoryIfMissing(file.getParent()).createChildData(this, file.getName());\n            virtualFiles.add(newFile);\n            MavenUtil.runFileTemplate(project, newFile, getFileTemplate());\n          }\n          catch (IOException ex) {\n            MavenUtil.showError(project, \"Cannot create \" + file.getName(), ex);\n          }\n        }\n      }.execute();\n      return;\n    }\n\n    for (VirtualFile each : virtualFiles) {\n      new OpenFileDescriptor(project, each).navigate(true);\n    }\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && !MavenActionUtil.getMavenProjects(e).isEmpty();\n  }","id":86605,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && !MavenActionUtil.getMavenProjects(e.getDataContext()).isEmpty();\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    perform(MavenActionUtil.getProjectsManager(e), MavenActionUtil.getMavenProjects(e), e);\n  }","id":86606,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    perform(MavenActionUtil.getProjectsManager(context), MavenActionUtil.getMavenProjects(context), e);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    perform(MavenActionUtil.getProjectsManager(e));\n  }","id":86607,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    perform(MavenActionUtil.getProjectsManager(e.getDataContext()));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MavenProjectsNavigator getNavigator(AnActionEvent e) {\n    return MavenProjectsNavigator.getInstance(MavenActionUtil.getProject(e));\n  }","id":86608,"modified_method":"private MavenProjectsNavigator getNavigator(AnActionEvent e) {\n    return MavenProjectsNavigator.getInstance(MavenActionUtil.getProject(e.getDataContext()));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isAvailable(AnActionEvent e) {\n    return MavenActionUtil.getProject(e) != null;\n  }","id":86609,"modified_method":"protected boolean isAvailable(AnActionEvent e) {\n    return MavenActionUtil.getProject(e.getDataContext()) != null;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected List<File> getFiles(AnActionEvent e) {\n    List<File> result = new ArrayList<File>();\n    for (MavenProject each : MavenActionUtil.getMavenProjects(e)) {\n      result.add(each.getProfilesXmlIoFile());\n    }\n    return result;\n  }","id":86610,"modified_method":"protected List<File> getFiles(AnActionEvent e) {\n    List<File> result = new ArrayList<File>();\n    for (MavenProject each : MavenActionUtil.getMavenProjects(e.getDataContext())) {\n      result.add(each.getProfilesXmlIoFile());\n    }\n    return result;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected List<File> getFiles(AnActionEvent e) {\n    File file = MavenActionUtil.getProjectsManager(e).getGeneralSettings().getEffectiveUserSettingsIoFile();\n    return file != null ? Collections.singletonList(file) : Collections.EMPTY_LIST;\n  }","id":86611,"modified_method":"protected List<File> getFiles(AnActionEvent e) {\n    File file = MavenActionUtil.getProjectsManager(e.getDataContext()).getGeneralSettings().getEffectiveUserSettingsIoFile();\n    return file != null ? Collections.singletonList(file) : Collections.EMPTY_LIST;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    for (VirtualFile each : MavenActionUtil.getMavenProjectsFiles(e)) {\n      if (MavenActionUtil.getProjectsManager(e).isManagedFile(each)) return true;\n    }\n    return false;\n  }","id":86612,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    for (VirtualFile each : MavenActionUtil.getMavenProjectsFiles(context)) {\n      if (MavenActionUtil.getProjectsManager(context).isManagedFile(each)) return true;\n    }\n    return false;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    MavenActionUtil.getProjectsManager(e).removeManagedFiles(MavenActionUtil.getMavenProjectsFiles(e));\n  }","id":86613,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    MavenActionUtil.getProjectsManager(context).removeManagedFiles(MavenActionUtil.getMavenProjectsFiles(context));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && checkOrPerform(e, false);\n  }","id":86614,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && checkOrPerform(e.getDataContext(), false);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    checkOrPerform(e, true);\n  }","id":86615,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    checkOrPerform(e.getDataContext(), true);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean checkOrPerform(AnActionEvent e, boolean perform) {\n    MavenProject project = MavenActionUtil.getMavenProject(e);\n    if (project == null) return false;\n\n    List<String> goals = e.getData(MavenDataKeys.MAVEN_GOALS);\n    if (goals == null || goals.isEmpty()) return false;\n\n    if (!perform) return true;\n\n    MavenRunnerParameters params = new MavenRunnerParameters(\n      true, project.getDirectory(), goals, MavenActionUtil.getProjectsManager(e).getExplicitProfiles());\n    MavenRunConfigurationType.runConfiguration(MavenActionUtil.getProject(e), params, e.getDataContext(), null);\n\n    return true;\n  }","id":86616,"modified_method":"private static boolean checkOrPerform(DataContext context, boolean perform) {\n    final MavenProject project = MavenActionUtil.getMavenProject(context);\n    if (project == null) return false;\n\n    final List<String> goals = MavenDataKeys.MAVEN_GOALS.getData(context);\n    if (goals == null || goals.isEmpty()) return false;\n\n    if (!perform) return true;\n\n    final MavenRunnerParameters params = new MavenRunnerParameters(true,\n                                                                   project.getDirectory(),\n                                                                   goals,\n                                                                   MavenActionUtil.getProjectsManager(context).getExplicitProfiles());\n    MavenRunConfigurationType.runConfiguration(MavenActionUtil.getProject(context), params, context, null);\n\n    return true;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && getTaskDesc(e) != null;\n  }","id":86617,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && getTaskDesc(e.getDataContext()) != null;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private RunManagerEx getRunManager(AnActionEvent e) {\n    return RunManagerEx.getInstanceEx(MavenActionUtil.getProject(e));\n  }","id":86618,"modified_method":"private static RunManagerEx getRunManager(DataContext context) {\n    return RunManagerEx.getInstanceEx(MavenActionUtil.getProject(context));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setSelected(final AnActionEvent e, boolean state) {\n    Pair<MavenProject, String> desc = getTaskDesc(e);\n    new MavenExecuteBeforeRunDialog(MavenActionUtil.getProject(e), desc.first, desc.second).show();\n  }","id":86619,"modified_method":"@Override\n  public void setSelected(final AnActionEvent e, boolean state) {\n    final DataContext context = e.getDataContext();\n    final Pair<MavenProject, String> desc = getTaskDesc(context);\n    if (desc != null) {\n      new MavenExecuteBeforeRunDialog(MavenActionUtil.getProject(context), desc.first, desc.second).show();\n    }\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    Pair<MavenProject, String> desc = getTaskDesc(e);\n    for (MavenBeforeRunTask each : getRunManager(e).getBeforeRunTasks(MavenBeforeRunTasksProvider.TASK_ID, true)) {\n      if (each.isEnabled() && each.isFor(desc.first, desc.second)) return true;\n    }\n    return false;\n  }","id":86620,"modified_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    final Pair<MavenProject, String> desc = getTaskDesc(context);\n    if (desc != null) {\n      for (MavenBeforeRunTask each : getRunManager(context).getBeforeRunTasks(MavenBeforeRunTasksProvider.TASK_ID, true)) {\n        if (each.isEnabled() && each.isFor(desc.first, desc.second)) return true;\n      }\n    }\n    return false;\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    return hasTask(getTasksManager(e), getTasks(e).get(0));\n  }","id":86621,"modified_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    return hasTask(getTasksManager(context), getTasks(context).get(0));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MavenTasksManager getTasksManager(AnActionEvent e) {\n    return MavenTasksManager.getInstance(MavenActionUtil.getProject(e));\n  }","id":86622,"modified_method":"private static MavenTasksManager getTasksManager(DataContext context) {\n    return MavenTasksManager.getInstance(MavenActionUtil.getProject(context));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && !getTasks(e).isEmpty();\n  }","id":86623,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    return super.isAvailable(e) && !getTasks(e.getDataContext()).isEmpty();\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state) {\n    List<MavenCompilerTask> tasks = getTasks(e);\n    if (state) {\n      addTasks(getTasksManager(e), tasks);\n    }\n    else {\n      removeTasks(getTasksManager(e), tasks);\n    }\n  }","id":86624,"modified_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state) {\n    final DataContext context = e.getDataContext();\n    List<MavenCompilerTask> tasks = getTasks(context);\n    if (state) {\n      addTasks(getTasksManager(context), tasks);\n    }\n    else {\n      removeTasks(getTasksManager(context), tasks);\n    }\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    if (!isAvailable(e)) return;\n\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(e);\n    List<MavenProject> projects = MavenActionUtil.getMavenProjects(e);\n\n    if (isIgnoredInSettings(projectsManager, projects)) {\n      e.getPresentation().setText(ProjectBundle.message(\"maven.ignore.edit\"));\n    }\n    else if (isIgnored(projectsManager, projects)) {\n      e.getPresentation().setText(ProjectBundle.message(\"maven.unignore\"));\n    }\n    else {\n      e.getPresentation().setText(ProjectBundle.message(\"maven.ignore\"));\n    }\n  }","id":86625,"modified_method":"@Override\n  public void update(AnActionEvent e) {\n    super.update(e);\n    if (!isAvailable(e)) return;\n\n    final DataContext context = e.getDataContext();\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(context);\n    List<MavenProject> projects = MavenActionUtil.getMavenProjects(context);\n\n    if (isIgnoredInSettings(projectsManager, projects)) {\n      e.getPresentation().setText(ProjectBundle.message(\"maven.ignore.edit\"));\n    }\n    else if (isIgnored(projectsManager, projects)) {\n      e.getPresentation().setText(ProjectBundle.message(\"maven.unignore\"));\n    }\n    else {\n      e.getPresentation().setText(ProjectBundle.message(\"maven.ignore\"));\n    }\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    if (!super.isAvailable(e)) return false;\n\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(e);\n    List<MavenProject> projects = MavenActionUtil.getMavenProjects(e);\n\n    if (projects == null || projects.isEmpty()) return false;\n\n    int ignoredStatesCount = 0;\n    int ignoredCount = 0;\n\n    for (MavenProject each : projects) {\n      if (projectsManager.getIgnoredState(each)) {\n        ignoredStatesCount++;\n      }\n      if (projectsManager.isIgnored(each)) {\n        ignoredCount++;\n      }\n    }\n\n    return (ignoredCount == 0 || ignoredCount == projects.size()) &&\n           (ignoredStatesCount == 0 || ignoredStatesCount == projects.size());\n  }","id":86626,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    if (!super.isAvailable(e)) return false;\n\n    final DataContext context = e.getDataContext();\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(context);\n    List<MavenProject> projects = MavenActionUtil.getMavenProjects(context);\n\n    if (projects == null || projects.isEmpty()) return false;\n\n    int ignoredStatesCount = 0;\n    int ignoredCount = 0;\n\n    for (MavenProject each : projects) {\n      if (projectsManager.getIgnoredState(each)) {\n        ignoredStatesCount++;\n      }\n      if (projectsManager.isIgnored(each)) {\n        ignoredCount++;\n      }\n    }\n\n    return (ignoredCount == 0 || ignoredCount == projects.size()) &&\n           (ignoredStatesCount == 0 || ignoredStatesCount == projects.size());\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(e);\n    List<MavenProject> projects = MavenActionUtil.getMavenProjects(e);\n\n    if (isIgnoredInSettings(projectsManager, projects)) {\n      ShowSettingsUtil.getInstance().editConfigurable(MavenActionUtil.getProject(e), new MavenIgnoredFilesConfigurable(projectsManager));\n    }\n    else {\n      projectsManager.setIgnoredState(projects, !isIgnored(projectsManager, projects));\n    }\n  }","id":86627,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    final DataContext context = e.getDataContext();\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(context);\n    List<MavenProject> projects = MavenActionUtil.getMavenProjects(context);\n\n    if (isIgnoredInSettings(projectsManager, projects)) {\n      ShowSettingsUtil.getInstance().editConfigurable(MavenActionUtil.getProject(context), new MavenIgnoredFilesConfigurable(projectsManager));\n    }\n    else {\n      projectsManager.setIgnoredState(projects, !isIgnored(projectsManager, projects));\n    }\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state) {\n    MavenActionUtil.getProjectsManager(e).getGeneralSettings().setWorkOffline(state);\n  }","id":86628,"modified_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state) {\n    MavenActionUtil.getProjectsManager(e.getDataContext()).getGeneralSettings().setWorkOffline(state);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    return MavenActionUtil.getProjectsManager(e).getGeneralSettings().isWorkOffline();\n  }","id":86629,"modified_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    return MavenActionUtil.getProjectsManager(e.getDataContext()).getGeneralSettings().isWorkOffline();\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    MavenProjectsManager manager = MavenActionUtil.getProjectsManager(e);\n    List<String> selectedProfiles = e.getData(MavenDataKeys.MAVEN_PROFILES);\n\n    Collection<String> activeProfiles = manager.getExplicitProfiles();\n    if (isActive(manager, selectedProfiles)) {\n      activeProfiles.removeAll(selectedProfiles);\n    }\n    else {\n      activeProfiles.addAll(selectedProfiles);\n    }\n    manager.setExplicitProfiles(activeProfiles);\n  }","id":86630,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    MavenProjectsManager manager = MavenActionUtil.getProjectsManager(e.getDataContext());\n    List<String> selectedProfiles = e.getData(MavenDataKeys.MAVEN_PROFILES);\n\n    Collection<String> activeProfiles = manager.getExplicitProfiles();\n    if (isActive(manager, selectedProfiles)) {\n      activeProfiles.removeAll(selectedProfiles);\n    }\n    else {\n      activeProfiles.addAll(selectedProfiles);\n    }\n    manager.setExplicitProfiles(activeProfiles);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    super.update(e);\n    if (!isAvailable(e)) return;\n\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(e);\n    List<String> profiles = e.getData(MavenDataKeys.MAVEN_PROFILES);\n\n    e.getPresentation().setText(isActive(projectsManager, profiles)\n                                ? ProjectBundle.message(\"maven.profile.deactivate\")\n                                : ProjectBundle.message(\"maven.profile.activate\"));\n  }","id":86631,"modified_method":"public void update(AnActionEvent e) {\n    super.update(e);\n    if (!isAvailable(e)) return;\n\n    MavenProjectsManager projectsManager = MavenActionUtil.getProjectsManager(e.getDataContext());\n    List<String> profiles = e.getData(MavenDataKeys.MAVEN_PROFILES);\n\n    e.getPresentation().setText(isActive(projectsManager, profiles)\n                                ? ProjectBundle.message(\"maven.profile.deactivate\")\n                                : ProjectBundle.message(\"maven.profile.activate\"));\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    if (!super.isAvailable(e)) return false;\n\n    List<String> selectedProfiles = e.getData(MavenDataKeys.MAVEN_PROFILES);\n    if (selectedProfiles == null || selectedProfiles.isEmpty()) return false;\n\n    Collection<String> activeProfiles = MavenActionUtil.getProjectsManager(e).getExplicitProfiles();\n    int activeCount = 0;\n    for (String profile : selectedProfiles) {\n      if (activeProfiles.contains(profile)) {\n        activeCount++;\n      }\n    }\n    return activeCount == 0 || activeCount == selectedProfiles.size();\n  }","id":86632,"modified_method":"@Override\n  protected boolean isAvailable(AnActionEvent e) {\n    if (!super.isAvailable(e)) return false;\n\n    List<String> selectedProfiles = e.getData(MavenDataKeys.MAVEN_PROFILES);\n    if (selectedProfiles == null || selectedProfiles.isEmpty()) return false;\n\n    Collection<String> activeProfiles = MavenActionUtil.getProjectsManager(e.getDataContext()).getExplicitProfiles();\n    int activeCount = 0;\n    for (String profile : selectedProfiles) {\n      if (activeProfiles.contains(profile)) {\n        activeCount++;\n      }\n    }\n    return activeCount == 0 || activeCount == selectedProfiles.size();\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    return MavenRunner.getInstance(MavenActionUtil.getProject(e)).getState().isSkipTests();\n  }","id":86633,"modified_method":"@Override\n  protected boolean doIsSelected(AnActionEvent e) {\n    return MavenRunner.getInstance(MavenActionUtil.getProject(e.getDataContext())).getState().isSkipTests();\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state){\n    MavenRunner.getInstance(MavenActionUtil.getProject(e)).getState().setSkipTests(state);\n  }","id":86634,"modified_method":"@Override\n  public void setSelected(AnActionEvent e, boolean state){\n    MavenRunner.getInstance(MavenActionUtil.getProject(e.getDataContext())).getState().setSkipTests(state);\n  }","commit_id":"db4166e0282227febe63275135b9b741baa6baef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n      myScopePanel.setBorder(IdeBorderFactory.createTitledBorder(myAnalysisNoon + \" scope\"));\n      myPackageButton.setText(myAnalysisVerb + StringUtil.decapitalize(myPackageName));\n      myPackageButton.setMnemonic(KeyEvent.VK_K);\n      myProjectButton.setText(myAnalysisVerb + \" the whole project\");\n      myProjectButton.setMnemonic(KeyEvent.VK_P);\n      ButtonGroup group = new ButtonGroup();\n      group.add(myProjectButton);\n      if (myModuleName != null) {\n        myModuleButton.setText(myAnalysisVerb + \" module \\'\" + myModuleName + \"\\'\");\n        myModuleButton.setMnemonic(KeyEvent.VK_M);\n        group.add(myModuleButton);\n      }\n      group.add(myPackageButton);\n      myPerPackageCycleCount.setFormatterFactory(new DefaultFormatterFactory());\n      myPerPackageCycleCount.setText(\"1\");\n      if (!myShowChooseScope){\n        myScopePanel.setVisible(false);\n      }\n      return myWholePanel;\n    }","id":86635,"modified_method":"protected JComponent createCenterPanel() {\n      myScopePanel.setBorder(IdeBorderFactory.createTitledBorder(myAnalysisNoon + \" scope\"));\n      myProjectButton.setText(myAnalysisVerb + \" the whole project\");\n      myProjectButton.setMnemonic(KeyEvent.VK_P);\n      ButtonGroup group = new ButtonGroup();\n      group.add(myProjectButton);\n      if (myModuleName != null) {\n        myModuleButton.setText(myAnalysisVerb + \" module \\'\" + myModuleName + \"\\'\");\n        myModuleButton.setMnemonic(KeyEvent.VK_M);\n        group.add(myModuleButton);\n      }\n      return myWholePanel;\n    }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProjectModuleOrPackageDialog(DataContext dataContext, String moduleName, boolean showChooseScope) {\n      super(true);\n      myShowChooseScope = showChooseScope;\n      myModuleName = moduleName;\n      final AnalysisScope scope = getPackageScope(dataContext);\n      if (scope != null){\n        myPackageName = scope.getDisplayName();\n      }\n      init();\n      setTitle(\"Specify \" + myTitle + \" Scope\");\n      if (scope == null){\n        myPackageButton.setVisible(false);\n        myProjectButton.setSelected(true);\n      } else {\n        myPackageButton.setSelected(true);\n      }\n      if (moduleName == null){\n        myModuleButton.setVisible(false);\n      }\n    }","id":86636,"modified_method":"public ProjectModuleOrPackageDialog(String moduleName) {\n      super(true);\n      myModuleName = moduleName;\n      init();\n      setTitle(\"Specify \" + myTitle + \" Scope\");\n\n      if (moduleName == null){\n        myModuleButton.setVisible(false);\n        myProjectButton.setSelected(true);\n      } else {\n        myModuleButton.setSelected(true);\n      }\n    }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AnalysisScope getInspectionScopeImpl(DataContext dataContext) {\n    //Possible scopes: package, project, module.\n    Project projectContext = (Project)dataContext.getData(DataConstantsEx.PROJECT_CONTEXT);\n    if (projectContext != null) {\n      return new AnalysisScope(projectContext, myFileFilter);\n    }\n\n    Module moduleContext = (Module)dataContext.getData(DataConstantsEx.MODULE_CONTEXT);\n    if (moduleContext != null) {\n      return new AnalysisScope(moduleContext, myFileFilter);\n    }\n\n    Module [] modulesArray = (Module[])dataContext.getData(DataConstantsEx.MODULE_CONTEXT_ARRAY);\n    if (modulesArray != null) {\n      return new AnalysisScope(modulesArray, myFileFilter);\n    }\n\n    AnalysisScope packageScope = getPackageScope(dataContext);\n    if (packageScope != null){\n      return packageScope;\n    }\n\n    return getProjectScope(dataContext);\n  }","id":86637,"modified_method":"private AnalysisScope getInspectionScopeImpl(DataContext dataContext) {\n    //Possible scopes: package, project, module.\n    Project projectContext = (Project)dataContext.getData(DataConstantsEx.PROJECT_CONTEXT);\n    if (projectContext != null) {\n      return new AnalysisScope(projectContext, myFileFilter);\n    }\n\n    Module moduleContext = (Module)dataContext.getData(DataConstantsEx.MODULE_CONTEXT);\n    if (moduleContext != null) {\n      return new AnalysisScope(moduleContext, myFileFilter);\n    }\n\n    Module [] modulesArray = (Module[])dataContext.getData(DataConstantsEx.MODULE_CONTEXT_ARRAY);\n    if (modulesArray != null) {\n      return new AnalysisScope(modulesArray, myFileFilter);\n    }\n\n    PsiElement psiTarget = (PsiElement)dataContext.getData(DataConstants.PSI_ELEMENT);\n    if (psiTarget instanceof PsiDirectory) {\n      PsiDirectory psiDirectory = (PsiDirectory)psiTarget;\n      if (!psiDirectory.getManager().isInProject(psiDirectory)) return null;\n      return new AnalysisScope(psiDirectory, myFileFilter);\n    }\n    else if (psiTarget instanceof PsiPackage) {\n      PsiPackage pack = (PsiPackage)psiTarget;\n      PsiDirectory[] dirs = pack.getDirectories(GlobalSearchScope.projectScope(pack.getProject()));\n      if (dirs == null || dirs.length == 0) return null;\n      return new AnalysisScope(pack, myFileFilter);\n    } else if (psiTarget != null){\n      return null;\n    }\n\n\n    return getProjectScope(dataContext);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    final Module module = (Module)dataContext.getData(DataConstants.MODULE);\n    if (project != null) {\n      PsiFile psiFile = (PsiFile)dataContext.getData(DataConstants.PSI_FILE);\n      if (psiFile != null && !(psiFile instanceof PsiJavaFile)) {\n        return;\n      }\n      AnalysisScope scope = getInspectionScope(dataContext);\n      boolean showChooseScope = true;\n      if (scope.getScopeType() == AnalysisScope.MODULES){\n        showChooseScope = false;\n      }\n      ProjectModuleOrPackageDialog dlg = new ProjectModuleOrPackageDialog(dataContext,\n                                                        module != null ? ModuleUtil.getModuleNameInReadAction(module) : null,\n                                                        showChooseScope);\n      dlg.show();\n      if (!dlg.isOK()) return;\n      if (showChooseScope){\n        if (dlg.isProjectScopeSelected()) {\n          scope = getProjectScope(dataContext);\n        }\n        else {\n          if (dlg.isModuleScopeSelected()) {\n            scope = getModuleScope(dataContext);\n          }\n        }\n      }\n\n      FileDocumentManager.getInstance().saveAllDocuments();\n\n      new CyclicDependenciesHandler(project, scope, dlg.getMaxPerPackageCycleCount()).analyze();\n    }\n  }","id":86638,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    final Module module = (Module)dataContext.getData(DataConstants.MODULE);\n    if (project != null) {\n      PsiFile psiFile = (PsiFile)dataContext.getData(DataConstants.PSI_FILE);\n      if (psiFile != null && !(psiFile instanceof PsiJavaFile)) {\n        return;\n      }\n      AnalysisScope scope = getInspectionScope(dataContext);\n      if (scope == null || scope.getScopeType() != AnalysisScope.MODULES){\n        ProjectModuleOrPackageDialog dlg = new ProjectModuleOrPackageDialog(module != null ? ModuleUtil.getModuleNameInReadAction(module) : null);\n        dlg.show();\n        if (!dlg.isOK()) return;\n        if (dlg.isProjectScopeSelected()) {\n          scope = getProjectScope(dataContext);\n        }\n        else {\n          if (dlg.isModuleScopeSelected()) {\n            scope = getModuleScope(dataContext);\n          }\n        }\n      }\n\n      FileDocumentManager.getInstance().saveAllDocuments();\n\n      new CyclicDependenciesHandler(project, scope).analyze();\n    }\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void analyze() {\n    final ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(getProject()).getFileIndex();\n    getScope().accept(new PsiRecursiveElementVisitor() {\n\n      public void visitFile(PsiFile file) {\n        if (file != null && file instanceof PsiJavaFile) {\n          PsiJavaFile psiJavaFile = (PsiJavaFile)file;\n          if (getScope().contains(psiJavaFile)) {\n            final PsiPackage aPackage = findPackage(psiJavaFile.getPackageName());\n            if (aPackage != null) {\n              myPackages.put(psiJavaFile.getPackageName(), aPackage);\n            }\n          }\n          final Set<PsiPackage> packs = getPackageHierarhy(psiJavaFile.getPackageName());\n          final ForwardDependenciesBuilder builder = new ForwardDependenciesBuilder(getProject(),\n                                                                                    new AnalysisScope(psiJavaFile,\n                                                                                                      AnalysisScope.SOURCE_JAVA_FILES));\n          builder.setTotalFileCount(getScope().getFileCount());\n          builder.setInitialFileCount(++myFileCount);\n          builder.analyze();\n          final Set<PsiFile> psiFiles = builder.getDependencies().get(psiJavaFile);\n          for (Iterator<PsiPackage> iterator = packs.iterator(); iterator.hasNext();) {\n            PsiPackage pack = iterator.next();\n            Set<PsiPackage> pack2Packages = myPackageDependencies.get(pack);\n            if (pack2Packages == null) {\n              pack2Packages = new HashSet<PsiPackage>();\n              myPackageDependencies.put(pack, pack2Packages);\n            }\n            for (Iterator<PsiFile> it = psiFiles.iterator(); it.hasNext();) {\n              PsiFile psiFile = it.next();\n              if (!(psiFile instanceof PsiJavaFile) ||\n                  !projectFileIndex.isInSourceContent(psiFile.getVirtualFile()) ||\n                  !getScope().contains(psiFile)) {\n                continue;\n              }\n\n              // construct dependent packages\n              final String packageName = ((PsiJavaFile)psiFile).getPackageName();\n              //do not depend on parent packages\n              if (packageName == null || packageName.startsWith(pack.getQualifiedName())) {\n                continue;\n              }\n              final Set<PsiPackage> depPackages = getPackageHierarhy(packageName);\n              if (depPackages.isEmpty()) { //not from analyze scope\n                continue;\n              }\n              pack2Packages.addAll(depPackages);\n\n              for (Iterator<PsiPackage> depIt = depPackages.iterator(); depIt.hasNext();) {\n                PsiPackage depPackage = depIt.next();\n                constractFilesInDependenciesPackagesMap(pack, depPackage, psiFile, myFilesInDependentPackages);\n                constractFilesInDependenciesPackagesMap(depPackage, pack, psiJavaFile, myBackwardFilesInDependentPackages);\n              }\n              \n              constractWholeDependenciesMap(psiJavaFile, psiFile);\n            }\n          }\n        }\n      }\n    });\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      if (indicator.isCanceled()) {\n        throw new ProcessCanceledException();\n      }\n      indicator.setText(\"Building dependencies graph\");\n      indicator.setText2(\"\");\n      indicator.setIndeterminate(true);\n    }\n    myCyclicDependencies = getCycles(myPackages.values(), myPerPackageCycleCount);\n  }","id":86639,"modified_method":"public void analyze() {\n    final ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(getProject()).getFileIndex();\n    getScope().accept(new PsiRecursiveElementVisitor() {\n      public void visitFile(PsiFile file) {\n        if (file != null && file instanceof PsiJavaFile) {\n          PsiJavaFile psiJavaFile = (PsiJavaFile)file;\n          if (getScope().contains(psiJavaFile)) {\n            final PsiPackage aPackage = findPackage(psiJavaFile.getPackageName());\n            if (aPackage != null) {\n              myPackages.put(psiJavaFile.getPackageName(), aPackage);\n            }\n          }\n          final Set<PsiPackage> packs = getPackageHierarhy(psiJavaFile.getPackageName());\n          final ForwardDependenciesBuilder builder = new ForwardDependenciesBuilder(getProject(),\n                                                                                    new AnalysisScope(psiJavaFile,\n                                                                                                      AnalysisScope.SOURCE_JAVA_FILES));\n          builder.setTotalFileCount(getScope().getFileCount());\n          builder.setInitialFileCount(++myFileCount);\n          builder.analyze();\n          final Set<PsiFile> psiFiles = builder.getDependencies().get(psiJavaFile);\n          for (Iterator<PsiPackage> iterator = packs.iterator(); iterator.hasNext();) {\n            PsiPackage pack = iterator.next();\n            Set<PsiPackage> pack2Packages = myPackageDependencies.get(pack);\n            if (pack2Packages == null) {\n              pack2Packages = new HashSet<PsiPackage>();\n              myPackageDependencies.put(pack, pack2Packages);\n            }\n            for (Iterator<PsiFile> it = psiFiles.iterator(); it.hasNext();) {\n              PsiFile psiFile = it.next();\n              if (!(psiFile instanceof PsiJavaFile) ||\n                  !projectFileIndex.isInSourceContent(psiFile.getVirtualFile()) ||\n                  !getScope().contains(psiFile)) {\n                continue;\n              }\n\n              // construct dependent packages\n              final String packageName = ((PsiJavaFile)psiFile).getPackageName();\n              //do not depend on parent packages\n              if (packageName == null || packageName.startsWith(pack.getQualifiedName())) {\n                continue;\n              }\n              final PsiPackage depPackage = findPackage(packageName);\n              if (depPackage == null) { //not from analyze scope\n                continue;\n              }\n              pack2Packages.add(depPackage);\n\n              constractFilesInDependenciesPackagesMap(pack, depPackage, psiFile, myFilesInDependentPackages);\n              constractFilesInDependenciesPackagesMap(depPackage, pack, psiJavaFile, myBackwardFilesInDependentPackages);\n              constractWholeDependenciesMap(psiJavaFile, psiFile);\n            }\n          }\n        }\n      }\n    });\n    ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    if (indicator != null) {\n      if (indicator.isCanceled()) {\n        throw new ProcessCanceledException();\n      }\n      indicator.setText(\"Building dependencies graph\");\n      indicator.setText2(\"\");\n      indicator.setIndeterminate(true);\n    }\n    myCyclicDependencies = getCycles(myPackages.values());\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Set<PsiFile> getDependentFilesInPackage(PsiPackage firstPack, PsiPackage middlePack, PsiPackage lastPack) {\n    Set<PsiFile> result = new HashSet<PsiFile>();\n    final Map<PsiPackage, Set<PsiFile>> forwardMap = myFilesInDependentPackages.get(middlePack);\n    if (forwardMap != null && forwardMap.get(lastPack) != null){\n      result.addAll(forwardMap.get(lastPack));\n    }\n    final Map<PsiPackage, Set<PsiFile>> backwardMap = myBackwardFilesInDependentPackages.get(middlePack);\n    if (backwardMap != null && backwardMap.get(firstPack) != null){\n      result.addAll(backwardMap.get(firstPack));\n    }\n    return result;\n  }","id":86640,"modified_method":"public Set<PsiFile> getDependentFilesInPackage(PsiPackage firstPack, PsiPackage middlePack, PsiPackage lastPack) {\n    Set<PsiFile> result = new HashSet<PsiFile>();\n    final Map<PsiPackage, Set<PsiFile>> forwardMap = myFilesInDependentPackages.get(firstPack);\n    if (forwardMap != null && forwardMap.get(middlePack) != null){\n      result.addAll(forwardMap.get(middlePack));\n    }\n    final Map<PsiPackage, Set<PsiFile>> backwardMap = myBackwardFilesInDependentPackages.get(lastPack);\n    if (backwardMap != null && backwardMap.get(middlePack) != null){\n      result.addAll(backwardMap.get(middlePack));\n    }\n    return result;\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> getCycles(Collection<PsiPackage> packages, int perPackageCycleCount) {\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> result = new HashMap<PsiPackage, Set<ArrayList<PsiPackage>>>();\n    final List<Chunk<PsiPackage>> chunks = buildChunks();\n    for (Iterator<PsiPackage> iterator = packages.iterator(); iterator.hasNext();) {\n      PsiPackage psiPackage = iterator.next();\n      final List<Chunk<PsiPackage>> chunksByPackage = findChunksByPackage(psiPackage, chunks);\n      for (Iterator<Chunk<PsiPackage>> it = chunksByPackage.iterator(); it.hasNext();) {\n        Chunk<PsiPackage> chunk = it.next();\n        if (chunk.getNodes().size() == 1){\n          continue;\n        }\n        Set<ArrayList<PsiPackage>> paths2Pack = result.get(psiPackage);\n        if (paths2Pack == null) {\n          paths2Pack = new HashSet<ArrayList<PsiPackage>>();\n          result.put(psiPackage, paths2Pack);\n        }\n        final GraphTraverser graphTraverser = new GraphTraverser(psiPackage, chunk, perPackageCycleCount);\n        paths2Pack.addAll(graphTraverser.convert(graphTraverser.traverse()));\n      }\n    }\n    /*for (Iterator<Chunk<PsiPackage>> iterator = chunks.iterator(); iterator.hasNext();) {\n      Chunk<PsiPackage> chunk = iterator.next();\n      for (Iterator<PsiPackage> it = chunk.getNodes().iterator(); it.hasNext();) {\n        PsiPackage pack = it.next();\n        Set<Chunk<PsiPackage>> chunks2Pack = result.get(pack);\n        if (chunks2Pack == null) {\n          chunks2Pack = new HashSet<Chunk<PsiPackage>>();\n          result.put(pack, chunks2Pack);\n        }\n        chunks2Pack.add(chunk);\n      }\n\n    }*/\n    return result;\n  }","id":86641,"modified_method":"public HashMap<PsiPackage, Set<List<PsiPackage>>> getCycles(Collection<PsiPackage> packages) {\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> result = new HashMap<PsiPackage, Set<List<PsiPackage>>>();\n    final List<Chunk<PsiPackage>> chunks = buildChunks();\n    for (Iterator<PsiPackage> iterator = packages.iterator(); iterator.hasNext();) {\n      PsiPackage psiPackage = iterator.next();\n      final List<Chunk<PsiPackage>> chunksByPackage = findChunksByPackage(psiPackage, chunks);\n      for (Iterator<Chunk<PsiPackage>> it = chunksByPackage.iterator(); it.hasNext();) {\n        Chunk<PsiPackage> chunk = it.next();\n        if (chunk.getNodes().size() == 1){\n          continue;\n        }\n        Set<List<PsiPackage>> paths2Pack = result.get(psiPackage);\n        if (paths2Pack == null) {\n          paths2Pack = new HashSet<List<PsiPackage>>();\n          result.put(psiPackage, paths2Pack);\n        }\n        paths2Pack.addAll(CyclicGraphUtil.getNodeCycles(myGraph, psiPackage));\n        /*final CyclicDependenciesUtil.GraphTraverser<PsiPackage> graphTraverser = new CyclicDependenciesUtil.GraphTraverser(psiPackage, chunk, 10, myGraph);\n        paths2Pack.addAll(graphTraverser.convert(graphTraverser.traverse()));*/\n      }\n    }\n    /*for (Iterator<Chunk<PsiPackage>> iterator = chunks.iterator(); iterator.hasNext();) {\n      Chunk<PsiPackage> chunk = iterator.next();\n      for (Iterator<PsiPackage> it = chunk.getNodes().iterator(); it.hasNext();) {\n        PsiPackage pack = it.next();\n        Set<Chunk<PsiPackage>> chunks2Pack = result.get(pack);\n        if (chunks2Pack == null) {\n          chunks2Pack = new HashSet<Chunk<PsiPackage>>();\n          result.put(pack, chunks2Pack);\n        }\n        chunks2Pack.add(chunk);\n      }\n\n    }*/\n    return result;\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> getCyclicDependencies() {\n    return myCyclicDependencies;\n  }","id":86642,"modified_method":"public HashMap<PsiPackage, Set<List<PsiPackage>>> getCyclicDependencies() {\n    return myCyclicDependencies;\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CyclicDependenciesBuilder(final Project project, final AnalysisScope scope, int perPackageCycleCount) {\n    myProject = project;\n    myScope = scope;\n    myForwardBuilder = new ForwardDependenciesBuilder(myProject, myScope){\n      public String getRootNodeNameInUsageView() {\n        return CyclicDependenciesBuilder.this.getRootNodeNameInUsageView();\n      }\n\n      public String getInitialUsagesPosition() {\n        return \"Select package to analyze from the left tree\";\n      }\n    };\n    myPerPackageCycleCount = perPackageCycleCount;\n  }","id":86643,"modified_method":"public CyclicDependenciesBuilder(final Project project, final AnalysisScope scope) {\n    myProject = project;\n    myScope = scope;\n    myForwardBuilder = new ForwardDependenciesBuilder(myProject, myScope){\n      public String getRootNodeNameInUsageView() {\n        return CyclicDependenciesBuilder.this.getRootNodeNameInUsageView();\n      }\n\n      public String getInitialUsagesPosition() {\n        return \"Select package to analyze from the left tree\";\n      }\n    };\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CyclicDependenciesHandler(Project project, AnalysisScope scope, int perPackageCycleCount) {\n    myProject = project;\n    myScope = scope;\n    myPerPackageCycleCount = perPackageCycleCount;\n  }","id":86644,"modified_method":"public CyclicDependenciesHandler(Project project, AnalysisScope scope) {\n    myProject = project;\n    myScope = scope;\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void analyze() {\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject, myScope, myPerPackageCycleCount);\n    if (ApplicationManager.getApplication().runProcessWithProgressSynchronously(new Runnable() {\n      public void run() {\n        builder.analyze();\n      }\n    }, \"Analyzing Dependencies\", true, myProject)) {\n      CyclicDependenciesPanel panel = new CyclicDependenciesPanel(myProject, builder);\n      Content content = PeerFactory.getInstance().getContentFactory().createContent(panel,\n                                                                                  \"Cyclic Dependencies of \" + builder.getScope().getDisplayName(),\n                                                                                  false);\n      panel.setContent(content);\n      DependencyValidationManager.getInstance(myProject).addContent(content);\n    }\n  }","id":86645,"modified_method":"public void analyze() {\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject, myScope);\n    if (ApplicationManager.getApplication().runProcessWithProgressSynchronously(new Runnable() {\n      public void run() {\n        builder.analyze();\n      }\n    }, \"Analyzing Dependencies\", true, myProject)) {\n      CyclicDependenciesPanel panel = new CyclicDependenciesPanel(myProject, builder);\n      Content content = PeerFactory.getInstance().getContentFactory().createContent(panel,\n                                                                                  \"Cyclic Dependencies of \" + builder.getScope().getDisplayName(),\n                                                                                  false);\n      panel.setContent(content);\n      DependencyValidationManager.getInstance(myProject).addContent(content);\n    }\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      DependencyValidationManager.getInstance(myProject).closeContent(myContent);\n      mySettings.copyToApplicationDependencySettings();\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          new CyclicDependenciesHandler(myProject, myBuilder.getScope(), myBuilder.getPerPackageCycleCount()).analyze();\n        }\n      });\n    }","id":86646,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      DependencyValidationManager.getInstance(myProject).closeContent(myContent);\n      mySettings.copyToApplicationDependencySettings();\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          new CyclicDependenciesHandler(myProject, myBuilder.getScope()).analyze();\n        }\n      });\n    }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateRightTreeModel() {\n    PackageDependenciesNode root = new RootNode();\n    final PackageNode packageNode = getSelectedPackage(myLeftTree);\n    if (packageNode != null) {\n      boolean group = mySettings.UI_GROUP_BY_SCOPE_TYPE;\n      mySettings.UI_GROUP_BY_SCOPE_TYPE = false;\n      final PsiPackage aPackage = (PsiPackage)packageNode.getPsiElement();\n      final Set<ArrayList<PsiPackage>> cyclesOfPackages = myDependencies.get(aPackage);\n      for (Iterator<ArrayList<PsiPackage>> iterator = cyclesOfPackages.iterator(); iterator.hasNext();) {\n        ArrayList<PsiPackage> packCycle = iterator.next();\n        PackageDependenciesNode[] nodes = new PackageDependenciesNode[packCycle.size()];\n        for (int i = 0; i < packCycle.size(); i++) {\n          final PsiPackage psiPackage = packCycle.get(i);\n          PsiPackage nextPackage = packCycle.get(i == packCycle.size() - 1 ? 0 : i + 1);\n          PsiPackage prevPackage = packCycle.get(i == 0 ? packCycle.size() - 1 : i - 1);\n          final Set<PsiFile> dependentFilesInPackage = myBuilder.getDependentFilesInPackage(prevPackage, psiPackage, nextPackage);\n\n          final PackageDependenciesNode pack = (PackageDependenciesNode)TreeModelBuilder.createTreeModel(myProject, false, dependentFilesInPackage, new TreeModelBuilder.Marker() {\n              public boolean isMarked(PsiFile file) {\n                return false;\n              }\n            }, mySettings).getRoot();\n          nodes[i] = hideEmptyMiddlePackages((PackageDependenciesNode)pack.getChildAt(0), new StringBuffer());\n        }\n\n        PackageDependenciesNode cycleNode = new CycleNode();\n        for (int i = 0; i < nodes.length; i++) {\n          nodes[i].setEquals(true);\n          cycleNode.add(nodes[i]);\n        }\n        root.add(cycleNode);\n      }\n      mySettings.UI_GROUP_BY_SCOPE_TYPE = group;\n    }\n    myRightTreeExpantionMonitor.freeze();\n    myRightTree.setModel(new TreeModelBuilder.TreeModel(root, -1, -1));\n    myRightTreeExpantionMonitor.restore();\n    expandFirstLevel(myRightTree);\n  }","id":86647,"modified_method":"private void updateRightTreeModel() {\n    PackageDependenciesNode root = new RootNode();\n    final PackageNode packageNode = getSelectedPackage(myLeftTree);\n    if (packageNode != null) {\n      boolean group = mySettings.UI_GROUP_BY_SCOPE_TYPE;\n      mySettings.UI_GROUP_BY_SCOPE_TYPE = false;\n      final PsiPackage aPackage = (PsiPackage)packageNode.getPsiElement();\n      final Set<List<PsiPackage>> cyclesOfPackages = myDependencies.get(aPackage);\n      for (Iterator<List<PsiPackage>> iterator = cyclesOfPackages.iterator(); iterator.hasNext();) {\n        List<PsiPackage> packCycle = iterator.next();\n        PackageDependenciesNode[] nodes = new PackageDependenciesNode[packCycle.size()];\n        for (int i = packCycle.size() - 1; i >=0; i--) {\n          final PsiPackage psiPackage = packCycle.get(i);\n          PsiPackage nextPackage = packCycle.get(i == 0 ? packCycle.size() - 1 : i - 1);\n          PsiPackage prevPackage = packCycle.get(i == packCycle.size() - 1 ? 0 : i + 1);\n          final Set<PsiFile> dependentFilesInPackage = myBuilder.getDependentFilesInPackage(prevPackage, psiPackage, nextPackage);\n\n          final PackageDependenciesNode pack = (PackageDependenciesNode)TreeModelBuilder.createTreeModel(myProject, false, dependentFilesInPackage, new TreeModelBuilder.Marker() {\n              public boolean isMarked(PsiFile file) {\n                return false;\n              }\n            }, mySettings).getRoot();\n          nodes[i] = hideEmptyMiddlePackages((PackageDependenciesNode)pack.getChildAt(0), new StringBuffer());\n        }\n\n        PackageDependenciesNode cycleNode = new CycleNode();\n        for (int i = 0; i < nodes.length; i++) {\n          nodes[i].setEquals(true);\n          cycleNode.insert(nodes[i], 0);\n        }\n        root.add(cycleNode);\n      }\n      mySettings.UI_GROUP_BY_SCOPE_TYPE = group;\n    }\n    myRightTreeExpantionMonitor.freeze();\n    myRightTree.setModel(new TreeModelBuilder.TreeModel(root, -1, -1));\n    myRightTreeExpantionMonitor.restore();\n    expandFirstLevel(myRightTree);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testT5() {\n    //com.b<->com.d\n    //com.b->com.a->com.c->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            10);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.b\", \"com.d\"}, {\"com.b\", \"com.a\", \"com.c\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.d\", \"com.b\"}, {\"com.d\", \"com.b\", \"com.a\", \"com.c\", \"com.b\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.c\", \"com.b\", \"com.a\"}, {\"com.c\", \"com.b\", \"com.d\", \"com.b\", \"com.a\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.a\", \"com.c\", \"com.b\"}, {\"com.a\", \"com.c\", \"com.b\", \"com.d\", \"com.b\"}});\n    checkResult(expected, cyclicDependencies, true);\n  }","id":86648,"modified_method":"public void testT5() {\n    //com.b<->com.d\n    //com.b->com.a->com.c->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.d\", \"com.b\"}, {\"com.c\", \"com.a\", \"com.b\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.b\", \"com.d\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.a\", \"com.b\", \"com.c\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.b\", \"com.c\", \"com.a\"}});\n    checkResult(expected, cyclicDependencies, true);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testT1() {\n    // com.a<->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            1);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.b\", \"com.a\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.a\", \"com.b\"}});\n    checkResult(expected, cyclicDependencies);\n  }","id":86649,"modified_method":"public void testT1() {\n    // com.a<->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.a\", \"com.b\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.b\", \"com.a\"}});\n    checkResult(expected, cyclicDependencies);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkResult(HashMap<String, String[][]> expected, HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cycles, boolean forceContains){\n    assertEquals(expected.size(), cycles.size());\n    for (Iterator<PsiPackage> iterator = cycles.keySet().iterator(); iterator.hasNext();) {\n      final PsiPackage psiPackage = iterator.next();\n      assertTrue(expected.containsKey(psiPackage.getQualifiedName()));\n      final String packs = psiPackage.getQualifiedName();\n      if (forceContains){\n        assertEquals(expected.get(packs).length, cycles.get(psiPackage).size());\n      }\n      for (Iterator<ArrayList<PsiPackage>> iC = cycles.get(psiPackage).iterator(); iC.hasNext();) {\n        final ArrayList<PsiPackage> cycle = iC.next();\n        final String[][] expectedCycles = expected.get(packs);\n        final String [] string = new String[cycle.size()];\n        int i = 0;\n        for (Iterator<PsiPackage> iCycle = cycle.iterator(); iCycle.hasNext();) {\n          final PsiPackage packageInCycle = iCycle.next();\n          string[i++] = packageInCycle.getQualifiedName();\n        }\n        assertTrue(findInMatrix(expectedCycles, string) > -1);\n      }\n    }\n  }","id":86650,"modified_method":"private void checkResult(HashMap<String, String[][]> expected, HashMap<PsiPackage, Set<List<PsiPackage>>> cycles, boolean forceContains){\n    assertEquals(expected.size(), cycles.size());\n    for (Iterator<PsiPackage> iterator = cycles.keySet().iterator(); iterator.hasNext();) {\n      final PsiPackage psiPackage = iterator.next();\n      assertTrue(expected.containsKey(psiPackage.getQualifiedName()));\n      final String packs = psiPackage.getQualifiedName();\n      if (forceContains){\n        assertEquals(expected.get(packs).length, cycles.get(psiPackage).size());\n      }\n      for (Iterator<List<PsiPackage>> iC = cycles.get(psiPackage).iterator(); iC.hasNext();) {\n        final List<PsiPackage> cycle = iC.next();\n        final String[][] expectedCycles = expected.get(packs);\n        final String [] string = new String[cycle.size()];\n        int i = 0;\n        for (Iterator<PsiPackage> iCycle = cycle.iterator(); iCycle.hasNext();) {\n          final PsiPackage packageInCycle = iCycle.next();\n          string[i++] = packageInCycle.getQualifiedName();\n        }\n        assertTrue(findInMatrix(expectedCycles, string) > -1);\n      }\n    }\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testT2() {\n    //com.b<->com.a\n    //com.c<->com.d\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            1);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.b\", \"com.a\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.d\", \"com.c\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.c\", \"com.d\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.a\", \"com.b\"}});\n    checkResult(expected, cyclicDependencies);\n  }","id":86651,"modified_method":"public void testT2() {\n    //com.b<->com.a\n    //com.c<->com.d\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.a\", \"com.b\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.c\", \"com.d\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.d\", \"com.c\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.b\", \"com.a\"}});\n    checkResult(expected, cyclicDependencies);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testT3() {\n    //com.b<->com.d\n    //com.b->com.a->com.c->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            1);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.b\", \"com.d\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.d\", \"com.b\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.c\", \"com.b\", \"com.a\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.a\", \"com.c\", \"com.b\"}});\n    checkResult(expected, cyclicDependencies, true);\n  }","id":86652,"modified_method":"public void testT3() {\n    //com.b<->com.d\n    //com.b->com.a->com.c->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.c\", \"com.a\", \"com.b\"}, {\"com.d\", \"com.b\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.b\", \"com.d\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.a\", \"com.b\", \"com.c\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.b\", \"com.c\", \"com.a\"}});\n    checkResult(expected, cyclicDependencies, true);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testPackageScope2() {\n    //com.b<->com.a  - find\n    //com.c<->com.d  - not in scope\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myPsiManager.findPackage(\"com.subscope1\"), AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            1);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.subscope1.b\", new String[][]{{\"com.subscope1.b\", \"com.subscope1.a\"}});\n    expected.put(\"com.subscope1.a\", new String[][]{{\"com.subscope1.a\", \"com.subscope1.b\"}});\n    checkResult(expected, cyclicDependencies);\n  }","id":86653,"modified_method":"public void testPackageScope2() {\n    //com.b<->com.a  - find\n    //com.c<->com.d  - not in scope\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myPsiManager.findPackage(\"com.subscope1\"), AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.subscope1.b\", new String[][]{{\"com.subscope1.a\", \"com.subscope1.b\"}});\n    expected.put(\"com.subscope1.a\", new String[][]{{\"com.subscope1.b\", \"com.subscope1.a\"}});\n    checkResult(expected, cyclicDependencies);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testT4() {\n    //com.a<->com.b\n    //com.a->com.c->com.d->com.a\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            1);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.b\", \"com.a\"}});\n    expected.put(\"com.d\", new String[][]{{\"com.d\", \"com.a\", \"com.c\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.c\", \"com.d\", \"com.a\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.a\", \"com.b\"}});\n    checkResult(expected, cyclicDependencies);\n  }","id":86654,"modified_method":"public void testT4() {\n    //com.a<->com.b\n    //com.a->com.c->com.d->com.a\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myProject, AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.a\", \"com.b\" }});\n    expected.put(\"com.d\", new String[][]{{\"com.c\", \"com.a\", \"com.d\"}});\n    expected.put(\"com.c\", new String[][]{{\"com.a\", \"com.d\", \"com.c\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.d\", \"com.c\",\"com.a\"}, {\"com.b\", \"com.a\"}});\n    checkResult(expected, cyclicDependencies, true);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkResult(HashMap<String, String[][]> expected, HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cycles) {\n    assertEquals(expected.size(), cycles.size());\n    Iterator<PsiPackage> it = cycles.keySet().iterator();\n    for (Iterator<String> iterator = expected.keySet().iterator(); iterator.hasNext();) {\n      final String packs = iterator.next();\n      final PsiPackage psiPackage = it.next();\n      assertEquals(packs, psiPackage.getQualifiedName());\n      assertEquals(expected.get(packs).length, cycles.get(psiPackage).size());\n      Iterator<ArrayList<PsiPackage>> iC = cycles.get(psiPackage).iterator();\n      for (int i = 0; i < expected.get(packs).length; i++) {\n        final String[] expectedCycle = expected.get(packs)[i];\n        final ArrayList<PsiPackage> cycle = iC.next();\n        assertEquals(expectedCycle.length, cycle.size());\n        Iterator<PsiPackage> iCycle = cycle.iterator();\n        for (int j = 0; j < expectedCycle.length; j++) {\n          final String expectedInCycle = expectedCycle[j];\n          final PsiPackage packageInCycle = iCycle.next();\n          assertEquals(expectedInCycle, packageInCycle.getQualifiedName());\n        }\n      }\n    }\n  }","id":86655,"modified_method":"private void checkResult(HashMap<String, String[][]> expected, HashMap<PsiPackage, Set<List<PsiPackage>>> cycles) {\n    assertEquals(expected.size(), cycles.size());\n    Iterator<PsiPackage> it = cycles.keySet().iterator();\n    for (Iterator<String> iterator = expected.keySet().iterator(); iterator.hasNext();) {\n      final String packs = iterator.next();\n      final PsiPackage psiPackage = it.next();\n      assertEquals(packs, psiPackage.getQualifiedName());\n      assertEquals(expected.get(packs).length, cycles.get(psiPackage).size());\n      Iterator<List<PsiPackage>> iC = cycles.get(psiPackage).iterator();\n      for (int i = 0; i < expected.get(packs).length; i++) {\n        final String[] expectedCycle = expected.get(packs)[i];\n        final List<PsiPackage> cycle = iC.next();\n        assertEquals(expectedCycle.length, cycle.size());\n        Iterator<PsiPackage> iCycle = cycle.iterator();\n        for (int j = 0; j < expectedCycle.length; j++) {\n          final String expectedInCycle = expectedCycle[j];\n          final PsiPackage packageInCycle = iCycle.next();\n          assertEquals(expectedInCycle, packageInCycle.getQualifiedName());\n        }\n      }\n    }\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testPackageScope1(){\n    // com.a<->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myPsiManager.findPackage(\"com\"), AnalysisScope.SOURCE_JAVA_FILES),\n                                                                            1);\n    builder.analyze();\n    final HashMap<PsiPackage, Set<ArrayList<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.b\", \"com.a\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.a\", \"com.b\"}});\n    checkResult(expected, cyclicDependencies);\n  }","id":86656,"modified_method":"public void testPackageScope1(){\n    // com.a<->com.b\n    final CyclicDependenciesBuilder builder = new CyclicDependenciesBuilder(myProject,\n                                                                            new AnalysisScope(myPsiManager.findPackage(\"com\"), AnalysisScope.SOURCE_JAVA_FILES));\n    builder.analyze();\n    final HashMap<PsiPackage, Set<List<PsiPackage>>> cyclicDependencies = builder.getCyclicDependencies();\n    HashMap<String, String[][]> expected = new HashMap<String, String[][]>();\n    expected.put(\"com.b\", new String[][]{{\"com.a\", \"com.b\"}});\n    expected.put(\"com.a\", new String[][]{{\"com.b\", \"com.a\"}});\n    checkResult(expected, cyclicDependencies);\n  }","commit_id":"dd739cc1c26760d6eb8cdf7932918be6eb56d214","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(getFeatureUsedKey());\n\n    Pair<PsiElement, PsiElement[]> sourceAndTarget = getSourceAndTargetElements(editor, file);\n    show(project, editor, file, sourceAndTarget.first, sourceAndTarget.second);\n  }","id":86657,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(getFeatureUsedKey());\n\n    Pair<PsiElement, PsiElement[]> sourceAndTarget = getSourceAndTargetElements(editor, file);\n    if (sourceAndTarget.first != null) {\n      show(project, editor, file, sourceAndTarget.first, sourceAndTarget.second);\n    }\n  }","commit_id":"31f2a05af2164a74f90911cd2b3149e2d0680b67","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void perform(XValueNodeImpl node, @NotNull String nodeName, AnActionEvent e) {\n    XReferrersProvider referrersProvider = node.getValueContainer().getReferrersProvider();\n    if (referrersProvider != null) {\n      XDebuggerTree tree = node.getTree();\n      XDebugSession session = e.getData(XDebugSession.DATA_KEY);\n      XInspectDialog dialog = new XInspectDialog(tree.getProject(),\n                                                 tree.getEditorsProvider(),\n                                                 tree.getSourcePosition(),\n                                                 nodeName,\n                                                 referrersProvider.getReferringObjectsValue(),\n                                                 tree.getValueMarkers(), session, false);\n      dialog.setTitle(XDebuggerBundle.message(\"showReferring.dialog.title\", nodeName));\n      dialog.show();\n    }\n  }","id":86658,"modified_method":"@Override\n  protected void perform(XValueNodeImpl node, @NotNull String nodeName, AnActionEvent e) {\n    XReferrersProvider referrersProvider = node.getValueContainer().getReferrersProvider();\n    if (referrersProvider != null) {\n      XDebuggerTree tree = node.getTree();\n      XDebugSession session = XDebuggerManager.getInstance(tree.getProject()).getCurrentSession();\n      if (session != null) {\n        XInspectDialog dialog = new XInspectDialog(tree.getProject(),\n                                                   tree.getEditorsProvider(),\n                                                   tree.getSourcePosition(),\n                                                   nodeName,\n                                                   referrersProvider.getReferringObjectsValue(),\n                                                   tree.getValueMarkers(), session, false);\n        dialog.setTitle(XDebuggerBundle.message(\"showReferring.dialog.title\", nodeName));\n        dialog.show();\n      }\n    }\n  }","commit_id":"d015f6995e4425b4a60a1d8f3b4170868cd897d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void perform(XValueNodeImpl node, @NotNull final String nodeName, AnActionEvent e) {\n    XDebugSession session = e.getData(XDebugSession.DATA_KEY);\n    XDebuggerTree tree = node.getTree();\n    XValue value = node.getValueContainer();\n    XInspectDialog dialog = new XInspectDialog(tree.getProject(), tree.getEditorsProvider(), tree.getSourcePosition(), nodeName, value,\n                                               tree.getValueMarkers(), session, true);\n    dialog.show();\n  }","id":86659,"modified_method":"@Override\n  protected void perform(XValueNodeImpl node, @NotNull final String nodeName, AnActionEvent e) {\n    XDebuggerTree tree = node.getTree();\n    XValue value = node.getValueContainer();\n    XDebugSession session = XDebuggerManager.getInstance(tree.getProject()).getCurrentSession();\n    if (session != null) {\n      XInspectDialog dialog = new XInspectDialog(tree.getProject(), tree.getEditorsProvider(), tree.getSourcePosition(), nodeName, value,\n                                                 tree.getValueMarkers(), session, true);\n      dialog.show();\n    }\n  }","commit_id":"d015f6995e4425b4a60a1d8f3b4170868cd897d9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private BoundingXYVisitor getBoundingBox() {\n        BoundingXYVisitor v = \"problem\".equals(mode) ? new ValidatorBoundingXYVisitor() : new BoundingXYVisitor();\n\n        switch (mode) {\n        case \"problem\":\n            TestError error = Main.map.validatorDialog.getSelectedError();\n            if (error == null)\n                return null;\n            ((ValidatorBoundingXYVisitor) v).visit(error);\n            if (v.getBounds() == null)\n                return null;\n            v.enlargeBoundingBox(Main.pref.getDouble(\"validator.zoom-enlarge-bbox\", 0.0002));\n            break;\n        case \"data\":\n            for (Layer l : Main.map.mapView.getAllLayers()) {\n                l.visitBoundingBox(v);\n            }\n            break;\n        case \"layer\":\n            // try to zoom to the first selected layer\n            Layer l = getFirstSelectedLayer();\n            if (l == null)\n                return null;\n            l.visitBoundingBox(v);\n            break;\n        case \"selection\":\n        case \"conflict\":\n            Collection<OsmPrimitive> sel = new HashSet<>();\n            if (\"selection\".equals(mode)) {\n                sel = getCurrentDataSet().getSelected();\n            } else {\n                Conflict<? extends OsmPrimitive> c = Main.map.conflictDialog.getSelectedConflict();\n                if (c != null) {\n                    sel.add(c.getMy());\n                } else if (Main.map.conflictDialog.getConflicts() != null) {\n                    sel = Main.map.conflictDialog.getConflicts().getMyConflictParties();\n                }\n            }\n            if (sel.isEmpty()) {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        \"selection\".equals(mode) ? tr(\"Nothing selected to zoom to.\") : tr(\"No conflicts to zoom to\"),\n                        tr(\"Information\"),\n                        JOptionPane.INFORMATION_MESSAGE);\n                return null;\n            }\n            for (OsmPrimitive osm : sel) {\n                osm.accept(v);\n            }\n\n            // Increase the bounding box by up to 100% to give more context.\n            v.enlargeBoundingBoxLogarithmically(100);\n            // Make the bounding box at least 100 meter wide to\n            // ensure reasonable zoom level when zooming onto single nodes.\n            v.enlargeToMinSize(Main.pref.getDouble(\"zoom_to_selection_min_size_in_meter\", 100));\n            break;\n        case \"download\":\n\n            if (lastZoomTime > 0 && System.currentTimeMillis() - lastZoomTime > Main.pref.getLong(\"zoom.bounds.reset.time\", 10*1000)) {\n                lastZoomTime = -1;\n            }\n            final DataSet dataset = getCurrentDataSet();\n            if (dataset != null) {\n                List<DataSource> dataSources = new ArrayList<>(dataset.getDataSources());\n                int s = dataSources.size();\n                if (s > 0) {\n                    if (lastZoomTime == -1 || lastZoomArea == -1 || lastZoomArea > s) {\n                        lastZoomArea = s-1;\n                        v.visit(dataSources.get(lastZoomArea).bounds);\n                    } else if (lastZoomArea > 0) {\n                        lastZoomArea -= 1;\n                        v.visit(dataSources.get(lastZoomArea).bounds);\n                    } else {\n                        lastZoomArea = -1;\n                        v.visit(new Bounds(Main.main.getCurrentDataSet().getDataSourceArea().getBounds2D()));\n                    }\n                    lastZoomTime = System.currentTimeMillis();\n                } else {\n                    lastZoomTime = -1;\n                    lastZoomArea = -1;\n                }\n            }\n            break;\n        }\n        return v;\n    }","id":86660,"modified_method":"private BoundingXYVisitor getBoundingBox() {\n        BoundingXYVisitor v = \"problem\".equals(mode) ? new ValidatorBoundingXYVisitor() : new BoundingXYVisitor();\n\n        switch (mode) {\n        case \"problem\":\n            TestError error = Main.map.validatorDialog.getSelectedError();\n            if (error == null)\n                return null;\n            ((ValidatorBoundingXYVisitor) v).visit(error);\n            if (v.getBounds() == null)\n                return null;\n            v.enlargeBoundingBox(Main.pref.getDouble(\"validator.zoom-enlarge-bbox\", 0.0002));\n            break;\n        case \"data\":\n            for (Layer l : Main.map.mapView.getAllLayers()) {\n                l.visitBoundingBox(v);\n            }\n            break;\n        case \"layer\":\n            // try to zoom to the first selected layer\n            Layer l = getFirstSelectedLayer();\n            if (l == null)\n                return null;\n            l.visitBoundingBox(v);\n            break;\n        case \"selection\":\n        case \"conflict\":\n            Collection<OsmPrimitive> sel = new HashSet<>();\n            if (\"selection\".equals(mode)) {\n                sel = getCurrentDataSet().getSelected();\n            } else {\n                Conflict<? extends OsmPrimitive> c = Main.map.conflictDialog.getSelectedConflict();\n                if (c != null) {\n                    sel.add(c.getMy());\n                } else if (Main.map.conflictDialog.getConflicts() != null) {\n                    sel = Main.map.conflictDialog.getConflicts().getMyConflictParties();\n                }\n            }\n            if (sel.isEmpty()) {\n                JOptionPane.showMessageDialog(\n                        Main.parent,\n                        \"selection\".equals(mode) ? tr(\"Nothing selected to zoom to.\") : tr(\"No conflicts to zoom to\"),\n                        tr(\"Information\"),\n                        JOptionPane.INFORMATION_MESSAGE);\n                return null;\n            }\n            for (OsmPrimitive osm : sel) {\n                osm.accept(v);\n            }\n\n            // Increase the bounding box by up to 100% to give more context.\n            v.enlargeBoundingBoxLogarithmically(100);\n            // Make the bounding box at least 100 meter wide to\n            // ensure reasonable zoom level when zooming onto single nodes.\n            v.enlargeToMinSize(Main.pref.getDouble(\"zoom_to_selection_min_size_in_meter\", 100));\n            break;\n        case \"download\":\n\n            if (lastZoomTime > 0 && System.currentTimeMillis() - lastZoomTime > Main.pref.getLong(\"zoom.bounds.reset.time\", 10*1000)) {\n                lastZoomTime = -1;\n            }\n            final DataSet dataset = getCurrentDataSet();\n            if (dataset != null) {\n                List<DataSource> dataSources = new ArrayList<>(dataset.getDataSources());\n                int s = dataSources.size();\n                if (s > 0) {\n                    if (lastZoomTime == -1 || lastZoomArea == -1 || lastZoomArea > s) {\n                        lastZoomArea = s-1;\n                        v.visit(dataSources.get(lastZoomArea).bounds);\n                    } else if (lastZoomArea > 0) {\n                        lastZoomArea -= 1;\n                        v.visit(dataSources.get(lastZoomArea).bounds);\n                    } else {\n                        lastZoomArea = -1;\n                        Area sourceArea = Main.main.getCurrentDataSet().getDataSourceArea();\n                        if (sourceArea != null) {\n                            v.visit(new Bounds(sourceArea.getBounds2D()));\n                        }\n                    }\n                    lastZoomTime = System.currentTimeMillis();\n                } else {\n                    lastZoomTime = -1;\n                    lastZoomArea = -1;\n                }\n            }\n            break;\n        }\n        return v;\n    }","commit_id":"d86f03cc543dd95847c17004310c0b9c3c435964","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    protected void validateRequest() throws RequestHandlerBadRequestException {\n        // Process mandatory arguments\n        minlat = 0;\n        maxlat = 0;\n        minlon = 0;\n        maxlon = 0;\n        try {\n            minlat = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"bottom\") : \"\"));\n            maxlat = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"top\") : \"\"));\n            minlon = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"left\") : \"\"));\n            maxlon = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"right\") : \"\"));\n        } catch (NumberFormatException e) {\n            throw new RequestHandlerBadRequestException(\"NumberFormatException (\"+e.getMessage()+')', e);\n        }\n\n        // Current API 0.6 check: \"The latitudes must be between -90 and 90\"\n        if (!LatLon.isValidLat(minlat) || !LatLon.isValidLat(maxlat)) {\n            throw new RequestHandlerBadRequestException(tr(\"The latitudes must be between {0} and {1}\", -90d, 90d));\n        }\n        // Current API 0.6 check: \"longitudes between -180 and 180\"\n        if (!LatLon.isValidLon(minlon) || !LatLon.isValidLon(maxlon)) {\n            throw new RequestHandlerBadRequestException(tr(\"The longitudes must be between {0} and {1}\", -180d, 180d));\n        }\n        // Current API 0.6 check: \"the minima must be less than the maxima\"\n        if (minlat > maxlat || minlon > maxlon) {\n            throw new RequestHandlerBadRequestException(tr(\"The minima must be less than the maxima\"));\n        }\n\n        // Process optional argument 'select'\n        if (args.containsKey(\"select\")) {\n            toSelect.clear();\n            for (String item : args.get(\"select\").split(\",\")) {\n                try {\n                    toSelect.add(SimplePrimitiveId.fromString(item));\n                } catch (IllegalArgumentException ex) {\n                    Main.warn(\"RemoteControl: invalid selection '\" + item + \"' ignored\");\n                }\n            }\n        }\n    }","id":86661,"modified_method":"@Override\n    protected void validateRequest() throws RequestHandlerBadRequestException {\n        // Process mandatory arguments\n        minlat = 0;\n        maxlat = 0;\n        minlon = 0;\n        maxlon = 0;\n        try {\n            minlat = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"bottom\") : \"\"));\n            maxlat = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"top\") : \"\"));\n            minlon = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"left\") : \"\"));\n            maxlon = LatLon.roundToOsmPrecision(Double.parseDouble(args != null ? args.get(\"right\") : \"\"));\n        } catch (NumberFormatException e) {\n            throw new RequestHandlerBadRequestException(\"NumberFormatException (\"+e.getMessage()+')', e);\n        }\n\n        // Current API 0.6 check: \"The latitudes must be between -90 and 90\"\n        if (!LatLon.isValidLat(minlat) || !LatLon.isValidLat(maxlat)) {\n            throw new RequestHandlerBadRequestException(tr(\"The latitudes must be between {0} and {1}\", -90d, 90d));\n        }\n        // Current API 0.6 check: \"longitudes between -180 and 180\"\n        if (!LatLon.isValidLon(minlon) || !LatLon.isValidLon(maxlon)) {\n            throw new RequestHandlerBadRequestException(tr(\"The longitudes must be between {0} and {1}\", -180d, 180d));\n        }\n        // Current API 0.6 check: \"the minima must be less than the maxima\"\n        if (minlat > maxlat || minlon > maxlon) {\n            throw new RequestHandlerBadRequestException(tr(\"The minima must be less than the maxima\"));\n        }\n\n        // Process optional argument 'select'\n        if (args != null && args.containsKey(\"select\")) {\n            toSelect.clear();\n            for (String item : args.get(\"select\").split(\",\")) {\n                try {\n                    toSelect.add(SimplePrimitiveId.fromString(item));\n                } catch (IllegalArgumentException ex) {\n                    Main.warn(\"RemoteControl: invalid selection '\" + item + \"' ignored\");\n                }\n            }\n        }\n    }","commit_id":"d86f03cc543dd95847c17004310c0b9c3c435964","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void enableActions(boolean enabled) {\n            for (Object key : actionMap.allKeys()) {\n                Action action = actionMap.get(key);\n                if (action != null) {\n                    action.setEnabled(enabled);\n                }\n            }\n        }","id":86662,"modified_method":"private void enableActions(boolean enabled) {\n            Object[] allKeys = actionMap.allKeys();\n            if (allKeys != null) {\n                for (Object key : allKeys) {\n                    Action action = actionMap.get(key);\n                    if (action != null) {\n                        action.setEnabled(enabled);\n                    }\n                }\n            }\n        }","commit_id":"d86f03cc543dd95847c17004310c0b9c3c435964","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Splits the way {@code way} into chunks of {@code wayChunks} and replies\n     * the result of this process in an instance of {@link SplitWayResult}.\n     * The {@link org.openstreetmap.josm.actions.SplitWayAction.Strategy} is used to determine which\n     * way chunk should reuse the old id and its history.\n     *\n     * Note that changes are not applied to the data yet. You have to\n     * submit the command in {@link SplitWayResult#getCommand()} first,\n     * i.e. {@code Main.main.undoredo.add(result.getCommand())}.\n     *\n     * @param layer the layer which the way belongs to. Must not be null.\n     * @param way the way to split. Must not be null.\n     * @param wayChunks the list of way chunks into the way is split. Must not be null.\n     * @param selection The list of currently selected primitives\n     * @param splitStrategy The strategy used to determine which way chunk should reuse the old id and its history\n     * @return the result from the split operation\n     * @since 8954\n     */\n    public static SplitWayResult splitWay(OsmDataLayer layer, Way way, List<List<Node>> wayChunks,\n            Collection<? extends OsmPrimitive> selection, Strategy splitStrategy) {\n        // build a list of commands, and also a new selection list\n        final List<OsmPrimitive> newSelection = new ArrayList<>(selection.size() + wayChunks.size());\n        newSelection.addAll(selection);\n\n        // Create all potential new ways\n        final List<Way> newWays = createNewWaysFromChunks(way, wayChunks);\n\n        // Determine which part reuses the existing way\n        final Way wayToKeep = splitStrategy.determineWayToKeep(newWays);\n\n        return doSplitWay(layer, way, wayToKeep, newWays, newSelection);\n    }","id":86663,"modified_method":"/**\n     * Splits the way {@code way} into chunks of {@code wayChunks} and replies\n     * the result of this process in an instance of {@link SplitWayResult}.\n     * The {@link org.openstreetmap.josm.actions.SplitWayAction.Strategy} is used to determine which\n     * way chunk should reuse the old id and its history.\n     *\n     * Note that changes are not applied to the data yet. You have to\n     * submit the command in {@link SplitWayResult#getCommand()} first,\n     * i.e. {@code Main.main.undoredo.add(result.getCommand())}.\n     *\n     * @param layer the layer which the way belongs to. Must not be null.\n     * @param way the way to split. Must not be null.\n     * @param wayChunks the list of way chunks into the way is split. Must not be null.\n     * @param selection The list of currently selected primitives\n     * @param splitStrategy The strategy used to determine which way chunk should reuse the old id and its history\n     * @return the result from the split operation\n     * @since 8954\n     */\n    public static SplitWayResult splitWay(OsmDataLayer layer, Way way, List<List<Node>> wayChunks,\n            Collection<? extends OsmPrimitive> selection, Strategy splitStrategy) {\n        // build a list of commands, and also a new selection list\n        final List<OsmPrimitive> newSelection = new ArrayList<>(selection.size() + wayChunks.size());\n        newSelection.addAll(selection);\n\n        // Create all potential new ways\n        final List<Way> newWays = createNewWaysFromChunks(way, wayChunks);\n\n        // Determine which part reuses the existing way\n        final Way wayToKeep = splitStrategy.determineWayToKeep(newWays);\n\n        return wayToKeep != null ? doSplitWay(layer, way, wayToKeep, newWays, newSelection) : null;\n    }","commit_id":"d86f03cc543dd95847c17004310c0b9c3c435964","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Called when the action is executed.\n     *\n     * This method performs an expensive check whether the selection clearly defines one\n     * of the split actions outlined above, and if yes, calls the splitWay method.\n     */\n    @Override\n    public void actionPerformed(ActionEvent e) {\n\n        if (SegmentToKeepSelectionDialog.DISPLAY_COUNT.get() > 0) {\n            new Notification(tr(\"Cannot split since another split operation is already in progress\"))\n                    .setIcon(JOptionPane.WARNING_MESSAGE).show();\n            return;\n        }\n\n        Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n\n        List<Node> selectedNodes = OsmPrimitive.getFilteredList(selection, Node.class);\n        List<Way> selectedWays = OsmPrimitive.getFilteredList(selection, Way.class);\n        List<Way> applicableWays = getApplicableWays(selectedWays, selectedNodes);\n\n        if (applicableWays == null) {\n            new Notification(\n                    tr(\"The current selection cannot be used for splitting - no node is selected.\"))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        } else if (applicableWays.isEmpty()) {\n            new Notification(\n                    tr(\"The selected nodes do not share the same way.\"))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        }\n\n        // If several ways have been found, remove ways that doesn't have selected\n        // node in the middle\n        if (applicableWays.size() > 1) {\n            for (Iterator<Way> it = applicableWays.iterator(); it.hasNext();) {\n                Way w = it.next();\n                for (Node n : selectedNodes) {\n                    if (!w.isInnerNode(n)) {\n                        it.remove();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (applicableWays.isEmpty()) {\n            new Notification(\n                    trn(\"The selected node is not in the middle of any way.\",\n                        \"The selected nodes are not in the middle of any way.\",\n                        selectedNodes.size()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        } else if (applicableWays.size() > 1) {\n            new Notification(\n                    trn(\"There is more than one way using the node you selected. Please select the way also.\",\n                        \"There is more than one way using the nodes you selected. Please select the way also.\",\n                        selectedNodes.size()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        }\n\n        // Finally, applicableWays contains only one perfect way\n        final Way selectedWay = applicableWays.get(0);\n        final List<List<Node>> wayChunks = buildSplitChunks(selectedWay, selectedNodes);\n        if (wayChunks != null) {\n            List<Relation> selectedRelations =\n                    OsmPrimitive.getFilteredList(selection, Relation.class);\n            final List<OsmPrimitive> sel = new ArrayList<>(selectedWays.size() + selectedRelations.size());\n            sel.addAll(selectedWays);\n            sel.addAll(selectedRelations);\n\n            final List<Way> newWays = createNewWaysFromChunks(selectedWay, wayChunks);\n            final Way wayToKeep = Strategy.keepLongestChunk().determineWayToKeep(newWays);\n\n            if (ExpertToggleAction.isExpert() && !selectedWay.isNew()) {\n                final ExtendedDialog dialog = new SegmentToKeepSelectionDialog(selectedWay, newWays, wayToKeep, sel);\n                dialog.toggleEnable(\"way.split.segment-selection-dialog\");\n                if (!dialog.toggleCheckState()) {\n                    dialog.setModal(false);\n                    dialog.showDialog();\n                    return; // splitting is performed in SegmentToKeepSelectionDialog.buttonAction()\n                }\n            }\n            final SplitWayResult result = doSplitWay(getEditLayer(), selectedWay, wayToKeep, newWays, sel);\n            Main.main.undoRedo.add(result.getCommand());\n            getCurrentDataSet().setSelected(result.getNewSelection());\n        }\n    }","id":86664,"modified_method":"/**\n     * Called when the action is executed.\n     *\n     * This method performs an expensive check whether the selection clearly defines one\n     * of the split actions outlined above, and if yes, calls the splitWay method.\n     */\n    @Override\n    public void actionPerformed(ActionEvent e) {\n\n        if (SegmentToKeepSelectionDialog.DISPLAY_COUNT.get() > 0) {\n            new Notification(tr(\"Cannot split since another split operation is already in progress\"))\n                    .setIcon(JOptionPane.WARNING_MESSAGE).show();\n            return;\n        }\n\n        Collection<OsmPrimitive> selection = getCurrentDataSet().getSelected();\n\n        List<Node> selectedNodes = OsmPrimitive.getFilteredList(selection, Node.class);\n        List<Way> selectedWays = OsmPrimitive.getFilteredList(selection, Way.class);\n        List<Way> applicableWays = getApplicableWays(selectedWays, selectedNodes);\n\n        if (applicableWays == null) {\n            new Notification(\n                    tr(\"The current selection cannot be used for splitting - no node is selected.\"))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        } else if (applicableWays.isEmpty()) {\n            new Notification(\n                    tr(\"The selected nodes do not share the same way.\"))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        }\n\n        // If several ways have been found, remove ways that doesn't have selected\n        // node in the middle\n        if (applicableWays.size() > 1) {\n            for (Iterator<Way> it = applicableWays.iterator(); it.hasNext();) {\n                Way w = it.next();\n                for (Node n : selectedNodes) {\n                    if (!w.isInnerNode(n)) {\n                        it.remove();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (applicableWays.isEmpty()) {\n            new Notification(\n                    trn(\"The selected node is not in the middle of any way.\",\n                        \"The selected nodes are not in the middle of any way.\",\n                        selectedNodes.size()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        } else if (applicableWays.size() > 1) {\n            new Notification(\n                    trn(\"There is more than one way using the node you selected. Please select the way also.\",\n                        \"There is more than one way using the nodes you selected. Please select the way also.\",\n                        selectedNodes.size()))\n                    .setIcon(JOptionPane.WARNING_MESSAGE)\n                    .show();\n            return;\n        }\n\n        // Finally, applicableWays contains only one perfect way\n        final Way selectedWay = applicableWays.get(0);\n        final List<List<Node>> wayChunks = buildSplitChunks(selectedWay, selectedNodes);\n        if (wayChunks != null) {\n            List<Relation> selectedRelations =\n                    OsmPrimitive.getFilteredList(selection, Relation.class);\n            final List<OsmPrimitive> sel = new ArrayList<>(selectedWays.size() + selectedRelations.size());\n            sel.addAll(selectedWays);\n            sel.addAll(selectedRelations);\n\n            final List<Way> newWays = createNewWaysFromChunks(selectedWay, wayChunks);\n            final Way wayToKeep = Strategy.keepLongestChunk().determineWayToKeep(newWays);\n\n            if (ExpertToggleAction.isExpert() && !selectedWay.isNew()) {\n                final ExtendedDialog dialog = new SegmentToKeepSelectionDialog(selectedWay, newWays, wayToKeep, sel);\n                dialog.toggleEnable(\"way.split.segment-selection-dialog\");\n                if (!dialog.toggleCheckState()) {\n                    dialog.setModal(false);\n                    dialog.showDialog();\n                    return; // splitting is performed in SegmentToKeepSelectionDialog.buttonAction()\n                }\n            }\n            if (wayToKeep != null) {\n                final SplitWayResult result = doSplitWay(getEditLayer(), selectedWay, wayToKeep, newWays, sel);\n                Main.main.undoRedo.add(result.getCommand());\n                getCurrentDataSet().setSelected(result.getNewSelection());\n            }\n        }\n    }","commit_id":"d86f03cc543dd95847c17004310c0b9c3c435964","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n        Object s = e.getSource();\n        if (menu != null && s instanceof Component) {\n            JPopupMenu pm = new JPopupMenu(getName());\n            for (Component c : menu.getMenuComponents()) {\n                pm.add(copyMenuComponent(c));\n            }\n            Point p = MouseInfo.getPointerInfo().getLocation();\n            pm.show(Main.parent, p.x-Main.parent.getX(), p.y-Main.parent.getY());\n        }\n    }","id":86665,"modified_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n        Object s = e.getSource();\n        if (menu != null && s instanceof Component) {\n            JPopupMenu pm = new JPopupMenu(getName());\n            for (Component c : menu.getMenuComponents()) {\n                pm.add(copyMenuComponent(c));\n            }\n            PointerInfo pointerInfo = MouseInfo.getPointerInfo();\n            if (pointerInfo != null) {\n                Point p = pointerInfo.getLocation();\n                pm.show(Main.parent, p.x-Main.parent.getX(), p.y-Main.parent.getY());\n            }\n        }\n    }","commit_id":"d86f03cc543dd95847c17004310c0b9c3c435964","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void update(AnActionEvent e) {\n      ChangeList[] lists = (ChangeList[])e.getDataContext().getData(DataConstants.CHANGE_LISTS);\n      e.getPresentation().setEnabled(lists != null && lists.length == 1 && lists[0].getChanges().size() > 0);\n    }","id":86666,"modified_method":"public void update(AnActionEvent e) {\n      Change[] changes = (Change[])e.getDataContext().getData(DataConstants.CHANGES);\n      e.getPresentation().setEnabled(getChangeListIfOnlyOne(changes) != null);\n    }","commit_id":"3134c4f44075ecb05d60d2b3e26fa1b8da95201c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n      ChangeList[] lists = (ChangeList[])e.getDataContext().getData(DataConstants.CHANGE_LISTS);\n      new CommitChangeListDialog(myProject, lists[0], new ArrayList<Change>(lists[0].getChanges())).show();\n    }","id":86667,"modified_method":"public void actionPerformed(AnActionEvent e) {\n      Change[] changes = (Change[])e.getDataContext().getData(DataConstants.CHANGES);\n      final ChangeList list = getChangeListIfOnlyOne(changes);\n      if (list == null) return;\n      new CommitChangeListDialog(myProject, list, Arrays.asList(changes)).show();\n    }","commit_id":"3134c4f44075ecb05d60d2b3e26fa1b8da95201c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void showValuePopup(@NotNull XFullValueEvaluator text, @NotNull MouseEvent event, @NotNull Project project) {\n    EditorTextField textArea = new TextViewer(\"Evaluating...\", project);\n    textArea.setBackground(HintUtil.INFORMATION_COLOR);\n\n    final FullValueEvaluationCallbackImpl callback = new FullValueEvaluationCallbackImpl(textArea);\n    text.startEvaluation(callback);\n\n    Dimension size = DimensionService.getInstance().getSize(FULL_VALUE_POPUP_DIMENSION_KEY, project);\n    if (size == null) {\n      Dimension frameSize = WindowManager.getInstance().getFrame(project).getSize();\n      size = new Dimension(frameSize.width / 2, frameSize.height / 2);\n    }\n\n    textArea.setPreferredSize(size);\n\n    JBPopupFactory.getInstance().createComponentPopupBuilder(textArea, null)\n      .setResizable(true)\n      .setMovable(true)\n      .setDimensionServiceKey(project, FULL_VALUE_POPUP_DIMENSION_KEY, false)\n      .setRequestFocus(false)\n      .setCancelCallback(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          callback.setObsolete();\n          return true;\n        }\n      })\n      .createPopup().show(new RelativePoint(event.getComponent(), new Point(event.getX() - size.width, event.getY() - size.height)));\n  }","id":86668,"modified_method":"public static void showValuePopup(@NotNull XFullValueEvaluator evaluator, @NotNull MouseEvent event, @NotNull Project project, @Nullable Editor editor) {\n    EditorTextField textArea = new TextViewer(\"Evaluating...\", project);\n    textArea.setBackground(HintUtil.INFORMATION_COLOR);\n\n    final FullValueEvaluationCallbackImpl callback = new FullValueEvaluationCallbackImpl(textArea);\n    evaluator.startEvaluation(callback);\n\n    Dimension size = DimensionService.getInstance().getSize(FULL_VALUE_POPUP_DIMENSION_KEY, project);\n    if (size == null) {\n      Dimension frameSize = WindowManager.getInstance().getFrame(project).getSize();\n      size = new Dimension(frameSize.width / 2, frameSize.height / 2);\n    }\n\n    textArea.setPreferredSize(size);\n\n    JBPopup popup = JBPopupFactory.getInstance().createComponentPopupBuilder(textArea, null)\n      .setResizable(true)\n      .setMovable(true)\n      .setDimensionServiceKey(project, FULL_VALUE_POPUP_DIMENSION_KEY, false)\n      .setRequestFocus(false)\n      .setCancelCallback(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          callback.setObsolete();\n          return true;\n        }\n      }).createPopup();\n    if (editor == null) {\n      popup.show(new RelativePoint(event.getComponent(), new Point(event.getX() - size.width, event.getY() - size.height)));\n    }\n    else {\n      popup.showInBestPositionFor(editor);\n    }\n  }","commit_id":"0441a534abf3512856aa6529fba5b581840eed92","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void evaluateAndShowHint() {\n    myEvaluator.evaluate(myExpression, new XEvaluationCallbackBase() {\n      @Override\n      public void evaluated(@NotNull final XValue result) {\n        result.computePresentation(new XValueNodePresentationConfigurator.ConfigurableXValueNodeImpl() {\n          private XFullValueEvaluator myFullValueEvaluator;\n\n          @Override\n          public void applyPresentation(@Nullable Icon icon,\n                                        @NotNull XValuePresentation valuePresenter,\n                                        boolean hasChildren) {\n            if (isHintHidden()) {\n              return;\n            }\n\n            SimpleColoredText text = new SimpleColoredText();\n            text.append(myExpression, XDebuggerUIConstants.VALUE_NAME_ATTRIBUTES);\n            XValueNodeImpl.buildText(valuePresenter, text);\n\n            if (!hasChildren) {\n              SimpleColoredComponent component = HintUtil.createInformationComponent();\n              text.appendToComponent(component);\n              if (myFullValueEvaluator != null) {\n                component.append(myFullValueEvaluator.getLinkText(), XDebuggerTreeNodeHyperlink.TEXT_ATTRIBUTES, new Consumer<MouseEvent>() {\n                  @Override\n                  public void consume(MouseEvent event) {\n                    DebuggerUIUtil.showValuePopup(myFullValueEvaluator, event, getProject());\n                  }\n                });\n                LinkMouseListenerBase.installSingleTagOn(component);\n              }\n              showHint(component);\n            }\n            else if (getType() == ValueHintType.MOUSE_CLICK_HINT) {\n              showTree(result, myExpression);\n            }\n            else {\n              JComponent component = createExpandableHintComponent(text, new Runnable() {\n                @Override\n                public void run() {\n                  showTree(result, myExpression);\n                }\n              });\n              showHint(component);\n            }\n          }\n\n          @Override\n          public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n            myFullValueEvaluator = fullValueEvaluator;\n          }\n\n          @Override\n          public boolean isObsolete() {\n            return isHintHidden();\n          }\n        }, XValuePlace.TOOLTIP);\n      }\n\n      @Override\n      public void errorOccurred(@NotNull final String errorMessage) {\n        LOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n      }\n    }, myExpressionPosition);\n  }","id":86669,"modified_method":"@Override\n  protected void evaluateAndShowHint() {\n    myEvaluator.evaluate(myExpression, new XEvaluationCallbackBase() {\n      @Override\n      public void evaluated(@NotNull final XValue result) {\n        result.computePresentation(new XValueNodePresentationConfigurator.ConfigurableXValueNodeImpl() {\n          private XFullValueEvaluator myFullValueEvaluator;\n\n          @Override\n          public void applyPresentation(@Nullable Icon icon,\n                                        @NotNull XValuePresentation valuePresenter,\n                                        boolean hasChildren) {\n            if (isHintHidden()) {\n              return;\n            }\n\n            SimpleColoredText text = new SimpleColoredText();\n            text.append(myExpression, XDebuggerUIConstants.VALUE_NAME_ATTRIBUTES);\n            XValueNodeImpl.buildText(valuePresenter, text);\n\n            if (!hasChildren) {\n              SimpleColoredComponent component = HintUtil.createInformationComponent();\n              text.appendToComponent(component);\n              if (myFullValueEvaluator != null) {\n                component.append(myFullValueEvaluator.getLinkText(), XDebuggerTreeNodeHyperlink.TEXT_ATTRIBUTES, new Consumer<MouseEvent>() {\n                  @Override\n                  public void consume(MouseEvent event) {\n                    DebuggerUIUtil.showValuePopup(myFullValueEvaluator, event, getProject(), getEditor());\n                  }\n                });\n                LinkMouseListenerBase.installSingleTagOn(component);\n              }\n              showHint(component);\n            }\n            else if (getType() == ValueHintType.MOUSE_CLICK_HINT) {\n              showTree(result, myExpression);\n            }\n            else {\n              JComponent component = createExpandableHintComponent(text, new Runnable() {\n                @Override\n                public void run() {\n                  showTree(result, myExpression);\n                }\n              });\n              showHint(component);\n            }\n          }\n\n          @Override\n          public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n            myFullValueEvaluator = fullValueEvaluator;\n          }\n\n          @Override\n          public boolean isObsolete() {\n            return isHintHidden();\n          }\n        }, XValuePlace.TOOLTIP);\n      }\n\n      @Override\n      public void errorOccurred(@NotNull final String errorMessage) {\n        LOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n      }\n    }, myExpressionPosition);\n  }","commit_id":"0441a534abf3512856aa6529fba5b581840eed92","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected XDebuggerTreeNodeHyperlink getLink() {\n    if (myFullValueEvaluator != null) {\n      return new XDebuggerTreeNodeHyperlink(myFullValueEvaluator.getLinkText()) {\n        @Override\n        public void onClick(MouseEvent event) {\n          DebuggerUIUtil.showValuePopup(myFullValueEvaluator, event, myTree.getProject());\n        }\n      };\n    }\n    return null;\n  }","id":86670,"modified_method":"@Nullable\n  @Override\n  protected XDebuggerTreeNodeHyperlink getLink() {\n    if (myFullValueEvaluator != null) {\n      return new XDebuggerTreeNodeHyperlink(myFullValueEvaluator.getLinkText()) {\n        @Override\n        public void onClick(MouseEvent event) {\n          DebuggerUIUtil.showValuePopup(myFullValueEvaluator, event, myTree.getProject(), null);\n        }\n      };\n    }\n    return null;\n  }","commit_id":"0441a534abf3512856aa6529fba5b581840eed92","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ManagementTreeMouseListener(JTree tree) {\n            this.tree = tree;\n            this.popup = new OperationMenu(cliGuiCtx, tree);\n        }","id":86671,"modified_method":"public ManagementTreeMouseListener(JTree tree) {\n            this.tree = tree;\n            this.operationMenu = new OperationMenu(cliGuiCtx, tree);\n            this.graphingMenu = new GraphingMenu(cliGuiCtx, tree);\n        }","commit_id":"24a714dfd405efa2b5fab5a4743ed888df7f5f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void showPopup(MouseEvent e) {\n            int selRow = tree.getRowForLocation(e.getX(), e.getY());\n            if (selRow == -1) return;\n\n            TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());\n            tree.setSelectionPath(selPath);\n\n            ManagementModelNode node = (ManagementModelNode)selPath.getLastPathComponent();\n\n            popup.show(node, e.getX(), e.getY());\n        }","id":86672,"modified_method":"private void showPopup(MouseEvent e) {\n            int selRow = tree.getRowForLocation(e.getX(), e.getY());\n            if (selRow == -1) return;\n\n            TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());\n            tree.setSelectionPath(selPath);\n\n            ManagementModelNode node = (ManagementModelNode)selPath.getLastPathComponent();\n\n            UserObject usrObj = (UserObject)node.getUserObject();\n            AttributeDescription attrDesc = usrObj.getAttributeDescription();\n            if ((attrDesc != null) && attrDesc.isGraphable()) {\n        //        graphingMenu.show(node, e.getX(), e.getY());\n            } else {\n                operationMenu.show(node, e.getX(), e.getY());\n            }\n        }","commit_id":"24a714dfd405efa2b5fab5a4743ed888df7f5f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"public UserObject(ModelNode backingNode, String name, String value, boolean isLeaf) {\n            this.backingNode = backingNode;\n            this.name = name;\n            this.value = value;\n            this.isLeaf = isLeaf;\n            if (isLeaf) {\n                this.separator = \" => \";\n            } else {\n                this.separator = \"=\";\n            }\n        }","id":86673,"modified_method":"public UserObject(ModelNode backingNode, String name, String value) {\n            this.backingNode = backingNode;\n            this.name = name;\n            this.value = value;\n            this.isLeaf = false;\n            this.separator = \"=\";\n        }","commit_id":"24a714dfd405efa2b5fab5a4743ed888df7f5f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Refresh children using read-resource operation.\n     */\n    public void explore() {\n        if (isLeaf) return;\n        if (isGeneric) return;\n        removeAllChildren();\n\n        try {\n            String addressPath = addressPath();\n            ModelNode response = executor.doCommand(addressPath + \":read-resource\");\n            ModelNode result = response.get(\"result\");\n            if (!result.isDefined()) return;\n\n            List<String> childrenTypes = getChildrenTypes(addressPath);\n            for (ModelNode node : result.asList()) {\n                Property prop = node.asProperty();\n                if (childrenTypes.contains(prop.getName())) { // resource node\n                    if (hasGenericOperations(addressPath, prop.getName())) {\n                        add(new ManagementModelNode(cliGuiCtx, new UserObject(node, prop.getName())));\n                    }\n                    if (prop.getValue().isDefined()) {\n                        for (ModelNode innerNode : prop.getValue().asList()) {\n                            UserObject usrObj = new UserObject(innerNode, prop.getName(), innerNode.asProperty().getName(), false);\n                            add(new ManagementModelNode(cliGuiCtx, usrObj));\n                        }\n                    }\n                } else { // attribute node\n                    UserObject usrObj = new UserObject(node, prop.getName(), prop.getValue().asString(), true);\n                    add(new ManagementModelNode(cliGuiCtx, usrObj));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","id":86674,"modified_method":"/**\n     * Refresh children using read-resource operation.\n     */\n    public void explore() {\n        if (isLeaf) return;\n        if (isGeneric) return;\n        removeAllChildren();\n\n        try {\n            String addressPath = addressPath();\n            ModelNode resourceDesc = executor.doCommand(addressPath + \":read-resource-description\");\n            resourceDesc = resourceDesc.get(\"result\");\n            ModelNode response = executor.doCommand(addressPath + \":read-resource(include-runtime=true,include-defaults=true)\");\n            ModelNode result = response.get(\"result\");\n            if (!result.isDefined()) return;\n\n            List<String> childrenTypes = getChildrenTypes(addressPath);\n            for (ModelNode node : result.asList()) {\n                Property prop = node.asProperty();\n                if (childrenTypes.contains(prop.getName())) { // resource node\n                    if (hasGenericOperations(addressPath, prop.getName())) {\n                        add(new ManagementModelNode(cliGuiCtx, new UserObject(node, prop.getName())));\n                    }\n                    if (prop.getValue().isDefined()) {\n                        for (ModelNode innerNode : prop.getValue().asList()) {\n                            UserObject usrObj = new UserObject(innerNode, prop.getName(), innerNode.asProperty().getName());\n                            add(new ManagementModelNode(cliGuiCtx, usrObj));\n                        }\n                    }\n                } else { // attribute node\n                    UserObject usrObj = new UserObject(node, resourceDesc, prop.getName(), prop.getValue().asString());\n                    add(new ManagementModelNode(cliGuiCtx, usrObj));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"24a714dfd405efa2b5fab5a4743ed888df7f5f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tgetClassName(activity));\n\n\t\tlong classPK = getClassPK(activity);\n\n\t\tif ((trashHandler != null) && (trashHandler.isInTrash(classPK) ||\n\t\t\ttrashHandler.isInTrashContainer(classPK))) {\n\n\t\t\treturn TrashUtil.getViewContentURL(\n\t\t\t\tgetClassName(activity), classPK,\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(serviceContext.getPortalURL());\n\t\tsb.append(serviceContext.getPathMain());\n\t\tsb.append(getPath(activity));\n\t\tsb.append(classPK);\n\n\t\treturn sb.toString();\n\t}","id":86675,"modified_method":"protected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tgetClassName(activity));\n\n\t\tlong classPK = getClassPK(activity);\n\n\t\tif ((trashHandler != null) && (trashHandler.isInTrash(classPK) ||\n\t\t\ttrashHandler.isInTrashContainer(classPK))) {\n\n\t\t\tPortletURL portletURL = TrashUtil.getViewContentURL(\n\t\t\t\tgetClassName(activity), classPK, serviceContext.getRequest());\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(serviceContext.getPortalURL());\n\t\tsb.append(serviceContext.getPathMain());\n\t\tsb.append(getPath(activity));\n\t\tsb.append(classPK);\n\n\t\treturn sb.toString();\n\t}","commit_id":"a406bf3d2ed056ad74d5e9f8f80261a15e27aeb6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\tactivity.getClassPK());\n\n\t\tif (TrashUtil.isInTrash(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey())) {\n\n\t\t\treturn TrashUtil.getViewContentURL(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t}\n\n\t\tJournalArticle lastestArticle =\n\t\t\tJournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tarticle.getGroupId(), article.getArticleId());\n\n\t\tif (Validator.isNotNull(lastestArticle.getLayoutUuid()) &&\n\t\t\t!article.isInTrash()) {\n\n\t\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\t\tserviceContext.getScopeGroup(), false,\n\t\t\t\tserviceContext.getThemeDisplay());\n\n\t\t\treturn groupFriendlyURL.concat(\n\t\t\t\tJournalArticleConstants.CANONICAL_URL_SEPARATOR).concat(\n\t\t\t\t\tlastestArticle.getUrlTitle());\n\t\t}\n\n\t\treturn null;\n\t}","id":86676,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tJournalArticle article = JournalArticleLocalServiceUtil.getArticle(\n\t\t\tactivity.getClassPK());\n\n\t\tif (TrashUtil.isInTrash(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey())) {\n\n\t\t\tPortletURL portletURL = TrashUtil.getViewContentURL(\n\t\t\t\tJournalArticle.class.getName(), article.getResourcePrimKey(),\n\t\t\t\tserviceContext.getRequest());\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\n\t\tJournalArticle lastestArticle =\n\t\t\tJournalArticleLocalServiceUtil.getLatestArticle(\n\t\t\t\tarticle.getGroupId(), article.getArticleId());\n\n\t\tif (Validator.isNotNull(lastestArticle.getLayoutUuid()) &&\n\t\t\t!article.isInTrash()) {\n\n\t\t\tString groupFriendlyURL = PortalUtil.getGroupFriendlyURL(\n\t\t\t\tserviceContext.getScopeGroup(), false,\n\t\t\t\tserviceContext.getThemeDisplay());\n\n\t\t\treturn groupFriendlyURL.concat(\n\t\t\t\tJournalArticleConstants.CANONICAL_URL_SEPARATOR).concat(\n\t\t\t\t\tlastestArticle.getUrlTitle());\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"a406bf3d2ed056ad74d5e9f8f80261a15e27aeb6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tMBMessage message = getMessage(activity);\n\n\t\tMBThread thread = message.getThread();\n\n\t\tif (thread.isInTrash()) {\n\t\t\treturn TrashUtil.getViewContentURL(\n\t\t\t\tMBThread.class.getName(), thread.getThreadId(),\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(serviceContext.getPortalURL());\n\t\tsb.append(serviceContext.getPathMain());\n\t\tsb.append(\"/message_boards/find_message?messageId=\");\n\t\tsb.append(message.getMessageId());\n\n\t\treturn sb.toString();\n\t}","id":86677,"modified_method":"@Override\n\tprotected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tMBMessage message = getMessage(activity);\n\n\t\tMBThread thread = message.getThread();\n\n\t\tif (thread.isInTrash()) {\n\t\t\tPortletURL portletURL = TrashUtil.getViewContentURL(\n\t\t\t\tMBThread.class.getName(), thread.getThreadId(),\n\t\t\t\tserviceContext.getRequest());\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(serviceContext.getPortalURL());\n\t\tsb.append(serviceContext.getPathMain());\n\t\tsb.append(\"/message_boards/find_message?messageId=\");\n\t\tsb.append(message.getMessageId());\n\n\t\treturn sb.toString();\n\t}","commit_id":"a406bf3d2ed056ad74d5e9f8f80261a15e27aeb6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static boolean isArrayLengthComparison(\n            PsiExpression condition, PsiVariable variable){\n        final PsiExpression strippedCondition =\n                ParenthesesUtils.stripParentheses(condition);\n        if(!(strippedCondition instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression binaryExp =\n                (PsiBinaryExpression) strippedCondition;\n        final PsiJavaToken sign = binaryExp.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.LT)){\n            return false;\n        }\n        final PsiExpression lhs = binaryExp.getLOperand();\n        if(!VariableAccessUtils.evaluatesToVariable(lhs, variable)){\n            return false;\n        }\n        final PsiExpression rhs = binaryExp.getROperand();\n        return rhs != null && expressionIsArrayLengthLookup(rhs);\n    }","id":86678,"modified_method":"private static boolean isArrayLengthComparison(\n            PsiExpression condition, PsiVariable variable){\n        condition = ParenthesesUtils.stripParentheses(condition);\n        if(!(condition instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression binaryExpression =\n                (PsiBinaryExpression) condition;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.LT)){\n            return false;\n        }\n        final PsiExpression lhs = binaryExpression.getLOperand();\n        if(!VariableAccessUtils.evaluatesToVariable(lhs, variable)){\n            return false;\n        }\n        final PsiExpression rhs = binaryExpression.getROperand();\n        return rhs != null && expressionIsArrayLengthLookup(rhs);\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override @Nullable\n    public JComponent createOptionsPanel(){\n        myReportIndexedLoop.setSelected(REPORT_INDEXED_LOOP);\n        myReportIndexedLoop.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e){\n                REPORT_INDEXED_LOOP = myReportIndexedLoop.isSelected();\n            }\n        });\n        return myPanel;\n    }","id":86679,"modified_method":"@Override @Nullable\n    public JComponent createOptionsPanel(){\n        return new SingleCheckboxOptionsPanel(\n                InspectionGadgetsBundle.message(\"for.can.be.foreach.option\"),\n                this, \"REPORT_INDEXED_LOOP\");\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitReferenceExpression(\n                @NotNull PsiReferenceExpression reference){\n            if(!indexVariableUsedOnlyAsIndex){\n                return;\n            }\n            super.visitReferenceExpression(reference);\n            final PsiElement element = reference.resolve();\n            if(indexVariable.equals(element)){\n                if(!isListIndexExpression(reference)){\n                    indexVariableUsedOnlyAsIndex = false;\n                }\n            } else if (collection == null){\n                if(isListNonGetMethodCall(reference)){\n                    indexVariableUsedOnlyAsIndex = false;\n                }\n            } else if (collection.equals(element) &&\n                       !isListReferenceInIndexExpression(reference)){\n                indexVariableUsedOnlyAsIndex = false;\n            }\n        }","id":86680,"modified_method":"@Override public void visitReferenceExpression(\n                @NotNull PsiReferenceExpression reference){\n            if(!indexVariableUsedOnlyAsIndex){\n                return;\n            }\n            super.visitReferenceExpression(reference);\n            final PsiElement element = reference.resolve();\n            if(indexVariable.equals(element)){\n                if(!isListIndexExpression(reference)){\n                    indexVariableUsedOnlyAsIndex = false;\n                }\n            } else if (collection == Holder.DUMMY){\n                if(isListNonGetMethodCall(reference)){\n                    indexVariableUsedOnlyAsIndex = false;\n                }\n            } else if (collection.getVariable().equals(element) &&\n                       !isListReferenceInIndexExpression(reference)){\n                indexVariableUsedOnlyAsIndex = false;\n            }\n        }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean isCollectionLoopStatement(\n            PsiForStatement forStatement){\n        final PsiStatement initialization = forStatement.getInitialization();\n        if(!(initialization instanceof PsiDeclarationStatement)){\n            return false;\n        }\n        final PsiDeclarationStatement declaration =\n                (PsiDeclarationStatement) initialization;\n        final PsiElement[] declaredElements = declaration.getDeclaredElements();\n        if(declaredElements.length != 1){\n            return false;\n        }\n        final PsiElement declaredElement = declaredElements[0];\n        if (!(declaredElement instanceof PsiVariable)) {\n            return false;\n        }\n        final PsiVariable variable = (PsiVariable)declaredElement;\n        if(variable == null){\n            return false;\n        }\n        final PsiType variableType = variable.getType();\n        if(!(variableType instanceof PsiClassType)){\n            return false;\n        }\n        final PsiClassType classType = (PsiClassType) variableType;\n        final PsiClass declaredClass = classType.resolve();\n        if(declaredClass == null){\n            return false;\n        }\n        if(!ClassUtils.isSubclass(declaredClass, CommonClassNames.JAVA_UTIL_ITERATOR)){\n            return false;\n        }\n        final PsiExpression initialValue = variable.getInitializer();\n        if(initialValue == null){\n            return false;\n        }\n        if(!(initialValue instanceof PsiMethodCallExpression)){\n            return false;\n        }\n        final PsiMethodCallExpression initialCall =\n                (PsiMethodCallExpression) initialValue;\n        final PsiReferenceExpression initialMethodExpression =\n                initialCall.getMethodExpression();\n        final String initialCallName =\n                initialMethodExpression.getReferenceName();\n        if(!HardcodedMethodConstants.ITERATOR.equals(initialCallName)){\n            return false;\n        }\n        final PsiExpression qualifier =\n                initialMethodExpression.getQualifierExpression();\n        final PsiClass qualifierClass;\n        if(qualifier == null){\n            qualifierClass =\n                    ClassUtils.getContainingClass(initialMethodExpression);\n        } else {\n            final PsiType qualifierType = qualifier.getType();\n            if(!(qualifierType instanceof PsiClassType)){\n                return false;\n            }\n            qualifierClass = ((PsiClassType) qualifierType).resolve();\n        }\n        if(qualifierClass == null){\n            return false;\n        }\n        if(!ClassUtils.isSubclass(qualifierClass,\n                CommonClassNames.JAVA_LANG_ITERABLE) &&\n                !ClassUtils.isSubclass(qualifierClass,\n                        CommonClassNames.JAVA_UTIL_COLLECTION)){\n            return false;\n        }\n        final String iteratorName = variable.getName();\n        final PsiExpression condition = forStatement.getCondition();\n        if(!isHasNext(condition, iteratorName)){\n            return false;\n        }\n        final PsiStatement update = forStatement.getUpdate();\n        if(update != null && !(update instanceof PsiEmptyStatement)){\n            return false;\n        }\n        final PsiStatement body = forStatement.getBody();\n        if(body == null){\n            return false;\n        }\n        if(calculateCallsToIteratorNext(iteratorName, body) != 1){\n            return false;\n        }\n        if(isIteratorRemoveCalled(iteratorName, body)){\n            return false;\n        }\n        if(isIteratorHasNextCalled(iteratorName, body)){\n            return false;\n        }\n        return !VariableAccessUtils.variableIsAssigned(variable, body) &&\n                !VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                        body);\n    }","id":86681,"modified_method":"static boolean isCollectionLoopStatement(\n            PsiForStatement forStatement){\n        final PsiStatement initialization = forStatement.getInitialization();\n        if(!(initialization instanceof PsiDeclarationStatement)){\n            return false;\n        }\n        final PsiDeclarationStatement declaration =\n                (PsiDeclarationStatement) initialization;\n        final PsiElement[] declaredElements = declaration.getDeclaredElements();\n        if(declaredElements.length != 1){\n            return false;\n        }\n        final PsiElement declaredElement = declaredElements[0];\n        if (!(declaredElement instanceof PsiVariable)) {\n            return false;\n        }\n        final PsiVariable variable = (PsiVariable)declaredElement;\n        if(variable == null){\n            return false;\n        }\n        final PsiType variableType = variable.getType();\n        if(!(variableType instanceof PsiClassType)){\n            return false;\n        }\n        final PsiClassType classType = (PsiClassType) variableType;\n        final PsiClass declaredClass = classType.resolve();\n        if(declaredClass == null){\n            return false;\n        }\n        if(!ClassUtils.isSubclass(declaredClass,\n                CommonClassNames.JAVA_UTIL_ITERATOR)){\n            return false;\n        }\n        final PsiExpression initialValue = variable.getInitializer();\n        if(initialValue == null){\n            return false;\n        }\n        if(!(initialValue instanceof PsiMethodCallExpression)){\n            return false;\n        }\n        final PsiMethodCallExpression initialCall =\n                (PsiMethodCallExpression) initialValue;\n        final PsiReferenceExpression initialMethodExpression =\n                initialCall.getMethodExpression();\n        final String initialCallName =\n                initialMethodExpression.getReferenceName();\n        if(!HardcodedMethodConstants.ITERATOR.equals(initialCallName)){\n            return false;\n        }\n        final PsiExpressionList argumentList = initialCall.getArgumentList();\n        final PsiExpression[] arguments = argumentList.getExpressions();\n        if (arguments.length != 0) {\n            return false;\n        }\n        final PsiExpression qualifier =\n                initialMethodExpression.getQualifierExpression();\n        final PsiClass qualifierClass;\n        if(qualifier == null){\n            qualifierClass =\n                    ClassUtils.getContainingClass(initialMethodExpression);\n        } else {\n            final PsiType qualifierType = qualifier.getType();\n            if(!(qualifierType instanceof PsiClassType)){\n                return false;\n            }\n            qualifierClass = ((PsiClassType) qualifierType).resolve();\n        }\n        if(qualifierClass == null){\n            return false;\n        }\n        if(!ClassUtils.isSubclass(qualifierClass,\n                CommonClassNames.JAVA_LANG_ITERABLE) &&\n                !ClassUtils.isSubclass(qualifierClass,\n                        CommonClassNames.JAVA_UTIL_COLLECTION)){\n            return false;\n        }\n        final String iteratorName = variable.getName();\n        final PsiExpression condition = forStatement.getCondition();\n        if(!isHasNext(condition, iteratorName)){\n            return false;\n        }\n        final PsiStatement update = forStatement.getUpdate();\n        if(update != null && !(update instanceof PsiEmptyStatement)){\n            return false;\n        }\n        final PsiStatement body = forStatement.getBody();\n        if(body == null){\n            return false;\n        }\n        if(calculateCallsToIteratorNext(iteratorName, body) != 1){\n            return false;\n        }\n        if(isIteratorRemoveCalled(iteratorName, body)){\n            return false;\n        }\n        if(isIteratorHasNextCalled(iteratorName, body)){\n            return false;\n        }\n        return !VariableAccessUtils.variableIsAssigned(variable, body) &&\n                !VariableAccessUtils.variableIsPassedAsMethodArgument(variable,\n                        body);\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isIndexVariableOnlyUsedAsListIndex(\n            PsiVariable collection, PsiVariable indexVariable,\n            PsiStatement body){\n        if(body == null){\n            return true;\n        }\n        final VariableOnlyUsedAsListIndexVisitor visitor =\n                new VariableOnlyUsedAsListIndexVisitor(collection,\n                        indexVariable);\n        body.accept(visitor);\n        return visitor.isIndexVariableUsedOnlyAsIndex();\n    }","id":86682,"modified_method":"private static boolean isIndexVariableOnlyUsedAsListIndex(\n            Holder collectionHolder, PsiVariable indexVariable,\n            PsiStatement body){\n        if(body == null){\n            return true;\n        }\n        final VariableOnlyUsedAsListIndexVisitor visitor =\n                new VariableOnlyUsedAsListIndexVisitor(collectionHolder,\n                        indexVariable);\n        body.accept(visitor);\n        return visitor.isIndexVariableUsedOnlyAsIndex();\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isIndexedListLoopStatement(\n            PsiForStatement forStatement){\n        final PsiStatement initialization = forStatement.getInitialization();\n        if(!(initialization instanceof PsiDeclarationStatement)){\n            return false;\n        }\n        final PsiDeclarationStatement declaration =\n                (PsiDeclarationStatement) initialization;\n        final PsiElement[] declaredElements = declaration.getDeclaredElements();\n        if(declaredElements.length != 1){\n            return false;\n        }\n        final PsiElement declaredElement = declaredElements[0];\n        if (!(declaredElement instanceof PsiVariable)) {\n            return false;\n        }\n        final PsiVariable indexVariable = (PsiVariable)declaredElement;\n        final PsiExpression initialValue = indexVariable.getInitializer();\n        if(initialValue == null){\n            return false;\n        }\n        final String initializerText = initialValue.getText();\n        if(!\"0\".equals(initializerText)){\n            return false;\n        }\n        final PsiExpression condition = forStatement.getCondition();\n        if(!isListSizeComparison(condition, indexVariable)){\n            return false;\n        }\n        final PsiStatement update = forStatement.getUpdate();\n        if(!VariableAccessUtils.variableIsIncremented(indexVariable, update)){\n            return false;\n        }\n        final PsiReferenceExpression collectionReference =\n                getVariableReferenceFromCondition(condition);\n        if(collectionReference == null){\n            return false;\n        }\n        final PsiElement resolved = collectionReference.resolve();\n        final PsiStatement body = forStatement.getBody();\n        if(resolved instanceof PsiVariable){\n            final PsiVariable collection = (PsiVariable) resolved;\n            if(!isIndexVariableOnlyUsedAsListIndex(collection, indexVariable,\n                    body)){\n                return false;\n            }\n            return !VariableAccessUtils.variableIsAssigned(collection, body);\n        } else if(resolved instanceof PsiMethod){\n            return isIndexVariableOnlyUsedAsListIndex(null, indexVariable,\n                    body);\n        } else {\n            return false;\n        }\n    }","id":86683,"modified_method":"private static boolean isIndexedListLoopStatement(\n            PsiForStatement forStatement){\n        final PsiStatement initialization = forStatement.getInitialization();\n        if(!(initialization instanceof PsiDeclarationStatement)){\n            return false;\n        }\n        final PsiDeclarationStatement declaration =\n                (PsiDeclarationStatement) initialization;\n        final PsiElement[] declaredElements = declaration.getDeclaredElements();\n        if(declaredElements.length != 1){\n            return false;\n        }\n        final PsiElement declaredElement = declaredElements[0];\n        if (!(declaredElement instanceof PsiVariable)) {\n            return false;\n        }\n        final PsiVariable indexVariable = (PsiVariable)declaredElement;\n        final PsiExpression initialValue = indexVariable.getInitializer();\n        if(initialValue == null){\n            return false;\n        }\n        final Object constant =\n                ExpressionUtils.computeConstantExpression(initialValue);\n        if (!(constant instanceof Number)) {\n            return false;\n        }\n        final Number number = (Number) constant;\n        if (number.intValue() != 0) {\n            return false;\n        }\n        final PsiExpression condition = forStatement.getCondition();\n        final Holder collectionHolder =\n                getCollectionFromSizeComparison(condition, indexVariable);\n        if (collectionHolder == null) {\n            return false;\n        }\n        final PsiStatement update = forStatement.getUpdate();\n        if(!VariableAccessUtils.variableIsIncremented(indexVariable, update)){\n            return false;\n        }\n        final PsiStatement body = forStatement.getBody();\n        if(!isIndexVariableOnlyUsedAsListIndex(collectionHolder,\n                indexVariable, body)) {\n            return false;\n        }\n        if (collectionHolder != Holder.DUMMY) {\n            final PsiVariable collection = collectionHolder.getVariable();\n            return !VariableAccessUtils.variableIsAssigned(collection, body);\n        }\n        return true;\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean expressionIsListGetLookup(PsiExpression expression){\n        return isListMethodCall(expression, HardcodedMethodConstants.GET);\n    }","id":86684,"modified_method":"static boolean expressionIsListGetLookup(PsiExpression expression){\n        expression = ParenthesesUtils.stripParentheses(expression);\n        if(!(expression instanceof PsiMethodCallExpression)){\n            return false;\n        }\n        final PsiMethodCallExpression reference =\n                (PsiMethodCallExpression) expression;\n        final PsiReferenceExpression methodExpression =\n                reference.getMethodExpression();\n        final PsiElement resolved = methodExpression.resolve();\n        if(!(resolved instanceof PsiMethod)){\n            return false;\n        }\n        final PsiMethod method = (PsiMethod) resolved;\n        if(!HardcodedMethodConstants.GET.equals(method.getName())){\n            return false;\n        }\n        final PsiClass aClass = method.getContainingClass();\n        return ClassUtils.isSubclass(aClass, CommonClassNames.JAVA_UTIL_LIST);\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"VariableOnlyUsedAsListIndexVisitor(\n                @Nullable PsiVariable collection,\n                @NotNull PsiVariable indexVariable){\n            this.collection = collection;\n            this.indexVariable = indexVariable;\n        }","id":86685,"modified_method":"VariableOnlyUsedAsListIndexVisitor(\n                @NotNull Holder collection,\n                @NotNull PsiVariable indexVariable){\n            this.collection = collection;\n            this.indexVariable = indexVariable;\n        }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean expressionIsArrayLengthLookup(\n            @NotNull PsiExpression expression){\n        final PsiExpression strippedExpression =\n                ParenthesesUtils.stripParentheses(expression);\n        if(!(strippedExpression instanceof PsiReferenceExpression)){\n            return false;\n        }\n        final PsiReferenceExpression reference =\n                (PsiReferenceExpression) strippedExpression;\n        final String referenceName = reference.getReferenceName();\n        if(!HardcodedMethodConstants.LENGTH.equals(referenceName)){\n            return false;\n        }\n        final PsiExpression qualifier = reference.getQualifierExpression();\n        if(!(qualifier instanceof PsiReferenceExpression)){\n            return false;\n        }\n        final PsiType type = qualifier.getType();\n        return type != null && type.getArrayDimensions() > 0;\n    }","id":86686,"modified_method":"private static boolean expressionIsArrayLengthLookup(\n            PsiExpression expression){\n        expression = ParenthesesUtils.stripParentheses(expression);\n        if(!(expression instanceof PsiReferenceExpression)){\n            return false;\n        }\n        final PsiReferenceExpression reference =\n                (PsiReferenceExpression) expression;\n        final String referenceName = reference.getReferenceName();\n        if(!HardcodedMethodConstants.LENGTH.equals(referenceName)){\n            return false;\n        }\n        final PsiExpression qualifier = reference.getQualifierExpression();\n        if(!(qualifier instanceof PsiReferenceExpression)){\n            return false;\n        }\n        final PsiType type = qualifier.getType();\n        return type != null && type.getArrayDimensions() > 0;\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isListGetExpression(\n                PsiMethodCallExpression methodCallExpression){\n            if(methodCallExpression == null){\n                return false;\n            }\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final PsiExpression qualifierExpression =\n                    methodExpression.getQualifierExpression();\n            if(!(qualifierExpression instanceof PsiReferenceExpression)){\n                if(collection == null &&\n                   (qualifierExpression == null ||\n                    qualifierExpression instanceof PsiThisExpression ||\n                    qualifierExpression instanceof PsiSuperExpression)){\n                    return expressionIsListGetLookup(methodCallExpression);\n                }\n                return false;\n            }\n            final PsiReferenceExpression reference =\n                    (PsiReferenceExpression)qualifierExpression;\n            final PsiExpression qualifier = reference.getQualifierExpression();\n            if(qualifier != null && !(qualifier instanceof PsiThisExpression)\n                   && !(qualifier instanceof PsiSuperExpression)){\n                return false;\n            }\n            final PsiElement target = reference.resolve();\n            if(collection == null || !collection.equals(target)){\n                return false;\n            }\n            return expressionIsListGetLookup(methodCallExpression);\n        }","id":86687,"modified_method":"private boolean isListGetExpression(\n                PsiMethodCallExpression methodCallExpression){\n            if(methodCallExpression == null){\n                return false;\n            }\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final PsiExpression qualifierExpression =\n                    methodExpression.getQualifierExpression();\n            if(!(qualifierExpression instanceof PsiReferenceExpression)){\n                if(collection == Holder.DUMMY &&\n                   (qualifierExpression == null ||\n                    qualifierExpression instanceof PsiThisExpression ||\n                    qualifierExpression instanceof PsiSuperExpression)){\n                    return expressionIsListGetLookup(methodCallExpression);\n                }\n                return false;\n            }\n            final PsiReferenceExpression reference =\n                    (PsiReferenceExpression)qualifierExpression;\n            final PsiExpression qualifier = reference.getQualifierExpression();\n            if(qualifier != null && !(qualifier instanceof PsiThisExpression)\n                   && !(qualifier instanceof PsiSuperExpression)){\n                return false;\n            }\n            final PsiElement target = reference.resolve();\n            if(collection == Holder.DUMMY ||\n                    !collection.getVariable().equals(target)){\n                return false;\n            }\n            return expressionIsListGetLookup(methodCallExpression);\n        }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n        private static String createListIterationText(\n                @NotNull PsiForStatement forStatement){\n            final PsiBinaryExpression condition =\n                    (PsiBinaryExpression)forStatement.getCondition();\n            if(condition == null){\n                return null;\n            }\n            final PsiExpression lhs = condition.getLOperand();\n            final String indexName = lhs.getText();\n            final PsiExpression rOperand = condition.getROperand();\n            if(rOperand == null){\n                return null;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression)\n                            ParenthesesUtils.stripParentheses(rOperand);\n            if(methodCallExpression == null){\n                return null;\n            }\n            final PsiReferenceExpression listLengthExpression =\n                    methodCallExpression.getMethodExpression();\n            final PsiExpression qualifier =\n                    listLengthExpression.getQualifierExpression();\n            final PsiReferenceExpression listReference;\n            if (!(qualifier instanceof PsiReferenceExpression)) {\n                listReference = null;\n            } else {\n                listReference = (PsiReferenceExpression) qualifier;\n            }\n            final PsiType parameterType;\n            if(listReference == null) {\n                parameterType = extractTypeFromContainingClass(forStatement);\n            } else {\n                final PsiType type = listReference.getType();\n                if (type == null) {\n                    return null;\n                }\n                parameterType = extractContentTypeFromType(type, forStatement);\n            }\n            if(parameterType == null){\n                return null;\n            }\n            final String typeString = parameterType.getCanonicalText();\n            final PsiVariable listVariable;\n            if (listReference == null) {\n                listVariable = null;\n            } else {\n                final PsiElement target = listReference.resolve();\n                if (!(target instanceof PsiVariable)) {\n                    return null;\n                }\n                listVariable = (PsiVariable)target;\n            }\n            final PsiStatement body = forStatement.getBody();\n            final PsiStatement firstStatement = getFirstStatement(body);\n            final boolean isDeclaration = isListElementDeclaration(\n                    firstStatement, listVariable, indexName, parameterType);\n            final String contentVariableName;\n            @NonNls final String finalString;\n            final PsiStatement statementToSkip;\n            if(isDeclaration){\n                final PsiDeclarationStatement declarationStatement =\n                        (PsiDeclarationStatement)firstStatement;\n                assert declarationStatement != null;\n                final PsiElement[] declaredElements =\n                        declarationStatement.getDeclaredElements();\n                final PsiElement declaredElement = declaredElements[0];\n                if (!(declaredElement instanceof PsiVariable)) {\n                    return null;\n                }\n                final PsiVariable variable = (PsiVariable)declaredElement;\n                contentVariableName = variable.getName();\n                statementToSkip = declarationStatement;\n                if(variable.hasModifierProperty(PsiModifier.FINAL)){\n                    finalString = \"final \";\n                } else {\n                    finalString = \"\";\n                }\n            } else {\n                final String collectionName;\n                if (listReference == null) {\n                    collectionName = null;\n                } else {\n                    collectionName = listReference.getReferenceName();\n                }\n                contentVariableName = createNewVariableName(forStatement,\n                        parameterType, collectionName);\n                finalString = \"\";\n                statementToSkip = null;\n            }\n            @NonNls final StringBuilder out = new StringBuilder();\n            out.append(\"for(\");\n            out.append(finalString);\n            out.append(typeString);\n            out.append(' ');\n            out.append(contentVariableName);\n            out.append(\": \");\n            @NonNls final String listName;\n            if (listReference == null) {\n                listName = \"this\";\n            } else {\n                listName = listReference.getText();\n            }\n            out.append(listName);\n            out.append(')');\n            if(body != null){\n                replaceCollectionGetAccess(body, contentVariableName,\n                        listVariable, indexName, statementToSkip, out);\n            }\n            return out.toString();\n        }","id":86688,"modified_method":"@Nullable\n        private static String createListIterationText(\n                @NotNull PsiForStatement forStatement){\n            final PsiBinaryExpression condition =\n                    (PsiBinaryExpression)ParenthesesUtils.stripParentheses(\n                            forStatement.getCondition());\n            if(condition == null){\n                return null;\n            }\n            final PsiExpression lhs = condition.getLOperand();\n            final String indexName = lhs.getText();\n            PsiExpression rOperand = ParenthesesUtils.stripParentheses(\n                    condition.getROperand());\n            if (rOperand instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression) rOperand;\n                final PsiElement target = referenceExpression.resolve();\n                if (target instanceof PsiVariable) {\n                    final PsiVariable variable = (PsiVariable) target;\n                    rOperand = variable.getInitializer();\n                }\n            }\n            if (!(rOperand instanceof PsiMethodCallExpression)) {\n                return null;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression)\n                            ParenthesesUtils.stripParentheses(rOperand);\n            if(methodCallExpression == null){\n                return null;\n            }\n            final PsiReferenceExpression listLengthExpression =\n                    methodCallExpression.getMethodExpression();\n            final PsiExpression qualifier =\n                    listLengthExpression.getQualifierExpression();\n            final PsiReferenceExpression listReference;\n            if (!(qualifier instanceof PsiReferenceExpression)) {\n                listReference = null;\n            } else {\n                listReference = (PsiReferenceExpression) qualifier;\n            }\n            final PsiType parameterType;\n            if(listReference == null) {\n                parameterType = extractTypeFromContainingClass(forStatement);\n            } else {\n                final PsiType type = listReference.getType();\n                if (type == null) {\n                    return null;\n                }\n                parameterType = extractContentTypeFromType(type, forStatement);\n            }\n            if(parameterType == null){\n                return null;\n            }\n            final String typeString = parameterType.getCanonicalText();\n            final PsiVariable listVariable;\n            if (listReference == null) {\n                listVariable = null;\n            } else {\n                final PsiElement target = listReference.resolve();\n                if (!(target instanceof PsiVariable)) {\n                    return null;\n                }\n                listVariable = (PsiVariable)target;\n            }\n            final PsiStatement body = forStatement.getBody();\n            final PsiStatement firstStatement = getFirstStatement(body);\n            final boolean isDeclaration = isListElementDeclaration(\n                    firstStatement, listVariable, indexName, parameterType);\n            final String contentVariableName;\n            @NonNls final String finalString;\n            final PsiStatement statementToSkip;\n            if(isDeclaration){\n                final PsiDeclarationStatement declarationStatement =\n                        (PsiDeclarationStatement)firstStatement;\n                assert declarationStatement != null;\n                final PsiElement[] declaredElements =\n                        declarationStatement.getDeclaredElements();\n                final PsiElement declaredElement = declaredElements[0];\n                if (!(declaredElement instanceof PsiVariable)) {\n                    return null;\n                }\n                final PsiVariable variable = (PsiVariable)declaredElement;\n                contentVariableName = variable.getName();\n                statementToSkip = declarationStatement;\n                if(variable.hasModifierProperty(PsiModifier.FINAL)){\n                    finalString = \"final \";\n                } else {\n                    finalString = \"\";\n                }\n            } else {\n                final String collectionName;\n                if (listReference == null) {\n                    collectionName = null;\n                } else {\n                    collectionName = listReference.getReferenceName();\n                }\n                contentVariableName = createNewVariableName(forStatement,\n                        parameterType, collectionName);\n                finalString = \"\";\n                statementToSkip = null;\n            }\n            @NonNls final StringBuilder out = new StringBuilder();\n            out.append(\"for(\");\n            out.append(finalString);\n            out.append(typeString);\n            out.append(' ');\n            out.append(contentVariableName);\n            out.append(\": \");\n            @NonNls final String listName;\n            if (listReference == null) {\n                listName = \"this\";\n            } else {\n                listName = listReference.getText();\n            }\n            out.append(listName);\n            out.append(')');\n            if(body != null){\n                replaceCollectionGetAccess(body, contentVariableName,\n                        listVariable, indexName, statementToSkip, out);\n            }\n            return out.toString();\n        }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isListMethodCall(PsiExpression expression,\n                                            String methodName){\n        final PsiExpression strippedExpression =\n                ParenthesesUtils.stripParentheses(expression);\n        if(!(strippedExpression instanceof PsiMethodCallExpression)){\n            return false;\n        }\n        final PsiMethodCallExpression reference =\n                (PsiMethodCallExpression) strippedExpression;\n        final PsiReferenceExpression methodExpression =\n                reference.getMethodExpression();\n        final PsiElement resolved = methodExpression.resolve();\n        if(!(resolved instanceof PsiMethod)){\n            return false;\n        }\n        final PsiMethod method = (PsiMethod) resolved;\n        if(!methodName.equals(method.getName())){\n            return false;\n        }\n        final PsiClass aClass = method.getContainingClass();\n        return ClassUtils.isSubclass(aClass, CommonClassNames.JAVA_UTIL_LIST);\n    }","id":86689,"modified_method":"private static Holder getCollectionFromListMethodCall(\n            PsiExpression expression, String methodName) {\n        expression = ParenthesesUtils.stripParentheses(expression);\n        if (expression instanceof PsiReferenceExpression) {\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) expression;\n            final PsiElement target = referenceExpression.resolve();\n            if (target instanceof PsiVariable) {\n                final PsiVariable variable = (PsiVariable) target;\n                expression = variable.getInitializer();\n            }\n        }\n        if (!(expression instanceof PsiMethodCallExpression)) {\n            return null;\n        }\n        final PsiMethodCallExpression methodCallExpression =\n                (PsiMethodCallExpression) expression;\n        final PsiReferenceExpression methodExpression =\n                methodCallExpression.getMethodExpression();\n        final String referenceName = methodExpression.getReferenceName();\n        if (!methodName.equals(referenceName)) {\n            return null;\n        }\n        final PsiMethod method = methodCallExpression.resolveMethod();\n        if (method == null) {\n            return null;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (!ClassUtils.isSubclass(containingClass,\n                CommonClassNames.JAVA_UTIL_LIST)) {\n            return null;\n        }\n        final PsiExpression qualifierExpression =\n                ParenthesesUtils.stripParentheses(\n                        methodExpression.getQualifierExpression());\n        if (qualifierExpression == null ||\n                qualifierExpression instanceof PsiThisExpression ||\n                qualifierExpression instanceof PsiSuperExpression) {\n            return Holder.DUMMY;\n        }\n        if (!(qualifierExpression instanceof PsiReferenceExpression)) {\n            return null;\n        }\n        final PsiReferenceExpression referenceExpression =\n                (PsiReferenceExpression) qualifierExpression;\n        final PsiElement target = referenceExpression.resolve();\n        if (!(target instanceof PsiVariable)) {\n            return null;\n        }\n        final PsiVariable variable = (PsiVariable) target;\n        return new Holder(variable);\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isListSizeComparison(PsiExpression condition,\n                                                PsiVariable variable){\n        condition = ParenthesesUtils.stripParentheses(condition);\n        if(!(condition instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression binaryExpression =\n                (PsiBinaryExpression) condition;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.LT)){\n            return false;\n        }\n        final PsiExpression lhs = binaryExpression.getLOperand();\n        if(!VariableAccessUtils.evaluatesToVariable(lhs, variable)){\n            return false;\n        }\n        final PsiExpression rhs = binaryExpression.getROperand();\n        return expressionIsListSizeLookup(rhs);\n    }","id":86690,"modified_method":"private static Holder getCollectionFromSizeComparison(\n            PsiExpression condition, PsiVariable variable) {\n        condition = ParenthesesUtils.stripParentheses(condition);\n        if(!(condition instanceof PsiBinaryExpression)){\n            return null;\n        }\n        final PsiBinaryExpression binaryExpression =\n                (PsiBinaryExpression) condition;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(!tokenType.equals(JavaTokenType.LT)){\n            return null;\n        }\n        final PsiExpression lhs = binaryExpression.getLOperand();\n        if(!VariableAccessUtils.evaluatesToVariable(lhs, variable)){\n            return null;\n        }\n        final PsiExpression rhs = binaryExpression.getROperand();\n        return getCollectionFromListMethodCall(rhs,\n                HardcodedMethodConstants.SIZE);\n    }","commit_id":"9892ab2f3270f4ed30662da8590d9e94a7f54bb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testViolations(String arg) {\n        if (arg != null && arg instanceof String) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (null != arg && arg instanceof String) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (arg instanceof String && null != arg) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (arg instanceof String && arg != null) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if ((arg instanceof String) && (arg != null)) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (arg == null || !(arg instanceof String)) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (((arg) != (null)) && ((arg) instanceof String)) {\n          System.out.println(\"this should trigger a warning\");\n        }\n     }","id":86691,"modified_method":"public void testViolations(Object arg) {\n        if (arg != null && arg instanceof String) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (null != arg && arg instanceof String) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (arg instanceof String && null != arg) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (arg instanceof String && arg != null) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if ((arg instanceof String) && (arg != null)) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (arg == null || !(arg instanceof String)) {\n            System.out.println(\"this should trigger a warning\");\n        }\n\n        if (((arg) != (null)) && ((arg) instanceof String)) {\n          System.out.println(\"this should trigger a warning\");\n        }\n        if (arg != null && (arg instanceof String || arg instanceof Integer)) {\n            System.out.println(\"this should trigger a warning\");\n        }\n     }","commit_id":"e6d5dd03035834388d64323ebf32172b2c69ccaf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitBinaryExpression(PsiBinaryExpression expression) {\n      super.visitBinaryExpression(expression);\n      final IElementType operationTokenType =\n        expression.getOperationTokenType();\n      final PsiExpression lhs = ParenthesesUtils.stripParentheses(\n        expression.getLOperand());\n      final PsiExpression rhs = ParenthesesUtils.stripParentheses(\n        expression.getROperand());\n      final PsiBinaryExpression binaryExpression;\n      final PsiInstanceOfExpression instanceofExpression;\n      if (operationTokenType.equals(JavaTokenType.ANDAND)) {\n        if (lhs instanceof PsiBinaryExpression &&\n            rhs instanceof PsiInstanceOfExpression) {\n          binaryExpression = (PsiBinaryExpression)lhs;\n          instanceofExpression = (PsiInstanceOfExpression)rhs;\n        }\n        else if (rhs instanceof PsiBinaryExpression &&\n                 lhs instanceof PsiInstanceOfExpression) {\n          binaryExpression = (PsiBinaryExpression)rhs;\n          instanceofExpression = (PsiInstanceOfExpression)lhs;\n        }\n        else {\n          return;\n        }\n        final IElementType tokenType =\n          binaryExpression.getOperationTokenType();\n        if (!tokenType.equals(JavaTokenType.NE)) {\n          return;\n        }\n      }\n      else if (operationTokenType.equals(JavaTokenType.OROR)) {\n        if (lhs instanceof PsiBinaryExpression &&\n            rhs instanceof PsiPrefixExpression) {\n          final PsiPrefixExpression prefixExpression =\n            (PsiPrefixExpression)rhs;\n          final IElementType prefixTokenType =\n            prefixExpression.getOperationTokenType();\n          if (!JavaTokenType.EXCL.equals(prefixTokenType)) {\n            return;\n          }\n          final PsiExpression operand =\n            ParenthesesUtils.stripParentheses(\n              prefixExpression.getOperand());\n          if (!(operand instanceof PsiInstanceOfExpression)) {\n            return;\n          }\n          binaryExpression = (PsiBinaryExpression)lhs;\n          instanceofExpression = (PsiInstanceOfExpression)operand;\n        }\n        else if (rhs instanceof PsiBinaryExpression &&\n                 lhs instanceof PsiPrefixExpression) {\n          final PsiPrefixExpression prefixExpression =\n            (PsiPrefixExpression)lhs;\n          final IElementType prefixTokenType =\n            prefixExpression.getOperationTokenType();\n          if (!JavaTokenType.EXCL.equals(prefixTokenType)) {\n            return;\n          }\n          final PsiExpression operand =\n            ParenthesesUtils.stripParentheses(\n              prefixExpression.getOperand());\n          if (!(operand instanceof PsiInstanceOfExpression)) {\n            return;\n          }\n          binaryExpression = (PsiBinaryExpression)rhs;\n          instanceofExpression = (PsiInstanceOfExpression)operand;\n        }\n        else {\n          return;\n        }\n        final IElementType tokenType =\n          binaryExpression.getOperationTokenType();\n        if (!tokenType.equals(JavaTokenType.EQEQ)) {\n          return;\n        }\n      }\n      else {\n        return;\n      }\n      final PsiReferenceExpression referenceExpression1 =\n        getReferenceFromNullCheck(binaryExpression);\n      if (referenceExpression1 == null) {\n        return;\n      }\n      final PsiExpression operand =\n        ParenthesesUtils.stripParentheses(\n          instanceofExpression.getOperand());\n      if (!(operand instanceof PsiReferenceExpression)) {\n        return;\n      }\n      final PsiReferenceExpression referenceExpression2 =\n        (PsiReferenceExpression)operand;\n      final PsiElement target1 = referenceExpression1.resolve();\n      final PsiElement target2 = referenceExpression2.resolve();\n      if (target1 == null || !target1.equals(target2)) {\n        return;\n      }\n      registerError(binaryExpression);\n    }","id":86692,"modified_method":"@Override\n    public void visitBinaryExpression(PsiBinaryExpression expression) {\n      super.visitBinaryExpression(expression);\n      final IElementType operationTokenType = expression.getOperationTokenType();\n      final PsiExpression lhs = ParenthesesUtils.stripParentheses(expression.getLOperand());\n      final PsiExpression rhs = ParenthesesUtils.stripParentheses(expression.getROperand());\n      final PsiBinaryExpression binaryExpression;\n      final PsiExpression possibleInstanceofExpression;\n      if (operationTokenType.equals(JavaTokenType.ANDAND)) {\n        if (lhs instanceof PsiBinaryExpression) {\n          binaryExpression = (PsiBinaryExpression)lhs;\n          possibleInstanceofExpression = rhs;\n        }\n        else if (rhs instanceof PsiBinaryExpression) {\n          binaryExpression = (PsiBinaryExpression)rhs;\n          possibleInstanceofExpression = lhs;\n        }\n        else {\n          return;\n        }\n        final IElementType tokenType = binaryExpression.getOperationTokenType();\n        if (!tokenType.equals(JavaTokenType.NE)) {\n          return;\n        }\n      }\n      else if (operationTokenType.equals(JavaTokenType.OROR)) {\n        if (lhs instanceof PsiBinaryExpression && rhs instanceof PsiPrefixExpression) {\n          final PsiPrefixExpression prefixExpression = (PsiPrefixExpression)rhs;\n          final IElementType prefixTokenType = prefixExpression.getOperationTokenType();\n          if (!JavaTokenType.EXCL.equals(prefixTokenType)) {\n            return;\n          }\n          binaryExpression = (PsiBinaryExpression)lhs;\n          possibleInstanceofExpression = ParenthesesUtils.stripParentheses(prefixExpression.getOperand());\n        }\n        else if (rhs instanceof PsiBinaryExpression && lhs instanceof PsiPrefixExpression) {\n          final PsiPrefixExpression prefixExpression = (PsiPrefixExpression)lhs;\n          final IElementType prefixTokenType = prefixExpression.getOperationTokenType();\n          if (!JavaTokenType.EXCL.equals(prefixTokenType)) {\n            return;\n          }\n          binaryExpression = (PsiBinaryExpression)rhs;\n          possibleInstanceofExpression = ParenthesesUtils.stripParentheses(prefixExpression.getOperand());\n        }\n        else {\n          return;\n        }\n        final IElementType tokenType = binaryExpression.getOperationTokenType();\n        if (!tokenType.equals(JavaTokenType.EQEQ)) {\n          return;\n        }\n      }\n      else {\n        return;\n      }\n      final PsiReferenceExpression referenceExpression1 = getReferenceFromNullCheck(binaryExpression);\n      if (referenceExpression1 == null) {\n        return;\n      }\n      final PsiReferenceExpression referenceExpression2 = getReferenceFromInstanceofExpression(possibleInstanceofExpression);\n      if (!referencesEqual(referenceExpression1, referenceExpression2)) {\n        return;\n      }\n      registerError(binaryExpression);\n    }","commit_id":"e6d5dd03035834388d64323ebf32172b2c69ccaf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Before\n    public void setUp() {\n        hz = createHazelcastInstance();\n        Node node = getNode(hz);\n        managementCenterService = node.getManagementCenterService();\n        cluster = hz.getCluster();\n    }","id":86693,"modified_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        cluster = hz.getCluster();\n        managementCenterService = getNode(hz).getManagementCenterService();\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        Node node = getNode(hz);\n        managementCenterService = node.getManagementCenterService();\n    }","id":86694,"modified_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        managementCenterService = getNode(hz).getManagementCenterService();\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public JsonObject toJson() {\n        final JsonObject root = new JsonObject();\n        root.add(\"script\", script);\n        root.add(\"engine\", engine);\n        JsonArray jsonTargets = new JsonArray();\n        for (String target : targets) {\n            jsonTargets.add(target);\n        }\n        root.add(\"targets\", jsonTargets);\n        root.add(\"targetAllMembers\", targetAllMembers);\n        return root;\n    }","id":86695,"modified_method":"@Override\n    public JsonObject toJson() {\n        JsonObject root = new JsonObject();\n        root.add(\"script\", script);\n        root.add(\"engine\", engine);\n        JsonArray jsonTargets = new JsonArray();\n        for (String target : targets) {\n            jsonTargets.add(target);\n        }\n        root.add(\"targets\", jsonTargets);\n        root.add(\"targetAllMembers\", targetAllMembers);\n        return root;\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void writeResponse(ManagementCenterService mcs, JsonObject root) throws Exception {\n        final JsonObject jsonResult = new JsonObject();\n        ArrayList results;\n        if (targetAllMembers) {\n            final Set<Member> members = mcs.getHazelcastInstance().getCluster().getMembers();\n            final ArrayList list = new ArrayList(members.size());\n            for (Member member : members) {\n                list.add(mcs.callOnMember(member, new ScriptExecutorOperation(engine, script, bindings)));\n            }\n            results = list;\n        } else {\n            final ArrayList list = new ArrayList(targets.size());\n            for (String address : targets) {\n                final AddressUtil.AddressHolder addressHolder = AddressUtil.getAddressHolder(address);\n                final Address targetAddress = new Address(addressHolder.getAddress(), addressHolder.getPort());\n                list.add(mcs.callOnAddress(targetAddress, new ScriptExecutorOperation(engine, script, bindings)));\n            }\n            results = list;\n        }\n\n        StringBuffer sb = new StringBuffer();\n        for (Object result : results) {\n            if (result instanceof String) {\n                sb.append(result);\n            } else if (result instanceof List) {\n                final List list = (List) result;\n                for (Object o : list) {\n                    sb.append(o).append(\"\\n\");\n                }\n            } else if (result instanceof Map) {\n                final Map map = (Map) result;\n                for (Object o : map.entrySet()) {\n                    final Map.Entry entry = (Map.Entry) o;\n                    sb.append(entry.getKey()).append(\"->\").append(entry.getValue()).append(\"\\n\");\n                }\n            } else if (result == null) {\n                sb.append(\"error\");\n            }\n            sb.append(\"\\n\");\n        }\n        jsonResult.add(\"scriptResult\", sb.toString());\n        root.add(\"result\", jsonResult);\n    }","id":86696,"modified_method":"@Override\n    public void writeResponse(ManagementCenterService mcs, JsonObject root) throws Exception {\n        JsonObject jsonResult = new JsonObject();\n        ArrayList results;\n        if (targetAllMembers) {\n            Set<Member> members = mcs.getHazelcastInstance().getCluster().getMembers();\n            ArrayList<Object> list = new ArrayList<Object>(members.size());\n            for (Member member : members) {\n                list.add(mcs.callOnMember(member, new ScriptExecutorOperation(engine, script, bindings)));\n            }\n            results = list;\n        } else {\n            ArrayList<Object> list = new ArrayList<Object>(targets.size());\n            for (String address : targets) {\n                AddressUtil.AddressHolder addressHolder = AddressUtil.getAddressHolder(address);\n                Address targetAddress = new Address(addressHolder.getAddress(), addressHolder.getPort());\n                list.add(mcs.callOnAddress(targetAddress, new ScriptExecutorOperation(engine, script, bindings)));\n            }\n            results = list;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (Object result : results) {\n            if (result instanceof String) {\n                sb.append(result);\n            } else if (result instanceof List) {\n                List list = (List) result;\n                for (Object o : list) {\n                    sb.append(o).append(\"\\n\");\n                }\n            } else if (result instanceof Map) {\n                Map map = (Map) result;\n                for (Object o : map.entrySet()) {\n                    Map.Entry entry = (Map.Entry) o;\n                    sb.append(entry.getKey()).append(\"->\").append(entry.getValue()).append(\"\\n\");\n                }\n            } else if (result == null) {\n                sb.append(\"error\");\n            }\n            sb.append(\"\\n\");\n        }\n        jsonResult.add(\"scriptResult\", sb.toString());\n        root.add(\"result\", jsonResult);\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        Node node = getNode(hz);\n        managementCenterService = node.getManagementCenterService();\n        request = new ForceStartNodeRequest();\n    }","id":86697,"modified_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        managementCenterService = getNode(hz).getManagementCenterService();\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testForceStart_fails_withNoEnterprise() throws Exception {\n        JsonObject jsonObject = new JsonObject();\n        request.writeResponse(managementCenterService, jsonObject);\n\n        JsonObject result = (JsonObject) jsonObject.get(\"result\");\n        assertEquals(ForceStartNodeRequest.FAILED_RESULT, request.readResponse(result));\n    }","id":86698,"modified_method":"@Test\n    public void testForceStart_fails_withNoEnterprise() throws Exception {\n        ForceStartNodeRequest request = new ForceStartNodeRequest();\n\n        JsonObject jsonObject = new JsonObject();\n        request.writeResponse(managementCenterService, jsonObject);\n\n        JsonObject result = (JsonObject) jsonObject.get(\"result\");\n        assertEquals(ForceStartNodeRequest.FAILED_RESULT, request.readResponse(result));\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Before\n    public void setUp() {\n        hz = createHazelcastInstance();\n        Node node = getNode(hz);\n        managementCenterService = node.getManagementCenterService();\n        cluster = hz.getCluster();\n        getClusterStateRequest = new GetClusterStateRequest();\n    }","id":86699,"modified_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        cluster = hz.getCluster();\n        managementCenterService = getNode(hz).getManagementCenterService();\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetClusterState() throws Exception {\n        ClusterState clusterState = cluster.getClusterState();\n        JsonObject jsonObject = new JsonObject();\n        getClusterStateRequest.writeResponse(managementCenterService, jsonObject);\n\n        JsonObject result = (JsonObject) jsonObject.get(\"result\");\n        assertEquals(clusterState.name(), getClusterStateRequest.readResponse(result));\n    }","id":86700,"modified_method":"@Test\n    public void testGetClusterState() throws Exception {\n        GetClusterStateRequest request = new GetClusterStateRequest();\n\n        ClusterState clusterState = cluster.getClusterState();\n        JsonObject jsonObject = new JsonObject();\n        request.writeResponse(managementCenterService, jsonObject);\n\n        JsonObject result = (JsonObject) jsonObject.get(\"result\");\n        assertEquals(clusterState.name(), request.readResponse(result));\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public JettyServer(int port, String sourceDir, String serverXml) throws Exception {\n        buildJetty(port, sourceDir, serverXml);\n    }","id":86701,"modified_method":"JettyServer(int port, String sourceDir, String serverXml) throws Exception {\n        buildJetty(port, sourceDir, serverXml);\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void buildJetty(int port, String sourceDir, String webXmlFile) throws Exception {\n        server = new Server();\n\n        SelectChannelConnector connector = new SelectChannelConnector();\n        connector.setPort(port);\n        server.addConnector(connector);\n        WebAppContext context = new WebAppContext();\n        context.setResourceBase(sourceDir);\n        context.setDescriptor(sourceDir + \"/WEB-INF/\" + webXmlFile);\n        context.setLogUrlOnStart(true);\n        context.setContextPath(\"/\");\n        context.setParentLoaderPriority(true);\n\n        server.setHandler(context);\n\n        server.start();\n    }","id":86702,"modified_method":"private void buildJetty(int port, String sourceDir, String webXmlFile) throws Exception {\n        server = new Server();\n\n        SelectChannelConnector connector = new SelectChannelConnector();\n        connector.setPort(port);\n        server.addConnector(connector);\n        WebAppContext context = new WebAppContext();\n        context.setResourceBase(sourceDir);\n        context.setDescriptor(sourceDir + \"/WEB-INF/\" + webXmlFile);\n        context.setLogUrlOnStart(true);\n        context.setContextPath(\"/\");\n        context.setParentLoaderPriority(true);\n\n        server.setHandler(context);\n\n        server.start();\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test //https://github.com/hazelcast/hazelcast/issues/8463\n    public void testJMXStatsWithPublicAdressHostName() {\n        Config config = new Config();\n        config.getNetworkConfig().setPublicAddress(\"hazelcast.org\");\n        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);\n        MemberStateImpl memberState = new MemberStateImpl();\n        TimedMemberStateFactoryHelper.registerJMXBeans(getNode(instance).hazelcastInstance, memberState);\n        PartitionServiceBeanDTO partitionServiceDTO = memberState.getMXBeans().getPartitionServiceBean();\n        assertEquals(partitionServiceDTO.getPartitionCount(), partitionServiceDTO.getActivePartitionCount());\n    }","id":86703,"modified_method":"/**\n     * https://github.com/hazelcast/hazelcast/issues/8463\n     */\n    @Test\n    public void testJMXStatsWithPublicAddressHostName() {\n        Config config = new Config();\n        config.getNetworkConfig().setPublicAddress(\"hazelcast.org\");\n        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);\n        MemberStateImpl memberState = new MemberStateImpl();\n        TimedMemberStateFactoryHelper.registerJMXBeans(getNode(instance).hazelcastInstance, memberState);\n        PartitionServiceBeanDTO partitionServiceDTO = memberState.getMXBeans().getPartitionServiceBean();\n        assertEquals(partitionServiceDTO.getPartitionCount(), partitionServiceDTO.getActivePartitionCount());\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testShutdownCluster() throws Exception {\n        ClusterState clusterState = cluster.getClusterState();\n        JsonObject jsonObject = new JsonObject();\n        shutdownClusterRequest.writeResponse(managementCenterService, jsonObject);\n\n        JsonObject result = (JsonObject) jsonObject.get(\"result\");\n        assertEquals(SUCCESS, shutdownClusterRequest.readResponse(result));\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertFalse(lifecycleService.isRunning());\n            }\n        });\n    }","id":86704,"modified_method":"@Test\n    public void testShutdownCluster() throws Exception {\n        ShutdownClusterRequest request = new ShutdownClusterRequest();\n\n        cluster.getClusterState();\n        JsonObject jsonObject = new JsonObject();\n        request.writeResponse(managementCenterService, jsonObject);\n\n        JsonObject result = (JsonObject) jsonObject.get(\"result\");\n        assertEquals(\"SUCCESS\", request.readResponse(result));\n\n        assertTrueEventually(new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                assertFalse(lifecycleService.isRunning());\n            }\n        });\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Before\n    public void setUp() {\n        hz = createHazelcastInstance();\n        lifecycleService = hz.getLifecycleService();\n        Node node = getNode(hz);\n        managementCenterService = node.getManagementCenterService();\n        cluster = hz.getCluster();\n        shutdownClusterRequest = new ShutdownClusterRequest();\n    }","id":86705,"modified_method":"@Before\n    public void setUp() {\n        HazelcastInstance hz = createHazelcastInstance();\n        lifecycleService = hz.getLifecycleService();\n        cluster = hz.getCluster();\n        managementCenterService = getNode(hz).getManagementCenterService();\n    }","commit_id":"2dbebeffa82c2ea6ed9cd7da6ab0aa39c32abe73","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected AbstractDistributedProgramRunner(TwillRunner twillRunner, Configuration hConf, CConfiguration cConf) {\n    this.twillRunner = twillRunner;\n    this.hConf = hConf;\n    this.cConf = cConf;\n    this.eventHandler = createEventHandler(cConf);\n  }","id":86706,"modified_method":"protected AbstractDistributedProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                             Configuration hConf, CConfiguration cConf) {\n    this.twillRunner = twillRunner;\n    this.locationFactory = locationFactory;\n    this.hConf = hConf;\n    this.cConf = cConf;\n    this.eventHandler = createEventHandler(cConf);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public final ProgramController run(final Program program, final ProgramOptions oldOptions) {\n    final String schedulerQueueName = oldOptions.getArguments().getOption(Constants.AppFabric.APP_SCHEDULER_QUEUE);\n    final File tempDir = DirUtils.createTempDir(new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                                         cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile());\n    try {\n      if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n        hConf.set(JobContext.QUEUE_NAME, schedulerQueueName);\n        LOG.info(\"Setting scheduler queue to {}\", schedulerQueueName);\n      }\n\n      Map<String, LocalizeResource> localizeResources = new HashMap<>();\n      final ProgramOptions options = program.getApplicationSpecification().getPlugins().isEmpty() ?\n        oldOptions : addArtifactPluginFiles(oldOptions, localizeResources, DirUtils.createTempDir(tempDir));\n\n      // Copy config files and program jar to local temp, and ask Twill to localize it to container.\n      // What Twill does is to save those files in HDFS and keep using them during the lifetime of application.\n      // Twill will manage the cleanup of those files in HDFS.\n      localizeResources.put(\"hConf.xml\",\n                            new LocalizeResource(saveHConf(hConf, File.createTempFile(\"hConf\", \".xml\", tempDir))));\n      localizeResources.put(\"cConf.xml\",\n                            new LocalizeResource(saveCConf(cConf, File.createTempFile(\"cConf\", \".xml\", tempDir))));\n      File programDir = DirUtils.createTempDir(tempDir);\n      final Program copiedProgram = copyProgramJar(program, tempDir, programDir);\n\n      final URI logbackURI = getLogBackURI(copiedProgram, programDir, tempDir);\n      final String programOptions = GSON.toJson(options);\n\n      // Obtains and add the HBase delegation token as well (if in non-secure mode, it's a no-op)\n      // Twill would also ignore it if it is not running in secure mode.\n      // The HDFS token should already obtained by Twill.\n      return launch(copiedProgram, options, localizeResources, new ApplicationLauncher() {\n        @Override\n        public TwillController launch(TwillApplication twillApplication, Iterable<String> extraClassPaths) {\n          TwillPreparer twillPreparer = twillRunner.prepare(twillApplication);\n          if (options.isDebug()) {\n            LOG.info(\"Starting {} with debugging enabled, programOptions: {}, and logback: {}\",\n                     program.getId(), programOptions, logbackURI);\n            twillPreparer.enableDebugging();\n          }\n          // Add scheduler queue name if defined\n          if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n            LOG.info(\"Setting scheduler queue for app {} as {}\", program.getId(), schedulerQueueName);\n            twillPreparer.setSchedulerQueue(schedulerQueueName);\n          }\n          if (logbackURI != null) {\n            twillPreparer.withResources(logbackURI);\n          }\n\n          String yarnAppClassPath = hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH,\n                                           Joiner.on(\",\").join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n          TwillController twillController = twillPreparer\n            .withDependencies(HBaseTableUtilFactory.getHBaseTableUtilClass())\n            .addLogHandler(new PrinterLogHandler(new PrintWriter(System.out)))\n            .addSecureStore(YarnSecureStore.create(HBaseTokenUtils.obtainToken(hConf, new Credentials())))\n            .withClassPaths(Iterables.concat(extraClassPaths, Splitter.on(',').trimResults()\n                              .split(hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH, \"\"))))\n            .withApplicationClassPaths(Splitter.on(\",\").trimResults().split(yarnAppClassPath))\n            .withBundlerClassAcceptor(new HadoopClassExcluder())\n            .withApplicationArguments(\n              String.format(\"--%s\", RunnableOptions.JAR), copiedProgram.getJarLocation().getName(),\n              String.format(\"--%s\", RunnableOptions.PROGRAM_OPTIONS), programOptions\n            ).start();\n          return addCleanupListener(twillController, program, tempDir);\n        }\n      });\n    } catch (IOException e) {\n      deleteDirectory(tempDir);\n      throw Throwables.propagate(e);\n    }\n  }","id":86707,"modified_method":"@Override\n  public final ProgramController run(final Program program, final ProgramOptions oldOptions) {\n    final String schedulerQueueName = oldOptions.getArguments().getOption(Constants.AppFabric.APP_SCHEDULER_QUEUE);\n    final File tempDir = DirUtils.createTempDir(new File(cConf.get(Constants.CFG_LOCAL_DATA_DIR),\n                                                         cConf.get(Constants.AppFabric.TEMP_DIR)).getAbsoluteFile());\n    try {\n      if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n        hConf.set(JobContext.QUEUE_NAME, schedulerQueueName);\n        LOG.info(\"Setting scheduler queue to {}\", schedulerQueueName);\n      }\n\n      Map<String, LocalizeResource> localizeResources = new HashMap<>();\n      final ProgramOptions options = program.getApplicationSpecification().getPlugins().isEmpty() ?\n        oldOptions : addArtifactPluginFiles(oldOptions, localizeResources, DirUtils.createTempDir(tempDir));\n\n      // Copy config files and program jar to local temp, and ask Twill to localize it to container.\n      // What Twill does is to save those files in HDFS and keep using them during the lifetime of application.\n      // Twill will manage the cleanup of those files in HDFS.\n      localizeResources.put(\"hConf.xml\",\n                            new LocalizeResource(saveHConf(hConf, File.createTempFile(\"hConf\", \".xml\", tempDir))));\n      localizeResources.put(\"cConf.xml\",\n                            new LocalizeResource(saveCConf(cConf, File.createTempFile(\"cConf\", \".xml\", tempDir))));\n      File programDir = DirUtils.createTempDir(tempDir);\n      final Program copiedProgram = copyProgramJar(program, tempDir, programDir);\n\n      final URI logbackURI = getLogBackURI(copiedProgram, programDir, tempDir);\n      final String programOptions = GSON.toJson(options);\n\n      // Obtains and add the HBase delegation token as well (if in non-secure mode, it's a no-op)\n      // Twill would also ignore it if it is not running in secure mode.\n      // The HDFS token should already obtained by Twill.\n      return launch(copiedProgram, options, localizeResources, new ApplicationLauncher() {\n        @Override\n        public TwillController launch(TwillApplication twillApplication, Iterable<String> extraClassPaths) {\n          TwillPreparer twillPreparer = twillRunner.prepare(twillApplication);\n          if (options.isDebug()) {\n            LOG.info(\"Starting {} with debugging enabled, programOptions: {}, and logback: {}\",\n                     program.getId(), programOptions, logbackURI);\n            twillPreparer.enableDebugging();\n          }\n          // Add scheduler queue name if defined\n          if (schedulerQueueName != null && !schedulerQueueName.isEmpty()) {\n            LOG.info(\"Setting scheduler queue for app {} as {}\", program.getId(), schedulerQueueName);\n            twillPreparer.setSchedulerQueue(schedulerQueueName);\n          }\n          if (logbackURI != null) {\n            twillPreparer.withResources(logbackURI);\n          }\n\n          String yarnAppClassPath = hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH,\n                                           Joiner.on(\",\").join(YarnConfiguration.DEFAULT_YARN_APPLICATION_CLASSPATH));\n          TwillController twillController = addSecureStore(twillPreparer, locationFactory)\n            .withDependencies(HBaseTableUtilFactory.getHBaseTableUtilClass())\n            .addLogHandler(new PrinterLogHandler(new PrintWriter(System.out)))\n            .withClassPaths(Iterables.concat(extraClassPaths, Splitter.on(',').trimResults()\n                              .split(hConf.get(YarnConfiguration.YARN_APPLICATION_CLASSPATH, \"\"))))\n            .withApplicationClassPaths(Splitter.on(\",\").trimResults().split(yarnAppClassPath))\n            .withBundlerClassAcceptor(new HadoopClassExcluder())\n            .withApplicationArguments(\n              String.format(\"--%s\", RunnableOptions.JAR), copiedProgram.getJarLocation().getName(),\n              String.format(\"--%s\", RunnableOptions.PROGRAM_OPTIONS), programOptions\n            ).start();\n          return addCleanupListener(twillController, program, tempDir);\n        }\n      });\n    } catch (IOException e) {\n      deleteDirectory(tempDir);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    final FileSystem fileSystem = dfsCluster.getFileSystem();\n\n    LocationFactory locationFactory = new HDFSLocationFactory(fileSystem);\n    namespacedLocationFactory = new DefaultNamespacedLocationFactory(CConfiguration.create(), locationFactory);\n\n  }","id":86708,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    LocationFactory locationFactory = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n    namespacedLocationFactory = new DefaultNamespacedLocationFactory(CConfiguration.create(), locationFactory);\n\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    final FileSystem fileSystem = dfsCluster.getFileSystem();\n\n    locationFactory = new HDFSLocationFactory(fileSystem);\n  }","id":86709,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    locationFactory = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    locationFactory = new HDFSLocationFactory(dfsCluster.getFileSystem());\n  }","id":86710,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    locationFactory = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    final FileSystem fileSystem = dfsCluster.getFileSystem();\n\n    locationFactory = new HDFSLocationFactory(fileSystem);\n  }","id":86711,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, TMP_FOLDER.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    locationFactory = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tmpFolder.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    FileSystem fileSystem = dfsCluster.getFileSystem();\n    final HDFSLocationFactory lf = new HDFSLocationFactory(fileSystem);\n    final NamespacedLocationFactory nlf = new DefaultNamespacedLocationFactory(cConf, lf);\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(LocationFactory.class).toInstance(lf);\n          bind(NamespacedLocationFactory.class).toInstance(nlf);\n        }\n      },\n      new TransactionMetricsModule(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getDistributedModules(),\n      Modules.override(new DataSetsModules().getDistributedModules()).with(new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(BusinessMetadataStore.class).to(NoOpBusinessMetadataStore.class);\n        }\n      }),\n      new ExploreClientModule(),\n      new ViewAdminModules().getInMemoryModules(),\n      Modules.override(new StreamAdminModules().getDistributedModules()).with(new AbstractModule() {\n\n        @Override\n        protected void configure() {\n          // Tests are running in same process, hence no need to have ZK to coordinate\n          bind(StreamCoordinatorClient.class).to(InMemoryStreamCoordinatorClient.class).in(Scopes.SINGLETON);\n          bind(StreamMetaStore.class).to(InMemoryStreamMetaStore.class);\n        }\n      }),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          // We don't need notification in this test, hence inject an no-op one\n          bind(NotificationFeedManager.class).to(NoOpNotificationFeedManager.class);\n        }\n      }\n    );\n\n    locationFactory = injector.getInstance(LocationFactory.class);\n    namespacedLocationFactory = injector.getInstance(NamespacedLocationFactory.class);\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    fileWriterFactory = injector.getInstance(StreamFileWriterFactory.class);\n    streamCoordinatorClient = injector.getInstance(StreamCoordinatorClient.class);\n    streamCoordinatorClient.startAndWait();\n  }","id":86712,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tmpFolder.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    final LocationFactory lf = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n    final NamespacedLocationFactory nlf = new DefaultNamespacedLocationFactory(cConf, lf);\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new ZKClientModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(LocationFactory.class).toInstance(lf);\n          bind(NamespacedLocationFactory.class).toInstance(nlf);\n        }\n      },\n      new TransactionMetricsModule(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getDistributedModules(),\n      Modules.override(new DataSetsModules().getDistributedModules()).with(new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(BusinessMetadataStore.class).to(NoOpBusinessMetadataStore.class);\n        }\n      }),\n      new ExploreClientModule(),\n      new ViewAdminModules().getInMemoryModules(),\n      Modules.override(new StreamAdminModules().getDistributedModules()).with(new AbstractModule() {\n\n        @Override\n        protected void configure() {\n          // Tests are running in same process, hence no need to have ZK to coordinate\n          bind(StreamCoordinatorClient.class).to(InMemoryStreamCoordinatorClient.class).in(Scopes.SINGLETON);\n          bind(StreamMetaStore.class).to(InMemoryStreamMetaStore.class);\n        }\n      }),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          // We don't need notification in this test, hence inject an no-op one\n          bind(NotificationFeedManager.class).to(NoOpNotificationFeedManager.class);\n        }\n      }\n    );\n\n    locationFactory = injector.getInstance(LocationFactory.class);\n    namespacedLocationFactory = injector.getInstance(NamespacedLocationFactory.class);\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    fileWriterFactory = injector.getInstance(StreamFileWriterFactory.class);\n    streamCoordinatorClient = injector.getInstance(StreamCoordinatorClient.class);\n    streamCoordinatorClient.startAndWait();\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration conf = new Configuration();\n    conf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tmpFolder.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(conf).numDataNodes(1).build();\n    locationFactory = new HDFSLocationFactory(dfsCluster.getFileSystem());\n  }","id":86713,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    Configuration conf = new Configuration();\n    conf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tmpFolder.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(conf).numDataNodes(1).build();\n    locationFactory = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  DistributedFlowProgramRunner(TwillRunner twillRunner, Configuration hConfig,\n                               CConfiguration cConfig, QueueAdmin queueAdmin, StreamAdmin streamAdmin,\n                               TransactionExecutorFactory txExecutorFactory) {\n    super(twillRunner, hConfig, cConfig);\n    this.queueAdmin = queueAdmin;\n    this.streamAdmin = streamAdmin;\n    this.txExecutorFactory = txExecutorFactory;\n  }","id":86714,"modified_method":"@Inject\n  DistributedFlowProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory, Configuration hConfig,\n                               CConfiguration cConfig, QueueAdmin queueAdmin, StreamAdmin streamAdmin,\n                               TransactionExecutorFactory txExecutorFactory) {\n    super(twillRunner, locationFactory, hConfig, cConfig);\n    this.queueAdmin = queueAdmin;\n    this.streamAdmin = streamAdmin;\n    this.txExecutorFactory = txExecutorFactory;\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DistributedMapReduceProgramRunner(TwillRunner twillRunner, Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, hConf, cConf);\n  }","id":86715,"modified_method":"@Inject\n  public DistributedMapReduceProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                           Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, locationFactory, hConf, cConf);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  DistributedServiceProgramRunner(TwillRunner twillRunner, Configuration hConfig, CConfiguration cConfig) {\n    super(twillRunner, hConfig, cConfig);\n  }","id":86716,"modified_method":"@Inject\n  DistributedServiceProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                  Configuration hConfig, CConfiguration cConfig) {\n    super(twillRunner, locationFactory, hConfig, cConfig);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DistributedSparkProgramRunner(TwillRunner twillRunner, Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, createConfiguration(hConf), cConf);\n  }","id":86717,"modified_method":"@Inject\n  public DistributedSparkProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                       Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, locationFactory, createConfiguration(hConf), cConf);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws IOException {\n    zkServer = InMemoryZKServer.builder().setDataDir(tmpFolder.newFolder()).build();\n    zkServer.startAndWait();\n\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tmpFolder.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    FileSystem fileSystem = dfsCluster.getFileSystem();\n    final HDFSLocationFactory lf = new HDFSLocationFactory(fileSystem);\n    final NamespacedLocationFactory nlf = new DefaultNamespacedLocationFactory(cConf, lf);\n\n    cConf.set(Constants.Zookeeper.QUORUM, zkServer.getConnectionStr());\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf),\n      new ZKClientModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new DataFabricModules().getDistributedModules(),\n      Modules.override(new DataSetsModules().getDistributedModules()).with(new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(BusinessMetadataStore.class).to(NoOpBusinessMetadataStore.class);\n        }\n      }),\n      new TransactionMetricsModule(),\n      new NotificationFeedServiceRuntimeModule().getInMemoryModules(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(LocationFactory.class).toInstance(lf);\n          bind(NamespacedLocationFactory.class).toInstance(nlf);\n        }\n      },\n      new ExploreClientModule(),\n      new ViewAdminModules().getInMemoryModules(),\n      Modules.override(new StreamAdminModules().getDistributedModules())\n        .with(new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(StreamMetaStore.class).to(InMemoryStreamMetaStore.class);\n          }\n        })\n    );\n\n    zkClient = injector.getInstance(ZKClientService.class);\n    zkClient.startAndWait();\n\n    setupNamespaces(injector.getInstance(NamespacedLocationFactory.class));\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    coordinatorClient = injector.getInstance(StreamCoordinatorClient.class);\n    coordinatorClient.startAndWait();\n  }","id":86718,"modified_method":"@BeforeClass\n  public static void init() throws IOException {\n    zkServer = InMemoryZKServer.builder().setDataDir(tmpFolder.newFolder()).build();\n    zkServer.startAndWait();\n\n    Configuration hConf = new Configuration();\n    hConf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, tmpFolder.newFolder().getAbsolutePath());\n    dfsCluster = new MiniDFSCluster.Builder(hConf).numDataNodes(1).build();\n    final LocationFactory lf = new FileContextLocationFactory(dfsCluster.getFileSystem().getConf());\n    final NamespacedLocationFactory nlf = new DefaultNamespacedLocationFactory(cConf, lf);\n\n    cConf.set(Constants.Zookeeper.QUORUM, zkServer.getConnectionStr());\n\n    Injector injector = Guice.createInjector(\n      new ConfigModule(cConf),\n      new ZKClientModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new DataFabricModules().getDistributedModules(),\n      Modules.override(new DataSetsModules().getDistributedModules()).with(new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(BusinessMetadataStore.class).to(NoOpBusinessMetadataStore.class);\n        }\n      }),\n      new TransactionMetricsModule(),\n      new NotificationFeedServiceRuntimeModule().getInMemoryModules(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(LocationFactory.class).toInstance(lf);\n          bind(NamespacedLocationFactory.class).toInstance(nlf);\n        }\n      },\n      new ExploreClientModule(),\n      new ViewAdminModules().getInMemoryModules(),\n      Modules.override(new StreamAdminModules().getDistributedModules())\n        .with(new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(StreamMetaStore.class).to(InMemoryStreamMetaStore.class);\n          }\n        })\n    );\n\n    zkClient = injector.getInstance(ZKClientService.class);\n    zkClient.startAndWait();\n\n    setupNamespaces(injector.getInstance(NamespacedLocationFactory.class));\n    streamAdmin = injector.getInstance(StreamAdmin.class);\n    coordinatorClient = injector.getInstance(StreamCoordinatorClient.class);\n    coordinatorClient.startAndWait();\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DistributedWebappProgramRunner(TwillRunner twillRunner, Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, hConf, cConf);\n  }","id":86719,"modified_method":"@Inject\n  public DistributedWebappProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                        Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, locationFactory, hConf, cConf);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  DistributedWorkerProgramRunner(TwillRunner twillRunner, Configuration hConfig, CConfiguration cConfig) {\n    super(twillRunner, hConfig, cConfig);\n  }","id":86720,"modified_method":"@Inject\n  DistributedWorkerProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                 Configuration hConfig, CConfiguration cConfig) {\n    super(twillRunner, locationFactory, hConfig, cConfig);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DistributedWorkflowProgramRunner(TwillRunner twillRunner, Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, createConfiguration(hConf), cConf);\n  }","id":86721,"modified_method":"@Inject\n  public DistributedWorkflowProgramRunner(TwillRunner twillRunner, LocationFactory locationFactory,\n                                          Configuration hConf, CConfiguration cConf) {\n    super(twillRunner, locationFactory, createConfiguration(hConf), cConf);\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Provides\n    @Singleton\n    private FileSystem providesFileSystem(CConfiguration cConf, Configuration hConf) {\n      String hdfsUser = cConf.get(Constants.CFG_HDFS_USER);\n      try {\n        if (hdfsUser == null || UserGroupInformation.isSecurityEnabled()) {\n          if (hdfsUser != null) {\n            LOG.debug(\"Ignoring configuration {}={}, running on secure Hadoop\", Constants.CFG_HDFS_USER, hdfsUser);\n          }\n          LOG.debug(\"Getting filesystem for current user\");\n          return FileSystem.get(FileSystem.getDefaultUri(hConf), hConf);\n        } else {\n          LOG.debug(\"Getting filesystem for user {}\", hdfsUser);\n          return FileSystem.get(FileSystem.getDefaultUri(hConf), hConf, hdfsUser);\n        }\n      } catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":86722,"modified_method":"@Provides\n    @Singleton\n    private RootLocationFactory provideRoot(Configuration hConf) {\n      return new RootLocationFactory(new FileContextLocationFactory(hConf));\n    }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Provides\n    @Singleton\n    private LocationFactory providesHDFSLocationFactory(FileSystem fileSystem, CConfiguration cConf) {\n      String namespace = cConf.get(Constants.CFG_HDFS_NAMESPACE);\n      LOG.info(\"HDFS namespace is \" + namespace);\n      return new HDFSLocationFactory(fileSystem, namespace);\n    }","id":86723,"modified_method":"@Provides\n    @Singleton\n    private LocationFactory providesLocationFactory(final Configuration hConf, CConfiguration cConf) {\n      final String namespace = cConf.get(Constants.CFG_HDFS_NAMESPACE);\n      LOG.info(\"HDFS namespace is \" + namespace);\n\n      String hdfsUser = cConf.get(Constants.CFG_HDFS_USER);\n      UserGroupInformation ugi;\n      try {\n        if (hdfsUser == null || UserGroupInformation.isSecurityEnabled()) {\n          if (hdfsUser != null) {\n            LOG.debug(\"Ignoring configuration {}={}, running on secure Hadoop\", Constants.CFG_HDFS_USER, hdfsUser);\n          }\n          LOG.debug(\"Getting filesystem for current user\");\n          ugi = UserGroupInformation.getCurrentUser();\n        } else {\n          LOG.debug(\"Getting filesystem for user {}\", hdfsUser);\n          ugi = UserGroupInformation.createRemoteUser(hdfsUser);\n        }\n      } catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n\n      return ugi.doAs(new PrivilegedAction<LocationFactory>() {\n        @Override\n        public LocationFactory run() {\n          return new FileContextLocationFactory(hConf, namespace);\n        }\n      });\n    }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Do some processing on the locations contained in the {@code startLocation}, using the {@code processor}. If this\n   * location is a directory, all the locations contained in it will also be processed. If the {@code recursive} tag\n   * is set to true, those locations that are directories will also be processed recursively. If the\n   * {@code startLocation} is not a directory, this method will return the result of the processing of that location.\n   *\n   * @param startLocation location to start the processing from\n   * @param recursive {@code true} if this method should be called on the directory {@link Location}s found from\n   *                  {@code startLocation}. If the {@code startLocation} is a directory, all the locations under it\n   *                  will be processed, regardless of the value of {@code recursive}\n   * @param processor used to process locations. If the {@link Processor#process} method returns false on any\n   *                  {@link Location} object processed, this method will return the current result of the processor.\n   * @param <R> Type of the return value\n   * @throws IOException if the locations could not be read\n   */\n  public static <R> R processLocations(Location startLocation, boolean recursive,\n                                       Processor<LocationStatus, R> processor) throws IOException {\n    // Becomes true after adding the locations under the startLocation to the processing stack\n    boolean firstPass = false;\n    boolean process;\n\n    LocationFactory locationFactory = startLocation.getLocationFactory();\n    if (locationFactory instanceof HDFSLocationFactory) {\n      // Treat the HDFS case\n      FileSystem fs = ((HDFSLocationFactory) locationFactory).getFileSystem();\n      Deque<FileStatus> statusStack = Lists.newLinkedList();\n      statusStack.push(fs.getFileLinkStatus(new Path(startLocation.toURI())));\n      while (!statusStack.isEmpty()) {\n        FileStatus currentStatus = statusStack.poll();\n        process = processor.process(new LocationStatus(currentStatus.getPath().toUri(), currentStatus.getLen(),\n                                                       currentStatus.isDirectory()));\n        if (!process) {\n          return processor.getResult();\n        }\n        if (currentStatus.isDirectory() && (!firstPass || recursive)) {\n          FileStatus[] statuses = fs.listStatus(currentStatus.getPath());\n          for (FileStatus status : statuses) {\n            statusStack.push(status);\n          }\n          firstPass = true;\n        }\n      }\n    } else {\n      // Treat the local FS case, we can directly use the Location class APIs\n      Deque<Location> locationStack = Lists.newLinkedList();\n      locationStack.push(startLocation);\n      while (!locationStack.isEmpty()) {\n        Location currentLocation = locationStack.poll();\n        process = processor.process(new LocationStatus(currentLocation.toURI(), currentLocation.length(),\n                                                       currentLocation.isDirectory()));\n        if (!process) {\n          return processor.getResult();\n        }\n        if (currentLocation.isDirectory() && (!firstPass || recursive)) {\n          List<Location> locations = currentLocation.list();\n          for (Location location : locations) {\n            locationStack.push(location);\n          }\n          firstPass = true;\n        }\n      }\n    }\n    return processor.getResult();\n  }","id":86724,"modified_method":"/**\n   * Do some processing on the locations contained in the {@code startLocation}, using the {@code processor}. If this\n   * location is a directory, all the locations contained in it will also be processed. If the {@code recursive} tag\n   * is set to true, those locations that are directories will also be processed recursively. If the\n   * {@code startLocation} is not a directory, this method will return the result of the processing of that location.\n   *\n   * @param startLocation location to start the processing from\n   * @param recursive {@code true} if this method should be called on the directory {@link Location}s found from\n   *                  {@code startLocation}. If the {@code startLocation} is a directory, all the locations under it\n   *                  will be processed, regardless of the value of {@code recursive}\n   * @param processor used to process locations. If the {@link Processor#process} method returns false on any\n   *                  {@link Location} object processed, this method will return the current result of the processor.\n   * @param <R> Type of the return value\n   * @throws IOException if the locations could not be read\n   */\n  public static <R> R processLocations(Location startLocation, boolean recursive,\n                                       Processor<LocationStatus, R> processor) throws IOException {\n    boolean topLevel = true;\n    LocationFactory lf = startLocation.getLocationFactory();\n    LinkedList<LocationStatus> statusStack = new LinkedList<>();\n    statusStack.push(getLocationStatus(startLocation));\n    while (!statusStack.isEmpty()) {\n      LocationStatus status = statusStack.poll();\n      if (!processor.process(status)) {\n        return processor.getResult();\n      }\n      if (status.isDir() && (topLevel || recursive)) {\n        topLevel = false;\n        RemoteIterator<LocationStatus> itor = listLocationStatus(lf.create(status.getUri()));\n        while (itor.hasNext()) {\n          statusStack.add(0, itor.next());\n        }\n      }\n    }\n    return processor.getResult();\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Creates a new {@link InputSupplier} that can provides {@link SeekableInputStream} from the given location.\n   *\n   * @param location Location for the input stream.\n   * @return A {@link InputSupplier}.\n   */\n  public static InputSupplier<? extends SeekableInputStream> newInputSupplier(final Location location) {\n    return new InputSupplier<SeekableInputStream>() {\n      @Override\n      public SeekableInputStream getInput() throws IOException {\n        InputStream input = location.getInputStream();\n        try {\n          if (input instanceof FileInputStream) {\n            return new FileSeekableInputStream((FileInputStream) input);\n          }\n          if (input instanceof FSDataInputStream) {\n            FSDataInputStream dataInput = (FSDataInputStream) input;\n            LocationFactory locationFactory = location.getLocationFactory();\n\n            // It should be HDFSLocationFactory\n            if (locationFactory instanceof HDFSLocationFactory) {\n              FileSystem fs = ((HDFSLocationFactory) locationFactory).getFileSystem();\n              return new DFSSeekableInputStream(dataInput,\n                                                createDFSStreamSizeProvider(fs, new Path(location.toURI()), dataInput));\n            } else {\n              // This shouldn't happen\n              return new DFSSeekableInputStream(dataInput, new StreamSizeProvider() {\n                @Override\n                public long size() throws IOException {\n                  // Assumption is if the FS is not a HDFS fs, the location length tells the stream size\n                  return location.length();\n                }\n              });\n            }\n          }\n\n          throw new IOException(\"Failed to create SeekableInputStream from location \" + location.toURI());\n        } catch (Throwable t) {\n          Closeables.closeQuietly(input);\n          Throwables.propagateIfInstanceOf(t, IOException.class);\n          throw new IOException(t);\n        }\n      }\n    };\n  }","id":86725,"modified_method":"/**\n   * Creates a new {@link InputSupplier} that can provides {@link SeekableInputStream} from the given location.\n   *\n   * @param location Location for the input stream.\n   * @return A {@link InputSupplier}.\n   */\n  public static InputSupplier<? extends SeekableInputStream> newInputSupplier(final Location location) {\n    return new InputSupplier<SeekableInputStream>() {\n      @Override\n      public SeekableInputStream getInput() throws IOException {\n        InputStream input = location.getInputStream();\n        try {\n          if (input instanceof FileInputStream) {\n            return new FileSeekableInputStream((FileInputStream) input);\n          }\n          if (input instanceof FSDataInputStream) {\n            FSDataInputStream dataInput = (FSDataInputStream) input;\n            LocationFactory locationFactory = location.getLocationFactory();\n\n            FileSystem fs = null;\n            if (locationFactory instanceof HDFSLocationFactory) {\n              fs = ((HDFSLocationFactory) locationFactory).getFileSystem();\n            } else if (locationFactory instanceof FileContextLocationFactory) {\n              final FileContextLocationFactory lf = (FileContextLocationFactory) locationFactory;\n              fs = lf.getFileContext().getUgi().doAs(new PrivilegedExceptionAction<FileSystem>() {\n                @Override\n                public FileSystem run() throws IOException {\n                  return FileSystem.get(lf.getConfiguration());\n                }\n              });\n            }\n\n            if (fs != null) {\n              return new DFSSeekableInputStream(dataInput,\n                                                createDFSStreamSizeProvider(fs, new Path(location.toURI()), dataInput));\n            }\n            // This shouldn't happen\n            return new DFSSeekableInputStream(dataInput, new StreamSizeProvider() {\n              @Override\n              public long size() throws IOException {\n                // Assumption is if the FS is not a HDFS fs, the location length tells the stream size\n                return location.length();\n              }\n            });\n          }\n\n          throw new IOException(\"Failed to create SeekableInputStream from location \" + location.toURI());\n        } catch (Throwable t) {\n          Closeables.closeQuietly(input);\n          Throwables.propagateIfInstanceOf(t, IOException.class);\n          throw new IOException(t);\n        }\n      }\n    };\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"private void refreshCredentials() {\n    try {\n      Credentials refreshedCredentials = new Credentials();\n\n      if (User.isHBaseSecurityEnabled(hConf)) {\n        HBaseTokenUtils.obtainToken(hConf, refreshedCredentials);\n      }\n\n      if (secureExplore) {\n        HiveTokenUtils.obtainToken(refreshedCredentials);\n        YarnTokenUtils.obtainToken(hConf, refreshedCredentials);\n        JobHistoryServerTokenUtils.obtainToken(hConf, refreshedCredentials);\n      }\n\n      YarnUtils.addDelegationTokens(hConf, locationFactory, refreshedCredentials);\n      credentials = refreshedCredentials;\n    } catch (IOException ioe) {\n      throw Throwables.propagate(ioe);\n    }\n  }","id":86726,"modified_method":"private void refreshCredentials() {\n    try {\n      Credentials refreshedCredentials = new Credentials();\n\n      if (User.isHBaseSecurityEnabled(hConf)) {\n        HBaseTokenUtils.obtainToken(hConf, refreshedCredentials);\n      }\n\n      if (secureExplore) {\n        HiveTokenUtils.obtainToken(refreshedCredentials);\n        YarnTokenUtils.obtainToken(hConf, refreshedCredentials);\n        JobHistoryServerTokenUtils.obtainToken(hConf, refreshedCredentials);\n      }\n\n      // Perform different logic to get delegation tokens based on the location factory type.\n      if (locationFactory instanceof HDFSLocationFactory) {\n        YarnUtils.addDelegationTokens(hConf, locationFactory, refreshedCredentials);\n      } else if (locationFactory instanceof FileContextLocationFactory) {\n        List<Token<?>> tokens = ((FileContextLocationFactory) locationFactory).getFileContext().getDelegationTokens(\n          new Path(locationFactory.getHomeLocation().toURI()), YarnUtils.getYarnTokenRenewer(hConf)\n        );\n        for (Token<?> token : tokens) {\n          refreshedCredentials.addToken(token.getService(), token);\n        }\n      }\n\n      credentials = refreshedCredentials;\n    } catch (IOException ioe) {\n      throw Throwables.propagate(ioe);\n    }\n  }","commit_id":"d9953a34f8da951828806629c193b2a39f1516ae","url":"https://github.com/caskdata/cdap"},{"original_method":"@SuppressWarnings(\"UnusedParameters\")\n  public ModelChangesWatcher(IMakeService ms, MessageBus bus, ProjectManager projectManager, VirtualFileManager virtualFileManager, LibraryManager libMan) {\n    myMakeService = ms;\n    myBus = bus;\n    myVirtualFileManager = virtualFileManager;\n    myProjectManager = projectManager;\n    myTimer = new Timer(\"Model Changes Watcher\", 50) {\n      protected void onTimer() throws InterruptedException {\n        synchronized (myLock) {\n          if (myReloadSession != null) {\n            doReload();\n          }\n        }\n        myTimer.suspend();\n      }\n    };\n    myTimer.setTakeInitialDelay(true);\n    myTimer.suspend();\n  }","id":86727,"modified_method":"public ModelChangesWatcher(MessageBus bus, ProjectManager projectManager, VirtualFileManager virtualFileManager) {\n    myBus = bus;\n    myVirtualFileManager = virtualFileManager;\n    myProjectManager = projectManager;\n    myTimer = new Timer(\"Model Changes Watcher\", 50) {\n      protected void onTimer() throws InterruptedException {\n        synchronized (myLock) {\n          if (myReloadSession != null) {\n            doReload();\n          }\n        }\n        myTimer.suspend();\n      }\n    };\n    myTimer.setTakeInitialDelay(true);\n    myTimer.suspend();\n  }","commit_id":"67fd9344d2020ff92c0e7ccc01bd51db319589ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent(boolean force) {\n    if (myConnection == null && (force || !(MPSCore.getInstance().isTestMode()))) {\n      myConnection = myBus.connect();\n      myConnection.subscribe(VirtualFileManager.VFS_CHANGES, myBusListener);\n      myVirtualFileManager.addVirtualFileManagerListener(myVirtualFileManagerListener);\n      myMakeService.addListener(myMakeListener);\n    }\n  }","id":86728,"modified_method":"public void initComponent(boolean force) {\n    if (myConnection == null && (force || !(MPSCore.getInstance().isTestMode()))) {\n      myConnection = myBus.connect();\n      myConnection.subscribe(VirtualFileManager.VFS_CHANGES, myBusListener);\n      myVirtualFileManager.addVirtualFileManagerListener(myVirtualFileManagerListener);\n    }\n  }","commit_id":"67fd9344d2020ff92c0e7ccc01bd51db319589ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeComponent() {\n    if (myConnection == null) {\n      return;\n    }\n    myMakeService.removeListener(myMakeListener);\n    myVirtualFileManager.removeVirtualFileManagerListener(myVirtualFileManagerListener);\n    myConnection.disconnect();\n    myConnection = null;\n  }","id":86729,"modified_method":"public void disposeComponent() {\n    if (myConnection == null) {\n      return;\n    }\n    if (myMakeService != null) {\n      myMakeService.removeListener(myMakeListener);\n      myMakeService = null;\n    }\n    myVirtualFileManager.removeVirtualFileManagerListener(myVirtualFileManagerListener);\n    myConnection.disconnect();\n    myConnection = null;\n  }","commit_id":"67fd9344d2020ff92c0e7ccc01bd51db319589ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeComponent() {\n    GenerationSettingsProvider.getInstance().setGenerationSettings(null);\n    pluginReloader.setMakeService(null);\n    IMakeService.INSTANCE.set(null);\n    INSTANCE = null;\n  }","id":86730,"modified_method":"public void disposeComponent() {\n    GenerationSettingsProvider.getInstance().setGenerationSettings(null);\n    watcher.setMakeService(null);\n    pluginReloader.setMakeService(null);\n    IMakeService.INSTANCE.set(null);\n    INSTANCE = null;\n  }","commit_id":"67fd9344d2020ff92c0e7ccc01bd51db319589ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"public WorkbenchMakeService(PluginReloader pluginReloader) {\n    this.pluginReloader = pluginReloader;\n  }","id":86731,"modified_method":"public WorkbenchMakeService(PluginReloader pluginReloader, ModelChangesWatcher watcher) {\n    this.pluginReloader = pluginReloader;\n    this.watcher = watcher;\n  }","commit_id":"67fd9344d2020ff92c0e7ccc01bd51db319589ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent() {\n    INSTANCE = this;\n    IMakeService.INSTANCE.set(this);\n    pluginReloader.setMakeService(this);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(GenerationSettings.getInstance());\n  }","id":86732,"modified_method":"public void initComponent() {\n    INSTANCE = this;\n    IMakeService.INSTANCE.set(this);\n    pluginReloader.setMakeService(this);\n    watcher.setMakeService(this);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(GenerationSettings.getInstance());\n  }","commit_id":"67fd9344d2020ff92c0e7ccc01bd51db319589ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeComponent() {\n    myClassLoaderManager.removeReloadHandler(myReloadListener);\n    myMakeService.removeListener(myMakeListener);\n  }","id":86733,"modified_method":"public void disposeComponent() {\n    myClassLoaderManager.removeReloadHandler(myReloadListener);\n    if (myMakeService != null) {\n      myMakeService.removeListener(myMakeListener);\n      this.myMakeService = null;\n    }\n  }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void load() {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          //write action is needed the because user can acquire write action inside of this [see MPS-9139]\n          loadPlugins();\n        }\n      };\n      if (myLoadPluginsRunnable.compareAndSet(null, runnable)) {\n        if (!myMakeService.isSessionActive()) {\n          myLoadPluginsRunnable.set(null);\n          ModelAccess.instance().runWriteInEDT(runnable);\n        }\n      }\n    }","id":86734,"modified_method":"public void load() {\n      Runnable runnable = new Runnable() {\n        public void run() {\n          //write action is needed the because user can acquire write action inside of this [see MPS-9139]\n          loadPlugins();\n        }\n      };\n      if (myLoadPluginsRunnable.compareAndSet(null, runnable)) {\n        if (myMakeService == null || !myMakeService.isSessionActive()) {\n          myLoadPluginsRunnable.set(null);\n          ModelAccess.instance().runWriteInEDT(runnable);\n        }\n      }\n    }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"@SuppressWarnings({\"UnusedDeclaration\"})\n  public PluginReloader(ClassLoaderManager classLoaderManager, ProjectManager projectManager, ApplicationPluginManager pluginManager, IMakeService makeService) {\n    myClassLoaderManager = classLoaderManager;\n    myProjectManager = projectManager;\n    myPluginManager = pluginManager;\n    myMakeService = makeService;\n  }","id":86735,"modified_method":"@SuppressWarnings({\"UnusedDeclaration\"})\n  public PluginReloader(ClassLoaderManager classLoaderManager, ProjectManager projectManager, ApplicationPluginManager pluginManager) {\n    myClassLoaderManager = classLoaderManager;\n    myProjectManager = projectManager;\n    myPluginManager = pluginManager;\n  }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent() {\n    myClassLoaderManager.addReloadHandler(myReloadListener);\n    myMakeService.addListener(myMakeListener);\n  }","id":86736,"modified_method":"public void initComponent() {\n    myClassLoaderManager.addReloadHandler(myReloadListener);\n  }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public WorkbenchMakeService(IOperationContext context, boolean cleanMake) {\n    this.currentSessionStickyMark.set(new MakeSession(context, new WorkbenchMakeService.MessageHandler(\"Make\", context), cleanMake), false);\n  }","id":86737,"modified_method":"public WorkbenchMakeService(PluginReloader pluginReloader) {\n    this.pluginReloader = pluginReloader;\n  }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeComponent() {\n    INSTANCE = null;\n  }","id":86738,"modified_method":"public void disposeComponent() {\n    INSTANCE = null;\n    pluginReloader.setMakeService(null);\n  }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent() {\n    INSTANCE = this;\n  }","id":86739,"modified_method":"public void initComponent() {\n    INSTANCE = this;\n    pluginReloader.setMakeService(this);\n  }","commit_id":"cd56ca567d484c92dedbef4ec12bd07fc97f6681","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void flushCache(XWikiContext context)\n    {\n        Utils.getComponent(ObservationManager.class).removeListener(this.indexUpdater.getName());\n\n        this.indexRebuilder = null;\n\n        try {\n            // set the thread to exit\n            this.indexUpdater.doExit();\n            // wait for the thread to finish\n            this.indexUpdaterThread.join();\n        } catch (InterruptedException ex) {\n            LOG.warn(\"Error while waiting for indexUpdaterThread to die.\", ex);\n        }\n\n        try {\n            closeSearchers(this.searchers);\n        } catch (IOException e) {\n            LOG.warn(\"cannot close searchers\", e);\n        }\n\n        this.indexUpdater = null;\n        this.analyzer = null;\n\n        init(context);\n    }","id":86740,"modified_method":"public void flushCache(XWikiContext context)\n    {\n        if (this.indexUpdater != null) {\n            Utils.getComponent(ObservationManager.class).removeListener(this.indexUpdater.getName());\n\n            // set the thread to exit\n            this.indexUpdater.doExit();\n        }\n\n        this.indexRebuilder = null;\n\n        try {\n            // wait for the thread to finish\n            this.indexUpdaterThread.join();\n        } catch (InterruptedException ex) {\n            LOG.warn(\"Error while waiting for indexUpdaterThread to die.\", ex);\n        }\n\n        try {\n            closeSearchers(this.searchers);\n        } catch (IOException e) {\n            LOG.warn(\"cannot close searchers\", e);\n        }\n\n        this.indexUpdater = null;\n        this.analyzer = null;\n\n        init(context);\n    }","commit_id":"7b643cb282ee5018eec7c1a93c38235889c5aeb9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public synchronized void init(XWikiContext context)\n    {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"lucene plugin: in init\");\n        }\n        this.config = context.getWiki().getConfig();\n\n        this.indexDirs = this.config.getProperty(PROP_INDEX_DIR);\n        if (StringUtils.isEmpty(this.indexDirs)) {\n            File workDir = context.getWiki().getWorkSubdirectory(\"lucene\", context);\n            this.indexDirs = workDir.getAbsolutePath();\n        }\n        String indexDir = StringUtils.split(this.indexDirs, \",\")[0];\n\n        File f = new File(indexDir);\n        Directory directory;\n        try {\n            if (!f.exists()) {\n                f.mkdirs();\n            }\n            directory = FSDirectory.open(f);\n        } catch (IOException e) {\n            LOG.error(\"Failed to open the index directory: \" + e);\n            throw new RuntimeException(e);\n        }\n\n        init(directory, context);\n    }","id":86741,"modified_method":"public synchronized void init(XWikiContext context)\n    {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"lucene plugin: in init\");\n        }\n\n        this.config = context.getWiki().getConfig();\n\n        this.indexDirs = this.config.getProperty(PROP_INDEX_DIR);\n        if (StringUtils.isEmpty(this.indexDirs)) {\n            File workDir = context.getWiki().getWorkSubdirectory(\"lucene\", context);\n            this.indexDirs = workDir.getAbsolutePath();\n        }\n        String indexDir = StringUtils.split(this.indexDirs, \",\")[0];\n\n        File f = new File(indexDir);\n        Directory directory;\n        try {\n            if (!f.exists()) {\n                f.mkdirs();\n            }\n            directory = FSDirectory.open(f);\n        } catch (IOException e) {\n            LOG.error(\"Failed to open the index directory: \", e);\n            throw new RuntimeException(e);\n        }\n\n        init(directory, context);\n    }","commit_id":"7b643cb282ee5018eec7c1a93c38235889c5aeb9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Opens the searchers for the configured index Dirs after closing any already existing ones.\n     */\n    protected synchronized void openSearchers(XWikiContext context)\n    {\n        try {\n            closeSearchers(this.searchers);\n            this.searchers = createSearchers(this.indexDirs, context);\n        } catch (Exception e1) {\n            LOG.error(\"error opening searchers for index dirs \" + config.getProperty(PROP_INDEX_DIR), e1);\n            throw new RuntimeException(\"error opening searchers for index dirs \" + config.getProperty(PROP_INDEX_DIR),\n                e1);\n        }\n    }","id":86742,"modified_method":"/**\n     * Opens the searchers for the configured index Dirs after closing any already existing ones.\n     */\n    protected synchronized void openSearchers(XWikiContext context)\n    {\n        try {\n            closeSearchers(this.searchers);\n            this.searchers = createSearchers(this.indexDirs, context);\n        } catch (Exception e) {\n            LOG.error(\"error opening searchers for index dirs \" + config.getProperty(PROP_INDEX_DIR), e);\n            throw new RuntimeException(\"error opening searchers for index dirs \" + config.getProperty(PROP_INDEX_DIR),\n                e);\n        }\n    }","commit_id":"7b643cb282ee5018eec7c1a93c38235889c5aeb9","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n  public void close() {\n    if (myEditorController != null) {\n      myEditorController.getSelection().revisionProperty().removeListener(mySelectionListener);\n      myEditorController.getJobManager().revisionProperty().removeListener(myListener);\n    }\n  }","id":86743,"modified_method":"@Override\n  public void close() {\n    if (myEditorController != null) {\n      if (mySelectionListener != null) {\n        myEditorController.getSelection().revisionProperty().removeListener(mySelectionListener);\n      }\n      if (myListener != null) {\n        myEditorController.getJobManager().revisionProperty().removeListener(myListener);\n      }\n    }\n  }","commit_id":"3e9eae3b52f80e41769931ffcdaad06badd3c4ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Configuration findExistingConfiguration(String pid, String factoryPid) throws Exception\n    {\n        String suffix = factoryPid == null ? \".cfg\" : \"-\" + factoryPid + \".cfg\";\n\n        String filter = \"(\" + DirectoryWatcher.FILENAME + \"=\" + pid + suffix + \")\";\n        Configuration[] configurations = getConfigurationAdmin().listConfigurations(filter);\n        if (configurations != null && configurations.length > 0)\n        {\n            return configurations[0];\n        }\n        else\n        {\n            return null;\n        }\n    }","id":86744,"modified_method":"Configuration findExistingConfiguration(String fileName) throws Exception\n    {\n        String filter = \"(\" + DirectoryWatcher.FILENAME + \"=\" + fileName + \")\";\n        Configuration[] configurations = getConfigurationAdmin().listConfigurations(filter);\n        if (configurations != null && configurations.length > 0)\n        {\n            return configurations[0];\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Remove the configuration.\n     *\n     * @param f\n     *            File where the configuration in whas defined.\n     * @return\n     * @throws Exception\n     */\n    boolean deleteConfig(File f) throws Exception\n    {\n        String pid[] = parsePid(f.getName());\n        Configuration config = getConfiguration(pid[0], pid[1]);\n        config.delete();\n        return true;\n    }","id":86745,"modified_method":"/**\n     * Remove the configuration.\n     *\n     * @param f\n     *            File where the configuration in whas defined.\n     * @return\n     * @throws Exception\n     */\n    boolean deleteConfig(File f) throws Exception\n    {\n        String pid[] = parsePid(f.getName());\n        Configuration config = getConfiguration(f.getAbsolutePath(), pid[0], pid[1]);\n        config.delete();\n        return true;\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Set the configuration based on the config file.\n     *\n     * @param f\n     *            Configuration file\n     * @return\n     * @throws Exception\n     */\n    boolean setConfig(final File f) throws Exception\n    {\n        final Hashtable ht = new Hashtable();\n        final InputStream in = new BufferedInputStream(new FileInputStream(f));\n        try\n        {\n            if ( f.getName().endsWith(\".cfg\") )\n            {\n                final Properties p = new Properties();\n                in.mark(1);\n                boolean isXml = in.read() == '<';\n                in.reset();\n                if (isXml) {\n                    p.loadFromXML(in);\n                } else {\n                    p.load(in);\n                }\n                Util.performSubstitution(p);\n                ht.putAll(p);\n            }\n            else\n            {\n                final Dictionary config = ConfigurationHandler.read(in);\n                final Enumeration i = config.keys();\n                while ( i.hasMoreElements() )\n                {\n                    final Object key = i.nextElement();\n                    ht.put(key, config.get(key));\n                }\n            }\n        }\n        finally\n        {\n            in.close();\n        }\n\n        String pid[] = parsePid(f.getName());\n        ht.put(DirectoryWatcher.FILENAME, f.getName());\n        Configuration config = getConfiguration(pid[0], pid[1]);\n        if (config.getBundleLocation() != null)\n        {\n            config.setBundleLocation(null);\n        }\n        config.update(ht);\n        return true;\n    }","id":86746,"modified_method":"/**\n     * Set the configuration based on the config file.\n     *\n     * @param f\n     *            Configuration file\n     * @return\n     * @throws Exception\n     */\n    boolean setConfig(final File f) throws Exception\n    {\n        final Hashtable ht = new Hashtable();\n        final InputStream in = new BufferedInputStream(new FileInputStream(f));\n        try\n        {\n            if ( f.getName().endsWith( \".cfg\" ) )\n            {\n                final Properties p = new Properties();\n                in.mark(1);\n                boolean isXml = in.read() == '<';\n                in.reset();\n                if (isXml) {\n                    p.loadFromXML(in);\n                } else {\n                    p.load(in);\n                }\n                InterpolationHelper.performSubstitution((Map) p);\n                ht.putAll(p);\n            }\n            else if ( f.getName().endsWith( \".config\" ) )\n            {\n                final Dictionary config = ConfigurationHandler.read(in);\n                final Enumeration i = config.keys();\n                while ( i.hasMoreElements() )\n                {\n                    final Object key = i.nextElement();\n                    ht.put(key, config.get(key));\n                }\n            }\n        }\n        finally\n        {\n            in.close();\n        }\n\n        String pid[] = parsePid(f.getName());\n        ht.put(DirectoryWatcher.FILENAME, f.getAbsolutePath());\n        Configuration config = getConfiguration(f.getAbsolutePath(), pid[0], pid[1]);\n        if (config.getBundleLocation() != null)\n        {\n            config.setBundleLocation(null);\n        }\n        config.update(ht);\n        return true;\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"Configuration getConfiguration(String pid, String factoryPid)\n        throws Exception\n    {\n        Configuration oldConfiguration = findExistingConfiguration(pid, factoryPid);\n        if (oldConfiguration != null)\n        {\n            Util.log(context, Util.getGlobalLogLevel(context),\n                Logger.LOG_DEBUG, \"Updating configuration from \" + pid\n                + (factoryPid == null ? \"\" : \"-\" + factoryPid) + \".cfg\", null);\n            return oldConfiguration;\n        }\n        else\n        {\n            Configuration newConfiguration;\n            if (factoryPid != null)\n            {\n                newConfiguration = getConfigurationAdmin().createFactoryConfiguration(pid, null);\n            }\n            else\n            {\n                newConfiguration = getConfigurationAdmin().getConfiguration(pid, null);\n            }\n            return newConfiguration;\n        }\n    }","id":86747,"modified_method":"Configuration getConfiguration(String fileName, String pid, String factoryPid)\n        throws Exception\n    {\n        Configuration oldConfiguration = findExistingConfiguration(fileName);\n        if (oldConfiguration != null)\n        {\n            Util.log(context, Util.getGlobalLogLevel(context),\n                Logger.LOG_DEBUG, \"Updating configuration from \" + pid\n                + (factoryPid == null ? \"\" : \"-\" + factoryPid) + \".cfg\", null);\n            return oldConfiguration;\n        }\n        else\n        {\n            Configuration newConfiguration;\n            if (factoryPid != null)\n            {\n                newConfiguration = getConfigurationAdmin().createFactoryConfiguration(pid, null);\n            }\n            else\n            {\n                newConfiguration = getConfigurationAdmin().getConfiguration(pid, null);\n            }\n            return newConfiguration;\n        }\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"public void testGetExistentFactoryConfiguration() throws Exception\n    {\n        mockConfigurationControl.replay();\n        mockConfigurationAdmin.listConfigurations( null );\n        mockConfigurationAdminControl.setMatcher( MockControl.ALWAYS_MATCHER );\n        mockConfigurationAdminControl.setReturnValue( null );\n        mockConfigurationAdmin.createFactoryConfiguration( \"pid\", null );\n        mockConfigurationAdminControl.setReturnValue( mockConfiguration );\n        mockConfigurationAdminControl.replay();\n        mockBundleContextControl.replay();\n\n        ConfigInstaller ci = new ConfigInstaller( mockBundleContext, mockConfigurationAdmin );\n\n        assertEquals( \"Factory configuration retrieved\", mockConfiguration, ci.getConfiguration( \"pid\", \"factoryPid\" ) );\n\n        mockConfigurationAdminControl.verify();\n        mockConfigurationControl.verify();\n        mockBundleContextControl.verify();\n    }","id":86748,"modified_method":"public void testGetExistentFactoryConfiguration() throws Exception\n    {\n        mockConfigurationControl.replay();\n        mockConfigurationAdmin.listConfigurations( null );\n        mockConfigurationAdminControl.setMatcher( MockControl.ALWAYS_MATCHER );\n        mockConfigurationAdminControl.setReturnValue( null );\n        mockConfigurationAdmin.createFactoryConfiguration( \"pid\", null );\n        mockConfigurationAdminControl.setReturnValue( mockConfiguration );\n        mockConfigurationAdminControl.replay();\n        mockBundleContextControl.replay();\n\n        ConfigInstaller ci = new ConfigInstaller( mockBundleContext, mockConfigurationAdmin );\n\n        assertEquals( \"Factory configuration retrieved\", mockConfiguration, ci.getConfiguration( \"pid-factoryPid.cfg\",\"pid\", \"factoryPid\" ) );\n\n        mockConfigurationAdminControl.verify();\n        mockConfigurationControl.verify();\n        mockBundleContextControl.verify();\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"public void testGetExistentNoFactoryConfiguration() throws Exception\n    {\n        mockConfigurationControl.replay();\n        mockConfigurationAdmin.listConfigurations( null );\n        mockConfigurationAdminControl.setMatcher( MockControl.ALWAYS_MATCHER );\n        mockConfigurationAdminControl.setReturnValue( null );\n        mockConfigurationAdmin.getConfiguration( \"pid\", null );\n        mockConfigurationAdminControl.setReturnValue( mockConfiguration );\n        mockConfigurationAdminControl.replay();\n        mockBundleContextControl.replay();\n\n        ConfigInstaller ci = new ConfigInstaller( mockBundleContext, mockConfigurationAdmin );\n\n        assertEquals( \"Factory configuration retrieved\", mockConfiguration, ci.getConfiguration( \"pid\", null ) );\n\n        mockConfigurationAdminControl.verify();\n        mockConfigurationControl.verify();\n        mockBundleContextControl.verify();\n    }","id":86749,"modified_method":"public void testGetExistentNoFactoryConfiguration() throws Exception\n    {\n        mockConfigurationControl.replay();\n        mockConfigurationAdmin.listConfigurations( null );\n        mockConfigurationAdminControl.setMatcher( MockControl.ALWAYS_MATCHER );\n        mockConfigurationAdminControl.setReturnValue( null );\n        mockConfigurationAdmin.getConfiguration( \"pid\", null );\n        mockConfigurationAdminControl.setReturnValue( mockConfiguration );\n        mockConfigurationAdminControl.replay();\n        mockBundleContextControl.replay();\n\n        ConfigInstaller ci = new ConfigInstaller( mockBundleContext, mockConfigurationAdmin );\n\n        assertEquals( \"Factory configuration retrieved\", mockConfiguration, ci.getConfiguration( \"pid.cfg\", \"pid\", null ) );\n\n        mockConfigurationAdminControl.verify();\n        mockConfigurationControl.verify();\n        mockBundleContextControl.verify();\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"public void testGetNewFactoryConfiguration() throws Exception\n    {\n        mockConfigurationControl.replay();\n        mockConfigurationAdmin.listConfigurations( null );\n        mockConfigurationAdminControl.setMatcher( MockControl.ALWAYS_MATCHER );\n        mockConfigurationAdminControl.setReturnValue( null );\n        mockConfigurationAdmin.createFactoryConfiguration( \"pid\", null );\n        mockConfigurationAdminControl.setReturnValue( mockConfiguration );\n        mockConfigurationAdminControl.replay();\n        mockBundleContextControl.replay();\n\n        ConfigInstaller ci = new ConfigInstaller( mockBundleContext, mockConfigurationAdmin );\n\n        assertEquals( \"Factory configuration retrieved\", mockConfiguration, ci.getConfiguration( \"pid\", \"factoryPid\" ) );\n\n        mockConfigurationAdminControl.verify();\n        mockConfigurationControl.verify();\n        mockBundleContextControl.verify();\n    }","id":86750,"modified_method":"public void testGetNewFactoryConfiguration() throws Exception\n    {\n        mockConfigurationControl.replay();\n        mockConfigurationAdmin.listConfigurations( null );\n        mockConfigurationAdminControl.setMatcher( MockControl.ALWAYS_MATCHER );\n        mockConfigurationAdminControl.setReturnValue( null );\n        mockConfigurationAdmin.createFactoryConfiguration( \"pid\", null );\n        mockConfigurationAdminControl.setReturnValue( mockConfiguration );\n        mockConfigurationAdminControl.replay();\n        mockBundleContextControl.replay();\n\n        ConfigInstaller ci = new ConfigInstaller( mockBundleContext, mockConfigurationAdmin );\n\n        assertEquals( \"Factory configuration retrieved\", mockConfiguration, ci.getConfiguration( \"pid-factoryPid.cfg\", \"pid\", \"factoryPid\" ) );\n\n        mockConfigurationAdminControl.verify();\n        mockConfigurationControl.verify();\n        mockBundleContextControl.verify();\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"public Object addingService(ServiceReference serviceReference)\n            {\n                ConfigurationAdmin cm = (ConfigurationAdmin) super.addingService(serviceReference);\n                configInstaller = new ConfigInstaller(context, cm);\n                fileInstall.addListener(configInstaller);\n                return cm;\n            }","id":86751,"modified_method":"public Object addingService(ServiceReference serviceReference)\n            {\n                ConfigurationAdmin cm = (ConfigurationAdmin) super.addingService(serviceReference);\n                configInstaller = new ConfigInstaller(context, cm);\n                configInstaller.init();\n                fileInstall.addListener(configInstaller);\n                return cm;\n            }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"public void updated(String pid, Dictionary properties)\n    {\n        Util.performSubstitution(properties);\n        DirectoryWatcher watcher = null;\n        synchronized (watchers)\n        {\n            watcher = (DirectoryWatcher) watchers.get(pid);\n            if (watcher != null && watcher.getProperties().equals(properties))\n            {\n                return;\n            }\n        }\n        if (watcher != null)\n        {\n            watcher.close();\n        }\n        watcher = new DirectoryWatcher(properties, context);\n        synchronized (watchers)\n        {\n            watchers.put(pid, watcher);\n        }\n        watcher.start();\n    }","id":86752,"modified_method":"public void updated(String pid, Dictionary properties)\n    {\n        InterpolationHelper.performSubstitution(new DictionaryAsMap(properties));\n        DirectoryWatcher watcher = null;\n        synchronized (watchers)\n        {\n            watcher = (DirectoryWatcher) watchers.get(pid);\n            if (watcher != null && watcher.getProperties().equals(properties))\n            {\n                return;\n            }\n        }\n        if (watcher != null)\n        {\n            watcher.close();\n        }\n        watcher = new DirectoryWatcher(properties, context);\n        synchronized (watchers)\n        {\n            watchers.put(pid, watcher);\n        }\n        watcher.start();\n    }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"public void removedService(ServiceReference serviceReference, Object o)\n            {\n                configInstaller = null;\n                fileInstall.removeListener(configInstaller);\n                super.removedService(serviceReference, o);\n            }","id":86753,"modified_method":"public void removedService(ServiceReference serviceReference, Object o)\n            {\n                if (configInstaller != null)\n                {\n                    configInstaller.destroy();\n                    fileInstall.removeListener(configInstaller);\n                    configInstaller = null;\n                }\n                super.removedService(serviceReference, o);\n            }","commit_id":"3d144cda088b054f7446d505fd3e80db4728533e","url":"https://github.com/apache/felix"},{"original_method":"private void stopImpl() {\n    if (myStopped) return;\n\n    myDebugProcess.stop();\n    myCurrentPosition = null;\n    myCurrentExecutionStack = null;\n    myCurrentStackFrame = null;\n    mySuspendContext = null;\n    myDebuggerManager.setActiveSession(this, null, false, null);\n    if (breakpointsInitialized) {\n      XBreakpointManagerImpl breakpointManager = myDebuggerManager.getBreakpointManager();\n      breakpointManager.removeBreakpointListener(myBreakpointListener);\n      breakpointManager.getDependentBreakpointManager().removeListener(myDependentBreakpointListener);\n    }\n    myStopped = true;\n    myDebuggerManager.removeSession(this);\n    myDispatcher.getMulticaster().sessionStopped();\n  }","id":86754,"modified_method":"private void stopImpl() {\n    if (myStopped) return;\n\n    myDebugProcess.stop();\n    myCurrentPosition = null;\n    myCurrentExecutionStack = null;\n    myCurrentStackFrame = null;\n    mySuspendContext = null;\n    myDebuggerManager.setActiveSession(this, null, false, null);\n    if (breakpointsInitialized) {\n      XBreakpointManagerImpl breakpointManager = myDebuggerManager.getBreakpointManager();\n      if (myBreakpointListener != null) {\n        breakpointManager.removeBreakpointListener(myBreakpointListener);\n      }\n      if (myDependentBreakpointListener != null) {\n        breakpointManager.getDependentBreakpointManager().removeListener(myDependentBreakpointListener);\n      }\n    }\n    myStopped = true;\n    myDebuggerManager.removeSession(this);\n    myDispatcher.getMulticaster().sessionStopped();\n  }","commit_id":"ebece422fb8a7410beeae0b1830a0102e2f3208b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void info(final String componentId, PrintWriter out)\n    {\n        Collection<ComponentDescriptionDTO> components = getComponentFromArg(componentId);\n        if (components == null)\n        {\n            return;\n        }\n\n        Collections.sort( new ArrayList<ComponentDescriptionDTO>(components), new Comparator<ComponentDescriptionDTO>()\n                {\n\n                    public int compare(ComponentDescriptionDTO c1, ComponentDescriptionDTO c2)\n                    {\n                        long bundleId1 = c1.bundle.id;\n                        long bundleId2 = c2.bundle.id;\n                        int result = Long.signum(bundleId1 - bundleId2);\n                        if ( result == 0)\n                        {\n                            result = c1.name.compareTo(c2.name);\n                        }\n                        return result;\n                    }\n\n                });\n\n        long bundleId = -1;\n\n        for ( ComponentDescriptionDTO component : components )\n        {\n            if ( component.bundle.id != bundleId )\n            {\n                if ( bundleId != -1 )\n                {\n                    out.println();\n                    out.println();\n                }\n                bundleId = component.bundle.id;\n                out.println(String.format(\"*** Bundle: %1$s (%2$d)\", component.bundle.symbolicName, bundleId));\n            }\n            out.println( \"Component Description:\");\n            out.print( \"  Name: \" );\n            out.println( component.name );\n            out.print( \"  Default State: \" );\n            out.println( component.defaultEnabled ? \"enabled\" : \"disabled\" );\n            out.print( \"  Activation: \" );\n            out.println( component.immediate ? \"immediate\" : \"delayed\" );\n\n            // DS 1.1 new features\n            out.print( \"  Configuration Policy: \" );\n            out.println( component.configurationPolicy );\n            out.print( \"  Activate Method: \" );\n            out.print( component.activate );\n            out.println();\n            out.print( \"  Deactivate Method: \" );\n            out.print( component.deactivate );\n            out.println();\n            out.print( \"  Modified Method: \" );\n            if ( component.modified != null )\n            {\n                out.print( component.modified );\n            }\n            else\n            {\n                out.print( \"-\" );\n            }\n            out.println();\n\n            out.print( \"  Configuration Pid: \" );\n            out.print( Arrays.asList(component.configurationPid) );\n            out.println();\n\n            if ( component.factory != null )\n            {\n                out.print( \"  Factory: \" );\n                out.println( component.factory );\n            }\n\n            String[] services = component.serviceInterfaces;\n            if ( services != null )\n            {\n                out.print( \"  Services: \" );\n                for ( String service: services )\n                {\n                    out.print( \"          \" );\n                    out.println( service );\n                }\n                out.print( \"  Service Scope: \" );\n                out.println( component.scope );\n            }\n\n            ReferenceDTO[] refs = component.references;\n            if ( refs != null )\n            {\n                for ( ReferenceDTO ref : refs )\n                {\n                    out.print( \"  Reference: \" );\n                    out.println( ref.name );\n                    out.print( \"    Interface Name: \" );\n                    out.println( ref.interfaceName );\n                    if ( ref.target != null )\n                    {\n                        out.print( \"    Target Filter: \" );\n                        out.println( ref.target );\n                    }\n                    out.print( \"    Cardinality: \" );\n                    out.println( ref.cardinality );\n                    out.print( \"    Policy: \" );\n                    out.println( ref.policy );\n                    out.print( \"    Policy option: \" );\n                    out.println( ref.policyOption );\n                    out.print( \"    Reference Scope: \");\n                    out.println( ref.scope);\n\n                }\n            }\n\n            Map<String, Object> props = component.properties;\n            propertyInfo(props, out, \"\");\n            for (ComponentConfigurationDTO cc: scrService.getComponentConfigurationDTOs(component))\n            {\n                info(cc, out);\n            }\n        }\n\n        out.flush();\n    }","id":86755,"modified_method":"/**\n     * @see org.apache.felix.scr.impl.ScrInfo#info(java.lang.String, java.io.PrintStream, java.io.PrintStream)\n     */\n    public void info(final String componentId, final PrintWriter out)\n    {\n        final Result result = getComponentsFromArg(componentId, false);\n        if (result.components.isEmpty())\n        {\n            return;\n        }\n\n        Collections.sort( new ArrayList<ComponentDescriptionDTO>(result.components), new Comparator<ComponentDescriptionDTO>()\n                {\n\n                    public int compare(final ComponentDescriptionDTO c1, final ComponentDescriptionDTO c2)\n                    {\n                        final long bundleId1 = c1.bundle.id;\n                        final long bundleId2 = c2.bundle.id;\n                        int result = Long.signum(bundleId1 - bundleId2);\n                        if ( result == 0)\n                        {\n                            result = c1.name.compareTo(c2.name);\n                        }\n                        return result;\n                    }\n\n                });\n\n        long bundleId = -1;\n\n        for ( ComponentDescriptionDTO component : result.components )\n        {\n            if ( component.bundle.id != bundleId )\n            {\n                if ( bundleId != -1 )\n                {\n                    out.println();\n                    out.println();\n                }\n                bundleId = component.bundle.id;\n                out.println(String.format(\"*** Bundle: %1$s (%2$d)\", component.bundle.symbolicName, bundleId));\n            }\n            out.println( \"Component Description:\");\n            out.print( \"  Name: \" );\n            out.println( component.name );\n            out.print( \"  Default State: \" );\n            out.println( component.defaultEnabled ? \"enabled\" : \"disabled\" );\n            out.print( \"  Activation: \" );\n            out.println( component.immediate ? \"immediate\" : \"delayed\" );\n\n            // DS 1.1 new features\n            out.print( \"  Configuration Policy: \" );\n            out.println( component.configurationPolicy );\n            out.print( \"  Activate Method: \" );\n            out.print( component.activate );\n            out.println();\n            out.print( \"  Deactivate Method: \" );\n            out.print( component.deactivate );\n            out.println();\n            out.print( \"  Modified Method: \" );\n            if ( component.modified != null )\n            {\n                out.print( component.modified );\n            }\n            else\n            {\n                out.print( \"-\" );\n            }\n            out.println();\n\n            out.print( \"  Configuration Pid: \" );\n            out.print( Arrays.asList(component.configurationPid) );\n            out.println();\n\n            if ( component.factory != null )\n            {\n                out.print( \"  Factory: \" );\n                out.println( component.factory );\n            }\n\n            String[] services = component.serviceInterfaces;\n            if ( services != null )\n            {\n                out.print( \"  Services: \" );\n                for ( String service: services )\n                {\n                    out.print( \"          \" );\n                    out.println( service );\n                }\n                out.print( \"  Service Scope: \" );\n                out.println( component.scope );\n            }\n\n            ReferenceDTO[] refs = component.references;\n            if ( refs != null )\n            {\n                for ( ReferenceDTO ref : refs )\n                {\n                    out.print( \"  Reference: \" );\n                    out.println( ref.name );\n                    out.print( \"    Interface Name: \" );\n                    out.println( ref.interfaceName );\n                    if ( ref.target != null )\n                    {\n                        out.print( \"    Target Filter: \" );\n                        out.println( ref.target );\n                    }\n                    out.print( \"    Cardinality: \" );\n                    out.println( ref.cardinality );\n                    out.print( \"    Policy: \" );\n                    out.println( ref.policy );\n                    out.print( \"    Policy option: \" );\n                    out.println( ref.policyOption );\n                    out.print( \"    Reference Scope: \");\n                    out.println( ref.scope);\n\n                }\n            }\n\n            Map<String, Object> props = component.properties;\n            propertyInfo(props, out, \"\");\n            if ( result.configuration != null )\n            {\n                info(result.configuration, out);\n            }\n            else\n            {\n                for (final ComponentConfigurationDTO cc: scrService.getComponentConfigurationDTOs(component))\n                {\n                    info(cc, out);\n                }\n            }\n        }\n\n        out.flush();\n    }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"public void config(PrintWriter out)\n    {\n        out.print(\"Log Level: \");\n        out.println(scrConfiguration.getLogLevel());\n        out.print(\"Obsolete Component Factory with Factory Configuration: \");\n        out.println(scrConfiguration.isFactoryEnabled() ? \"Supported\" : \"Unsupported\");\n        out.print(\"Keep instances with no references: \");\n        out.println(scrConfiguration.keepInstances() ? \"Supported\" : \"Unsupported\");\n        out.print(\"Lock timeount milliseconds: \");\n        out.println(scrConfiguration.lockTimeout());\n        out.print(\"Stop timeount milliseconds: \");\n        out.println(scrConfiguration.stopTimeout());\n        out.print(\"Global extender: \");\n        out.println(scrConfiguration.globalExtender());\n        out.print(\"Info Service registered: \");\n        out.println(scrConfiguration.infoAsService() ? \"Supported\" : \"Unsupported\");\n    }","id":86756,"modified_method":"/**\n     * @see org.apache.felix.scr.impl.ScrInfo#config(java.io.PrintStream)\n     */\n    public void config(final PrintWriter out)\n    {\n        out.print(\"Log Level: \");\n        out.println(scrConfiguration.getLogLevel());\n        out.print(\"Obsolete Component Factory with Factory Configuration: \");\n        out.println(scrConfiguration.isFactoryEnabled() ? \"Supported\" : \"Unsupported\");\n        out.print(\"Keep instances with no references: \");\n        out.println(scrConfiguration.keepInstances() ? \"Supported\" : \"Unsupported\");\n        out.print(\"Lock timeount milliseconds: \");\n        out.println(scrConfiguration.lockTimeout());\n        out.print(\"Stop timeount milliseconds: \");\n        out.println(scrConfiguration.stopTimeout());\n        out.print(\"Global extender: \");\n        out.println(scrConfiguration.globalExtender());\n        out.print(\"Info Service registered: \");\n        out.println(scrConfiguration.infoAsService() ? \"Supported\" : \"Unsupported\");\n        out.flush();\n    }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"private String toStateString(int state)\n    {\n        switch (state) {\n\n        case (ComponentConfigurationDTO.UNSATISFIED_REFERENCE):\n            return \"unsatisfied reference\";\n        case (ComponentConfigurationDTO.ACTIVE):\n            return \"active      \";\n        case (ComponentConfigurationDTO.SATISFIED):\n            return \"satisfied  \";\n        default:\n            return \"unkown: \" + state;\n        }\n    }","id":86757,"modified_method":"private String toStateString(final int state)\n    {\n        switch (state)\n        {\n\n        case (ComponentConfigurationDTO.UNSATISFIED_REFERENCE):\n            return \"unsatisfied reference\";\n        case (ComponentConfigurationDTO.ACTIVE):\n            return \"active      \";\n        case (ComponentConfigurationDTO.SATISFIED):\n            return \"satisfied   \";\n        case (ComponentConfigurationDTO.UNSATISFIED_CONFIGURATION):\n            return \"unsatisfied config\";\n        default:\n            return \"unkown: \" + state;\n        }\n    }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"void change(final String componentIdentifier, PrintWriter out, boolean enable)\n    {\n        Collection<ComponentDescriptionDTO> components = getComponentFromArg(componentIdentifier);\n        ArrayList<String> disposed = new ArrayList<String>();\n        if (components == null)\n        {\n            return;\n        }\n\n        for ( ComponentDescriptionDTO component : components )\n        {\n            if ( enable )\n            {\n                if ( !scrService.isComponentEnabled(component) )\n                {\n                    scrService.enableComponent(component);\n                    out.println( \"Component \" + component.name + \" enabled\" );\n                }\n                else\n                {\n                    out.println( \"Component \" + component.name + \" already enabled\" );\n                }\n            }\n            else\n            {\n                if ( scrService.isComponentEnabled(component) )\n                {\n                    scrService.disableComponent(component);\n                    out.println( \"Component \" + component.name + \" disabled\" );\n                }\n                else\n                {\n                    out.println( \"Component \" + component.name + \" already disabled\" );\n                }\n            }\n        }\n        out.flush();\n        if ( !disposed.isEmpty() )\n        {\n            throw new IllegalArgumentException( \"Components \" + disposed + \" already disposed, cannot change state\" );\n\n        }\n    }","id":86758,"modified_method":"void change(final String componentIdentifier, final PrintWriter out, final boolean enable)\n    {\n        final Result result = getComponentsFromArg(componentIdentifier, true);\n\n        for ( final ComponentDescriptionDTO component : result.components )\n        {\n            if ( enable )\n            {\n                if ( !scrService.isComponentEnabled(component) )\n                {\n                    scrService.enableComponent(component);\n                    out.println( \"Component \" + component.name + \" enabled\" );\n                }\n                else\n                {\n                    out.println( \"Component \" + component.name + \" already enabled\" );\n                }\n            }\n            else\n            {\n                if ( scrService.isComponentEnabled(component) )\n                {\n                    scrService.disableComponent(component);\n                    out.println( \"Component \" + component.name + \" disabled\" );\n                }\n                else\n                {\n                    out.println( \"Component \" + component.name + \" already disabled\" );\n                }\n            }\n        }\n        out.flush();\n    }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"public void list(final String bundleIdentifier, final PrintWriter out)\n    {\n        List<ComponentDescriptionDTO> components;\n\n        if (bundleIdentifier != null)\n        {\n            Bundle bundle = null;\n            try\n            {\n                long bundleId = Long.parseLong(bundleIdentifier);\n                bundle = bundleContext.getBundle(bundleId);\n            }\n            catch (NumberFormatException nfe)\n            {\n                // might be a bundle symbolic name\n                Bundle[] bundles = bundleContext.getBundles();\n                for (int i = 0; i < bundles.length; i++)\n                {\n                    if (bundleIdentifier.equals(bundles[i].getSymbolicName()))\n                    {\n                        bundle = bundles[i];\n                        break;\n                    }\n                }\n            }\n\n            if (bundle == null)\n            {\n                throw new IllegalArgumentException(\"Missing bundle with ID \" + bundleIdentifier);\n            }\n            if (ComponentRegistry.isBundleActive(bundle))\n            {\n                components = new ArrayList<ComponentDescriptionDTO>(scrService.getComponentDescriptionDTOs(bundle));\n                if (components.isEmpty())\n                {\n                    out.println(\"Bundle \" + bundleIdentifier + \" declares no components\");\n                    return;\n                }\n            }\n            else\n            {\n                out.println(\"Bundle \" + bundleIdentifier + \" is not active\");\n                return;\n            }\n        }\n        else\n        {\n            components = new ArrayList<ComponentDescriptionDTO>(scrService.getComponentDescriptionDTOs());\n            if (components.isEmpty())\n            {\n                out.println(\"No components registered\");\n                return;\n            }\n        }\n\n        Collections.sort( components, new Comparator<ComponentDescriptionDTO>()\n                {\n\n                    public int compare(ComponentDescriptionDTO c1, ComponentDescriptionDTO c2)\n                    {\n                        return c1.name.compareTo(c2.name);\n                    }\n\n                });\n\n        out.println(\" Name  BundleId DefaultEnabled\");\n        for ( ComponentDescriptionDTO component : components )\n        {\n            out.println( String.format( \"[%1$s] [%2$4d] [%3$b]\", component.name, component.bundle.id, component.defaultEnabled ) );\n        }\n        out.flush();\n   }","id":86759,"modified_method":"public void list(final String bundleIdentifier, final PrintWriter out)\n    {\n        List<ComponentConfigurationDTO> components;\n\n        if (bundleIdentifier != null)\n        {\n            Bundle bundle = null;\n            try\n            {\n                final long bundleId = Long.parseLong(bundleIdentifier);\n                bundle = bundleContext.getBundle(bundleId);\n            }\n            catch (final NumberFormatException nfe)\n            {\n                // might be a bundle symbolic name\n                final Bundle[] bundles = bundleContext.getBundles();\n                for (int i = 0; i < bundles.length; i++)\n                {\n                    if (bundleIdentifier.equals(bundles[i].getSymbolicName()))\n                    {\n                        bundle = bundles[i];\n                        break;\n                    }\n                }\n            }\n\n            if (bundle == null)\n            {\n                throw new IllegalArgumentException(\"Missing bundle with ID \" + bundleIdentifier);\n            }\n            if (ComponentRegistry.isBundleActive(bundle))\n            {\n                components = new ArrayList<ComponentConfigurationDTO>();\n                for(final ComponentDescriptionDTO cmp : scrService.getComponentDescriptionDTOs(bundle))\n                {\n                    components.addAll(scrService.getComponentConfigurationDTOs(cmp));\n                }\n                if (components.isEmpty())\n                {\n                    out.println(\"Bundle \" + bundleIdentifier + \" declares no components\");\n                    return;\n                }\n            }\n            else\n            {\n                out.println(\"Bundle \" + bundleIdentifier + \" is not active\");\n                return;\n            }\n        }\n        else\n        {\n            components = new ArrayList<ComponentConfigurationDTO>();\n            for(final ComponentDescriptionDTO cmp : scrService.getComponentDescriptionDTOs())\n            {\n                components.addAll(scrService.getComponentConfigurationDTOs(cmp));\n            }\n            if (components.isEmpty())\n            {\n                out.println(\"No components registered\");\n                return;\n            }\n        }\n\n        Collections.sort( components, new Comparator<ComponentConfigurationDTO>()\n                {\n\n                    public int compare(final ComponentConfigurationDTO c1, final ComponentConfigurationDTO c2)\n                    {\n                        return Long.signum(c1.id - c2.id);\n                    }\n\n                });\n\n        out.println(\" Id   State BundleId Name\");\n        for ( final ComponentConfigurationDTO component : components )\n        {\n            out.println( String.format( \"[%1$4d] [%2$s] [%3$4d] %4$s\", component.id, toStateString( component.state ), component.description.bundle.id, component.description.name ) );\n        }\n        out.flush();\n   }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"private Collection<ComponentDescriptionDTO> getComponentFromArg(final String componentIdentifier)\n    {\n        Collection<ComponentDescriptionDTO> components = scrService.getComponentDescriptionDTOs();\n        if (componentIdentifier != null)\n        {\n            ArrayList<ComponentDescriptionDTO> cs = new ArrayList<ComponentDescriptionDTO>(components.size());\n            Pattern p = Pattern.compile(componentIdentifier);\n            for (ComponentDescriptionDTO component: components)\n            {\n                if ( p.matcher( component.name).matches() )\n                {\n                    cs.add( component );\n                }\n            }\n            if (cs.isEmpty())\n            {\n                throw new IllegalArgumentException(\"No Component with ID or matching \" + componentIdentifier);\n            }\n            components = cs;\n        }\n\n        return components;\n    }","id":86760,"modified_method":"private Result getComponentsFromArg(final String componentIdentifier, final boolean nameMatch)\n    {\n        final Pattern p = (componentIdentifier == null ? null : Pattern.compile(componentIdentifier));\n        final Result result = new Result();\n\n        for(final ComponentDescriptionDTO cmp : scrService.getComponentDescriptionDTOs())\n        {\n            if (componentIdentifier != null)\n            {\n                if ( p.matcher(cmp.name).matches() )\n                {\n                    result.components.add(cmp);\n                }\n                else if ( !nameMatch )\n                {\n                    boolean done = false;\n                    for (final ComponentConfigurationDTO cfg: scrService.getComponentConfigurationDTOs(cmp))\n                    {\n                        if ( p.matcher( String.valueOf( cfg.id )).matches() )\n                        {\n                            result.components.add( cmp );\n                            result.configuration = cfg;\n                            done = true;\n                            break;\n                        }\n                    }\n                    if ( done )\n                    {\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                result.components.add(cmp);\n            }\n        }\n        if (componentIdentifier != null && result.components.isEmpty())\n        {\n            throw new IllegalArgumentException(\"No Component with name or configuration with ID matching \" + componentIdentifier);\n        }\n\n        return result;\n    }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"private void help(PrintStream out, String command)\n    {\n        if (LIST_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + LIST_CMD + \" [ <bundleId> ]\");\n            out.println(\"\");\n            out.println(\"This command lists registered components. If a bundle ID is\\n\"\n                + \"added, only the components of the selected bundles are listed.\");\n            out.println(\"\");\n        }\n        else if (INFO_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + INFO_CMD + \" <componentId>\");\n            out.println(\"\");\n            out.println(\"This command dumps information of the component whose\\n\"\n                + \"component ID is given as command argument.\");\n            out.println(\"\");\n        }\n        else if (ENABLE_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + ENABLE_CMD + \" <componentId>\");\n            out.println(\"\");\n            out.println(\"This command enables the component whose component ID\\n\" + \"is given as command argument.\");\n            out.println(\"\");\n        }\n        else if (DISABLE_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + DISABLE_CMD + \" <componentId>\");\n            out.println(\"\");\n            out.println(\"This command disables the component whose component ID\\n\" + \"is given as command argument.\");\n            out.println(\"\");\n        }\n        else if (CONFIG_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + CONFIG_CMD);\n            out.println(\"\");\n            out.println(\"This command lists the current SCR configuration.\");\n            out.println(\"\");\n        }\n        else\n        {\n            out.println(\"scr \" + HELP_CMD + \" [\" + LIST_CMD + \"]\");\n            out.println(\"scr \" + LIST_CMD + \" [ <bundleId> ]\");\n            out.println(\"scr \" + INFO_CMD + \" <componentId>\");\n            out.println(\"scr \" + ENABLE_CMD + \" <componentId>\");\n            out.println(\"scr \" + DISABLE_CMD + \" <componentId>\");\n            out.println(\"scr \" + CONFIG_CMD);\n        }\n    }","id":86761,"modified_method":"private void help(PrintStream out, String command)\n    {\n        if (LIST_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + LIST_CMD + \" [ <bundleId> ]\");\n            out.println(\"\");\n            out.println(\"This command lists registered component configurations. If a bundle ID is\\n\"\n                + \"added, only the component configurations of the selected bundles are listed.\");\n            out.println(\"\");\n        }\n        else if (INFO_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + INFO_CMD + \" <componentId>\");\n            out.println(\"\");\n            out.println(\"This command dumps information of the component whose\\n\"\n                + \"component name or component configuration ID is given as command argument.\");\n            out.println(\"\");\n        }\n        else if (ENABLE_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + ENABLE_CMD + \" <componentName>\");\n            out.println(\"\");\n            out.println(\"This command enables the component whose component name\\n\" + \"is given as command argument.\");\n            out.println(\"\");\n        }\n        else if (DISABLE_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + DISABLE_CMD + \" <componentName>\");\n            out.println(\"\");\n            out.println(\"This command disables the component whose component name\\n\" + \"is given as command argument.\");\n            out.println(\"\");\n        }\n        else if (CONFIG_CMD.equals( command ))\n        {\n            out.println(\"\");\n            out.println(\"scr \" + CONFIG_CMD);\n            out.println(\"\");\n            out.println(\"This command lists the current SCR configuration.\");\n            out.println(\"\");\n        }\n        else\n        {\n            out.println(\"scr \" + HELP_CMD + \" [\" + LIST_CMD + \"]\");\n            out.println(\"scr \" + LIST_CMD + \" [ <bundleId> ]\");\n            out.println(\"scr \" + INFO_CMD + \" <componentId>\");\n            out.println(\"scr \" + ENABLE_CMD + \" <componentName>\");\n            out.println(\"scr \" + DISABLE_CMD + \" <componentName>\");\n            out.println(\"scr \" + CONFIG_CMD);\n        }\n    }","commit_id":"2abaa5f07c357b4d3c0531111e1723383816e4d3","url":"https://github.com/apache/felix"},{"original_method":"public void list(final String bundleIdentifier, final PrintWriter out)\n    {\n        List<ComponentConfigurationDTO> components;\n\n        if (bundleIdentifier != null)\n        {\n            Bundle bundle = null;\n            try\n            {\n                final long bundleId = Long.parseLong(bundleIdentifier);\n                bundle = bundleContext.getBundle(bundleId);\n            }\n            catch (final NumberFormatException nfe)\n            {\n                // might be a bundle symbolic name\n                final Bundle[] bundles = bundleContext.getBundles();\n                for (int i = 0; i < bundles.length; i++)\n                {\n                    if (bundleIdentifier.equals(bundles[i].getSymbolicName()))\n                    {\n                        bundle = bundles[i];\n                        break;\n                    }\n                }\n            }\n\n            if (bundle == null)\n            {\n                throw new IllegalArgumentException(\"Missing bundle with ID \" + bundleIdentifier);\n            }\n            if (ComponentRegistry.isBundleActive(bundle))\n            {\n                components = new ArrayList<ComponentConfigurationDTO>();\n                for(final ComponentDescriptionDTO cmp : scrService.getComponentDescriptionDTOs(bundle))\n                {\n                    components.addAll(scrService.getComponentConfigurationDTOs(cmp));\n                }\n                if (components.isEmpty())\n                {\n                    out.println(\"Bundle \" + bundleIdentifier + \" declares no components\");\n                    return;\n                }\n            }\n            else\n            {\n                out.println(\"Bundle \" + bundleIdentifier + \" is not active\");\n                return;\n            }\n        }\n        else\n        {\n            components = new ArrayList<ComponentConfigurationDTO>();\n            for(final ComponentDescriptionDTO cmp : scrService.getComponentDescriptionDTOs())\n            {\n                components.addAll(scrService.getComponentConfigurationDTOs(cmp));\n            }\n            if (components.isEmpty())\n            {\n                out.println(\"No components registered\");\n                return;\n            }\n        }\n\n        Collections.sort( components, new Comparator<ComponentConfigurationDTO>()\n                {\n\n                    public int compare(final ComponentConfigurationDTO c1, final ComponentConfigurationDTO c2)\n                    {\n                        return Long.signum(c1.id - c2.id);\n                    }\n\n                });\n\n        out.println(\" Id   State BundleId Name\");\n        for ( final ComponentConfigurationDTO component : components )\n        {\n            out.println( String.format( \"[%1$4d] [%2$s] [%3$4d] %4$s\", component.id, toStateString( component.state ), component.description.bundle.id, component.description.name ) );\n        }\n        out.flush();\n   }","id":86762,"modified_method":"public void list(final String bundleIdentifier, final PrintWriter out)\n    {\n        final List<ComponentDescriptionDTO> descriptions = new ArrayList<ComponentDescriptionDTO>();\n\n        if (bundleIdentifier != null)\n        {\n            Bundle bundle = null;\n            try\n            {\n                final long bundleId = Long.parseLong(bundleIdentifier);\n                bundle = bundleContext.getBundle(bundleId);\n            }\n            catch (final NumberFormatException nfe)\n            {\n                // might be a bundle symbolic name\n                final Bundle[] bundles = bundleContext.getBundles();\n                for (int i = 0; i < bundles.length; i++)\n                {\n                    if (bundleIdentifier.equals(bundles[i].getSymbolicName()))\n                    {\n                        bundle = bundles[i];\n                        break;\n                    }\n                }\n            }\n\n            if (bundle == null)\n            {\n                throw new IllegalArgumentException(\"Missing bundle with ID \" + bundleIdentifier);\n            }\n            if (ComponentRegistry.isBundleActive(bundle))\n            {\n                descriptions.addAll(scrService.getComponentDescriptionDTOs(bundle));\n                if (descriptions.isEmpty())\n                {\n                    out.println(\"Bundle \" + bundleIdentifier + \" declares no components\");\n                    return;\n                }\n            }\n            else\n            {\n                out.println(\"Bundle \" + bundleIdentifier + \" is not active\");\n                return;\n            }\n        }\n        else\n        {\n            descriptions.addAll(scrService.getComponentDescriptionDTOs());\n            if (descriptions.isEmpty())\n            {\n                out.println(\"No components registered\");\n                return;\n            }\n        }\n\n        Collections.sort( descriptions, DESCRIPTION_COMP);\n\n        out.println(\" BundleId Component Name Id    State\");\n        for(final ComponentDescriptionDTO desc : descriptions)\n        {\n            final List<ComponentConfigurationDTO> configs = new ArrayList<ComponentConfigurationDTO>(this.scrService.getComponentConfigurationDTOs(desc));\n            if ( configs.isEmpty() )\n            {\n                out.println( String.format( \" [%1$4d]   %2$s  --    --\", desc.bundle.id, desc.name  ) );            }\n            else\n            {\n                Collections.sort( configs, CONFIGURATION_COMP);\n                for ( final ComponentConfigurationDTO component : configs )\n                {\n                    out.println( String.format( \" [%1$4d]   %2$s [%3$4d] [%4$s]\", desc.bundle.id, desc.name, component.id,\n                          toStateString( component.state )  ) );\n                }\n            }\n        }\n        out.flush();\n   }","commit_id":"d04a42ff1c4cfc47c035859b2cc3954eb9534e69","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * A > 1.1 > B > 0..1 > A Both should start, but B should not have an A reference.\n     */\n    @Test\n    public void test_A11_B01_delayed_B_first() throws InvalidSyntaxException\n    {\n        String componentNameA = \"7.A.1.1.dynamic\";\n        final ComponentConfigurationDTO componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.SATISFIED );\n\n        String componentNameB = \"7.B.0.1.dynamic\";\n        final ComponentConfigurationDTO componentB = findComponentConfigurationByName( componentNameB, ComponentConfigurationDTO.SATISFIED );\n\n        ServiceReference[] serviceReferencesB = bundleContext.getServiceReferences( B.class.getName(), \"(service.pid=\" + componentNameB + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesB.length );\n        ServiceReference serviceReferenceB = serviceReferencesB[0];\n        Object serviceB = bundleContext.getService( serviceReferenceB );\n        assertNotNull( serviceB );\n\n        ServiceReference[] serviceReferencesA = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesA.length );\n        ServiceReference serviceReferenceA = serviceReferencesA[0];\n        Object serviceA = bundleContext.getService( serviceReferenceA );\n        assertNotNull( serviceA );\n\n\n        delay();\n        A a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        B b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n\n        //disabling (removing the A service registration) and re-enabling will\n        //result in a service event to B, so B will bind A.\n        disableAndCheck(componentA);\n        delay();\n        enableAndCheck(componentA.description);\n        delay();\n//        ServiceReference[] serviceReferencesA1 = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n//        TestCase.assertEquals( 1, serviceReferencesA1.length );\n//        ServiceReference serviceReferenceA1 = serviceReferencesA1[0];\n//        Object serviceA1 = bundleContext.getService( serviceReferenceA1 );\n//        assertNotNull( serviceA1 );\n\n        a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n    }","id":86763,"modified_method":"/**\n     * A > 1.1 > B > 0..1 > A Both should start, but B should not have an A reference.\n     */\n    @Test\n    public void test_A11_B01_delayed_B_first() throws InvalidSyntaxException\n    {\n        String componentNameA = \"7.A.1.1.dynamic\";\n        ComponentConfigurationDTO componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.SATISFIED );\n\n        String componentNameB = \"7.B.0.1.dynamic\";\n        final ComponentConfigurationDTO componentB = findComponentConfigurationByName( componentNameB, ComponentConfigurationDTO.SATISFIED );\n\n        ServiceReference[] serviceReferencesB = bundleContext.getServiceReferences( B.class.getName(), \"(service.pid=\" + componentNameB + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesB.length );\n        ServiceReference serviceReferenceB = serviceReferencesB[0];\n        Object serviceB = bundleContext.getService( serviceReferenceB );\n        assertNotNull( serviceB );\n\n        ServiceReference[] serviceReferencesA = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesA.length );\n        ServiceReference serviceReferenceA = serviceReferencesA[0];\n        Object serviceA = bundleContext.getService( serviceReferenceA );\n        assertNotNull( serviceA );\n\n\n        delay();\n        A a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        B b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n\n        //disabling (removing the A service registration) and re-enabling will\n        //result in a service event to B, so B will bind A.\n        disableAndCheck(componentA);\n        delay();\n        enableAndCheck(componentA.description);\n        delay();\n//        ServiceReference[] serviceReferencesA1 = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n//        TestCase.assertEquals( 1, serviceReferencesA1.length );\n//        ServiceReference serviceReferenceA1 = serviceReferencesA1[0];\n//        Object serviceA1 = bundleContext.getService( serviceReferenceA1 );\n//        assertNotNull( serviceA1 );\n\n        //new component.id, refetch configuration.\n        componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.ACTIVE );\n        a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * A > 1.1 > B > 0..n > A Both should start, but B should not have an A reference.\n     */\n    @Test\n    public void test_A11_B0n_delayed_B_first() throws InvalidSyntaxException\n    {\n        String componentNameA = \"4.A.1.1.dynamic\";\n        final ComponentConfigurationDTO componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.SATISFIED );\n\n        String componentNameB = \"4.B.0.n.dynamic\";\n        final ComponentConfigurationDTO componentB = findComponentConfigurationByName( componentNameB, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferencesB = bundleContext.getServiceReferences( B.class.getName(), \"(service.pid=\" + componentNameB + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesB.length );\n        ServiceReference serviceReferenceB = serviceReferencesB[0];\n        Object serviceB = bundleContext.getService( serviceReferenceB );\n        assertNotNull( serviceB );\n\n        ServiceReference[] serviceReferencesA = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesA.length );\n        ServiceReference serviceReferenceA = serviceReferencesA[0];\n        Object serviceA = bundleContext.getService( serviceReferenceA );\n        assertNotNull( serviceA );\n\n        delay();\n        A a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        B b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n\n        //disabling (removing the A service registration) and re-enabling will\n        //result in a service event to B, so B will bind A.\n        disableAndCheck(componentA);\n        delay();\n        enableAndCheck(componentA.description);\n        delay();\n//        ServiceReference[] serviceReferencesA1 = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n//        TestCase.assertEquals( 1, serviceReferencesA1.length );\n//        ServiceReference serviceReferenceA1 = serviceReferencesA1[0];\n//        Object serviceA1 = bundleContext.getService( serviceReferenceA1 );\n//        assertNotNull( serviceA1 );\n\n        a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n    }","id":86764,"modified_method":"/**\n     * A > 1.1 > B > 0..n > A Both should start, but B should not have an A reference.\n     */\n    @Test\n    public void test_A11_B0n_delayed_B_first() throws InvalidSyntaxException\n    {\n        String componentNameA = \"4.A.1.1.dynamic\";\n        ComponentConfigurationDTO componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.SATISFIED );\n\n        String componentNameB = \"4.B.0.n.dynamic\";\n        final ComponentConfigurationDTO componentB = findComponentConfigurationByName( componentNameB, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferencesB = bundleContext.getServiceReferences( B.class.getName(), \"(service.pid=\" + componentNameB + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesB.length );\n        ServiceReference serviceReferenceB = serviceReferencesB[0];\n        Object serviceB = bundleContext.getService( serviceReferenceB );\n        assertNotNull( serviceB );\n\n        ServiceReference[] serviceReferencesA = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n        TestCase.assertEquals( 1, serviceReferencesA.length );\n        ServiceReference serviceReferenceA = serviceReferencesA[0];\n        Object serviceA = bundleContext.getService( serviceReferenceA );\n        assertNotNull( serviceA );\n\n        delay();\n        A a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        B b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n\n        //disabling (removing the A service registration) and re-enabling will\n        //result in a service event to B, so B will bind A.\n        disableAndCheck(componentA);\n        delay();\n        enableAndCheck(componentA.description);\n        delay();\n//        ServiceReference[] serviceReferencesA1 = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n//        TestCase.assertEquals( 1, serviceReferencesA1.length );\n//        ServiceReference serviceReferenceA1 = serviceReferencesA1[0];\n//        Object serviceA1 = bundleContext.getService( serviceReferenceA1 );\n//        assertNotNull( serviceA1 );\n\n        //new component.id, refetch configuration.\n        componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.ACTIVE );\n        a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * A > 1.1 > B > 0..n > A Both should start, but B should not have an A reference.\n     */\n    @Test\n    public void test_A11_B0n_delayed_A_first() throws InvalidSyntaxException\n    {\n        String componentNameA = \"4.A.1.1.dynamic\";\n        final ComponentConfigurationDTO componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.SATISFIED );\n\n        String componentNameB = \"4.B.0.n.dynamic\";\n        final ComponentConfigurationDTO componentB = findComponentConfigurationByName( componentNameB, ComponentConfigurationDTO.SATISFIED );\n\n//        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n//        TestCase.assertEquals( 1, serviceReferences.length );\n//        ServiceReference serviceReference = serviceReferences[0];\n//        Object service = bundleContext.getService( serviceReference );\n//        assertNotNull( service );\n\n        delay();\n\n        A a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        B b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n    }","id":86765,"modified_method":"/**\n     * A > 1.1 > B > 0..n > A Both should start, but B should not have an A reference.\n     */\n    @Test\n    public void test_A11_B0n_delayed_A_first() throws InvalidSyntaxException\n    {\n        String componentNameA = \"4.A.1.1.dynamic\";\n        final ComponentConfigurationDTO componentA = findComponentConfigurationByName( componentNameA, ComponentConfigurationDTO.SATISFIED );\n\n        String componentNameB = \"4.B.0.n.dynamic\";\n        final ComponentConfigurationDTO componentB = findComponentConfigurationByName( componentNameB, ComponentConfigurationDTO.SATISFIED );\n\n//        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( A.class.getName(), \"(service.pid=\" + componentNameA + \")\" );\n//        TestCase.assertEquals( 1, serviceReferences.length );\n//        ServiceReference serviceReference = serviceReferences[0];\n//        Object service = bundleContext.getService( serviceReference );\n//        assertNotNull( service );\n\n        delay();\n\n        A a = getServiceFromConfiguration(componentA, A.class);\n        assertEquals( 1, a.getBs().size());\n        delay(); //async binding of a to b after circular ref detected\n        B b = getServiceFromConfiguration(componentB, B.class);\n        assertEquals( 1, b.getAs().size() );\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void test_concurrent_component_activation_using_componentFactories()\n    {\n\n\n    \tComponentConfigurationDTO ccA = getDisabledConfigurationAndEnable( \"org.apache.felix.scr.integration.components.concurrency.AFactory\", ComponentConfigurationDTO.ACTIVE );\n    \tComponentConfigurationDTO ccC = getDisabledConfigurationAndEnable( \"org.apache.felix.scr.integration.components.concurrency.CFactory\", ComponentConfigurationDTO.ACTIVE );\n\n        delay( 30 );\n        for ( Iterator it = log.foundWarnings().iterator(); it.hasNext();)\n        {\n            String message = ( String ) it.next();\n            if ( message.contains( \"FrameworkEvent ERROR\" ) ||\n                    message.contains( \"Could not get service from ref\" ) ||\n                    message.contains( \"Failed creating the component instance; see log for reason\" ) ||\n                    message.contains( \"Cannot create component instance due to failure to bind reference\" ))\n            {\n                continue;\n            }\n            TestCase.fail( \"unexpected warning or error logged: \" + message );\n        }\n    }","id":86766,"modified_method":"@Test\n    public void test_concurrent_component_activation_using_componentFactories()\n    {\n\n\n    \tComponentConfigurationDTO ccA = getDisabledConfigurationAndEnable( \"org.apache.felix.scr.integration.components.concurrency.AFactory\", ComponentConfigurationDTO.ACTIVE );\n    \tComponentConfigurationDTO ccC = getDisabledConfigurationAndEnable( \"org.apache.felix.scr.integration.components.concurrency.CFactory\", ComponentConfigurationDTO.ACTIVE );\n\n        delay( 30 );\n        if ( ! log.foundWarnings().isEmpty() )\n        {\n            TestCase.fail( \"unexpected warning or error logged: \" + log.foundWarnings() );\n        }\n        for ( String message: log.foundWarnings() )\n        {\n            TestCase.fail( \"unexpected warning or error logged: \" + message );\n        }\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"public Log( boolean restrictedLogging )\n        {\n            this.restrictedLogging = restrictedLogging;\n        }","id":86767,"modified_method":"public Log( boolean restrictedLogging, String[] ignoredWarnings )\n        {\n            this.restrictedLogging = restrictedLogging;\n            this.ignoredWarnings = ignoredWarnings;\n        }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"@Before\n    public void setUp() throws BundleException\n    {\n        log = new Log(restrictedLogging);\n        log.start();\n        bundleContext.addFrameworkListener( log );\n        bundleContext.registerService( LogService.class.getName(), log, null );\n        \n        scrTracker = new ServiceTracker<ServiceComponentRuntime, ServiceComponentRuntime>( bundleContext, ServiceComponentRuntime.class, null );\n        scrTracker.open();\n        configAdminTracker = new ServiceTracker<ConfigurationAdmin, ConfigurationAdmin>( bundleContext, ConfigurationAdmin.class, null );\n        configAdminTracker.open();\n\n        bundle = installBundle( descriptorFile, COMPONENT_PACKAGE );\n        bundle.start();\n    }","id":86768,"modified_method":"@Before\n    public void setUp() throws BundleException\n    {\n        log = new Log(restrictedLogging, ignoredWarnings);\n        log.start();\n        bundleContext.addFrameworkListener( log );\n        bundleContext.registerService( LogService.class.getName(), log, null );\n        \n        scrTracker = new ServiceTracker<ServiceComponentRuntime, ServiceComponentRuntime>( bundleContext, ServiceComponentRuntime.class, null );\n        scrTracker.open();\n        configAdminTracker = new ServiceTracker<ConfigurationAdmin, ConfigurationAdmin>( bundleContext, ConfigurationAdmin.class, null );\n        configAdminTracker.open();\n\n        bundle = installBundle( descriptorFile, COMPONENT_PACKAGE );\n        bundle.start();\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"public void run()\n        {\n            try\n            {\n                LogEntry entry = null;\n                while ( true )\n                {\n                    entry = m_logQueue.take();\n                    if ( entry.getLevel() <= 2 )\n                    {\n                        if ( m_warnings.size() < 1024 )\n                        {\n                            m_warnings.add( entry.getMessage() );\n                        }\n                        else\n                        {\n                            // Avoid out of memory ...\n                            m_warnings.set( 1023, \"Unexpected errors logged. Please look at previous logs\" );\n                        }\n                    }\n\n                    StringWriter sw = new StringWriter();\n                    sw.append( \"log level: \" + entry.getLevel() );\n                    sw.append( \" D=\" );\n                    sw.append( m_sdf.format( new Date( entry.getTime() ) ) );\n                    sw.append( \" T=\" + entry.getThread() );\n                    sw.append( \": \" );\n                    sw.append( entry.getMessage() );\n                    if ( entry.getError() != null )\n                    {\n                        sw.append( System.getProperty( \"line.separator\" ) );\n                        PrintWriter pw = new PrintWriter( sw );\n                        entry.getError().printStackTrace( pw );\n                        pw.flush();\n                    }\n                    if ( restrictedLogging )\n                    {\n                        log[i++] = sw.toString();\n                        if ( i == RESTRICTED_LOG_SIZE ) i = 0;\n                    }\n                    else\n                    {\n                        m_out.println( sw.toString() );\n                        m_out.flush();\n                    }\n                }\n            }\n            catch ( InterruptedException e )\n            {\n                return;\n            }\n        }","id":86769,"modified_method":"public void run()\n        {\n            try\n            {\n                LogEntry entry = null;\n                while ( true )\n                {\n                    entry = m_logQueue.take();\n                    if ( entry.getLevel() <= 2 )\n                    {\n                        if ( m_warnings.size() < 1024 && acceptWarning( entry.getMessage() ) )\n                        {\n                            m_warnings.add( entry.getMessage() );\n                        }\n                        else\n                        {\n                            // Avoid out of memory ...\n                            m_warnings.set( 1023, \"Unexpected errors logged. Please look at previous logs\" );\n                        }\n                    }\n\n                    StringWriter sw = new StringWriter();\n                    sw.append( \"log level: \" + entry.getLevel() );\n                    sw.append( \" D=\" );\n                    sw.append( m_sdf.format( new Date( entry.getTime() ) ) );\n                    sw.append( \" T=\" + entry.getThread() );\n                    sw.append( \": \" );\n                    sw.append( entry.getMessage() );\n                    if ( entry.getError() != null )\n                    {\n                        sw.append( System.getProperty( \"line.separator\" ) );\n                        PrintWriter pw = new PrintWriter( sw );\n                        entry.getError().printStackTrace( pw );\n                        pw.flush();\n                    }\n                    if ( restrictedLogging )\n                    {\n                        log[i++] = sw.toString();\n                        if ( i == RESTRICTED_LOG_SIZE ) i = 0;\n                    }\n                    else\n                    {\n                        m_out.println( sw.toString() );\n                        m_out.flush();\n                    }\n                }\n            }\n            catch ( InterruptedException e )\n            {\n                return;\n            }\n        }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"protected Collection<ComponentConfigurationDTO> findComponentConfigurationsByName( Bundle b, String name, int expected )\n    {\n        ServiceComponentRuntime scr = scrTracker.getService();\n        if ( scr == null )\n        {\n        \tTestCase.fail(\"no ServiceComponentRuntime\");\n        }\n        \tComponentDescriptionDTO cd = scr.getComponentDescriptionDTO(bundle, name);\n        \tCollection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs(cd);\n        \tif (expected != -1)\n        \t{\n        \t\tfor (ComponentConfigurationDTO cc: ccs)\n        \t\t{\n        \t    \tAssert.assertEquals( \"for ComponentConfiguration name: \" + cc.description.name + \" properties\" + cc.properties + \"Expected state \" + STATES.get(expected) + \" but was \" + STATES.get(cc.state), expected, cc.state);        \t\t\t\n        \t\t}\n        \t}\n        \treturn ccs;\n    }","id":86770,"modified_method":"protected Collection<ComponentConfigurationDTO> findComponentConfigurationsByName( Bundle b, String name, int expected )\n    {\n        ServiceComponentRuntime scr = scrTracker.getService();\n        if ( scr == null )\n        {\n        \tTestCase.fail(\"no ServiceComponentRuntime\");\n        }\n        ComponentDescriptionDTO cd = scr.getComponentDescriptionDTO(b, name);\n        Collection<ComponentConfigurationDTO> ccs = scr.getComponentConfigurationDTOs(cd);\n        if (expected != -1)\n        {\n        \tfor (ComponentConfigurationDTO cc: ccs)\n        \t{\n        \t\tAssert.assertEquals( \"for ComponentConfiguration name: \" + cc.description.name + \" properties\" + cc.properties + \"Expected state \" + STATES.get(expected) + \" but was \" + STATES.get(cc.state), expected, cc.state);        \t\t\t\n        \t}\n        }\n        return ccs;\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"private void multipleTest(String pid, boolean dynamic)\n    {\n        final SimpleServiceImpl srv1 = SimpleServiceImpl.create( bundleContext, \"srv1\" );\n        final SimpleServiceImpl srv2 = SimpleServiceImpl.create( bundleContext, \"srv2\" );\n\n        theConfig.put(\"ref.target\", \"(value=srv1)\");\n        configure( pid );\n\n        getDisabledConfigurationAndEnable(pid, ComponentConfigurationDTO.ACTIVE);\n\n        final SimpleComponent comp10 = SimpleComponent.INSTANCE;\n        TestCase.assertNotNull( comp10 );\n        TestCase.assertEquals( 1, comp10.m_multiRef.size() );\n        TestCase.assertEquals( srv1, comp10.m_multiRef.iterator().next() );\n        TestCase.assertEquals( 1, comp10.m_multiRefBind );\n        TestCase.assertEquals( 0, comp10.m_multiRefUnbind);\n\n        // update configuration to target srv2\n        theConfig.put(\"ref.target\", \"(value=srv2)\");\n        configure( pid );\n\n        delay();\n        // should bind to srv2\n        SimpleComponent comp20;\n        if ( dynamic )\n        {\n            TestCase.assertEquals( 1, comp10.m_modified );\n            comp20 = comp10;\n            TestCase.assertEquals( 2, comp20.m_multiRefBind );\n            TestCase.assertEquals( 1, comp20.m_multiRefUnbind);\n        } \n        else\n        {\n            TestCase.assertEquals( 0, comp10.m_modified );\n            comp20 = SimpleComponent.INSTANCE;\n            TestCase.assertNotSame( comp10, comp20 );\n            TestCase.assertEquals( 0, comp20.m_modified );\n            TestCase.assertEquals( 1, comp20.m_multiRefBind );\n            TestCase.assertEquals( 0, comp20.m_multiRefUnbind);\n            TestCase.assertEquals( 1, comp10.m_multiRefUnbind);\n        }\n        findComponentConfigurationByName(pid, ComponentConfigurationDTO.ACTIVE);\n        TestCase.assertEquals( 1, comp20.m_multiRef.size() );\n        TestCase.assertEquals( srv2, comp20.m_multiRef.iterator().next() );\n    }","id":86771,"modified_method":"private void multipleTest(String pid, boolean dynamic)\n    {\n        final SimpleServiceImpl srv1 = SimpleServiceImpl.create( bundleContext, \"srv1\" );\n        final SimpleServiceImpl srv2 = SimpleServiceImpl.create( bundleContext, \"srv2\" );\n\n        theConfig.put(\"ref.target\", \"(value=srv1)\");\n        configure( pid );\n        delay();//let cm thread finish before enabling.\n        \n        getDisabledConfigurationAndEnable(pid, ComponentConfigurationDTO.ACTIVE);\n\n        final SimpleComponent comp10 = SimpleComponent.INSTANCE;\n        TestCase.assertNotNull( comp10 );\n        TestCase.assertEquals( 1, comp10.m_multiRef.size() );\n        TestCase.assertEquals( srv1, comp10.m_multiRef.iterator().next() );\n        TestCase.assertEquals( 1, comp10.m_multiRefBind );\n        TestCase.assertEquals( 0, comp10.m_multiRefUnbind);\n\n        // update configuration to target srv2\n        theConfig.put(\"ref.target\", \"(value=srv2)\");\n        configure( pid );\n\n        delay();\n        // should bind to srv2\n        SimpleComponent comp20;\n        if ( dynamic )\n        {\n            TestCase.assertEquals( 1, comp10.m_modified );\n            comp20 = comp10;\n            TestCase.assertEquals( 2, comp20.m_multiRefBind );\n            TestCase.assertEquals( 1, comp20.m_multiRefUnbind);\n        } \n        else\n        {\n            TestCase.assertEquals( 0, comp10.m_modified );\n            comp20 = SimpleComponent.INSTANCE;\n            TestCase.assertNotSame( comp10, comp20 );\n            TestCase.assertEquals( 0, comp20.m_modified );\n            TestCase.assertEquals( 1, comp20.m_multiRefBind );\n            TestCase.assertEquals( 0, comp20.m_multiRefUnbind);\n            TestCase.assertEquals( 1, comp10.m_multiRefUnbind);\n        }\n        findComponentConfigurationByName(pid, ComponentConfigurationDTO.ACTIVE);\n        TestCase.assertEquals( 1, comp20.m_multiRef.size() );\n        TestCase.assertEquals( srv2, comp20.m_multiRef.iterator().next() );\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"private void singleTest(String pid, boolean dynamic)\n    {\n        final SimpleServiceImpl srv1 = SimpleServiceImpl.create( bundleContext, \"srv1\" );\n        final SimpleServiceImpl srv2 = SimpleServiceImpl.create( bundleContext, \"srv2\" );\n\n        theConfig.put(\"ref.target\", \"(value=srv1)\");\n        configure( pid );\n\n\t\tgetDisabledConfigurationAndEnable(pid, ComponentConfigurationDTO.ACTIVE);\n        final SimpleComponent comp10 = SimpleComponent.INSTANCE;\n        TestCase.assertNotNull( comp10 );\n        TestCase.assertEquals( srv1, comp10.m_singleRef );\n        TestCase.assertTrue( comp10.m_multiRef.isEmpty() );\n        TestCase.assertEquals( 1, comp10.m_singleRefBind );\n        TestCase.assertEquals( 0, comp10.m_singleRefUnbind);\n\n        // update configuration to target srv2\n        theConfig.put(\"ref.target\", \"(value=srv2)\");\n        configure( pid );\n\n        delay();\n        // should bind to srv2\n        SimpleComponent comp20;\n        if ( dynamic )\n        {\n            TestCase.assertEquals( 1, comp10.m_modified );\n            comp20 = comp10;\n            TestCase.assertEquals( 2, comp20.m_singleRefBind );\n            TestCase.assertEquals( 1, comp20.m_singleRefUnbind);\n        } \n        else\n        {\n            TestCase.assertEquals( 0, comp10.m_modified );\n            comp20 = SimpleComponent.INSTANCE;\n            TestCase.assertNotSame( comp10, comp20 );\n            TestCase.assertEquals( 0, comp20.m_modified );\n            TestCase.assertEquals( 1, comp20.m_singleRefBind );\n            TestCase.assertEquals( 0, comp20.m_singleRefUnbind);\n            TestCase.assertEquals( 1, comp10.m_singleRefUnbind);\n        }\n        findComponentConfigurationByName(pid, ComponentConfigurationDTO.ACTIVE);\n        TestCase.assertEquals( srv2, comp20.m_singleRef );\n        TestCase.assertTrue( comp20.m_multiRef.isEmpty() );\n    }","id":86772,"modified_method":"private void singleTest(String pid, boolean dynamic)\n    {\n        final SimpleServiceImpl srv1 = SimpleServiceImpl.create( bundleContext, \"srv1\" );\n        final SimpleServiceImpl srv2 = SimpleServiceImpl.create( bundleContext, \"srv2\" );\n\n        theConfig.put(\"ref.target\", \"(value=srv1)\");\n        configure( pid );\n        delay();//all cm event to complete\n        \n\t\tgetDisabledConfigurationAndEnable(pid, ComponentConfigurationDTO.ACTIVE);\n        final SimpleComponent comp10 = SimpleComponent.INSTANCE;\n        TestCase.assertNotNull( comp10 );\n        TestCase.assertEquals( srv1, comp10.m_singleRef );\n        TestCase.assertTrue( comp10.m_multiRef.isEmpty() );\n        TestCase.assertEquals( 1, comp10.m_singleRefBind );\n        TestCase.assertEquals( 0, comp10.m_singleRefUnbind);\n\n        // update configuration to target srv2\n        theConfig.put(\"ref.target\", \"(value=srv2)\");\n        configure( pid );\n\n        delay();\n        // should bind to srv2\n        SimpleComponent comp20;\n        if ( dynamic )\n        {\n            TestCase.assertEquals( 1, comp10.m_modified );\n            comp20 = comp10;\n            TestCase.assertEquals( 2, comp20.m_singleRefBind );\n            TestCase.assertEquals( 1, comp20.m_singleRefUnbind);\n        } \n        else\n        {\n            TestCase.assertEquals( 0, comp10.m_modified );\n            comp20 = SimpleComponent.INSTANCE;\n            TestCase.assertNotSame( comp10, comp20 );\n            TestCase.assertEquals( 0, comp20.m_modified );\n            TestCase.assertEquals( 1, comp20.m_singleRefBind );\n            TestCase.assertEquals( 0, comp20.m_singleRefUnbind);\n            TestCase.assertEquals( 1, comp10.m_singleRefUnbind);\n        }\n        findComponentConfigurationByName(pid, ComponentConfigurationDTO.ACTIVE);\n        TestCase.assertEquals( srv2, comp20.m_singleRef );\n        TestCase.assertTrue( comp20.m_multiRef.isEmpty() );\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void test_concurrent_deactivation() throws Exception\n    {\n        final Bundle bundle1 = installBundle(\"/integration_test_FELIX_4188_1.xml\", \"\", \"simplecomponent1\");\n        bundle1.start();\n\n        final Bundle bundle2 = installBundle(\"/integration_test_FELIX_4188_2.xml\", \"\", \"simplecomponent2\");\n        bundle2.start();\n\n        final ComponentConfigurationDTO aComp1 =\n                findComponentConfigurationByName( bundle1, \"org.apache.felix.scr.integration.components.Felix4188Component-1\", ComponentConfigurationDTO.ACTIVE);\n        final Felix4188Component aInst1 = getServiceFromConfiguration(aComp1, Felix4188Component.class);\n\n        final ComponentConfigurationDTO aComp2 =\n                findComponentConfigurationByName( bundle1, \"org.apache.felix.scr.integration.components.Felix4188Component-2\", ComponentConfigurationDTO.ACTIVE);\n        final Felix4188Component aInst2 = getServiceFromConfiguration(aComp2, Felix4188Component.class);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        new Thread() {\n            public void run() {\n                Bundle scrBundle = scrTracker.getServiceReference().getBundle();\n                try {\n                    scrBundle.stop();\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }\n        }.start();\n        Thread.sleep(100);\n        long t0 = System.currentTimeMillis();\n        bundle1.stop();\n        bundle2.stop();\n        long t1 = System.currentTimeMillis();\n        TestCase.assertTrue(t1 - t0 > 1000);  // It should have taken more than a second\n\n        TestCase.assertNull(getField(aInst1, \"throwable\"));\n        TestCase.assertNull(getField(aInst2, \"throwable\"));\n\n        latch.await();\n\n        TestCase.assertNull(getField(aInst1, \"throwable\"));\n        TestCase.assertNull(getField(aInst2, \"throwable\"));\n    }","id":86773,"modified_method":"@Test\n    public void test_concurrent_deactivation() throws Exception\n    {\n        final Bundle bundle1 = installBundle(\"/integration_test_FELIX_4188_1.xml\", \"org.apache.felix.scr.integration.components\", \"simplecomponent1\");\n        bundle1.start();\n\n        final Bundle bundle2 = installBundle(\"/integration_test_FELIX_4188_2.xml\", \"org.apache.felix.scr.integration.components\", \"simplecomponent2\");\n        bundle2.start();\n\n        final ComponentConfigurationDTO aComp1 =\n                findComponentConfigurationByName( bundle1, \"org.apache.felix.scr.integration.components.Felix4188Component-1\", ComponentConfigurationDTO.SATISFIED);\n        final Object aInst1 = getServiceFromConfiguration(aComp1, Felix4188Component.class);\n\n        final ComponentConfigurationDTO aComp2 =\n                findComponentConfigurationByName( bundle2, \"org.apache.felix.scr.integration.components.Felix4188Component-2\", ComponentConfigurationDTO.SATISFIED);\n        final Object aInst2 = getServiceFromConfiguration(aComp2, Felix4188Component.class);\n\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        new Thread() {\n            public void run() {\n                Bundle scrBundle = scrTracker.getServiceReference().getBundle();\n                try {\n                    scrBundle.stop();\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                } finally {\n                    latch.countDown();\n                }\n            }\n        }.start();\n        Thread.sleep(100);\n        long t0 = System.currentTimeMillis();\n        bundle1.stop();\n        bundle2.stop();\n        long t1 = System.currentTimeMillis();\n        TestCase.assertTrue(t1 - t0 > 1000);  // It should have taken more than a second\n\n        TestCase.assertNull(getField(aInst1, \"throwable\"));\n        TestCase.assertNull(getField(aInst2, \"throwable\"));\n\n        latch.await();\n\n        TestCase.assertNull(getField(aInst1, \"throwable\"));\n        TestCase.assertNull(getField(aInst2, \"throwable\"));\n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testTargetedPID() throws Exception\n    {\n        try\n        {\n            new ConfigurationPermission(REGION, ConfigurationPermission.TARGET);\n        }\n        catch (IllegalArgumentException e)\n        {\n            return;//not an R5 CA\n        }\n        String pid = COMPONENT_NAME;\n        theConfig.put(TARGETED_PID, pid);\n        Configuration config = configure( pid );\n        config.setBundleLocation( REGION );\n        \n        String pidSN = pid + \"|simplecomponent2\";\n        theConfig.put(TARGETED_PID, pidSN);\n        Configuration configSN = configure( pidSN );\n        configSN.setBundleLocation( REGION );\n        \n        String pidSNV = pidSN + \"|0.0.12\";\n        theConfig.put(TARGETED_PID, pidSNV);\n        Configuration configSNV = configure( pidSNV );\n        configSNV.setBundleLocation( REGION );\n        \n        String pidSNVL = pidSNV + \"|bundleLocation\";\n        theConfig.put(TARGETED_PID, pidSNVL);\n        Configuration configSNVL = configure( pidSNVL );\n        configSNVL.setBundleLocation( REGION );\n        \n        //Add more and more specific components to check that they pick up the appropriate configuration\n        Set<ComponentConfigurationDTO> known = new HashSet<ComponentConfigurationDTO>();\n        \n        final ComponentConfigurationDTO component = findComponentConfigurationByName( COMPONENT_NAME, ComponentConfigurationDTO.ACTIVE );\n        known.add( component );\n//        component.enable();\n\n        TestCase.assertNotNull( SimpleComponent.INSTANCE );\n        SimpleComponent sc = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pid, sc.getProperty( TARGETED_PID ) );\n        \n        \n        Bundle bSN = installBundle( descriptorFile, COMPONENT_PACKAGE, \"simplecomponent2\", \"0.0.11\", null );\n        bSN.start();\n        findComponentConfigurationByName( bSN, pid, ComponentConfigurationDTO.ACTIVE );\n\n        \n//        cSN.enable();\n//        delay();\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSN.getState() );\n        SimpleComponent scSN = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pidSN, scSN.getProperty( TARGETED_PID ) );\n        \n        Bundle bSNV = installBundle( descriptorFile, COMPONENT_PACKAGE, \"simplecomponent2\", \"0.0.12\", null );\n        bSNV.start();\n        findComponentConfigurationByName( bSNV, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( 3, components.size() );\n//        ComponentConfigurationDTO cSNV = getNewComponent( known, components ); \n        \n//        cSNV.enable();\n//        delay();\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNV.getState() );\n        SimpleComponent scSNV = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pidSNV, scSNV.getProperty( TARGETED_PID ) );\n        \n        Bundle bSNVL = installBundle( descriptorFile, COMPONENT_PACKAGE, \"simplecomponent2\", \"0.0.12\", \"bundleLocation\" );\n        bSNVL.start();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( 4, components.size() );\n//        ComponentConfigurationDTO cSNVL = getNewComponent( known, components ); \n        \n//        cSNVL.enable();\n//        delay();\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        SimpleComponent scSNVL = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pidSNVL, scSNVL.getProperty( TARGETED_PID ) );\n        \n        //remove configurations to check that the components now use the less specific configurations.\n        \n        configSNVL.delete();\n        delay();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        TestCase.assertEquals( pidSNV, scSNVL.getProperty( TARGETED_PID ) );\n        \n        configSNV.delete();\n        delay();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        TestCase.assertEquals( pidSN, scSNVL.getProperty( TARGETED_PID ) );\n        findComponentConfigurationByName( bSNV, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNV.getState() );\n        TestCase.assertEquals( pidSN, scSNV.getProperty( TARGETED_PID ) );\n        \n        configSN.delete();\n        delay();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        TestCase.assertEquals( pid, scSNVL.getProperty( TARGETED_PID ) );\n        findComponentConfigurationByName( bSNV, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNV.getState() );\n        TestCase.assertEquals( pid, scSNV.getProperty( TARGETED_PID ) );\n        findComponentConfigurationByName( bSN, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSN.getState() );\n        TestCase.assertEquals( pid, scSN.getProperty( TARGETED_PID ) );\n        \n        \n    }","id":86774,"modified_method":"@Test\n    public void testTargetedPID() throws Exception\n    {\n        try\n        {\n            new ConfigurationPermission(REGION, ConfigurationPermission.TARGET);\n        }\n        catch (IllegalArgumentException e)\n        {\n            return;//not an R5 CA\n        }\n        String pid = COMPONENT_NAME;\n        theConfig.put(TARGETED_PID, pid);\n        Configuration config = configure( pid );\n        config.setBundleLocation( REGION );\n        \n        String pidSN = pid + \"|simplecomponent2\";\n        theConfig.put(TARGETED_PID, pidSN);\n        Configuration configSN = configure( pidSN );\n        configSN.setBundleLocation( REGION );\n        \n        String pidSNV = pidSN + \"|0.0.12\";\n        theConfig.put(TARGETED_PID, pidSNV);\n        Configuration configSNV = configure( pidSNV );\n        configSNV.setBundleLocation( REGION );\n        \n        String pidSNVL = pidSNV + \"|bundleLocation\";\n        theConfig.put(TARGETED_PID, pidSNVL);\n        Configuration configSNVL = configure( pidSNVL );\n        configSNVL.setBundleLocation( REGION );\n        \n        delay();\n        \n        //Add more and more specific components to check that they pick up the appropriate configuration\n        Set<ComponentConfigurationDTO> known = new HashSet<ComponentConfigurationDTO>();\n        \n        final ComponentConfigurationDTO component = findComponentConfigurationByName( COMPONENT_NAME, ComponentConfigurationDTO.ACTIVE );\n        known.add( component );\n//        component.enable();\n\n        TestCase.assertNotNull( SimpleComponent.INSTANCE );\n        SimpleComponent sc = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pid, sc.getProperty( TARGETED_PID ) );\n        \n        \n        Bundle bSN = installBundle( descriptorFile, COMPONENT_PACKAGE, \"simplecomponent2\", \"0.0.11\", null );\n        bSN.start();\n        findComponentConfigurationByName( bSN, pid, ComponentConfigurationDTO.ACTIVE );\n\n        \n//        cSN.enable();\n//        delay();\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSN.getState() );\n        SimpleComponent scSN = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pidSN, scSN.getProperty( TARGETED_PID ) );\n        \n        Bundle bSNV = installBundle( descriptorFile, COMPONENT_PACKAGE, \"simplecomponent2\", \"0.0.12\", null );\n        bSNV.start();\n        findComponentConfigurationByName( bSNV, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( 3, components.size() );\n//        ComponentConfigurationDTO cSNV = getNewComponent( known, components ); \n        \n//        cSNV.enable();\n//        delay();\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNV.getState() );\n        SimpleComponent scSNV = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pidSNV, scSNV.getProperty( TARGETED_PID ) );\n        \n        Bundle bSNVL = installBundle( descriptorFile, COMPONENT_PACKAGE, \"simplecomponent2\", \"0.0.12\", \"bundleLocation\" );\n        bSNVL.start();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( 4, components.size() );\n//        ComponentConfigurationDTO cSNVL = getNewComponent( known, components ); \n        \n//        cSNVL.enable();\n//        delay();\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        SimpleComponent scSNVL = SimpleComponent.INSTANCE;\n        TestCase.assertEquals( pidSNVL, scSNVL.getProperty( TARGETED_PID ) );\n        \n        //remove configurations to check that the components now use the less specific configurations.\n        \n        configSNVL.delete();\n        delay();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        TestCase.assertEquals( pidSNV, scSNVL.getProperty( TARGETED_PID ) );\n        \n        configSNV.delete();\n        delay();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        TestCase.assertEquals( pidSN, scSNVL.getProperty( TARGETED_PID ) );\n        findComponentConfigurationByName( bSNV, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNV.getState() );\n        TestCase.assertEquals( pidSN, scSNV.getProperty( TARGETED_PID ) );\n        \n        configSN.delete();\n        delay();\n        findComponentConfigurationsByName( bSNVL, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNVL.getState() );\n        TestCase.assertEquals( pid, scSNVL.getProperty( TARGETED_PID ) );\n        findComponentConfigurationByName( bSNV, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSNV.getState() );\n        TestCase.assertEquals( pid, scSNV.getProperty( TARGETED_PID ) );\n        findComponentConfigurationByName( bSN, pid, ComponentConfigurationDTO.ACTIVE );\n//        TestCase.assertEquals( Component.STATE_ACTIVE, cSN.getState() );\n        TestCase.assertEquals( pid, scSN.getProperty( TARGETED_PID ) );\n        \n        \n    }","commit_id":"c2357ed033d32685ecaf7b24fe04caed7cb035ae","url":"https://github.com/apache/felix"},{"original_method":"@Restricted(NoExternalUse.class)\n    public static void cleanUp() {\n        PluginServletFilter instance = getInstance(Jenkins.getInstance().servletContext);\n        if (instance != null) {\n            for (Iterator<Filter> iterator = instance.list.iterator(); iterator.hasNext(); ) {\n                Filter f = iterator.next();\n                try {\n                    f.destroy();\n                } catch (RuntimeException e) {\n                    LOGGER.log(Level.WARNING, \"Filter \" + f + \" propagated an exception from its destroy method\", e);\n                } catch (Error e) {\n                    throw e; // we are not supposed to catch errors, don't log as could be an OOM\n                } catch (Throwable e) {\n                    LOGGER.log(Level.SEVERE, \"Filter \" + f + \" propagated an exception from its destroy method\", e);\n                }\n                iterator.remove();\n            }\n        }\n    }","id":86775,"modified_method":"@Restricted(NoExternalUse.class)\n    public static void cleanUp() {\n        PluginServletFilter instance = getInstance(Jenkins.getInstance().servletContext);\n        if (instance != null) {\n            // While we could rely on the current implementation of list being a CopyOnWriteArrayList\n            // safer to just take an explicit copy of the list and operate on the copy\n            for (Filter f: new ArrayList<>(instance.list)) {\n                instance.list.remove(f);\n                // remove from the list even if destroy() fails as a failed destroy is still a destroy\n                try {\n                    f.destroy();\n                } catch (RuntimeException e) {\n                    LOGGER.log(Level.WARNING, \"Filter \" + f + \" propagated an exception from its destroy method\",\n                            e);\n                } catch (Error e) {\n                    throw e; // we are not supposed to catch errors, don't log as could be an OOM\n                } catch (Throwable e) {\n                    LOGGER.log(Level.SEVERE, \"Filter \" + f + \" propagated an exception from its destroy method\", e);\n                }\n            }\n            // if some fool adds a filter while we are terminating, we should just log the fact\n            if (!instance.list.isEmpty()) {\n                LOGGER.log(Level.SEVERE, \"The following filters appear to have been added during clean up: {0}\",\n                        instance.list);\n            }\n        }\n    }","commit_id":"a5febd7666fd78542d45428505cc62c067315c43","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Restricted(NoExternalUse.class)\n    public static void cleanUp() {\n        PluginServletFilter instance = getInstance(Jenkins.getInstance().servletContext);\n        if (instance != null) {\n            for (Iterator<Filter> iterator = instance.list.iterator(); iterator.hasNext(); ) {\n                Filter f = iterator.next();\n                try {\n                    f.destroy();\n                } catch (RuntimeException e) {\n                    LOGGER.log(Level.WARNING, \"Filter \" + f + \" propagated an exception from its destroy method\", e);\n                } catch (Error e) {\n                    throw e; // we are not supposed to catch errors, don't log as could be an OOM\n                } catch (Throwable e) {\n                    LOGGER.log(Level.SEVERE, \"Filter \" + f + \" propagated an exception from its destroy method\", e);\n                }\n                iterator.remove();\n            }\n        }\n    }","id":86776,"modified_method":"@Restricted(NoExternalUse.class)\n    public static void cleanUp() {\n        PluginServletFilter instance = getInstance(Jenkins.getInstance().servletContext);\n        if (instance != null) {\n            // While we could rely on the current implementation of list being a CopyOnWriteArrayList\n            // safer to just take an explicit copy of the list and operate on the copy\n            for (Filter f: new ArrayList<>(instance.list)) {\n                instance.list.remove(f);\n                // remove from the list even if destroy() fails as a failed destroy is still a destroy\n                try {\n                    f.destroy();\n                } catch (RuntimeException e) {\n                    LOGGER.log(Level.WARNING, \"Filter \" + f + \" propagated an exception from its destroy method\",\n                            e);\n                } catch (Error e) {\n                    throw e; // we are not supposed to catch errors, don't log as could be an OOM\n                } catch (Throwable e) {\n                    LOGGER.log(Level.SEVERE, \"Filter \" + f + \" propagated an exception from its destroy method\", e);\n                }\n            }\n            // if some fool adds a filter while we are terminating, we should just log the fact\n            if (!instance.list.isEmpty()) {\n                LOGGER.log(Level.SEVERE, \"The following filters appear to have been added during clean up: {0}\",\n                        instance.list);\n            }\n        }\n    }","commit_id":"c57af86955c2c799930a93cd955ed7f98c7dc504","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void startPipeline() {\r\n\t\tsynchronized (inOrderSegments) {\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: starting pipelining\");\r\n\r\n\t\t\t_pipelineStartTime = System.currentTimeMillis();\r\n\t\t\tif (SystemConfiguration.PIPELINE_STATS)\r\n\t\t\t\tSystem.out.println(\"plot \"+(System.currentTimeMillis() - _pipelineStartTime)+\" inOrder: \"+inOrderSegments.size() +\" outOfOrder: \"+outOfOrderSegments.size() + \" interests: \"+_sentInterests.size() +\" holes: \"+_holes + \" received: \"+_totalReceived+\" [\"+_baseName+\"].1\"+ \" toProcess \"+incoming.size());\t\t\r\n\r\n\t\t\tlong segmentToGet = -1;\r\n\t\t\tInterest interest = null;\r\n\r\n\t\t\tif(_basePipelineName == null) {\r\n\t\t\t\t_basePipelineName = _baseName.clone();\r\n\t\t\t}\r\n\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: BaseName for pipeline: {0} base name: {1}\", _basePipelineName, _baseName);\r\n\r\n\t\t\tif (_currentSegment!=null) {\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we already have the first segment...  start from there: {0}\", _currentSegment.name());\r\n\t\t\t\t//we already have the starting segment...\r\n\r\n\t\t\t\t//is the first segment the last one?\r\n\t\t\t\tif (SegmentationProfile.isLastSegment(_currentSegment)) {\r\n\t\t\t\t\t//this is the last segment...  don't pipeline\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we already have the last segment...  don't need to pipeline (returning)\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//this isn't the last segment, start up pipelining...  only ask for next segment to start\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: this isn't the last segment...  need to start up pipelining\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: need to get the first segment: startingSegmentNumber={0}\",_startingSegmentNumber);\r\n\t\t\t}\r\n\r\n\t\t\tsegmentToGet = nextSegmentNumber();\r\n\t\t\t_nextPipelineSegment = segmentToGet;\r\n\t\t\tinterest = SegmentationProfile.segmentInterest(_basePipelineName, segmentToGet, _publisher);\r\n\t\t\ttry {\r\n\t\t\t\tinterest.userTime = System.currentTimeMillis();\r\n\t\t\t\t_handle.expressInterest(interest, this);\r\n\t\t\t\t_sentInterests.add(interest);\r\n\t\t\t\t_lastRequestedPipelineSegment = segmentToGet;\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: expressed interest for segment {0} in startPipeline(): {1}\", segmentToGet, interest);\r\n\t\t\t} catch(IOException e) {\r\n\t\t\t\t//could not express interest for next segment...  logging the error\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.WARNING) )\r\n\t\t\t\t\tLog.warning(Log.FAC_PIPELINE, \"Failed to express interest for pipelining segments in CCNAbstractInputStream:  Interest = {0}\", interest.name());\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":86777,"modified_method":"private void startPipeline() {\r\n\t\tsynchronized (inOrderSegments) {\r\n\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: starting pipelining\");\r\n\r\n\t\t\t_pipelineStartTime = System.currentTimeMillis();\r\n\t\t\tif (SystemConfiguration.PIPELINE_STATS)\r\n\t\t\t\tSystem.out.println(\"plot \"+(System.currentTimeMillis() - _pipelineStartTime)+\" inOrder: \"+inOrderSegments.size() +\" outOfOrder: \"+outOfOrderSegments.size() + \" interests: \"+_sentInterests.size() +\" holes: \"+_holes + \" received: \"+_totalReceived+\" [\"+_baseName+\"].1\"+ \" toProcess \"+incoming.size());\t\t\r\n\r\n\t\t\tlong segmentToGet = -1;\r\n\t\t\tInterest interest = null;\r\n\r\n\t\t\tif(_basePipelineName == null) {\r\n\t\t\t\t_basePipelineName = _baseName.clone();\r\n\t\t\t}\r\n\r\n\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: BaseName for pipeline: {0} base name: {1}\", _basePipelineName, _baseName);\r\n\r\n\t\t\tif (_currentSegment!=null) {\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we already have the first segment...  start from there: {0}\", _currentSegment.name());\r\n\t\t\t\t//we already have the starting segment...\r\n\r\n\t\t\t\t//is the first segment the last one?\r\n\t\t\t\tif (SegmentationProfile.isLastSegment(_currentSegment)) {\r\n\t\t\t\t\t//this is the last segment...  don't pipeline\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we already have the last segment...  don't need to pipeline (returning)\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//this isn't the last segment, start up pipelining...  only ask for next segment to start\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: this isn't the last segment...  need to start up pipelining\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: need to get the first segment: startingSegmentNumber={0}\",_startingSegmentNumber);\r\n\t\t\t}\r\n\r\n\t\t\tsegmentToGet = nextSegmentNumber();\r\n\t\t\t_nextPipelineSegment = segmentToGet;\r\n\t\t\t\r\n\t\t\t//check here if it is an instance of a versioned stream.  if so, and the basename doesn't have a version in it, do not send the interest\r\n\t\t\t\r\n\t\t\tif (this instanceof CCNVersionedInputStream) {\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"this is a versioned stream, skip sending non-versioned interest\");\r\n\t\t\t} else {\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"this is not a versioned stream, go ahead and get the first segment\");\r\n\r\n\t\t\t\tinterest = SegmentationProfile.segmentInterest(_basePipelineName, segmentToGet, _publisher);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tinterest.userTime = System.currentTimeMillis();\r\n\t\t\t\t\t_handle.expressInterest(interest, this);\r\n\t\t\t\t\t_sentInterests.add(interest);\r\n\t\t\t\t\t_lastRequestedPipelineSegment = segmentToGet;\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: expressed interest for segment {0} in startPipeline(): {1}\", segmentToGet, interest);\r\n\t\t\t\t} catch(IOException e) {\r\n\t\t\t\t\t//could not express interest for next segment...  logging the error\r\n\t\t\t\t\tLog.warning(Log.FAC_PIPELINE, \"Failed to express interest for pipelining segments in CCNAbstractInputStream:  Interest = {0}\", interest.name());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"f9251c2615f48c22119a9e18bdeb655019b9459b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void receivePipelineContent(ContentObject co) {\r\n\t\tlong returnedSegment = SegmentationProfile.getSegmentNumber(co.name());\r\n\t\tArrayList<Interest> toRemove = new ArrayList<Interest>();\t\r\n\r\n\t\t//is there a reader ready?\r\n\t\tlong rr;\r\n\t\tsynchronized(readerReady) {\r\n\t\t\trr = Long.parseLong(readerReady);\r\n\t\t}\r\n\t\t//while(rr > -1) {\r\n\t\tif(rr > -1) {\r\n\t\t\t//there is a reader waiting\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: there is a reader waiting, we should wait unless we have their segment\");\r\n\t\t\tif(returnedSegment == rr) {\r\n\t\t\t\t//this is the segment they want, we should just finish\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we are working on their segment...  we should finish!\");\r\n\t\t\t\t//break;\r\n\t\t\t} else {\r\n\t\t\t\tif (haveSegmentBuffered(rr)) {\r\n\t\t\t\t\t//we have their segment\r\n\t\t\t\t\t//this isn't their segment, but the one they want is here. we should defer\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we are deferring until they are done\");\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tinOrderSegments.wait();\r\n\t\t\t\t\t\t//readerReady.wait();\r\n\t\t\t\t\t\tsynchronized(readerReady) {\r\n\t\t\t\t\t\t\trr = Long.parseLong(readerReady);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we can go back to processing\");\r\n\t\t\t\t\t\t//break;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//we don't have their segment, we should keep going\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we don't have their segment, keep processing this one.\");\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t//are we at the last segment?\r\n\t\tsynchronized(inOrderSegments) {\r\n\t\t\tif (SegmentationProfile.isLastSegment(co)) {\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we just got the last segment...\");\r\n\t\t\t\t_lastSegmentNumber = returnedSegment;\r\n\t\t\t}\r\n\t\t\t//}\r\n\t\t\tlong segNum;\r\n\t\t\t//synchronized (_sentInterests) {\r\n\t\t\tfor(Interest i: _sentInterests) {\r\n\t\t\t\tsegNum = SegmentationProfile.getSegmentNumber(i.name());\r\n\t\t\t\tif(segNum == returnedSegment || (_lastSegmentNumber > -1 && segNum > _lastSegmentNumber)) {\r\n\t\t\t\t\tif(Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: cancelling interest for segment \"+SegmentationProfile.getSegmentNumber(i.name())+\" Interest: \"+i);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_handle.cancelInterest(i, this);\r\n\t\t\t\t\ttoRemove.add(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t_sentInterests.removeAll(toRemove);\r\n\t\t\ttoRemove.clear();\r\n\t\t}\r\n\r\n\r\n\t\tsynchronized(inOrderSegments) {\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: received pipeline segment: {0}\", co.name());\r\n\r\n\t\t\t/*\r\n\t\t\tsynchronized(readySegment) {\r\n\t\t\t\t//can we help the reader with a shortcut\r\n\t\t\t\tif (readySegment == null) {\r\n\t\t\t\t\t//need to set the ready segment\r\n\t\t\t\t\tif(inOrderSegments.size() > 0)\r\n\t\t\t\t\t\treadySegment = inOrderSegments.get(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t */\r\n\r\n\t\t\tif (returnedSegment == _nextPipelineSegment) {\r\n\t\t\t\t_totalReceived++;\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we got the segment ({0}) we were expecting!\", returnedSegment);\r\n\t\t\t\tif(waitingSegment!=-1)\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: someone is waiting for segment: {0}\", waitingSegment);\r\n\t\t\t\t//this is the next segment in order\r\n\t\t\t\tinOrderSegments.add(co);\r\n\t\t\t\t_lastInOrderSegment = returnedSegment;\r\n\t\t\t\t//do we have any out of order segments to move over?\r\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: before checking ooos:\" );\r\n\t\t\t\t\tprintSegments();\r\n\t\t\t\t}\r\n\t\t\t\tif (outOfOrderSegments.size() > 0 ) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we have out of order segments to check\");\r\n\r\n\t\t\t\t\t//this was a hole..  cancel its other interests\r\n\r\n\t\t\t\t\twhile (outOfOrderSegments.size() > 0 ) {\r\n\t\t\t\t\t\tif(SegmentationProfile.getSegmentNumber(outOfOrderSegments.get(0).name()) == nextInOrderSegmentNeeded()) {\r\n\t\t\t\t\t\t\t_lastInOrderSegment = SegmentationProfile.getSegmentNumber(outOfOrderSegments.get(0).name());\r\n\t\t\t\t\t\t\tinOrderSegments.add(outOfOrderSegments.remove(0));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t//the first one isn't what we wanted..\r\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we have \"+SegmentationProfile.getSegmentNumber(outOfOrderSegments.get(0).name())+\" but need \"+nextInOrderSegmentNeeded()+\" breaking from loop, we don't have the one we need\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: after checking ooos: \");\r\n\t\t\t\t\tprintSegments();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//if we had out of order segments, we might still want to advance the pipeline...\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we got segment {0} an Out of Order segment...  we were expecting segment {1}\", returnedSegment, _nextPipelineSegment);\r\n\t\t\t\t//this segment is out of order\r\n\t\t\t\t//make sure it wasn't a previous segment that we don't need any more...\r\n\t\t\t\tif (_nextPipelineSegment > returnedSegment) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: this is a previous segment...  drop\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: this is a pipeline segment, add to outOfOrderSegment queue\");\r\n\t\t\t\t\t_totalReceived++;\r\n\t\t\t\t\t_holes++;\r\n\t\t\t\t\tint i = 0;\r\n\t\t\t\t\tfor (ContentObject c:outOfOrderSegments) {\r\n\t\t\t\t\t\tif(returnedSegment < SegmentationProfile.getSegmentNumber(c.name()))\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutOfOrderSegments.add(i, co);\r\n\r\n\t\t\t\t\t//now we have a hole to fill\r\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we got a segment out of order, need to fill a hole at \"+nextInOrderSegmentNeeded());\r\n\t\t\t\t\tattemptHoleFilling(_nextPipelineSegment);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t_nextPipelineSegment = nextInOrderSegmentNeeded();\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: the next segment needed is {0}\", _nextPipelineSegment);\r\n\t\t\tsynchronized(incoming) {\r\n\t\t\t\tprocessingSegment = -1;\r\n\t\t\t}\r\n\r\n\t\t\tif(waitingThread!=null && returnedSegment == waitingSegment) {\r\n\t\t\t\tinOrderSegments.notifyAll();\r\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: notifyAll: min sleep {0}\", (System.currentTimeMillis()-waitSleep));\r\n\t\t\t\ttry {\r\n\t\t\t\t\tinOrderSegments.wait();\r\n\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t//back to me...  keep going\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}","id":86778,"modified_method":"private void receivePipelineContent(ContentObject co) {\r\n\t\tlong returnedSegment = SegmentationProfile.getSegmentNumber(co.name());\r\n\t\tArrayList<Interest> toRemove = new ArrayList<Interest>();\t\r\n\r\n\t\t//is there a reader ready?\r\n\t\tlong rr;\r\n\t\tsynchronized(readerReady) {\r\n\t\t\trr = Long.parseLong(readerReady);\r\n\t\t}\r\n\t\t//while(rr > -1) {\r\n\t\tif(rr > -1) {\r\n\t\t\t//there is a reader waiting\r\n\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: there is a reader waiting, we should wait unless we have their segment\");\r\n\t\t\tif(returnedSegment == rr) {\r\n\t\t\t\t//this is the segment they want, we should just finish\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we are working on their segment...  we should finish!\");\r\n\t\t\t\t//break;\r\n\t\t\t} else {\r\n\t\t\t\tif (haveSegmentBuffered(rr)) {\r\n\t\t\t\t\t//we have their segment\r\n\t\t\t\t\t//this isn't their segment, but the one they want is here. we should defer\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we are deferring until they are done\");\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tinOrderSegments.wait();\r\n\t\t\t\t\t\t//readerReady.wait();\r\n\t\t\t\t\t\tsynchronized(readerReady) {\r\n\t\t\t\t\t\t\trr = Long.parseLong(readerReady);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we can go back to processing\");\r\n\t\t\t\t\t\t//break;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//we don't have their segment, we should keep going\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we don't have their segment, keep processing this one.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t//are we at the last segment?\r\n\t\tsynchronized(inOrderSegments) {\r\n\t\t\tif (SegmentationProfile.isLastSegment(co)) {\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we just got the last segment...\");\r\n\t\t\t\t_lastSegmentNumber = returnedSegment;\r\n\t\t\t}\r\n\t\t\t//}\r\n\t\t\tlong segNum;\r\n\t\t\t//synchronized (_sentInterests) {\r\n\t\t\tfor(Interest i: _sentInterests) {\r\n\t\t\t\tsegNum = SegmentationProfile.getSegmentNumber(i.name());\r\n\t\t\t\tif(segNum == returnedSegment || (_lastSegmentNumber > -1 && segNum > _lastSegmentNumber)) {\r\n\t\t\t\t\tif(Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: cancelling interest for segment \"+SegmentationProfile.getSegmentNumber(i.name())+\" Interest: \"+i);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_handle.cancelInterest(i, this);\r\n\t\t\t\t\ttoRemove.add(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t_sentInterests.removeAll(toRemove);\r\n\t\t\ttoRemove.clear();\r\n\t\t}\r\n\r\n\r\n\t\tsynchronized(inOrderSegments) {\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: received pipeline segment: {0}\", co.name());\r\n\r\n\t\t\t/*\r\n\t\t\tsynchronized(readySegment) {\r\n\t\t\t\t//can we help the reader with a shortcut\r\n\t\t\t\tif (readySegment == null) {\r\n\t\t\t\t\t//need to set the ready segment\r\n\t\t\t\t\tif(inOrderSegments.size() > 0)\r\n\t\t\t\t\t\treadySegment = inOrderSegments.get(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t */\r\n\r\n\t\t\tif (returnedSegment == _nextPipelineSegment) {\r\n\t\t\t\t_totalReceived++;\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we got the segment ({0}) we were expecting!\", returnedSegment);\r\n\t\t\t\tif(waitingSegment!=-1)\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: someone is waiting for segment: {0}\", waitingSegment);\r\n\t\t\t\t//this is the next segment in order\r\n\t\t\t\tinOrderSegments.add(co);\r\n\t\t\t\t_lastInOrderSegment = returnedSegment;\r\n\t\t\t\t//do we have any out of order segments to move over?\r\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: before checking ooos:\" );\r\n\t\t\t\t\tprintSegments();\r\n\t\t\t\t}\r\n\t\t\t\tif (outOfOrderSegments.size() > 0 ) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we have out of order segments to check\");\r\n\r\n\t\t\t\t\t//this was a hole..  cancel its other interests\r\n\r\n\t\t\t\t\twhile (outOfOrderSegments.size() > 0 ) {\r\n\t\t\t\t\t\tif(SegmentationProfile.getSegmentNumber(outOfOrderSegments.get(0).name()) == nextInOrderSegmentNeeded()) {\r\n\t\t\t\t\t\t\t_lastInOrderSegment = SegmentationProfile.getSegmentNumber(outOfOrderSegments.get(0).name());\r\n\t\t\t\t\t\t\tinOrderSegments.add(outOfOrderSegments.remove(0));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t//the first one isn't what we wanted..\r\n\t\t\t\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we have \"+SegmentationProfile.getSegmentNumber(outOfOrderSegments.get(0).name())+\" but need \"+nextInOrderSegmentNeeded()+\" breaking from loop, we don't have the one we need\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO)) {\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: after checking ooos: \");\r\n\t\t\t\t\tprintSegments();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//if we had out of order segments, we might still want to advance the pipeline...\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we got segment {0} an Out of Order segment...  we were expecting segment {1}\", returnedSegment, _nextPipelineSegment);\r\n\t\t\t\t//this segment is out of order\r\n\t\t\t\t//make sure it wasn't a previous segment that we don't need any more...\r\n\t\t\t\tif (_nextPipelineSegment > returnedSegment) {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: this is a previous segment...  drop\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: this is a pipeline segment, add to outOfOrderSegment queue\");\r\n\t\t\t\t\t_totalReceived++;\r\n\t\t\t\t\t_holes++;\r\n\t\t\t\t\tint i = 0;\r\n\t\t\t\t\tfor (ContentObject c:outOfOrderSegments) {\r\n\t\t\t\t\t\tif(returnedSegment < SegmentationProfile.getSegmentNumber(c.name()))\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\toutOfOrderSegments.add(i, co);\r\n\r\n\t\t\t\t\t//now we have a hole to fill\r\n\t\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\r\n\t\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: we got a segment out of order, need to fill a hole at \"+nextInOrderSegmentNeeded());\r\n\t\t\t\t\tattemptHoleFilling(_nextPipelineSegment);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\t_nextPipelineSegment = nextInOrderSegmentNeeded();\r\n\t\t\tif( Log.isLoggable(Log.FAC_PIPELINE, Level.INFO) )\r\n\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: the next segment needed is {0}\", _nextPipelineSegment);\r\n\t\t\tsynchronized(incoming) {\r\n\t\t\t\tprocessingSegment = -1;\r\n\t\t\t}\r\n\r\n\t\t\tif(waitingThread!=null && returnedSegment == waitingSegment) {\r\n\t\t\t\tinOrderSegments.notifyAll();\r\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\r\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: notifyAll: min sleep {0}\", (System.currentTimeMillis()-waitSleep));\r\n\t\t\t\ttry {\r\n\t\t\t\t\tinOrderSegments.wait();\r\n\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t//back to me...  keep going\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}","commit_id":"f9251c2615f48c22119a9e18bdeb655019b9459b","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private int checkCallbacks(ContentName prefix, int segments) {\n\t\tLog.fine(Log.FAC_TEST, \"checking for callbacks:  {0} segments: {1}\", prefix, segments);\n\t\tboolean[] received = (boolean[]) Array.newInstance(boolean.class, segments);\n\t\tArrays.fill(received, false);\n\t\tboolean[]finished = (boolean[]) Array.newInstance(boolean.class, segments);\n\t\tArrays.fill(finished, true);\n\t\tint loopsToTry = (segments * 2) + 20;\n\t\twhile (segments != 0 && loopsToTry > 0) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.warning(Log.FAC_TEST, \"interrupted while waiting for names on callback\");\n\t\t\t}\n\t\t\tsynchronized(callbackNames) {\n\t\t\t\tfor (ContentName n: callbackNames) {\n\t\t\t\t\tif (prefix.isPrefixOf(n)) {\n\t\t\t\t\t\t//this is one of our names\n\t\t\t\t\t\tif ( MetadataProfile.isHeader(n)) {\n\t\t\t\t\t\t\t//this is the header!\n\t\t\t\t\t\t\treceived[segments-1] = true;\n\t\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"got the header\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//this is not the header...  get the segment number\n\t\t\t\t\t\t\treceived[(int) SegmentationProfile.getSegmentNumber(n)] = true;\n\t\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"got segment {0}\", SegmentationProfile.getSegmentNumber(n));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"received: {0} finished: {1}\", Arrays.toString(received), Arrays.toString(finished));\n\t\t\t\t\t\tif (Arrays.equals(received, finished)) {\n\t\t\t\t\t\t\t//all done!\n\t\t\t\t\t\t\tsegments = 0;\n\t\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"got all the segments!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tloopsToTry = loopsToTry - 1;\n\t\t\tLog.fine(Log.FAC_TEST, \"trying to loop again looking for segments\");\n\t\t}\n\t\tLog.fine(Log.FAC_TEST, \"done looping, returning.  outstanding segments = {0}\", segments);\n\t\treturn segments;\n\t}","id":86779,"modified_method":"private int checkCallbacks(ContentName prefix, int segments) {\n\t\tLog.fine(Log.FAC_TEST, \"checking for callbacks:  {0} segments: {1}\", prefix, segments);\n\t\tboolean[] received = (boolean[]) Array.newInstance(boolean.class, segments);\n\t\tArrays.fill(received, false);\n\t\tboolean[]finished = (boolean[]) Array.newInstance(boolean.class, segments);\n\t\tArrays.fill(finished, true);\n\t\tint loopsToTry = (segments * 2) + 20;\n\t\twhile (segments != 0 && loopsToTry > 0) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.warning(Log.FAC_TEST, \"interrupted while waiting for names on callback\");\n\t\t\t}\n\t\t\tsynchronized(callbackNames) {\n\t\t\t\tfor (ContentName n: callbackNames) {\n\t\t\t\t\tif (prefix.isPrefixOf(n)) {\n\t\t\t\t\t\t//this is one of our names\n\t\t\t\t\t\tif ( MetadataProfile.isHeader(n)) {\n\t\t\t\t\t\t\t//this is the header!\n\t\t\t\t\t\t\treceived[segments-1] = true;\n\t\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"got the header\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//this is not the header...  get the segment number\n\t\t\t\t\t\t\treceived[(int) SegmentationProfile.getSegmentNumber(n)] = true;\n\t\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"got segment {0}\", SegmentationProfile.getSegmentNumber(n));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"received: {0} finished: {1}\", Arrays.toString(received), Arrays.toString(finished));\n\t\t\t\t\t\tif (Arrays.equals(received, finished)) {\n\t\t\t\t\t\t\t//all done!\n\t\t\t\t\t\t\tsegments = 0;\n\t\t\t\t\t\t\tLog.fine(Log.FAC_TEST, \"got all the segments!\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tloopsToTry = loopsToTry - 1;\n\t\t\tLog.fine(Log.FAC_TEST, \"trying to loop again looking for segments\");\n\t\t}\n\t\tint outstanding = 0;\n\t\tfor (int i = 0; i < received.length; i++)\n\t\t\tif (!received[i])\n\t\t\t\toutstanding++;\n\t\tLog.fine(Log.FAC_TEST, \"done looping, returning.  outstanding segments = {0}\", outstanding);\n\t\treturn segments;\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SyncRootTree popNext() {\n\t\t\tif (!_nextStack.isEmpty())\n\t\t\t\treturn _nextStack.pop();\n\t\t\treturn null;\n\t\t}","id":86780,"modified_method":"protected SyncTreeEntry popNext() {\n\t\t\tif (!_nextStack.isEmpty()) {\n\t\t\t\tSyncTreeEntry srt =  _nextStack.pop();\nLog.info(\"popping entry with hash: {0}\", Component.printURI(srt._hash));\n\t\t\t\treturn srt;\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected void addNextHash(SyncRootTree srt) {\n\t\t\t_nextHash = srt;\n\t\t}","id":86781,"modified_method":"protected void addNextHash(SyncTreeEntry srt) {\n\t\t\t_nextHash = srt;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t\t * Needs outside synchronization\n\t\t */\n\t\tprotected void nextRound(SyncRootTree srt) {\n\t\t\t_currentRoot = _nextRoot;\n\t\t\t_nextHash = srt;\n\t\t\t_nextRoot = new SyncRootTree(_sliceHash, _decoder);\n\t\t\t_state = SyncCompareState.INIT;\n\t\t\tif (null != _lastHash) {\n\t\t\t\tfor (SyncRootTree tsrt : _hashes.values()) {\n\t\t\t\t\ttsrt.setCurrent(true);\n\t\t\t\t}\n\t\t\t\tpushCurrent(_lastHash);\n\t\t\t}\n\t\t\t_lastHash = _nextHash;\n\t\t}","id":86782,"modified_method":"/**\n\t\t * Needs outside synchronization\n\t\t */\n\t\tprotected void nextRound(SyncTreeEntry srt) {\nLog.info(\"Starting next round with hash: {0}\", Component.printURI(srt.getHash()));\n\t\t\t_currentRoot = _nextRoot;\n\t\t\t_nextHash = srt;\n\t\t\t_nextRoot = new SyncTreeEntry(_sliceHash, _decoder);\n\t\t\t_state = SyncCompareState.INIT;\n\t\t\tif (null != _lastHash) {\n\t\t\t\tfor (SyncTreeEntry tsrt : _hashes.values()) {\n\t\t\t\t\ttsrt.setCurrent(true);\n\t\t\t\t}\n\t\t\t\tpushCurrent(_lastHash);\n\t\t\t}\n\t\t\t_lastHash = _nextHash;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void registerCallback(CCNSyncHandler syncHandler, ConfigSlice slice) throws IOException {\n\t\tsynchronized (callbacks) {\n\t\t\tregisterCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tsynchronized (_rootsByTopo) {\n\t\t\tHashMap<ConfigSlice, SliceReferences> topoMap = _rootsByTopo.get(slice.topo);\n\t\t\tif (null == topoMap) {\n\t\t\t\ttopoMap = new HashMap<ConfigSlice, SliceReferences>();\n\t\t\t}\n\t\t\tbyte[] hash = slice.getHash();\n\t\t\tif (null == topoMap.get(slice)) {\n\t\t\t\tSliceReferences sr = new SliceReferences(slice.topo, hash);\n\t\t\t\ttopoMap.put(slice, sr);\n\t\t\t\t_rootsByTopo.put(slice.topo, topoMap);\n\t\t\t\taddHash(sr, hash);\n\t\t\t}\n\t\t}\n\t\tContentName rootAdvise = new ContentName(slice.topo, Sync.SYNC_ROOT_ADVISE_MARKER, slice.getHash());\n\t\tInterest interest = new Interest(rootAdvise);\n\t\tinterest.scope(1);\n\t\t_handle.expressInterest(interest, this);\n\t\t_handle.registerFilter(rootAdvise, this);\n\t}","id":86783,"modified_method":"public void registerCallback(CCNSyncHandler syncHandler, ConfigSlice slice) throws IOException {\n\t\tsynchronized (callbacks) {\n\t\t\tregisterCallbackInternal(syncHandler, slice);\n\t\t}\n\t\tsynchronized (_rootsByTopo) {\n\t\t\tHashMap<ConfigSlice, SliceReferences> topoMap = _rootsByTopo.get(slice.topo);\n\t\t\tif (null == topoMap) {\n\t\t\t\ttopoMap = new HashMap<ConfigSlice, SliceReferences>();\n\t\t\t}\n\t\t\tbyte[] hash = slice.getHash();\n\t\t\tif (null == topoMap.get(slice)) {\n\t\t\t\tSliceReferences sr = new SliceReferences(slice.topo, hash);\n\t\t\t\ttopoMap.put(slice, sr);\n\t\t\t\t_rootsByTopo.put(slice.topo, topoMap);\n\t\t\t\taddHash(sr, hash);\n\t\t\t}\n\t\t}\n\t\tContentName rootAdvise = new ContentName(slice.topo, Sync.SYNC_ROOT_ADVISE_MARKER, slice.getHash());\n\t\tInterest interest = new Interest(rootAdvise);\n\t\tinterest.scope(1);\n\t\t_handle.registerFilter(rootAdvise, this);\nLog.info(\"Output root advise for {0}\", rootAdvise);\n\t\t_handle.expressInterest(interest, this);\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void run() {\n\t\tArrayList<ContentName> topos = new ArrayList<ContentName>();\t\t\n\t\tdo {\n\t\t\tsynchronized (_timerLock) {\n\t\t\t\t_needToCompare = false;\n\t\t\t}\n\t\t\t\n\t\t\ttopos.clear();\n\t\t\tsynchronized (_rootsByTopo) {\n\t\t\t\tfor (ContentName topo : _rootsByTopo.keySet()) {\n\t\t\t\t\ttopos.add(topo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (ContentName topo : topos) {\n\t\t\t\tArrayList<SliceReferences> slicesForTopo = new ArrayList<SliceReferences>();\n\t\t\t\tsynchronized (_rootsByTopo) {\n\t\t\t\t\tHashMap<ConfigSlice, SliceReferences> hm = _rootsByTopo.get(topo);\n\t\t\t\t\tif (null != hm) {\n\t\t\t\t\t\tfor (ConfigSlice cs : hm.keySet()) {\n\t\t\t\t\t\t\tslicesForTopo.add(hm.get(cs));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (SliceReferences sr : slicesForTopo) {\n\t\t\t\t\tswitch (sr.getState()) {\n\t\t\t\t\tcase BUSY:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase INIT:\n\t\t\t\t\t\tSyncRootTree srt = sr.getNextHash();\n\t\t\t\t\t\tif (null == srt)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tsr.pushNext(srt);\n\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\tcase PRELOAD:\n\t\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t\tif (null == sr.getNextHead()) {\n\t\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (doPreload(topo, sr, sr.getNextHead())) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsr.setState(SyncCompareState.COMPARE);\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\tcase COMPARE:\n\t\t\t\t\t\tdoComparison(topo, sr);\n\t\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t\tif (sr.getState() == SyncCompareState.DONE)\n\t\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Fall through\n\t\t\t\t\tcase DONE:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsynchronized (_timerLock) {\n\t\t\t\tif (!_keepComparing)\n\t\t\t\t\t_needToCompare = true;\n\t\t\t}\n\t\t} while (_keepComparing);\n\t}","id":86784,"modified_method":"public void run() {\n\t\ttry {\n\t\t\tArrayList<ContentName> topos = new ArrayList<ContentName>();\t\t\n\t\t\tdo {\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t_needToCompare = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttopos.clear();\n\t\t\t\tsynchronized (_rootsByTopo) {\n\t\t\t\t\tfor (ContentName topo : _rootsByTopo.keySet()) {\n\t\t\t\t\t\ttopos.add(topo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (ContentName topo : topos) {\n\t\t\t\t\tArrayList<SliceReferences> slicesForTopo = new ArrayList<SliceReferences>();\n\t\t\t\t\tsynchronized (_rootsByTopo) {\n\t\t\t\t\t\tHashMap<ConfigSlice, SliceReferences> hm = _rootsByTopo.get(topo);\n\t\t\t\t\t\tif (null != hm) {\n\t\t\t\t\t\t\tfor (ConfigSlice cs : hm.keySet()) {\n\t\t\t\t\t\t\t\tslicesForTopo.add(hm.get(cs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (SliceReferences sr : slicesForTopo) {\n\t\t\t\t\t\tswitch (sr.getState()) {\n\t\t\t\t\t\tcase BUSY:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INIT:\n\t\t\t\t\t\t\tSyncTreeEntry srt = sr.getNextHash();\n\t\t\t\t\t\t\tif (null == srt)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tsr.pushNext(srt);\n\t\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase PRELOAD:\n\t\t\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t\t\tif (null == sr.getNextHead()) {\n\t\t\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (doPreload(topo, sr, sr.getNextHead())) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsr.setState(SyncCompareState.COMPARE);\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase COMPARE:\n\t\t\t\t\t\t\tdoComparison(topo, sr);\n\t\t\t\t\t\t\t// Fall through\n\t\t\t\t\t\tcase DONE:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\t\t\t\t_keepComparing = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (_timerLock) {\n\t\t\t\t\tif (!_keepComparing)\n\t\t\t\t\t\t_needToCompare = true;\n\t\t\t\t}\n\t\t\t} while (_keepComparing);\n\t\t} catch (Exception ex) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, ex);} \t\n\t\t  catch (Error er) {Log.logStackTrace(Log.FAC_SYNC, Level.WARNING, er);} \n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SyncRootTree popCurrent() {\n\t\t\tif (!_currentStack.isEmpty())\n\t\t\t\treturn _currentStack.pop();\n\t\t\treturn null;\n\t\t}","id":86785,"modified_method":"protected SyncTreeEntry popCurrent() {\n\t\t\tif (!_currentStack.isEmpty())\n\t\t\t\treturn _currentStack.pop();\n\t\t\treturn null;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t\t * Must be synchronized by caller\n\t\t */\n\t\tprotected void addHash(byte[] hash, SyncRootTree srt) {\n\t\t\t_hashes.put(hash, srt);\n\t\t}","id":86786,"modified_method":"/**\n\t\t * Must be synchronized by caller\n\t\t */\n\t\tprotected void addHash(byte[] hash, SyncTreeEntry srt) {\n\t\t\t_hashes.put(new HashEntry(hash), srt);\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SyncRootTree getNextHash() {\n\t\t\treturn _nextHash;\n\t\t}","id":86787,"modified_method":"protected SyncTreeEntry getNextHash() {\n\t\t\treturn _nextHash;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SliceReferences(ContentName name, byte[] sliceHash) {\n\t\t\t_sliceHash = sliceHash;\n\t\t\t_nextRoot = new SyncRootTree(sliceHash, _decoder);\n\t\t\t_currentRoot = new SyncRootTree(sliceHash, _decoder);\n\t\t\t_hashes.put(sliceHash, _nextRoot);\n\t\t}","id":86788,"modified_method":"protected SliceReferences(ContentName name, byte[] sliceHash) {\n\t\t\t_sliceHash = sliceHash;\n\t\t\t_nextRoot = new SyncTreeEntry(sliceHash, _decoder);\n\t\t\t_currentRoot = new SyncTreeEntry(sliceHash, _decoder);\n\t\t\t_hashes.put(new HashEntry(sliceHash), _nextRoot);\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private SyncRootTree addHash(SliceReferences sr, byte[] hash) {\n\t\tsynchronized (sr) {\n\t\t\tSyncRootTree entry = sr.getByHash(hash);\n\t\t\tif (null == entry) {\n\t\t\t\tentry = new SyncRootTree(hash, _decoder);\n\t\t\t\tsr.addHash(hash, entry);\n\t\t\t}\n\t\t\treturn entry;\n\t\t}\n\t}","id":86789,"modified_method":"private SyncTreeEntry addHash(SliceReferences sr, byte[] hash) {\n\t\tsynchronized (sr) {\n\t\t\tSyncTreeEntry entry = sr.getByHash(new HashEntry(hash));\n\t\t\tif (null == entry) {\n\t\t\t\tentry = new SyncTreeEntry(hash, _decoder);\n\t\t\t\tsr.addHash(hash, entry);\n\t\t\t}\n\t\t\treturn entry;\n\t\t}\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\t\tContentName name = data.name();\n\t\t\tint hashComponent = name.containsWhere(Sync.SYNC_NODE_FETCH_MARKER);\n\t\t\tif (hashComponent < 0 || name.count() < (hashComponent + 1)) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect node content in sync: {0}\", name);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tContentName topo = name.cut(Sync.SYNC_NODE_FETCH_MARKER.getBytes());\n\t\t\tbyte[] sliceHash = name.component(hashComponent + 1);\n\t\t\tbyte[] hash = name.component(hashComponent + 2);\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINE))\n\t\t\t\tLog.fine(Log.FAC_SYNC, \"Saw data from nodefind: hash: {0}\", name);\n\t\t\tSliceReferences sr = getReferencesBySliceHash(topo, sliceHash);\n\t\t\tif (null != sr) {\n\t\t\t\tSyncRootTree srt = genericContentHandler(data, topo, sr, hash);\n\t\t\t\tif (null != srt) {\n\t\t\t\t\tsr.pushNext(srt);\n\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\tkickCompare();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","id":86790,"modified_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\t\tContentName name = data.name();\n\t\t\tint hashComponent = name.containsWhere(Sync.SYNC_NODE_FETCH_MARKER);\n\t\t\tif (hashComponent < 0 || name.count() < (hashComponent + 1)) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect node content in sync: {0}\", name);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tContentName topo = name.cut(Sync.SYNC_NODE_FETCH_MARKER.getBytes());\n\t\t\tbyte[] sliceHash = name.component(hashComponent + 1);\n\t\t\tbyte[] hash = name.component(hashComponent + 2);\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Saw data from nodefind: hash: {0}\", name);\n\t\t\tSliceReferences sr = getReferencesBySliceHash(topo, sliceHash);\n\t\t\tif (null != sr) {\n\t\t\t\tsynchronized (sr) {\n\t\t\t\t\tSyncTreeEntry srt = genericContentHandler(data, topo, sr, hash);\n\t\t\t\t\tif (null != srt) {\n\t\t\t\t\t\tsr.pushNext(srt);\n\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\tkickCompare();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private SyncRootTree genericContentHandler(ContentObject data, ContentName topo, SliceReferences sr, byte[] hash) {\n\t\tSyncRootTree srt = null;\n\t\tsrt = addHash(sr, hash);\n\t\tsrt.setRawContent(data.content());\n\t\tsrt.setPending(false);\n\t\treturn srt;\n\t}","id":86791,"modified_method":"/**\n\t * Caller should synchronize\n\t */\n\tprivate SyncTreeEntry genericContentHandler(ContentObject data, ContentName topo, SliceReferences sr, byte[] hash) {\n\t\tSyncTreeEntry srt = null;\n\t\tsynchronized (sr) {\n\t\t\tsrt = addHash(sr, hash);\n\t\t\tsrt.setRawContent(data.content());\n\t\t\tsrt.setPending(false);\n\t\t}\n\t\treturn srt;\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SyncRootTree getNextHead() {\n\t\t\tif (! _nextStack.isEmpty())\n\t\t\t\treturn _nextStack.lastElement();\n\t\t\treturn null;\n\t\t}","id":86792,"modified_method":"protected SyncTreeEntry getNextHead() {\n\t\t\tif (! _nextStack.isEmpty())\n\t\t\t\treturn _nextStack.lastElement();\n\t\t\treturn null;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected SyncRootTree getCurrentHead() {\n\t\t\tif (! _currentStack.isEmpty())\n\t\t\t\treturn _currentStack.lastElement();\n\t\t\treturn null;\n\t\t}","id":86793,"modified_method":"protected SyncTreeEntry getCurrentHead() {\n\t\t\tif (! _currentStack.isEmpty())\n\t\t\t\treturn _currentStack.lastElement();\n\t\t\treturn null;\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected void pushCurrent(SyncRootTree srt) {\n\t\t\t_currentStack.push(srt);\n\t\t}","id":86794,"modified_method":"protected void pushCurrent(SyncTreeEntry srt) {\n\t\t\t_currentStack.push(srt);\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void doComparison(ContentName topo, SliceReferences sr) {\n\t\tboolean sawAHash = false;\n\t\tSyncRootTree srt = sr.getNextHead();\n\t\twhile (null != srt) {\n\t\t\tSyncNodeComposite snc = srt.getNextNode();\n\t\t\tif (null != snc) {\n\t\t\t\tfor (SyncNodeComposite.SyncNodeElement sne : snc.getRefs()) {\n\t\t\t\t\tswitch (sne.getType()) {\n\t\t\t\t\tcase LEAF:\n\t\t\t\t\t\tContentName name = sne.getName().parent();\t// remove digest here\n\t\t\t\t\t\tHashMap<ConfigSlice, ArrayList<CCNSyncHandler>> tCallbacks = null;\n\t\t\t\t\t\tsynchronized(callbacks) {\n\t\t\t\t\t\t\t// We can't call the callback with locks held so extract what we will call \n\t\t\t\t\t\t\t// under the lock\n\t\t\t\t\t\t\ttCallbacks = new HashMap<ConfigSlice, ArrayList<CCNSyncHandler>>(callbacks.size());\n\t\t\t\t\t\t\tfor (ConfigSlice cs : callbacks.keySet()) {\n\t\t\t\t\t\t\t\ttCallbacks.put(cs, callbacks.get(cs));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (ConfigSlice cs : tCallbacks.keySet()) {\n\t\t\t\t\t\t\tif (cs.prefix.isPrefixOf(name)) {\n\t\t\t\t\t\t\t\tfor (CCNSyncHandler handler: callbacks.get(cs)) {\n\t\t\t\t\t\t\t\t\thandler.handleContentName(cs, name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase HASH:\n\t\t\t\t\t\tsawAHash = true;\n\t\t\t\t\t\tbyte[] hash = sne.getData();\n\t\t\t\t\t\trequestNode(topo, sr, hash);\n\t\t\t\t\t\tLog.info(\"We requested a node\");\n\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsr.popNext();\n\t\t\tsrt = sr.getNextHead();\n\t\t}\n\t\tif (sr.getNextHead()  == null && sr.getState()  == SyncCompareState.COMPARE || !sawAHash)\n\t\t\tsr.setState(SyncCompareState.DONE);\n\t}","id":86795,"modified_method":"private void doComparison(ContentName topo, SliceReferences sr) {\nLog.info(\"started compare\");\n\t\tSyncTreeEntry srt = null;\n\t\tsynchronized (sr) {\n\t\t\tsrt = sr.getNextHead();\n\t\t}\n\t\twhile (null != srt) {\n\t\t\tboolean lastPos = false;\n\t\t\tSyncNodeComposite.SyncNodeElement sne = null;\n\t\t\tsynchronized (sr) {\n\t\t\t\tSyncNodeComposite snc = srt.getNode();\n\t\t\t\tif (null != snc) {\n\t\t\t\t\tsne = srt.getCurrentElement();\n\t\t\t\t\tif (null == sne)\n\t\t\t\t\t\tlastPos = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!lastPos) {\n\t\t\t\tif (null != sne) {\nLog.info(\"Comparing hash for {0}, type is {1}\", Component.printURI(srt.getHash()), sne.getType());\n\t\t\t\t\tswitch (sne.getType()) {\n\t\t\t\t\tcase LEAF:\n\t\t\t\t\t\tContentName name = sne.getName().parent();\t// remove digest here\n\t\t\t\t\t\tHashMap<ConfigSlice, ArrayList<CCNSyncHandler>> tCallbacks = null;\n\t\t\t\t\t\tsynchronized(callbacks) {\n\t\t\t\t\t\t\t// We can't call the callback with locks held so extract what we will call \n\t\t\t\t\t\t\t// under the lock\n\t\t\t\t\t\t\ttCallbacks = new HashMap<ConfigSlice, ArrayList<CCNSyncHandler>>(callbacks.size());\n\t\t\t\t\t\t\tfor (ConfigSlice cs : callbacks.keySet()) {\n\t\t\t\t\t\t\t\tArrayList<CCNSyncHandler> tal = new ArrayList<CCNSyncHandler>();\n\t\t\t\t\t\t\t\tfor (CCNSyncHandler csh : callbacks.get(cs)) {\n\t\t\t\t\t\t\t\t\ttal.add(csh);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttCallbacks.put(cs, tal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (ConfigSlice cs : tCallbacks.keySet()) {\n\t\t\t\t\t\t\tif (cs.prefix.isPrefixOf(name)) {\n\t\t\t\t\t\t\t\tfor (CCNSyncHandler handler: tCallbacks.get(cs)) {\n\t\t\t\t\t\t\t\t\thandler.handleContentName(cs, name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase HASH:\n\t\t\t\t\t\tif (requestNode(topo, sr, sne.getData())) {\n\tLog.info(\"requested from compare\");\n\t\t\t\t\t\t\tsynchronized (sr) {\n\t\t\t\t\t\t\t\tsr.setState(SyncCompareState.PRELOAD);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.info(\"No data for {0}\", Component.printURI(srt.getHash()));\n\t\t\t\t\trequestNode(topo, sr, srt.getHash());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsynchronized (sr) {\n\t\t\t\tsrt.incPos();\n\t\t\t\twhile (null != srt && srt.lastPos()) {\n\t\t\t\t\tsr.popNext();\n\t\t\t\t\tsrt = sr.getNextHead();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsynchronized (sr) {\n\t\t\tif (sr.getState() == SyncCompareState.COMPARE)\n\t\t\t\tsr.setState(SyncCompareState.DONE);\n\t\t}\nLog.info(\"Exited 1 and status was: {0}\", sr.getState());\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private boolean requestNode(ContentName topo, SliceReferences sr, byte[] hash) {\n\t\tboolean ret = false;\n\t\tSyncRootTree tsrt = addHash(sr, hash);\n\t\tif (tsrt.getNextNode() == null && !tsrt.getPending()) {\n\t\t\ttsrt.setPending(true);\n\t\t\tret = getHash(topo, sr.getSliceHash(), hash);\n\t\t\tif (ret)\n\t\t\t\tsr.pushNext(tsrt);\n\t\t}\n\t\treturn ret;\n\t}","id":86796,"modified_method":"/**\n\t * \n\t * @param topo\n\t * @param sr\n\t * @param hash\n\t * @return true if request made\n\t */\n\tprivate boolean requestNode(ContentName topo, SliceReferences sr, byte[] hash) {\n\t\tboolean ret = false;\n\t\tsynchronized (sr) {\n\t\t\tSyncTreeEntry tsrt = addHash(sr, hash);\n\t\t\tif (tsrt.getNode() == null && !tsrt.getPending()) {\n\t\t\t\ttsrt.setPending(true);\n\t\t\t\tLog.info(\"requesting node for hash: {0}\", Component.printURI(hash));\n\t\t\t\tret = getHash(topo, sr.getSliceHash(), hash);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * \n\t * @param sr\n\t * @param topo\n\t * @param srt\n\t * @return false if no preloads requested\n\t */\n\tprivate boolean doPreload(ContentName topo, SliceReferences sr, SyncRootTree srt) {\n\t\tSyncNodeComposite snc = srt.getNextNode();\n\t\tBoolean ret = false;\n\t\tif (null != snc) {\n\t\t\tfor (SyncNodeElement sne : snc.getRefs()) {\n\t\t\t\tif (sne.getType() == SyncNodeType.HASH) {\n\t\t\t\t\tbyte[] hash = sne.getData();\n\t\t\t\t\tLog.info(\"Preload requested something\");\n\t\t\t\t\tret = requestNode(topo, sr, hash);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","id":86797,"modified_method":"/**\n\t * \n\t * @param sr\n\t * @param topo\n\t * @param srt\n\t * @return false if no preloads requested\n\t */\n\tprivate boolean doPreload(ContentName topo, SliceReferences sr, SyncTreeEntry srt) {\n\t\tBoolean ret = false;\n\t\tsynchronized (sr) {\n\t\t\tSyncNodeComposite snc = srt.getNode();\n\t\t\tif (null != snc) {\n\t\t\t\tfor (SyncNodeElement sne : snc.getRefs()) {\n\t\t\t\t\tif (sne.getType() == SyncNodeType.HASH) {\n\t\t\t\t\t\tbyte[] hash = sne.getData();\n\t\t\t\t\t\tret = requestNode(topo, sr, hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tContentName name = data.name();\n\t\tint hashComponent = name.containsWhere(Sync.SYNC_ROOT_ADVISE_MARKER);\n\t\tif (hashComponent < 0) {\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect content in sync: {0}\", name);\n\t\t\treturn null;\n\t\t}\n\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.FINE))\n\t\t\tLog.fine(Log.FAC_SYNC, \"Saw new content from sync: {0}\", name);\n\t\tContentName topo = name.cut(Sync.SYNC_ROOT_ADVISE_MARKER.getBytes());\n\t\tbyte[] hash = name.component(hashComponent + 1);\n\t\tSliceReferences sr = getReferencesBySliceHash(topo, hash);\n\t\tif (null != sr) {\n\t\t\tSyncRootTree srt = null;\n\t\t\tsynchronized (sr) {\n\t\t\t\tsrt = genericContentHandler(data, topo, sr, hash);\n\t\t\t\tif (null != srt) {\n\t\t\t\t\tif (sr.getState() == SyncCompareState.DONE) {\n\t\t\t\t\t\tsr.nextRound(srt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null != srt)\n\t\t\t\tkickCompare();\t// Don't want to do this inside lock\n\t\t}\n\t\treturn null;\n\t}","id":86798,"modified_method":"public Interest handleContent(ContentObject data, Interest interest) {\n\t\tContentName name = data.name();\n\t\tint hashComponent = name.containsWhere(Sync.SYNC_ROOT_ADVISE_MARKER);\n\t\tif (hashComponent < 0) {\n\t\t\tif (Log.isLoggable(Log.FAC_SYNC, Level.INFO))\n\t\t\t\tLog.info(Log.FAC_SYNC, \"Received incorrect content in sync: {0}\", name);\n\t\t\treturn null;\n\t\t}\n\t\tLog.info(Log.FAC_SYNC, \"Saw new content from sync: {0}\", name);\n\t\tContentName topo = name.cut(Sync.SYNC_ROOT_ADVISE_MARKER.getBytes());\n\t\tbyte[] hash = name.component(hashComponent + 1);\n\t\tSliceReferences sr = getReferencesBySliceHash(topo, hash);\n\t\tif (null != sr) {\n\t\t\tSyncTreeEntry srt = null;\n\t\t\tsynchronized (sr) {\n\t\t\t\tsrt = genericContentHandler(data, topo, sr, hash);\n\t\t\t\tif (null != srt) {\n\t\t\t\t\tif (sr.getState() == SyncCompareState.DONE) {\n\t\t\t\t\t\tsr.nextRound(srt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (null != srt)\n\t\t\t\tkickCompare();\t// Don't want to do this inside lock\n\t\t}\n\t\treturn null;\n\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected void pushNext(SyncRootTree srt) {\n\t\t\t_nextStack.push(srt);\n\t\t}","id":86799,"modified_method":"protected void pushNext(SyncTreeEntry srt) {\nLog.info(\"pushing entry with hash: {0}\", Component.printURI(srt._hash));\n\t\t\t_nextStack.push(srt);\n\t\t}","commit_id":"22209a92c7755069f114e7c60bd789bd7304e012","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected ApiDiscoveryServiceImpl() {\n        super();\n        for (RoleType roleType: RoleType.values())\n            _roleTypeDiscoveryResponseListMap.put(roleType, new ArrayList<ApiDiscoveryResponse>());\n        cacheListApiResponse();\n    }","id":86800,"modified_method":"protected ApiDiscoveryServiceImpl() {\n        super();\n        if (_roleTypeDiscoveryResponseListMap == null) {\n            long startTime = System.nanoTime();\n            _roleTypeDiscoveryResponseListMap = new HashMap<RoleType, List<ApiDiscoveryResponse>>();\n            for (RoleType roleType: RoleType.values())\n                _roleTypeDiscoveryResponseListMap.put(roleType, new ArrayList<ApiDiscoveryResponse>());\n            cacheResponseMap();\n            long endTime = System.nanoTime();\n            s_logger.info(\"Api Discovery Service: Annotation, docstrings, api relation graph processed in \" + (endTime - startTime) / 1000000.0 + \" ms\");\n        }\n    }","commit_id":"86a77e29dc26fee1bb2169a9a1424bdd4e52f65e","url":"https://github.com/apache/cloudstack"},{"original_method":"private void cacheListApiResponse() {\n        Set<Class<?>> cmdClasses = ReflectUtil.getClassesWithAnnotation(APICommand.class,\n                new String[]{\"org.apache.cloudstack.api\", \"com.cloud.api\"});\n\n        for(Class<?> cmdClass: cmdClasses) {\n            APICommand apiCmdAnnotation = cmdClass.getAnnotation(APICommand.class);\n            if (apiCmdAnnotation == null)\n                apiCmdAnnotation = cmdClass.getSuperclass().getAnnotation(APICommand.class);\n            if (apiCmdAnnotation == null\n                    || !apiCmdAnnotation.includeInApiDoc()\n                    || apiCmdAnnotation.name().isEmpty())\n                continue;\n\n            String apiName = apiCmdAnnotation.name();\n            ApiDiscoveryResponse response = new ApiDiscoveryResponse();\n            response.setName(apiName);\n            response.setDescription(apiCmdAnnotation.description());\n            response.setSince(apiCmdAnnotation.since());\n\n            Field[] fields = ReflectUtil.getAllFieldsForClass(cmdClass,\n                    new Class<?>[] {BaseCmd.class, BaseAsyncCmd.class, BaseAsyncCreateCmd.class});\n\n            boolean isAsync = ReflectUtil.isCmdClassAsync(cmdClass,\n                    new Class<?>[] {BaseAsyncCmd.class, BaseAsyncCreateCmd.class});\n\n            response.setAsync(isAsync);\n\n            for(Field field: fields) {\n                Parameter parameterAnnotation = field.getAnnotation(Parameter.class);\n                if (parameterAnnotation != null\n                        && parameterAnnotation.expose()\n                        && parameterAnnotation.includeInApiDoc()) {\n\n                    ApiParameterResponse paramResponse = new ApiParameterResponse();\n                    paramResponse.setName(parameterAnnotation.name());\n                    paramResponse.setDescription(parameterAnnotation.description());\n                    paramResponse.setType(parameterAnnotation.type().toString());\n                    paramResponse.setLength(parameterAnnotation.length());\n                    paramResponse.setRequired(parameterAnnotation.required());\n                    paramResponse.setSince(parameterAnnotation.since());\n                    response.addParam(paramResponse);\n                }\n            }\n            response.setObjectName(\"apis\");\n            _apiNameDiscoveryResponseMap.put(apiName, response);\n        }\n    }","id":86801,"modified_method":"private void cacheResponseMap() {\n        Set<Class<?>> cmdClasses = ReflectUtil.getClassesWithAnnotation(APICommand.class,\n                new String[]{\"org.apache.cloudstack.api\", \"com.cloud.api\"});\n\n        Map<String, List<String>> responseApiNameListMap = new HashMap<String, List<String>>();\n\n        for(Class<?> cmdClass: cmdClasses) {\n            APICommand apiCmdAnnotation = cmdClass.getAnnotation(APICommand.class);\n            if (apiCmdAnnotation == null)\n                apiCmdAnnotation = cmdClass.getSuperclass().getAnnotation(APICommand.class);\n            if (apiCmdAnnotation == null\n                    || !apiCmdAnnotation.includeInApiDoc()\n                    || apiCmdAnnotation.name().isEmpty())\n                continue;\n\n            String apiName = apiCmdAnnotation.name();\n            String responseName = apiCmdAnnotation.responseObject().getName();\n            if (!responseName.contains(\"SuccessResponse\")) {\n                if (!responseApiNameListMap.containsKey(responseName))\n                    responseApiNameListMap.put(responseName, new ArrayList<String>());\n                responseApiNameListMap.get(responseName).add(apiName);\n            }\n            ApiDiscoveryResponse response = new ApiDiscoveryResponse();\n            response.setName(apiName);\n            response.setDescription(apiCmdAnnotation.description());\n            if (!apiCmdAnnotation.since().isEmpty())\n                response.setSince(apiCmdAnnotation.since());\n            response.setRelated(responseName);\n\n            Field[] responseFields = apiCmdAnnotation.responseObject().getDeclaredFields();\n            for(Field responseField: responseFields) {\n                SerializedName serializedName = responseField.getAnnotation(SerializedName.class);\n                if(serializedName != null) {\n                    ApiResponseResponse responseResponse = new ApiResponseResponse();\n                    responseResponse.setName(serializedName.value());\n                    Param param = responseField.getAnnotation(Param.class);\n                    if (param != null)\n                        responseResponse.setDescription(param.description());\n                    responseResponse.setType(responseField.getType().getSimpleName().toLowerCase());\n                    response.addApiResponse(responseResponse);\n                }\n            }\n\n            Field[] fields = ReflectUtil.getAllFieldsForClass(cmdClass,\n                    new Class<?>[] {BaseCmd.class, BaseAsyncCmd.class, BaseAsyncCreateCmd.class});\n\n            boolean isAsync = ReflectUtil.isCmdClassAsync(cmdClass,\n                    new Class<?>[] {BaseAsyncCmd.class, BaseAsyncCreateCmd.class});\n\n            response.setAsync(isAsync);\n\n            for(Field field: fields) {\n                Parameter parameterAnnotation = field.getAnnotation(Parameter.class);\n                if (parameterAnnotation != null\n                        && parameterAnnotation.expose()\n                        && parameterAnnotation.includeInApiDoc()) {\n\n                    ApiParameterResponse paramResponse = new ApiParameterResponse();\n                    paramResponse.setName(parameterAnnotation.name());\n                    paramResponse.setDescription(parameterAnnotation.description());\n                    paramResponse.setType(parameterAnnotation.type().toString().toLowerCase());\n                    paramResponse.setLength(parameterAnnotation.length());\n                    paramResponse.setRequired(parameterAnnotation.required());\n                    if (!parameterAnnotation.since().isEmpty())\n                        paramResponse.setSince(parameterAnnotation.since());\n                    paramResponse.setRelated(parameterAnnotation.entityType()[0].getName());\n                    response.addParam(paramResponse);\n                }\n            }\n            response.setObjectName(\"api\");\n            _apiNameDiscoveryResponseMap.put(apiName, response);\n        }\n\n        for (String apiName: _apiNameDiscoveryResponseMap.keySet()) {\n            ApiDiscoveryResponse response = _apiNameDiscoveryResponseMap.get(apiName);\n            Set<ApiParameterResponse> processedParams = new HashSet<ApiParameterResponse>();\n            for (ApiParameterResponse param: response.getParams()) {\n                if (responseApiNameListMap.containsKey(param.getRelated())) {\n                    List<String> relatedApis = responseApiNameListMap.get(param.getRelated());\n                    param.setRelated(StringUtils.join(relatedApis, \",\"));\n                } else {\n                    param.setRelated(null);\n                }\n                processedParams.add(param);\n            }\n            response.setParams(processedParams);\n\n            if (responseApiNameListMap.containsKey(response.getRelated())) {\n                List<String> relatedApis = responseApiNameListMap.get(response.getRelated());\n                relatedApis.remove(apiName);\n                response.setRelated(StringUtils.join(relatedApis, \",\"));\n            } else {\n                response.setRelated(null);\n            }\n            _apiNameDiscoveryResponseMap.put(apiName, response);\n        }\n    }","commit_id":"86a77e29dc26fee1bb2169a9a1424bdd4e52f65e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ListResponse<? extends BaseResponse> listApis(RoleType roleType) {\n        // Creates roles based response list cache the first time listApis is called\n        // Due to how adapters work, this cannot be done when mgmt loads\n        if (_apiNameRoleTypeListMap == null) {\n            _apiNameRoleTypeListMap = getApiNameRoleTypeListMap();\n            for (Map.Entry<String, List<RoleType>> entry: _apiNameRoleTypeListMap.entrySet()) {\n                String apiName = entry.getKey();\n                for (RoleType roleTypeInList: entry.getValue()) {\n                    _roleTypeDiscoveryResponseListMap.get(roleTypeInList).add(\n                            _apiNameDiscoveryResponseMap.get(apiName));\n                }\n            }\n        }\n        ListResponse<ApiDiscoveryResponse> response = new ListResponse<ApiDiscoveryResponse>();\n        response.setResponses(_roleTypeDiscoveryResponseListMap.get(roleType));\n        return response;\n    }","id":86802,"modified_method":"@Override\n    public ListResponse<? extends BaseResponse> listApis(RoleType roleType, String name) {\n        // Creates roles based response list cache the first time listApis is called\n        // Due to how adapters work, this cannot be done when mgmt loads\n        if (_apiNameRoleTypeListMap == null) {\n            long startTime = System.nanoTime();\n            _apiNameRoleTypeListMap = getApiNameRoleTypeListMap();\n            for (Map.Entry<String, List<RoleType>> entry: _apiNameRoleTypeListMap.entrySet()) {\n                String apiName = entry.getKey();\n                for (RoleType roleTypeInList: entry.getValue()) {\n                    _roleTypeDiscoveryResponseListMap.get(roleTypeInList).add(\n                            _apiNameDiscoveryResponseMap.get(apiName));\n                }\n            }\n            long endTime = System.nanoTime();\n            s_logger.info(\"Api Discovery Service: List apis cached in \" + (endTime - startTime) / 1000000.0 + \" ms\");\n        }\n        ListResponse<ApiDiscoveryResponse> response = new ListResponse<ApiDiscoveryResponse>();\n        if (name != null) {\n            if (!_apiNameDiscoveryResponseMap.containsKey(name))\n                return null;\n\n             List<ApiDiscoveryResponse> singleResponse = new ArrayList<ApiDiscoveryResponse>();\n            singleResponse.add(_apiNameDiscoveryResponseMap.get(name));\n            response.setResponses(singleResponse);\n\n        } else {\n            response.setResponses(_roleTypeDiscoveryResponseListMap.get(roleType));\n        }\n        return response;\n    }","commit_id":"86a77e29dc26fee1bb2169a9a1424bdd4e52f65e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() throws ServerApiException {\n        if (_apiDiscoveryService != null) {\n            Account caller = UserContext.current().getCaller();\n            RoleType roleType = _accountService.getRoleType(UserContext.current().getCaller());\n            ListResponse<ApiDiscoveryResponse> response = (ListResponse<ApiDiscoveryResponse>) _apiDiscoveryService.listApis(roleType);\n            if (response == null) {\n                throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Api Discovery plugin was unable to find and process any apis\");\n            }\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        }\n    }","id":86803,"modified_method":"@Override\n    public void execute() throws ServerApiException {\n        if (_apiDiscoveryService != null) {\n            RoleType roleType = _accountService.getRoleType(UserContext.current().getCaller());\n            ListResponse<ApiDiscoveryResponse> response = (ListResponse<ApiDiscoveryResponse>) _apiDiscoveryService.listApis(roleType, name);\n            if (response == null) {\n                throw new ServerApiException(BaseCmd.INTERNAL_ERROR, \"Api Discovery plugin was unable to find an api by that name or process any apis\");\n            }\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        }\n    }","commit_id":"86a77e29dc26fee1bb2169a9a1424bdd4e52f65e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void create() {\n        if (getSourceCidrList() != null) {\n            String guestCidr = _networkService.getNetwork(getNetworkId()).getCidr();\n\n            for (String cidr : getSourceCidrList()) {\n                if (!NetUtils.isValidCIDR(cidr)) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Source cidrs formatting error \" + cidr);\n                }\n                if (cidr.equals(NetUtils.ALL_CIDRS)) {\n                    continue;\n                }\n                if (!NetUtils.isNetworkAWithinNetworkB(cidr, guestCidr)) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, cidr + \" is not within the guest cidr \" + guestCidr);\n                }\n            }\n        }\n        if (getProtocol().equalsIgnoreCase(NetUtils.ALL_PROTO)) {\n            if (getSourcePortStart() != null && getSourcePortEnd() != null) {\n                throw new InvalidParameterValueException(\"Do not pass ports to protocol ALL, porotocol ALL do not require ports. Unable to create \" +\n                    \"firewall rule for the network id=\" + networkId);\n            }\n        }\n\n        if (getVpcId() != null) {\n                throw new  InvalidParameterValueException(\"Unable to create firewall rule for the network id=\" + networkId +\n                        \" as firewall egress rule can be created only for non vpc networks.\");\n            }\n\n        try {\n            FirewallRule result = _firewallService.createEgressFirewallRule(this);\n            setEntityId(result.getId());\n            setEntityUuid(result.getUuid());\n        } catch (NetworkRuleConflictException ex) {\n            s_logger.info(\"Network rule conflict: \" + ex.getMessage());\n            s_logger.trace(\"Network Rule Conflict: \", ex);\n            throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, ex.getMessage());\n        }\n    }","id":86804,"modified_method":"@Override\n    public void create() {\n        if (getSourceCidrList() != null) {\n            String guestCidr = _networkService.getNetwork(getNetworkId()).getCidr();\n\n            for (String cidr : getSourceCidrList()) {\n                if (!NetUtils.isValidCIDR(cidr)) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, \"Source cidrs formatting error \" + cidr);\n                }\n                if (cidr.equals(NetUtils.ALL_CIDRS)) {\n                    continue;\n                }\n                if (!NetUtils.isNetworkAWithinNetworkB(cidr, guestCidr)) {\n                    throw new ServerApiException(ApiErrorCode.PARAM_ERROR, cidr + \" is not within the guest cidr \" + guestCidr);\n                }\n            }\n        }\n        if (getProtocol().equalsIgnoreCase(NetUtils.ALL_PROTO)) {\n            if (getSourcePortStart() != null && getSourcePortEnd() != null) {\n                throw new InvalidParameterValueException(\"Do not pass ports to protocol ALL, porotocol ALL do not require ports. Unable to create \" +\n                    \"firewall rule for the network id=\" + networkId);\n            }\n        }\n\n        if (getVpcId() != null) {\n                throw new  InvalidParameterValueException(\"Unable to create firewall rule for the network id=\" + networkId +\n                        \" as firewall egress rule can be created only for non vpc networks.\");\n            }\n\n        try {\n            FirewallRule result = _firewallService.createEgressFirewallRule(this);\n            if (result != null) {\n                setEntityId(result.getId());\n                setEntityUuid(result.getUuid());\n            }\n        } catch (NetworkRuleConflictException ex) {\n            s_logger.info(\"Network rule conflict: \" + ex.getMessage());\n            s_logger.trace(\"Network Rule Conflict: \", ex);\n            throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, ex.getMessage());\n        }\n    }","commit_id":"cae4124dc66a6d7b962f5d57dfe3afb861dacbc4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() {\n        Pair<List<? extends FirewallRule>, Integer> result = _firewallService.listFirewallRules(this);\n        ListResponse<FirewallResponse> response = new ListResponse<FirewallResponse>();\n        List<FirewallResponse> fwResponses = new ArrayList<FirewallResponse>();\n\n        for (FirewallRule fwRule : result.first()) {\n            FirewallResponse ruleData = _responseGenerator.createFirewallResponse(fwRule);\n            ruleData.setObjectName(\"firewallrule\");\n            fwResponses.add(ruleData);\n        }\n        response.setResponses(fwResponses, result.second());\n        response.setResponseName(getCommandName());\n        setResponseObject(response);\n    }","id":86805,"modified_method":"@Override\n    public void execute() {\n        Pair<List<? extends FirewallRule>, Integer> result = _firewallService.listFirewallRules(this);\n        ListResponse<FirewallResponse> response = new ListResponse<FirewallResponse>();\n        List<FirewallResponse> fwResponses = new ArrayList<FirewallResponse>();\n\n        if (result != null) {\n            for (FirewallRule fwRule : result.first()) {\n                FirewallResponse ruleData = _responseGenerator.createFirewallResponse(fwRule);\n                ruleData.setObjectName(\"firewallrule\");\n                fwResponses.add(ruleData);\n            }\n            response.setResponses(fwResponses, result.second());\n        }\n        response.setResponseName(getCommandName());\n        setResponseObject(response);\n    }","commit_id":"cae4124dc66a6d7b962f5d57dfe3afb861dacbc4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() throws ResourceUnavailableException, ResourceAllocationException, ConcurrentOperationException, InsufficientCapacityException {\n\n        try {\n            List<? extends Nic> results = _networkService.listNics(this);\n            ListResponse<NicResponse> response = new ListResponse<NicResponse>();\n            List<NicResponse> resList = new ArrayList<NicResponse>(results.size());\n            for (Nic r : results) {\n                NicResponse resp = _responseGenerator.createNicResponse(r);\n                resp.setObjectName(\"nic\");\n                resList.add(resp);\n            }\n            response.setResponses(resList);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n\n        } catch (Exception e) {\n            s_logger.warn(\"Failed to list secondary ip address per nic \");\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());\n        }\n    }","id":86806,"modified_method":"@Override\n    public void execute() throws ResourceUnavailableException, ResourceAllocationException, ConcurrentOperationException, InsufficientCapacityException {\n\n        try {\n            List<? extends Nic> results = _networkService.listNics(this);\n            ListResponse<NicResponse> response = new ListResponse<NicResponse>();\n            List<NicResponse> resList = null;\n            if (results != null) {\n                resList = new ArrayList<NicResponse>(results.size());\n                for (Nic r : results) {\n                    NicResponse resp = _responseGenerator.createNicResponse(r);\n                    resp.setObjectName(\"nic\");\n                    resList.add(resp);\n                }\n                response.setResponses(resList);\n            }\n            response.setResponses(resList);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n\n        } catch (Exception e) {\n            s_logger.warn(\"Failed to list secondary ip address per nic \");\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage());\n        }\n    }","commit_id":"cae4124dc66a6d7b962f5d57dfe3afb861dacbc4","url":"https://github.com/apache/cloudstack"},{"original_method":"private void upgradeEgressFirewallRules(Connection conn) {\n        PreparedStatement pstmt = null;\n        ResultSet rs = null;\n        ResultSet rsId = null;\n        ResultSet rsNw = null;\n        try {\n            // update the existing ingress rules traffic type\n            pstmt = conn.prepareStatement(\"update `cloud`.`firewall_rules`  set traffic_type='Ingress' where purpose='Firewall' and ip_address_id is \" +\n                \"not null and traffic_type is null\");\n            s_logger.debug(\"Updating firewall Ingress rule traffic type: \" + pstmt);\n            pstmt.executeUpdate();\n\n            pstmt = conn.prepareStatement(\"select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='VirtualRouter' \");\n            rs = pstmt.executeQuery();\n            while (rs.next()) {\n                long netId = rs.getLong(1);\n                //When upgraded from 2.2.14 to 3.0.6 guest_type is updated to Isolated in the 2214to30 clean up sql. clean up executes\n                //after this. So checking for Isolated OR Virtual\n                pstmt = conn.prepareStatement(\"select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR \" +\n                    \"guest_type='Virtual') and traffic_type='Guest' and vpc_id is NULL and \" +\n                    \"(state='implemented' OR state='Shutdown') and id=? \");\n                pstmt.setLong(1, netId);\n                s_logger.debug(\"Getting account_id, domain_id from networks table: \" + pstmt);\n                rsNw = pstmt.executeQuery();\n\n                if (rsNw.next()) {\n                    long accountId = rsNw.getLong(1);\n                    long domainId = rsNw.getLong(2);\n\n                    //Add new rule for the existing networks\n                    s_logger.debug(\"Adding default egress firewall rule for network \" + netId);\n                    pstmt = conn.prepareStatement(\"INSERT INTO firewall_rules (uuid, state, protocol, purpose, account_id, domain_id, network_id, xid, created,  traffic_type) VALUES (?, 'Active', 'all', 'Firewall', ?, ?, ?, ?, now(), 'Egress')\");\n                    pstmt.setString(1, UUID.randomUUID().toString());\n                    pstmt.setLong(2, accountId);\n                    pstmt.setLong(3, domainId);\n                    pstmt.setLong(4, netId);\n                    pstmt.setString(5, UUID.randomUUID().toString());\n                    s_logger.debug(\"Inserting default egress firewall rule \" + pstmt);\n                    pstmt.executeUpdate();\n\n                    pstmt = conn.prepareStatement(\"select id from firewall_rules where protocol='all' and network_id=?\");\n                    pstmt.setLong(1, netId);\n                    rsId = pstmt.executeQuery();\n\n                    long firewallRuleId;\n                    if (rsId.next()) {\n                        firewallRuleId = rsId.getLong(1);\n                        pstmt = conn.prepareStatement(\"insert into firewall_rules_cidrs (firewall_rule_id,source_cidr) values (?, '0.0.0.0/0')\");\n                        pstmt.setLong(1, firewallRuleId);\n                        s_logger.debug(\"Inserting rule for cidr 0.0.0.0/0 for the new Firewall rule id=\" + firewallRuleId + \" with statement \" + pstmt);\n                        pstmt.executeUpdate();\n                    }\n                }\n            }\n        } catch (SQLException e) {\n            throw new CloudRuntimeException(\"Unable to set egress firewall rules \", e);\n        } finally {\n            try {\n                if (rs != null) {\n                    rs.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (SQLException e) {\n            }\n        }\n    }","id":86807,"modified_method":"private void upgradeEgressFirewallRules(Connection conn) {\n\n        // update the existing ingress rules traffic type\n        try (PreparedStatement updateNwpstmt = conn.prepareStatement(\"update `cloud`.`firewall_rules`  set traffic_type='Ingress' where purpose='Firewall' and ip_address_id is \" +\n                \"not null and traffic_type is null\");)\n        {\n            updateNwpstmt.executeUpdate();\n            s_logger.debug(\"Updating firewall Ingress rule traffic type: \" + updateNwpstmt);\n        } catch (SQLException e) {\n            throw new CloudRuntimeException(\"Unable to update ingress firewall rules \", e);\n        }\n\n\n        try (PreparedStatement vrNwpstmt = conn.prepareStatement(\"select network_id FROM `cloud`.`ntwk_service_map` where service='Firewall' and provider='VirtualRouter' \");\n             ResultSet vrNwsRs = vrNwpstmt.executeQuery();\n        ) {\n            while (vrNwsRs.next()) {\n                long netId = vrNwsRs.getLong(1);\n                //When upgraded from 2.2.14 to 3.0.6 guest_type is updated to Isolated in the 2214to30 clean up sql. clean up executes\n                //after this. So checking for Isolated OR Virtual\n                try (PreparedStatement NwAcctDomIdpstmt = conn.prepareStatement(\"select account_id, domain_id FROM `cloud`.`networks` where (guest_type='Isolated' OR \" +\n                        \"guest_type='Virtual') and traffic_type='Guest' and vpc_id is NULL and \" +\n                        \"(state='implemented' OR state='Shutdown') and id=? \"); ) {\n                    NwAcctDomIdpstmt.setLong(1, netId);\n\n                    try (ResultSet NwAcctDomIdps = NwAcctDomIdpstmt.executeQuery();) {\n                        s_logger.debug(\"Getting account_id, domain_id from networks table: \" + NwAcctDomIdpstmt);\n\n                        if (NwAcctDomIdps.next()) {\n                            long accountId = NwAcctDomIdps.getLong(1);\n                            long domainId = NwAcctDomIdps.getLong(2);\n                            //Add new rule for the existing networks\n                            s_logger.debug(\"Adding default egress firewall rule for network \" + netId);\n                            try (PreparedStatement fwRulespstmt = conn.prepareStatement(\"INSERT INTO firewall_rules \"+\n                                    \" (uuid, state, protocol, purpose, account_id, domain_id, network_id, xid, created,\"\n                                    + \" traffic_type) VALUES (?, 'Active', 'all', 'Firewall', ?, ?, ?, ?, now(), \"\n                                 +\"'Egress')\");\n                            ) {\n                            fwRulespstmt.setString(1, UUID.randomUUID().toString());\n                            fwRulespstmt.setLong(2, accountId);\n                            fwRulespstmt.setLong(3, domainId);\n                            fwRulespstmt.setLong(4, netId);\n                            fwRulespstmt.setString(5, UUID.randomUUID().toString());\n                            s_logger.debug(\"Inserting default egress firewall rule \" + fwRulespstmt);\n                            fwRulespstmt.executeUpdate();\n                            }  catch (SQLException e) {\n                                throw new CloudRuntimeException(\"failed to insert default egress firewall rule \", e);\n                            }\n\n                            try (PreparedStatement protoAllpstmt = conn.prepareStatement(\"select id from firewall_rules where protocol='all' and network_id=?\");)\n                            {\n                            protoAllpstmt.setLong(1, netId);\n\n                                try (ResultSet protoAllRs = protoAllpstmt.executeQuery();) {\n                                    long firewallRuleId;\n                                    if (protoAllRs.next()) {\n                                        firewallRuleId = protoAllRs.getLong(1);\n\n                                        try (PreparedStatement fwCidrsPstmt = conn.prepareStatement(\"insert into firewall_rules_cidrs (firewall_rule_id,source_cidr) values (?, '0.0.0.0/0')\");) {\n                                            fwCidrsPstmt.setLong(1, firewallRuleId);\n                                            s_logger.debug(\"Inserting rule for cidr 0.0.0.0/0 for the new Firewall rule id=\" + firewallRuleId + \" with statement \" + fwCidrsPstmt);\n                                            fwCidrsPstmt.executeUpdate();\n                                        }  catch (SQLException e) {\n                                            throw new CloudRuntimeException(\"Unable to set egress firewall rules \", e);\n                                        }\n\n                                    }\n                                } catch (SQLException e) {\n                                    throw new CloudRuntimeException(\"Unable to set egress firewall rules \", e);\n                                }\n\n                            } catch (SQLException e) {\n                                throw new CloudRuntimeException(\"Unable to set egress firewall rules \", e);\n                            }\n\n                        } //if\n                    } catch (SQLException e) {\n                        throw new CloudRuntimeException(\"Unable execute update query \", e);\n                    }\n\n                } catch (SQLException e) {\n                    throw new CloudRuntimeException(\"Unable to get account id domainid of networks \", e);\n                }\n            } //while\n        } catch (SQLException e) {\n            throw new CloudRuntimeException(\"Unable to set egress firewall rules \", e);\n\n        }\n    }","commit_id":"cae4124dc66a6d7b962f5d57dfe3afb861dacbc4","url":"https://github.com/apache/cloudstack"},{"original_method":"/**\n     * Returns the list of publish groups with resources that can be published.<p>\n     * \n     * @return the list of publish groups with resources that can be published\n     */\n    public List<CmsPublishGroup> getPublishGroups() {\n\n        // first look for already published resources\n        Set<CmsResource> published = getAlreadyPublishedResources();\n\n        // then for resources without permission\n        Set<CmsResource> exclude = new HashSet<CmsResource>(published);\n\n        ResourcesAndRelated permissions = getResourcesWithoutPermissions(exclude);\n\n        // and finally for locked resources\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(permissions.getRelatedResources());\n\n        ResourcesAndRelated locked = getBlockingLockedResources(exclude);\n\n        // collect all direct resources that can not be published\n        exclude.clear();\n        exclude.addAll(published);\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(locked.getResources());\n\n        // update the publish list\n        ResourcesAndRelated pubResources = new ResourcesAndRelated();\n        pubResources.getResources().addAll(getPublishResources().getResources());\n        pubResources.getResources().removeAll(exclude);\n        pubResources.getRelatedResources().addAll(getPublishResources().getRelatedResources());\n        pubResources.getRelatedResources().removeAll(permissions.getRelatedResources());\n        pubResources.getRelatedResources().removeAll(locked.getRelatedResources());\n\n        if (getPublishResources().getResources().isEmpty()) {\n            // nothing to do\n            return new ArrayList<CmsPublishGroup>();\n        }\n\n        // sort the list\n        List<CmsResource> sortedResources = new ArrayList<CmsResource>(getPublishResources().getResources());\n        Collections.sort(sortedResources, I_CmsResource.COMPARE_DATE_LAST_MODIFIED);\n\n        // the resources the user can really publish\n        Set<CmsResource> allPubRes = new HashSet<CmsResource>(pubResources.getRelatedResources());\n        allPubRes.addAll(pubResources.getResources());\n\n        List<CmsResource> pubList = new ArrayList<CmsResource>();\n        try {\n            pubList = OpenCms.getPublishManager().getUsersPubList(m_cms);\n        } catch (CmsException e) {\n            // should never happen\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        CmsPublishGroupHelper groupHelper = new CmsPublishGroupHelper(m_locale);\n\n        Map<Long, Integer> daysMap = groupHelper.computeDaysForResources(sortedResources);\n        Map<GroupAge, List<CmsResource>> resourcesByAge = groupHelper.partitionPublishResourcesByAge(\n            sortedResources,\n            daysMap);\n        List<List<CmsResource>> youngGroups = groupHelper.partitionYoungResources(resourcesByAge.get(GroupAge.young));\n        List<List<CmsResource>> mediumGroups = groupHelper.partitionMediumResources(\n            resourcesByAge.get(GroupAge.medium),\n            daysMap);\n        List<CmsResource> oldGroup = resourcesByAge.get(GroupAge.old);\n\n        List<CmsPublishGroup> resultGroups = new ArrayList<CmsPublishGroup>();\n        for (List<CmsResource> groupRes : youngGroups) {\n            List<CmsPublishResource> groupPubRes = new ArrayList<CmsPublishResource>();\n            for (CmsResource res : groupRes) {\n                CmsPublishResource pubRes = createPublishResource(\n                    res,\n                    pubList,\n                    allPubRes,\n                    published,\n                    permissions,\n                    locked);\n                groupPubRes.add(pubRes);\n            }\n            String name = groupHelper.getPublishGroupName(groupRes, GroupAge.young);\n            resultGroups.add(new CmsPublishGroup(name, groupPubRes));\n        }\n\n        for (List<CmsResource> groupRes : mediumGroups) {\n            List<CmsPublishResource> groupPubRes = new ArrayList<CmsPublishResource>();\n            for (CmsResource res : groupRes) {\n                CmsPublishResource pubRes = createPublishResource(\n                    res,\n                    pubList,\n                    allPubRes,\n                    published,\n                    permissions,\n                    locked);\n                groupPubRes.add(pubRes);\n            }\n            String name = groupHelper.getPublishGroupName(groupRes, GroupAge.medium);\n            resultGroups.add(new CmsPublishGroup(name, groupPubRes));\n        }\n\n        if (!oldGroup.isEmpty()) {\n            String oldName = groupHelper.getPublishGroupName(oldGroup, GroupAge.old);\n            List<CmsPublishResource> oldRes = new ArrayList<CmsPublishResource>();\n            for (CmsResource res : oldGroup) {\n                CmsPublishResource pubRes = createPublishResource(\n                    res,\n                    pubList,\n                    allPubRes,\n                    published,\n                    permissions,\n                    locked);\n                oldRes.add(pubRes);\n            }\n            resultGroups.add(new CmsPublishGroup(oldName, oldRes));\n        }\n\n        return resultGroups;\n    }","id":86808,"modified_method":"/**\n     * Returns the list of publish groups with resources that can be published.<p>\n     * \n     * @return the list of publish groups with resources that can be published\n     */\n    public List<CmsPublishGroup> getPublishGroups() {\n\n        // first look for already published resources\n        Set<CmsResource> published = getAlreadyPublishedResources();\n\n        // then for resources without permission\n        Set<CmsResource> exclude = new HashSet<CmsResource>(published);\n\n        ResourcesAndRelated permissions = getResourcesWithoutPermissions(exclude);\n\n        // and finally for locked resources\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(permissions.getRelatedResources());\n\n        ResourcesAndRelated locked = getBlockingLockedResources(exclude);\n\n        // collect all direct resources that can not be published\n        exclude.clear();\n        exclude.addAll(published);\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(locked.getResources());\n\n        // update the publish list\n        ResourcesAndRelated pubResources = new ResourcesAndRelated();\n        pubResources.getResources().addAll(getPublishResources().getResources());\n        pubResources.getResources().removeAll(exclude);\n        pubResources.getRelatedResources().addAll(getPublishResources().getRelatedResources());\n        pubResources.getRelatedResources().removeAll(permissions.getRelatedResources());\n        pubResources.getRelatedResources().removeAll(locked.getRelatedResources());\n\n        if (getPublishResources().getResources().isEmpty()) {\n            // nothing to do\n            return new ArrayList<CmsPublishGroup>();\n        }\n\n        // sort the list\n        List<CmsResource> sortedResources = new ArrayList<CmsResource>(getPublishResources().getResources());\n        Collections.sort(sortedResources, I_CmsResource.COMPARE_DATE_LAST_MODIFIED);\n\n        // the resources the user can really publish\n        Set<CmsResource> allPubRes = new HashSet<CmsResource>(pubResources.getRelatedResources());\n        allPubRes.addAll(pubResources.getResources());\n\n        List<CmsResource> pubList = new ArrayList<CmsResource>();\n        try {\n            long t1 = System.currentTimeMillis();\n            pubList = OpenCms.getPublishManager().getUsersPubList(m_cms);\n            long t2 = System.currentTimeMillis();\n            System.out.println(\"time for reading publish list: \" + (t2 - t1));\n        } catch (CmsException e) {\n            // should never happen\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        CmsPublishGroupHelper groupHelper = new CmsPublishGroupHelper(m_locale);\n\n        Map<Long, Integer> daysMap = groupHelper.computeDaysForResources(sortedResources);\n        Map<GroupAge, List<CmsResource>> resourcesByAge = groupHelper.partitionPublishResourcesByAge(\n            sortedResources,\n            daysMap);\n        List<List<CmsResource>> youngGroups = groupHelper.partitionYoungResources(resourcesByAge.get(GroupAge.young));\n        List<List<CmsResource>> mediumGroups = groupHelper.partitionMediumResources(\n            resourcesByAge.get(GroupAge.medium),\n            daysMap);\n        List<CmsResource> oldGroup = resourcesByAge.get(GroupAge.old);\n\n        List<CmsPublishGroup> resultGroups = new ArrayList<CmsPublishGroup>();\n        for (List<CmsResource> groupRes : youngGroups) {\n            List<CmsPublishResource> groupPubRes = new ArrayList<CmsPublishResource>();\n            for (CmsResource res : groupRes) {\n                CmsPublishResource pubRes = createPublishResource(\n                    res,\n                    pubList,\n                    allPubRes,\n                    published,\n                    permissions,\n                    locked);\n                groupPubRes.add(pubRes);\n            }\n            String name = groupHelper.getPublishGroupName(groupRes, GroupAge.young);\n            resultGroups.add(new CmsPublishGroup(name, groupPubRes));\n        }\n\n        for (List<CmsResource> groupRes : mediumGroups) {\n            List<CmsPublishResource> groupPubRes = new ArrayList<CmsPublishResource>();\n            for (CmsResource res : groupRes) {\n                CmsPublishResource pubRes = createPublishResource(\n                    res,\n                    pubList,\n                    allPubRes,\n                    published,\n                    permissions,\n                    locked);\n                groupPubRes.add(pubRes);\n            }\n            String name = groupHelper.getPublishGroupName(groupRes, GroupAge.medium);\n            resultGroups.add(new CmsPublishGroup(name, groupPubRes));\n        }\n\n        if (!oldGroup.isEmpty()) {\n            String oldName = groupHelper.getPublishGroupName(oldGroup, GroupAge.old);\n            List<CmsPublishResource> oldRes = new ArrayList<CmsPublishResource>();\n            for (CmsResource res : oldGroup) {\n                CmsPublishResource pubRes = createPublishResource(\n                    res,\n                    pubList,\n                    allPubRes,\n                    published,\n                    permissions,\n                    locked);\n                oldRes.add(pubRes);\n            }\n            resultGroups.add(new CmsPublishGroup(oldName, oldRes));\n        }\n\n        return resultGroups;\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Method which is called after the publish list has been received from the server.<p>\n     * \n     * @param groups the groups of the publish list\n     */\n    public void onReceivePublishList(List<CmsPublishGroup> groups) {\n\n        m_publishSelectPanel.setGroups(groups);\n        setPanel(PANEL_SELECT);\n        if (!isVisible()) {\n            center();\n        }\n    }","id":86809,"modified_method":"/**\n     * Method which is called after the publish list has been received from the server.<p>\n     * \n     * @param groups the groups of the publish list\n     */\n    public void onReceivePublishList(List<CmsPublishGroup> groups) {\n\n        m_publishSelectPanel.setGroups(groups, true);\n        setPanel(PANEL_SELECT);\n        if (!isVisible()) {\n            center();\n        }\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a resource bean to this group.<p>\n     * \n     * @param resourceBean the resource bean which should be added\n     * @param indent if true, indent the widget representing the resource bean (for related resources)\n     */\n    private void addResource(CmsPublishResource resourceBean, boolean indent) {\n\n        CmsTreeItem row = buildItem(resourceBean);\n        m_panel.add(row);\n        if (resourceBean.getInfo() != null) {\n            m_numProblems += 1;\n        } else {\n            m_noProblemItems.add(row);\n        }\n        // we don't count related resources.\n        m_size += 1;\n\n        for (CmsPublishResource related : resourceBean.getRelated()) {\n            row.addChild(buildItem(related));\n        }\n    }","id":86810,"modified_method":"/**\n     * Creates a widget from resource bean data.<p>\n     * \n     * @param resourceBean the resource bean for which a widget should be constructed\n     * @param status the publish item status\n     * @param isSubItem true if this is not a top-level publish item  \n     * \n     * @return a widget representing the resource bean\n     */\n    private CmsTreeItem buildItem(final CmsPublishResource resourceBean, CmsPublishItemStatus status, boolean isSubItem) {\n\n        CmsListItemWidget itemWidget = createListItemWidget(resourceBean);\n        final CmsStyleVariable styleVar = new CmsStyleVariable(itemWidget);\n        styleVar.setValue(CSS.itemToKeep());\n\n        final CmsCheckBox checkbox = new CmsCheckBox();\n        CmsTreeItem row;\n        row = new CmsTreeItem(false, checkbox, itemWidget);\n        if (isSubItem) {\n            checkbox.getElement().getStyle().setVisibility(Visibility.HIDDEN);\n        }\n\n        row.setOpen(true);\n        row.addStyleName(CSS.publishRow());\n\n        // we do not need most of the interactive elements for the sub-items \n        if (!isSubItem) {\n            ClickHandler checkboxHandler = new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    boolean checked = checkbox.isChecked();\n                    m_model.signal(checked ? Signal.publish : Signal.unpublish, resourceBean.getId());\n                    m_selectionChangeHandler.onChangePublishSelection();\n                }\n            };\n            checkbox.addClickHandler(checkboxHandler);\n\n            final boolean hasProblem = (resourceBean.getInfo() != null);\n            if (hasProblem) {\n                // can't select resource with problems\n                checkbox.setChecked(false);\n                checkbox.setEnabled(false);\n            }\n\n            final CmsCheckBox remover = new CmsCheckBox();\n            final CmsPublishItemSelectionController controller = new CmsPublishItemSelectionController(\n                resourceBean.getId(),\n                checkbox,\n                remover,\n                styleVar,\n                hasProblem);\n            m_controllersById.put(resourceBean.getId(), controller);\n\n            remover.setTitle(Messages.get().key(Messages.GUI_PUBLISH_REMOVE_BUTTON_0));\n            remover.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent e) {\n\n                    boolean remove = remover.isChecked();\n                    m_model.signal(remove ? Signal.remove : Signal.unremove, resourceBean.getId());\n                    m_selectionChangeHandler.onChangePublishSelection();\n                }\n            });\n            itemWidget.addButtonToFront(remover);\n\n            controller.update(status);\n        }\n        return row;\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a widget from resource bean data.<p>\n     * \n     * @param resourceBean the resource bean for which a widget should be constructed\n     * \n     * @return a widget representing the resource bean\n     */\n    private CmsTreeItem buildItem(CmsPublishResource resourceBean) {\n\n        ClickHandler checkboxHandler = new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                m_selectionChangeHandler.onChangePublishSelection();\n            }\n        };\n\n        CmsListItemWidget itemWidget = createListItemWidget(resourceBean);\n        final CmsStyleVariable styleVar = new CmsStyleVariable(itemWidget);\n        styleVar.setValue(CSS.itemToKeep());\n\n        final CmsCheckBox checkbox = new CmsCheckBox();\n        checkbox.addClickHandler(checkboxHandler);\n        final boolean hasProblem = (resourceBean.getInfo() != null);\n        if (hasProblem) {\n            // can't select resource with problems\n            checkbox.setChecked(false);\n            checkbox.setEnabled(false);\n        }\n        CmsTreeItem row = new CmsTreeItem(false, checkbox, itemWidget);\n        final CmsCheckBox remover = new CmsCheckBox();\n        final CmsPublishItemSelectionController controller = new CmsPublishItemSelectionController(\n            resourceBean.getId(),\n            checkbox,\n            remover,\n            hasProblem);\n        m_selectionControllers.add(controller);\n\n        remover.setTitle(Messages.get().key(Messages.GUI_PUBLISH_REMOVE_BUTTON_0));\n        remover.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                boolean remove = remover.isChecked();\n                controller.onClickRemove(remove);\n                I_CmsListItemWidgetCss itemWidgetCss = I_CmsLayoutBundle.INSTANCE.listItemWidgetCss();\n                styleVar.setValue(remove ? itemWidgetCss.disabledItem() : CSS.itemToKeep());\n                remover.setTitle(remove\n                ? Messages.get().key(Messages.GUI_PUBLISH_UNREMOVE_BUTTON_0)\n                : Messages.get().key(Messages.GUI_PUBLISH_REMOVE_BUTTON_0));\n\n                m_selectionChangeHandler.onChangePublishSelection();\n            }\n        });\n        itemWidget.addButtonToFront(remover);\n        row.addStyleName(CSS.publishRow());\n        return row;\n    }","id":86811,"modified_method":"/**\n     * Adds a resource bean to this group.<p>\n     * \n     * @param resourceBean the resource bean which should be added\n     */\n    private void addItem(CmsPublishResource resourceBean) {\n\n        CmsTreeItem row = buildItem(resourceBean, m_model.getStatus(resourceBean.getId()), false);\n        m_panel.add(row);\n\n        for (CmsPublishResource related : resourceBean.getRelated()) {\n            row.addChild(buildItem(related, m_model.getStatus(related.getId()), true));\n        }\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the \"select all/none\" buttons, adds them to the group header and \n     * attaches event handlers to them.<p>\n     */\n    private void initSelectButtons() {\n\n        m_selectAll = new CmsPushButton();\n        m_selectAll.setText(Messages.get().key(Messages.GUI_PUBLISH_TOP_PANEL_ALL_BUTTON_0));\n        m_selectAll.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageChecked());\n        m_selectAll.setSize(I_CmsButton.Size.small);\n        m_selectAll.setUseMinWidth(true);\n        m_selectAll.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                setAllSelected(true);\n                m_selectionChangeHandler.onChangePublishSelection();\n            }\n        });\n\n        m_selectNone = new CmsPushButton();\n        m_selectNone.setText(Messages.get().key(Messages.GUI_PUBLISH_TOP_PANEL_NONE_BUTTON_0));\n        m_selectNone.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageUnchecked());\n        m_selectNone.setSize(I_CmsButton.Size.small);\n        m_selectNone.setUseMinWidth(true);\n        m_selectNone.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                setAllSelected(false);\n                m_selectionChangeHandler.onChangePublishSelection();\n            }\n        });\n\n        FlowPanel selectButtons = new FlowPanel();\n        selectButtons.add(m_selectAll);\n        selectButtons.add(m_selectNone);\n        selectButtons.setStyleName(CSS.selectButtons());\n        m_header.add(selectButtons);\n    }","id":86812,"modified_method":"/**\n     * Initializes the \"select all/none\" buttons, adds them to the group header and \n     * attaches event handlers to them.<p>\n     */\n    private void initSelectButtons() {\n\n        m_selectAll = new CmsPushButton();\n        m_selectAll.setText(Messages.get().key(Messages.GUI_PUBLISH_TOP_PANEL_ALL_BUTTON_0));\n        m_selectAll.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageChecked());\n        m_selectAll.setSize(I_CmsButton.Size.small);\n        m_selectAll.setUseMinWidth(true);\n        m_selectAll.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                m_model.signalGroup(Signal.publish, m_groupIndex);\n                CmsPublishGroupPanel.this.m_selectionChangeHandler.onChangePublishSelection();\n            }\n        });\n\n        m_selectNone = new CmsPushButton();\n        m_selectNone.setText(Messages.get().key(Messages.GUI_PUBLISH_TOP_PANEL_NONE_BUTTON_0));\n        m_selectNone.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageUnchecked());\n        m_selectNone.setSize(I_CmsButton.Size.small);\n        m_selectNone.setUseMinWidth(true);\n        m_selectNone.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                m_model.signalGroup(Signal.unpublish, m_groupIndex);\n                CmsPublishGroupPanel.this.m_selectionChangeHandler.onChangePublishSelection();\n            }\n        });\n\n        FlowPanel selectButtons = new FlowPanel();\n        selectButtons.add(m_selectAll);\n        selectButtons.add(m_selectNone);\n        selectButtons.setStyleName(CSS.selectButtons());\n        m_header.add(selectButtons);\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructs a new instance.<p>\n     * \n     * @param title the title of the group\n     * @param group the list of resource beans for the group\n     * @param selectionChangeHandler the handler for selection changes for publish resources \n     */\n    public CmsPublishGroupPanel(\n        String title,\n        List<CmsPublishResource> group,\n        I_CmsPublishSelectionChangeHandler selectionChangeHandler) {\n\n        initWidget(m_panel);\n        m_panel.add(m_header);\n        m_panel.truncate(TM_PUBLISH_LIST, CmsPublishDialog.DIALOG_WIDTH);\n        for (CmsPublishResource resourceBean : group) {\n            addResource(resourceBean, false);\n        }\n        initSelectButtons();\n\n        if (m_numProblems == m_size) {\n            m_selectAll.setEnabled(false);\n            m_selectNone.setEnabled(false);\n        }\n        Label label = new Label(title);\n        label.addStyleName(CSS.groupHeader());\n        m_header.add(label);\n\n        FlowPanel clear = new FlowPanel();\n        clear.setStyleName(CSS.clear());\n        m_header.add(clear);\n        m_selectionChangeHandler = selectionChangeHandler;\n    }","id":86813,"modified_method":"/**\n     * Constructs a new instance.<p>\n     * \n     * @param title the title of the group\n     * @param groupIndex the index of the group which this panel should render\n     * @param selectionChangeHandler the handler for selection changes for publish resources\n     * @param model the data model for the publish resources\n     * @param controllersById the map of selection controllers to which this panel's selection controllers should be added\n     * @param showProblemsOnly if true, sets this panel into \"show resources with problems only\" mode\n     */\n    public CmsPublishGroupPanel(\n        String title,\n        int groupIndex,\n        I_CmsPublishSelectionChangeHandler selectionChangeHandler,\n        CmsPublishDataModel model,\n        Map<CmsUUID, CmsPublishItemSelectionController> controllersById,\n        boolean showProblemsOnly) {\n\n        initWidget(m_panel);\n        m_panel.add(m_header);\n        m_model = model;\n        m_groupIndex = groupIndex;\n        m_publishResources = model.getGroups().get(groupIndex).getResources();\n        m_controllersById = controllersById;\n        m_panel.truncate(TM_PUBLISH_LIST, CmsPublishDialog.DIALOG_WIDTH);\n        initSelectButtons();\n        if (hasOnlyProblemResources()) {\n            m_selectAll.setEnabled(false);\n            m_selectNone.setEnabled(false);\n        }\n        m_showProblemsOnly = showProblemsOnly;\n        if (hasNoProblemResources() && showProblemsOnly) {\n            this.setVisible(false);\n        }\n\n        Label label = new Label(title + CmsPublishSelectPanel.formatResourceCount(m_publishResources.size()));\n        label.addStyleName(CSS.groupHeader());\n        m_header.add(label);\n\n        FlowPanel clear = new FlowPanel();\n        clear.setStyleName(CSS.clear());\n        m_header.add(clear);\n        m_selectionChangeHandler = selectionChangeHandler;\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructs a new instance.<p>\n     * \n     * @param id the id of the resource\n     * @param selectedCheckBox the checkbox representing the selection status of the resource\n     * @param removeCheckBox the checkbox representing the remove status of the resource \n     * @param hasProblems a flag indicating whether there are problems with the resource\n     */\n    public CmsPublishItemSelectionController(\n        CmsUUID id,\n        CmsCheckBox selectedCheckBox,\n        CmsCheckBox removeCheckBox,\n        boolean hasProblems) {\n\n        m_id = id;\n        m_hasProblems = hasProblems;\n        m_selectedCheckBox = selectedCheckBox;\n        m_removeCheckBox = removeCheckBox;\n        if (m_hasProblems) {\n            m_selectedCheckBox.setChecked(false);\n            m_selectedCheckBox.setEnabled(false);\n        }\n    }","id":86814,"modified_method":"/**\n     * Constructs a new instance.<p>\n     * \n     * @param id the id of the resource\n     * @param selectedCheckBox the checkbox representing the selection status of the resource\n     * @param removeCheckBox the checkbox representing the remove status of the resource \n     * @param removeStyle the style variable to keep track of the \"remove\" status  \n     * @param hasProblems a flag indicating whether there are problems with the resource\n     */\n    public CmsPublishItemSelectionController(\n        CmsUUID id,\n        CmsCheckBox selectedCheckBox,\n        CmsCheckBox removeCheckBox,\n        CmsStyleVariable removeStyle,\n        boolean hasProblems) {\n\n        m_id = id;\n        m_hasProblems = hasProblems;\n        m_selectedCheckBox = selectedCheckBox;\n        m_removeCheckBox = removeCheckBox;\n        m_removeStyle = removeStyle;\n        if (m_hasProblems) {\n            m_selectedCheckBox.setChecked(false);\n            m_selectedCheckBox.setEnabled(false);\n        }\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the ids of the resources which should be published.<p>\n     * \n     * @return a set of id strings \n     */\n    public Set<CmsUUID> getResourcesToPublish() {\n\n        Set<CmsUUID> result = new HashSet<CmsUUID>();\n        for (CmsPublishGroupPanel groupPanel : m_groupPanels) {\n            result.addAll(groupPanel.getResourcesToPublish());\n        }\n        return result;\n    }","id":86815,"modified_method":"/**\n     * Returns the ids of the resources which should be published.<p>\n     * \n     * @return a set of id strings \n     */\n    public Set<CmsUUID> getResourcesToPublish() {\n\n        return new HashSet<CmsUUID>(m_model.getPublishIds());\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.publish.client.I_CmsPublishSelectionChangeHandler#onChangePublishSelection()\n     */\n    public void onChangePublishSelection() {\n\n        boolean enablePublishButton = (getResourcesToRemove().size() != 0) || (getResourcesToPublish().size() != 0);\n        m_publishButton.setEnabled(enablePublishButton);\n\n    }","id":86816,"modified_method":"/**\n     * @see org.opencms.ade.publish.client.I_CmsPublishSelectionChangeHandler#onChangePublishSelection()\n     */\n    public void onChangePublishSelection() {\n\n        m_publishButton.setEnabled(shouldEnablePublishButton());\n\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds the scroll handler to the scroll panel which makes more groups visible when the user \n     * scrolls to the bottom.<p>\n     */\n    private void addScrollHandler() {\n\n        m_scrollPanel.addScrollHandler(new CmsScrollToBottomHandler(new Runnable() {\n\n            /**\n             * @see java.lang.Runnable#run()\n             */\n            public void run() {\n\n                addMoreGroups();\n            }\n        }, SCROLL_THRESHOLD));\n\n    }","id":86817,"modified_method":"/**\n     * Adds the scroll handler to the scroll panel which makes more groups visible when the user \n     * scrolls to the bottom.<p>\n     */\n    private void addScrollHandler() {\n\n        m_scrollPanel.addScrollHandler(new CmsScrollToBottomHandler(new Runnable() {\n\n            /**\n             * @see java.lang.Runnable#run()\n             */\n            public void run() {\n\n                addMoreListItems();\n            }\n        }, SCROLL_THRESHOLD));\n\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds more groups if there are still undisplayed groups left.<p>\n     */\n    protected void addMoreGroups() {\n\n        if ((m_splitter != null) && m_splitter.hasMore()) {\n            for (CmsPublishGroupPanel groupPanel : m_splitter.getMore()) {\n                m_groupPanelContainer.add(groupPanel);\n            }\n        }\n    }","id":86818,"modified_method":"/**\n     * Adds more groups if there are still undisplayed groups left.<p>\n     */\n    protected void addMoreGroups() {\n\n        //TODO: adding more groups  \n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** \n     * Check for problems with new/deleted folders in the publish selection.<p>\n     * \n     * @param resourceIds the ids of the resources selected for publishing \n     * @return true if there are problems with nested \n     */\n    public boolean checkForProblems(Set<CmsUUID> resourceIds) {\n\n        List<CmsPublishResource> pubResources = new ArrayList<CmsPublishResource>();\n        Set<CmsUUID> publishIds = getResourcesToPublish();\n        for (CmsUUID publishId : publishIds) {\n            pubResources.add(m_publishResources.get(publishId));\n        }\n        for (CmsPublishResource pubResource : pubResources) {\n            String parentPath = CmsResource.getParentFolder(pubResource.getName());\n            CmsPublishResource parent = m_publishResourcesByPath.get(parentPath);\n            if (parent != null) {\n                boolean parentIsNew = parent.getState().isNew();\n                boolean parentIsDeleted = parent.getState().isDeleted();\n                if (parentIsNew || parentIsDeleted) {\n                    if (!resourceIds.contains(parent.getId())) {\n                        String title = Messages.get().key(Messages.ERR_CANT_PUBLISH_RESOURCE_TITLE_0);\n                        String message = null;\n                        if (parentIsNew) {\n                            message = Messages.get().key(\n                                Messages.ERR_PUBLISH_CANT_PUBLISH_NEW_RESOURCE_2,\n                                pubResource.getName(),\n                                parent.getName());\n                        }\n                        if (parentIsDeleted) {\n                            message = Messages.get().key(\n                                Messages.ERR_PUBLISH_CANT_PUBLISH_DELETED_RESOURCE_2,\n                                pubResource.getName(),\n                                parent.getName());\n                        }\n                        CmsAlertDialog alert = new CmsAlertDialog(title, message);\n                        alert.center();\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","id":86819,"modified_method":"/** \n     * Check for problems with new/deleted folders in the publish selection.<p>\n     * \n     * @param resourceIds the ids of the resources selected for publishing \n     * @return true if there are problems with nested \n     */\n    public boolean checkForProblems(Set<CmsUUID> resourceIds) {\n\n        List<CmsPublishResource> pubResources = new ArrayList<CmsPublishResource>();\n        Set<CmsUUID> publishIds = getResourcesToPublish();\n        for (CmsUUID publishId : publishIds) {\n            pubResources.add(m_model.getPublishResources().get(publishId));\n        }\n        for (CmsPublishResource pubResource : pubResources) {\n            String parentPath = CmsResource.getParentFolder(pubResource.getName());\n            CmsPublishResource parent = m_model.getPublishResourcesByPath().get(parentPath);\n            if (parent != null) {\n                boolean parentIsNew = parent.getState().isNew();\n                boolean parentIsDeleted = parent.getState().isDeleted();\n                if (parentIsNew || parentIsDeleted) {\n                    if (!resourceIds.contains(parent.getId())) {\n                        String title = Messages.get().key(Messages.ERR_CANT_PUBLISH_RESOURCE_TITLE_0);\n                        String message = null;\n                        if (parentIsNew) {\n                            message = Messages.get().key(\n                                Messages.ERR_PUBLISH_CANT_PUBLISH_NEW_RESOURCE_2,\n                                pubResource.getName(),\n                                parent.getName());\n                        }\n                        if (parentIsDeleted) {\n                            message = Messages.get().key(\n                                Messages.ERR_PUBLISH_CANT_PUBLISH_DELETED_RESOURCE_2,\n                                pubResource.getName(),\n                                parent.getName());\n                        }\n                        CmsAlertDialog alert = new CmsAlertDialog(title, message);\n                        alert.center();\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the publish groups used by this widget.<p>\n     * \n     * @param groups the new publish groups \n     */\n    public void setGroups(List<CmsPublishGroup> groups) {\n\n        m_problemsPanel.clear();\n        m_checkboxProblems.setChecked(false);\n        m_checkboxProblems.setVisible(false);\n        m_problemsPanel.setVisible(false);\n        m_groupPanels.clear();\n        m_groupPanelContainer.clear();\n        m_publishButton.setEnabled(false);\n\n        int numGroups = groups.size();\n        setResourcesVisible(numGroups > 0);\n        if (numGroups == 0) {\n            return;\n        }\n        int numProblems = 0;\n        m_publishResources = new HashMap<CmsUUID, CmsPublishResource>();\n        m_publishResourcesByPath = new HashMap<String, CmsPublishResource>();\n        for (CmsPublishGroup group : groups) {\n            String header = group.getName();\n            List<CmsPublishResource> resourceBeans = group.getResources();\n            CmsPublishGroupPanel groupPanel = new CmsPublishGroupPanel(header, resourceBeans, this);\n            m_groupPanels.add(groupPanel);\n            numProblems += groupPanel.countProblems();\n            for (CmsPublishResource pubResource : group.getResources()) {\n                m_publishResources.put(pubResource.getId(), pubResource);\n                m_publishResourcesByPath.put(pubResource.getName(), pubResource);\n            }\n        }\n        resetGroups();\n        m_publishButton.setEnabled(true);\n        showProblemCount(numProblems);\n        onChangePublishSelection();\n    }","id":86820,"modified_method":"/**\n     * Sets the publish groups used by this widget.<p>\n     * \n     * @param groups the new publish groups\n     * @param newData true if the groups are new data which has been loaded  \n     */\n    public void setGroups(List<CmsPublishGroup> groups, boolean newData) {\n\n        m_model = new CmsPublishDataModel(groups, this);\n        m_resourceCountLabel.setText(formatResourceCount(m_model.getPublishResources().size()));\n        m_currentGroupIndex = 0;\n        m_currentGroupPanel = null;\n        m_problemsPanel.clear();\n        if (newData) {\n            m_showProblemsOnly = false;\n            m_checkboxProblems.setChecked(false);\n            m_checkboxProblems.setVisible(false);\n            m_problemsPanel.setVisible(false);\n        }\n        m_groupPanels.clear();\n        m_groupPanelContainer.clear();\n        m_publishButton.setEnabled(false);\n\n        int numGroups = groups.size();\n        setResourcesVisible(numGroups > 0);\n\n        if (numGroups == 0) {\n            return;\n        }\n\n        m_publishButton.setEnabled(true);\n        addMoreListItems();\n        showProblemCount(m_model.countProblems());\n        onChangePublishSelection();\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new instance.<p>\n     * \n     * @param publishDialog the publish dialog to which this panel should belong\n     * @param projects a map of projects, where the keys are the project ids and the values are the names of the projects \n     * @param publishOptions the initial publish options\n     */\n    public CmsPublishSelectPanel(\n        CmsPublishDialog publishDialog,\n        List<CmsProjectBean> projects,\n        CmsPublishOptions publishOptions) {\n\n        m_publishOptions = publishOptions;\n\n        initWidget(UI_BINDER.createAndBindUi(this));\n        m_checkboxProblems.setVisible(false);\n\n        List<CmsPair<String, String>> items = new ArrayList<CmsPair<String, String>>();\n        CmsMessages messages = Messages.get();\n        items.add(new CmsPair<String, String>(\n            CmsUUID.getNullUUID().toString(),\n            messages.key(Messages.GUI_PUBLISH_DIALOG_MY_CHANGES_0)));\n        boolean foundOldProject = false;\n        for (CmsProjectBean project : projects) {\n            items.add(new CmsPair<String, String>(project.getId().toString(), project.getName()));\n\n            // look if the project id from the last publish list is among the available projects.\n            // (this might not be the case if the project has been deleted in the meantime.)\n            if (project.getId().equals(publishOptions.getProjectId())) {\n                foundOldProject = true;\n            }\n\n        }\n        m_projectSelector.setItems(items);\n        m_projectSelector.addStyleName(CSS.selector());\n\n        m_publishDialog = publishDialog;\n        m_checkboxRelated.setChecked(publishOptions.isIncludeRelated());\n        m_checkboxSiblings.setChecked(publishOptions.isIncludeSiblings());\n        if (foundOldProject) {\n            m_projectSelector.selectValue(publishOptions.getProjectId().toString());\n        }\n\n        m_projectSelector.addValueChangeHandler(new ValueChangeHandler<String>() {\n\n            /**\n             * @see ValueChangeHandler#onValueChange(ValueChangeEvent)\n             */\n            public void onValueChange(ValueChangeEvent<String> event) {\n\n                m_publishOptions.setProjectId(new CmsUUID(event.getValue()));\n                m_publishDialog.onChangeOptions();\n            }\n        });\n        m_projectSelector.truncate(TM_PUBLISH, 200);\n\n        m_checkboxRelated.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                m_publishOptions.setIncludeRelated(m_checkboxRelated.isChecked());\n                m_publishDialog.onChangeOptions();\n            }\n        });\n        m_checkboxSiblings.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                m_publishOptions.setIncludeSiblings(m_checkboxSiblings.isChecked());\n                m_publishDialog.onChangeOptions();\n            }\n        });\n\n        m_checkboxProblems.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                setProblemMode(m_checkboxProblems.isChecked());\n            }\n        });\n\n        m_publishButton.setText(messages.key(Messages.GUI_PUBLISH_DIALOG_PUBLISH_0));\n        m_publishButton.setUseMinWidth(true);\n        m_cancelButton.setText(messages.key(Messages.GUI_PUBLISH_DIALOG_CANCEL_BUTTON_0));\n        m_cancelButton.setUseMinWidth(true);\n\n        m_selectAll.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_ALL_BUTTON_0));\n        m_selectAll.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageChecked());\n        m_selectAll.setUseMinWidth(true);\n\n        m_selectNone.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_NONE_BUTTON_0));\n        m_selectNone.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageUnchecked());\n        m_selectNone.setUseMinWidth(true);\n\n        m_noResources.setText(messages.key(Messages.GUI_PUBLISH_DIALOG_NO_RES_0));\n        m_selectAll.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                setAllCheckboxes(true);\n                onChangePublishSelection();\n            }\n        });\n\n        m_selectNone.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                setAllCheckboxes(false);\n                onChangePublishSelection();\n            }\n        });\n\n        m_checkboxSiblings.setText(messages.key(Messages.GUI_PUBLISH_CHECKBOXES_SIBLINGS_0));\n        m_checkboxRelated.setText(messages.key(Messages.GUI_PUBLISH_CHECKBOXES_REL_RES_0));\n        m_checkboxProblems.setText(messages.key(Messages.GUI_PUBLISH_CHECKBOXES_PROBLEMS_0));\n\n        m_selectLabel.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_LEFT_LABEL_0));\n        m_selectorLabel.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_RIGHT_LABEL_0));\n        addScrollHandler();\n\n    }","id":86821,"modified_method":"/**\n     * Creates a new instance.<p>\n     * \n     * @param publishDialog the publish dialog to which this panel should belong\n     * @param projects a map of projects, where the keys are the project ids and the values are the names of the projects \n     * @param publishOptions the initial publish options\n     */\n    public CmsPublishSelectPanel(\n        CmsPublishDialog publishDialog,\n        List<CmsProjectBean> projects,\n        CmsPublishOptions publishOptions) {\n\n        m_publishOptions = publishOptions;\n\n        initWidget(UI_BINDER.createAndBindUi(this));\n        m_checkboxProblems.setVisible(false);\n\n        List<CmsPair<String, String>> items = new ArrayList<CmsPair<String, String>>();\n        CmsMessages messages = Messages.get();\n        items.add(new CmsPair<String, String>(\n            CmsUUID.getNullUUID().toString(),\n            messages.key(Messages.GUI_PUBLISH_DIALOG_MY_CHANGES_0)));\n        boolean foundOldProject = false;\n        for (CmsProjectBean project : projects) {\n            items.add(new CmsPair<String, String>(project.getId().toString(), project.getName()));\n\n            // look if the project id from the last publish list is among the available projects.\n            // (this might not be the case if the project has been deleted in the meantime.)\n            if (project.getId().equals(publishOptions.getProjectId())) {\n                foundOldProject = true;\n            }\n\n        }\n        m_projectSelector.setItems(items);\n        m_projectSelector.addStyleName(CSS.selector());\n        m_publishDialog = publishDialog;\n        m_checkboxRelated.setChecked(publishOptions.isIncludeRelated());\n        m_checkboxSiblings.setChecked(publishOptions.isIncludeSiblings());\n        if (foundOldProject) {\n            m_projectSelector.selectValue(publishOptions.getProjectId().toString());\n        }\n\n        m_projectSelector.addValueChangeHandler(new ValueChangeHandler<String>() {\n\n            /**\n             * @see ValueChangeHandler#onValueChange(ValueChangeEvent)\n             */\n            public void onValueChange(ValueChangeEvent<String> event) {\n\n                m_publishOptions.setProjectId(new CmsUUID(event.getValue()));\n                m_publishDialog.onChangeOptions();\n            }\n        });\n        m_projectSelector.truncate(TM_PUBLISH, 200);\n\n        m_checkboxRelated.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                m_publishOptions.setIncludeRelated(m_checkboxRelated.isChecked());\n                m_publishDialog.onChangeOptions();\n            }\n        });\n        m_checkboxSiblings.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                m_publishOptions.setIncludeSiblings(m_checkboxSiblings.isChecked());\n                m_publishDialog.onChangeOptions();\n            }\n        });\n\n        m_checkboxProblems.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                setProblemMode(m_checkboxProblems.isChecked());\n            }\n        });\n\n        m_publishButton.setText(messages.key(Messages.GUI_PUBLISH_DIALOG_PUBLISH_0));\n        m_publishButton.setUseMinWidth(true);\n        m_cancelButton.setText(messages.key(Messages.GUI_PUBLISH_DIALOG_CANCEL_BUTTON_0));\n        m_cancelButton.setUseMinWidth(true);\n\n        m_selectAll.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_ALL_BUTTON_0));\n        m_selectAll.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageChecked());\n        m_selectAll.setUseMinWidth(true);\n\n        m_selectNone.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_NONE_BUTTON_0));\n        m_selectNone.setImageClass(I_CmsInputLayoutBundle.INSTANCE.inputCss().checkBoxImageUnchecked());\n        m_selectNone.setUseMinWidth(true);\n\n        m_noResources.setText(messages.key(Messages.GUI_PUBLISH_DIALOG_NO_RES_0));\n        m_selectAll.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                m_model.signalAll(Signal.publish);\n                CmsPublishSelectPanel.this.onChangePublishSelection();\n            }\n        });\n\n        m_selectNone.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent e) {\n\n                m_model.signalAll(Signal.unpublish);\n                CmsPublishSelectPanel.this.onChangePublishSelection();\n            }\n        });\n\n        m_checkboxSiblings.setText(messages.key(Messages.GUI_PUBLISH_CHECKBOXES_SIBLINGS_0));\n        m_checkboxRelated.setText(messages.key(Messages.GUI_PUBLISH_CHECKBOXES_REL_RES_0));\n        m_checkboxProblems.setText(messages.key(Messages.GUI_PUBLISH_CHECKBOXES_PROBLEMS_0));\n\n        m_selectLabel.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_LEFT_LABEL_0));\n        m_selectorLabel.setText(messages.key(Messages.GUI_PUBLISH_TOP_PANEL_RIGHT_LABEL_0));\n        addScrollHandler();\n\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the set of ids of resources which have been selected for removal.<p>\n     * \n     * @return a set of id strings\n     */\n    public Set<CmsUUID> getResourcesToRemove() {\n\n        Set<CmsUUID> result = new HashSet<CmsUUID>();\n        for (CmsPublishGroupPanel groupPanel : m_groupPanels) {\n            result.addAll(groupPanel.getResourcesToRemove());\n        }\n        return result;\n    }","id":86822,"modified_method":"/**\n     * Returns the set of ids of resources which have been selected for removal.<p>\n     * \n     * @return a set of id strings\n     */\n    public Set<CmsUUID> getResourcesToRemove() {\n\n        return new HashSet<CmsUUID>(m_model.getRemoveIds());\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Enables or disables the \"only show resources with problems\" mode.<p>\n     * \n     * @param enabled if true, enable the mode, else disable it\n     */\n    protected void setProblemMode(boolean enabled) {\n\n        for (CmsPublishGroupPanel groupPanel : m_groupPanels) {\n            groupPanel.setProblemMode(enabled);\n        }\n        resetGroups();\n    }","id":86823,"modified_method":"/**\n     * Enables or disables the \"only show resources with problems\" mode.<p>\n     * \n     * @param enabled if true, enable the mode, else disable it\n     */\n    protected void setProblemMode(boolean enabled) {\n\n        m_showProblemsOnly = enabled;\n        setGroups(m_model.getGroups(), false);\n    }","commit_id":"6e0437e94478965db4a49aaccb86ca18d29aff28","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static native void openURL(String url)/*-{\n                                                $wnd.open(url);\n                                                }-*/;","id":86824,"modified_method":"public static native String openURL(String url, String name, String options)/*-{\n    \t$wnd.open(url, name , options)\n   }-*/;","commit_id":"2ff170a2610dd3fc7a1896b26910f76323a866f0","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void updateDownloadFileProgress()\n   {\n      dispatcher.execute(new GetDownloadAllFilesProgress(processId), new AsyncCallback<GetDownloadAllFilesProgressResult>()\n      {\n         @Override\n         public void onFailure(Throwable caught)\n         {\n            eventBus.fireEvent(new NotificationEvent(NotificationEvent.Severity.Warning, \"Unable get progress of file preparation\"));\n            display.hideConfirmation();\n         }\n\n         @Override\n         public void onSuccess(GetDownloadAllFilesProgressResult result)\n         {\n            display.updateFileDownloadProgress(result.getCurrentProgress(), result.getMaxProgress());\n\n            if (result.isDone())\n            {\n               timer.cancel();\n               display.hideConfirmation();\n               eventBus.fireEvent(new NotificationEvent(NotificationEvent.Severity.Info, \"File ready to download\"));\n               Application.openURL(Application.getAllFilesDownloadURL(result.getDownloadId()));\n            }\n         }\n      });\n   }","id":86825,"modified_method":"public void updateDownloadFileProgress()\n   {\n      display.setDownloadInProgress(true);\n      dispatcher.execute(new GetDownloadAllFilesProgress(processId), new AsyncCallback<GetDownloadAllFilesProgressResult>()\n      {\n         @Override\n         public void onFailure(Throwable caught)\n         {\n            eventBus.fireEvent(new NotificationEvent(NotificationEvent.Severity.Warning, \"Unable get progress of file preparation\"));\n            display.hideConfirmation();\n         }\n\n         @Override\n         public void onSuccess(GetDownloadAllFilesProgressResult result)\n         {\n            display.updateFileDownloadProgress(result.getCurrentProgress(), result.getMaxProgress());\n\n            if (result.isDone())\n            {\n               timer.cancel();\n//               display.hideConfirmation();\n               String url = Application.getAllFilesDownloadURL(result.getDownloadId());\n               display.setFilesDownloadLink(url);\n               eventBus.fireEvent(new NotificationEvent(NotificationEvent.Severity.Info, \"File ready to download\"));\n               Application.openURL(url, \"\", \"menubar=0,resizable=0,location=0,status=0,toolbar=0,width=200,height=200\");\n            }\n         }\n      });\n   }","commit_id":"2ff170a2610dd3fc7a1896b26910f76323a866f0","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public DocumentListView(Resources resources, WebTransMessages messages, UserWorkspaceContext userworkspaceContext)\n   {\n      this.resources = resources;\n      this.messages = messages;\n      this.userworkspaceContext = userworkspaceContext;\n\n      dataProvider = new ListDataProvider<DocumentNode>();\n      confirmationBox = new DownloadFilesConfirmationBox(false, this);\n      pager = new DocumentListPager(TextLocation.CENTER, false, true);\n      searchField = new SearchField(this);\n      searchField.setTextBoxTitle(messages.docListFilterDescription());\n\n      initWidget(uiBinder.createAndBindUi(this));\n      \n      downloadAllFiles.setText(\"Download all files (zip)\");\n\n      caseSensitiveCheckBox.setTitle(messages.docListFilterCaseSensitiveDescription());\n      exactSearchCheckBox.setTitle(messages.docListFilterExactMatchDescription());\n      statsByMsg.setText(messages.byMessage());\n      statsByWord.setText(messages.byWords());\n      this.addSelectionHandler(new SelectionHandler<DocumentInfo>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<DocumentInfo> event)\n         {\n            listener.fireDocumentSelection(event.getSelectedItem());\n         }\n      });\n   }","id":86826,"modified_method":"@Inject\n   public DocumentListView(Resources resources, WebTransMessages messages, UserWorkspaceContext userworkspaceContext)\n   {\n      this.resources = resources;\n      this.messages = messages;\n      this.userworkspaceContext = userworkspaceContext;\n\n      dataProvider = new ListDataProvider<DocumentNode>();\n      confirmationBox = new DownloadFilesConfirmationBox(false, this, resources);\n      pager = new DocumentListPager(TextLocation.CENTER, false, true);\n      searchField = new SearchField(this);\n      searchField.setTextBoxTitle(messages.docListFilterDescription());\n\n      initWidget(uiBinder.createAndBindUi(this));\n      \n      downloadAllFiles.setText(\"Download all files (zip)\");\n\n      caseSensitiveCheckBox.setTitle(messages.docListFilterCaseSensitiveDescription());\n      exactSearchCheckBox.setTitle(messages.docListFilterExactMatchDescription());\n      statsByMsg.setText(messages.byMessage());\n      statsByWord.setText(messages.byWords());\n      this.addSelectionHandler(new SelectionHandler<DocumentInfo>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<DocumentInfo> event)\n         {\n            listener.fireDocumentSelection(event.getSelectedItem());\n         }\n      });\n   }","commit_id":"2ff170a2610dd3fc7a1896b26910f76323a866f0","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void hide()\n   {\n      setProgressMessage(\"\");\n      super.hide();\n   }","id":86827,"modified_method":"public void hide()\n   {\n\t  setInProgress(false);\n     super.hide();\n   }","commit_id":"2ff170a2610dd3fc7a1896b26910f76323a866f0","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DownloadFilesConfirmationBox(boolean autoHide, final HasDownloadFileHandler handler)\n   {\n      super(autoHide);\n      setText(\"Download All Files\");\n      setGlassEnabled(true);\n      setStyleName(\"DownloadFileDialogBox\");\n\n      VerticalPanel panel = new VerticalPanel();\n\n      message = new Label(\"Your download will be prepared and may take a few minutes to complete. Is this ok?\");\n      progressMessage = new Label();\n      cancelButton = new PushButton(\"Cancel\");\n      cancelButton.addStyleName(\"button\");\n      okButton = new PushButton(\"OK\");\n      okButton.addStyleName(\"button\");\n\n      HorizontalPanel infoPanel = new HorizontalPanel();\n      infoPanel.setStyleName(\"img\");\n      InlineLabel infoImg = new InlineLabel();\n      infoImg.setStyleName(\"icon-help-circle\");\n      infoPanel.add(infoImg);\n      infoPanel.add(message);\n      infoPanel.setCellVerticalAlignment(message, HasVerticalAlignment.ALIGN_MIDDLE);\n\n      HorizontalPanel buttonPanel = new HorizontalPanel();\n      buttonPanel.setStyleName(\"buttonPanel\");\n      buttonPanel.add(cancelButton);\n      buttonPanel.add(okButton);\n      \n      panel.add(infoPanel);\n      panel.add(progressMessage);\n      panel.add(buttonPanel);\n      \n      panel.setCellHorizontalAlignment(buttonPanel, HasHorizontalAlignment.ALIGN_RIGHT);\n\n      add(panel);\n      \n      cancelButton.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            handler.onCancelButtonClicked();\n         }\n      });\n      \n      okButton.addClickHandler(new ClickHandler()\n      {\n         \n         @Override\n         public void onClick(ClickEvent event)\n         {\n            handler.onOkButtonClicked();\n         }\n      });\n   }","id":86828,"modified_method":"public DownloadFilesConfirmationBox(boolean autoHide, final HasDownloadFileHandler handler, final Resources resources)\n   {\n      super(autoHide);\n      setText(\"Download All Files\");\n      setGlassEnabled(true);\n      setStyleName(\"DownloadFileDialogBox\");\n\n      VerticalPanel panel = new VerticalPanel();\n      \n      Label infoMessage = new Label(defaultMessage);\n      InlineLabel infoImg = new InlineLabel();\n      infoImg.setStyleName(\"icon-help-circle\");\n      \n      infoPanel = new HorizontalPanel();\n      infoPanel.setStyleName(\"info\");\n      infoPanel.add(infoImg);\n      infoPanel.add(infoMessage);\n      infoPanel.setCellVerticalAlignment(infoMessage, HasVerticalAlignment.ALIGN_MIDDLE);\n\n      PushButton cancelButton = new PushButton(\"Cancel\");\n      cancelButton.addStyleName(\"button\");\n      \n      PushButton okButton = new PushButton(\"OK\");\n      okButton.addStyleName(\"button\");\n      \n      HorizontalPanel buttonPanel = new HorizontalPanel();\n      buttonPanel.setStyleName(\"buttonPanel\");\n      buttonPanel.add(cancelButton);\n      buttonPanel.add(okButton);\n      \n      Image progressImage = new Image(resources.progressLoading());\n      progressMessage = new Label();\n      \n      progressPanel = new HorizontalPanel();\n      progressPanel.setSpacing(5);\n      progressPanel.setStyleName(\"progress\");\n      progressPanel.setVisible(false);\n      progressPanel.add(progressImage);\n      progressPanel.add(progressMessage);\n      progressPanel.setCellVerticalAlignment(progressImage, HasVerticalAlignment.ALIGN_MIDDLE);\n      progressPanel.setCellVerticalAlignment(progressMessage, HasVerticalAlignment.ALIGN_MIDDLE);\n      \n      panel.add(infoPanel);\n      panel.add(progressPanel);\n      panel.add(buttonPanel);\n      \n      panel.setCellHorizontalAlignment(infoPanel, HasHorizontalAlignment.ALIGN_CENTER);\n      panel.setCellHorizontalAlignment(progressPanel, HasHorizontalAlignment.ALIGN_CENTER);\n      panel.setCellHorizontalAlignment(buttonPanel, HasHorizontalAlignment.ALIGN_RIGHT);\n\n      add(panel);\n      \n      downloadLink = new Anchor(\"Click here to download\");\n      \n      cancelButton.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            handler.onCancelButtonClicked();\n         }\n      });\n      \n      okButton.addClickHandler(new ClickHandler()\n      {\n         \n         @Override\n         public void onClick(ClickEvent event)\n         {\n            handler.onOkButtonClicked();\n         }\n      });\n   }","commit_id":"2ff170a2610dd3fc7a1896b26910f76323a866f0","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Creates new instance.<p>\n     */\n    public CmsBasicDialog() {\n        addStyleName(OpenCmsTheme.DIALOG);\n        setMargin(true);\n        setSpacing(true);\n        setWidth(\"100%\");\n\n        m_mainPanel = new VerticalLayout();\n        m_mainPanel.addStyleName(OpenCmsTheme.DIALOG_CONTENT);\n        m_mainPanel.setSpacing(true);\n        m_mainPanel.setSizeFull();\n\n        m_contentPanel = new Panel();\n        m_contentPanel.setSizeFull();\n        m_contentPanel.addStyleName(\"v-scrollable\");\n\n        m_mainPanel.addComponent(m_contentPanel);\n        m_mainPanel.setExpandRatio(m_contentPanel, 3);\n\n        Panel panel = new Panel();\n        panel.setContent(m_mainPanel);\n        panel.setSizeFull();\n        addComponent(panel);\n        setExpandRatio(panel, 1);\n\n        m_buttonPanel = new HorizontalLayout();\n        m_buttonPanel.setSpacing(true);\n        m_buttonPanel.addStyleName(OpenCmsTheme.DIALOG_BUTTON_BAR);\n        addComponent(m_buttonPanel);\n        setComponentAlignment(m_buttonPanel, Alignment.MIDDLE_RIGHT);\n        enableMaxHeight();\n    }","id":86829,"modified_method":"/**\n     * Creates new instance.<p>\n     */\n    public CmsBasicDialog() {\n        addStyleName(OpenCmsTheme.DIALOG);\n        setMargin(true);\n        setSpacing(true);\n        setWidth(\"100%\");\n\n        m_mainPanel = new VerticalLayout();\n        m_mainPanel.addStyleName(OpenCmsTheme.DIALOG_CONTENT);\n        m_mainPanel.setSpacing(true);\n        m_mainPanel.setSizeFull();\n\n        m_contentPanel = new Panel();\n        m_contentPanel.setSizeFull();\n        m_contentPanel.addStyleName(\"v-scrollable\");\n\n        m_mainPanel.addComponent(m_contentPanel);\n        m_mainPanel.setExpandRatio(m_contentPanel, 3);\n\n        Panel panel = new Panel();\n        panel.setContent(m_mainPanel);\n        panel.setSizeFull();\n        addComponent(panel);\n        setExpandRatio(panel, 1);\n        HorizontalLayout buttons = new HorizontalLayout();\n        buttons.setWidth(\"100%\");\n        buttons.addStyleName(OpenCmsTheme.DIALOG_BUTTON_BAR);\n        addComponent(buttons);\n        m_buttonPanelLeft = new HorizontalLayout();\n        m_buttonPanelLeft.setSpacing(true);\n        buttons.addComponent(m_buttonPanelLeft);\n        buttons.setComponentAlignment(m_buttonPanelLeft, Alignment.MIDDLE_LEFT);\n        m_buttonPanelLeft.setVisible(false);\n        m_buttonPanelRight = new HorizontalLayout();\n        m_buttonPanelRight.setSpacing(true);\n        buttons.addComponent(m_buttonPanelRight);\n        buttons.setComponentAlignment(m_buttonPanelRight, Alignment.MIDDLE_RIGHT);\n        enableMaxHeight();\n    }","commit_id":"8d85605ba4efaf0f58ebcb6e174c4060fab17c1d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see com.vaadin.ui.AbstractOrderedLayout#readDesign(org.jsoup.nodes.Element, com.vaadin.ui.declarative.DesignContext)\n     */\n    @Override\n    public void readDesign(Element design, DesignContext designContext) {\n\n        for (Element child : design.children()) {\n            boolean contentRead = false;\n            boolean buttonsRead = false;\n            boolean aboveRead = false;\n            boolean belowRead = false;\n            if (\"content\".equals(child.tagName()) && !contentRead) {\n                Component content = designContext.readDesign(child.child(0));\n                setContent(content);\n                contentRead = true;\n            } else if (\"buttons\".equals(child.tagName()) && !buttonsRead) {\n                for (Element buttonElement : child.children()) {\n                    Component button = designContext.readDesign(buttonElement);\n                    addButton(button);\n                }\n                buttonsRead = true;\n            } else if (\"above\".equals(child.tagName()) && !aboveRead) {\n                Component aboveContent = designContext.readDesign(child.child(0));\n                setAbove(aboveContent);\n                aboveRead = true;\n            } else if (\"below\".equals(child.tagName()) && !belowRead) {\n                Component belowContent = designContext.readDesign(child.child(0));\n                setBelow(belowContent);\n                belowRead = true;\n            }\n        }\n    }","id":86830,"modified_method":"/**\n     * @see com.vaadin.ui.AbstractOrderedLayout#readDesign(org.jsoup.nodes.Element, com.vaadin.ui.declarative.DesignContext)\n     */\n    @Override\n    public void readDesign(Element design, DesignContext designContext) {\n\n        for (Element child : design.children()) {\n            boolean contentRead = false;\n            boolean buttonsRead = false;\n            boolean aboveRead = false;\n            boolean belowRead = false;\n            if (\"content\".equals(child.tagName()) && !contentRead) {\n                Component content = designContext.readDesign(child.child(0));\n                setContent(content);\n                contentRead = true;\n            } else if (\"buttons\".equals(child.tagName()) && !buttonsRead) {\n                for (Element buttonElement : child.children()) {\n                    Component button = designContext.readDesign(buttonElement);\n                    Attributes attr = buttonElement.attributes();\n                    addButton(button, !attr.hasKey(\":left\"));\n                }\n                buttonsRead = true;\n            } else if (\"above\".equals(child.tagName()) && !aboveRead) {\n                Component aboveContent = designContext.readDesign(child.child(0));\n                setAbove(aboveContent);\n                aboveRead = true;\n            } else if (\"below\".equals(child.tagName()) && !belowRead) {\n                Component belowContent = designContext.readDesign(child.child(0));\n                setBelow(belowContent);\n                belowRead = true;\n            }\n        }\n    }","commit_id":"8d85605ba4efaf0f58ebcb6e174c4060fab17c1d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a button to the button bar.<p>\n     *\n     * @param button the button to add\n     */\n    public void addButton(Component button) {\n\n        m_buttonPanel.addComponent(button);\n    }","id":86831,"modified_method":"/**\n     * Adds a button to the button bar.<p>\n     *\n     * @param button the button to add\n     */\n    public void addButton(Component button) {\n\n        addButton(button, true);\n    }","commit_id":"8d85605ba4efaf0f58ebcb6e174c4060fab17c1d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Test\n\t@Ignore\n\tpublic void testClazzesInDefaultPackageNameWithOneChar() {\n\t\tString signature = \"D\";\n\t\tBinaryTypeSignature typeSignature = BinarySignatures.createTypeSignature(signature);\n\t\tAssert.assertEquals(\"java:/Objects/D#D\",typeSignature.getURI().toString());\n\t}","id":86832,"modified_method":"@Test\n\tpublic void testClassesInDefaultPackage_01() {\n\t\tString signature = \"LDummyService;\";\n\t\tBinaryTypeSignature typeSignature = BinarySignatures.createTypeSignature(signature);\n\t\tAssert.assertEquals(\"java:/Objects/DummyService#DummyService\", typeSignature.getURI().toString());\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testClazzesInDefaultPackage() {\n\t\tString signature = \"DummyService\";\n\t\tBinaryTypeSignature typeSignature = BinarySignatures.createTypeSignature(signature);\n\t\tAssert.assertEquals(\"java:/Objects/DummyService#DummyService\",typeSignature.getURI().toString());\n\t}","id":86833,"modified_method":"@Test\n\tpublic void testClassesInDefaultPackage_02() {\n\t\tString signature = \"DummyService\";\n\t\tBinaryTypeSignature typeSignature = BinarySignatures.createObjectTypeSignature(signature);\n\t\tAssert.assertEquals(\"java:/Objects/DummyService#DummyService\", typeSignature.getURI().toString());\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"public URI getURI() {\n\t\tBinaryTypeSignature typeErasure = getArrayComponentType().getTypeErasure();\n\t\tif (typeErasure.length==1) {\n\t\t\tswitch(typeErasure.chars.charAt(typeErasure.offset)) {\n\t\t\t\tcase 'B':\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'I':\n\t\t\t\tcase 'J':\n\t\t\t\tcase 'S':\n\t\t\t\tcase 'Z':\n\t\t\t\tcase 'V': {\n\t\t\t\t\treturn URIHelperConstants.PRIMITIVES_URI.appendFragment(toIdentifier());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString identifier = typeErasure.toIdentifier();\n\t\tURI result = URIHelperConstants.OBJECTS_URI.appendSegment(identifier).appendFragment(toIdentifier());\n\t\treturn result;\n\t}","id":86834,"modified_method":"public URI getURI() {\n\t\tBinaryTypeSignature typeErasure = getArrayComponentType().getTypeErasure();\n\t\tswitch(typeErasure.chars.charAt(typeErasure.offset)) {\n\t\t\tcase 'B':\n\t\t\tcase 'C':\n\t\t\tcase 'D':\n\t\t\tcase 'F':\n\t\t\tcase 'I':\n\t\t\tcase 'J':\n\t\t\tcase 'S':\n\t\t\tcase 'Z':\n\t\t\tcase 'V': {\n\t\t\t\treturn URIHelperConstants.PRIMITIVES_URI.appendFragment(toIdentifier());\n\t\t\t}\n\t\t}\n\t\tString identifier = typeErasure.toIdentifier();\n\t\tURI result = URIHelperConstants.OBJECTS_URI.appendSegment(identifier).appendFragment(toIdentifier());\n\t\treturn result;\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void visit(String name, Object value) {\n\t\tif (name != null) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t\tif (result == null) {\n\t\t\tresult = proxies.createAnnotationValue(value);\n\t\t} else {\n\t\t\tif (value instanceof Type) {\n\t\t\t\tType type = (Type) value;\n\t\t\t\tString typeName = type.getSort() == Type.OBJECT ? type.getInternalName() : type.getDescriptor();\n\t\t\t\t((InternalEList<JvmTypeReference>) ((JvmTypeAnnotationValue) result).getValues()).addUnique(proxies.createTypeReference(BinarySignatures.createTypeSignature(typeName), null));\n\t\t\t} else {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tInternalEList<Object> list = (InternalEList<Object>) result.eGet(result.eClass().getEStructuralFeature(\"values\"));\n\t\t\t\tlist.addUnique(value);\n\t\t\t}\n\t\t}\n\t}","id":86835,"modified_method":"@Override\n\tpublic void visit(String name, Object value) {\n\t\tif (name != null) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t\tif (result == null) {\n\t\t\tresult = proxies.createAnnotationValue(value);\n\t\t} else {\n\t\t\tif (value instanceof Type) {\n\t\t\t\tType type = (Type) value;\n\t\t\t\tBinaryTypeSignature signature;\n\t\t\t\tif (type.getSort() == Type.OBJECT) {\n\t\t\t\t\tString typeName = type.getInternalName();\n\t\t\t\t\tsignature = BinarySignatures.createObjectTypeSignature(typeName);\n\t\t\t\t} else {\n\t\t\t\t\tString typeName = type.getDescriptor();\n\t\t\t\t\tsignature = BinarySignatures.createTypeSignature(typeName);\n\t\t\t\t}\n\t\t\t\t((InternalEList<JvmTypeReference>) ((JvmTypeAnnotationValue) result).getValues()).addUnique(proxies.createTypeReference(signature, null));\n\t\t\t} else {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tInternalEList<Object> list = (InternalEList<Object>) result.eGet(result.eClass().getEStructuralFeature(\"values\"));\n\t\t\t\tlist.addUnique(value);\n\t\t\t}\n\t\t}\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"private void setSuperTypes(String name, BinarySuperTypeSignature signature, String superName, String[] interfaces) {\n    \tInternalEList<JvmTypeReference> superTypes = (InternalEList<JvmTypeReference>) result.getSuperTypes();\n\t\tif (signature != null) {\n\t\t\tList<BinaryGenericTypeSignature> superTypeSignatures = signature.getSuperTypes();\n\t\t\tif (result.eClass() == TypesPackage.Literals.JVM_GENERIC_TYPE && ((JvmGenericType) result).isInterface()) {\n\t\t\t\tif (superTypeSignatures.size() > 1) {\n\t\t\t\t\tsuperTypeSignatures = superTypeSignatures.subList(1, superTypeSignatures.size());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < superTypeSignatures.size(); i++) {\n\t\t\t\tsuperTypes.addUnique(proxies.createTypeReference(superTypeSignatures.get(i), typeParameters));\n\t\t\t}\n\t\t} else {\n\t\t\tif (superName != null && result.eClass() != TypesPackage.Literals.JVM_ANNOTATION_TYPE) {\n\t\t\t\tsuperTypes.addUnique(proxies.createTypeReference(BinarySignatures.createTypeSignature(superName), typeParameters));\n\t\t\t}\n\t\t\tsetInterfaces(interfaces, typeParameters, superTypes);\n\t\t\tif (superTypes.isEmpty() && !Proxies.JAVA_LANG_OBJECT.equals(name)) {\n\t\t\t\tsuperTypes.addUnique(proxies.createObjectTypeReference());\n\t\t\t}\n\t\t}\n\t}","id":86836,"modified_method":"private void setSuperTypes(String name, BinarySuperTypeSignature signature, String superName, String[] interfaces) {\n    \tInternalEList<JvmTypeReference> superTypes = (InternalEList<JvmTypeReference>) result.getSuperTypes();\n\t\tif (signature != null) {\n\t\t\tList<BinaryGenericTypeSignature> superTypeSignatures = signature.getSuperTypes();\n\t\t\tif (result.eClass() == TypesPackage.Literals.JVM_GENERIC_TYPE && ((JvmGenericType) result).isInterface()) {\n\t\t\t\tif (superTypeSignatures.size() > 1) {\n\t\t\t\t\tsuperTypeSignatures = superTypeSignatures.subList(1, superTypeSignatures.size());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < superTypeSignatures.size(); i++) {\n\t\t\t\tsuperTypes.addUnique(proxies.createTypeReference(superTypeSignatures.get(i), typeParameters));\n\t\t\t}\n\t\t} else {\n\t\t\tif (superName != null && result.eClass() != TypesPackage.Literals.JVM_ANNOTATION_TYPE) {\n\t\t\t\tsuperTypes.addUnique(proxies.createTypeReference(BinarySignatures.createObjectTypeSignature(superName), typeParameters));\n\t\t\t}\n\t\t\tsetInterfaces(interfaces, typeParameters, superTypes);\n\t\t\tif (superTypes.isEmpty() && !Proxies.JAVA_LANG_OBJECT.equals(name)) {\n\t\t\t\tsuperTypes.addUnique(proxies.createObjectTypeReference());\n\t\t\t}\n\t\t}\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setInterfaces(String[] interfaces, Map<String, JvmTypeParameter> typeParameters,\n\t\t\tInternalEList<JvmTypeReference> result) {\n\t\tif (interfaces != null) {\n\t\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\t\tString interfaceName = interfaces[i];\n\t\t\t\tresult.addUnique(proxies.createTypeReference(BinarySignatures.createTypeSignature(interfaceName), typeParameters));\n\t\t\t}\n\t\t}\n\t}","id":86837,"modified_method":"protected void setInterfaces(String[] interfaces, Map<String, JvmTypeParameter> typeParameters,\n\t\t\tInternalEList<JvmTypeReference> result) {\n\t\tif (interfaces != null) {\n\t\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\t\tString interfaceName = interfaces[i];\n\t\t\t\tresult.addUnique(proxies.createTypeReference(BinarySignatures.createObjectTypeSignature(interfaceName), typeParameters));\n\t\t\t}\n\t\t}\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmExecutableBuilder(\n    \tfinal JvmDeclaredType declarator,\n    \tfinal int initialOffset,\n        Map<String, JvmTypeParameter> typeParameters,\n        Proxies proxies,\n        final int access,\n        final String name,\n        final String desc,\n        final String signature,\n        final String[] exceptions)\n    {\n    \tsuper(Opcodes.ASM5);\n    \tthis.proxies = proxies;\n\t\tthis.declarator = declarator;\n\t\tfinal StringBuilder fqName;\n\t\tif (isConstructor(name)) {\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\t\tString declaratorIdentifier = declarator.getIdentifier();\n\t\t\tString simpleName = declarator.getSimpleName();\n\t\t\tfqName = new StringBuilder(declaratorIdentifier.length() + 1 + simpleName.length() + desc.length());\n\t\t\tfqName.append(declaratorIdentifier);\n\t\t\tfqName.append('.');\n\t\t\tfqName.append(simpleName);\n\t\t\tresult.setSimpleName(simpleName);\n\t\t\tthis.offset = initialOffset;\n\t\t} else {\n\t\t\tJvmOperation operation = TypesFactory.eINSTANCE.createJvmOperation();\n\t\t\tresult = operation;\n\t\t\tString declaratorIdentifier = declarator.getIdentifier();\n\t\t\tfqName = new StringBuilder(declaratorIdentifier.length() + 1 + name.length() + desc.length());\n\t\t\tfqName.append(declaratorIdentifier);\n\t\t\tfqName.append('.');\n\t\t\tfqName.append(name);\n\t\t\tresult.setSimpleName(name);\n\t\t\tthis.offset = 0;\n\t\t\t\n\t\t\toperation.setAbstract((access & ACC_ABSTRACT) != 0);\n\t\t\toperation.setFinal((access & ACC_FINAL) != 0);\n\t\t\toperation.setStatic((access & ACC_STATIC) != 0);\n\t\t\toperation.setSynchronized((access & ACC_SYNCHRONIZED) != 0);\n\t\t\toperation.setStrictFloatingPoint((access & ACC_STRICT) != 0);\n\t\t\toperation.setNative((access & ACC_NATIVE) != 0);\n\t\t}\n\t\tproxies.setVisibility(access, result);\n\t\t\n\t\tBinaryMethodSignature binarySignature = BinarySignatures.createMethodSignature(signature != null ? signature: desc);\n\t\ttypeParameters = proxies.createTypeParameters(binarySignature, result, typeParameters);\n\t\t\n\t\tif (result.eClass() == TypesPackage.Literals.JVM_OPERATION) {\n\t\t\treturnType = desc;\n\t\t\t((JvmOperation) result).setReturnType(proxies.createTypeReference(binarySignature.getReturnType(), typeParameters));\n\t\t}\n\t\t\n\t\tfqName.append('(');\n\t\tList<BinaryGenericTypeSignature> parameterTypes = binarySignature.getParameterTypes();\n\t\tint myOffset = signature == null ? offset : 0;\n\t\tif (parameterTypes.size() > myOffset) {\n//\t\t\tchar[][] argumentNames = method.getArgumentNames();\n//\t\t\tboolean hasArgumentNames = argumentNames != null && argumentNames.length != 0;\n\t\t\tInternalEList<JvmFormalParameter> parameters = (InternalEList<JvmFormalParameter>) result.getParameters();\n\t\t\tfor (int i = myOffset; i < parameterTypes.size(); i++) {\n\t\t\t\tif (i != myOffset)\n\t\t\t\t\tfqName.append(',');\n\t\t\t\t\n\t\t\t\tBinaryTypeSignature parameterType = parameterTypes.get(i);\n\t\t\t\tfqName.append(parameterType.getTypeErasure().toIdentifier());\n\t\t\t\tparameters.addUnique(createFormalParameter(parameterType,\n\t\t\t\t\t\t\"arg\" + (i - myOffset), result,\n\t\t\t\t\t\ttypeParameters));\n\t\t\t}\n\t\t}\n\t\tfqName.append(')');\n\t\tresult.internalSetIdentifier(fqName.toString());\n\t\tproxies.setVisibility(access, result);\n\t\tresult.setVarArgs((access & ACC_VARARGS) != 0);\n\t\tresult.setDeprecated((access & ACC_DEPRECATED) != 0);\n\n\t\tList<BinaryGenericTypeSignature> exceptionSignatures = binarySignature.getExceptionTypes();\n\t\tif (exceptionSignatures.size() == 0) {\n\t\t\tif (exceptions != null) {\n\t\t\t\tInternalEList<JvmTypeReference> resultExceptions = (InternalEList<JvmTypeReference>) result\n\t\t\t\t\t\t.getExceptions();\n\t\t\t\tfor (int i = 0, max = exceptions.length; i < max; i++) {\n\t\t\t\t\tresultExceptions.addUnique(proxies.createTypeReference(BinarySignatures.createTypeSignature(exceptions[i]), typeParameters));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tInternalEList<JvmTypeReference> resultExceptions = (InternalEList<JvmTypeReference>) result.getExceptions();\n\t\t\tfor (int i = 0, max = exceptionSignatures.size(); i < max; i++) {\n\t\t\t\tresultExceptions.addUnique(proxies.createTypeReference(exceptionSignatures.get(i), typeParameters));\n\t\t\t}\n\t\t}\n    }","id":86838,"modified_method":"public JvmExecutableBuilder(\n    \tfinal JvmDeclaredType declarator,\n    \tfinal int initialOffset,\n        Map<String, JvmTypeParameter> typeParameters,\n        Proxies proxies,\n        final int access,\n        final String name,\n        final String desc,\n        final String signature,\n        final String[] exceptions)\n    {\n    \tsuper(Opcodes.ASM5);\n    \tthis.proxies = proxies;\n\t\tthis.declarator = declarator;\n\t\tfinal StringBuilder fqName;\n\t\tif (isConstructor(name)) {\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\t\tString declaratorIdentifier = declarator.getIdentifier();\n\t\t\tString simpleName = declarator.getSimpleName();\n\t\t\tfqName = new StringBuilder(declaratorIdentifier.length() + 1 + simpleName.length() + desc.length());\n\t\t\tfqName.append(declaratorIdentifier);\n\t\t\tfqName.append('.');\n\t\t\tfqName.append(simpleName);\n\t\t\tresult.setSimpleName(simpleName);\n\t\t\tthis.offset = initialOffset;\n\t\t} else {\n\t\t\tJvmOperation operation = TypesFactory.eINSTANCE.createJvmOperation();\n\t\t\tresult = operation;\n\t\t\tString declaratorIdentifier = declarator.getIdentifier();\n\t\t\tfqName = new StringBuilder(declaratorIdentifier.length() + 1 + name.length() + desc.length());\n\t\t\tfqName.append(declaratorIdentifier);\n\t\t\tfqName.append('.');\n\t\t\tfqName.append(name);\n\t\t\tresult.setSimpleName(name);\n\t\t\tthis.offset = 0;\n\t\t\t\n\t\t\toperation.setAbstract((access & ACC_ABSTRACT) != 0);\n\t\t\toperation.setFinal((access & ACC_FINAL) != 0);\n\t\t\toperation.setStatic((access & ACC_STATIC) != 0);\n\t\t\toperation.setSynchronized((access & ACC_SYNCHRONIZED) != 0);\n\t\t\toperation.setStrictFloatingPoint((access & ACC_STRICT) != 0);\n\t\t\toperation.setNative((access & ACC_NATIVE) != 0);\n\t\t}\n\t\tproxies.setVisibility(access, result);\n\t\t\n\t\tBinaryMethodSignature binarySignature = BinarySignatures.createMethodSignature(signature != null ? signature: desc);\n\t\ttypeParameters = proxies.createTypeParameters(binarySignature, result, typeParameters);\n\t\t\n\t\tif (result.eClass() == TypesPackage.Literals.JVM_OPERATION) {\n\t\t\treturnType = desc;\n\t\t\t((JvmOperation) result).setReturnType(proxies.createTypeReference(binarySignature.getReturnType(), typeParameters));\n\t\t}\n\t\t\n\t\tfqName.append('(');\n\t\tList<BinaryGenericTypeSignature> parameterTypes = binarySignature.getParameterTypes();\n\t\tint myOffset = signature == null ? offset : 0;\n\t\tif (parameterTypes.size() > myOffset) {\n//\t\t\tchar[][] argumentNames = method.getArgumentNames();\n//\t\t\tboolean hasArgumentNames = argumentNames != null && argumentNames.length != 0;\n\t\t\tInternalEList<JvmFormalParameter> parameters = (InternalEList<JvmFormalParameter>) result.getParameters();\n\t\t\tfor (int i = myOffset; i < parameterTypes.size(); i++) {\n\t\t\t\tif (i != myOffset)\n\t\t\t\t\tfqName.append(',');\n\t\t\t\t\n\t\t\t\tBinaryTypeSignature parameterType = parameterTypes.get(i);\n\t\t\t\tfqName.append(parameterType.getTypeErasure().toIdentifier());\n\t\t\t\tparameters.addUnique(createFormalParameter(parameterType,\n\t\t\t\t\t\t\"arg\" + (i - myOffset), result,\n\t\t\t\t\t\ttypeParameters));\n\t\t\t}\n\t\t}\n\t\tfqName.append(')');\n\t\tresult.internalSetIdentifier(fqName.toString());\n\t\tproxies.setVisibility(access, result);\n\t\tresult.setVarArgs((access & ACC_VARARGS) != 0);\n\t\tresult.setDeprecated((access & ACC_DEPRECATED) != 0);\n\n\t\tList<BinaryGenericTypeSignature> exceptionSignatures = binarySignature.getExceptionTypes();\n\t\tif (exceptionSignatures.size() == 0) {\n\t\t\tif (exceptions != null) {\n\t\t\t\tInternalEList<JvmTypeReference> resultExceptions = (InternalEList<JvmTypeReference>) result\n\t\t\t\t\t\t.getExceptions();\n\t\t\t\tfor (int i = 0, max = exceptions.length; i < max; i++) {\n\t\t\t\t\tresultExceptions.addUnique(proxies.createTypeReference(BinarySignatures.createObjectTypeSignature(exceptions[i]), typeParameters));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tInternalEList<JvmTypeReference> resultExceptions = (InternalEList<JvmTypeReference>) result.getExceptions();\n\t\t\tfor (int i = 0, max = exceptionSignatures.size(); i < max; i++) {\n\t\t\t\tresultExceptions.addUnique(proxies.createTypeReference(exceptionSignatures.get(i), typeParameters));\n\t\t\t}\n\t\t}\n    }","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmEnumerationLiteral createEnumLiteral(String literalName, String typeName) {\n\t\treturn createEnumLiteral(literalName, BinarySignatures.createTypeSignature(typeName));\n\t}","id":86839,"modified_method":"public JvmEnumerationLiteral createEnumLiteral(String literalName, String typeName) {\n\t\treturn createEnumLiteral(literalName, BinarySignatures.createObjectTypeSignature(typeName));\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmAnnotationValue createAnnotationValue(Object value) {\n\t\tClass<?> valueClass = value.getClass();\n\t\tif (valueClass == Byte.class) {\n\t\t\tJvmByteAnnotationValue result = TypesFactory.eINSTANCE.createJvmByteAnnotationValue();\n\t\t\t((InternalEList<Byte>) result.getValues()).addUnique((Byte) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Boolean.class) {\n\t\t\tJvmBooleanAnnotationValue result = TypesFactory.eINSTANCE.createJvmBooleanAnnotationValue();\n\t\t\t((InternalEList<Boolean>) result.getValues()).addUnique((Boolean) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Character.class) {\n\t\t\tJvmCharAnnotationValue result = TypesFactory.eINSTANCE.createJvmCharAnnotationValue();\n\t\t\t((InternalEList<Character>) result.getValues()).addUnique((Character) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Short.class) {\n\t\t\tJvmShortAnnotationValue result = TypesFactory.eINSTANCE.createJvmShortAnnotationValue();\n\t\t\t((InternalEList<Short>) result.getValues()).addUnique((Short) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Integer.class) {\n\t\t\tJvmIntAnnotationValue result = TypesFactory.eINSTANCE.createJvmIntAnnotationValue();\n\t\t\t((InternalEList<Integer>) result.getValues()).addUnique((Integer) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Long.class) {\n\t\t\tJvmLongAnnotationValue result = TypesFactory.eINSTANCE.createJvmLongAnnotationValue();\n\t\t\t((InternalEList<Long>) result.getValues()).addUnique((Long) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Float.class) {\n\t\t\tJvmFloatAnnotationValue result = TypesFactory.eINSTANCE.createJvmFloatAnnotationValue();\n\t\t\t((InternalEList<Float>) result.getValues()).addUnique((Float) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Double.class) {\n\t\t\tJvmDoubleAnnotationValue result = TypesFactory.eINSTANCE.createJvmDoubleAnnotationValue();\n\t\t\t((InternalEList<Double>) result.getValues()).addUnique((Double) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == String.class) {\n\t\t\tJvmStringAnnotationValue result = TypesFactory.eINSTANCE.createJvmStringAnnotationValue();\n\t\t\t((InternalEList<String>) result.getValues()).addUnique((String) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Type.class) {\n\t\t\tJvmTypeAnnotationValue result = TypesFactory.eINSTANCE.createJvmTypeAnnotationValue();\n\t\t\tType type = (Type) value;\n\t\t\tString typeName = type.getSort() == Type.OBJECT ? type.getInternalName() : type.getDescriptor();\n\t\t\t((InternalEList<JvmTypeReference>) result.getValues()).addUnique(createTypeReference(BinarySignatures.createTypeSignature(typeName), null));\n\t\t\treturn result;\n\t\t}\n\t\tString className = valueClass.getName();\n\t\tif (className.startsWith(\"[\") && className.length() == 2) {\n\t\t\tswitch (className.charAt(1)) {\n\t\t\t\tcase 'Z': {\n\t\t\t\t\tJvmBooleanAnnotationValue result = TypesFactory.eINSTANCE.createJvmBooleanAnnotationValue();\n\t\t\t\t\tboolean[] booleanValues = (boolean[]) value;\n\t\t\t\t\tfor (boolean b : booleanValues)\n\t\t\t\t\t\t((InternalEList<Boolean>) result.getValues()).addUnique(b);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'C': {\n\t\t\t\t\tJvmCharAnnotationValue result = TypesFactory.eINSTANCE.createJvmCharAnnotationValue();\n\t\t\t\t\tchar[] charValues = (char[]) value;\n\t\t\t\t\tfor (char c : charValues)\n\t\t\t\t\t\t((InternalEList<Character>) result.getValues()).addUnique(c);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'B': {\n\t\t\t\t\tJvmByteAnnotationValue result = TypesFactory.eINSTANCE.createJvmByteAnnotationValue();\n\t\t\t\t\tbyte[] byteValues = (byte[]) value;\n\t\t\t\t\tfor (byte b : byteValues)\n\t\t\t\t\t\t((InternalEList<Byte>) result.getValues()).addUnique(b);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'S': {\n\t\t\t\t\tJvmShortAnnotationValue result = TypesFactory.eINSTANCE.createJvmShortAnnotationValue();\n\t\t\t\t\tshort[] shortValues = (short[]) value;\n\t\t\t\t\tfor (short s : shortValues)\n\t\t\t\t\t\t((InternalEList<Short>) result.getValues()).addUnique(s);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'I': {\n\t\t\t\t\tJvmIntAnnotationValue result = TypesFactory.eINSTANCE.createJvmIntAnnotationValue();\n\t\t\t\t\tint[] intValues = (int[]) value;\n\t\t\t\t\tfor (int i : intValues)\n\t\t\t\t\t\t((InternalEList<Integer>) result.getValues()).addUnique(i);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'F': {\n\t\t\t\t\tJvmFloatAnnotationValue result = TypesFactory.eINSTANCE.createJvmFloatAnnotationValue();\n\t\t\t\t\tfloat[] floatValues = (float[]) value;\n\t\t\t\t\tfor (float f : floatValues)\n\t\t\t\t\t\t((InternalEList<Float>) result.getValues()).addUnique(f);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'J': {\n\t\t\t\t\tJvmLongAnnotationValue result = TypesFactory.eINSTANCE.createJvmLongAnnotationValue();\n\t\t\t\t\tlong[] longValues = (long[]) value;\n\t\t\t\t\tfor (long l : longValues)\n\t\t\t\t\t\t((InternalEList<Long>) result.getValues()).addUnique(l);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'D': {\n\t\t\t\t\tJvmDoubleAnnotationValue result = TypesFactory.eINSTANCE.createJvmDoubleAnnotationValue();\n\t\t\t\t\tdouble[] doubleValues = (double[]) value;\n\t\t\t\t\tfor (double d : doubleValues)\n\t\t\t\t\t\t((InternalEList<Double>) result.getValues()).addUnique(d);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(String.valueOf(value));\n\t}","id":86840,"modified_method":"public JvmAnnotationValue createAnnotationValue(Object value) {\n\t\tClass<?> valueClass = value.getClass();\n\t\tif (valueClass == Byte.class) {\n\t\t\tJvmByteAnnotationValue result = TypesFactory.eINSTANCE.createJvmByteAnnotationValue();\n\t\t\t((InternalEList<Byte>) result.getValues()).addUnique((Byte) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Boolean.class) {\n\t\t\tJvmBooleanAnnotationValue result = TypesFactory.eINSTANCE.createJvmBooleanAnnotationValue();\n\t\t\t((InternalEList<Boolean>) result.getValues()).addUnique((Boolean) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Character.class) {\n\t\t\tJvmCharAnnotationValue result = TypesFactory.eINSTANCE.createJvmCharAnnotationValue();\n\t\t\t((InternalEList<Character>) result.getValues()).addUnique((Character) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Short.class) {\n\t\t\tJvmShortAnnotationValue result = TypesFactory.eINSTANCE.createJvmShortAnnotationValue();\n\t\t\t((InternalEList<Short>) result.getValues()).addUnique((Short) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Integer.class) {\n\t\t\tJvmIntAnnotationValue result = TypesFactory.eINSTANCE.createJvmIntAnnotationValue();\n\t\t\t((InternalEList<Integer>) result.getValues()).addUnique((Integer) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Long.class) {\n\t\t\tJvmLongAnnotationValue result = TypesFactory.eINSTANCE.createJvmLongAnnotationValue();\n\t\t\t((InternalEList<Long>) result.getValues()).addUnique((Long) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Float.class) {\n\t\t\tJvmFloatAnnotationValue result = TypesFactory.eINSTANCE.createJvmFloatAnnotationValue();\n\t\t\t((InternalEList<Float>) result.getValues()).addUnique((Float) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Double.class) {\n\t\t\tJvmDoubleAnnotationValue result = TypesFactory.eINSTANCE.createJvmDoubleAnnotationValue();\n\t\t\t((InternalEList<Double>) result.getValues()).addUnique((Double) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == String.class) {\n\t\t\tJvmStringAnnotationValue result = TypesFactory.eINSTANCE.createJvmStringAnnotationValue();\n\t\t\t((InternalEList<String>) result.getValues()).addUnique((String) value);\n\t\t\treturn result;\n\t\t}\n\t\tif (valueClass == Type.class) {\n\t\t\tJvmTypeAnnotationValue result = TypesFactory.eINSTANCE.createJvmTypeAnnotationValue();\n\t\t\tType type = (Type) value;\n\t\t\tBinaryTypeSignature signature;\n\t\t\tif (type.getSort() == Type.OBJECT) {\n\t\t\t\tString typeName = type.getInternalName();\n\t\t\t\tsignature = BinarySignatures.createObjectTypeSignature(typeName);\n\t\t\t} else {\n\t\t\t\tString typeName = type.getDescriptor();\n\t\t\t\tsignature = BinarySignatures.createTypeSignature(typeName);\n\t\t\t}\n\t\t\t((InternalEList<JvmTypeReference>) result.getValues()).addUnique(createTypeReference(signature, null));\n\t\t\treturn result;\n\t\t}\n\t\tString className = valueClass.getName();\n\t\tif (className.startsWith(\"[\") && className.length() == 2) {\n\t\t\tswitch (className.charAt(1)) {\n\t\t\t\tcase 'Z': {\n\t\t\t\t\tJvmBooleanAnnotationValue result = TypesFactory.eINSTANCE.createJvmBooleanAnnotationValue();\n\t\t\t\t\tboolean[] booleanValues = (boolean[]) value;\n\t\t\t\t\tfor (boolean b : booleanValues)\n\t\t\t\t\t\t((InternalEList<Boolean>) result.getValues()).addUnique(b);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'C': {\n\t\t\t\t\tJvmCharAnnotationValue result = TypesFactory.eINSTANCE.createJvmCharAnnotationValue();\n\t\t\t\t\tchar[] charValues = (char[]) value;\n\t\t\t\t\tfor (char c : charValues)\n\t\t\t\t\t\t((InternalEList<Character>) result.getValues()).addUnique(c);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'B': {\n\t\t\t\t\tJvmByteAnnotationValue result = TypesFactory.eINSTANCE.createJvmByteAnnotationValue();\n\t\t\t\t\tbyte[] byteValues = (byte[]) value;\n\t\t\t\t\tfor (byte b : byteValues)\n\t\t\t\t\t\t((InternalEList<Byte>) result.getValues()).addUnique(b);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'S': {\n\t\t\t\t\tJvmShortAnnotationValue result = TypesFactory.eINSTANCE.createJvmShortAnnotationValue();\n\t\t\t\t\tshort[] shortValues = (short[]) value;\n\t\t\t\t\tfor (short s : shortValues)\n\t\t\t\t\t\t((InternalEList<Short>) result.getValues()).addUnique(s);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'I': {\n\t\t\t\t\tJvmIntAnnotationValue result = TypesFactory.eINSTANCE.createJvmIntAnnotationValue();\n\t\t\t\t\tint[] intValues = (int[]) value;\n\t\t\t\t\tfor (int i : intValues)\n\t\t\t\t\t\t((InternalEList<Integer>) result.getValues()).addUnique(i);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'F': {\n\t\t\t\t\tJvmFloatAnnotationValue result = TypesFactory.eINSTANCE.createJvmFloatAnnotationValue();\n\t\t\t\t\tfloat[] floatValues = (float[]) value;\n\t\t\t\t\tfor (float f : floatValues)\n\t\t\t\t\t\t((InternalEList<Float>) result.getValues()).addUnique(f);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'J': {\n\t\t\t\t\tJvmLongAnnotationValue result = TypesFactory.eINSTANCE.createJvmLongAnnotationValue();\n\t\t\t\t\tlong[] longValues = (long[]) value;\n\t\t\t\t\tfor (long l : longValues)\n\t\t\t\t\t\t((InternalEList<Long>) result.getValues()).addUnique(l);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcase 'D': {\n\t\t\t\t\tJvmDoubleAnnotationValue result = TypesFactory.eINSTANCE.createJvmDoubleAnnotationValue();\n\t\t\t\t\tdouble[] doubleValues = (double[]) value;\n\t\t\t\t\tfor (double d : doubleValues)\n\t\t\t\t\t\t((InternalEList<Double>) result.getValues()).addUnique(d);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(String.valueOf(value));\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"public JvmTypeReference createObjectTypeReference() {\n\t\treturn createTypeReference(BinarySignatures.createTypeSignature(JAVA_LANG_OBJECT), null);\n\t}","id":86841,"modified_method":"public JvmTypeReference createObjectTypeReference() {\n\t\treturn createTypeReference(BinarySignatures.createObjectTypeSignature(JAVA_LANG_OBJECT), null);\n\t}","commit_id":"5019a099db675115b09a188397700c907165661e","url":"https://github.com/eclipse/xtext"},{"original_method":"public List getSiteMembersInRole(final String siteContext, final Role role) {\n\t\tList sakaiMembers;\n\t\tString siteRef = SakaiUtil.getSiteReference();\n        if(role.isInstructor()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, siteRef);\n        } else if(role.isTeachingAssistant()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, siteRef);\n        } else if(role.isStudent()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.STUDENT_PERMISSION, siteRef);\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, siteRef));\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, siteRef));\n        } else {\n        \t// Role.NONE should throw an error\n        \tthrow new RuntimeException(\"Can not get site members in role \" + role.getDescription());\n        }\n        List membersList = new ArrayList();\n\n        // Get the course object associated with this site\n        HibernateCallback hc = new HibernateCallback() {\n        \tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n        \t\treturn getCourse(siteContext, session);\n        \t}\n        };\n        Course course = (Course)getHibernateTemplate().execute(hc);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n        \tif(role.isInstructor()) {\n        \t\tInstructorRecordImpl record = new InstructorRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isTeachingAssistant()) {\n        \t\tTeachingAssistantRecordImpl record = new TeachingAssistantRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isStudent()) {\n        \t\t// TODO Where do we get the enrollment status?\n        \t\tEnrollmentRecordImpl record = new EnrollmentRecordImpl(course, null, user);\n        \t\tmembersList.add(record);\n        \t}\n        }\n        return membersList;\n\t}","id":86842,"modified_method":"public List getSiteMembersInRole(final String siteContext, final Role role) {\n\t\tList sakaiMembers;\n\t\tString siteRef = SakaiUtil.getSiteReference();\n        if(role.isInstructor()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, siteRef);\n        } else if(role.isTeachingAssistant()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, siteRef);\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, siteRef));\n        } else if(role.isStudent()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.STUDENT_PERMISSION, siteRef);\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, siteRef));\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, siteRef));\n        } else {\n        \t// Role.NONE should throw an error\n        \tthrow new RuntimeException(\"Can not get site members in role \" + role.getDescription());\n        }\n        List membersList = new ArrayList();\n\n        // Get the course object associated with this site\n        HibernateCallback hc = new HibernateCallback() {\n        \tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n        \t\treturn getCourse(siteContext, session);\n        \t}\n        };\n        Course course = (Course)getHibernateTemplate().execute(hc);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n        \tif(role.isInstructor()) {\n        \t\tInstructorRecordImpl record = new InstructorRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isTeachingAssistant()) {\n        \t\tTeachingAssistantRecordImpl record = new TeachingAssistantRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isStudent()) {\n        \t\t// TODO Where do we get the enrollment status?\n        \t\tEnrollmentRecordImpl record = new EnrollmentRecordImpl(course, null, user);\n        \t\tmembersList.add(record);\n        \t}\n        }\n        return membersList;\n\t}","commit_id":"68d54ec18b46748d6fc3419b159111ffeec3b032","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List getSiteTeachingAssistants(final String siteContext) {\n        List sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, SakaiUtil.getSiteReference());\n        List membersList = new ArrayList();\n\n        Course course = getCourse(siteContext);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n    \t\tTeachingAssistantRecordImpl record = new TeachingAssistantRecordImpl(course, user);\n    \t\tmembersList.add(record);\n        }\n        return membersList;\n\t}","id":86843,"modified_method":"public List getSiteTeachingAssistants(final String siteContext) {\n\t\tString siteRef = SakaiUtil.getSiteReference();\n        List sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, siteRef);\n        sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, siteRef));\n\n        List membersList = new ArrayList();\n        Course course = getCourse(siteContext);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n    \t\tTeachingAssistantRecordImpl record = new TeachingAssistantRecordImpl(course, user);\n    \t\tmembersList.add(record);\n        }\n        return membersList;\n\t}","commit_id":"68d54ec18b46748d6fc3419b159111ffeec3b032","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Add to the user list any other users who should be notified about this ref's change.\n\t * \n\t * @param users\n\t *        The user list, already populated based on site visit and resource ability.\n\t * @param ref\n\t *        The entity reference.\n\t */\n\tprotected void addSpecialRecipients(List<User> users, Reference ref)\n\t{\n\t\t// include any users who have AnnouncementService.SECURE_ALL_GROUPS and getResourceAbility() in the context\n\t\tString contextRef = SiteService.siteReference(ref.getContext());\n\n\t\t// get the list of users who have SECURE_ALL_GROUPS\n\t\tList<User> allGroupUsers = SecurityService.unlockUsers(ContentHostingService.AUTH_RESOURCE_ALL_GROUPS, contextRef);\n\n\t\t// filter down by the permission\n\t\tif (getResourceAbility() != null)\n\t\t{\n\t\t\tList<User> allGroupUsers2 = SecurityService.unlockUsers(getResourceAbility(), contextRef);\n\t\t\tallGroupUsers.retainAll(allGroupUsers2);\n\t\t}\n\n\t\t// remove any in the list already\n\t\tallGroupUsers.removeAll(users);\n\n\t\t// combine\n\t\tusers.addAll(allGroupUsers);\n\t}","id":86844,"modified_method":"/**\n\t * Add to the user list any other users who should be notified about this ref's change.\n\t * \n\t * @param users\n\t *        The user list, already populated based on site visit and resource ability.\n\t * @param ref\n\t *        The entity reference.\n\t */\n\tprotected void addSpecialRecipients(List<User> users, Reference ref)\n\t{\n\t\t// include any users who have AnnouncementService.SECURE_ALL_GROUPS and getResourceAbility() in the context\n\t\tString contextRef = SiteService.siteReference(ref.getContext());\n\n\t\t// get the list of users who have SECURE_ALL_GROUPS\n\t\tList<User> allGroupUsers = SecurityService.unlockUsers(ContentHostingService.AUTH_RESOURCE_ALL_GROUPS, contextRef);\n\n\t\t// filter down by the permission\n\t\tif (getResourceAbility() != null)\n\t\t{\n\t\t\tboolean hidden = false;\n\t\t\tif (!ContentHostingService.isCollection(ref.getId())) {\n\t\t\t\ttry {\n\t\t\t\t\tContentResource resource = ContentHostingService.getResource(ref.getId());\n\t\t\t\t\thidden = resource.isHidden();\n\t\t\t\t\t\n\t\t\t\t    //we need to check the containing folder too\n\t\t\t\t\tContentCollection folder = resource.getContainingCollection();\n\t\t\t\t\tSystem.out.println(\"folder: \" + folder.getId() + \" is \" + folder.isHidden());\n\t\t\t\t\tif (folder.isHidden()) {\n\t\t\t\t\t\thidden = folder.isHidden();\n\t\t\t\t\t\tSystem.out.println(\"Folder is hidden!\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} catch (PermissionException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (IdUnusedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (TypeException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tList<User> allGroupUsers2 = null;\n\t\t\tif (!hidden) {\n\t\t\t\t//resource is visible get all users\n\t\t\t\tallGroupUsers2 = SecurityService.unlockUsers(getResourceAbility(), contextRef);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tallGroupUsers2 = SecurityService.unlockUsers(ContentHostingService.AUTH_RESOURCE_HIDDEN, contextRef);\n\t\t\t\t//we need to remove all users from the list as that is too open in this case\n\t\t\t\tusers.clear();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tallGroupUsers.retainAll(allGroupUsers2);\n\t\t}\n\n\t\t// remove any in the list already\n\t\tallGroupUsers.removeAll(users);\n\n\t\t// combine\n\t\tusers.addAll(allGroupUsers);\n\t}","commit_id":"c640009dc8575298fc92910becc7e5b437567b54","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @inheritDoc\n\t */\n\tpublic Role getSiteRole(String userUuid, String siteContext) {\n        boolean isInstructor = SecurityService.unlock(INSTRUCTOR_PERMISSION, siteContext);\n        boolean isTa = SecurityService.unlock(TA_PERMISSION, siteContext);\n        boolean isStudent = SecurityService.unlock(STUDENT_PERMISSION, siteContext);\n\n        if(isInstructor) {\n           return Role.INSTRUCTOR;\n        } else if(isTa) {\n            return Role.TA;\n        } else if(isStudent) {\n           return Role.STUDENT;\n        } else {\n           return Role.NONE;\n        }\n\t}","id":86845,"modified_method":"/**\n\t * @inheritDoc\n\t */\n\tpublic Role getSiteRole(String userUuid, String siteContext) {\n\t\tString siteAuthzRef = SakaiUtil.getSiteReference();\n        boolean isInstructor = SecurityService.unlock(INSTRUCTOR_PERMISSION, siteAuthzRef);\n        boolean isTa = SecurityService.unlock(TA_PERMISSION, siteAuthzRef);\n        boolean isStudent = SecurityService.unlock(STUDENT_PERMISSION, siteAuthzRef);\n\n        if(isInstructor) {\n           return Role.INSTRUCTOR;\n        } else if(isTa) {\n            return Role.TA;\n        } else if(isStudent) {\n           return Role.STUDENT;\n        } else {\n           return Role.NONE;\n        }\n\t}","commit_id":"7439294ef415ed6deab4067fa2a04ee0e4409437","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List getSiteMembersInRole(final String siteContext, final Role role) {\n        String authString = null;\n        if(role.isInstructor()) {\n        \tauthString = AuthzSakaiImpl.INSTRUCTOR_PERMISSION;\n        } else if(role.isTeachingAssistant()) {\n        \tauthString = AuthzSakaiImpl.TA_PERMISSION;\n        } else if(role.isStudent()) {\n        \tauthString = AuthzSakaiImpl.STUDENT_PERMISSION;\n        }\n        List sakaiMembers = SecurityService.unlockUsers(authString, SakaiUtil.getSiteReference());\n        List membersList = new ArrayList();\n\n        // Get the course object associated with this site\n        HibernateCallback hc = new HibernateCallback() {\n        \tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n        \t\treturn getCourse(siteContext, session);\n        \t}\n        };\n        Course course = (Course)getHibernateTemplate().execute(hc);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n        \tif(role.isInstructor()) {\n        \t\tInstructorRecordImpl record = new InstructorRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isTeachingAssistant()) {\n        \t\tTeachingAssistantRecordImpl record = new TeachingAssistantRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isStudent()) {\n        \t\t// TODO Where do we get the enrollment status?\n        \t\tEnrollmentRecordImpl record = new EnrollmentRecordImpl(course, user.getUserUuid(), null);\n        \t\tmembersList.add(record);\n        \t}\n        }\n        return membersList;\n\t}","id":86846,"modified_method":"public List getSiteMembersInRole(final String siteContext, final Role role) {\n\t\tList sakaiMembers;\n        if(role.isInstructor()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, SakaiUtil.getSiteReference());\n        } else if(role.isTeachingAssistant()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, SakaiUtil.getSiteReference());\n        } else if(role.isStudent()) {\n            sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.STUDENT_PERMISSION, SakaiUtil.getSiteReference());\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, SakaiUtil.getSiteReference()));\n            sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, SakaiUtil.getSiteReference()));\n        } else {\n        \t// Role.NONE should throw an error\n        \tthrow new RuntimeException(\"Can not get site members in role \" + role.getDescription());\n        }\n        List membersList = new ArrayList();\n\n        // Get the course object associated with this site\n        HibernateCallback hc = new HibernateCallback() {\n        \tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n        \t\treturn getCourse(siteContext, session);\n        \t}\n        };\n        Course course = (Course)getHibernateTemplate().execute(hc);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n        \tif(role.isInstructor()) {\n        \t\tInstructorRecordImpl record = new InstructorRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isTeachingAssistant()) {\n        \t\tTeachingAssistantRecordImpl record = new TeachingAssistantRecordImpl(course, user);\n        \t\tmembersList.add(record);\n        \t}\n        \tif(role.isStudent()) {\n        \t\t// TODO Where do we get the enrollment status?\n        \t\tEnrollmentRecordImpl record = new EnrollmentRecordImpl(course, user.getUserUuid(), null);\n        \t\tmembersList.add(record);\n        \t}\n        }\n        return membersList;\n\t}","commit_id":"7439294ef415ed6deab4067fa2a04ee0e4409437","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List getSiteEnrollments(final String siteContext) {\n        List sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.STUDENT_PERMISSION, SakaiUtil.getSiteReference());\n        List membersList = new ArrayList();\n\n        Course course = getCourse(siteContext);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n    \t\t// TODO Where do we get the enrollment status?\n    \t\tEnrollmentRecordImpl record = new EnrollmentRecordImpl(course, null, user);\n    \t\tmembersList.add(record);\n        }\n        return membersList;\n\t}","id":86847,"modified_method":"public List getSiteEnrollments(final String siteContext) {\n        List sakaiMembers = SecurityService.unlockUsers(AuthzSakaiImpl.STUDENT_PERMISSION, SakaiUtil.getSiteReference());\n        sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.INSTRUCTOR_PERMISSION, SakaiUtil.getSiteReference()));\n        sakaiMembers.removeAll(SecurityService.unlockUsers(AuthzSakaiImpl.TA_PERMISSION, SakaiUtil.getSiteReference()));\n        List membersList = new ArrayList();\n\n        Course course = getCourse(siteContext);\n        \n        for(Iterator iter = sakaiMembers.iterator(); iter.hasNext();) {\n        \torg.sakaiproject.service.legacy.user.User sakaiUser = (org.sakaiproject.service.legacy.user.User)iter.next();\n        \tUser user = SakaiUtil.convertUser(sakaiUser);\n    \t\t// TODO Where do we get the enrollment status?\n    \t\tEnrollmentRecordImpl record = new EnrollmentRecordImpl(course, null, user);\n    \t\tmembersList.add(record);\n        }\n        return membersList;\n\t}","commit_id":"7439294ef415ed6deab4067fa2a04ee0e4409437","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Nullable\n  public VcsSelection getSelection(final VcsContext context) {\n    PsiElement psiElement = TargetElementUtil.findTargetElement(context.getEditor(), TargetElementUtil.ELEMENT_NAME_ACCEPTED);\n    if (psiElement == null) {\n      return null;\n    }\n    if (!psiElement.isValid()) {\n      return null;\n    }\n    if (psiElement instanceof PsiCompiledElement) {\n      return null;\n    }\n\n    final String actionName;\n\n    if (psiElement instanceof PsiClass) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.class\");\n    }\n    else if (psiElement instanceof PsiField) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.field\");\n    }\n    else if (psiElement instanceof PsiMethod) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.method\");\n    }\n    else if (psiElement instanceof XmlTag) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.tag\");\n    }\n    else if (psiElement instanceof XmlText) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.text\");\n    }\n    else if (psiElement instanceof PsiCodeBlock) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.code.block\");\n    }\n    else if (psiElement instanceof PsiStatement) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.statement\");\n    }\n    else {\n      return null;\n    }\n\n    TextRange textRange = psiElement.getTextRange();\n    if (textRange == null) {\n      return null;\n    }\n\n    VirtualFile virtualFile = psiElement.getContainingFile().getVirtualFile();\n    if (virtualFile == null) {\n      return null;\n    }\n    if (!virtualFile.isValid()) {\n      return null;\n    }\n\n    Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n    return new VcsSelection(document, textRange, actionName);\n  }","id":86848,"modified_method":"@Nullable\n  public VcsSelection getSelection(final VcsContext context) {\n    final Editor editor = context.getEditor();\n    if (editor == null) return null;\n    PsiElement psiElement = TargetElementUtil.findTargetElement(editor, TargetElementUtil.ELEMENT_NAME_ACCEPTED);\n    if (psiElement == null) {\n      return null;\n    }\n    if (!psiElement.isValid()) {\n      return null;\n    }\n    if (psiElement instanceof PsiCompiledElement) {\n      return null;\n    }\n\n    final String actionName;\n\n    if (psiElement instanceof PsiClass) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.class\");\n    }\n    else if (psiElement instanceof PsiField) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.field\");\n    }\n    else if (psiElement instanceof PsiMethod) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.method\");\n    }\n    else if (psiElement instanceof XmlTag) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.tag\");\n    }\n    else if (psiElement instanceof XmlText) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.text\");\n    }\n    else if (psiElement instanceof PsiCodeBlock) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.code.block\");\n    }\n    else if (psiElement instanceof PsiStatement) {\n      actionName = VcsBundle.message(\"action.name.show.history.for.statement\");\n    }\n    else {\n      return null;\n    }\n\n    TextRange textRange = psiElement.getTextRange();\n    if (textRange == null) {\n      return null;\n    }\n\n    VirtualFile virtualFile = psiElement.getContainingFile().getVirtualFile();\n    if (virtualFile == null) {\n      return null;\n    }\n    if (!virtualFile.isValid()) {\n      return null;\n    }\n\n    Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n    return new VcsSelection(document, textRange, actionName);\n  }","commit_id":"fc73f7fbe9828e9869ca9119b4b9fdc1f340794c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void storeOriginalElement(final Project project, final PsiElement originalElement, final PsiElement element) {\n    try {\n      element.putUserData(\n        ORIGINAL_ELEMENT_KEY,\n        SmartPointerManager.getInstance(project).createSmartPsiElementPointer(originalElement)\n      );\n    } catch (RuntimeException ex) {\n      // PsiPackage does not allow putUserData\n    }\n  }","id":86849,"modified_method":"private static void storeOriginalElement(final Project project, final PsiElement originalElement, final PsiElement element) {\n    if (element == null) return;\n    try {\n      element.putUserData(\n        ORIGINAL_ELEMENT_KEY,\n        SmartPointerManager.getInstance(project).createSmartPsiElementPointer(originalElement)\n      );\n    } catch (RuntimeException ex) {\n      // PsiPackage does not allow putUserData\n    }\n  }","commit_id":"f7472a45efec6b55ed6e8e338570d9578733930d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement findTargetElement(final Editor editor, final PsiFile file, PsiElement contextElement) {\n    PsiElement element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements);\n\n    // Allow context doc over xml tag content\n    if (element == null && contextElement != null) {\n        final PsiElement parent = contextElement.getParent();\n        if (parent instanceof XmlText) {\n          element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements,\n                                                             parent.getParent().getTextRange().getStartOffset() + 1\n                                                           );\n        } else if (parent instanceof XmlTag || parent instanceof XmlAttribute) {\n          element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements,\n                                                             parent.getTextRange().getStartOffset() + 1\n                                                           );\n        } else if (parent instanceof XmlAttributeValue) {\n          final PsiElement grandParent = parent.getParent();\n          element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements,\n                                                             grandParent.getTextRange().getStartOffset() + 1\n                                                           );\n        }\n    }\n\n    if (element == null && editor != null) {\n      final PsiReference ref = TargetElementUtil.findReference(editor, editor.getCaretModel().getOffset());\n\n      if (ref != null) {\n        final PsiElement parent = ref.getElement().getParent();\n\n        if (parent instanceof PsiMethodCallExpression) {\n          element = parent;\n        } else if (ref instanceof PsiPolyVariantReference) {\n          element = ref.getElement();\n        }\n      }\n\n      final Lookup activeLookup = LookupManager.getInstance(file.getProject()).getActiveLookup();\n\n      if (activeLookup != null) {\n        LookupItem item = activeLookup.getCurrentItem();\n        if (item == null) return null;\n\n        final DocumentationProvider documentationProvider = getProviderFromElement(file);\n\n        if (documentationProvider!=null) {\n          element = documentationProvider.getDocumentationElementForLookupItem(\n            file.getManager(),\n            item.getObject(),\n            ref != null ? ref.getElement():contextElement\n          );\n        }\n      }\n    }\n\n    storeOriginalElement(file.getProject(), contextElement, element);\n\n    return element;\n  }","id":86850,"modified_method":"@Nullable\n  public PsiElement findTargetElement(final Editor editor, @Nullable final PsiFile file, PsiElement contextElement) {\n    PsiElement element = editor != null ? TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements) : null;\n\n    // Allow context doc over xml tag content\n    if (element == null && contextElement != null) {\n        final PsiElement parent = contextElement.getParent();\n        if (parent instanceof XmlText) {\n          element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements,\n                                                             parent.getParent().getTextRange().getStartOffset() + 1\n                                                           );\n        } else if (parent instanceof XmlTag || parent instanceof XmlAttribute) {\n          element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements,\n                                                             parent.getTextRange().getStartOffset() + 1\n                                                           );\n        } else if (parent instanceof XmlAttributeValue) {\n          final PsiElement grandParent = parent.getParent();\n          element = TargetElementUtil.findTargetElement(editor, ourFlagsForTargetElements,\n                                                             grandParent.getTextRange().getStartOffset() + 1\n                                                           );\n        }\n    }\n\n    if (element == null && editor != null) {\n      final PsiReference ref = TargetElementUtil.findReference(editor, editor.getCaretModel().getOffset());\n\n      if (ref != null) {\n        final PsiElement parent = ref.getElement().getParent();\n\n        if (parent instanceof PsiMethodCallExpression) {\n          element = parent;\n        } else if (ref instanceof PsiPolyVariantReference) {\n          element = ref.getElement();\n        }\n      }\n\n      final Lookup activeLookup = LookupManager.getInstance(myProject).getActiveLookup();\n\n      if (activeLookup != null) {\n        LookupItem item = activeLookup.getCurrentItem();\n        if (item == null) return null;\n\n        final DocumentationProvider documentationProvider = getProviderFromElement(file);\n\n        if (documentationProvider!=null) {\n          element = documentationProvider.getDocumentationElementForLookupItem(\n            PsiManager.getInstance(myProject),\n            item.getObject(),\n            ref != null ? ref.getElement():contextElement\n          );\n        }\n      }\n    }\n\n    storeOriginalElement(myProject, contextElement, element);\n\n    return element;\n  }","commit_id":"f7472a45efec6b55ed6e8e338570d9578733930d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ResultsFilter createFilter(Project project, final Editor editor, final PsiFile file, PsiElement element, final int offset) {\n    final PsiElement element1 = TargetElementUtil.findTargetElement(editor, TargetElementUtil.ELEMENT_NAME_ACCEPTED, offset);\n\n    return new ResultsFilter() {\n      public boolean acceptClass(PsiClass aClass) {\n        return aClass != element1;\n      }\n\n      public boolean acceptMethod(PsiMethod method) {\n        return method != element1;\n      }\n    };\n  }","id":86851,"modified_method":"protected ResultsFilter createFilter(Project project, final Editor editor, final PsiFile file, PsiElement element, final int offset) {\n    final PsiElement element1 = editor == null ? null : TargetElementUtil.findTargetElement(editor, TargetElementUtil.ELEMENT_NAME_ACCEPTED, offset);\n\n    return new ResultsFilter() {\n      public boolean acceptClass(PsiClass aClass) {\n        return aClass != element1;\n      }\n\n      public boolean acceptMethod(PsiMethod method) {\n        return method != element1;\n      }\n    };\n  }","commit_id":"c9bf670c40ef726e2a42d58391b50dcefc9f7140","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiElement[] getSelfAndImplementations(Editor editor, PsiFile file, PsiElement element) {\n    GotoImplementationHandler handler = new GotoImplementationHandler() {\n      protected PsiElement[] filterElements(Editor editor, PsiFile file, PsiElement element, PsiElement[] targetElements, final int offset) {\n        Set<PsiElement> unique = new LinkedHashSet<PsiElement>(Arrays.asList(targetElements));\n        for (PsiElement elt : targetElements) {\n          PsiFile psiFile = elt.getContainingFile();\n          final PsiFile originalFile = psiFile.getOriginalFile();\n          if (originalFile != null) psiFile = originalFile;\n          if (psiFile.getVirtualFile() == null) unique.remove(elt);\n        }\n        return unique.toArray(new PsiElement[unique.size()]);\n      }\n    };\n\n    final PsiElement[] handlerImplementations = handler.searchImplementations(editor, file, element, editor.getCaretModel().getOffset(), true, true);\n    if (handlerImplementations.length > 0) return handlerImplementations;\n\n    PsiFile psiFile = element.getContainingFile();\n    if (psiFile == null) {\n      // Magically, it's null for ant property declarations.\n      element = element.getNavigationElement();\n      psiFile = element.getContainingFile();\n      if (psiFile == null) return PsiElement.EMPTY_ARRAY;\n    }\n    return psiFile.getVirtualFile() != null ? new PsiElement[] {element} : PsiElement.EMPTY_ARRAY;\n  }","id":86852,"modified_method":"private static PsiElement[] getSelfAndImplementations(Editor editor, PsiFile file, PsiElement element) {\n    GotoImplementationHandler handler = new GotoImplementationHandler() {\n      protected PsiElement[] filterElements(Editor editor, PsiFile file, PsiElement element, PsiElement[] targetElements, final int offset) {\n        Set<PsiElement> unique = new LinkedHashSet<PsiElement>(Arrays.asList(targetElements));\n        for (PsiElement elt : targetElements) {\n          PsiFile psiFile = elt.getContainingFile();\n          final PsiFile originalFile = psiFile.getOriginalFile();\n          if (originalFile != null) psiFile = originalFile;\n          if (psiFile.getVirtualFile() == null) unique.remove(elt);\n        }\n        return unique.toArray(new PsiElement[unique.size()]);\n      }\n    };\n\n    int offset = editor == null ? 0 : editor.getCaretModel().getOffset();\n    final PsiElement[] handlerImplementations = handler.searchImplementations(editor, file, element, offset, true, true);\n    if (handlerImplementations.length > 0) return handlerImplementations;\n\n    PsiFile psiFile = element.getContainingFile();\n    if (psiFile == null) {\n      // Magically, it's null for ant property declarations.\n      element = element.getNavigationElement();\n      psiFile = element.getContainingFile();\n      if (psiFile == null) return PsiElement.EMPTY_ARRAY;\n    }\n    return psiFile.getVirtualFile() != null ? new PsiElement[] {element} : PsiElement.EMPTY_ARRAY;\n  }","commit_id":"c9bf670c40ef726e2a42d58391b50dcefc9f7140","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createDependencyReducedPom( Set artifactsToRemove )\n        throws IOException, DependencyTreeBuilderException, ProjectBuildingException\n    {\n        Model model = project.getOriginalModel();\n        List dependencies = new ArrayList();\n\n        boolean modified = false;\n\n        List transitiveDeps = new ArrayList();\n\n        for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            //promote\n            Dependency dep = new Dependency();\n            dep.setArtifactId( artifact.getArtifactId() );\n            if ( artifact.hasClassifier() )\n            {\n                dep.setClassifier( artifact.getClassifier() );\n            }\n            dep.setGroupId( artifact.getGroupId() );\n            dep.setOptional( artifact.isOptional() );\n            dep.setScope( artifact.getScope() );\n            dep.setType( artifact.getType() );\n            dep.setVersion( artifact.getVersion() );\n\n            //we'll figure out the exclusions in a bit.\n\n            transitiveDeps.add( dep );\n        }\n        List origDeps = project.getDependencies();\n\n        if ( promoteTransitiveDependencies )\n        {\n            origDeps = transitiveDeps;\n        }\n\n        for ( Iterator i = origDeps.iterator(); i.hasNext(); )\n        {\n            Dependency d = (Dependency) i.next();\n\n            dependencies.add( d );\n\n            String id = d.getGroupId() + \":\" + d.getArtifactId();\n\n            if ( artifactsToRemove.contains( id ) )\n            {\n                modified = true;\n\n                if ( keepDependenciesWithProvidedScope )\n                {\n                    d.setScope( \"provided\" );\n                }\n                else\n                {\n                    dependencies.remove( d );\n                }\n            }\n        }\n\n        // Check to see if we have a reduction and if so rewrite the POM.\n        if ( modified )\n        {\n            while ( modified )\n            {\n\n                model.setDependencies( dependencies );\n\n                /*\n                 * NOTE: Be sure to create the POM in the original base directory to be able to resolve the relativePath\n                 * to local parent POMs when invoking the project builder below.\n                 */\n                File f = new File( project.getBasedir(), \"dependency-reduced-pom.xml\" );\n                if ( f.exists() )\n                {\n                    f.delete();\n                }\n\n                Writer w = WriterFactory.newXmlWriter( f );\n\n                try\n                {\n                    PomWriter.write( w, model, true );\n                }\n                finally\n                {\n                    w.close();\n                }\n\n                MavenProject p2 = mavenProjectBuilder.build( f, localRepository, null );\n                modified = updateExcludesInDeps( p2, dependencies, transitiveDeps );\n\n            }\n\n            /*\n             * NOTE: Although the dependency reduced POM in the project directory is temporary build output, we have to\n             * use that for the file of the project instead of something in target to avoid messing up the base\n             * directory of the project. We'll delete this file on exit to make sure it gets cleaned up but keep a copy\n             * for inspection in the target directory as well.\n             */\n            File f = new File( project.getBasedir(), \"dependency-reduced-pom.xml\" );\n            File f2 = new File( outputDirectory, \"dependency-reduced-pom.xml\" );\n            FileUtils.copyFile( f, f2 );\n            FileUtils.forceDeleteOnExit( f );\n            project.setFile( f );\n        }\n    }","id":86853,"modified_method":"private void createDependencyReducedPom( Set artifactsToRemove )\n        throws IOException, DependencyTreeBuilderException, ProjectBuildingException\n    {\n        Model model = project.getOriginalModel();\n        List dependencies = new ArrayList();\n\n        boolean modified = false;\n\n        List transitiveDeps = new ArrayList();\n\n        for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            //promote\n            Dependency dep = new Dependency();\n            dep.setArtifactId( artifact.getArtifactId() );\n            if ( artifact.hasClassifier() )\n            {\n                dep.setClassifier( artifact.getClassifier() );\n            }\n            dep.setGroupId( artifact.getGroupId() );\n            dep.setOptional( artifact.isOptional() );\n            dep.setScope( artifact.getScope() );\n            dep.setType( artifact.getType() );\n            dep.setVersion( artifact.getVersion() );\n\n            //we'll figure out the exclusions in a bit.\n\n            transitiveDeps.add( dep );\n        }\n        List origDeps = project.getDependencies();\n\n        if ( promoteTransitiveDependencies )\n        {\n            origDeps = transitiveDeps;\n        }\n\n        for ( Iterator i = origDeps.iterator(); i.hasNext(); )\n        {\n            Dependency d = (Dependency) i.next();\n\n            dependencies.add( d );\n\n            String id = getId( d );\n\n            if ( artifactsToRemove.contains( id ) )\n            {\n                modified = true;\n\n                if ( keepDependenciesWithProvidedScope )\n                {\n                    d.setScope( \"provided\" );\n                }\n                else\n                {\n                    dependencies.remove( d );\n                }\n            }\n        }\n\n        // Check to see if we have a reduction and if so rewrite the POM.\n        if ( modified )\n        {\n            while ( modified )\n            {\n\n                model.setDependencies( dependencies );\n\n                /*\n                 * NOTE: Be sure to create the POM in the original base directory to be able to resolve the relativePath\n                 * to local parent POMs when invoking the project builder below.\n                 */\n                File f = new File( project.getBasedir(), \"dependency-reduced-pom.xml\" );\n                if ( f.exists() )\n                {\n                    f.delete();\n                }\n\n                Writer w = WriterFactory.newXmlWriter( f );\n\n                try\n                {\n                    PomWriter.write( w, model, true );\n                }\n                finally\n                {\n                    w.close();\n                }\n\n                MavenProject p2 = mavenProjectBuilder.build( f, localRepository, null );\n                modified = updateExcludesInDeps( p2, dependencies, transitiveDeps );\n\n            }\n\n            /*\n             * NOTE: Although the dependency reduced POM in the project directory is temporary build output, we have to\n             * use that for the file of the project instead of something in target to avoid messing up the base\n             * directory of the project. We'll delete this file on exit to make sure it gets cleaned up but keep a copy\n             * for inspection in the target directory as well.\n             */\n            File f = new File( project.getBasedir(), \"dependency-reduced-pom.xml\" );\n            File f2 = new File( outputDirectory, \"dependency-reduced-pom.xml\" );\n            FileUtils.copyFile( f, f2 );\n            FileUtils.forceDeleteOnExit( f );\n            project.setFile( f );\n        }\n    }","commit_id":"b83bac99fe084a07488ef970451ace86343f0093","url":"https://github.com/apache/maven-plugins"},{"original_method":"private String getId( Artifact artifact )\n    {\n        if ( artifact.getClassifier() == null || \"jar\".equals( artifact.getClassifier() ) )\n        {\n            return artifact.getGroupId() + \":\" + artifact.getArtifactId();\n        }\n        else\n        {\n            return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getClassifier();\n        }\n    }","id":86854,"modified_method":"private String getId( Artifact artifact )\n    {\n        return getId( artifact.getGroupId(), artifact.getArtifactId(), artifact.getClassifier() );\n    }","commit_id":"b83bac99fe084a07488ef970451ace86343f0093","url":"https://github.com/apache/maven-plugins"},{"original_method":"public DefaultClientModule createDependency(String notation) {\n            ParsedModuleStringNotation parsedNotation = new ParsedModuleStringNotation(notation, null);\n            DefaultClientModule clientModule = new DefaultClientModule(\n                    parsedNotation.getGroup(),\n                    parsedNotation.getName(),\n                    parsedNotation.getVersion());\n            ModuleFactoryHelper.addClassifierArtifactIfSet(parsedNotation.getClassifier(), clientModule);\n            return clientModule;\n        }","id":86855,"modified_method":"public DefaultClientModule createDependency(String notation) {\n            ParsedModuleStringNotation parsedNotation = new ParsedModuleStringNotation(notation, null);\n            DefaultClientModule clientModule = new DefaultClientModule(\n                    parsedNotation.getGroup(),\n                    parsedNotation.getName(),\n                    parsedNotation.getVersion());\n            ModuleFactoryHelper.addExplicitArtifactsIfDefined(clientModule, null, parsedNotation.getClassifier());\n            return clientModule;\n        }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"private void addExcludeRules(DefaultModuleDescriptor moduleDescriptor, Set<Configuration> configurations) {\n        for (Configuration configuration : configurations) {\n            for (ExcludeRule excludeRule : configuration.getExcludeRules()) {\n                moduleDescriptor.addExcludeRule(excludeRuleConverter.createExcludeRule(excludeRule));\n            }\n        }\n    }","id":86856,"modified_method":"private void addExcludeRules(DefaultModuleDescriptor moduleDescriptor, Set<Configuration> configurations) {\n        for (Configuration configuration : configurations) {\n            for (ExcludeRule excludeRule : configuration.getExcludeRules()) {\n                org.apache.ivy.core.module.descriptor.ExcludeRule rule = excludeRuleConverter.createExcludeRule(\n                        configuration.getName(), excludeRule);\n                moduleDescriptor.addExcludeRule(rule);\n            }\n        }\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"private void associateGradleExcludeRuleWithIvyExcludeRule(final ExcludeRule gradleExcludeRule,\n                                                              final org.apache.ivy.core.module.descriptor.ExcludeRule ivyExcludeRule,\n                                                              final Configuration configuration) {\n        context.checking(new Expectations() {{\n            allowing(excludeRuleConverterStub).createExcludeRule(gradleExcludeRule);\n            will(returnValue(ivyExcludeRule));\n\n            allowing(ivyExcludeRule).getConfigurations();\n            will(returnValue(WrapUtil.toArray(configuration.getName())));\n        }});\n    }","id":86857,"modified_method":"private void associateGradleExcludeRuleWithIvyExcludeRule(final ExcludeRule gradleExcludeRule,\n                                                              final org.apache.ivy.core.module.descriptor.ExcludeRule ivyExcludeRule,\n                                                              final Configuration configuration) {\n        final String expectedConfigurationName = configuration.getName();\n        context.checking(new Expectations() {{\n            allowing(excludeRuleConverterStub).createExcludeRule(expectedConfigurationName, gradleExcludeRule);\n            will(returnValue(ivyExcludeRule));\n\n            allowing(ivyExcludeRule).getConfigurations();\n            will(returnValue(WrapUtil.toArray(configuration.getName())));\n        }});\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"private void addExcludes(String configuration, Set<ExcludeRule> excludeRules, DefaultDependencyDescriptor dependencyDescriptor) {\n        for (ExcludeRule excludeRule : excludeRules) {\n            dependencyDescriptor.addExcludeRule(configuration, excludeRuleConverter.createExcludeRule(excludeRule));\n        }\n    }","id":86858,"modified_method":"private void addExcludes(String configuration, Set<ExcludeRule> excludeRules, DefaultDependencyDescriptor dependencyDescriptor) {\n        for (ExcludeRule excludeRule : excludeRules) {\n            dependencyDescriptor.addExcludeRule(configuration, excludeRuleConverter.createExcludeRule(configuration, excludeRule));\n        }\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"@Before\n    public void setUp() {\n        dependencyDescriptorFactory = new DefaultDependencyDescriptorFactory();\n        dependencyDescriptorFactory.setExcludeRuleConverter(excludeRuleConverterStub);\n        context.checking(new Expectations() {{\n            allowing(excludeRuleConverterStub).createExcludeRule(TEST_EXCLUDE_RULE);\n            will(returnValue(TEST_IVY_EXCLUDE_RULE));\n        }});\n    }","id":86859,"modified_method":"@Before\n    public void setUp() {\n        dependencyDescriptorFactory = new DefaultDependencyDescriptorFactory();\n        dependencyDescriptorFactory.setExcludeRuleConverter(excludeRuleConverterStub);\n        context.checking(new Expectations() {{\n            allowing(excludeRuleConverterStub).createExcludeRule(TEST_CONF, TEST_EXCLUDE_RULE);\n            will(returnValue(TEST_IVY_EXCLUDE_RULE));\n        }});\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultExcludeRule createExcludeRule(ExcludeRule excludeRule) {\n        String org = GUtil.elvis(excludeRule.getExcludeArgs().get(ExcludeRule.GROUP_KEY), PatternMatcher.ANY_EXPRESSION);\n        String module = GUtil.elvis(excludeRule.getExcludeArgs().get(ExcludeRule.MODULE_KEY), PatternMatcher.ANY_EXPRESSION);\n        DefaultExcludeRule ivyExcludeRule = new DefaultExcludeRule(new ArtifactId(\n                new ModuleId(org, module), PatternMatcher.ANY_EXPRESSION,\n                PatternMatcher.ANY_EXPRESSION,\n                PatternMatcher.ANY_EXPRESSION),\n                ExactPatternMatcher.INSTANCE, null);\n        return ivyExcludeRule;\n    }","id":86860,"modified_method":"public DefaultExcludeRule createExcludeRule(String configurationName, ExcludeRule excludeRule) {\n        String org = GUtil.elvis(excludeRule.getExcludeArgs().get(ExcludeRule.GROUP_KEY), PatternMatcher.ANY_EXPRESSION);\n        String module = GUtil.elvis(excludeRule.getExcludeArgs().get(ExcludeRule.MODULE_KEY), PatternMatcher.ANY_EXPRESSION);\n        DefaultExcludeRule ivyExcludeRule = new DefaultExcludeRule(new ArtifactId(\n                new ModuleId(org, module), PatternMatcher.ANY_EXPRESSION,\n                PatternMatcher.ANY_EXPRESSION,\n                PatternMatcher.ANY_EXPRESSION),\n                ExactPatternMatcher.INSTANCE, null);\n        ivyExcludeRule.addConfiguration(configurationName);\n        return ivyExcludeRule;\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testCreateExcludeRule() {\n        Map excludeRuleArgs = GUtil.map(ExcludeRule.GROUP_KEY, \"someOrg\", ExcludeRule.MODULE_KEY, \"someModule\");\n        org.apache.ivy.core.module.descriptor.ExcludeRule ivyExcludeRule =\n                new DefaultExcludeRuleConverter().createExcludeRule(new DefaultExcludeRule(excludeRuleArgs));\n        assertThat(ivyExcludeRule.getId().getModuleId().getOrganisation(),\n                Matchers.equalTo(excludeRuleArgs.get(ExcludeRule.GROUP_KEY)));\n        assertThat(ivyExcludeRule.getId().getName(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getExt(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getType(), \n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat((ExactPatternMatcher) ivyExcludeRule.getMatcher(),\n                Matchers.equalTo(ExactPatternMatcher.INSTANCE));\n    }","id":86861,"modified_method":"@Test\n    public void testCreateExcludeRule() {\n        String configurationName = \"someConf\";\n        Map excludeRuleArgs = GUtil.map(ExcludeRule.GROUP_KEY, \"someOrg\", ExcludeRule.MODULE_KEY, \"someModule\");\n        org.apache.ivy.core.module.descriptor.ExcludeRule ivyExcludeRule =\n                new DefaultExcludeRuleConverter().createExcludeRule(configurationName, new DefaultExcludeRule(excludeRuleArgs));\n        assertThat(ivyExcludeRule.getId().getModuleId().getOrganisation(),\n                Matchers.equalTo(excludeRuleArgs.get(ExcludeRule.GROUP_KEY)));\n        assertThat(ivyExcludeRule.getId().getName(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getExt(),\n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat(ivyExcludeRule.getId().getType(), \n                Matchers.equalTo(PatternMatcher.ANY_EXPRESSION));\n        assertThat((ExactPatternMatcher) ivyExcludeRule.getMatcher(),\n                Matchers.equalTo(ExactPatternMatcher.INSTANCE));\n        assertThat(ivyExcludeRule.getConfigurations(),\n                Matchers.equalTo(WrapUtil.toArray(configurationName)));\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"public ExternalDependency createDependency(Class<? extends ExternalDependency> dependencyType, Map<String, Object> map) {\n        Map<String, Object> args = new HashMap<String, Object>(map);\n        String group = getAndRemove(args, \"group\");\n        String name = getAndRemove(args, \"name\");\n        String version = getAndRemove(args, \"version\");\n        try {\n            ExternalDependency dependency = dependencyType.getConstructor(String.class, String.class, String.class).\n                    newInstance(group, name, version);\n            ModuleFactoryHelper.addClassifierArtifactIfSet(getAndRemove(args, \"classifier\"), dependency);\n            for (String property : args.keySet()) {\n                ReflectionUtil.setProperty(dependency, property, args.get(property));\n            }\n            return dependency;\n        } catch (InstantiationException e) {\n            throw new GradleException(e);\n        } catch (IllegalAccessException e) {\n            throw new GradleException(e);\n        } catch (InvocationTargetException e) {\n            throw new GradleException(e);\n        } catch (NoSuchMethodException e) {\n            throw new GradleException(e);\n        }\n    }","id":86862,"modified_method":"public ExternalDependency createDependency(Class<? extends ExternalDependency> dependencyType, Map<String, Object> map) {\n        Map<String, Object> args = new HashMap<String, Object>(map);\n        String group = getAndRemove(args, \"group\");\n        String name = getAndRemove(args, \"name\");\n        String version = getAndRemove(args, \"version\");\n        try {\n            ExternalDependency dependency = dependencyType.getConstructor(String.class, String.class, String.class).\n                    newInstance(group, name, version);\n            ModuleFactoryHelper.addExplicitArtifactsIfDefined(dependency, getAndRemove(args, \"ext\"), getAndRemove(args, \"classifier\"));\n            GradleUtil.setFromMap(dependency, args);\n            return dependency;\n        } catch (InstantiationException e) {\n            throw new GradleException(e);\n        } catch (IllegalAccessException e) {\n            throw new GradleException(e);\n        } catch (InvocationTargetException e) {\n            throw new GradleException(e);\n        } catch (NoSuchMethodException e) {\n            throw new GradleException(e);\n        }\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultModuleDependency createDependency(String notation) {\n            ParsedModuleStringNotation parsedNotation = splitDescriptionIntoModuleNotationAndArtifactType(notation);\n            DefaultModuleDependency moduleDependency = new DefaultModuleDependency(\n                    parsedNotation.getGroup(),\n                    parsedNotation.getName(),\n                    parsedNotation.getVersion());\n            String actualArtifactType = parsedNotation.getArtifactType();\n            if (parsedNotation.getArtifactType() == null) {\n                if (parsedNotation.getClassifier() != null) {\n                    actualArtifactType = DependencyArtifact.DEFAULT_TYPE;\n                }\n            } else {\n                moduleDependency.setTransitive(false);\n            }\n            if (actualArtifactType != null) {\n                moduleDependency.addArtifact(new DefaultDependencyArtifact(moduleDependency.getName(),\n                        actualArtifactType, actualArtifactType, parsedNotation.getClassifier(), null));\n            }\n            return moduleDependency;\n        }","id":86863,"modified_method":"public DefaultModuleDependency createDependency(String notation) {\n            ParsedModuleStringNotation parsedNotation = splitDescriptionIntoModuleNotationAndArtifactType(notation);\n            DefaultModuleDependency moduleDependency = new DefaultModuleDependency(\n                    parsedNotation.getGroup(),\n                    parsedNotation.getName(),\n                    parsedNotation.getVersion());\n            ModuleFactoryHelper.addExplicitArtifactsIfDefined(moduleDependency, parsedNotation.getArtifactType(), parsedNotation.getClassifier());\n            return moduleDependency;\n        }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testStringNotationWithArtifact() {\n        ExternalDependency moduleDependency = createDependency(TEST_ARTIFACT_DESCRIPTOR);\n        checkCommonModuleProperties(moduleDependency);\n        assertFalse(moduleDependency.isTransitive());\n        assertEquals(1, moduleDependency.getArtifacts().size());\n        DependencyArtifact artifact = moduleDependency.getArtifacts().iterator().next();\n        assertEquals(TEST_NAME, artifact.getName());\n        assertEquals(TEST_TYPE, artifact.getType());\n        assertEquals(null, artifact.getClassifier());\n    }","id":86864,"modified_method":"@Test\n    public void testStringNotationWithArtifact() {\n        ExternalDependency moduleDependency = createDependency(TEST_ARTIFACT_DESCRIPTOR);\n        assertIsArtifactOnly(moduleDependency);\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testStringNotationWithArtifactAndClassifier() {\n        ExternalDependency moduleDependency = createDependency(TEST_ARTIFACT_DESCRIPTOR_WITH_CLASSIFIER);\n        checkCommonModuleProperties(moduleDependency);\n        assertFalse(moduleDependency.isTransitive());\n        assertEquals(1, moduleDependency.getArtifacts().size());\n        DependencyArtifact artifact = moduleDependency.getArtifacts().iterator().next();\n        assertEquals(TEST_NAME, artifact.getName());\n        assertEquals(TEST_TYPE, artifact.getType());\n        assertEquals(TEST_TYPE, artifact.getExtension());\n        assertEquals(TEST_CLASSIFIER, artifact.getClassifier());\n    }","id":86865,"modified_method":"@Test\n    public void testStringNotationWithArtifactAndClassifier() {\n        ExternalDependency moduleDependency = createDependency(TEST_ARTIFACT_DESCRIPTOR_WITH_CLASSIFIER);\n        assertIsArtifactOnlyWithClassifier(moduleDependency);\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"public static void addClassifierArtifactIfSet(String classifier, ExternalDependency dependency) {\n        if (classifier != null) {\n            dependency.addArtifact(new DefaultDependencyArtifact(dependency.getName(),\n                    DependencyArtifact.DEFAULT_TYPE, DependencyArtifact.DEFAULT_TYPE, classifier, null));\n        }\n    }","id":86866,"modified_method":"public static void addExplicitArtifactsIfDefined(ExternalDependency moduleDependency, String artifactType, String classifier) {\n        String actualArtifactType = artifactType;\n        if (actualArtifactType == null) {\n            if (classifier != null) {\n                actualArtifactType = DependencyArtifact.DEFAULT_TYPE;\n            }\n        } else {\n            moduleDependency.setTransitive(false);\n        }\n        if (actualArtifactType != null) {\n            moduleDependency.addArtifact(new DefaultDependencyArtifact(moduleDependency.getName(),\n                    actualArtifactType, actualArtifactType, classifier, null));\n        }\n    }","commit_id":"cb1508af9451e1719023eac6bc3c0ce1d383e79e","url":"https://github.com/gradle/gradle"},{"original_method":"public void init(PortletConfig config) throws PortletException {\n\t\t_portletConfig = (PortletConfigImpl)config;\n\n\t\t_portletId = _portletConfig.getPortletId();\n\n\t\tClassLoader classLoader = _getPortletClassLoader();\n\n\t\tif (classLoader != null) {\n\t\t\tThread.currentThread().setContextClassLoader(classLoader);\n\t\t}\n\n\t\t_portlet.init(config);\n\n\t\tif (classLoader != null) {\n\t\t\tThread.currentThread().setContextClassLoader(\n\t\t\t\tclassLoader.getParent());\n\t\t}\n\n\t\t_destroyable = true;\n\t}","id":86867,"modified_method":"public void init(PortletConfig config) throws PortletException {\n\t\t_portletConfig = (PortletConfigImpl)config;\n\n\t\t_portletId = _portletConfig.getPortletId();\n\n\t\tClassLoader portletClassLoader = _getPortletClassLoader();\n\t\t\n\t\tClassLoader currentClassLoader = \n\t\t\tThread.currentThread().getContextClassLoader();\n\n\t\tif (portletClassLoader != null) {\n\t\t\tThread.currentThread().setContextClassLoader(portletClassLoader);\n\t\t}\n\n\t\t_portlet.init(config);\n\n\t\tif (portletClassLoader != null) {\n\t\t\tThread.currentThread().setContextClassLoader(currentClassLoader);\n\t\t}\n\n\t\t_destroyable = true;\n\t}","commit_id":"4c35c352f72b63a15bd9ce601b70a8088ab1df59","url":"https://github.com/liferay/liferay-portal"},{"original_method":"static void activate(final DeploymentProcessorTarget processorTarget) {\n\n        processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEBSERVICES_XML, new WSDescriptorDeploymentProcessor());\n        processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WS_EJB_INTEGRATION, new WSEJBIntegrationProcessor());\n        processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WS, new WSDependenciesProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_JMS_INTEGRATION, new WSJMSIntegrationProcessor());\n        //processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_JAXRPC, new WSJAXRPCDependenciesDeploymentProcessor());\n        processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WS_UNIVERSAL_META_DATA_MODEL, new WSModelDeploymentProcessor());\n\n        addDeploymentProcessors(processorTarget, Phase.INSTALL, Phase.INSTALL_WS_DEPLOYMENT_ASPECTS);\n\n        // Add a EEResourceReferenceProcessor which handles @Resource references of type WebServiceContext.\n        // Note that we do it here instead of a DUP because the @Resource reference processor for WebServiceContext *isn't*\n        // per DU\n        EEResourceReferenceProcessorRegistry.registerResourceReferenceProcessor(new WebServiceContextResourceProcessor());\n    }","id":86868,"modified_method":"static void activate(final DeploymentProcessorTarget processorTarget) {\n\n        processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEBSERVICES_XML, new WSDescriptorDeploymentProcessor());\n        processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WS_EJB_INTEGRATION, new WSEJBIntegrationProcessor());\n        processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_WS, new WSDependenciesProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_REF_ANNOTATION, new WSRefAnnotationParsingProcessor());\n        processorTarget.addDeploymentProcessor(Phase.POST_MODULE, Phase.POST_MODULE_WS_JMS_INTEGRATION, new WSJMSIntegrationProcessor());\n        //processorTarget.addDeploymentProcessor(Phase.DEPENDENCIES, Phase.DEPENDENCIES_JAXRPC, new WSJAXRPCDependenciesDeploymentProcessor());\n        processorTarget.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_WS_UNIVERSAL_META_DATA_MODEL, new WSModelDeploymentProcessor());\n\n        addDeploymentProcessors(processorTarget, Phase.INSTALL, Phase.INSTALL_WS_DEPLOYMENT_ASPECTS);\n\n        // Add a EEResourceReferenceProcessor which handles @Resource references of type WebServiceContext.\n        // Note that we do it here instead of a DUP because the @Resource reference processor for WebServiceContext *isn't*\n        // per DU\n        EEResourceReferenceProcessorRegistry.registerResourceReferenceProcessor(new WebServiceContextResourceProcessor());\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processMethodRef(final DeploymentUnit deploymentUnit, final Module module, final EEModuleDescription eeModuleDescription, final WebServiceRefWrapper annotation, final MethodInfo methodInfo, final EEApplicationClasses applicationClasses) {\n        final String methodName = methodInfo.name();\n        if (!methodName.startsWith(\"set\") || methodInfo.args().length != 1) {\n            throw new IllegalArgumentException(\"@WebServiceRef injection target is invalid.  Only setter methods are allowed: \" + methodInfo);\n        }\n        final String injectionType = isEmpty(annotation.type()) || annotation.type().equals(Object.class.getName()) ? methodInfo.args()[0].name().toString() : annotation.type();\n        final InjectionTarget targetDescription = new MethodInjectionTarget(methodInfo.declaringClass().name().toString(), methodName, injectionType);\n\n        final String localContextName = isEmpty(annotation.name()) ? methodInfo.declaringClass().name().toString() + \"/\" + methodName.substring(3, 4).toLowerCase() + methodName.substring(4) : annotation.name();\n        processRef(deploymentUnit, module, eeModuleDescription, annotation.name(), targetDescription.getClassName(), annotation.value(), annotation.wsdlLocation(), methodInfo.declaringClass(), targetDescription, localContextName, applicationClasses);\n    }","id":86869,"modified_method":"private void processMethodRef(final DeploymentUnit deploymentUnit, final WebServiceRefWrapper annotation, final MethodInfo methodInfo) {\n        final String methodName = methodInfo.name();\n        if (!methodName.startsWith(\"set\") || methodInfo.args().length != 1) {\n            throw new IllegalArgumentException(\"@WebServiceRef injection target is invalid.  Only setter methods are allowed: \" + methodInfo);\n        }\n        final String injectionType = isEmpty(annotation.type()) || annotation.type().equals(Object.class.getName()) ? methodInfo.args()[0].name().toString() : annotation.type();\n        final InjectionTarget targetDescription = new MethodInjectionTarget(methodInfo.declaringClass().name().toString(), methodName, injectionType);\n\n        final String localContextName = isEmpty(annotation.name()) ? methodInfo.declaringClass().name().toString() + \"/\" + methodName.substring(3, 4).toLowerCase() + methodName.substring(4) : annotation.name();\n        processRef(deploymentUnit, localContextName, injectionType, annotation.value(), annotation.wsdlLocation(), methodInfo.declaringClass(), targetDescription, localContextName);\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final CompositeIndex index = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPOSITE_ANNOTATION_INDEX);\n        final List<AnnotationInstance> resourceAnnotations = index.getAnnotations(WEB_SERVICE_REF_ANNOTATION_NAME);\n        for (AnnotationInstance annotation : resourceAnnotations) {\n            final AnnotationTarget annotationTarget = annotation.target();\n            final WebServiceRefWrapper annotationWrapper = new WebServiceRefWrapper(annotation);\n\n            if (annotationTarget instanceof FieldInfo) {\n                processFieldRef(deploymentUnit, module, eeModuleDescription, annotationWrapper, (FieldInfo) annotationTarget, applicationClasses);\n            } else if (annotationTarget instanceof MethodInfo) {\n                processMethodRef(deploymentUnit, module, eeModuleDescription, annotationWrapper, (MethodInfo) annotationTarget, applicationClasses);\n            } else if (annotationTarget instanceof ClassInfo) {\n                processClassRef(deploymentUnit, module, eeModuleDescription, annotationWrapper, (ClassInfo) annotationTarget, applicationClasses);\n            }\n        }\n        final List<AnnotationInstance> resourcesAnnotations = index.getAnnotations(WEB_SERVICE_REFS_ANNOTATION_NAME);\n        for (AnnotationInstance outerAnnotation : resourcesAnnotations) {\n            final AnnotationTarget annotationTarget = outerAnnotation.target();\n            if (annotationTarget instanceof ClassInfo) {\n                final AnnotationInstance[] values = outerAnnotation.value(\"value\").asNestedArray();\n                for (AnnotationInstance annotation : values) {\n                    processClassRef(deploymentUnit, module, eeModuleDescription, new WebServiceRefWrapper(annotation), (ClassInfo) annotationTarget, applicationClasses);\n                }\n            }\n        }\n    }","id":86870,"modified_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final CompositeIndex index = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPOSITE_ANNOTATION_INDEX);\n        final List<AnnotationInstance> resourceAnnotations = index.getAnnotations(WEB_SERVICE_REF_ANNOTATION_NAME);\n        // TODO: we removed EEComponetClasses & EEapplicationClasses from parameters passing - fix it in all AS7 processors as well\n        for (AnnotationInstance annotation : resourceAnnotations) {\n            final AnnotationTarget annotationTarget = annotation.target();\n            final WebServiceRefWrapper annotationWrapper = new WebServiceRefWrapper(annotation);\n\n            if (annotationTarget instanceof FieldInfo) {\n                processFieldRef(deploymentUnit, annotationWrapper, (FieldInfo) annotationTarget);\n            } else if (annotationTarget instanceof MethodInfo) {\n                processMethodRef(deploymentUnit, annotationWrapper, (MethodInfo) annotationTarget);\n            } else if (annotationTarget instanceof ClassInfo) {\n                processClassRef(deploymentUnit, annotationWrapper, (ClassInfo) annotationTarget);\n            }\n        }\n        final List<AnnotationInstance> resourcesAnnotations = index.getAnnotations(WEB_SERVICE_REFS_ANNOTATION_NAME);\n        for (AnnotationInstance outerAnnotation : resourcesAnnotations) {\n            final AnnotationTarget annotationTarget = outerAnnotation.target();\n            if (annotationTarget instanceof ClassInfo) {\n                final AnnotationInstance[] values = outerAnnotation.value(\"value\").asNestedArray();\n                for (AnnotationInstance annotation : values) {\n                    processClassRef(deploymentUnit, new WebServiceRefWrapper(annotation), (ClassInfo) annotationTarget);\n                }\n            }\n        }\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"private UnifiedServiceRefMetaData getServiceReference(final DeploymentUnit deploymentUnit, final String name, final String type, final String value, final String wsdlLocation) {\n        final UnifiedServiceRefMetaData reference = new UnifiedServiceRefMetaData(getUnifiedVirtualFile(deploymentUnit));\n        reference.setServiceRefName(name);\n        // TODO handle mappedName\n\n        if (wsdlLocation != null && wsdlLocation.length() > 0) {\n            reference.setWsdlFile(wsdlLocation);\n        }\n        reference.setServiceRefType(type);\n        reference.setServiceInterface(value);\n\n        final boolean isJAXRPC = reference.getMappingFile() != null // TODO: is mappingFile check required?\n                || \"javax.xml.rpc.Service\".equals(reference.getServiceInterface());\n        reference.setType(isJAXRPC ? ServiceRefHandler.Type.JAXRPC : ServiceRefHandler.Type.JAXWS);\n        return reference;\n    }","id":86871,"modified_method":"private UnifiedServiceRefMetaData getServiceReference(final DeploymentUnit deploymentUnit, final ClassLoader classLoader, final String name, final String type, final String value, final String wsdlLocation) {\n        final UnifiedServiceRefMetaData serviceRefUMDM = new UnifiedServiceRefMetaData(getUnifiedVirtualFile(deploymentUnit));\n        serviceRefUMDM.setServiceRefName(name);\n        // TODO handle mappedName\n\n        final Class<?> typeClass;\n        try {\n            typeClass = classLoader.loadClass(type);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Could not load class \" + type);\n        }\n\n        if (wsdlLocation != null && wsdlLocation.length() > 0) {\n            serviceRefUMDM.setWsdlFile(wsdlLocation);\n        }\n        serviceRefUMDM.setServiceRefType(type);\n        if (!isEmpty(value)) {\n            serviceRefUMDM.setServiceInterface(value);\n        } else if (Service.class.isAssignableFrom(typeClass)) {\n            serviceRefUMDM.setServiceInterface(type);\n        } else {\n            serviceRefUMDM.setServiceInterface(Service.class.getName());\n        }\n\n        final boolean isJAXRPC = serviceRefUMDM.getMappingFile() != null // TODO: is mappingFile check required?\n                || \"javax.xml.rpc.Service\".equals(serviceRefUMDM.getServiceInterface());\n        serviceRefUMDM.setType(isJAXRPC ? ServiceRefHandler.Type.JAXRPC : ServiceRefHandler.Type.JAXWS);\n        return serviceRefUMDM;\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processFieldRef(final DeploymentUnit deploymentUnit, final Module module, final EEModuleDescription eeModuleDescription, final WebServiceRefWrapper annotation, final FieldInfo fieldInfo, final EEApplicationClasses applicationClasses) {\n        final String fieldName = fieldInfo.name();\n        final String injectionType = isEmpty(annotation.type()) || annotation.type().equals(Object.class.getName()) ? fieldInfo.type().name().toString() : annotation.type();\n        final InjectionTarget targetDescription = new FieldInjectionTarget(fieldInfo.declaringClass().name().toString(),  fieldName, injectionType);\n        final String localContextName = isEmpty(annotation.name()) ? fieldInfo.declaringClass().name().toString() + \"/\" + fieldInfo.name() : annotation.name();\n        processRef(deploymentUnit, module, eeModuleDescription, annotation.name(), targetDescription.getClassName(), annotation.value(), annotation.wsdlLocation(), fieldInfo.declaringClass(), targetDescription, localContextName, applicationClasses);\n    }","id":86872,"modified_method":"private void processFieldRef(final DeploymentUnit deploymentUnit, final WebServiceRefWrapper annotation, final FieldInfo fieldInfo) {\n        final String fieldName = fieldInfo.name();\n        final String injectionType = isEmpty(annotation.type()) || annotation.type().equals(Object.class.getName()) ? fieldInfo.type().name().toString() : annotation.type();\n        final InjectionTarget targetDescription = new FieldInjectionTarget(fieldInfo.declaringClass().name().toString(),  fieldName, injectionType);\n        final String localContextName = isEmpty(annotation.name()) ? fieldInfo.declaringClass().name().toString() + \"/\" + fieldInfo.name() : annotation.name();\n        processRef(deploymentUnit, localContextName, injectionType, annotation.value(), annotation.wsdlLocation(), fieldInfo.declaringClass(), targetDescription, localContextName);\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processClassRef(final DeploymentUnit deploymentUnit, final Module module, final EEModuleDescription eeModuleDescription, final WebServiceRefWrapper annotation, final ClassInfo classInfo, final EEApplicationClasses applicationClasses) throws DeploymentUnitProcessingException {\n        if (isEmpty(annotation.name())) {\n            throw new DeploymentUnitProcessingException(\"@WebServiceRef attribute 'name' is required fo class level annotations.\");\n        }\n        if (isEmpty(annotation.type())) {\n            throw new DeploymentUnitProcessingException(\"@WebServiceRef attribute 'type' is required fo class level annotations.\");\n        }\n        processRef(deploymentUnit, module, eeModuleDescription, annotation.name(), annotation.type(), annotation.value(), annotation.wsdlLocation(), classInfo, null, annotation.name(), applicationClasses);\n    }","id":86873,"modified_method":"private void processClassRef(final DeploymentUnit deploymentUnit, final WebServiceRefWrapper annotation, final ClassInfo classInfo) throws DeploymentUnitProcessingException {\n        if (isEmpty(annotation.name())) {\n            throw new DeploymentUnitProcessingException(\"@WebServiceRef attribute 'name' is required fo class level annotations.\");\n        }\n        if (isEmpty(annotation.type())) {\n            throw new DeploymentUnitProcessingException(\"@WebServiceRef attribute 'type' is required fo class level annotations.\");\n        }\n        processRef(deploymentUnit, annotation.name(), annotation.type(), annotation.value(), annotation.wsdlLocation(), classInfo, null, annotation.name());\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processRef(final DeploymentUnit deploymentUnit, final Module module, final EEModuleDescription eeModuleDescription, final String name, final String type, final String value, final String wsdlLocation, final ClassInfo classInfo, final InjectionTarget targetDescription, final String localContextName, final EEApplicationClasses applicationClasses) {\n        final EEModuleClassDescription classDescription = applicationClasses.getOrAddClassByName(classInfo.name().toString());\n\n        // our injection comes from the local lookup, no matter what.\n        final ResourceInjectionConfiguration injectionConfiguration = targetDescription != null ?\n            new ResourceInjectionConfiguration(targetDescription, new LookupInjectionSource(localContextName)) : null;\n\n        // Create the binding from whence our injection comes.\n        final InjectionSource valueSource = new WSRefValueSource(module, getServiceReference(deploymentUnit, name, type, value, wsdlLocation));\n        final BindingConfiguration bindingConfiguration = new BindingConfiguration(localContextName, valueSource);\n\n        // TODO: class hierarchies? shared bindings?\n        classDescription.getConfigurators().add(new ClassConfigurator() {\n            public void configure(final DeploymentPhaseContext context, final EEModuleClassDescription description, final EEModuleClassConfiguration configuration) throws DeploymentUnitProcessingException {\n                configuration.getBindingConfigurations().add(bindingConfiguration);\n                if (injectionConfiguration != null) {\n                    configuration.getInjectionConfigurations().add(injectionConfiguration);\n                }\n            }\n        });\n    }","id":86874,"modified_method":"private void processRef(final DeploymentUnit deploymentUnit, final String name, final String type, final String value, final String wsdlLocation, final ClassInfo classInfo, final InjectionTarget targetDescription, final String localContextName) {\n        final EEApplicationClasses applicationClasses = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n        final EEModuleClassDescription classDescription = applicationClasses.getOrAddClassByName(classInfo.name().toString());\n\n        // our injection comes from the local lookup, no matter what.\n        final ResourceInjectionConfiguration injectionConfiguration = targetDescription != null ?\n            new ResourceInjectionConfiguration(targetDescription, new LookupInjectionSource(localContextName)) : null;\n\n        // Create the binding from whence our injection comes.\n        final Module module = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.MODULE);\n        final ClassLoader classLoader = module.getClassLoader();\n        final UnifiedServiceRefMetaData serviceRefUMDM = getServiceReference(deploymentUnit, classLoader, name, type, value, wsdlLocation);\n        final InjectionSource valueSource = new WSRefValueSource(serviceRefUMDM);\n        final BindingConfiguration bindingConfiguration = new BindingConfiguration(localContextName, valueSource);\n\n        // TODO: class hierarchies? shared bindings?\n        // TODO: split injection & binding configurators\n        classDescription.getConfigurators().add(new ClassConfigurator() {\n            public void configure(final DeploymentPhaseContext context, final EEModuleClassDescription description, final EEModuleClassConfiguration configuration) throws DeploymentUnitProcessingException {\n                configuration.getBindingConfigurations().add(bindingConfiguration);\n                if (injectionConfiguration != null) {\n                    configuration.getInjectionConfigurations().add(injectionConfiguration);\n                }\n            }\n        });\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Object getValue() throws IllegalStateException, IllegalArgumentException {\n        // FIXME this is a workaround to class loader issues\n        final ClassLoader tccl = ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader();\n        final ClassLoader classLoader = new ClassLoader(this.getClass().getClassLoader()) {\n            @Override\n            public Class<?> loadClass(String className) throws ClassNotFoundException {\n                try {\n                    return super.loadClass(className);\n                } catch (ClassNotFoundException cnfe) {\n                    return module.getClassLoader().loadClass(className);\n                }\n            }\n\n            @Override\n            public Enumeration<URL> getResources(String name) throws IOException {\n                final Enumeration<URL> superResources = super.getResources(name);\n                final Enumeration<URL> duModuleCLResources = module.getClassLoader().getResources(name);\n                if (superResources == null || !superResources.hasMoreElements()) {\n                    return duModuleCLResources;\n                }\n                if (duModuleCLResources == null || !duModuleCLResources.hasMoreElements()) {\n                    return superResources;\n                }\n                return new Enumeration<URL>() {\n                    public boolean hasMoreElements() {\n                        return superResources.hasMoreElements() || duModuleCLResources.hasMoreElements();\n                    }\n\n                    public URL nextElement() {\n                        if (superResources.hasMoreElements()) {\n                            return superResources.nextElement();\n                        }\n                        return duModuleCLResources.nextElement();\n                    }\n                };\n            }\n        };\n        Thread.currentThread().setContextClassLoader(classLoader);\n        try {\n            return new CXFServiceObjectFactoryJAXWS().getObjectInstance(getReferenceable(), null, null, null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n        }\n    }","id":86875,"modified_method":"public Object getValue() throws IllegalStateException, IllegalArgumentException {\n        final ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\n        try {\n            final ClassLoader integrationCL = ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader();\n            final ClassLoader newCL = new DelegateClassLoader(integrationCL, oldCL);\n            Thread.currentThread().setContextClassLoader(newCL);\n            final Referenceable referenceable = getReferenceable(integrationCL);\n            final Class<?> clazz = Class.forName(referenceable.getReference().getFactoryClassName(), true, integrationCL);\n            final ObjectFactory factory = (ObjectFactory)clazz.newInstance();\n            return factory.getObjectInstance(referenceable.getReference(), null, null, null);\n        } catch (final Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            Thread.currentThread().setContextClassLoader(oldCL);\n        }\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"WSRefValueSource(Module module, UnifiedServiceRefMetaData serviceRef) {\n        this.module = module;\n        this.serviceRef = serviceRef;\n    }","id":86876,"modified_method":"WSRefValueSource(final UnifiedServiceRefMetaData serviceRef) {\n        this.serviceRef = serviceRef;\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void getResourceValue(final ResolutionContext resolutionContext, ServiceBuilder<?> serviceBuilder, DeploymentPhaseContext phaseContext, Injector<ManagedReferenceFactory> injector) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final EEApplicationDescription applicationComponentDescription = deploymentUnit.getAttachment(Attachments.EE_APPLICATION_DESCRIPTION);\n        if (applicationComponentDescription == null) {\n            return; // Not an EE deployment\n        }\n        ManagedReferenceFactory factory = new ValueManagedReferenceFactory(this);\n        serviceBuilder.addInjection(injector, factory);\n    }","id":86877,"modified_method":"public void getResourceValue(final ResolutionContext resolutionContext, final ServiceBuilder<?> serviceBuilder, final DeploymentPhaseContext phaseContext, final Injector<ManagedReferenceFactory> injector) throws DeploymentUnitProcessingException {\n        final ManagedReferenceFactory factory = new ValueManagedReferenceFactory(this);\n        serviceBuilder.addInjection(injector, factory);\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Referenceable getReferenceable() {\n        // FIXME SPIProviderResolver won't require a TCCL in the future\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        final Referenceable referenceable;\n        try {\n            Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\n            final SPIProvider spiProvider = SPIProviderResolver.getInstance().getProvider();\n            final ServiceRefHandler serviceRefHandler = spiProvider.getSPI(ServiceRefHandlerFactory.class).getServiceRefHandler();\n            return serviceRefHandler.createReferenceable(serviceRef);\n        } finally {\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n    }","id":86878,"modified_method":"private Referenceable getReferenceable(final ClassLoader loader) {\n        final SPIProvider spiProvider = SPIProviderResolver.getInstance().getProvider();\n        final ServiceRefHandler serviceRefHandler = spiProvider.getSPI(ServiceRefHandlerFactory.class, loader).getServiceRefHandler();\n        return serviceRefHandler.createReferenceable(serviceRef);\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n\n        log.info(\"Activating WebServices Extension\");\n        ModuleClassLoaderProvider.register();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                // add the DUP for dealing with WS deployments\n                WSDeploymentActivator.activate(processorTarget);\n                processorTarget.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_WEB_SERVICE_INJECTION_ANNOTATION, new WSRefAnnotationParsingProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        WSServices.saveContainerRegistry(context.getServiceRegistry(false));\n        ServiceTarget serviceTarget = context.getServiceTarget();\n        ServerConfigImpl serverConfig = createServerConfig(operation);\n        newControllers.add(ServerConfigService.install(serviceTarget, serverConfig, verificationHandler));\n        newControllers.add(EndpointRegistryService.install(serviceTarget, verificationHandler));\n    }","id":86879,"modified_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n\n        log.info(\"Activating WebServices Extension\");\n        ModuleClassLoaderProvider.register();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                // add the DUP for dealing with WS deployments\n                WSDeploymentActivator.activate(processorTarget);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        WSServices.saveContainerRegistry(context.getServiceRegistry(false));\n        ServiceTarget serviceTarget = context.getServiceTarget();\n        ServerConfigImpl serverConfig = createServerConfig(operation);\n        newControllers.add(ServerConfigService.install(serviceTarget, serverConfig, verificationHandler));\n        newControllers.add(EndpointRegistryService.install(serviceTarget, verificationHandler));\n    }","commit_id":"fb63618379e4e00288fbcbfcef42c2120b93c8c3","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void install() {\n    try {\n      URL[] urls = parseUrls();\n      if (urls != null) {\n        Thread.currentThread().setContextClassLoader(new ExternalClasspathClassLoader(urls));\n      }\n    }\n    catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","id":86880,"modified_method":"public static void install() {\n    try {\n      URL[] urls = parseUrls();\n      if (urls != null) {\n        URLClassLoader auxLoader = new URLClassLoader(urls, Thread.currentThread().getContextClassLoader());\n        Thread.currentThread().setContextClassLoader(auxLoader);\n        Thread.currentThread().setContextClassLoader(loadOptimizedLoader(urls, auxLoader));\n      }\n    }\n    catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"35e27f05e93d71684bca6b0965bfcde36ae5d0d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<String> callWithTimeout(final File workingDirectory,\n            String command) {\n        final List<String> commands =\n                Lists.newArrayList(Splitter.on(\" \").split(command));\n\n        SimpleTimeLimiter timeLimiter = new SimpleTimeLimiter();\n        Callable<List<String>> work = new Callable<List<String>>() {\n            @Override\n            public List<String> call() throws Exception {\n                Process process =\n                        ClientWorkFlow.invokeClient(workingDirectory,\n                                commands);\n                process.waitFor();\n                List<String> output = ClientWorkFlow.getOutput(process);\n                logOutputLines(output);\n                return output;\n            }\n        };\n        try {\n            return timeLimiter\n                    .callWithTimeout(work, 60, TimeUnit.SECONDS, true);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":86881,"modified_method":"public List<String> callWithTimeout(final File workingDirectory,\n            String command) {\n        log.info(\"=== about to call ===\\n{}\", command);\n        final List<String> commands =\n                Lists.newArrayList(Splitter.on(\" \").split(command));\n\n        SimpleTimeLimiter timeLimiter = new SimpleTimeLimiter();\n        Callable<List<String>> work = new Callable<List<String>>() {\n            @Override\n            public List<String> call() throws Exception {\n                Process process =\n                        ClientWorkFlow.invokeClient(workingDirectory,\n                                commands);\n                process.waitFor();\n                List<String> output = ClientWorkFlow.getOutput(process);\n                logOutputLines(output);\n                return output;\n            }\n        };\n        try {\n            return timeLimiter\n                    .callWithTimeout(work, timeoutDuration, TimeUnit.SECONDS, true);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"8b32c28a14d864ef9214dcac244394c159a66590","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void makeSampleLanguages() {\n        forLocale(true, LocaleId.FR).makeAndPersist(entityManager,\n                HLocale.class);\n\n        forLocale(true, new LocaleId(\"hi\")).makeAndPersist(entityManager,\n                HLocale.class);\n\n        forLocale(true, new LocaleId(\"pl\")).makeAndPersist(entityManager,\n                HLocale.class);\n    }","id":86882,"modified_method":"public void makeSampleLanguages() {\n        makeLanguage(LocaleId.FR);\n\n        makeLanguage(new LocaleId(\"hi\"));\n\n        makeLanguage(new LocaleId(\"pl\"));\n    }","commit_id":"8b32c28a14d864ef9214dcac244394c159a66590","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void clearThreadLocalMap(Object map, Field internalTableField)\n            throws NoSuchMethodException, IllegalAccessException,\n            NoSuchFieldException, InvocationTargetException {\n        if (map != null) {\n            Method mapRemove =\n                map.getClass().getDeclaredMethod(\"remove\",\n                        ThreadLocal.class);\n            mapRemove.setAccessible(true);\n            Object[] table = (Object[]) internalTableField.get(map);\n            if (table != null) {\n                for (int j =0; j < table.length; j++) {\n                    if (table[j] != null) {\n                        boolean remove = false;\n                        // Check the key\n                        Field keyField =\n                            Reference.class.getDeclaredField(\"referent\");\n                        keyField.setAccessible(true);\n                        Object key = keyField.get(table[j]);\n                        if (this.equals(key) || (key != null &&\n                                this == key.getClass().getClassLoader())) {\n                            remove = true;\n                        }\n                        // Check the value\n                        Field valueField =\n                            table[j].getClass().getDeclaredField(\"value\");\n                        valueField.setAccessible(true);\n                        Object value = valueField.get(table[j]);\n                        if (this.equals(value) || (value != null &&\n                                this == value.getClass().getClassLoader())) {\n                            remove = true;\n                        }\n                        if (remove) {\n                            Object entry = ((Reference<?>) table[j]).get();\n                            Object[] args = new Object[4];\n                            if (key != null) {\n                                args[0] = key.getClass().getCanonicalName();\n                                args[1] = key.toString();\n                            }\n                            if (value != null) {\n                                args[2] = value.getClass().getCanonicalName();\n                                args[3] = value.toString();\n                            }\n                            if (value == null) {\n                                if (log.isDebugEnabled()) {\n                                    log.debug(sm.getString(\n                                            \"webappClassLoader.clearThreadLocalDebug\",\n                                            args));\n                                }\n                            } else {\n                                log.error(sm.getString(\n                                        \"webappClassLoader.clearThreadLocal\",\n                                        args));\n                            }\n                            mapRemove.invoke(map, entry);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":86883,"modified_method":"private void clearThreadLocalMap(Object map, Field internalTableField)\n            throws NoSuchMethodException, IllegalAccessException,\n            NoSuchFieldException, InvocationTargetException {\n        if (map != null) {\n            Method mapRemove =\n                map.getClass().getDeclaredMethod(\"remove\",\n                        ThreadLocal.class);\n            mapRemove.setAccessible(true);\n            Object[] table = (Object[]) internalTableField.get(map);\n            int staleEntriesCount = 0;\n            if (table != null) {\n                for (int j =0; j < table.length; j++) {\n                    if (table[j] != null) {\n                        boolean remove = false;\n                        // Check the key\n                        Object key = ((Reference<?>) table[j]).get();\n                        if (this.equals(key) || (key != null &&\n                                this == key.getClass().getClassLoader())) {\n                            remove = true;\n                        }\n                        // Check the value\n                        Field valueField =\n                            table[j].getClass().getDeclaredField(\"value\");\n                        valueField.setAccessible(true);\n                        Object value = valueField.get(table[j]);\n                        if (this.equals(value) || (value != null &&\n                                this == value.getClass().getClassLoader())) {\n                            remove = true;\n                        }\n                        if (remove) {\n                            Object[] args = new Object[4];\n                            if (key != null) {\n                                args[0] = key.getClass().getCanonicalName();\n                                args[1] = key.toString();\n                            }\n                            if (value != null) {\n                                args[2] = value.getClass().getCanonicalName();\n                                args[3] = value.toString();\n                            }\n                            if (value == null) {\n                                if (log.isDebugEnabled()) {\n                                    log.debug(sm.getString(\n                                            \"webappClassLoader.clearThreadLocalDebug\",\n                                            args));\n                                }\n                            } else {\n                                log.error(sm.getString(\n                                        \"webappClassLoader.clearThreadLocal\",\n                                        args));\n                            }\n                            if (key == null) {\n                              staleEntriesCount++;\n                            } else {\n                              mapRemove.invoke(map, key);\n                            }\n                        }\n                    }\n                }\n            }\n            if (staleEntriesCount > 0) {\n                Method mapRemoveStale =\n                    map.getClass().getDeclaredMethod(\"expungeStaleEntries\");\n                mapRemoveStale.setAccessible(true);\n                mapRemoveStale.invoke(map);\n            }\n        }\n    }","commit_id":"ca89c78cf9b0bdd35d22eb136fe04ac4101eb0b9","url":"https://github.com/apache/tomcat"},{"original_method":"public void testCompilerConfiguration() throws Exception {\r\n        // test default is eclipse jdt core\r\n        PackageBuilder builder = new PackageBuilder();;\r\n        final Field compilerField = builder.getClass().getDeclaredField( \"compiler\" );\r\n        compilerField.setAccessible( true );\r\n        JavaCompiler compiler = (JavaCompiler) compilerField.get( builder );\r\n        assertSame( EclipseJavaCompiler.class,\r\n                    compiler.getClass() );\r\n\r\n        // test JANINO with property settings\r\n        PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n        conf.setCompiler( PackageBuilderConfiguration.JANINO );\r\n        builder = new PackageBuilder( conf );;\r\n        compiler = (JavaCompiler) compilerField.get( builder );\r\n        assertSame( JaninoJavaCompiler.class,\r\n                    compiler.getClass() );\r\n\r\n        // test eclipse jdt core with property settings and default source level\r\n        conf = new PackageBuilderConfiguration();\r\n        conf.setCompiler( PackageBuilderConfiguration.ECLIPSE );\r\n        builder = new PackageBuilder( conf );;\r\n        compiler = (JavaCompiler) compilerField.get( builder );\r\n        assertSame( EclipseJavaCompiler.class,\r\n                    compiler.getClass() );\r\n\r\n        EclipseJavaCompiler eclipseCompiler = (EclipseJavaCompiler) compiler;\r\n        final Field settingsField = eclipseCompiler.getClass().getDeclaredField( \"settings\" );\r\n        settingsField.setAccessible( true );\r\n        Map map = (Map) settingsField.get( eclipseCompiler );\r\n        assertEquals( \"1.4\",\r\n                      map.get( \"org.eclipse.jdt.core.compiler.codegen.targetPlatform\" ) );\r\n        assertEquals( \"1.5\",\r\n                      map.get( \"org.eclipse.jdt.core.compiler.source\" ) );\r\n\r\n        // test eclipse jdt core with property settings and jdk1.5 source level\r\n        conf = new PackageBuilderConfiguration();\r\n        conf.setCompiler( PackageBuilderConfiguration.ECLIPSE );\r\n        conf.setJavaLanguageLevel( \"1.4\" );\r\n        builder = new PackageBuilder( conf );;\r\n        compiler = (JavaCompiler) compilerField.get( builder );\r\n        assertSame( EclipseJavaCompiler.class,\r\n                    compiler.getClass() );\r\n\r\n        eclipseCompiler = (EclipseJavaCompiler) compiler;\r\n        map = (Map) settingsField.get( eclipseCompiler );\r\n        assertEquals( \"1.5\",\r\n                      map.get( \"org.eclipse.jdt.core.compiler.codegen.targetPlatform\" ) );\r\n        // it cannot be set below 1.5, so if they add 1.4, it still ends up at 1.5.        \r\n        assertEquals( \"1.5\",\r\n                      map.get( \"org.eclipse.jdt.core.compiler.source\" ) );\r\n    }","id":86884,"modified_method":"public void testCompilerConfiguration() throws Exception {\r\n        // test default is eclipse jdt core\r\n        PackageBuilder builder = new PackageBuilder();\r\n        final Field dialectField = builder.getClass().getDeclaredField( \"dialect\" );\r\n        dialectField.setAccessible( true );\r\n        JavaDialect dialect = ( JavaDialect ) dialectField.get( builder );\r\n        \r\n        final Field compilerField = dialect.getClass().getDeclaredField( \"compiler\" );\r\n        compilerField.setAccessible( true );\r\n        JavaCompiler compiler = (JavaCompiler) compilerField.get( dialect );\r\n        assertSame( EclipseJavaCompiler.class,\r\n                    compiler.getClass() );\r\n\r\n        // test JANINO with property settings\r\n        PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n        conf.setCompiler( PackageBuilderConfiguration.JANINO );\r\n        builder = new PackageBuilder( conf );    \r\n        dialect = ( JavaDialect ) dialectField.get( builder );        \r\n        compiler = (JavaCompiler) compilerField.get( dialect );\r\n        assertSame( JaninoJavaCompiler.class,\r\n                    compiler.getClass() );\r\n\r\n        // test eclipse jdt core with property settings and default source level\r\n        conf = new PackageBuilderConfiguration();\r\n        conf.setCompiler( PackageBuilderConfiguration.ECLIPSE );\r\n        builder = new PackageBuilder( conf );    \r\n        dialect = ( JavaDialect ) dialectField.get( builder );        \r\n        compiler = (JavaCompiler) compilerField.get( dialect );\r\n        assertSame( EclipseJavaCompiler.class,\r\n                    compiler.getClass() );\r\n    }","commit_id":"3aeaec693a8ab708d56540a0a53d5a018320248e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testSigning() throws NoSuchFieldException, IllegalAccessException {\n        AwsConfig awsConfig = new AwsConfig();\n        awsConfig.setRegion(TEST_REGION);\n        awsConfig.setHostHeader(TEST_HOST);\n        awsConfig.setAccessKey(TEST_ACCESS_KEY);\n        awsConfig.setSecretKey(TEST_SECRET_KEY);\n\n        DescribeInstances di = new DescribeInstances(awsConfig);\n        Field field = di.getClass().getDeclaredField(\"attributes\");\n        field.setAccessible(true);\n        Map<String, String> attributes = (Map<String, String>) field.get(di);\n        field.set(di, attributes);\n\n        EC2RequestSigner rs = new EC2RequestSigner(awsConfig, TEST_REQUEST_DATE);\n\n        String signature = rs.sign(TEST_SERVICE, attributes);\n\n        assertEquals(TEST_SIGNATURE_EXPECTED, signature);\n    }","id":86885,"modified_method":"@Test\n    public void testSigning() throws NoSuchFieldException, IllegalAccessException {\n        AwsConfig awsConfig = new AwsConfig();\n        awsConfig.setRegion(TEST_REGION);\n        awsConfig.setHostHeader(TEST_HOST);\n        awsConfig.setAccessKey(TEST_ACCESS_KEY);\n        awsConfig.setSecretKey(TEST_SECRET_KEY);\n\n        DescribeInstances di = new DescribeInstances(awsConfig);\n\n        Field timeField = di.getClass().getDeclaredField(\"timeStamp\");\n        timeField.setAccessible(true);\n        String timeStamp = (String) timeField.get(di);\n        timeStamp = TEST_REQUEST_DATE;\n        timeField.set(di,timeStamp);\n\n        Field attributesField = di.getClass().getDeclaredField(\"attributes\");\n        attributesField.setAccessible(true);\n        Map<String, String> attributes = (Map<String, String>) attributesField.get(di);\n        attributes.put(\"X-Amz-Date\", TEST_REQUEST_DATE);\n\n\n        EC2RequestSigner rs = new EC2RequestSigner(awsConfig, TEST_REQUEST_DATE);\n        attributes.put(\"X-Amz-Credential\",rs.createFormattedCredential());\n        String signature = rs.sign(TEST_SERVICE, attributes);\n\n        assertEquals(TEST_SIGNATURE_EXPECTED, signature);\n    }","commit_id":"a13952945620db9b8a7c68010ba76909df356df9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected static void checkAllTimersAreDisposed() {\n    try {\n      Class<?> aClass = Class.forName(\"javax.swing.TimerQueue\");\n\n      Method inst = aClass.getDeclaredMethod(\"sharedInstance\");\n      inst.setAccessible(true);\n      Object queue = inst.invoke(null);\n      Field field = aClass.getDeclaredField(\"firstTimer\");\n      field.setAccessible(true);\n      Object firstTimer = field.get(queue);\n      if (firstTimer != null) {\n        try {\n          fail(\"Not disposed Timer: \" + firstTimer.toString() + \"; queue:\" + queue);\n        }\n        finally {\n          field.set(queue, null);\n        }\n      }\n    }\n    catch (Throwable e) {\n      // Ignore\n    }\n  }","id":86886,"modified_method":"protected static void checkAllTimersAreDisposed() {\n    Field firstTimerF;\n    Object timerQueue;\n    Object timer;\n    try {\n      Class<?> TimerQueueC = Class.forName(\"javax.swing.TimerQueue\");\n      Method sharedInstance = TimerQueueC.getDeclaredMethod(\"sharedInstance\");\n      sharedInstance.setAccessible(true);\n\n      firstTimerF = ReflectionUtil.getDeclaredField(TimerQueueC, \"firstTimer\");\n      timerQueue = sharedInstance.invoke(null);\n      if (firstTimerF == null) {\n        // jdk 8\n        DelayQueue delayQueue = ReflectionUtil.getField(TimerQueueC, timerQueue, DelayQueue.class, \"queue\");\n        timer = delayQueue.peek();\n      }\n      else {\n        // ancient jdk\n        firstTimerF.setAccessible(true);\n        timer = firstTimerF.get(timerQueue);\n      }\n    }\n    catch (Throwable e) {\n      throw new RuntimeException(e);\n    }\n    if (timer != null) {\n      if (firstTimerF != null) {\n        ReflectionUtil.resetField(timerQueue, firstTimerF);\n      }\n      fail(\"Not disposed Timer: \" + timer.toString() + \"; queue:\" + timerQueue);\n    }\n  }","commit_id":"75b461ebc399e015d2f47658c3f741c3c3683827","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean annotatedWith(@NotNull Class annotationClass) {\n    Class<?> aClass = getClass();\n    String methodName = \"test\" + getTestName(false);\n    boolean methodChecked = false;\n    while (aClass != null && aClass != Object.class) {\n      if (aClass.getAnnotation(annotationClass) != null) return true;\n      if (!methodChecked) {\n        try {\n          Method method = aClass.getDeclaredMethod(methodName);\n          if (method.getAnnotation(annotationClass) != null) return true;\n          methodChecked = true;\n        }\n        catch (NoSuchMethodException ignored) { }\n      }\n      aClass = aClass.getSuperclass();\n    }\n    return false;\n  }","id":86887,"modified_method":"protected boolean annotatedWith(@NotNull Class annotationClass) {\n    Class<?> aClass = getClass();\n    String methodName = \"test\" + getTestName(false);\n    boolean methodChecked = false;\n    while (aClass != null && aClass != Object.class) {\n      if (aClass.getAnnotation(annotationClass) != null) return true;\n      if (!methodChecked) {\n        Method method = ReflectionUtil.getDeclaredMethod(aClass, methodName);\n        if (method != null) {\n          if (method.getAnnotation(annotationClass) != null) return true;\n          methodChecked = true;\n        }\n      }\n      aClass = aClass.getSuperclass();\n    }\n    return false;\n  }","commit_id":"75b461ebc399e015d2f47658c3f741c3c3683827","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected String getElementPresentation() {\n    return \"Condition\" + getElement();\n  }","id":86888,"modified_method":"@Override\n  protected String getElementPresentation() {\n    return \"Condition \" + getElement();\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitInstanceofExpression(GrInstanceOfExpression expression) {\n    expression.getOperand().accept(this);\n    final ConditionInstruction cond = myConditions.peek();\n    if (cond != null) {\n      addNode(new InstanceOfInstruction(myInstructionNumber++, expression, cond));\n    }\n  }","id":86889,"modified_method":"@Override\n  public void visitInstanceofExpression(GrInstanceOfExpression expression) {\n    expression.getOperand().accept(this);\n\n    ConditionInstruction cond = new ConditionInstruction(expression, myInstructionNumber++);\n    addNodeAndCheckPending(cond);\n    registerCondition(cond);\n\n    addNode(new InstanceOfInstruction(myInstructionNumber++, expression, cond));\n    NegatingGotoInstruction negation = new NegatingGotoInstruction(expression, myInstructionNumber++, cond);\n    addNode(negation);\n    addPendingEdge(expression, negation);\n\n    myHead = cond;\n    InstanceOfInstruction instruction = addNode(new InstanceOfInstruction(myInstructionNumber++, expression, cond));\n    myConditions.removeFirstOccurrence(cond);\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n\n    final InstructionImpl head = myHead;\n\n    final GrCondition condition = ifStatement.getCondition();\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n\n    InstructionImpl conditionEnd = null;\n    InstructionImpl thenEnd = null;\n    InstructionImpl elseEnd = null;\n\n    List<NegatingGotoInstruction> pendingNegations = new ArrayList<NegatingGotoInstruction>();\n    ConditionInstruction conditionStart = null;\n    if (condition != null) {\n      final List<Pair<InstructionImpl, GroovyPsiElement>> oldPending = myPending;\n      myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n\n      conditionStart = addNodeAndCheckPending(new ConditionInstruction(condition, myInstructionNumber++));\n      registerCondition(conditionStart);\n      condition.accept(this);\n      conditionEnd = myHead;\n\n      List<Pair<InstructionImpl, GroovyPsiElement>> pendingFromCondition = myPending;\n      myPending = oldPending;\n      for (Pair<InstructionImpl, GroovyPsiElement> pair : pendingFromCondition) {\n        if (pair.first instanceof NegatingGotoInstruction) {\n          pendingNegations.add((NegatingGotoInstruction)pair.first);\n        }\n        else {\n          addPendingEdge(pair.second, pair.first);\n        }\n      }\n    }\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      thenEnd = myHead;\n      interruptFlow();\n    }\n\n    if (condition != null) {\n      myHead = conditionEnd;\n      myNegatingStack.push(addNode(new NegatingGotoInstruction(condition, myInstructionNumber++, conditionStart)));\n    }\n    else {\n      myHead = head;\n    }\n\n    for (NegatingGotoInstruction negation : pendingNegations) {\n      assert condition != null;\n      addPendingEdge(condition, negation);\n    }\n    if (elseBranch != null) {\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n      elseEnd = myHead;\n    }\n\n    if (thenBranch != null || elseBranch != null) {\n      final InstructionImpl end = new IfEndInstruction(ifStatement, myInstructionNumber++);\n      addNode(end);\n      if (thenEnd != null) addEdge(thenEnd, end);\n      if (elseEnd != null) addEdge(elseEnd, end);\n    }\n    finishNode(ifInstruction);\n  }","id":86890,"modified_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n\n    final GrCondition condition = ifStatement.getCondition();\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n\n    InstructionImpl conditionEnd = null;\n    InstructionImpl thenEnd = null;\n    InstructionImpl elseEnd = null;\n\n    if (condition != null) {\n      condition.accept(this);\n      conditionEnd = myHead;\n    }\n\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(ifStatement);\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      thenEnd = myHead;\n      interruptFlow();\n    }\n\n    myHead = reduceAllNegationsIntoInstruction(ifStatement, negations);\n    if (negations.isEmpty() && conditionEnd != null) {\n      myHead = conditionEnd;\n    }\n    if (elseBranch != null) {\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n      elseEnd = myHead;\n      interruptFlow();\n    }\n\n    if (thenBranch != null || elseBranch != null) {\n      final InstructionImpl end = new IfEndInstruction(ifStatement, myInstructionNumber++);\n      addNode(end);\n      if (thenEnd != null) addEdge(thenEnd, end);\n      if (elseEnd != null) {\n        addEdge(elseEnd, end);\n      }\n      else {\n        addEdge(conditionEnd != null ? conditionEnd : ifInstruction, end);\n      }\n    }\n\n    finishNode(ifInstruction);\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private <T extends InstructionImpl> T addNode(T instruction) {\n    myInstructions.add(instruction);\n    instruction.setNegating(myNegatingStack.peek());\n    if (myHead != null) {\n      addEdge(myHead, instruction);\n    }\n    myHead = instruction;\n    return instruction;\n  }","id":86891,"modified_method":"private <T extends InstructionImpl> T addNode(T instruction) {\n    myInstructions.add(instruction);\n    if (myHead != null) {\n      addEdge(myHead, instruction);\n    }\n    myHead = instruction;\n    return instruction;\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    final GrExpression right = expression.getRightOperand();\n    final IElementType opType = expression.getOperationTokenType();\n\n    final ConditionInstruction cond;\n    if (opType == mLOR || opType == mLAND) {\n      cond = addNodeAndCheckPending(new ConditionInstruction(expression, myInstructionNumber++));\n      registerCondition(cond);\n    }\n    else {\n      cond = null;\n    }\n    left.accept(this);\n\n    if (cond != null) {\n      myConditions.removeFirstOccurrence(cond);\n    }\n\n    NegatingGotoInstruction first = null;\n    if (right != null) {\n      if (cond != null) {\n        final InstructionImpl head = myHead;\n        if (opType == mLAND) {\n          first = addNodeAndCheckPending(new NegatingGotoInstruction(expression, myInstructionNumber++, cond));\n        }\n        addPendingEdge(expression, myHead);\n        myHead = head;\n        if (opType == mLOR) {\n          myNegatingStack.push(addNodeAndCheckPending(new NegatingGotoInstruction(expression, myInstructionNumber++, cond)));\n        }\n      }\n\n      right.accept(this);\n    }\n\n    visitCall(expression);\n    if (first != null) {\n      myNegatingStack.push(first);\n    }\n  }","id":86892,"modified_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    final GrExpression right = expression.getRightOperand();\n    final IElementType opType = expression.getOperationTokenType();\n\n    if (opType != mLOR && opType != mLAND) {\n      left.accept(this);\n      if (right != null) {\n        right.accept(this);\n      }\n      visitCall(expression);\n      return;\n    }\n\n    ConditionInstruction condition = new ConditionInstruction(expression, myInstructionNumber++);\n    addNodeAndCheckPending(condition);\n    registerCondition(condition);\n\n    left.accept(this);\n\n    if (right == null) return;\n\n    final List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    visitCall(expression);\n\n    if (opType == mLAND) {\n      for (GotoInstruction negation : negations) {\n        addPendingEdge(expression, negation);\n      }\n      if (negations.isEmpty()) {\n        InstructionImpl head = myHead;\n        NegatingGotoInstruction negation = addNode(new NegatingGotoInstruction(expression, myInstructionNumber++, condition));\n        addPendingEdge(expression, negation);\n        myHead = head;\n      }\n    }\n    else /*if (opType == mLOR)*/ {\n      addNodeAndCheckPending(new InstructionImpl(expression, myInstructionNumber++)); //collect all pending edges from left argument\n      addPendingEdge(expression, myHead);\n\n      myHead = reduceAllNegationsIntoInstruction(expression, negations);\n      //addNode(new NegatingGotoInstruction(expression, myInstructionNumber++, condition));\n    }\n    myConditions.removeFirstOccurrence(condition);\n\n    right.accept(this);\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand != null) {\n      ConditionInstruction cond = null;\n      if (expression.getOperationTokenType() == mLNOT) {\n        cond = new ConditionInstruction(expression, myInstructionNumber++);\n        addNodeAndCheckPending(cond);\n        registerCondition(cond);\n      }\n      operand.accept(this);\n      visitCall(expression);\n\n      if (cond != null) {\n        myConditions.removeFirstOccurrence(cond);\n        myNegatingStack.push(addNodeAndCheckPending(new NegatingGotoInstruction(expression, myInstructionNumber++, cond)));\n      }\n    }\n  }","id":86893,"modified_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand == null) return;\n\n    if (expression.getOperationTokenType() != mLNOT) {\n      operand.accept(this);\n      visitCall(expression);\n      return;\n    }\n\n    ConditionInstruction cond = new ConditionInstruction(expression, myInstructionNumber++);\n    addNodeAndCheckPending(cond);\n    registerCondition(cond);\n\n    operand.accept(this);\n    visitCall(expression);\n\n    myConditions.removeFirstOccurrence(cond);\n\n    List<GotoInstruction> negations = collectAndRemoveAllPendingNegations(expression);\n\n    addPendingEdge(expression, addNodeAndCheckPending(new PositiveGotoInstruction(expression, myInstructionNumber++, cond)));\n\n    myHead = reduceAllNegationsIntoInstruction(expression, negations);\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addEdge(InstructionImpl begin, InstructionImpl end) {\n    begin.addSuccessor(end);\n    end.addPredecessor(begin);\n  }","id":86894,"modified_method":"private static void addEdge(InstructionImpl begin, InstructionImpl end) {\n    begin.addSuccessor(end);\n    end.addPredecessor(begin);\n\n    if (!(begin instanceof ReadWriteVariableInstruction || begin instanceof MixinTypeInstruction)) {\n      end.addNegationsFrom(begin);\n    }\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new ArrayDeque<InstructionImpl>();\n    myCaughtExceptionInfos = new ArrayDeque<ExceptionInfo>();\n    myConditions = new ArrayDeque<ConditionInstruction>();\n    myNegatingStack = new ArrayDeque<NegatingGotoInstruction>();\n\n    myFinallyCount = 0;\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 0;\n\n    myLastInScope = null;\n\n    if (scope instanceof GrStatementOwner) {\n      GrStatement[] statements = ((GrStatementOwner)scope).getStatements();\n      if (statements.length > 0) {\n        myLastInScope = statements[statements.length - 1];\n      }\n    }\n\n    startNode(null);\n    if (scope instanceof GrClosableBlock) {\n      buildFlowForClosure((GrClosableBlock)scope);\n    }\n    else {\n      scope.accept(this);\n    }\n\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n\n\n    return assertValidPsi(myInstructions.toArray(new Instruction[myInstructions.size()]));\n  }","id":86895,"modified_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new ArrayDeque<InstructionImpl>();\n    myCaughtExceptionInfos = new ArrayDeque<ExceptionInfo>();\n    myConditions = new ArrayDeque<ConditionInstruction>();\n\n    myFinallyCount = 0;\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 0;\n\n    myLastInScope = null;\n\n    if (scope instanceof GrStatementOwner) {\n      GrStatement[] statements = ((GrStatementOwner)scope).getStatements();\n      if (statements.length > 0) {\n        myLastInScope = statements[statements.length - 1];\n      }\n    }\n\n    startNode(null);\n    if (scope instanceof GrClosableBlock) {\n      buildFlowForClosure((GrClosableBlock)scope);\n    }\n    else {\n      scope.accept(this);\n    }\n\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n\n\n    return assertValidPsi(myInstructions.toArray(new Instruction[myInstructions.size()]));\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DFAType negate(NegatingGotoInstruction negating) {\n    final DFAType type = new DFAType(primary);\n\n    for (Mixin mixin : mixins) {\n      type.mixins.add(mixin);\n    }\n\n    for (; negating != null; negating = negating.getNegatingGotoInstruction()) {\n      final Set<ConditionInstruction> conditionsToNegate = negating.getCondition().getDependentConditions();\n\n      for (ListIterator<Mixin> iterator = type.mixins.listIterator(); iterator.hasNext(); ) {\n        Mixin mixin = iterator.next();\n        if (conditionsToNegate.contains(mixin.myCondition)) {\n          iterator.set(mixin.negate());\n        }\n      }\n    }\n    return type;\n  }","id":86896,"modified_method":"public DFAType negate(@NotNull Instruction instruction) {\n    final DFAType type = new DFAType(primary);\n\n    for (Mixin mixin : mixins) {\n      type.mixins.add(mixin);\n    }\n\n    for (NegatingGotoInstruction negation: instruction.getNegatingGotoInstruction()) {\n      final Set<ConditionInstruction> conditionsToNegate = negation.getCondition().getDependentConditions();\n\n      for (ListIterator<Mixin> iterator = type.mixins.listIterator(); iterator.hasNext(); ) {\n        Mixin mixin = iterator.next();\n        if (conditionsToNegate.contains(mixin.myCondition)) {\n          iterator.set(mixin.negate());\n        }\n      }\n    }\n    return type;\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public NegatingGotoInstruction getNegatingGotoInstruction() {\n    return myNegating;\n  }","id":86897,"modified_method":"@NotNull\n  @Override\n  public Iterable<? extends NegatingGotoInstruction> getNegatingGotoInstruction() {\n    return myNegations;\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NegatingGotoInstruction(@Nullable PsiElement element, int num, @NotNull ConditionInstruction condition) {\n    super(element, num);\n    myCondition = condition;\n  }","id":86898,"modified_method":"public NegatingGotoInstruction(@Nullable PsiElement element, int num, @NotNull ConditionInstruction condition) {\n    super(element, num, condition);\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected String getElementPresentation() {\n    return \" Negating goto instruction, condition=\" + myCondition.num() + getElement();\n  }","id":86899,"modified_method":"@Override\n  protected String getElementPresentation() {\n    return \" Negating goto instruction, condition=\" + getCondition().num() + getElement();\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static DFAType getInferredType(@NotNull String varName, @NotNull Instruction instruction, @NotNull Instruction[] flow, @NotNull GrControlFlowOwner scope) {\n    final Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>> pair = getDefUseMaps(scope);\n\n    List<TIntObjectHashMap<TIntHashSet>> dfaResult = pair.second;\n    if (dfaResult == null) return null;\n\n    final int varIndex = pair.first.getVarIndex(varName);\n\n    final TIntObjectHashMap<TIntHashSet> allDefs = dfaResult.get(instruction.num());\n    final TIntHashSet varDefs = allDefs.get(varIndex);\n    if (varDefs == null) return null;\n\n    DFAType result = null;\n    for (int defIndex : varDefs.toArray()) {\n      DFAType defType = getDefinitionType(flow[defIndex], flow, scope);\n\n      final NegatingGotoInstruction negating = instruction.getNegatingGotoInstruction();\n      if (defType != null) {\n        defType = defType.negate(negating);\n      }\n\n      if (defType != null) {\n        result = result == null ? defType : DFAType.create(defType, result, scope.getManager());\n      }\n    }\n    return result;\n  }","id":86900,"modified_method":"@Nullable\n  private static DFAType getInferredType(@NotNull String varName, @NotNull Instruction instruction, @NotNull Instruction[] flow, @NotNull GrControlFlowOwner scope) {\n    final Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>> pair = getDefUseMaps(scope);\n\n    List<TIntObjectHashMap<TIntHashSet>> dfaResult = pair.second;\n    if (dfaResult == null) return null;\n\n    final int varIndex = pair.first.getVarIndex(varName);\n\n    final TIntObjectHashMap<TIntHashSet> allDefs = dfaResult.get(instruction.num());\n    final TIntHashSet varDefs = allDefs.get(varIndex);\n    if (varDefs == null) return null;\n\n    DFAType result = null;\n    for (int defIndex : varDefs.toArray()) {\n      DFAType defType = getDefinitionType(flow[defIndex], flow, scope);\n\n      if (defType != null) {\n        defType = defType.negate(instruction);\n      }\n\n      if (defType != null) {\n        result = result == null ? defType : DFAType.create(defType, result, scope.getManager());\n      }\n    }\n    return result;\n  }","commit_id":"d41471cadee075e3a7bbf6d75569912884b8df5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReturnStatement(GrReturnStatement returnStatement) {\n    final GrExpression value = returnStatement.getReturnValue();\n    if (value != null) value.accept(this);\n\n    addPendingEdge(null, myHead);\n    flowAbrupted();\n  }","id":86901,"modified_method":"public void visitReturnStatement(GrReturnStatement returnStatement) {\n    boolean isNodeNeeded = myHead == null || myHead.getElement() != returnStatement;\n    final GrExpression value = returnStatement.getReturnValue();\n    if (value != null) value.accept(this);\n\n    if (isNodeNeeded) {\n      InstructionImpl retInsn = startNode(returnStatement);\n      addPendingEdge(null, myHead);\n      finishNode(retInsn);\n    } else {\n      addPendingEdge(null, myHead);\n    }\n    flowAbrupted();\n  }","commit_id":"ea6d8244fb4eb0ca8fe5905d433bbadff43180b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Class[] getInspectionClasses() {\n    return new Class[] {\n        SecondUnsafeCallInspection.class,\n        UnusedDefInspection.class,\n        UnassignedVariableAccessInspection.class,\n\n        GroovyResultOfAssignmentUsedInspection.class,\n        GroovyAssignmentCanBeOperatorAssignmentInspection.class,\n        GroovyAssignmentToForLoopParameterInspection.class,\n        GroovyAssignmentToMethodParameterInspection.class,\n        GroovyNestedAssignmentInspection.class,\n        GroovySillyAssignmentInspection.class,\n\n        GroovyContinueOrBreakFromFinallyBlockInspection.class,\n        GroovyReturnFromFinallyBlockInspection.class,\n        GroovyThrowFromFinallyBlockInspection.class,\n        GroovyThrowFromFinallyBlockInspection.class,\n        GroovyEmptyCatchBlockInspection.class,\n        GroovyEmptyFinallyBlockInspection.class,\n        GroovyEmptyTryBlockInspection.class,\n        GroovyUnusedCatchParameterInspection.class,\n\n        GroovyBreakInspection.class,\n        GroovyContinueInspection.class,\n        GroovyUnreachableStatementInspection.class,\n        GroovyLoopStatementThatDoesntLoopInspection.class,\n        GroovyConditionalWithIdenticalBranchesInspection.class,\n        GroovyConditionalCanBeElvisInspection.class,\n        GroovyConditionalCanBeConditionalCallInspection.class,\n        GroovyIfStatementWithIdenticalBranchesInspection.class,\n        GroovyIfStatementWithTooManyBranchesInspection.class,\n        GroovyFallthroughInspection.class,\n        GroovyUnnecessaryContinueInspection.class,\n        GroovyUnnecessaryReturnInspection.class,\n        GroovySwitchStatementWithNoDefaultInspection.class,\n        GroovyReturnFromClosureCanBeImplicitInspection.class,\n        GroovyTrivialConditionalInspection.class,\n        GroovyConstantConditionalInspection.class,\n        GroovyConstantIfStatementInspection.class,\n        GroovyTrivialIfInspection.class,\n\n        GroovyAccessToStaticFieldLockedOnInstanceInspection.class,\n        GroovyDoubleCheckedLockingInspection.class,\n        GroovyUnconditionalWaitInspection.class,\n        GroovyPublicFieldAccessedInSynchronizedContextInspection.class,\n        GroovyBusyWaitInspection.class,\n        GroovyEmptySyncBlockInspection.class,\n        GroovySynchronizationOnThisInspection.class,\n        GroovySynchronizedMethodInspection.class,\n        GroovyNestedSynchronizedStatementInspection.class,\n        GroovyThreadStopSuspendResumeInspection.class,\n        GroovySystemRunFinalizersOnExitInspection.class,\n        GroovyNotifyWhileNotSynchronizedInspection.class,\n        GroovyWaitCallNotInLoopInspection.class,\n        GroovyWaitWhileNotSynchronizedInspection.class,\n        GroovySynchronizationOnNonFinalFieldInspection.class,\n        GroovySynchronizationOnVariableInitializedWithLiteralInspection.class,\n        GroovyUnsynchronizedMethodOverridesSynchronizedMethodInspection.class,\n        GroovyWhileLoopSpinsOnFieldInspection.class,\n\n        GroovyMethodParameterCountInspection.class,\n        GroovyOverlyComplexMethodInspection.class,\n        GroovyOverlyLongMethodInspection.class,\n        GroovyOverlyNestedMethodInspection.class,\n        GroovyMethodWithMoreThanThreeNegationsInspection.class,\n        GroovyMultipleReturnPointsPerMethodInspection.class,\n\n        GroovyNestedSwitchInspection.class,\n        GroovyConditionalInspection.class,\n        GroovyNestedConditionalInspection.class,\n        GroovyNegatedConditionalInspection.class,\n        GroovyNegatedIfInspection.class,\n        GroovyResultOfIncrementOrDecrementUsedInspection.class,\n        GroovyEmptyStatementBodyInspection.class,\n        GroovyPointlessBooleanInspection.class,\n        GroovyPointlessArithmeticInspection.class,\n        GroovyDoubleNegationInspection.class,\n        GroovyOverlyComplexArithmeticExpressionInspection.class,\n        GroovyOverlyComplexBooleanExpressionInspection.class,\n        GroovyOctalIntegerInspection.class,\n\n        GroovyDuplicateSwitchBranchInspection.class,\n        GroovyMethodWithInconsistentReturnsInspection.class,\n\n        GroovyNonShortCircuitBooleanInspection.class,\n        GroovyInfiniteLoopStatementInspection.class,\n        GroovyInfiniteRecursionInspection.class,\n        GroovyDivideByZeroInspection.class,\n        GroovyResultOfArrayAllocationIgnoredInspection.class,\n        GroovyResultOfObjectAllocationIgnoredInspection.class,\n\n        GroovyClassNamingConventionInspection.class,\n        GroovyInterfaceNamingConventionInspection.class,\n        GroovyAnnotationNamingConventionInspection.class,\n        GroovyEnumerationNamingConventionInspection.class,\n        GroovyLocalVariableNamingConventionInspection.class,\n        GroovyStaticMethodNamingConventionInspection.class,\n        GroovyStaticVariableNamingConventionInspection.class,\n        GroovyInstanceMethodNamingConventionInspection.class,\n        GroovyInstanceVariableNamingConventionInspection.class,\n        GroovyConstantNamingConventionInspection.class,\n        GroovyParameterNamingConventionInspection.class,\n\n        GroovyGetterCallCanBePropertyAccessInspection.class,\n        GroovySetterCallCanBePropertyAccessInspection.class,\n        GroovyMapGetCanBeKeyedAccessInspection.class,\n        GroovyMapPutCanBeKeyedAccessInspection.class,\n        GroovyListGetCanBeKeyedAccessInspection.class,\n        GroovyListSetCanBeKeyedAccessInspection.class,\n    };\n  }","id":86902,"modified_method":"public Class[] getInspectionClasses() {\n    return new Class[] {\n        SecondUnsafeCallInspection.class,\n        UnusedDefInspection.class,\n        UnassignedVariableAccessInspection.class,\n        MissingReturnInspection.class,\n\n        GroovyResultOfAssignmentUsedInspection.class,\n        GroovyAssignmentCanBeOperatorAssignmentInspection.class,\n        GroovyAssignmentToForLoopParameterInspection.class,\n        GroovyAssignmentToMethodParameterInspection.class,\n        GroovyNestedAssignmentInspection.class,\n        GroovySillyAssignmentInspection.class,\n\n        GroovyContinueOrBreakFromFinallyBlockInspection.class,\n        GroovyReturnFromFinallyBlockInspection.class,\n        GroovyThrowFromFinallyBlockInspection.class,\n        GroovyThrowFromFinallyBlockInspection.class,\n        GroovyEmptyCatchBlockInspection.class,\n        GroovyEmptyFinallyBlockInspection.class,\n        GroovyEmptyTryBlockInspection.class,\n        GroovyUnusedCatchParameterInspection.class,\n\n        GroovyBreakInspection.class,\n        GroovyContinueInspection.class,\n        GroovyUnreachableStatementInspection.class,\n        GroovyLoopStatementThatDoesntLoopInspection.class,\n        GroovyConditionalWithIdenticalBranchesInspection.class,\n        GroovyConditionalCanBeElvisInspection.class,\n        GroovyConditionalCanBeConditionalCallInspection.class,\n        GroovyIfStatementWithIdenticalBranchesInspection.class,\n        GroovyIfStatementWithTooManyBranchesInspection.class,\n        GroovyFallthroughInspection.class,\n        GroovyUnnecessaryContinueInspection.class,\n        GroovyUnnecessaryReturnInspection.class,\n        GroovySwitchStatementWithNoDefaultInspection.class,\n        GroovyReturnFromClosureCanBeImplicitInspection.class,\n        GroovyTrivialConditionalInspection.class,\n        GroovyConstantConditionalInspection.class,\n        GroovyConstantIfStatementInspection.class,\n        GroovyTrivialIfInspection.class,\n\n        GroovyAccessToStaticFieldLockedOnInstanceInspection.class,\n        GroovyDoubleCheckedLockingInspection.class,\n        GroovyUnconditionalWaitInspection.class,\n        GroovyPublicFieldAccessedInSynchronizedContextInspection.class,\n        GroovyBusyWaitInspection.class,\n        GroovyEmptySyncBlockInspection.class,\n        GroovySynchronizationOnThisInspection.class,\n        GroovySynchronizedMethodInspection.class,\n        GroovyNestedSynchronizedStatementInspection.class,\n        GroovyThreadStopSuspendResumeInspection.class,\n        GroovySystemRunFinalizersOnExitInspection.class,\n        GroovyNotifyWhileNotSynchronizedInspection.class,\n        GroovyWaitCallNotInLoopInspection.class,\n        GroovyWaitWhileNotSynchronizedInspection.class,\n        GroovySynchronizationOnNonFinalFieldInspection.class,\n        GroovySynchronizationOnVariableInitializedWithLiteralInspection.class,\n        GroovyUnsynchronizedMethodOverridesSynchronizedMethodInspection.class,\n        GroovyWhileLoopSpinsOnFieldInspection.class,\n\n        GroovyMethodParameterCountInspection.class,\n        GroovyOverlyComplexMethodInspection.class,\n        GroovyOverlyLongMethodInspection.class,\n        GroovyOverlyNestedMethodInspection.class,\n        GroovyMethodWithMoreThanThreeNegationsInspection.class,\n        GroovyMultipleReturnPointsPerMethodInspection.class,\n\n        GroovyNestedSwitchInspection.class,\n        GroovyConditionalInspection.class,\n        GroovyNestedConditionalInspection.class,\n        GroovyNegatedConditionalInspection.class,\n        GroovyNegatedIfInspection.class,\n        GroovyResultOfIncrementOrDecrementUsedInspection.class,\n        GroovyEmptyStatementBodyInspection.class,\n        GroovyPointlessBooleanInspection.class,\n        GroovyPointlessArithmeticInspection.class,\n        GroovyDoubleNegationInspection.class,\n        GroovyOverlyComplexArithmeticExpressionInspection.class,\n        GroovyOverlyComplexBooleanExpressionInspection.class,\n        GroovyOctalIntegerInspection.class,\n\n        GroovyDuplicateSwitchBranchInspection.class,\n        GroovyMethodWithInconsistentReturnsInspection.class,\n\n        GroovyNonShortCircuitBooleanInspection.class,\n        GroovyInfiniteLoopStatementInspection.class,\n        GroovyInfiniteRecursionInspection.class,\n        GroovyDivideByZeroInspection.class,\n        GroovyResultOfArrayAllocationIgnoredInspection.class,\n        GroovyResultOfObjectAllocationIgnoredInspection.class,\n\n        GroovyClassNamingConventionInspection.class,\n        GroovyInterfaceNamingConventionInspection.class,\n        GroovyAnnotationNamingConventionInspection.class,\n        GroovyEnumerationNamingConventionInspection.class,\n        GroovyLocalVariableNamingConventionInspection.class,\n        GroovyStaticMethodNamingConventionInspection.class,\n        GroovyStaticVariableNamingConventionInspection.class,\n        GroovyInstanceMethodNamingConventionInspection.class,\n        GroovyInstanceVariableNamingConventionInspection.class,\n        GroovyConstantNamingConventionInspection.class,\n        GroovyParameterNamingConventionInspection.class,\n\n        GroovyGetterCallCanBePropertyAccessInspection.class,\n        GroovySetterCallCanBePropertyAccessInspection.class,\n        GroovyMapGetCanBeKeyedAccessInspection.class,\n        GroovyMapPutCanBeKeyedAccessInspection.class,\n        GroovyListGetCanBeKeyedAccessInspection.class,\n        GroovyListSetCanBeKeyedAccessInspection.class,\n    };\n  }","commit_id":"ea6d8244fb4eb0ca8fe5905d433bbadff43180b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(GrAssignmentExpression expression) {\n    GrExpression lValue = expression.getLValue();\n    if (expression.getOperationToken() != GroovyTokenTypes.mASSIGN) {\n      if (lValue instanceof GrReferenceExpression) {\n        String referenceName = ((GrReferenceExpression)lValue).getReferenceName();\n        if (referenceName != null) {\n          addNodeAndCheckPending(new ReadWriteVariableInstruction(referenceName, lValue, myInstructionNumber++, READ));\n        }\n      }\n    }\n\n    GrExpression rValue = expression.getRValue();\n    if (rValue != null) {\n      rValue.accept(this);\n      lValue.accept(this);\n    }\n  }","id":86903,"modified_method":"public void visitAssignmentExpression(GrAssignmentExpression expression) {\n    GrExpression lValue = expression.getLValue();\n    if (expression.getOperationToken() != mASSIGN) {\n      if (lValue instanceof GrReferenceExpression) {\n        String referenceName = ((GrReferenceExpression)lValue).getReferenceName();\n        if (referenceName != null) {\n          addNodeAndCheckPending(new ReadWriteVariableInstruction(referenceName, lValue, myInstructionNumber++, READ));\n        }\n      }\n    }\n\n    GrExpression rValue = expression.getRValue();\n    if (rValue != null) {\n      rValue.accept(this);\n      lValue.accept(this);\n    }\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new ArrayDeque<InstructionImpl>();\n    myCaughtExceptionInfos = new ArrayDeque<ExceptionInfo>();\n    myFinallyCount = 0;\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 0;\n\n    myLastInScope = null;\n\n    if (scope instanceof GrStatementOwner) {\n      GrStatement[] statements = ((GrStatementOwner)scope).getStatements();\n      if (statements.length > 0) {\n        myLastInScope = statements[statements.length - 1];\n      }\n    }\n\n    startNode(null);\n    if (scope instanceof GrClosableBlock) {\n      buildFlowForClosure((GrClosableBlock)scope);\n    }\n    else {\n      scope.accept(this);\n    }\n\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n\n\n    return assertValidPsi(myInstructions.toArray(new Instruction[myInstructions.size()]));\n  }","id":86904,"modified_method":"public Instruction[] buildControlFlow(GroovyPsiElement scope) {\n    myInstructions = new ArrayList<InstructionImpl>();\n    myProcessingStack = new ArrayDeque<InstructionImpl>();\n    myCaughtExceptionInfos = new ArrayDeque<ExceptionInfo>();\n    myConditions = new ArrayDeque<ConditionInstruction>();\n    myNegatingStack = new ArrayDeque<NegatingGotoInstruction>();\n\n    myFinallyCount = 0;\n    myPending = new ArrayList<Pair<InstructionImpl, GroovyPsiElement>>();\n    myInstructionNumber = 0;\n\n    myLastInScope = null;\n\n    if (scope instanceof GrStatementOwner) {\n      GrStatement[] statements = ((GrStatementOwner)scope).getStatements();\n      if (statements.length > 0) {\n        myLastInScope = statements[statements.length - 1];\n      }\n    }\n\n    startNode(null);\n    if (scope instanceof GrClosableBlock) {\n      buildFlowForClosure((GrClosableBlock)scope);\n    }\n    else {\n      scope.accept(this);\n    }\n\n    final InstructionImpl end = startNode(null);\n    checkPending(end); //collect return edges\n\n\n    return assertValidPsi(myInstructions.toArray(new Instruction[myInstructions.size()]));\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand != null) {\n      final boolean negation = expression.getOperationTokenType() == GroovyTokenTypes.mLNOT;\n      if (negation) {\n        myNegate = !myNegate;\n      }\n      operand.accept(this);\n      if (negation) {\n        myNegate = !myNegate;\n      }\n      visitCall(expression);\n    }\n  }","id":86905,"modified_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand != null) {\n      ConditionInstruction cond = null;\n      if (expression.getOperationTokenType() == mLNOT) {\n        cond = new ConditionInstruction(expression, myInstructionNumber++);\n        addNodeAndCheckPending(cond);\n        registerCondition(cond);\n      }\n      operand.accept(this);\n      visitCall(expression);\n\n      if (cond != null) {\n        myConditions.removeFirstOccurrence(cond);\n        myNegatingStack.push(addNodeAndCheckPending(new NegatingGotoInstruction(expression, myInstructionNumber++, cond)));\n      }\n    }\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitInstanceofExpression(GrInstanceOfExpression expression) {\n    expression.getOperand().accept(this);\n    addNode(new InstanceOfInstruction(myInstructionNumber++, expression, myNegate));\n  }","id":86906,"modified_method":"@Override\n  public void visitInstanceofExpression(GrInstanceOfExpression expression) {\n    expression.getOperand().accept(this);\n    final ConditionInstruction cond = myConditions.peek();\n    addNode(new InstanceOfInstruction(myInstructionNumber++, expression, cond));\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n    final GrCondition condition = ifStatement.getCondition();\n\n    final InstructionImpl head = myHead;\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    InstructionImpl thenEnd = null;\n    if (thenBranch != null) {\n      if (condition != null) {\n        condition.accept(this);\n      }\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      thenEnd = myHead;\n    }\n\n    myHead = head;\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    InstructionImpl elseEnd = null;\n    if (elseBranch != null) {\n      if (condition != null) {\n        myNegate = !myNegate;\n        final boolean old = myAssertionsOnly;\n        myAssertionsOnly = true;\n        condition.accept(this);\n        myNegate = !myNegate;\n        myAssertionsOnly = old;\n      }\n\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n      elseEnd = myHead;\n    }\n\n\n    if (thenBranch != null || elseBranch != null) {\n      final InstructionImpl end = new IfEndInstruction(ifStatement, myInstructionNumber++);\n      addNode(end);\n      if (thenEnd != null) addEdge(thenEnd, end);\n      if (elseEnd != null) addEdge(elseEnd, end);\n    }\n    finishNode(ifInstruction);\n  }","id":86907,"modified_method":"public void visitIfStatement(GrIfStatement ifStatement) {\n    InstructionImpl ifInstruction = startNode(ifStatement);\n\n    final InstructionImpl head = myHead;\n\n    final GrCondition condition = ifStatement.getCondition();\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n\n    InstructionImpl conditionEnd = null;\n    InstructionImpl thenEnd = null;\n    InstructionImpl elseEnd = null;\n\n    ConditionInstruction conditionStart = null;\n    if (condition != null) {\n      conditionStart = addNodeAndCheckPending(new ConditionInstruction(condition, myInstructionNumber++));\n      registerCondition(conditionStart);\n      condition.accept(this);\n      conditionEnd = myHead;\n    }\n\n    if (thenBranch != null) {\n      thenBranch.accept(this);\n      handlePossibleReturn(thenBranch);\n      thenEnd = myHead;\n      interruptFlow();\n    }\n\n    if (condition != null) {\n      myHead = conditionEnd;\n      myNegatingStack.push(addNode(new NegatingGotoInstruction(condition, myInstructionNumber++, conditionStart)));\n    }\n    else {\n      myHead = head;\n    }\n\n    if (elseBranch != null) {\n      elseBranch.accept(this);\n      handlePossibleReturn(elseBranch);\n      elseEnd = myHead;\n    }\n\n    if (thenBranch != null || elseBranch != null) {\n      final InstructionImpl end = new IfEndInstruction(ifStatement, myInstructionNumber++);\n      addNode(end);\n      if (thenEnd != null) addEdge(thenEnd, end);\n      if (elseEnd != null) addEdge(elseEnd, end);\n    }\n    finishNode(ifInstruction);\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addNodeAndCheckPending(InstructionImpl i) {\n    addNode(i);\n    checkPending(i);\n  }","id":86908,"modified_method":"private <T extends InstructionImpl> T addNodeAndCheckPending(T i) {\n    addNode(i);\n    checkPending(i);\n    return i;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    final GrExpression right = expression.getRightOperand();\n    final IElementType opType = expression.getOperationTokenType();\n\n    InstructionImpl start = myHead;\n    left.accept(this);\n\n    if (right != null) {\n      if (opType == GroovyTokenTypes.mLOR) {\n        addPendingEdge(expression, myHead);\n        myHead = start;\n\n        myNegate = !myNegate;\n        left.accept(this);\n        myNegate = !myNegate;\n      }\n\n      right.accept(this);\n    }\n\n    visitCall(expression);\n  }","id":86909,"modified_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    final GrExpression right = expression.getRightOperand();\n    final IElementType opType = expression.getOperationTokenType();\n\n    final ConditionInstruction cond;\n    if (opType == mLOR /*|| opType == mLAND*/) {\n      cond = addNodeAndCheckPending(new ConditionInstruction(expression, myInstructionNumber++));\n      registerCondition(cond);\n    }\n    else {\n      cond = null;\n    }\n    left.accept(this);\n\n    if (cond != null) {\n      myConditions.removeFirstOccurrence(cond);\n    }\n\n    NegatingGotoInstruction first = null;\n    if (right != null) {\n      if (cond != null) {\n        final InstructionImpl head = myHead;\n        /*if (opType == mLAND) {\n          first = addNodeAndCheckPending(new NegatingGotoInstruction(expression, myInstructionNumber++, cond));\n        }*/\n        addPendingEdge(expression, myHead);\n        myHead = head;\n        if (opType == mLOR) {\n          myNegatingStack.push(addNodeAndCheckPending(new NegatingGotoInstruction(expression, myInstructionNumber++, cond)));\n        }\n      }\n\n      right.accept(this);\n    }\n\n    visitCall(expression);\n    if (first != null) {\n      myNegatingStack.push(first);\n    }\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReferenceExpression(GrReferenceExpression refExpr) {\n    super.visitReferenceExpression(refExpr);\n    if (refExpr.getQualifierExpression() == null) {\n      String name = refExpr.getReferenceName();\n      if (name == null) return;\n\n      if (ControlFlowUtils.isIncOrDecOperand(refExpr) && !myAssertionsOnly) {\n        final InstructionImpl i = new ReadWriteVariableInstruction(name, refExpr, myInstructionNumber++, READ);\n        addNodeAndCheckPending(i);\n        addNode(new ReadWriteVariableInstruction(name, refExpr, myInstructionNumber++, WRITE));\n      }\n      else {\n        boolean isWrite = !myAssertionsOnly && PsiUtil.isLValue(refExpr);\n        addNodeAndCheckPending(new ReadWriteVariableInstruction(name, refExpr, myInstructionNumber++, isWrite ? WRITE : READ));\n        if (refExpr.getParent() instanceof GrArgumentList && refExpr.getParent().getParent() instanceof GrCall) {\n          addNodeAndCheckPending(new ArgumentInstruction(refExpr, myInstructionNumber++));\n        }\n      }\n    }\n    else if (!(refExpr.getParent() instanceof GrCall)) {\n      visitCall(refExpr);\n    }\n  }","id":86910,"modified_method":"public void visitReferenceExpression(GrReferenceExpression refExpr) {\n    super.visitReferenceExpression(refExpr);\n    if (refExpr.getQualifierExpression() == null) {\n      String name = refExpr.getReferenceName();\n      if (name == null) return;\n\n      if (ControlFlowUtils.isIncOrDecOperand(refExpr)) {\n        final InstructionImpl i = new ReadWriteVariableInstruction(name, refExpr, myInstructionNumber++, READ);\n        addNodeAndCheckPending(i);\n        addNode(new ReadWriteVariableInstruction(name, refExpr, myInstructionNumber++, WRITE));\n      }\n      else {\n        final int type = PsiUtil.isLValue(refExpr) ? WRITE : READ;\n        addNodeAndCheckPending(new ReadWriteVariableInstruction(name, refExpr, myInstructionNumber++, type));\n        if (refExpr.getParent() instanceof GrArgumentList && refExpr.getParent().getParent() instanceof GrCall) {\n          addNodeAndCheckPending(new ArgumentInstruction(refExpr, myInstructionNumber++));\n        }\n      }\n    }\n    else if (!(refExpr.getParent() instanceof GrCall)) {\n      visitCall(refExpr);\n    }\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private GrInstanceOfExpression getApplicableInstanceof() {\n    final PsiElement element = getElement();\n    if (element instanceof GrInstanceOfExpression && !isNegate()) {\n      GrExpression operand = ((GrInstanceOfExpression)element).getOperand();\n      final GrTypeElement typeElement = ((GrInstanceOfExpression)element).getTypeElement();\n      if (operand instanceof GrReferenceExpression && ((GrReferenceExpression)operand).getQualifier() == null && typeElement != null) {\n        return (GrInstanceOfExpression)element;\n      }\n    }\n    return null;\n  }","id":86911,"modified_method":"@Nullable\n  private GrInstanceOfExpression getApplicableInstanceof() {\n    final PsiElement element = getElement();\n    if (element instanceof GrInstanceOfExpression) {\n      GrExpression operand = ((GrInstanceOfExpression)element).getOperand();\n      final GrTypeElement typeElement = ((GrInstanceOfExpression)element).getTypeElement();\n      if (operand instanceof GrReferenceExpression && ((GrReferenceExpression)operand).getQualifier() == null && typeElement != null) {\n        return (GrInstanceOfExpression)element;\n      }\n    }\n    return null;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getElementPresentation() {\n    return \"instanceof: \" + (myNegate ? \"! \" : \"\") + getElement().getText();\n  }","id":86912,"modified_method":"protected String getElementPresentation() {\n    return \"instanceof: \" + getElement().getText();\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InstanceOfInstruction(int num, GrExpression assertion, boolean negate) {\n    super(assertion, num);\n    myNegate = negate;\n  }","id":86913,"modified_method":"public InstanceOfInstruction(int num, GrExpression assertion, ConditionInstruction cond) {\n    super(assertion, num);\n    myCondition = cond;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTooComplexTooAnalyze(GrControlFlowOwner scope) {\n    return getDefUseMaps(scope).second == null;\n  }","id":86914,"modified_method":"public static boolean isTooComplexTooAnalyze(GrControlFlowOwner scope) {\n    return getDefUseMaps(scope) == null;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>> getDefUseMaps(final GrControlFlowOwner scope) {\n    return CachedValuesManager.getManager(scope.getProject()).getCachedValue(scope, new CachedValueProvider<Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>>>() {\n      @Override\n      public Result<Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>>> compute() {\n        final Instruction[] flow = scope.getControlFlow();\n        final ReachingDefinitionsDfaInstance dfaInstance = new ReachingDefinitionsDfaInstance(flow) {\n          @Override\n          public void fun(TIntObjectHashMap<TIntHashSet> m, Instruction instruction) {\n            if (instruction instanceof InstanceOfInstruction) { //todo assertions are not defs, they just add to type intersection and don't overwrite it completely\n              final InstanceOfInstruction instanceOfInstruction = (InstanceOfInstruction)instruction;\n              final PsiElement element = instanceOfInstruction.getElement();\n              if (element instanceof GrInstanceOfExpression && !instanceOfInstruction.isNegate()) {\n                final GrExpression operand = ((GrInstanceOfExpression)element).getOperand();\n                final GrTypeElement typeElement = ((GrInstanceOfExpression)element).getTypeElement();\n                if (typeElement != null) {\n                  final int varIndex = getVarIndex(operand.getText());\n                  if (varIndex >= 0) {\n                    registerDef(m, instruction, varIndex);\n                  }\n                }\n              }\n            }\n            else if (instruction instanceof ArgumentInstruction) {\n              final int varIndex = getVarIndex(((ArgumentInstruction)instruction).getVariableName());\n              registerDef(m, instruction, varIndex);\n            }\n            else {\n              super.fun(m, instruction);\n            }\n          }\n        };\n        final ReachingDefinitionsSemilattice lattice = new ReachingDefinitionsSemilattice();\n        final DFAEngine<TIntObjectHashMap<TIntHashSet>> engine = new DFAEngine<TIntObjectHashMap<TIntHashSet>>(flow, dfaInstance, lattice);\n        final List<TIntObjectHashMap<TIntHashSet>> dfaResult = engine.performDFAWithTimeout();\n        return Result.create(Pair.create(dfaInstance, dfaResult), PsiModificationTracker.MODIFICATION_COUNT);\n      }\n    });\n  }","id":86915,"modified_method":"private static Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>> getDefUseMaps(final GrControlFlowOwner scope) {\n    return CachedValuesManager.getManager(scope.getProject()).getCachedValue(scope, new CachedValueProvider<Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>>>() {\n      @Override\n      public Result<Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>>> compute() {\n        final Instruction[] flow = scope.getControlFlow();\n        final ReachingDefinitionsDfaInstance dfaInstance = new ReachingDefinitionsDfaInstance(flow) {\n          @Override\n          public void fun(TIntObjectHashMap<TIntHashSet> m, Instruction instruction) {\n            if (instruction instanceof InstanceOfInstruction) {\n              final InstanceOfInstruction instanceOfInstruction = (InstanceOfInstruction)instruction;\n              final PsiElement element = instanceOfInstruction.getElement();\n              if (element instanceof GrInstanceOfExpression) {\n                final GrExpression operand = ((GrInstanceOfExpression)element).getOperand();\n                final GrTypeElement typeElement = ((GrInstanceOfExpression)element).getTypeElement();\n                if (typeElement != null) {\n                  final int varIndex = getVarIndex(operand.getText());\n                  if (varIndex >= 0) {\n                    registerDef(m, instruction, varIndex);\n                  }\n                }\n              }\n            }\n            else if (instruction instanceof ArgumentInstruction) {\n              final int varIndex = getVarIndex(((ArgumentInstruction)instruction).getVariableName());\n              registerDef(m, instruction, varIndex);\n            }\n            else {\n              super.fun(m, instruction);\n            }\n          }\n        };\n        final ReachingDefinitionsSemilattice lattice = new ReachingDefinitionsSemilattice();\n        final DFAEngine<TIntObjectHashMap<TIntHashSet>> engine = new DFAEngine<TIntObjectHashMap<TIntHashSet>>(flow, dfaInstance, lattice);\n        final List<TIntObjectHashMap<TIntHashSet>> dfaResult = engine.performDFAWithTimeout();\n        return Result.create(Pair.create(dfaInstance, dfaResult), PsiModificationTracker.MODIFICATION_COUNT);\n      }\n    });\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiType getInferredType(@NotNull String varName, @NotNull Instruction instruction, @NotNull Instruction[] flow, @NotNull GrControlFlowOwner scope) {\n    final Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>> pair = getDefUseMaps(scope);\n\n    List<TIntObjectHashMap<TIntHashSet>> dfaResult = pair.second;\n    if (dfaResult == null) return null;\n\n    final int varIndex = pair.first.getVarIndex(varName);\n\n    final TIntObjectHashMap<TIntHashSet> allDefs = dfaResult.get(instruction.num());\n    final TIntHashSet varDefs = allDefs.get(varIndex);\n    if (varDefs == null) return null;\n\n    PsiType result = null;\n    for (int defIndex : varDefs.toArray()) {\n      PsiType defType = getDefinitionType(flow[defIndex], flow, scope);\n      if (defType != null) {\n        defType = TypesUtil.boxPrimitiveType(defType, scope.getManager(), scope.getResolveScope());\n        result = result == null ? defType : TypesUtil.getLeastUpperBound(result, defType, scope.getManager());\n      }\n    }\n    return result;\n  }","id":86916,"modified_method":"@Nullable\n  private static DFAType getInferredType(@NotNull String varName, @NotNull Instruction instruction, @NotNull Instruction[] flow, @NotNull GrControlFlowOwner scope) {\n    final Pair<ReachingDefinitionsDfaInstance, List<TIntObjectHashMap<TIntHashSet>>> pair = getDefUseMaps(scope);\n\n    List<TIntObjectHashMap<TIntHashSet>> dfaResult = pair.second;\n    if (dfaResult == null) return null;\n\n    final int varIndex = pair.first.getVarIndex(varName);\n\n    final TIntObjectHashMap<TIntHashSet> allDefs = dfaResult.get(instruction.num());\n    final TIntHashSet varDefs = allDefs.get(varIndex);\n    if (varDefs == null) return null;\n\n    DFAType result = null;\n    for (int defIndex : varDefs.toArray()) {\n      DFAType defType = getDefinitionType(flow[defIndex], flow, scope);\n\n      final NegatingGotoInstruction negating = instruction.getNegatingGotoInstruction();\n      if (defType != null) {\n        defType = defType.negate(negating);\n      }\n\n      if (defType != null) {\n        result = result == null ? defType : DFAType.create(defType, result, scope.getManager());\n      }\n    }\n    return result;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiType getDefinitionType(Instruction instruction, Instruction[] flow, GrControlFlowOwner scope) {\n    if (instruction instanceof ReadWriteVariableInstruction && ((ReadWriteVariableInstruction) instruction).isWrite()) {\n      final PsiElement element = instruction.getElement();\n      if (element != null) {\n        return getInitializerType(element);\n      }\n    }\n    if (instruction instanceof MixinTypeInstruction) {\n      return mixinType((MixinTypeInstruction)instruction, flow, scope);\n    }\n    return null;\n  }","id":86917,"modified_method":"@Nullable\n  private static DFAType getDefinitionType(Instruction instruction, Instruction[] flow, GrControlFlowOwner scope) {\n    if (instruction instanceof ReadWriteVariableInstruction && ((ReadWriteVariableInstruction) instruction).isWrite()) {\n      final PsiElement element = instruction.getElement();\n      if (element != null) {\n        return DFAType.create(TypesUtil.boxPrimitiveType(getInitializerType(element), scope.getManager(), scope.getResolveScope()));\n      }\n    }\n    if (instruction instanceof MixinTypeInstruction) {\n      return mixinType((MixinTypeInstruction)instruction, flow, scope);\n    }\n    return null;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiType mixinType(final MixinTypeInstruction instruction, final Instruction[] flow, final GrControlFlowOwner scope) {\n    return RecursionManager.doPreventingRecursion(instruction, false, new NullableComputable<PsiType>() {\n      @Override\n      @Nullable\n      public PsiType compute() {\n        String varName = instruction.getVariableName();\n        if (varName == null) return null;\n        ReadWriteVariableInstruction originalInstr = instruction.getInstructionToMixin(flow);\n        LOG.assertTrue(originalInstr != null, scope.getContainingFile().getName() + \":\" + scope.getText());\n        final PsiType original = getInferredType(varName, originalInstr, flow, scope);\n        final PsiType mixin = instruction.inferMixinType();\n        if (mixin == null) return original;\n        if (original == null) return mixin;\n        if (TypesUtil.isAssignableByMethodCallConversion(mixin, original, scope)) return original;\n        return PsiIntersectionType.createIntersection(mixin, original);\n      }\n    });\n  }","id":86918,"modified_method":"@Nullable\n  private static DFAType mixinType(final MixinTypeInstruction instruction, final Instruction[] flow, final GrControlFlowOwner scope) {\n    return RecursionManager.doPreventingRecursion(instruction, false, new NullableComputable<DFAType>() {\n      @Override\n      @Nullable\n      public DFAType compute() {\n        String varName = instruction.getVariableName();\n        if (varName == null) return null;\n        ReadWriteVariableInstruction originalInstr = instruction.getInstructionToMixin(flow);\n        LOG.assertTrue(originalInstr != null, scope.getContainingFile().getName() + \":\" + scope.getText());\n\n        DFAType original = getInferredType(varName, originalInstr, flow, scope);\n        final PsiType mixin = instruction.inferMixinType();\n        if (mixin == null) return original;\n        if (original == null) {\n          original = DFAType.create(null);\n        }\n        original.addMixin(mixin, instruction.getConditionInstruction());\n        return original;\n      }\n    });\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getInferredType(@NotNull final GrReferenceExpression refExpr) {\n    return RecursionManager.doPreventingRecursion(refExpr, true, new NullableComputable<PsiType>() {\n      @Override\n      public PsiType compute() {\n        final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(refExpr);\n        if (scope == null) return null;\n\n        final Instruction[] flow = scope.getControlFlow();\n        ReadWriteVariableInstruction instruction = findInstruction(refExpr, flow);\n        if (instruction == null) return null;\n\n        if (instruction.isWrite()) {\n          return getInitializerType(refExpr);\n        }\n\n        return getInferredType(refExpr.getReferenceName(), instruction, flow, scope);\n      }\n\n    });\n  }","id":86919,"modified_method":"@Nullable\n  public static PsiType getInferredType(@NotNull final GrReferenceExpression refExpr) {\n    return RecursionManager.doPreventingRecursion(refExpr, true, new NullableComputable<PsiType>() {\n      @Override\n      public PsiType compute() {\n        final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(refExpr);\n        if (scope == null) return null;\n\n        final Instruction[] flow = scope.getControlFlow();\n        ReadWriteVariableInstruction instruction = findInstruction(refExpr, flow);\n        if (instruction == null) return null;\n\n        if (instruction.isWrite()) {\n          return getInitializerType(refExpr);\n        }\n\n        final DFAType type = getInferredType(refExpr.getReferenceName(), instruction, flow, scope);\n        if (type == null) return null;\n        return type.getType();\n      }\n\n    });\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getInferredType(@NotNull PsiElement place, String variableName) {\n    final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(place);\n    if (scope == null) return null;\n\n    final Instruction[] flow = scope.getControlFlow();\n    Instruction instruction = findInstructionAt(place, flow);\n    if (instruction == null) return null;\n\n    return getInferredType(variableName, instruction, flow, scope);\n  }","id":86920,"modified_method":"@Nullable\n  public static PsiType getInferredType(@NotNull PsiElement place, String variableName) {\n    final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(place);\n    if (scope == null) return null;\n\n    final Instruction[] flow = scope.getControlFlow();\n    Instruction instruction = findInstructionAt(place, flow);\n    if (instruction == null) return null;\n\n    final DFAType type = getInferredType(variableName, instruction, flow, scope);\n    return type != null ? type.getType() : null;\n  }","commit_id":"cbd9cbc865892d68730f212afc453eb6bde5f511","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    super.doOKAction();\n    int exitCode = Messages.showDialog(IdeBundle.message(\"prompt.open.project.in.new.frame\"), IdeBundle.message(\"title.open.project\"),\n      new String[]{IdeBundle.message(\"button.newframe\"), IdeBundle.message(\"button.existingframe\")}, 1, Messages.getQuestionIcon());\n\n    final String[] error = new String[]{null};\n    ProgressManager.getInstance().run(new Task.Modal(myProject, \"Creating\", false) {\n      public void run(@NotNull() ProgressIndicator indicator) {\n        indicator.setIndeterminate(true);\n        error[0] = createDirs();\n        if (error[0] != null) {\n          return;\n        }\n        createProject();\n      }\n    });\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        SModelRepository.getInstance().saveAll();\n      }\n    });\n\n\n    if (error[0] != null) {\n      Messages.showErrorDialog(getContentPane(), error[0]);\n      return;\n    }\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        if (myCreatedSolution != null && myCreatedLanguage != null) {\n          addLanguageImportToSolution(myCreatedLanguage, myCreatedSolution);\n        }\n      }\n    });\n\n    if (myCreatedProject == null) return;\n    myCreatedProject.save();\n\n    if ((exitCode == 1) && (myProject != null)) {\n      ProjectUtil.closeProject(myProject);\n    }\n\n    ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    projectManager.openProject(myCreatedProject);\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            myCreatedProject.getComponent(ProjectPane.class).activate();\n          }\n        }, ModalityState.NON_MODAL);\n      }\n    }, ModalityState.NON_MODAL);\n  }","id":86921,"modified_method":"protected void doOKAction() {\n    super.doOKAction();\n    int exitCode = 1;\n    if (myProject != null) {\n      exitCode = Messages.showDialog(IdeBundle.message(\"prompt.open.project.in.new.frame\"), IdeBundle.message(\"title.open.project\"),\n        new String[]{IdeBundle.message(\"button.newframe\"), IdeBundle.message(\"button.existingframe\")}, 1, Messages.getQuestionIcon());\n    }\n\n    final String[] error = new String[]{null};\n    ProgressManager.getInstance().run(new Task.Modal(myProject, \"Creating\", false) {\n      public void run(@NotNull() ProgressIndicator indicator) {\n        indicator.setIndeterminate(true);\n        error[0] = createDirs();\n        if (error[0] != null) {\n          return;\n        }\n        createProject();\n      }\n    });\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        SModelRepository.getInstance().saveAll();\n      }\n    });\n\n\n    if (error[0] != null) {\n      Messages.showErrorDialog(getContentPane(), error[0]);\n      return;\n    }\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        if (myCreatedSolution != null && myCreatedLanguage != null) {\n          addLanguageImportToSolution(myCreatedLanguage, myCreatedSolution);\n        }\n      }\n    });\n\n    if (myCreatedProject == null) return;\n    myCreatedProject.save();\n\n    if ((exitCode == 1) && (myProject != null)) {\n      ProjectUtil.closeProject(myProject);\n    }\n\n    ProjectManagerEx projectManager = ProjectManagerEx.getInstanceEx();\n    projectManager.openProject(myCreatedProject);\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          public void run() {\n            myCreatedProject.getComponent(ProjectPane.class).activate();\n          }\n        }, ModalityState.NON_MODAL);\n      }\n    }, ModalityState.NON_MODAL);\n  }","commit_id":"ad58808ec03a9d10c749a0ec7c484c60eb18e886","url":"https://github.com/JetBrains/MPS"},{"original_method":"private ModelRootWrapper(ModelRoot modelRoot) {\n      myModelRoot = modelRoot;\n    }","id":86922,"modified_method":"private ModelRootWrapper(ModelRoot modelRoot) {\n      myModelRoot = modelRoot;\n      myText = myModelRoot.getPath() + \" (\" + myModelRoot.getPrefix() + \")\";\n    }","commit_id":"e84c72a0cbe326b22b9d891af532d867f28c306b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String toString() {\n      return myModelRoot.getPath() + \" (\" + myModelRoot.getPrefix() + \")\";\n    }","id":86923,"modified_method":"public String toString() {\n      return myText; \n    }","commit_id":"e84c72a0cbe326b22b9d891af532d867f28c306b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BaseDialog.Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOk() {\n\n    if (myModelName.getText().length() == 0) {\n      setErrorText(\"Empty model's name isn't allowed\");\n      return;\n    }\n\n    SModelUID modelUID = new SModelUID(myModelName.getText(), myModelStereotype.getSelectedItem().toString());\n    if (SModelRepository.getInstance().getModelDescriptor(modelUID) != null) {\n      setErrorText(\"Model with an uid \" + myModelName.getText() + \" is already exists\");\n      return;\n    }\n\n    ModelRootWrapper wrapper = (ModelRootWrapper) myModelRoots.getSelectedItem();\n    if (!myModelName.getText().startsWith(wrapper.myModelRoot.getPrefix())) {\n      setErrorText(\"Model name should have a prefix \" + wrapper.myModelRoot.getPrefix());\n      return;\n    }\n\n    SModelDescriptor model = myContext.getModule().createModel(modelUID, wrapper.myModelRoot);\n\n    new ModelPropertiesDialog(model, myContext).showDialog();\n\n    dispose();\n  }","id":86924,"modified_method":"@BaseDialog.Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOk() {\n    SModelDescriptor model = ModelAccess.instance().runWriteActionInCommand(new Computable<SModelDescriptor>() {\n      public SModelDescriptor compute() {\n        if (myModelName.getText().length() == 0) {\n          setErrorText(\"Empty model's name isn't allowed\");\n          return null;\n        }\n\n        SModelUID modelUID = new SModelUID(myModelName.getText(), myModelStereotype.getSelectedItem().toString());\n        if (SModelRepository.getInstance().getModelDescriptor(modelUID) != null) {\n          setErrorText(\"Model with an uid \" + myModelName.getText() + \" is already exists\");\n          return null;\n        }\n\n        ModelRootWrapper wrapper = (ModelRootWrapper) myModelRoots.getSelectedItem();\n        if (!myModelName.getText().startsWith(wrapper.myModelRoot.getPrefix())) {\n          setErrorText(\"Model name should have a prefix \" + wrapper.myModelRoot.getPrefix());\n          return null;\n        }\n\n        return myContext.getModule().createModel(modelUID, wrapper.myModelRoot);\n      }\n    });\n\n    if (model == null) {\n      return;\n    }\n\n    new ModelPropertiesDialog(model, myContext).showDialog();\n\n    dispose();\n  }","commit_id":"e84c72a0cbe326b22b9d891af532d867f28c306b","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * Constructs a new connection.\n\t */\n\tCmsConnection(Connection originalConnection, CmsPool pool) {\n          this(originalConnection, pool, new Hashtable());\n\t}","id":86925,"modified_method":"/**\n\t * Constructs a new connection.\n\t */\n\tCmsConnection(Connection originalConnection, CmsPool pool) {\n          this(originalConnection, pool, new Hashtable(), System.currentTimeMillis());\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Constructs a new connection.\n\t */\n\tCmsConnection(Connection originalConnection, CmsPool pool, Hashtable statementPool) {\n          m_originalConnection = originalConnection;\n          m_pool = pool;\n          // create an empty statement\n          m_lastUsed = System.currentTimeMillis();\n          m_statementPool = statementPool;\n          m_isClosed = false;\n\t}","id":86926,"modified_method":"/**\n\t * Reconstructs a connection.\n\t */\n\tCmsConnection(Connection originalConnection, CmsPool pool, Hashtable statementPool, long establishTime) {\n          m_originalConnection = originalConnection;\n          m_pool = pool;\n          // create an empty statement\n          m_lastUsed = System.currentTimeMillis();\n          m_establishTime = establishTime;\n          m_statementPool = statementPool;\n          m_isClosed = false;\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * This method don't closes this connection. It puts it back to\n\t * the pool. Please use it at the end of your database activity.\n\t */\n\tpublic void close() throws SQLException {\n\t\tcheckIsClosed();\n\t\t// set is closed to true\n\t\tm_isClosed = true;\n\n\t\t// put the connection back to the pool\n\t\tm_pool.putConnection(new CmsConnection(m_originalConnection, m_pool, m_statementPool));\n\t}","id":86927,"modified_method":"/**\n\t * This method don't closes this connection. It puts it back to\n\t * the pool. Please use it at the end of your database activity.\n\t */\n\tpublic void close() throws SQLException {\n\t\tcheckIsClosed();\n\t\t// set is closed to true\n\t\tm_isClosed = true;\n\n\t\t// put the connection back to the pool\n\t\tm_pool.putConnection(new CmsConnection(m_originalConnection, m_pool, m_statementPool, m_establishTime));\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Creates a new pool with the name poolName. Reads informations\n\t * for the pool from configurations.\n\t * @param poolName - the name of the pool to create.\n\t * @return Pool - the created pool.\n\t * @exception SQLException - is a SQL-Error occurs.\n\t */\n\tprivate CmsPool createPool(String poolName) throws SQLException {\n\t\tString driver = c_config.getString(\"pool.\" + poolName + \".driver\");\n\t\tString url = c_config.getString(\"pool.\" + poolName + \".url\");\n\t\tString user = c_config.getString(\"pool.\" + poolName + \".user\");\n\t\tString password = c_config.getString(\"pool.\" + poolName + \".password\");\n\t\tint minConn = c_config.getInteger(\"pool.\" + poolName + \".minConn\", 1);\n\t\tint maxConn = c_config.getInteger(\"pool.\" + poolName + \".maxConn\", 1);\n\t\tint increaseRate = c_config.getInteger(\"pool.\" + poolName + \".increaseRate\", 1);\n\t\tint timeout = c_config.getInteger(\"pool.\" + poolName + \".timeout\", 120);\n\t\t\n\t\t// create the pool and return it\n\t\treturn new CmsPool(poolName, driver, url, user, password, minConn, \n\t\t\t\t\t\tmaxConn, increaseRate, timeout);\n\t}","id":86928,"modified_method":"/**\n\t * Creates a new pool with the name poolName. Reads informations\n\t * for the pool from configurations.\n\t * @param poolName - the name of the pool to create.\n\t * @return Pool - the created pool.\n\t * @exception SQLException - is a SQL-Error occurs.\n\t */\n\tprivate CmsPool createPool(String poolName) throws SQLException {\n\t\tString driver = c_config.getString(\"pool.\" + poolName + \".driver\");\n\t\tString url = c_config.getString(\"pool.\" + poolName + \".url\");\n\t\tString user = c_config.getString(\"pool.\" + poolName + \".user\");\n\t\tString password = c_config.getString(\"pool.\" + poolName + \".password\");\n\t\tint minConn = c_config.getInteger(\"pool.\" + poolName + \".minConn\", 1);\n\t\tint maxConn = c_config.getInteger(\"pool.\" + poolName + \".maxConn\", 1);\n\t\tint increaseRate = c_config.getInteger(\"pool.\" + poolName + \".increaseRate\", 1);\n\t\tint timeout = c_config.getInteger(\"pool.\" + poolName + \".timeout\", 120);\n                int maxage = c_config.getInteger(\"pool.\" + poolName + \".maxage\", 360);\n\n\t\t// create the pool and return it\n\t\treturn new CmsPool(poolName, driver, url, user, password, minConn,\n\t\t\t\t\t\tmaxConn, increaseRate, timeout, maxage);\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Creates a new id for the given table.\n\t * @param pooName - the name of the pool.\n\t * @param tableName - the name of the table to create the id.\n\t * @param key - the key to store the generated values.\n\t * @return the next id for this resource.\n\t */\n\tprivate static void generateNextId(String poolName, String tableName, String key) \n\t\tthrows CmsException {\n\t\tConnection con = null;\n\t\tint id;\n\t\tint borderId;\n\t\ttry\t{\t\t\t\n\t\t\tcon = DriverManager.getConnection(poolName);\n\t\t\t// repeat this operation, until the nextId is valid and can be saved\n\t\t\t// (this is for clustering of several OpenCms)\n\t\t\tdo {\n\t\t\t\tid = readId(con, tableName);\n\t\t\t\tif( id == I_CmsConstants.C_UNKNOWN_ID ) {\n\t\t\t\t\t// there was no entry - set it to 0\n\t\t\t\t\tid = 0;\n\t\t\t\t\tcreateId(con, tableName, id);\n\t\t\t\t}\n\t\t\t\tborderId = id + C_GROW_VALUE;\n\t\t\t\t// save the next id for future requests\n\t\t\t} while(!writeId(con, tableName, id, borderId));\n\t\t\t// store the generated values in the cache\n\t\t\tc_currentId.put(key, new Integer(id));\n\t\t\tc_borderId.put(key, new Integer(borderId));\t\t\t\n\t\t} catch (SQLException e){\n\t\t\tthrow new CmsException(\"[\"+CmsIdGenerator.class.getName()+\"]\"+e.getMessage(),CmsException.C_SQL_ERROR, e);\t\t\t\n\t\t}finally {\n\t\t\t // close all db-resources\n\t\t\t if(con != null) {\n\t\t\t\t try {\n\t\t\t\t\t con.close();\n\t\t\t\t } catch(SQLException exc) {\n\t\t\t\t\t // nothing to do here\n\t\t\t\t }\n\t\t\t }\n\t\t }\t\n\t}","id":86929,"modified_method":"/**\n\t * Creates a new id for the given table.\n\t * @param pooName - the name of the pool.\n\t * @param tableName - the name of the table to create the id.\n\t * @param key - the key to store the generated values.\n\t * @return the next id for this resource.\n\t */\n\tprivate static void generateNextId(String poolName, String tableName, String key)\n\t\tthrows CmsException {\n\t\tConnection con = null;\n\t\tint id;\n\t\tint borderId;\n\t\ttry\t{\n\t\t\tcon = DriverManager.getConnection(poolName);\n\t\t\t// repeat this operation, until the nextId is valid and can be saved\n\t\t\t// (this is for clustering of several OpenCms)\n\t\t\tdo {\n\t\t\t\tid = readId(con, tableName);\n\t\t\t\tif( id == I_CmsConstants.C_UNKNOWN_ID ) {\n\t\t\t\t\t// there was no entry - set it to 0\n\t\t\t\t\tid = 0;\n\t\t\t\t\tcreateId(con, tableName, id);\n\t\t\t\t}\n\t\t\t\tborderId = id + C_GROW_VALUE;\n\t\t\t\t// save the next id for future requests\n\t\t\t} while(!writeId(con, tableName, id, borderId));\n\t\t\t// store the generated values in the cache\n\t\t\tc_currentId.put(key, new Integer(id));\n\t\t\tc_borderId.put(key, new Integer(borderId - 1));\n\t\t} catch (SQLException e){\n\t\t\tthrow new CmsException(\"[\"+CmsIdGenerator.class.getName()+\"]\"+e.getMessage(),CmsException.C_SQL_ERROR, e);\n\t\t}finally {\n\t\t\t // close all db-resources\n\t\t\t if(con != null) {\n\t\t\t\t try {\n\t\t\t\t\t con.close();\n\t\t\t\t } catch(SQLException exc) {\n\t\t\t\t\t // nothing to do here\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Creates the needed connections, if possible.\n\t * @param amount - the amount of connections to create.\n\t * @exception SQLException if a database-access error occurs. \n\t */\n\tprivate synchronized void createConnections(int amount) \n\t\tthrows SQLException {\n\t\tfor(int i = 0; (i < amount) && (m_connectionAmount < m_maxConn); i++) {\n\t\t\t// create another connection\n\t\t\tm_availableConnections.push(createConnection());\n\t\t\tm_connectionAmount++;\n\t\t}\n\t}","id":86930,"modified_method":"/**\n\t * Creates the needed connections, if possible.\n\t * @param amount - the amount of connections to create.\n\t * @exception SQLException if a database-access error occurs.\n\t */\n\tprivate void createConnections(int amount)\n\t\tthrows SQLException {\n                synchronized(m_availableConnections) {\n                System.out.println(\"createConnections \" + amount + \" \" + m_connectionAmount + \" \" + m_maxConn);\n                  for(int i = 0; (i < amount) && (m_connectionAmount < m_maxConn); i++) {\n                          // create another connection\n                          m_availableConnections.push(createConnection());\n                          m_connectionAmount++;\n  \t\t  }\n                  m_availableConnections.notifyAll();\n                }\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Puts a connection back to the pool.\n\t */\n\tpublic void putConnection(CmsConnection con) {\n\t\tboolean alive = false;\n\t\ttry {\n\t\t\t// check, if the connection is available\n\t\t\tif(!con.isClosed()) {\n\t\t\t\tcon.clearWarnings();\n\t\t\t\t// this connection is alive\n\t\t\t\talive = true;\n\t\t\t}\n\t\t} catch(SQLException exc) {\n\t\t\t// ignore the exception, alive is false\n\t\t}\n\t\t\n\t\tif(alive) {\n\t\t\t// put the connection to the available connections\n\t\t\tm_availableConnections.push(con);\n\t\t} else {\n\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": connection was broken\");\n\t\t\t}\n\t\t\t// no, the connection is dead -> trhow it away and close it\n\t\t\tcon.closeOriginalConnection();\n\t\t\tm_connectionAmount --;\n\n\t\t\t// create a new one\n\t\t\ttry {\n\t\t\t\tcreateConnections(1);\n\t\t\t} catch(SQLException exc) {\n\t\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": unable to create new connection for broken one\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// wake up eventually waiting threads\t\t\n\t\tsynchronized(m_availableConnections) {\n\t\t\tm_availableConnections.notifyAll();\n\t\t}\n\t}","id":86931,"modified_method":"/**\n\t * Puts a connection back to the pool.\n\t */\n\tpublic void putConnection(CmsConnection con) {\n          synchronized(m_availableConnections) {\n\n\t\tboolean alive = false;\n                System.out.println(\"put back\");\n\t\ttry {\n\t\t\t// check, if the connection is available\n\t\t\tif(!con.isClosed()) {\n\t\t\t\tcon.clearWarnings();\n\t\t\t\t// this connection is alive\n\t\t\t\talive = true;\n\t\t\t}\n\t\t} catch(SQLException exc) {\n\t\t\t// ignore the exception, alive is false\n\t\t}\n\n/*                if((con.getEstablishedTime() + (m_maxage * 60 * 1000)) < System.currentTimeMillis()) {\n                  // this connection is to old. destroy it and create a new-one!\n                  alive = false;\n                  if(A_OpenCms.isLogging()) {\n                    A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": connection is to old, destroy it.\");\n                  }\n                } */\n\n\t\tif(alive) {\n\t\t\t// put the connection to the available connections\n\t\t\tm_availableConnections.push(con);\n\t\t} else {\n\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": connection was broken\");\n\t\t\t}\n\t\t\t// no, the connection is dead -> trhow it away and close it\n                        con.closeOriginalConnection();\n                        m_connectionAmount --;\n\n\t\t\t// create a new one\n\t\t\ttry {\n\t\t\t\tcreateConnections(1);\n\t\t\t} catch(SQLException exc) {\n\t\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": unable to create new connection for broken one\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// wake up eventually waiting threads\n                  m_availableConnections.notifyAll();\n          }\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Creates a new Pool.\n\t * @param poolname - the name of this pool.\n\t * @param driver - the classname of the driver.\n\t * @param url - the url to connect to the database.\n\t * @param user - the user to access the db.\n\t * @param password - the password to connect to the db.\n\t * @param minConn - the minimum amount Connections maintained in the pool.\n\t * @param maxConn - the maximum amount Connections maintained in the pool.\n\t * @param increaseRate - the rate to increase the the amount of \n\t * connections in the pool.\n\t * @param timeout - the timout after a unused connection has to be closed.\n\t * @exception SQLException - if a SQL-Error occurs.\n\t */\n\tpublic CmsPool(String poolname, String driver, String url, String user, \n\t\t\t\tString password, int minConn, int maxConn, int increasRate, int timeout) \n\t\tthrows SQLException {\n\t\t// store the parameters\n\t\tm_poolname = poolname;\n\t\tm_driver = driver;\n\t\tm_url = url;\n\t\tm_user = user;\n\t\tm_password = password;\n\t\tm_minConn = minConn;\n\t\tm_maxConn = maxConn;\n\t\tm_increaseRate = increasRate;\n\t\tm_timeout = timeout;\n\t\t\n\t\t// register the driver to the driver-manager\n\t\ttry {\n\t\t\tClass.forName(driver);\n\t\t} catch(ClassNotFoundException exc) {\n\t\t\tthrow new SQLException(\"Driver not found: \" + exc.getMessage());\n\t\t}\n\t\t\n\t\t// create the initial amount of connections\n\t\tif(A_OpenCms.isLogging()) {\n\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": created\");\n\t\t}\n\t\tcreateConnections(m_minConn);\n\t}","id":86932,"modified_method":"/**\n\t * Creates a new Pool.\n\t * @param poolname - the name of this pool.\n\t * @param driver - the classname of the driver.\n\t * @param url - the url to connect to the database.\n\t * @param user - the user to access the db.\n\t * @param password - the password to connect to the db.\n\t * @param minConn - the minimum amount Connections maintained in the pool.\n\t * @param maxConn - the maximum amount Connections maintained in the pool.\n\t * @param increaseRate - the rate to increase the the amount of\n\t * connections in the pool.\n\t * @param timeout - the timout after a unused connection has to be closed.\n\t * @exception SQLException - if a SQL-Error occurs.\n\t */\n\tpublic CmsPool(String poolname, String driver, String url, String user,\n\t\t\t\tString password, int minConn, int maxConn, int increasRate, int timeout, int maxage)\n\t\tthrows SQLException {\n\t\t// store the parameters\n\t\tm_poolname = poolname;\n\t\tm_driver = driver;\n\t\tm_url = url;\n\t\tm_user = user;\n\t\tm_password = password;\n\t\tm_minConn = minConn;\n\t\tm_maxConn = maxConn;\n\t\tm_increaseRate = increasRate;\n\t\tm_timeout = timeout;\n                m_maxage = maxage;\n\n\t\t// register the driver to the driver-manager\n\t\ttry {\n\t\t\tClass.forName(driver);\n\t\t} catch(ClassNotFoundException exc) {\n\t\t\tthrow new SQLException(\"Driver not found: \" + exc.getMessage());\n\t\t}\n\n\t\t// create the initial amount of connections\n\t\tif(A_OpenCms.isLogging()) {\n\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": created\");\n\t\t}\n\t\tcreateConnections(m_minConn);\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Gets a connection.\n\t * @exception SQLException if a database-access error occurs. \n\t */\n\tpublic Connection getConnection() \n\t\tthrows SQLException {\n\t\ttry {\n\t\t\treturn (Connection) m_availableConnections.pop();\n\t\t} catch(EmptyStackException exc) {\n\t\t\tif(m_connectionAmount < m_maxConn) {\n\t\t\t\t// create new connections\n\t\t\t\tcreateConnections(m_increaseRate);\n\t\t\t} else {\n\t\t\t\t// no connections available - have to wait\n\t\t\t\tsynchronized(m_availableConnections) {\n\t\t\t\t\t// wait until there are available connections\n\t\t\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\t\t\tA_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": no connections available - have to wait\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tm_availableConnections.wait();\n\t\t\t\t\t} catch(InterruptedException iExc) {\n\t\t\t\t\t\t// ignore the exception\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// try again to get a connection\n\t\treturn getConnection();\n\t}","id":86933,"modified_method":"/**\n\t * Gets a connection.\n\t * @exception SQLException if a database-access error occurs.\n\t */\n\tpublic Connection getConnection()\n\t\tthrows SQLException {\n\t\tsynchronized(m_availableConnections) {\n                  try {\n                          return (Connection) m_availableConnections.pop();\n                  } catch(EmptyStackException exc) {\n                          if(m_connectionAmount < m_maxConn) {\n                                  // create new connections\n                                  createConnections(m_increaseRate);\n                          } else {\n                                  // no connections available - have to wait\n                                  // wait until there are available connections\n                                  if(A_OpenCms.isLogging()) {\n                                          A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_POOL, \"[\"+ getClass().getName() +\"] \" + m_poolname + \": no connections available - have to wait\");\n                                  }\n                                  try {\n                                          m_availableConnections.wait();\n                                  } catch(InterruptedException iExc) {\n                                          // ignore the exception\n                                  }\n                          }\n                  }\n                  // try again to get a connection\n                  return getConnection();\n                }\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Try to make a database connection to the given database. \n\t * @return a Connection to the database\n\t * @exception SQLException if a database-access error occurs. \n\t */\n\tpublic Connection connect() \n\t\tthrows SQLException {\n\t\treturn getConnection();\n\t}","id":86934,"modified_method":"/**\n\t * Try to make a database connection to the given database.\n\t * @return a Connection to the database\n\t * @exception SQLException if a database-access error occurs.\n\t */\n\tpublic Connection connect()\n\t\tthrows SQLException {\n                System.out.println(\"connect \" + m_connectionAmount + \" \" + m_availableConnections.size());\n\t\treturn getConnection();\n\t}","commit_id":"349d40b4f761a08df75b53eacd2354da03cd4cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void realRun() throws IOException {\n\t\tOutputStream os = new BufferedOutputStream(handler.sock.getOutputStream(), 4096);\n\t\twhile(true) {\n\t\t\tboolean closed;\n\t\t\tFCPMessage msg = null;\n\t\t\twhile(true) {\n\t\t\t\tclosed = handler.isClosed();\n\t\t\t\tsynchronized(outQueue) {\n\t\t\t\t\tif(outQueue.isEmpty()) {\n\t\t\t\t\t\tif(closed) {\n\t\t\t\t\t\t\tclosedOutputQueue = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tos.flush();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutQueue.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmsg = outQueue.removeFirst();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(msg == null) {\n\t\t\t\tif(closed) {\n\t\t\t\t\tos.flush();\n\t\t\t\t\tos.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmsg.send(os);\n\t\t\t}\n\t\t}\n\t}","id":86935,"modified_method":"private void realRun() throws IOException {\n\t\tOutputStream os = new BufferedOutputStream(handler.sock.getOutputStream(), 4096);\n\t\twhile(true) {\n\t\t\tboolean closed;\n\t\t\tFCPMessage msg = null;\n\t\t\twhile(true) {\n\t\t\t\tclosed = handler.isClosed();\n\t\t\t\tsynchronized(outQueue) {\n\t\t\t\t\tif(outQueue.isEmpty()) {\n\t\t\t\t\t\tif(closed) {\n\t\t\t\t\t\t\tclosedOutputQueue = true;\n\t\t\t\t\t\t\toutQueue.notifyAll();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tos.flush();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toutQueue.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t// Ignore\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmsg = outQueue.removeFirst();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(msg == null) {\n\t\t\t\tif(closed) {\n\t\t\t\t\tos.flush();\n\t\t\t\t\tos.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmsg.send(os);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c4d51e6d6c7799cb30171c630a0967ea187b3c30","url":"https://github.com/freenet/fred"},{"original_method":"public void onClosed() {\n\t\tsynchronized(outQueue) {\n\t\t\toutQueue.notifyAll();\n\t\t}\n\t\t// Give a chance to the output handler to flush\n\t\t// its queue before the socket is closed\n\t\t// @see #2019 - nextgens\n\t\twhile(!outQueue.isEmpty()) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {}\n\t\t\tsynchronized(outQueue) {\n\t\t\t\tif(closedOutputQueue) return;\n\t\t\t}\n\t\t}\n\t}","id":86936,"modified_method":"public void onClosed() {\n\t\tsynchronized(outQueue) {\n\t\t\toutQueue.notifyAll();\n\t\t\t// Give a chance to the output handler to flush\n\t\t\t// its queue before the socket is closed\n\t\t\t// @see #2019 - nextgens\n\t\t\twhile(!outQueue.isEmpty()) {\n\t\t\t\tif(closedOutputQueue) return;\n\t\t\t\ttry {\n\t\t\t\t\toutQueue.wait();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"c4d51e6d6c7799cb30171c630a0967ea187b3c30","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public ClientConnection ownerConnection(Address address) throws Exception {\n        final ManagerAuthenticator authenticator = new ManagerAuthenticator();\n        final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, true);\n        ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n        try {\n            ownerConnection = future.get(5, TimeUnit.SECONDS);\n            synchronized (ownerConnectionLock) {\n                ownerConnectionLock.notifyAll();\n            }\n            return ownerConnection;\n        } catch (Exception e) {\n            future.cancel(true);\n            throw new RetryableIOException(e);\n        }\n    }","id":86937,"modified_method":"@Override\n    public ClientConnection ownerConnection(Address address) throws Exception {\n        final ManagerAuthenticator authenticator = new ManagerAuthenticator();\n        final ConnectionProcessor connectionProcessor = new ConnectionProcessor(address, authenticator, true);\n        ICompletableFuture<ClientConnection> future = executionService.submitInternal(connectionProcessor);\n        try {\n            synchronized (ownerConnectionLock) {\n                ownerConnection = future.get(5, TimeUnit.SECONDS);\n                ownerConnectionLock.notifyAll();\n                return ownerConnection;\n            }\n        } catch (Exception e) {\n            future.cancel(true);\n            throw new RetryableIOException(e);\n        }\n    }","commit_id":"05f8f23090c5244b49ec617cf318b9790613740d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void closeIfOwnerConnection(Address endpoint) {\n        final ClientConnection currentOwnerConnection = ownerConnection;\n        if (currentOwnerConnection == null || !currentOwnerConnection.live()) {\n            return;\n        }\n        if (endpoint.equals(currentOwnerConnection.getRemoteEndpoint())) {\n            try {\n                currentOwnerConnection.close();\n            } catch (Exception ignored) {\n            }\n        }\n    }","id":86938,"modified_method":"private void closeIfOwnerConnection(Address endpoint) {\n        final ClientConnection currentOwnerConnection = ownerConnection;\n        if (currentOwnerConnection == null || !currentOwnerConnection.live()) {\n            return;\n        }\n        if (endpoint.equals(currentOwnerConnection.getRemoteEndpoint())) {\n            try {\n                currentOwnerConnection.close();\n                markOwnerAddressAsClosed();\n            } catch (Exception ignored) {\n            }\n        }\n    }","commit_id":"05f8f23090c5244b49ec617cf318b9790613740d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private Address waitForOwnerConnection() throws RetryableIOException {\n        if (ownerConnection != null) {\n            return ownerConnection.getRemoteEndpoint();\n        }\n\n        synchronized (ownerConnectionLock) {\n            ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();\n            int connectionAttemptLimit = networkConfig.getConnectionAttemptLimit();\n            int connectionAttemptPeriod = networkConfig.getConnectionAttemptPeriod();\n            int waitTime = connectionAttemptLimit * connectionAttemptPeriod * 2;\n\n            while (ownerConnection == null) {\n                try {\n                    ownerConnectionLock.wait(waitTime);\n                } catch (InterruptedException e) {\n                    logger.warning(\"Wait for owner connection is timed out\");\n                    throw new RetryableIOException(e);\n                }\n            }\n            return ownerConnection.getRemoteEndpoint();\n        }\n    }","id":86939,"modified_method":"private Address waitForOwnerConnection() throws RetryableIOException {\n        final ClientConnection currentOwnerConnection = ownerConnection;\n        if (currentOwnerConnection != null) {\n            return currentOwnerConnection.getRemoteEndpoint();\n        }\n\n        synchronized (ownerConnectionLock) {\n            ClientNetworkConfig networkConfig = client.getClientConfig().getNetworkConfig();\n            int connectionAttemptLimit = networkConfig.getConnectionAttemptLimit();\n            int connectionAttemptPeriod = networkConfig.getConnectionAttemptPeriod();\n            int waitTime = connectionAttemptLimit * connectionAttemptPeriod * 2;\n\n            while (ownerConnection == null) {\n                try {\n                    ownerConnectionLock.wait(waitTime);\n                } catch (InterruptedException e) {\n                    logger.warning(\"Wait for owner connection is timed out\");\n                    throw new RetryableIOException(e);\n                }\n            }\n            return ownerConnection.getRemoteEndpoint();\n        }\n    }","commit_id":"05f8f23090c5244b49ec617cf318b9790613740d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * adds an object to the tail of this queue\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     */\n    public void add(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n        if(closed)\n            throw new QueueClosedException();\n        if(this.num_markers > 0)\n            throw new QueueClosedException(\"Queue.add(): queue has been closed. You can not add more elements. \" +\n                                           \"Waiting for removal of remaining elements.\");\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n            /*create a new linked list element*/\n            Element el=new Element(obj);\n            /*check the first element*/\n            if(head == null) {\n                /*the object added is the first element*/\n                /*set the head to be this object*/\n                head=el;\n                /*set the tail to be this object*/\n                tail=head;\n                /*set the size to be one, since the queue was empty*/\n                size=1;\n            }\n            else {\n                /*add the object to the end of the linked list*/\n                tail.next=el;\n                /*set the tail to point to the last element*/\n                tail=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","id":86940,"modified_method":"/**\n     * adds an object to the tail of this queue\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     */\n    public void add(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n           if(closed)\n              throw new QueueClosedException();\n           if(this.num_markers > 0)\n              throw new QueueClosedException(\"Queue.add(): queue has been closed. You can not add more elements. \" +\n                                             \"Waiting for removal of remaining elements.\");\n\n            /*create a new linked list element*/\n            Element el=new Element(obj);\n            /*check the first element*/\n            if(head == null) {\n                /*the object added is the first element*/\n                /*set the head to be this object*/\n                head=el;\n                /*set the tail to be this object*/\n                tail=head;\n                /*set the size to be one, since the queue was empty*/\n                size=1;\n            }\n            else {\n                /*add the object to the end of the linked list*/\n                tail.next=el;\n                /*set the tail to point to the last element*/\n                tail=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns true if the Queue has been closed\n     * however, this method will return false if the queue has been closed\n     * using the close(true) method and the last element has yet not been received.\n     * @return true if the queue has been closed\n     */\n    public boolean closed() {\n        return closed;\n    }","id":86941,"modified_method":"/**\n     * returns true if the Queue has been closed\n     * however, this method will return false if the queue has been closed\n     * using the close(true) method and the last element has yet not been received.\n     * @return true if the queue has been closed\n     */\n    public boolean closed() {\n        synchronized(mutex) {\n            return closed;\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added\n     * @return the first object on the queue\n     */\n    public Object peek() throws QueueClosedException {\n        Object retval=null;\n\n        synchronized(mutex) {\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=(head != null)? head.obj : null;\n\n            // @remove:\n            if(retval == null) {\n                // print some diagnostics\n                if(log.isErrorEnabled()) log.error(\"retval is null: head=\" + head + \", tail=\" + tail + \", size()=\" + size() +\n                                            \", num_markers=\" + num_markers + \", closed()=\" + closed());\n            }\n        }\n\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        return retval;\n    }","id":86942,"modified_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added\n     * @return the first object on the queue\n     */\n    public Object peek() throws QueueClosedException {\n        Object retval;\n\n        synchronized(mutex) {\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=(head != null)? head.obj : null;\n\n            // @remove:\n            if(retval == null) {\n                // print some diagnostics\n                if(log.isErrorEnabled()) log.error(\"retval is null: head=\" + head + \", tail=\" + tail + \", size()=\" + size() +\n                                            \", num_markers=\" + num_markers + \", closed=\" + closed);\n            }\n        }\n\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        return retval;\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * resets the queue.\n     * This operation removes all the objects in the queue and marks the queue open\n     */\n    public void reset() {\n        num_markers=0;\n        if(!closed)\n            close(false);\n\n        synchronized(mutex) {\n            size=0;\n            head=null;\n            tail=null;\n            closed=false;\n            mutex.notifyAll();\n        }\n\n//        synchronized(remove_mutex) {\n//            remove_mutex.notifyAll();\n//        }\n    }","id":86943,"modified_method":"/**\n     * resets the queue.\n     * This operation removes all the objects in the queue and marks the queue open\n     */\n    public void reset() {\n        synchronized(mutex) {\n           num_markers=0;\n           if(!closed)\n              close(false);\n            size=0;\n            head=null;\n            tail=null;\n            closed=false;\n            mutex.notifyAll();\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the first element. Returns null if no elements are available.\n     */\n    public Object getFirst() {\n        return head != null? head.obj : null;\n    }","id":86944,"modified_method":"/**\n     * Returns the first element. Returns null if no elements are available.\n     */\n    public Object getFirst() {\n        synchronized(mutex) {\n            return head != null? head.obj : null;\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns the number of objects that are currently in the queue\n     */\n    public int size() {\n        return size - num_markers;\n    }","id":86945,"modified_method":"/**\n     * returns the number of objects that are currently in the queue\n     */\n    public int size() {\n        synchronized(mutex) {\n            return size - num_markers;\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes 1 element from head or <B>blocks<\/B>\n     * until next element has been added or until queue has been closed\n     * @return the first element to be taken of the queue\n     */\n    public Object remove() throws QueueClosedException {\n        /*initialize the return value*/\n        Object retval=null;\n        /*lock the queue*/\n        synchronized(mutex) {\n            /*wait as long as the queue is empty. return when an element is present or queue is closed*/\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            /*remove the head from the queue, if we make it to this point, retval should not be null !*/\n            retval=removeInternal();\n            if(retval == null)\n                if(log.isErrorEnabled()) log.error(\"element was null, should never be the case\");\n        }\n\n        /*\n         * we ran into an Endmarker, which means that the queue was closed before\n         * through close(true)\n         */\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        /*return the object*/\n        return retval;\n    }","id":86946,"modified_method":"/**\n     * Removes 1 element from head or <B>blocks<\/B>\n     * until next element has been added or until queue has been closed\n     * @return the first element to be taken of the queue\n     */\n    public Object remove() throws QueueClosedException {\n        /*initialize the return value*/\n        Object retval;\n        /*lock the queue*/\n        synchronized(mutex) {\n            /*wait as long as the queue is empty. return when an element is present or queue is closed*/\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            /*remove the head from the queue, if we make it to this point, retval should not be null !*/\n            retval=removeInternal();\n            if(retval == null)\n                if(log.isErrorEnabled()) log.error(\"element was null, should never be the case\");\n        }\n\n        /*\n         * we ran into an Endmarker, which means that the queue was closed before\n         * through close(true)\n         */\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        /*return the object*/\n        return retval;\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added or the operation times out\n     * @param timeout how long in milli seconds will this operation wait for an object to be added to the queue\n     *        before it times out\n     * @return the first object on the queue\n     */\n\n    public Object peek(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval=null;\n\n        synchronized(mutex) {\n            if(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=head != null? head.obj : null;\n\n            if(retval == null) throw new TimeoutException();\n\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            return retval;\n        }\n    }","id":86947,"modified_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added or the operation times out\n     * @param timeout how long in milli seconds will this operation wait for an object to be added to the queue\n     *        before it times out\n     * @return the first object on the queue\n     */\n    public Object peek(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval;\n\n        synchronized(mutex) {\n            if(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=head != null? head.obj : null;\n\n            if(retval == null) throw new TimeoutException();\n\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            return retval;\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"void decrementSize() {\n        size--;\n        if(size < 0)\n            size=0;\n    }","id":86948,"modified_method":"/** Doesn't need to be synchronized; is always called from synchronized methods */\n    void decrementSize() {\n        size--;\n        if(size < 0)\n            size=0;\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a new object to the head of the queue\n     * basically (obj.equals(queue.remove(queue.add(obj)))) returns true\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     *\n     */\n    public void addAtHead(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n        if(closed)\n            throw new QueueClosedException();\n        if(this.num_markers > 0)\n            throw new QueueClosedException(\"Queue.addAtHead(): queue has been closed. You can not add more elements. \" +\n                                           \"Waiting for removal of remaining elements.\");\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n            Element el=new Element(obj);\n            /*check the head element in the list*/\n            if(head == null) {\n                /*this is the first object, we could have done add(obj) here*/\n                head=el;\n                tail=head;\n                size=1;\n            }\n            else {\n                /*set the head element to be the child of this one*/\n                el.next=head;\n                /*set the head to point to the recently added object*/\n                head=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","id":86949,"modified_method":"/**\n     * Adds a new object to the head of the queue\n     * basically (obj.equals(queue.remove(queue.add(obj)))) returns true\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     *\n     */\n    public void addAtHead(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n           if(closed)\n              throw new QueueClosedException();\n           if(this.num_markers > 0)\n              throw new QueueClosedException(\"Queue.addAtHead(): queue has been closed. You can not add more elements. \" +\n                                             \"Waiting for removal of remaining elements.\");\n\n            Element el=new Element(obj);\n            /*check the head element in the list*/\n            if(head == null) {\n                /*this is the first object, we could have done add(obj) here*/\n                head=el;\n                tail=head;\n                size=1;\n            }\n            else {\n                /*set the head element to be the child of this one*/\n                el.next=head;\n                /*set the head to point to the recently added object*/\n                head=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes 1 element from the head.\n     * If the queue is empty the operation will wait for timeout ms.\n     * if no object is added during the timeout time, a Timout exception is thrown\n     * @param timeout - the number of milli seconds this operation will wait before it times out\n     * @return the first object in the queue\n     */\n    public Object remove(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval=null;\n\n        /*lock the queue*/\n        synchronized(mutex) {\n\n            /*check to see if the queue is closed*/\n            if(closed)\n                throw new QueueClosedException();\n\n            /*if the queue size is zero, we want to wait until a new object is added*/\n            if(size == 0) {\n                try {\n                    /*release the add_mutex lock and wait no more than timeout ms*/\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            /*we either timed out, or got notified by the add_mutex lock object*/\n\n            /*get the next value*/\n            retval=removeInternal();\n            /*null result means we timed out*/\n            if(retval == null) throw new TimeoutException();\n\n            /*if we reached an end marker we are going to close the queue*/\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            /*at this point we actually did receive a value from the queue, return it*/\n            return retval;\n        }\n    }","id":86950,"modified_method":"/**\n     * Removes 1 element from the head.\n     * If the queue is empty the operation will wait for timeout ms.\n     * if no object is added during the timeout time, a Timout exception is thrown\n     * @param timeout - the number of milli seconds this operation will wait before it times out\n     * @return the first object in the queue\n     */\n    public Object remove(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval;\n\n        synchronized(mutex) {\n            if(closed)\n                throw new QueueClosedException();\n\n            /*if the queue size is zero, we want to wait until a new object is added*/\n            if(size == 0) {\n                try {\n                    /*release the mutex lock and wait no more than timeout ms*/\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            /*we either timed out, or got notified by the mutex lock object*/\n\n            /*get the next value*/\n            retval=removeInternal();\n            /*null result means we timed out*/\n            if(retval == null) throw new TimeoutException();\n\n            /*if we reached an end marker we are going to close the queue*/\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            /*at this point we actually did receive a value from the queue, return it*/\n            return retval;\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the last element. Returns null if no elements are available.\n     */\n    public Object getLast() {\n        return tail != null? tail.obj : null;\n    }","id":86951,"modified_method":"/**\n     * Returns the last element. Returns null if no elements are available.\n     */\n    public Object getLast() {\n        synchronized(mutex) {\n            return tail != null? tail.obj : null;\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Marks the queues as closed. When an <code>add<\/code> or <code>remove<\/code> operation is\n     attempted on a closed queue, an exception is thrown.\n     @param flush_entries When true, a end-of-entries marker is added to the end of the queue.\n     Entries may be added and removed, but when the end-of-entries marker\n     is encountered, the queue is marked as closed. This allows to flush\n     pending messages before closing the queue.\n     */\n    public void close(boolean flush_entries) {\n        if(flush_entries) {\n            try {\n                add(endMarker); // add an end-of-entries marker to the end of the queue\n                num_markers++;\n            }\n            catch(QueueClosedException closed_ex) {\n            }\n            return;\n        }\n\n        synchronized(mutex) {\n            closed=true;\n            mutex.notifyAll();\n        }\n\n//        synchronized(remove_mutex) {\n//            remove_mutex.notifyAll();\n//        }\n    }","id":86952,"modified_method":"/**\n     Marks the queues as closed. When an <code>add<\/code> or <code>remove<\/code> operation is\n     attempted on a closed queue, an exception is thrown.\n     @param flush_entries When true, a end-of-entries marker is added to the end of the queue.\n     Entries may be added and removed, but when the end-of-entries marker\n     is encountered, the queue is marked as closed. This allows to flush\n     pending messages before closing the queue.\n     */\n    public void close(boolean flush_entries) {\n        synchronized(mutex) {\n            if(flush_entries) {\n                try {\n                    add(endMarker); // add an end-of-entries marker to the end of the queue\n                    num_markers++;\n                }\n                catch(QueueClosedException closed_ex) {\n                }\n                return;\n            }\n            closed=true;\n            mutex.notifyAll();\n        }\n    }","commit_id":"947a15f2521f9acfa5269d292d1dfe939ac12531","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleCHKDataFound(Message msg, final boolean wasFork, PeerNode next) {\n    \t// Found data\n    \t\n    \t// First get headers\n    \t\n    \theaders = ((ShortBuffer)msg.getObject(DMT.BLOCK_HEADERS)).getData();\n    \t\n    \t// FIXME: Validate headers\n    \t\n    \tnode.addTransferringSender((NodeCHK)key, this);\n    \t\n    \tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n    \t\n    \tsynchronized(this) {\n    \t\tnotifyAll();\n    \t}\n    \tfireCHKTransferBegins();\n    \t\n    \tfinal long tStart = System.currentTimeMillis();\n    \tfinal BlockReceiver br = new BlockReceiver(node.usm, next, uid, prb, this, node.getTicker(), true, realTimeFlag, myTimeoutHandler);\n    \t\n    \tif(logMINOR) Logger.minor(this, \"Receiving data\");\n    \tfinal PeerNode from = next;\n    \tsynchronized(this) {\n    \t\ttransferringFrom = next;\n    \t}\n    \tnode.getTicker().queueTimedJob(new Runnable() {\n    \t\t\n    \t\tpublic void run() {\n    \t\t\tsynchronized(RequestSender.this) {\n    \t\t\t\tif(transferringFrom != from) return;\n    \t\t\t}\n    \t\t\tmakeTurtle();\n    \t\t}\n    \t\t\n    \t}, 60*1000);\n    \tfinal PeerNode sentTo = next;\n\t\t\treceivingAsync = true;\n    \tbr.receive(new BlockReceiverCompletion() {\n    \t\t\n    \t\tpublic void blockReceived(byte[] data) {\n    \t\t\ttry {\n    \t\t\t\tlong tEnd = System.currentTimeMillis();\n    \t\t\t\ttransferTime = tEnd - tStart;\n    \t\t\t\tboolean turtle;\n    \t\t\t\tboolean turtleBackedOff;\n    \t\t\t\tsynchronized(RequestSender.this) {\n    \t\t\t\t\tturtle = turtleMode;\n    \t\t\t\t\tturtleBackedOff = sentBackoffTurtle;\n    \t\t\t\t\tsentBackoffTurtle = true;\n    \t\t\t\t\ttransferringFrom = null;\n    \t\t\t\t}\n    \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n    \t\t\t\tif(!turtle)\n    \t\t\t\t\tsentTo.transferSuccess();\n    \t\t\t\telse {\n    \t\t\t\t\tLogger.normal(this, \"TURTLE SUCCEEDED: \"+key+\" for \"+RequestSender.this+\" in \"+TimeUtil.formatTime(transferTime, 2, true)+\" from \"+sentTo);\n    \t\t\t\t\tif(!turtleBackedOff)\n    \t\t\t\t\t\tsentTo.transferFailed(\"TurtledTransfer\");\n    \t\t\t\t\tnode.nodeStats.turtleSucceeded();\n    \t\t\t\t}\n    \t\t\t\tsentTo.successNotOverload();\n    \t\t\t\tif(turtle) {\n    \t\t\t\t\tsentTo.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t\tnode.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t}\n    \t\t\t\tnode.nodeStats.successfulBlockReceive(realTimeFlag, source == null);\n    \t\t\t\tif(logMINOR) Logger.minor(this, \"Received data\");\n    \t\t\t\t// Received data\n    \t\t\t\ttry {\n    \t\t\t\t\tverifyAndCommit(data);\n    \t\t\t\t} catch (KeyVerifyException e1) {\n    \t\t\t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n    \t\t\t\t\tif(!wasFork)\n    \t\t\t\t\t\tfinish(VERIFY_FAILURE, sentTo, false);\n    \t\t\t\t\telse\n    \t\t\t\t\t\torigTag.removeRoutingTo(sentTo);\n    \t\t\t\t\tnode.failureTable.onFinalFailure(key, sentTo, htl, origHTL, FailureTable.REJECT_TIME, source);\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t\tfinish(SUCCESS, sentTo, false);\n    \t\t\t} catch (Throwable t) {\n        \t\t\tLogger.error(this, \"Failed on \"+this, t);\n        \t\t\tif(!wasFork)\n        \t\t\t\tfinish(INTERNAL_ERROR, sentTo, true);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tpublic void blockReceiveFailed(\n    \t\t\t\tRetrievalException e) {\n    \t\t\ttry {\n    \t\t\t\tboolean turtle;\n    \t\t\t\tsynchronized(RequestSender.this) {\n    \t\t\t\t\tturtle = turtleMode;\n    \t\t\t\t\ttransferringFrom = null;\n    \t\t\t\t}\n    \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n    \t\t\t\tif(turtle) {\n    \t\t\t\t\tif(e.getReason() != RetrievalException.GONE_TO_TURTLE_MODE) {\n    \t\t\t\t\t\tLogger.normal(this, \"TURTLE FAILED: \"+key+\" for \"+this+\" : \"+e);\n    \t\t\t\t\t\tnode.nodeStats.turtleFailed();\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Upstream turtled for \"+this+\" from \"+sentTo);\n    \t\t\t\t\t}\n    \t\t\t\t\tsentTo.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t\tnode.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t}\n    \t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n    \t\t\t\t\tLogger.normal(this, \"Transfer failed (disconnect): \"+e, e);\n    \t\t\t\telse\n    \t\t\t\t\t// A certain number of these are normal, it's better to track them through statistics than call attention to them in the logs.\n    \t\t\t\t\tLogger.normal(this, \"Transfer failed (\"+e.getReason()+\"/\"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+sentTo, e);\n    \t\t\t\tif(RequestSender.this.source == null)\n    \t\t\t\t\tLogger.normal(this, \"Local transfer failed: \"+e.getReason()+\" : \"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+sentTo, e);\n    \t\t\t\t// We do an ordinary backoff in all cases.\n    \t\t\t\t// This includes the case where we decide not to turtle the request. This is reasonable as if it had completely quickly we wouldn't have needed to make that choice.\n    \t\t\t\tsentTo.localRejectedOverload(\"TransferFailedRequest\"+e.getReason());\n    \t\t\t\tif(!wasFork)\n    \t\t\t\t\tfinish(TRANSFER_FAILED, sentTo, false);\n    \t\t\t\tnode.failureTable.onFinalFailure(key, sentTo, htl, origHTL, FailureTable.REJECT_TIME, source);\n    \t\t\t\tint reason = e.getReason();\n    \t\t\t\tboolean timeout = (!br.senderAborted()) &&\n    \t\t\t\t(reason == RetrievalException.SENDER_DIED || reason == RetrievalException.RECEIVER_DIED || reason == RetrievalException.TIMED_OUT\n    \t\t\t\t\t\t|| reason == RetrievalException.UNABLE_TO_SEND_BLOCK_WITHIN_TIMEOUT);\n    \t\t\t\t// But we only do a transfer backoff (which is separate, and starts at a higher threshold) if we timed out i.e. not if upstream turtled.\n    \t\t\t\tif(timeout) {\n    \t\t\t\t\t// Looks like a timeout. Backoff, even if it's a turtle.\n    \t\t\t\t\tif(logMINOR) Logger.minor(this, \"Timeout transferring data : \"+e, e);\n    \t\t\t\t\tsentTo.transferFailed(e.getErrString());\n    \t\t\t\t} else {\n    \t\t\t\t\t// Quick failure (in that we didn't have to timeout). Don't backoff.\n    \t\t\t\t\t// Treat as a DNF.\n    \t\t\t\t\t// If it was turtled, and then failed, still treat it as a DNF.\n    \t\t\t\t\tnode.failureTable.onFinalFailure(key, sentTo, htl, origHTL, FailureTable.REJECT_TIME, source);\n    \t\t\t\t}\n    \t\t\t\tnode.nodeStats.failedBlockReceive(true, timeout, reason == RetrievalException.GONE_TO_TURTLE_MODE, realTimeFlag, source == null);\n    \t\t\t} catch (Throwable t) {\n        \t\t\tLogger.error(this, \"Failed on \"+this, t);\n        \t\t\tif(!wasFork)\n        \t\t\t\tfinish(INTERNAL_ERROR, sentTo, true);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t});\n\t}","id":86953,"modified_method":"private void handleCHKDataFound(Message msg, final boolean wasFork, final PeerNode next) {\n    \t// Found data\n    \t\n    \t// First get headers\n    \t\n    \tfinal byte[] headers = ((ShortBuffer)msg.getObject(DMT.BLOCK_HEADERS)).getData();\n    \t\n    \t// FIXME: Validate headers\n    \t\n    \tif(!wasFork)\n    \t\tnode.addTransferringSender((NodeCHK)key, this);\n    \t\n    \tfinal PartiallyReceivedBlock prb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n    \t\n    \tboolean failNow = false;\n    \t\n    \tsynchronized(this) {\n    \t\tif(!wasFork)\n    \t\t\tthis.headers = headers;\n    \t\tif(!wasFork)\n    \t\t\tthis.prb = prb;\n    \t\tif(wasFork && (this.status == SUCCESS || this.prb != null && transferringFrom != null))\n    \t\t\tfailNow = true;\n    \t\tnotifyAll();\n    \t}\n    \tfireCHKTransferBegins();\n    \t\n    \tfinal long tStart = System.currentTimeMillis();\n    \tfinal BlockReceiver br = new BlockReceiver(node.usm, next, uid, prb, this, node.getTicker(), true, realTimeFlag, myTimeoutHandler);\n    \t\n    \tif(failNow) {\n    \t\tif(logMINOR) Logger.minor(this, \"Terminating forked transfer on \"+this+\" from \"+next);\n    \t\tprb.abort(RetrievalException.CANCELLED_BY_RECEIVER, \"Cancelling fork\");\n    \t\tbr.receive(new BlockReceiverCompletion() {\n\n\t\t\t\tpublic void blockReceived(byte[] buf) {\n\t\t\t\t\tnext.noLongerRoutingTo(origTag, false);\n\t\t\t\t}\n\n\t\t\t\tpublic void blockReceiveFailed(RetrievalException e) {\n\t\t\t\t\tnext.noLongerRoutingTo(origTag, false);\n\t\t\t\t}\n    \t\t\t\n    \t\t});\n    \t\treturn;\n    \t}\n    \t\n    \tif(logMINOR) Logger.minor(this, \"Receiving data\");\n    \tfinal PeerNode from = next;\n    \tif(!wasFork) {\n    \t\tsynchronized(this) {\n    \t\t\ttransferringFrom = next;\n    \t\t}\n    \t}\n    \tnode.getTicker().queueTimedJob(new Runnable() {\n    \t\t\n    \t\tpublic void run() {\n    \t\t\tsynchronized(RequestSender.this) {\n    \t\t\t\tif(transferringFrom != from) return;\n    \t\t\t}\n    \t\t\tmakeTurtle();\n    \t\t}\n    \t\t\n    \t}, 60*1000);\n    \tfinal PeerNode sentTo = next;\n\t\t\treceivingAsync = true;\n    \tbr.receive(new BlockReceiverCompletion() {\n    \t\t\n    \t\tpublic void blockReceived(byte[] data) {\n    \t\t\ttry {\n    \t\t\t\tlong tEnd = System.currentTimeMillis();\n    \t\t\t\ttransferTime = tEnd - tStart;\n    \t\t\t\tboolean turtle;\n    \t\t\t\tboolean turtleBackedOff;\n    \t\t\t\tsynchronized(RequestSender.this) {\n    \t\t\t\t\tturtle = turtleMode;\n    \t\t\t\t\tturtleBackedOff = sentBackoffTurtle;\n    \t\t\t\t\tsentBackoffTurtle = true;\n    \t\t\t\t\ttransferringFrom = null;\n    \t\t\t\t}\n    \t\t\t\tif(!wasFork)\n    \t\t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n    \t\t\t\tif(!turtle)\n    \t\t\t\t\tsentTo.transferSuccess();\n    \t\t\t\telse {\n    \t\t\t\t\tLogger.normal(this, \"TURTLE SUCCEEDED: \"+key+\" for \"+RequestSender.this+\" in \"+TimeUtil.formatTime(transferTime, 2, true)+\" from \"+sentTo);\n    \t\t\t\t\tif(!turtleBackedOff)\n    \t\t\t\t\t\tsentTo.transferFailed(\"TurtledTransfer\");\n    \t\t\t\t\tnode.nodeStats.turtleSucceeded();\n    \t\t\t\t}\n    \t\t\t\tsentTo.successNotOverload();\n    \t\t\t\tif(turtle) {\n    \t\t\t\t\tsentTo.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t\tnode.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t}\n    \t\t\t\tnode.nodeStats.successfulBlockReceive(realTimeFlag, source == null);\n    \t\t\t\tif(logMINOR) Logger.minor(this, \"Received data\");\n    \t\t\t\t// Received data\n    \t\t\t\ttry {\n    \t\t\t\t\tverifyAndCommit(headers, data);\n    \t\t\t\t} catch (KeyVerifyException e1) {\n    \t\t\t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n    \t\t\t\t\tif(!wasFork)\n    \t\t\t\t\t\tfinish(VERIFY_FAILURE, sentTo, false);\n    \t\t\t\t\telse\n    \t\t\t\t\t\torigTag.removeRoutingTo(sentTo);\n    \t\t\t\t\tnode.failureTable.onFinalFailure(key, sentTo, htl, origHTL, FailureTable.REJECT_TIME, source);\n    \t\t\t\t\treturn;\n    \t\t\t\t}\n    \t\t\t\tfinish(SUCCESS, sentTo, false);\n    \t\t\t} catch (Throwable t) {\n        \t\t\tLogger.error(this, \"Failed on \"+this, t);\n        \t\t\tif(!wasFork)\n        \t\t\t\tfinish(INTERNAL_ERROR, sentTo, true);\n    \t\t\t} finally {\n    \t\t\t\tif(wasFork)\n    \t\t\t\t\tnext.noLongerRoutingTo(origTag, false);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tpublic void blockReceiveFailed(\n    \t\t\t\tRetrievalException e) {\n    \t\t\ttry {\n    \t\t\t\tboolean turtle;\n    \t\t\t\tsynchronized(RequestSender.this) {\n    \t\t\t\t\tturtle = turtleMode;\n    \t\t\t\t\ttransferringFrom = null;\n    \t\t\t\t}\n    \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n    \t\t\t\tif(turtle) {\n    \t\t\t\t\tif(e.getReason() != RetrievalException.GONE_TO_TURTLE_MODE) {\n    \t\t\t\t\t\tLogger.normal(this, \"TURTLE FAILED: \"+key+\" for \"+this+\" : \"+e);\n    \t\t\t\t\t\tnode.nodeStats.turtleFailed();\n    \t\t\t\t\t} else {\n    \t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Upstream turtled for \"+this+\" from \"+sentTo);\n    \t\t\t\t\t}\n    \t\t\t\t\tsentTo.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t\tnode.unregisterTurtleTransfer(RequestSender.this);\n    \t\t\t\t}\n    \t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n    \t\t\t\t\tLogger.normal(this, \"Transfer failed (disconnect): \"+e, e);\n    \t\t\t\telse\n    \t\t\t\t\t// A certain number of these are normal, it's better to track them through statistics than call attention to them in the logs.\n    \t\t\t\t\tLogger.normal(this, \"Transfer failed (\"+e.getReason()+\"/\"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+sentTo, e);\n    \t\t\t\tif(RequestSender.this.source == null)\n    \t\t\t\t\tLogger.normal(this, \"Local transfer failed: \"+e.getReason()+\" : \"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+sentTo, e);\n    \t\t\t\t// We do an ordinary backoff in all cases.\n    \t\t\t\t// This includes the case where we decide not to turtle the request. This is reasonable as if it had completely quickly we wouldn't have needed to make that choice.\n    \t\t\t\tsentTo.localRejectedOverload(\"TransferFailedRequest\"+e.getReason());\n    \t\t\t\tif(!wasFork)\n    \t\t\t\t\tfinish(TRANSFER_FAILED, sentTo, false);\n    \t\t\t\tnode.failureTable.onFinalFailure(key, sentTo, htl, origHTL, FailureTable.REJECT_TIME, source);\n    \t\t\t\tint reason = e.getReason();\n    \t\t\t\tboolean timeout = (!br.senderAborted()) &&\n    \t\t\t\t(reason == RetrievalException.SENDER_DIED || reason == RetrievalException.RECEIVER_DIED || reason == RetrievalException.TIMED_OUT\n    \t\t\t\t\t\t|| reason == RetrievalException.UNABLE_TO_SEND_BLOCK_WITHIN_TIMEOUT);\n    \t\t\t\t// But we only do a transfer backoff (which is separate, and starts at a higher threshold) if we timed out i.e. not if upstream turtled.\n    \t\t\t\tif(timeout) {\n    \t\t\t\t\t// Looks like a timeout. Backoff, even if it's a turtle.\n    \t\t\t\t\tif(logMINOR) Logger.minor(this, \"Timeout transferring data : \"+e, e);\n    \t\t\t\t\tsentTo.transferFailed(e.getErrString());\n    \t\t\t\t} else {\n    \t\t\t\t\t// Quick failure (in that we didn't have to timeout). Don't backoff.\n    \t\t\t\t\t// Treat as a DNF.\n    \t\t\t\t\t// If it was turtled, and then failed, still treat it as a DNF.\n    \t\t\t\t\tnode.failureTable.onFinalFailure(key, sentTo, htl, origHTL, FailureTable.REJECT_TIME, source);\n    \t\t\t\t}\n    \t\t\t\tnode.nodeStats.failedBlockReceive(true, timeout, reason == RetrievalException.GONE_TO_TURTLE_MODE, realTimeFlag, source == null);\n    \t\t\t} catch (Throwable t) {\n        \t\t\tLogger.error(this, \"Failed on \"+this, t);\n        \t\t\tif(!wasFork)\n        \t\t\t\tfinish(INTERNAL_ERROR, sentTo, true);\n    \t\t\t} finally {\n    \t\t\t\tif(wasFork)\n    \t\t\t\t\tnext.noLongerRoutingTo(origTag, false);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t});\n\t}","commit_id":"6656f1f7a15ce802d7498c0a98e7a10ce9e8d396","url":"https://github.com/freenet/fred"},{"original_method":"private void verifyAndCommit(byte[] data) throws KeyVerifyException {\n    \tif(!isSSK) {\n    \t\tCHKBlock block = new CHKBlock(data, headers, (NodeCHK)key);\n    \t\t// Cache only in the cache, not the store. The reason for this is that\n    \t\t// requests don't go to the full distance, and therefore pollute the \n    \t\t// store; simulations it is best to only include data from requests\n    \t\t// which go all the way i.e. inserts.\n    \t\tnode.storeShallow(block, canWriteClientCache, canWriteDatastore, tryOffersOnly);\n\t\t\tif(node.random.nextInt(RANDOM_REINSERT_INTERVAL) == 0)\n\t\t\t\tnode.queueRandomReinsert(block);\n    \t} else /*if (key instanceof NodeSSK)*/ {\n    \t\ttry {\n\t\t\t\tnode.storeShallow(new SSKBlock(data, headers, (NodeSSK)key, false), canWriteClientCache, canWriteDatastore, tryOffersOnly);\n\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\tLogger.normal(this, \"Collision on \"+this);\n\t\t\t}\n    \t}\n\t}","id":86954,"modified_method":"private void verifyAndCommit(byte[] headers, byte[] data) throws KeyVerifyException {\n    \tif(!isSSK) {\n    \t\tCHKBlock block = new CHKBlock(data, headers, (NodeCHK)key);\n    \t\t// Cache only in the cache, not the store. The reason for this is that\n    \t\t// requests don't go to the full distance, and therefore pollute the \n    \t\t// store; simulations it is best to only include data from requests\n    \t\t// which go all the way i.e. inserts.\n    \t\tnode.storeShallow(block, canWriteClientCache, canWriteDatastore, tryOffersOnly);\n\t\t\tif(node.random.nextInt(RANDOM_REINSERT_INTERVAL) == 0)\n\t\t\t\tnode.queueRandomReinsert(block);\n    \t} else /*if (key instanceof NodeSSK)*/ {\n    \t\ttry {\n\t\t\t\tnode.storeShallow(new SSKBlock(data, headers, (NodeSSK)key, false), canWriteClientCache, canWriteDatastore, tryOffersOnly);\n\t\t\t} catch (KeyCollisionException e) {\n\t\t\t\tLogger.normal(this, \"Collision on \"+this);\n\t\t\t}\n    \t}\n\t}","commit_id":"6656f1f7a15ce802d7498c0a98e7a10ce9e8d396","url":"https://github.com/freenet/fred"},{"original_method":"/** @return True if we successfully received the offer or failed fatally. False if we\n     * should try the next offer and/or normal fetches. */\n\tprivate boolean handleCHKOfferReply(Message reply, PeerNode pn, final BlockOffer offer, final OfferList offers) {\n\t\tif(reply.getSpec() == DMT.FNPRejectedOverload) {\n\t\t\t// Non-fatal, keep it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey for \"+key+\" (expired=\"+offer.isExpired());\n\t\t\toffers.keepLastOffer();\n        \torigTag.removeFetchingOfferedKeyFrom(pn);\n        \treturn false;\n\t\t} else if(reply.getSpec() == DMT.FNPGetOfferedKeyInvalid) {\n\t\t\t// Fatal, delete it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey as invalid with reason \"+reply.getShort(DMT.REASON));\n\t\t\toffers.deleteLastOffer();\n        \torigTag.removeFetchingOfferedKeyFrom(pn);\n        \treturn false;\n\t\t} else if(reply.getSpec() == DMT.FNPCHKDataFound) {\n\t\t\theaders = ((ShortBuffer)reply.getObject(DMT.BLOCK_HEADERS)).getData();\n\t\t\t// Receive the data\n\t\t\t\n        \t// FIXME: Validate headers\n        \t\n        \tnode.addTransferringSender((NodeCHK)key, this);\n        \t\n        \ttry {\n        \t\t\n        \t\tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n        \t\t\n        \t\tsynchronized(this) {\n        \t\t\tnotifyAll();\n        \t\t}\n        \t\tfireCHKTransferBegins();\n\t\t\t\t\n        \t\tBlockReceiver br = new BlockReceiver(node.usm, pn, uid, prb, this, node.getTicker(), true, realTimeFlag, myTimeoutHandler);\n        \t\t\n       \t\t\tif(logMINOR) Logger.minor(this, \"Receiving data\");\n       \t\t\tfinal PeerNode p = pn;\n       \t\t\treceivingAsync = true;\n       \t\t\tbr.receive(new BlockReceiverCompletion() {\n       \t\t\t\t\n\t\t\t\t\tpublic void blockReceived(byte[] data) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n                \t\ttry {\n\t                \t\t// Received data\n\t               \t\t\tp.transferSuccess();\n\t                \t\tif(logMINOR) Logger.minor(this, \"Received data\");\n                \t\t\tverifyAndCommit(data);\n\t                \t\tfinish(SUCCESS, p, true);\n\t                \t\tnode.nodeStats.successfulBlockReceive(realTimeFlag, source == null);\n                \t\t} catch (KeyVerifyException e1) {\n                \t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n                \t\t\tfinish(GET_OFFER_VERIFY_FAILURE, p, true);\n                       \t\toffers.deleteLastOffer();\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic void blockReceiveFailed(\n\t\t\t\t\t\t\tRetrievalException e) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer failed (disconnect): \"+e, e);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// A certain number of these are normal, it's better to track them through statistics than call attention to them in the logs.\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer for offer failed (\"+e.getReason()+\"/\"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+p, e);\n\t\t\t\t\t\t\tfinish(GET_OFFER_TRANSFER_FAILED, p, true);\n\t\t\t\t\t\t\t// Backoff here anyway - the node really ought to have it!\n\t\t\t\t\t\t\tp.transferFailed(\"RequestSenderGetOfferedTransferFailed\");\n\t\t\t\t\t\t\toffers.deleteLastOffer();\n\t\t\t\t\t\t\tnode.nodeStats.failedBlockReceive(false, false, false, realTimeFlag, source == null);\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n        \t\t\t\t\n        \t\t});\n        \t\treturn true;\n        \t} finally {\n        \t\tnode.removeTransferringSender((NodeCHK)key, this);\n        \t}\n\t\t} else return false;\n\t}","id":86955,"modified_method":"/** @return True if we successfully received the offer or failed fatally. False if we\n     * should try the next offer and/or normal fetches. */\n\tprivate boolean handleCHKOfferReply(Message reply, PeerNode pn, final BlockOffer offer, final OfferList offers) {\n\t\tif(reply.getSpec() == DMT.FNPRejectedOverload) {\n\t\t\t// Non-fatal, keep it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey for \"+key+\" (expired=\"+offer.isExpired());\n\t\t\toffers.keepLastOffer();\n        \torigTag.removeFetchingOfferedKeyFrom(pn);\n        \treturn false;\n\t\t} else if(reply.getSpec() == DMT.FNPGetOfferedKeyInvalid) {\n\t\t\t// Fatal, delete it.\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Node \"+pn+\" rejected FNPGetOfferedKey as invalid with reason \"+reply.getShort(DMT.REASON));\n\t\t\toffers.deleteLastOffer();\n        \torigTag.removeFetchingOfferedKeyFrom(pn);\n        \treturn false;\n\t\t} else if(reply.getSpec() == DMT.FNPCHKDataFound) {\n\t\t\theaders = ((ShortBuffer)reply.getObject(DMT.BLOCK_HEADERS)).getData();\n\t\t\t// Receive the data\n\t\t\t\n        \t// FIXME: Validate headers\n        \t\n        \tnode.addTransferringSender((NodeCHK)key, this);\n        \t\n        \ttry {\n        \t\t\n        \t\tprb = new PartiallyReceivedBlock(Node.PACKETS_IN_BLOCK, Node.PACKET_SIZE);\n        \t\t\n        \t\tsynchronized(this) {\n        \t\t\tnotifyAll();\n        \t\t}\n        \t\tfireCHKTransferBegins();\n\t\t\t\t\n        \t\tBlockReceiver br = new BlockReceiver(node.usm, pn, uid, prb, this, node.getTicker(), true, realTimeFlag, myTimeoutHandler);\n        \t\t\n       \t\t\tif(logMINOR) Logger.minor(this, \"Receiving data\");\n       \t\t\tfinal PeerNode p = pn;\n       \t\t\treceivingAsync = true;\n       \t\t\tbr.receive(new BlockReceiverCompletion() {\n       \t\t\t\t\n\t\t\t\t\tpublic void blockReceived(byte[] data) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n                \t\ttry {\n\t                \t\t// Received data\n\t               \t\t\tp.transferSuccess();\n\t                \t\tif(logMINOR) Logger.minor(this, \"Received data\");\n                \t\t\tverifyAndCommit(headers, data);\n\t                \t\tfinish(SUCCESS, p, true);\n\t                \t\tnode.nodeStats.successfulBlockReceive(realTimeFlag, source == null);\n                \t\t} catch (KeyVerifyException e1) {\n                \t\t\tLogger.normal(this, \"Got data but verify failed: \"+e1, e1);\n                \t\t\tfinish(GET_OFFER_VERIFY_FAILURE, p, true);\n                       \t\toffers.deleteLastOffer();\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic void blockReceiveFailed(\n\t\t\t\t\t\t\tRetrievalException e) {\n        \t\t\t\tsynchronized(RequestSender.this) {\n        \t\t\t\t\ttransferringFrom = null;\n        \t\t\t\t}\n        \t\t\t\tnode.removeTransferringSender((NodeCHK)key, RequestSender.this);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (e.getReason()==RetrievalException.SENDER_DISCONNECTED)\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer failed (disconnect): \"+e, e);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// A certain number of these are normal, it's better to track them through statistics than call attention to them in the logs.\n\t\t\t\t\t\t\t\tLogger.normal(this, \"Transfer for offer failed (\"+e.getReason()+\"/\"+RetrievalException.getErrString(e.getReason())+\"): \"+e+\" from \"+p, e);\n\t\t\t\t\t\t\tfinish(GET_OFFER_TRANSFER_FAILED, p, true);\n\t\t\t\t\t\t\t// Backoff here anyway - the node really ought to have it!\n\t\t\t\t\t\t\tp.transferFailed(\"RequestSenderGetOfferedTransferFailed\");\n\t\t\t\t\t\t\toffers.deleteLastOffer();\n\t\t\t\t\t\t\tnode.nodeStats.failedBlockReceive(false, false, false, realTimeFlag, source == null);\n                \t\t} catch (Throwable t) {\n                \t\t\tLogger.error(this, \"Failed on \"+this, t);\n                \t\t\tfinish(INTERNAL_ERROR, p, true);\n                \t\t}\n\t\t\t\t\t}\n        \t\t\t\t\n        \t\t});\n        \t\treturn true;\n        \t} finally {\n        \t\tnode.removeTransferringSender((NodeCHK)key, this);\n        \t}\n\t\t} else return false;\n\t}","commit_id":"6656f1f7a15ce802d7498c0a98e7a10ce9e8d396","url":"https://github.com/freenet/fred"},{"original_method":"public StorableBlock fetch(byte[] routingKey, byte[] fullKey, boolean dontPromote) throws IOException {\n\t\tif (logMINOR)\n\t\t\tLogger.minor(this, \"Fetch \" + HexUtil.bytesToHex(routingKey) + \" for \" + callback);\n\n\t\tEntry entry = probeEntry(routingKey);\n\n\t\tif (entry == null) {\n\t\t\tincMisses();\n\t\t\treturn null;\n\t\t}\n\n\t\tunlockEntry(entry.curOffset);\n\n\t\ttry {\n\t\t\tStorableBlock block = entry.getStorableBlock(routingKey, fullKey);\n\t\t\tincHits();\n\t\t\tif (updateBloom && !checkBloom)\n\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), false);\n\t\t\treturn block;\n\t\t} catch (KeyVerifyException e) {\n\t\t\tLogger.minor(this, \"key verification exception\", e);\n\t\t\tincMisses();\n\t\t\treturn null;\n\t\t}\n\t}","id":86956,"modified_method":"public StorableBlock fetch(byte[] routingKey, byte[] fullKey, boolean dontPromote) throws IOException {\n\t\tif (logMINOR)\n\t\t\tLogger.minor(this, \"Fetch \" + HexUtil.bytesToHex(routingKey) + \" for \" + callback);\n\n\t\tconfigLock.readLock().lock();\n\t\ttry {\n\t\tEntry entry = probeEntry(routingKey);\n\n\t\tif (entry == null) {\n\t\t\tincMisses();\n\t\t\treturn null;\n\t\t}\n\n\t\tunlockEntry(entry.curOffset);\n\n\t\ttry {\n\t\t\tStorableBlock block = entry.getStorableBlock(routingKey, fullKey);\n\t\t\tincHits();\n\t\t\tif (updateBloom && !checkBloom)\n\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), false);\n\t\t\treturn block;\n\t\t} catch (KeyVerifyException e) {\n\t\t\tLogger.minor(this, \"key verification exception\", e);\n\t\t\tincMisses();\n\t\t\treturn null;\n\t\t}\n\t\t} finally {\n\t\t\tconfigLock.readLock().unlock();\n\t\t}\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"public void setBloomSync(boolean sync) {\n\t\tif (lockGlobal(Integer.MAX_VALUE)) {\n\t\t\tthis.syncBloom = sync;\n\t\t\tunlockGlobal();\n\t\t}\n\t}","id":86957,"modified_method":"public void setBloomSync(boolean sync) {\n\t\tconfigLock.writeLock().lock();\n\t\t\tthis.syncBloom = sync;\n\t\tconfigLock.writeLock().unlock();\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"public void setMaxKeys(long newStoreSize, boolean shrinkNow) throws IOException {\n\t\tLogger.normal(this, \"[\" + name + \"] Resize newStoreSize=\" + newStoreSize + \", shinkNow=\" + shrinkNow);\n\n\t\tassert newStoreSize > 0;\n\t\t// TODO assert newStoreSize > (141 * (3 * 3) + 13 * 3) * 2; // store size too small\n\n\t\tsynchronized (cleanerLock) {\n\t\t\tif (newStoreSize == this.storeSize)\n\t\t\t\treturn;\n\n\t\t\tif (prevStoreSize != 0) {\n\t\t\t\tif (shrinkNow) {\n\t\t\t\t\t// TODO shrink now\n\t\t\t\t} else {\n\t\t\t\t\tLogger.normal(this, \"[\" + name + \"] resize already in progress, ignore resize request\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprevStoreSize = storeSize;\n\t\t\tstoreSize = newStoreSize;\n\t\t\twriteConfigFile();\n\t\t\tcleanerLock.notifyAll();\n\n\t\t\tif (shrinkNow) {\n\t\t\t\t// TODO shrink now\n\t\t\t}\n\t\t}\n\t}","id":86958,"modified_method":"public void setMaxKeys(long newStoreSize, boolean shrinkNow) throws IOException {\n\t\tLogger.normal(this, \"[\" + name + \"] Resize newStoreSize=\" + newStoreSize + \", shinkNow=\" + shrinkNow);\n\n\t\tassert newStoreSize > 0;\n\t\t// TODO assert newStoreSize > (141 * (3 * 3) + 13 * 3) * 2; // store size too small\n\n\t\tconfigLock.writeLock().lock();\n\t\ttry {\n\t\t\tif (newStoreSize == this.storeSize)\n\t\t\t\treturn;\n\n\t\t\tif (prevStoreSize != 0) {\n\t\t\t\tif (shrinkNow) {\n\t\t\t\t\t// TODO shrink now\n\t\t\t\t} else {\n\t\t\t\t\tLogger.normal(this, \"[\" + name + \"] resize already in progress, ignore resize request\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprevStoreSize = storeSize;\n\t\t\tstoreSize = newStoreSize;\n\t\t\twriteConfigFile();\n\t\t\tsynchronized (cleanerLock) {\n\t\t\tcleanerLock.notifyAll();\n\t\t\t}\n\n\t\t\tif (shrinkNow) {\n\t\t\t\t// TODO shrink now\n\t\t\t}\n\t\t} finally {\n\t\t\tconfigLock.writeLock().unlock();\n\t\t}\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\t\twhile (!shutdown) {\n\t\t\t\tsynchronized (cleanerLock) {\n\t\t\t\t\tif (prevStoreSize != 0)\n\t\t\t\t\t\tresizeStore();\n\n\t\t\t\t\tcleanerLock.notifyAll();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcleanerLock.wait(CLEANER_PERIOD);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tLogger.debug(this, \"interrupted\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":86959,"modified_method":"@Override\n        public void run() {\n\t\t\twhile (!shutdown) {\n\t\t\t\tsynchronized (cleanerLock) {\n\t\t\t\t\tconfigLock.readLock().lock();\n\t\t\t\t\ttry {\n\t\t\t\t\tif (prevStoreSize != 0)\n\t\t\t\t\t\tresizeStore();\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tconfigLock.readLock().unlock();\n\t\t\t\t\t}\n\n\t\t\t\t\tcleanerLock.notifyAll();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcleanerLock.wait(CLEANER_PERIOD);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tLogger.debug(this, \"interrupted\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Unlock the entry\n\t */\n\tprivate void unlockEntry(long offset) {\n\t\tif (logDEBUG && logLOCK)\n\t\t\tLogger.debug(this, \"unlocking \" + offset);\n\t\tLong lxr = new Long(offset);\n\n\t\tsynchronized (lockMap) {\n\t\t\tObject o = lockMap.remove(lxr);\n\t\t\tassert o == Thread.currentThread();\n\n\t\t\tlockMap.notifyAll();\n\t\t}\n\t}","id":86960,"modified_method":"/**\n\t * Unlock the entry\n\t */\n\tprivate void unlockEntry(long offset) {\n\t\tif (logDEBUG && logLOCK)\n\t\t\tLogger.debug(this, \"unlocking \" + offset);\n\n\t\tentryLock.lock();\n\t\t\ttry {\n\t\t\tCondition cond = lockMap.remove(offset);\n\t\t\tcond.signal();\n\t\t\t} finally {\n\t\t\tentryLock.unlock();\n\t\t}\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Write config file\n\t */\n\tprivate void writeConfigFile() throws IOException {\n\t\tFile tempConfig = new File(configFile.getPath() + \".tmp\");\n\t\tRandomAccessFile raf = new RandomAccessFile(tempConfig, \"rw\");\n\t\traf.seek(0);\n\t\traf.write(salt);\n\n\t\traf.writeLong(storeSize);\n\t\traf.writeLong(prevStoreSize);\n\t\traf.writeLong(keyCount);\n\t\traf.writeLong(0);\n\n\t\traf.close();\n\n\t\tFileUtil.renameTo(tempConfig, configFile);\n\t}","id":86961,"modified_method":"/**\n\t * Write config file\n\t */\n\tprivate void writeConfigFile() throws IOException {\n\t\tconfigLock.writeLock().lock();\n\t\ttry {\n\t\tFile tempConfig = new File(configFile.getPath() + \".tmp\");\n\t\tRandomAccessFile raf = new RandomAccessFile(tempConfig, \"rw\");\n\t\traf.seek(0);\n\t\traf.write(salt);\n\n\t\traf.writeLong(storeSize);\n\t\traf.writeLong(prevStoreSize);\n\t\traf.writeLong(keyCount);\n\t\traf.writeLong(0);\n\n\t\traf.close();\n\n\t\tFileUtil.renameTo(tempConfig, configFile);\n\t\t} finally {\n\t\t\tconfigLock.writeLock().unlock();\n\t\t}\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\t\tshutdown = true;\n\n\t\t\tsynchronized (cleanerLock) {\n\t\t\t\tcleanerLock.notifyAll();\n\t\t\t}\n\n\t\t\tlockGlobal(10 * 1000); // 10 seconds\n\n\t\t\tcleanerThread.interrupt();\n\n\t\t\tflushAndClose();\n\n\t\t\ttry {\n\t\t\t\twriteConfigFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"error writing store config\", e);\n\t\t\t}\n\t\t}","id":86962,"modified_method":"public void run() {\n\t\t\tshutdown = true;\n\n\t\t\tsynchronized (cleanerLock) {\n\t\t\t\tcleanerLock.notifyAll();\n\t\t\t}\n\n\t\t\tconfigLock.writeLock().lock();\n\t\t\ttry {\n\t\t\tcleanerThread.interrupt();\n\n\t\t\tflushAndClose();\n\n\t\t\ttry {\n\t\t\t\twriteConfigFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"error writing store config\", e);\n\t\t\t}\n\t\t\t} finally {\n\t\t\t\tconfigLock.writeLock().unlock();\n\t\t\t}\n\t\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Lock the entry\n\t *\n\t * This lock is <strong>not<\/strong> reentrance. No threads except Cleaner should hold more then\n\t * one lock at a time (or deadlock may occur).\n\t */\n\tprivate boolean lockEntry(long offset) {\n\t\tif (logDEBUG && logLOCK)\n\t\t\tLogger.debug(this, \"try locking \" + offset, new Exception());\n\n\t\tLong lxr = new Long(offset);\n\n\t\ttry {\n\t\t\tsynchronized (lockMap) {\n\t\t\t\twhile (lockMap.containsKey(lxr) || lockedGlobal || lockingGlobal != 0) { // while someone hold the lock\n\t\t\t\t\tif (shutdown)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\tlockMap.wait();\n\t\t\t\t}\n\n\t\t\t\tlockMap.put(lxr, Thread.currentThread());\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\tLogger.error(this, \"lock interrupted\", e);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (logDEBUG && logLOCK)\n\t\t\tLogger.debug(this, \"locked \" + offset, new Exception());\n\t\treturn true;\n\t}","id":86963,"modified_method":"/**\n\t * Lock the entry\n\t *\n\t * This lock is <strong>not<\/strong> re-entrance. No threads except Cleaner should hold more\n\t * then one lock at a time (or deadlock may occur).\n\t */\n\tprivate boolean lockEntry(long offset) {\n\t\tif (logDEBUG && logLOCK)\n\t\t\tLogger.debug(this, \"try locking \" + offset, new Exception());\n\n\t\ttry {\n\t\t\tentryLock.lock();\n\t\t\ttry {\n\t\t\t\tdo {\n\t\t\t\t\tif (shutdown)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\tCondition lockCond = lockMap.get(offset);\n\t\t\t\t\tif (lockCond != null)\n\t\t\t\t\t\tlockCond.await(10, TimeUnit.SECONDS); // 10s for checking shutdown\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while (true);\n\t\t\t\tlockMap.put(offset, entryLock.newCondition());\n\t\t\t} finally {\n\t\t\t\tentryLock.unlock();\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\tLogger.error(this, \"lock interrupted\", e);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (logDEBUG && logLOCK)\n\t\t\tLogger.debug(this, \"locked \" + offset, new Exception());\n\t\treturn true;\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"public void put(StorableBlock block, byte[] routingKey, byte[] fullKey, byte[] data, byte[] header,\n\t        boolean overwrite) throws IOException, KeyCollisionException {\n\t\tif (logMINOR)\n\t\t\tLogger.minor(this, \"Putting \" + HexUtil.bytesToHex(routingKey) + \" for \" + callback);\n\n\t\t// don't use fetch(), as fetch() would do a miss++/hit++\n\t\tEntry oldEntry = probeEntry(routingKey);\n\t\tif (oldEntry != null) {\n\t\t\tlong oldOffset = oldEntry.curOffset;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tStorableBlock oldBlock = oldEntry.getStorableBlock(routingKey, fullKey);\n\t\t\t\t\tif (!collisionPossible)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (block.equals(oldBlock)) {\n\t\t\t\t\t\treturn; // already in store\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!overwrite)\n\t\t\t\t\t\t\tthrow new KeyCollisionException();\n\t\t\t\t\t}\n\t\t\t\t} catch (KeyVerifyException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\t// Overwrite old offset\n\t\t\t\tif (updateBloom)\n\t\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), syncBloom);\n\t\t\t\tEntry entry = new Entry(routingKey, header, data);\n\t\t\t\twriteEntry(entry, oldOffset);\n\t\t\t\tincWrites();\n\t\t\t\treturn;\n\t\t\t} finally {\n\t\t\t\tunlockEntry(oldOffset);\n\t\t\t}\n\t\t}\n\n\t\tEntry entry = new Entry(routingKey, header, data);\n\t\tlong[] offset = entry.getOffset();\n\n\t\tfor (int i = 0; i < offset.length; i++) {\n\t\t\tif (!lockEntry(offset[i])) {\n\t\t\t\tLogger.error(this, \"can't lock entry: \" + offset[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (isFree(offset[i])) {\n\t\t\t\t\t// write to free block\n\t\t\t\t\tif (logDEBUG)\n\t\t\t\t\t\tLogger.debug(this, \"probing, write to i=\" + i + \", offset=\" + offset[i]);\n\t\t\t\t\tif (updateBloom)\n\t\t\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), syncBloom);\n\t\t\t\t\twriteEntry(entry, offset[i]);\n\t\t\t\t\tincWrites();\n\t\t\t\t\tincKeyCount();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tunlockEntry(offset[i]);\n\t\t\t}\n\t\t}\n\n\t\t// no free blocks, overwrite the first one\n\t\tif (!lockEntry(offset[0])) {\n\t\t\tLogger.error(this, \"can't lock entry: \" + offset[0]);\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tif (logDEBUG)\n\t\t\t\tLogger.debug(this, \"collision, write to i=0, offset=\" + offset[0]);\n\t\t\tif (updateBloom)\n\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), syncBloom);\n\t\t\twriteEntry(entry, offset[0]);\n\t\t\tincWrites();\n\t\t} finally {\n\t\t\tunlockEntry(offset[0]);\n\t\t}\n\t}","id":86964,"modified_method":"public void put(StorableBlock block, byte[] routingKey, byte[] fullKey, byte[] data, byte[] header,\n\t        boolean overwrite) throws IOException, KeyCollisionException {\n\t\tif (logMINOR)\n\t\t\tLogger.minor(this, \"Putting \" + HexUtil.bytesToHex(routingKey) + \" for \" + callback);\n\n\t\tconfigLock.readLock().lock();\n\t\ttry {\n\t\t// don't use fetch(), as fetch() would do a miss++/hit++\n\t\tEntry oldEntry = probeEntry(routingKey);\n\t\tif (oldEntry != null) {\n\t\t\tlong oldOffset = oldEntry.curOffset;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tStorableBlock oldBlock = oldEntry.getStorableBlock(routingKey, fullKey);\n\t\t\t\t\tif (!collisionPossible)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (block.equals(oldBlock)) {\n\t\t\t\t\t\treturn; // already in store\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!overwrite)\n\t\t\t\t\t\t\tthrow new KeyCollisionException();\n\t\t\t\t\t}\n\t\t\t\t} catch (KeyVerifyException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\t// Overwrite old offset\n\t\t\t\tif (updateBloom)\n\t\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), syncBloom);\n\t\t\t\tEntry entry = new Entry(routingKey, header, data);\n\t\t\t\twriteEntry(entry, oldOffset);\n\t\t\t\tincWrites();\n\t\t\t\treturn;\n\t\t\t} finally {\n\t\t\t\tunlockEntry(oldOffset);\n\t\t\t}\n\t\t}\n\n\t\tEntry entry = new Entry(routingKey, header, data);\n\t\tlong[] offset = entry.getOffset();\n\n\t\tfor (int i = 0; i < offset.length; i++) {\n\t\t\tif (!lockEntry(offset[i])) {\n\t\t\t\tLogger.error(this, \"can't lock entry: \" + offset[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (isFree(offset[i])) {\n\t\t\t\t\t// write to free block\n\t\t\t\t\tif (logDEBUG)\n\t\t\t\t\t\tLogger.debug(this, \"probing, write to i=\" + i + \", offset=\" + offset[i]);\n\t\t\t\t\tif (updateBloom)\n\t\t\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), syncBloom);\n\t\t\t\t\twriteEntry(entry, offset[i]);\n\t\t\t\t\tincWrites();\n\t\t\t\t\tincKeyCount();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tunlockEntry(offset[i]);\n\t\t\t}\n\t\t}\n\n\t\t// no free blocks, overwrite the first one\n\t\tif (!lockEntry(offset[0])) {\n\t\t\tLogger.error(this, \"can't lock entry: \" + offset[0]);\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tif (logDEBUG)\n\t\t\t\tLogger.debug(this, \"collision, write to i=0, offset=\" + offset[0]);\n\t\t\tif (updateBloom)\n\t\t\t\tbloomFilter.updateFilter(getDigestedRoutingKey(routingKey), syncBloom);\n\t\t\twriteEntry(entry, offset[0]);\n\t\t\tincWrites();\n\t\t} finally {\n\t\t\tunlockEntry(offset[0]);\n\t\t}\n\t\t} finally {\n\t\t\tconfigLock.readLock().unlock();\n\t\t}\n\t}","commit_id":"c5e38fce12db6552055f6525747013305fab4eb0","url":"https://github.com/freenet/fred"},{"original_method":"public void wait(int milliseconds)\n        {\n            synchronized (this){\n                if(ran) return;\n                this.wait(milliseconds);\n            }\n        }","id":86965,"modified_method":"public void waitForEvent(int milliseconds)\n        {\n            synchronized (waitingForResponseLock){\n                if(ran)\n                    return;\n\n                try\n                {\n                    waitingForResponseLock.wait(milliseconds);\n                }\n                catch (InterruptedException exc)\n                {\n                    logger.error(\"Interrupted while waiting for response.\"\n                                 , exc);\n                }\n            }\n        }","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void handleResponse(SnacResponseEvent e)\n        {\n            synchronized(this) {\n                if (ran) return;\n                ran = true;\n            }\n            if(e.getSnacCommand() instanceof FullInfoAck)\n            {\n                FullInfoAck cmd = (FullInfoAck)e.getSnacCommand();;\n                if(cmd.isCommandSuccesful())\n                {\n                    success = true;\n                }\n            }\n\n            synchronized(waitingForResponseLock){\n                waitingForResponseLock.notifyAll();\n            }\n        }","id":86966,"modified_method":"public void handleResponse(SnacResponseEvent evt)\n        {\n            synchronized(waitingForResponseLock)\n            {\n                if (ran)\n                    return;\n                ran = true;\n                if (evt.getSnacCommand() instanceof FullInfoAck)\n                {\n                    FullInfoAck cmd = (FullInfoAck) evt.getSnacCommand();\n                    if (cmd.isCommandSuccesful())\n                    {\n                        success = true;\n                    }\n                }\n                waitingForResponseLock.notifyAll();\n            }\n        }","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Replaces the currentDetailValue detail with newDetailValue and returns\n     * true if the operation was a success or false if currentDetailValue did\n     * not previously exist (in this case an additional call to addDetail is\n     * required).\n     *\n     * @param currentDetailValue the detail value we'd like to replace.\n     * @param newDetailValue the value of the detail that we'd like to\n     *   replace currentDetailValue with.\n     * @throws ClassCastException if newDetailValue is not an instance of\n     *   the same class as currentDetailValue.\n     * @throws OperationFailedException with code Network Failure if putting\n     *   the new value back online has failed\n     * @return boolean\n     */\n    public boolean replaceDetail(GenericDetail currentDetailValue,\n                                 GenericDetail newDetailValue) throws\n        ClassCastException, OperationFailedException\n    {\n        if(!newDetailValue.getClass().equals(currentDetailValue.getClass()))\n            throw new ClassCastException(\"New value to be replaced is not as the current one\");\n\n        boolean isFound = false;\n        Vector alreadySetDetails = new Vector();\n        Iterator iter = infoRetreiver.getDetails(uin, currentDetailValue.getClass());\n        while (iter.hasNext())\n        {\n            GenericDetail item = (GenericDetail) iter.next();\n            if(item.equals(currentDetailValue))\n            {\n                isFound = true;\n                // add the details to the list. We will save the list on one pass\n                // most of the multiple details require saving at one time, like Spoken Language\n                // we are placing it at the right place. replacing the old one\n                alreadySetDetails.add(newDetailValue);\n            }\n            else\n                alreadySetDetails.add(item);\n        }\n        // current detail value does not exist\n        if(!isFound)\n            return false;\n\n        SuccessResponseListener responseListener = new SuccessResponseListener();\n        icqProvider.getAimConnection().getInfoService().\n            sendSnacRequest(\n                new FullInfoCmd(uin, alreadySetDetails, null), responseListener);\n\n        synchronized(responseListener.waitingForResponseLock){\n            try{\n                responseListener.waitingForResponseLock.wait(2000);\n            }\n            catch (InterruptedException ex){}\n        }\n\n        if(!responseListener.success && responseListener.timeout)\n            throw new OperationFailedException(\"Replacing Detail Failed!\",\n                            OperationFailedException.NETWORK_FAILURE);\n\n        if(responseListener.success)\n        {\n            infoRetreiver.detailsChanged(uin);\n            return true;\n        }\n        else\n            return false;\n    }","id":86967,"modified_method":"/**\n     * Replaces the currentDetailValue detail with newDetailValue and returns\n     * true if the operation was a success or false if currentDetailValue did\n     * not previously exist (in this case an additional call to addDetail is\n     * required).\n     *\n     * @param currentDetailValue the detail value we'd like to replace.\n     * @param newDetailValue the value of the detail that we'd like to\n     *   replace currentDetailValue with.\n     * @throws ClassCastException if newDetailValue is not an instance of\n     *   the same class as currentDetailValue.\n     * @throws OperationFailedException with code Network Failure if putting\n     *   the new value back online has failed\n     * @return boolean\n     */\n    public boolean replaceDetail(GenericDetail currentDetailValue,\n                                 GenericDetail newDetailValue) throws\n        ClassCastException, OperationFailedException\n    {\n        if(!newDetailValue.getClass().equals(currentDetailValue.getClass()))\n            throw new ClassCastException(\"New value to be replaced is not as the current one\");\n\n        boolean isFound = false;\n        Vector alreadySetDetails = new Vector();\n        Iterator iter = infoRetreiver.getDetails(uin, currentDetailValue.getClass());\n        while (iter.hasNext())\n        {\n            GenericDetail item = (GenericDetail) iter.next();\n            if(item.equals(currentDetailValue))\n            {\n                isFound = true;\n                // add the details to the list. We will save the list on one pass\n                // most of the multiple details require saving at one time, like Spoken Language\n                // we are placing it at the right place. replacing the old one\n                alreadySetDetails.add(newDetailValue);\n            }\n            else\n                alreadySetDetails.add(item);\n        }\n        // current detail value does not exist\n        if(!isFound)\n            return false;\n\n        SuccessResponseListener responseListener = new SuccessResponseListener();\n        icqProvider.getAimConnection().getInfoService().\n            sendSnacRequest(\n                new FullInfoCmd(uin, alreadySetDetails, null), responseListener);\n\n        responseListener.waitForEvent(5000);\n\n        if(!responseListener.success && responseListener.timeout)\n            throw new OperationFailedException(\"Replacing Detail Failed!\",\n                            OperationFailedException.NETWORK_FAILURE);\n\n        if(responseListener.success)\n        {\n            infoRetreiver.detailsChanged(uin);\n            return true;\n        }\n        else\n            return false;\n    }","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void handleSent(SnacRequestSentEvent e)\n        {}","id":86968,"modified_method":"public void handleSent(SnacRequestSentEvent evt)\n        {}","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the specified detail from the list of details stored online\n     * for this account.\n     *\n     * @param detail the detail to remove\n     * @return true if the specified detail existed and was successfully\n     *   removed and false otherwise.\n     * @throws OperationFailedException with code Network Failure if\n     *   removing the detail from the server has failed\n     */\n    public boolean removeDetail(GenericDetail detail) throws\n        OperationFailedException\n    {\n        // as there is no remove method for the details we will\n        // set it with empty or default value\n\n        boolean isFound = false;\n        // as there is items like langusge, which must be changed all the values\n        // we write not only the changed one but and the other found\n        ArrayList foundValues = new ArrayList();\n        Iterator iter = infoRetreiver.getDetails(uin, detail.getClass());\n        while (iter.hasNext())\n        {\n            GenericDetail item = (GenericDetail) iter.next();\n            if(item.equals(detail))\n            {\n                isFound = true;\n                foundValues.add(detail);\n            }\n            else\n                foundValues.add(item);\n        }\n        // current detail value does not exist\n        if(!isFound)\n            return false;\n\n        List removeValues = new ArrayList();\n        removeValues.add(detail);\n\n        SuccessResponseListener responseListener = new SuccessResponseListener();\n        icqProvider.getAimConnection().getInfoService().\n            sendSnacRequest(new FullInfoCmd(uin, foundValues, removeValues), responseListener);\n\n        synchronized(responseListener.waitingForResponseLock){\n            try{\n                responseListener.waitingForResponseLock.wait(2000);}\n            catch (InterruptedException ex)\n            {}\n        }\n\n        if(!responseListener.success && responseListener.timeout)\n            throw new OperationFailedException(\"Replacing Detail Failed!\",\n                            OperationFailedException.NETWORK_FAILURE);\n\n        if(responseListener.success)\n        {\n            infoRetreiver.detailsChanged(uin);\n            return true;\n        }\n        else\n            return false;\n    }","id":86969,"modified_method":"/**\n     * Removes the specified detail from the list of details stored online\n     * for this account.\n     *\n     * @param detail the detail to remove\n     * @return true if the specified detail existed and was successfully\n     *   removed and false otherwise.\n     * @throws OperationFailedException with code Network Failure if\n     *   removing the detail from the server has failed\n     */\n    public boolean removeDetail(GenericDetail detail) throws\n        OperationFailedException\n    {\n        // as there is no remove method for the details we will\n        // set it with empty or default value\n\n        boolean isFound = false;\n        // as there is items like langusge, which must be changed all the values\n        // we write not only the changed one but and the other found\n        ArrayList foundValues = new ArrayList();\n        Iterator iter = infoRetreiver.getDetails(uin, detail.getClass());\n        while (iter.hasNext())\n        {\n            GenericDetail item = (GenericDetail) iter.next();\n            if(item.equals(detail))\n            {\n                isFound = true;\n                foundValues.add(detail);\n            }\n            else\n                foundValues.add(item);\n        }\n        // current detail value does not exist\n        if(!isFound)\n            return false;\n\n        List removeValues = new ArrayList();\n        removeValues.add(detail);\n\n        SuccessResponseListener responseListener = new SuccessResponseListener();\n        icqProvider.getAimConnection().getInfoService().\n            sendSnacRequest(new FullInfoCmd(uin, foundValues, removeValues), responseListener);\n\n        responseListener.waitForEvent(5000);\n\n        if(!responseListener.success && responseListener.timeout)\n            throw new OperationFailedException(\"Replacing Detail Failed!\",\n                            OperationFailedException.NETWORK_FAILURE);\n\n        if(responseListener.success)\n        {\n            infoRetreiver.detailsChanged(uin);\n            return true;\n        }\n        else\n            return false;\n    }","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the specified detail to the list of details registered on-line\n     * for this account. If such a detail already exists its max instance number\n     * is consulted and if it allows it - a second instance is added or otherwise\n     * and illegal argument exception is thrown. An IllegalArgumentException is\n     * also thrown in case the class of the specified detail is not supported by\n     * the underlying implementation, i.e. its class name was not returned by the\n     * getSupportedDetailTypes() method.\n     * <p>\n     * @param detail the detail that we'd like registered on the server.\n     * <p>\n     * @throws IllegalArgumentException if such a detail already exists and its\n     * max instances number has been atteined or if the underlying\n     * implementation does not support setting details of the corresponding\n     * class.\n     * @throws OperationFailedException with code Network Failure if putting the\n     * new value online has failed\n     * @throws java.lang.ArrayIndexOutOfBoundsException if the number of\n     * instances currently registered by the application is already equal to the\n     * maximum number of supported instances (@see getMaxDetailInstances())\n     */\n    public void addDetail(GenericDetail detail) throws IllegalArgumentException,\n        OperationFailedException, ArrayIndexOutOfBoundsException\n    {\n        if(!isDetailClassSupported(detail.getClass()))\n            throw new IllegalArgumentException(\n                \"implementation does not support such details \" +\n                detail.getClass());\n\n        Vector alreadySetDetails = new Vector();\n        Iterator iter = getDetails(detail.getClass());\n        while (iter.hasNext())\n        {\n            alreadySetDetails.add(iter.next());\n        }\n\n        if(alreadySetDetails.size() >= getMaxDetailInstances(detail.getClass()))\n            throw new ArrayIndexOutOfBoundsException(\n                \"Max count for this detail is already reached\");\n\n        // everything is ok , so set it\n        alreadySetDetails.add(detail);\n\n        SuccessResponseListener responseListener = new SuccessResponseListener();\n        icqProvider.getAimConnection().getInfoService().\n            sendSnacRequest(new FullInfoCmd(uin, alreadySetDetails, null), responseListener);\n\n        synchronized(responseListener.waitingForResponseLock){\n            try{\n                responseListener.waitingForResponseLock.wait(2000);\n            }\n            catch (InterruptedException ex){}\n        }\n\n        if(!responseListener.success)\n            if(responseListener.timeout)\n                throw new OperationFailedException(\"Adding Detail Failed!\",\n                            OperationFailedException.NETWORK_FAILURE);\n            else\n                throw new OperationFailedException(\"Adding Detail Failed!\",\n                            OperationFailedException.GENERAL_ERROR);\n\n        infoRetreiver.detailsChanged(uin);\n    }","id":86970,"modified_method":"/**\n     * Adds the specified detail to the list of details registered on-line\n     * for this account. If such a detail already exists its max instance number\n     * is consulted and if it allows it - a second instance is added or otherwise\n     * and illegal argument exception is thrown. An IllegalArgumentException is\n     * also thrown in case the class of the specified detail is not supported by\n     * the underlying implementation, i.e. its class name was not returned by the\n     * getSupportedDetailTypes() method.\n     * <p>\n     * @param detail the detail that we'd like registered on the server.\n     * <p>\n     * @throws IllegalArgumentException if such a detail already exists and its\n     * max instances number has been atteined or if the underlying\n     * implementation does not support setting details of the corresponding\n     * class.\n     * @throws OperationFailedException with code Network Failure if putting the\n     * new value online has failed\n     * @throws java.lang.ArrayIndexOutOfBoundsException if the number of\n     * instances currently registered by the application is already equal to the\n     * maximum number of supported instances (@see getMaxDetailInstances())\n     */\n    public void addDetail(GenericDetail detail) throws IllegalArgumentException,\n        OperationFailedException, ArrayIndexOutOfBoundsException\n    {\n        if(!isDetailClassSupported(detail.getClass()))\n            throw new IllegalArgumentException(\n                \"implementation does not support such details \" +\n                detail.getClass());\n\n        Vector alreadySetDetails = new Vector();\n        Iterator iter = getDetails(detail.getClass());\n        while (iter.hasNext())\n        {\n            alreadySetDetails.add(iter.next());\n        }\n\n        if(alreadySetDetails.size() >= getMaxDetailInstances(detail.getClass()))\n            throw new ArrayIndexOutOfBoundsException(\n                \"Max count for this detail is already reached\");\n\n        // everything is ok , so set it\n        alreadySetDetails.add(detail);\n\n        SuccessResponseListener responseListener = new SuccessResponseListener();\n        icqProvider.getAimConnection().getInfoService().\n            sendSnacRequest(new FullInfoCmd(uin, alreadySetDetails, null), responseListener);\n\n        responseListener.waitForEvent(5000);\n\n        if(!responseListener.success)\n            if(responseListener.timeout)\n                throw new OperationFailedException(\"Adding Detail Failed!\",\n                            OperationFailedException.NETWORK_FAILURE);\n            else\n                throw new OperationFailedException(\"Adding Detail Failed!\",\n                            OperationFailedException.GENERAL_ERROR);\n\n        infoRetreiver.detailsChanged(uin);\n    }","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void handleTimeout(SnacRequestTimeoutEvent event)\n        {\n            logger.trace(\"Timeout!\");\n\n            synchronized(this) {\n                if (ran) return;\n\n                ran = true;\n                timeout = true;\n            }\n\n            synchronized(waitingForResponseLock)\n            {\n                waitingForResponseLock.notifyAll();\n            }\n        }","id":86971,"modified_method":"public void handleTimeout(SnacRequestTimeoutEvent event)\n        {\n            logger.trace(\"Timeout!\");\n\n            synchronized(waitingForResponseLock)\n            {\n                if (ran)\n                    return;\n\n                ran = true;\n                timeout = true;\n                waitingForResponseLock.notifyAll();\n            }\n        }","commit_id":"c33b6aced1514f561e07a956d97c0f58870e2cf5","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void notifyEvent(String eventName, Object args) {\n        if (_ignore) return;\n        if (args == null) {\n            args = \"[null value]\";\n        }\n        //_log.debug(this.hashCode() + \": got notification [\" + eventName + \"] = [\" + args + \"]\");\n        synchronized (_events) {\n            _events.put(eventName, args);\n            _events.notifyAll();\n            synchronized (_attached) {\n                Iterator it = _attached.iterator();\n                EventDispatcher e;\n                while (it.hasNext()) {\n                    e = (EventDispatcher) it.next();\n                    //_log.debug(this.hashCode() + \": notifying attached EventDispatcher \" + e.hashCode() + \": [\"\n                    //           + eventName + \"] = [\" + args + \"]\");\n                    e.notifyEvent(eventName, args);\n                }\n            }\n        }\n    }","id":86972,"modified_method":"public void notifyEvent(String eventName, Object args) {\n        if (_ignore) return;\n        if (args == null) {\n            args = \"[null value]\";\n        }\n        _events.put(eventName, args);\n        synchronized (_events) {\n            _events.notifyAll();\n        }\n        for (EventDispatcher e : _attached) {\n            e.notifyEvent(eventName, args);\n        }\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void ignoreEvents() {\n        _ignore = true;\n        synchronized (_events) {\n            _events.clear();\n        }\n    }","id":86973,"modified_method":"public void ignoreEvents() {\n        _ignore = true;\n        _events.clear();\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void attachEventDispatcher(EventDispatcher ev) {\n        if (ev == null) return;\n        synchronized (_attached) {\n            //_log.debug(this.hashCode() + \": attaching EventDispatcher \" + ev.hashCode());\n            _attached.add(ev);\n        }\n    }","id":86974,"modified_method":"public void attachEventDispatcher(EventDispatcher ev) {\n        if (ev == null) return;\n        _attached.add(ev);\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void detachEventDispatcher(EventDispatcher ev) {\n        if (ev == null) return;\n        synchronized (_attached) {\n            ListIterator it = _attached.listIterator();\n            while (it.hasNext()) {\n                if (((EventDispatcher) it.next()) == ev) {\n                    it.remove();\n                    break;\n                }\n            }\n        }\n    }","id":86975,"modified_method":"public void detachEventDispatcher(EventDispatcher ev) {\n        if (ev == null) return;\n        _attached.remove(ev);\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Object getEventValue(String name) {\n        if (_ignore) return null;\n        Object val;\n\n        synchronized (_events) {\n            val = _events.get(name);\n        }\n\n        return val;\n    }","id":86976,"modified_method":"public Object getEventValue(String name) {\n        if (_ignore) return null;\n        return _events.get(name);\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Set getEvents() {\n        if (_ignore) return Collections.EMPTY_SET;\n        Set set;\n\n        synchronized (_events) {\n            set = new HashSet(_events.keySet());\n        }\n\n        return set;\n    }","id":86977,"modified_method":"public Set<String> getEvents() {\n        if (_ignore) return Collections.EMPTY_SET;\n        return new HashSet(_events.keySet());\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public Object waitEventValue(String name) {\n        if (_ignore) return null;\n        Object val;\n\n        //_log.debug(this.hashCode() + \": waiting for [\" + name + \"]\");\n        do {\n            synchronized (_events) {\n                if (_events.containsKey(name)) {\n                    val = _events.get(name);\n                    break;\n                }\n                try {\n                    _events.wait(1 * 1000);\n                } catch (InterruptedException e) { // nop\n                }\n            }\n        } while (true);\n\n        return val;\n    }","id":86978,"modified_method":"public Object waitEventValue(String name) {\n        if (_ignore) return null;\n        do {\n            synchronized (_events) {\n                Object val = _events.get(name);\n                if (val != null)\n                    return val;\n                try {\n                    _events.wait(5 * 1000);\n                } catch (InterruptedException e) {}\n            }\n        } while (true);\n    }","commit_id":"55bfd6aa2d90806e484ee5df37500175a1b09291","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"void decrementSize() {\n        size--;\n        if(size < 0)\n            size=0;\n    }","id":86979,"modified_method":"/** Doesn't need to be synchronized; is always called from synchronized methods */\n    void decrementSize() {\n        size--;\n        if(size < 0)\n            size=0;\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the last element. Returns null if no elements are available.\n     */\n    public Object getLast() {\n        return tail != null? tail.obj : null;\n    }","id":86980,"modified_method":"/**\n     * Returns the last element. Returns null if no elements are available.\n     */\n    public Object getLast() {\n        synchronized(mutex) {\n            return tail != null? tail.obj : null;\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Marks the queues as closed. When an <code>add<\/code> or <code>remove<\/code> operation is\n     attempted on a closed queue, an exception is thrown.\n     @param flush_entries When true, a end-of-entries marker is added to the end of the queue.\n     Entries may be added and removed, but when the end-of-entries marker\n     is encountered, the queue is marked as closed. This allows to flush\n     pending messages before closing the queue.\n     */\n    public void close(boolean flush_entries) {\n        if(flush_entries) {\n            try {\n                add(endMarker); // add an end-of-entries marker to the end of the queue\n                num_markers++;\n            }\n            catch(QueueClosedException closed_ex) {\n            }\n            return;\n        }\n\n        synchronized(mutex) {\n            closed=true;\n            mutex.notifyAll();\n        }\n\n//        synchronized(remove_mutex) {\n//            remove_mutex.notifyAll();\n//        }\n    }","id":86981,"modified_method":"/**\n     Marks the queues as closed. When an <code>add<\/code> or <code>remove<\/code> operation is\n     attempted on a closed queue, an exception is thrown.\n     @param flush_entries When true, a end-of-entries marker is added to the end of the queue.\n     Entries may be added and removed, but when the end-of-entries marker\n     is encountered, the queue is marked as closed. This allows to flush\n     pending messages before closing the queue.\n     */\n    public void close(boolean flush_entries) {\n        synchronized(mutex) {\n            if(flush_entries) {\n                try {\n                    add(endMarker); // add an end-of-entries marker to the end of the queue\n                    num_markers++;\n                }\n                catch(QueueClosedException closed_ex) {\n                }\n                return;\n            }\n            closed=true;\n            mutex.notifyAll();\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns true if the Queue has been closed\n     * however, this method will return false if the queue has been closed\n     * using the close(true) method and the last element has yet not been received.\n     * @return true if the queue has been closed\n     */\n    public boolean closed() {\n        return closed;\n    }","id":86982,"modified_method":"/**\n     * returns true if the Queue has been closed\n     * however, this method will return false if the queue has been closed\n     * using the close(true) method and the last element has yet not been received.\n     * @return true if the queue has been closed\n     */\n    public boolean closed() {\n        synchronized(mutex) {\n            return closed;\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes 1 element from the head.\n     * If the queue is empty the operation will wait for timeout ms.\n     * if no object is added during the timeout time, a Timout exception is thrown\n     * @param timeout - the number of milli seconds this operation will wait before it times out\n     * @return the first object in the queue\n     */\n    public Object remove(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval=null;\n\n        /*lock the queue*/\n        synchronized(mutex) {\n\n            /*check to see if the queue is closed*/\n            if(closed)\n                throw new QueueClosedException();\n\n            /*if the queue size is zero, we want to wait until a new object is added*/\n            if(size == 0) {\n                try {\n                    /*release the add_mutex lock and wait no more than timeout ms*/\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            /*we either timed out, or got notified by the add_mutex lock object*/\n\n            /*get the next value*/\n            retval=removeInternal();\n            /*null result means we timed out*/\n            if(retval == null) throw new TimeoutException();\n\n            /*if we reached an end marker we are going to close the queue*/\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            /*at this point we actually did receive a value from the queue, return it*/\n            return retval;\n        }\n    }","id":86983,"modified_method":"/**\n     * Removes 1 element from the head.\n     * If the queue is empty the operation will wait for timeout ms.\n     * if no object is added during the timeout time, a Timout exception is thrown\n     * @param timeout - the number of milli seconds this operation will wait before it times out\n     * @return the first object in the queue\n     */\n    public Object remove(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval;\n\n        synchronized(mutex) {\n            if(closed)\n                throw new QueueClosedException();\n\n            /*if the queue size is zero, we want to wait until a new object is added*/\n            if(size == 0) {\n                try {\n                    /*release the mutex lock and wait no more than timeout ms*/\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            /*we either timed out, or got notified by the mutex lock object*/\n\n            /*get the next value*/\n            retval=removeInternal();\n            /*null result means we timed out*/\n            if(retval == null) throw new TimeoutException();\n\n            /*if we reached an end marker we are going to close the queue*/\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            /*at this point we actually did receive a value from the queue, return it*/\n            return retval;\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added or the operation times out\n     * @param timeout how long in milli seconds will this operation wait for an object to be added to the queue\n     *        before it times out\n     * @return the first object on the queue\n     */\n\n    public Object peek(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval=null;\n\n        synchronized(mutex) {\n            if(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=head != null? head.obj : null;\n\n            if(retval == null) throw new TimeoutException();\n\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            return retval;\n        }\n    }","id":86984,"modified_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added or the operation times out\n     * @param timeout how long in milli seconds will this operation wait for an object to be added to the queue\n     *        before it times out\n     * @return the first object on the queue\n     */\n    public Object peek(long timeout) throws QueueClosedException, TimeoutException {\n        Object retval;\n\n        synchronized(mutex) {\n            if(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait(timeout);\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=head != null? head.obj : null;\n\n            if(retval == null) throw new TimeoutException();\n\n            if(retval == endMarker) {\n                close(false);\n                throw new QueueClosedException();\n            }\n            return retval;\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the first element. Returns null if no elements are available.\n     */\n    public Object getFirst() {\n        return head != null? head.obj : null;\n    }","id":86985,"modified_method":"/**\n     * Returns the first element. Returns null if no elements are available.\n     */\n    public Object getFirst() {\n        synchronized(mutex) {\n            return head != null? head.obj : null;\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added\n     * @return the first object on the queue\n     */\n    public Object peek() throws QueueClosedException {\n        Object retval=null;\n\n        synchronized(mutex) {\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=(head != null)? head.obj : null;\n\n            // @remove:\n            if(retval == null) {\n                // print some diagnostics\n                if(log.isErrorEnabled()) log.error(\"retval is null: head=\" + head + \", tail=\" + tail + \", size()=\" + size() +\n                                            \", num_markers=\" + num_markers + \", closed()=\" + closed());\n            }\n        }\n\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        return retval;\n    }","id":86986,"modified_method":"/**\n     * returns the first object on the queue, without removing it.\n     * If the queue is empty this object blocks until the first queue object has\n     * been added\n     * @return the first object on the queue\n     */\n    public Object peek() throws QueueClosedException {\n        Object retval;\n\n        synchronized(mutex) {\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            retval=(head != null)? head.obj : null;\n\n            // @remove:\n            if(retval == null) {\n                // print some diagnostics\n                if(log.isErrorEnabled()) log.error(\"retval is null: head=\" + head + \", tail=\" + tail + \", size()=\" + size() +\n                                            \", num_markers=\" + num_markers + \", closed=\" + closed);\n            }\n        }\n\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        return retval;\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * adds an object to the tail of this queue\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     */\n    public void add(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n        if(closed)\n            throw new QueueClosedException();\n        if(this.num_markers > 0)\n            throw new QueueClosedException(\"Queue.add(): queue has been closed. You can not add more elements. \" +\n                                           \"Waiting for removal of remaining elements.\");\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n            /*create a new linked list element*/\n            Element el=new Element(obj);\n            /*check the first element*/\n            if(head == null) {\n                /*the object added is the first element*/\n                /*set the head to be this object*/\n                head=el;\n                /*set the tail to be this object*/\n                tail=head;\n                /*set the size to be one, since the queue was empty*/\n                size=1;\n            }\n            else {\n                /*add the object to the end of the linked list*/\n                tail.next=el;\n                /*set the tail to point to the last element*/\n                tail=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","id":86987,"modified_method":"/**\n     * adds an object to the tail of this queue\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     */\n    public void add(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n           if(closed)\n              throw new QueueClosedException();\n           if(this.num_markers > 0)\n              throw new QueueClosedException(\"Queue.add(): queue has been closed. You can not add more elements. \" +\n                                             \"Waiting for removal of remaining elements.\");\n\n            /*create a new linked list element*/\n            Element el=new Element(obj);\n            /*check the first element*/\n            if(head == null) {\n                /*the object added is the first element*/\n                /*set the head to be this object*/\n                head=el;\n                /*set the tail to be this object*/\n                tail=head;\n                /*set the size to be one, since the queue was empty*/\n                size=1;\n            }\n            else {\n                /*add the object to the end of the linked list*/\n                tail.next=el;\n                /*set the tail to point to the last element*/\n                tail=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a new object to the head of the queue\n     * basically (obj.equals(queue.remove(queue.add(obj)))) returns true\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     *\n     */\n    public void addAtHead(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n        if(closed)\n            throw new QueueClosedException();\n        if(this.num_markers > 0)\n            throw new QueueClosedException(\"Queue.addAtHead(): queue has been closed. You can not add more elements. \" +\n                                           \"Waiting for removal of remaining elements.\");\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n            Element el=new Element(obj);\n            /*check the head element in the list*/\n            if(head == null) {\n                /*this is the first object, we could have done add(obj) here*/\n                head=el;\n                tail=head;\n                size=1;\n            }\n            else {\n                /*set the head element to be the child of this one*/\n                el.next=head;\n                /*set the head to point to the recently added object*/\n                head=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","id":86988,"modified_method":"/**\n     * Adds a new object to the head of the queue\n     * basically (obj.equals(queue.remove(queue.add(obj)))) returns true\n     * If the queue has been closed with close(true) no exception will be\n     * thrown if the queue has not been flushed yet.\n     * @param obj - the object to be added to the queue\n     * @exception QueueClosedException exception if closed() returns true\n     *\n     */\n    public void addAtHead(Object obj) throws QueueClosedException {\n        if(obj == null) {\n            if(log.isErrorEnabled()) log.error(\"argument must not be null\");\n            return;\n        }\n\n        /*lock the queue from other threads*/\n        synchronized(mutex) {\n           if(closed)\n              throw new QueueClosedException();\n           if(this.num_markers > 0)\n              throw new QueueClosedException(\"Queue.addAtHead(): queue has been closed. You can not add more elements. \" +\n                                             \"Waiting for removal of remaining elements.\");\n\n            Element el=new Element(obj);\n            /*check the head element in the list*/\n            if(head == null) {\n                /*this is the first object, we could have done add(obj) here*/\n                head=el;\n                tail=head;\n                size=1;\n            }\n            else {\n                /*set the head element to be the child of this one*/\n                el.next=head;\n                /*set the head to point to the recently added object*/\n                head=el;\n                /*increase the size*/\n                size++;\n            }\n            /*wake up all the threads that are waiting for the lock to be released*/\n            mutex.notifyAll();\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * resets the queue.\n     * This operation removes all the objects in the queue and marks the queue open\n     */\n    public void reset() {\n        num_markers=0;\n        if(!closed)\n            close(false);\n\n        synchronized(mutex) {\n            size=0;\n            head=null;\n            tail=null;\n            closed=false;\n            mutex.notifyAll();\n        }\n\n//        synchronized(remove_mutex) {\n//            remove_mutex.notifyAll();\n//        }\n    }","id":86989,"modified_method":"/**\n     * resets the queue.\n     * This operation removes all the objects in the queue and marks the queue open\n     */\n    public void reset() {\n        synchronized(mutex) {\n           num_markers=0;\n           if(!closed)\n              close(false);\n            size=0;\n            head=null;\n            tail=null;\n            closed=false;\n            mutex.notifyAll();\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes 1 element from head or <B>blocks<\/B>\n     * until next element has been added or until queue has been closed\n     * @return the first element to be taken of the queue\n     */\n    public Object remove() throws QueueClosedException {\n        /*initialize the return value*/\n        Object retval=null;\n        /*lock the queue*/\n        synchronized(mutex) {\n            /*wait as long as the queue is empty. return when an element is present or queue is closed*/\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            /*remove the head from the queue, if we make it to this point, retval should not be null !*/\n            retval=removeInternal();\n            if(retval == null)\n                if(log.isErrorEnabled()) log.error(\"element was null, should never be the case\");\n        }\n\n        /*\n         * we ran into an Endmarker, which means that the queue was closed before\n         * through close(true)\n         */\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        /*return the object*/\n        return retval;\n    }","id":86990,"modified_method":"/**\n     * Removes 1 element from head or <B>blocks<\/B>\n     * until next element has been added or until queue has been closed\n     * @return the first element to be taken of the queue\n     */\n    public Object remove() throws QueueClosedException {\n        /*initialize the return value*/\n        Object retval;\n        /*lock the queue*/\n        synchronized(mutex) {\n            /*wait as long as the queue is empty. return when an element is present or queue is closed*/\n            while(size == 0) {\n                if(closed)\n                    throw new QueueClosedException();\n                try {\n                    mutex.wait();\n                }\n                catch(InterruptedException ex) {\n                }\n            }\n\n            if(closed)\n                throw new QueueClosedException();\n\n            /*remove the head from the queue, if we make it to this point, retval should not be null !*/\n            retval=removeInternal();\n            if(retval == null)\n                if(log.isErrorEnabled()) log.error(\"element was null, should never be the case\");\n        }\n\n        /*\n         * we ran into an Endmarker, which means that the queue was closed before\n         * through close(true)\n         */\n        if(retval == endMarker) {\n            close(false); // mark queue as closed\n            throw new QueueClosedException();\n        }\n\n        /*return the object*/\n        return retval;\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * returns the number of objects that are currently in the queue\n     */\n    public int size() {\n        return size - num_markers;\n    }","id":86991,"modified_method":"/**\n     * returns the number of objects that are currently in the queue\n     */\n    public int size() {\n        synchronized(mutex) {\n            return size - num_markers;\n        }\n    }","commit_id":"ceb1838bc64b9a1901b5e2daa002dadcf8225840","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File tmpFile = File.createTempFile(\"mps-generator-caches\", \"tmp\");\n    tmpFile.deleteOnExit();\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), new TestMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    // Stage 2. Modify model\n    Map<String, String> incrementalGenerationResults = null;\n    Assert.assertTrue(changeModel.length > 0);\n    for(final Runnable r : changeModel) {\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n        }\n      });\n\n      // Stage 3. Generate incrementally\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(false).strictMode(true).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n      generationHandler = new IncrementalTestGenerationHandler();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), new TestMessageHandler(), options);\n\n      Map<String,String> prevResults = incrementalGenerationResults == null ? generationHandler.getExistingContent() : incrementalGenerationResults;\n\n      incrementalGenerationResults = generationHandler.getGeneratedContent();\n      assertDiff(prevResults, incrementalGenerationResults, 1);\n    }\n\n    // Stage 4. Regenerate. Check incremental results.\n\n    options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).incremental(false, null).create();\n    generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), new TestMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n    ThreadUtils.runInUIThreadAndWait(new Runnable(){\n      @Override\n      public void run() {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            ((EditableSModelDescriptor)descr).reloadFromDisk();\n          }\n        });\n      }\n    });\n\n  }","id":86992,"modified_method":"protected void doTestIncrementalGeneration(final MPSProject p, final SModelDescriptor descr, final Runnable ...changeModel) throws IOException {\n    GeneratorManager gm = p.getProject().getComponent(GeneratorManager.class);\n\n    File tmpFile = File.createTempFile(\"mps-generator-caches\", \"tmp\");\n    tmpFile.deleteOnExit();\n\n    // Stage 1. Regenerate\n\n    GenerationOptions options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n    IncrementalTestGenerationHandler generationHandler = new IncrementalTestGenerationHandler();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n\n    assertNoDiff(generationHandler.getExistingContent(), generationHandler.getGeneratedContent());\n\n    // Stage 2. Modify model\n    Map<String, String> incrementalGenerationResults = null;\n    List<Long> time = new ArrayList<Long>();\n    Assert.assertTrue(changeModel.length > 0);\n    for(final Runnable r : changeModel) {\n\n      ThreadUtils.runInUIThreadAndWait(new Runnable(){\n        @Override\n        public void run() {\n          ModelAccess.instance().runWriteActionInCommand(r, p.getProject());\n        }\n      });\n\n      // Stage 3. Generate incrementally\n\n      options = GenerationOptions.getDefaults()\n        .rebuildAll(false).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n      generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n      long start = System.nanoTime();\n      gm.generateModels(\n        Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n        generationHandler,\n        new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n      time.add(System.nanoTime() - start);\n\n      incrementalGenerationResults = generationHandler.getGeneratedContent();\n      assertDiff(generationHandler.getExistingContent(), incrementalGenerationResults, 1);\n    }\n\n    // Stage 4. Regenerate. Check incremental results.\n\n    options = GenerationOptions.getDefaults()\n      .rebuildAll(true).strictMode(true).reporting(true, true, false, 2).incremental(true, new FileBasedGenerationCacheContainer(tmpFile)).create();\n    generationHandler = new IncrementalTestGenerationHandler(incrementalGenerationResults);\n    long start = System.nanoTime();\n    gm.generateModels(\n      Collections.singletonList(descr), ModuleContext.create(descr, p.getProject()),\n      generationHandler,\n      new EmptyProgressIndicator(), generationHandler.getMessageHandler(), options);\n    time.add(System.nanoTime() - start);\n\n    assertNoDiff(generationHandler.getGeneratedContent(), incrementalGenerationResults);\n\n    ThreadUtils.runInUIThreadAndWait(new Runnable(){\n      @Override\n      public void run() {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            ((EditableSModelDescriptor)descr).reloadFromDisk();\n          }\n        });\n      }\n    });\n\n    if(DEBUG) {\n      long regen = time.remove(time.size() - 1);\n      System.out.print(\"Full cycle: \" + regen/1000000/1000.);\n      for(long l : time) {\n        System.out.print(\", incremental: \" + l/1000000/1000.);\n      }\n      System.out.println();\n    }\n  }","commit_id":"1d86a4f641b70f4a1420f5f4dfb99106c4940e90","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String propertyKey() { return key; }","id":86993,"modified_method":"public String propertyKey() {\n        if(key == null)\n            key = (String)valueForBinding(\"propertyKey\");\n        return key;\n    }","commit_id":"ce5ba03e6723be1bd9b99bcd177478c3a89a434a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setMaxValue(String max) {\n        _maxValue=max;\n        displayGroup().queryMax().takeValueForKey(dateForString(max), propertyKey());\n    }","id":86994,"modified_method":"public void setMaxValue(String max) {\n        _maxValue=max;\n        NSTimestamp maxDate = dateForString(max);\n        if(maxDate != null)\n            displayGroup().queryMax().takeValueForKey(maxDate, propertyKey());\n    }","commit_id":"ce5ba03e6723be1bd9b99bcd177478c3a89a434a","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setMinValue(String min) {\n        _minValue=min;\n        displayGroup().queryMin().takeValueForKey(dateForString(min), propertyKey());\n    }","id":86995,"modified_method":"public void setMinValue(String min) {\n        _minValue=min;\n        NSTimestamp minDate = dateForString(min);\n        if(minDate != null)\n            displayGroup().queryMin().takeValueForKey(minDate, propertyKey());\n    }","commit_id":"ce5ba03e6723be1bd9b99bcd177478c3a89a434a","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Returns an array of attribute names from the EOEntity of source that should be marshalled to the client.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @return an array of attribute names from the EOEntity of source that should be marshalled\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"cast\" })\n\tpublic static NSArray<String> publicAttributeNames(EOEnterpriseObject source) {\n\t\t// These are cached on EOEntity name as an optimization.\n\n\t\tEOEntity entity = EOUtilities.entityForObject(source.editingContext(), source);\n\t\tNSArray<String> attributeNames = EOEnterpriseObjectSerializer.publicAttributeNames.objectForKey(entity.name());\n\t\t//AK: should use clientProperties from EM\n\t\tif (attributeNames == null) {\n\t\t\tattributeNames = (NSArray<String>)ERXProperties.arrayForKey(\"er.ajax.json.\" + entity.name() + \".attributes\");\n\t\t\tif (attributeNames == null) {\n\t\t\t\t//publicAttributes = source.attributeKeys();\n\t\t\t\t//publicAttributeSet.addObjectsFromArray(publicAttributes);\n\t\t\t\t//NSArray classProperties = entity.classPropertyNames();\n\t\t\t\t//publicAttributeNames = publicAttributeSet.setByIntersectingSet(new NSSet(classProperties)).allObjects();\n\t\t\t\tattributeNames = entity.classPropertyNames();\n\t\t\t}\n\t\t\tEOEnterpriseObjectSerializer.publicAttributeNames.setObjectForKey(attributeNames, entity.name());\n\t\t}\n\n\t\treturn attributeNames;\n\t}","id":86996,"modified_method":"/**\n\t * Returns an array of attribute names from the EOEntity of source that should be marshalled from the client.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject\n\t * @return an array of attribute names from the EOEntity of source that should be unmarshalled\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"cast\" })\n\tpublic static NSArray<String> writableAttributeNames(EOEnterpriseObject source) {\n\t\t// These are cached on EOEntity name as an optimization.\n\n\t\tEOEntity entity = EOUtilities.entityForObject(source.editingContext(), source);\n\t\tNSArray<String> writableNames = EOEnterpriseObjectSerializer.writableAttributeNames.objectForKey(entity.name());\n\t\t//AK: should use clientProperties from EM\n\t\tif (writableNames == null) {\n\t\t\twritableNames = (NSArray<String>)ERXProperties.arrayForKey(\"er.ajax.json.\" + entity.name() + \".writableAttributes\");\n\t\t\tif (writableNames == null) {\n\t\t\t\t//publicAttributes = source.attributeKeys();\n\t\t\t\t//publicAttributeSet.addObjectsFromArray(publicAttributes);\n\t\t\t\t//NSArray classProperties = entity.classPropertyNames();\n\t\t\t\t//publicAttributeNames = publicAttributeSet.setByIntersectingSet(new NSSet(classProperties)).allObjects();\n\t\t\t\twritableNames = entity.clientClassPropertyNames();\n\t\t\t}\n\t\t\tEOEnterpriseObjectSerializer.writableAttributeNames.setObjectForKey(writableNames, entity.name());\n\t\t}\n\n\t\treturn writableNames;\n\t}","commit_id":"2f7e815131de00f68270dc2c00ccef057912a084","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * This copies the attributes from the source EOEnterpriseObject to the destination. Only attributes which are class\n\t * properties are copied. However if an attribute is a class property and also used in a relationship it is assumed\n\t * to be an exposed primary or foreign key and not copied. Such attributes are set to null. See\n\t * exposedKeyAttributeNames for details on how this is determined. It can be used when creating custom\n\t * implementations of the duplicate() method in EOCopyable.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @param destination\n\t *            the EOEnterpriseObject to copy attribute values to\n\t */\n\tpublic void addAttributes(SerializerState state, EOEnterpriseObject source, JSONObject destination) throws MarshallException {\n\t\tboolean useEO = false;\n\t\ttry {\n\t\t\tJSONObject eoData = destination;\n\t\t\tif(useEO) {\n\t\t\t\tdestination = new JSONObject();\n\t\t\t\tdestination.put(\"eo\", eoData);\n\t\t\t\tstate.push(source, eoData, \"eo\");\n\t\t\t}\n\t\t\tEOClassDescription cd = source.classDescription();\n\t\t\tNSArray<String> attributeNames = _publicAttributeNames(source);\n\t\t\tNSArray<String> relationshipNames = _includedRelationshipNames(source);\n\t\t\t\n\t\t\tfor (Enumeration e = attributeNames.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\tString key = (String) e.nextElement();\n\t\t\t\tObject jsonValue;\n\t\t\t\tif(cd.toManyRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tif (relationshipNames.containsObject(key)) {\n\t\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tJSONObject rel = new JSONObject();\n\t\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOArrayFault\");\n\t\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n\t\t\t\t\t\trel.put(\"relationshipName\", key);\n\t\t\t\t\t\tjsonValue = rel;\n\t\t\t\t\t}\n\t\t\t\t} else if (cd.toOneRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tif (relationshipNames.containsObject(key)) {\n\t\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tJSONObject rel = new JSONObject();\n\t\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOFault\");\n\t\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n\t\t\t\t\t\trel.put(\"relationshipName\", key);\n\t\t\t\t\t\tjsonValue = rel;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t}\n\t\t\t\tif (JSONSerializer.CIRC_REF_OR_DUPLICATE == jsonValue) {\n\t\t\t\t\tdestination.put(key, JSONObject.NULL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdestination.put(key, jsonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall EO.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif(useEO) {\n\t\t\t\tstate.pop();\n\t\t\t}\n\t\t}\n\t}","id":86997,"modified_method":"/**\n\t * This copies the attributes from the source EOEnterpriseObject to the destination. Only attributes which are class\n\t * properties are copied. However if an attribute is a class property and also used in a relationship it is assumed\n\t * to be an exposed primary or foreign key and not copied. Such attributes are set to null. See\n\t * exposedKeyAttributeNames for details on how this is determined. It can be used when creating custom\n\t * implementations of the duplicate() method in EOCopyable.\n\t * \n\t * @param source\n\t *            the EOEnterpriseObject to copy attribute values from\n\t * @param destination\n\t *            the EOEnterpriseObject to copy attribute values to\n\t */\n\tpublic void addAttributes(SerializerState state, EOEnterpriseObject source, JSONObject destination) throws MarshallException {\n\t\tboolean useEO = false;\n\t\ttry {\n\t\t\tJSONObject eoData = destination;\n\t\t\tif(useEO) {\n\t\t\t\tdestination = new JSONObject();\n\t\t\t\tdestination.put(\"eo\", eoData);\n\t\t\t\tstate.push(source, eoData, \"eo\");\n\t\t\t}\n\t\t\tEOClassDescription cd = source.classDescription();\n\t\t\tNSArray<String> attributeNames = _readableAttributeNames(source);\n\t\t\tNSArray<String> relationshipNames = _includedRelationshipNames(source);\n\t\t\t\n\t\t\tfor (Enumeration e = attributeNames.objectEnumerator(); e.hasMoreElements();) {\n\t\t\t\tString key = (String) e.nextElement();\n\t\t\t\tObject jsonValue;\n\t\t\t\tif(cd.toManyRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tif (relationshipNames.containsObject(key)) {\n\t\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n//\t\t\t\t\t\tJSONObject rel = new JSONObject();\n//\t\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOArrayFault\");\n//\t\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n//\t\t\t\t\t\trel.put(\"relationshipName\", key);\n//\t\t\t\t\t\tjsonValue = rel;\n\t\t\t\t\t\tjsonValue = null;\n\t\t\t\t\t}\n\t\t\t\t} else if (cd.toOneRelationshipKeys().containsObject(key)) {\n\t\t\t\t\tif (relationshipNames.containsObject(key)) {\n\t\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n//\t\t\t\t\t\tJSONObject rel = new JSONObject();\n//\t\t\t\t\t\trel.put(\"javaClass\", \"com.webobjects.eocontrol.EOFault\");\n//\t\t\t\t\t\trel.put(\"sourceGlobalID\", destination.get(\"gid\"));\n//\t\t\t\t\t\trel.put(\"relationshipName\", key);\n//\t\t\t\t\t\tjsonValue = rel;\n\t\t\t\t\t\tjsonValue = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tObject value = source.valueForKey(key);\n\t\t\t\t\tjsonValue = ser.marshall(state, source, value, key);\n\t\t\t\t}\n\t\t\t\tif (JSONSerializer.CIRC_REF_OR_DUPLICATE == jsonValue) {\n\t\t\t\t\tdestination.put(key, JSONObject.NULL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdestination.put(key, jsonValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall EO.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif(useEO) {\n\t\t\t\tstate.pop();\n\t\t\t}\n\t\t}\n\t}","commit_id":"2f7e815131de00f68270dc2c00ccef057912a084","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object marshall(SerializerState state, Object p, Object o) throws MarshallException {\n\t\ttry {\n\t\t\tEOEnterpriseObject eo = (EOEnterpriseObject) o;\n\t\t\tJSONObject obj = new JSONObject();\n\t\t\tobj.put(\"javaClass\", o.getClass().getName());\n\n\t\t\tEOEditingContext ec = eo.editingContext();\n\t\t\tString ecid = registerEditingContext(ec);\n\t\t\tString pk = ERXStringUtilities.urlEncode(ERXEOControlUtilities.primaryKeyStringForObject(eo));\n\t\t\tobj.put(\"gid\", ecid + \"/\" + eo.entityName() +  \"/\" + pk);\n\n\t\t\taddAttributes(state, eo, obj);\n\t\t\treturn obj;\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall EO.\", e);\n\t\t}\n\t}","id":86998,"modified_method":"public Object marshall(SerializerState state, Object p, Object o) throws MarshallException {\n\t\ttry {\n\t\t\tEOEnterpriseObject eo = (EOEnterpriseObject) o;\n\t\t\tJSONObject obj = new JSONObject();\n\t\t\tobj.put(\"javaClass\", o.getClass().getName());\n\n\t\t\tEOEditingContext ec = eo.editingContext();\n\t\t\tString ecid = registerEditingContext(ec);\n\t\t\tString pkStr = ERXEOControlUtilities.primaryKeyStringForObject(eo);\n\t\t\tif (pkStr == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Uncommitted EO's are not currently supported for marshalling.\");\n\t\t\t}\n\t\t\tString encodedPKStr = ERXStringUtilities.urlEncode(pkStr);\n\t\t\tobj.put(\"gid\", ecid + \"/\" + eo.entityName() +  \"/\" + encodedPKStr);\n\n\t\t\taddAttributes(state, eo, obj);\n\t\t\treturn obj;\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new MarshallException(\"Failed to marshall EO.\", e);\n\t\t}\n\t}","commit_id":"2f7e815131de00f68270dc2c00ccef057912a084","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Object unmarshall(SerializerState state, Class clazz, Object o) throws UnmarshallException {\n\t\ttry {\n\t\t\tJSONObject jso = (JSONObject) o;\n\t\t\tJSONObject eoDict = jso;\n\t\t\tif(jso.has(\"eo\")) {\n\t\t\t\tjso.getJSONObject(\"eo\");\n\t\t\t}\n\t\t\tif (eoDict == null) {\n\t\t\t\tthrow new UnmarshallException(\"eo missing\");\n\t\t\t}\n\t\t\tString gidString = jso.getString(\"gid\");\n\t\t\tif (gidString == null) {\n\t\t\t\tthrow new UnmarshallException(\"gid missing\");\n\t\t\t}\n\t\t\tString parts[] = gidString.split(\"/\");\n\t\t\tString ecid = parts[0];\n\t\t\tString entityName = parts[1];\n\t\t\tEOGlobalID keyGlobalID;\n\t\n\t\t\tEOEditingContext ec = null;\n\t\t\tif(ecid != null) {\n\t\t\t\tec = editingContextForKey(ecid);\n\t\t\t}\n\t\t\tif(ec == null) {\n\t\t\t\tec = _editingContextFactory.newEditingContext();\n\t\t\t\tregisterEditingContext(ec);\n\t\t\t}\n\t\t\tec.lock();\n\t\t\ttry {\n\t\t\t\tString pk = parts.length > 2 ? parts[2] : null;\n\t\t\t\tEOEnterpriseObject eo;\n\t\t\t\tif(pk != null && pk.length() > 0) {\n\t\t\t\t\tpk = ERXStringUtilities.urlDecode(pk);\n\t\t\t\t\tkeyGlobalID = ERXEOControlUtilities.globalIDForString(ec, entityName, pk);\n\t\t\t\t\teo = ec.faultForGlobalID(keyGlobalID, ec);\n\t\t\t\t} else {\n\t\t\t\t\teo = ERXEOControlUtilities.createAndInsertObject(ec, entityName);\n\t\t\t\t}\n\t\t\t\tfor (Iterator iterator = eoDict.keys(); iterator.hasNext();) {\n\t\t\t\t\tString key = (String) iterator.next();\n\t\t\t\t\tif(!(\"javaClass\".equals(key) || \"gid\".equals(key))) {\n\t\t\t\t\t\tObject value = eoDict.get(key);\n\t\t\t\t\t\teo.takeValueForKey(value, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstate.setSerialized(o, eo);\n\t\t\t\treturn eo;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tec.unlock();\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Failed to unmarshall EO.\", e);\n\t\t}\n\t}","id":86999,"modified_method":"public Object unmarshall(SerializerState state, Class clazz, Object o) throws UnmarshallException {\n\t\ttry {\n\t\t\tJSONObject jso = (JSONObject) o;\n\t\t\tJSONObject eoDict = jso;\n\t\t\tif(jso.has(\"eo\")) {\n\t\t\t\tjso.getJSONObject(\"eo\");\n\t\t\t}\n\t\t\tif (eoDict == null) {\n\t\t\t\tthrow new UnmarshallException(\"eo missing\");\n\t\t\t}\n\t\t\tString gidString = jso.getString(\"gid\");\n\t\t\tif (gidString == null) {\n\t\t\t\tthrow new UnmarshallException(\"gid missing\");\n\t\t\t}\n\t\t\tString parts[] = gidString.split(\"/\");\n\t\t\tString ecid = parts[0];\n\t\t\tString entityName = parts[1];\n\t\t\tEOGlobalID keyGlobalID;\n\t\n\t\t\tEOEditingContext ec = null;\n\t\t\tif(ecid != null) {\n\t\t\t\tec = editingContextForKey(ecid);\n\t\t\t}\n\t\t\tif(ec == null) {\n\t\t\t\tec = _editingContextFactory.newEditingContext();\n\t\t\t\tregisterEditingContext(ec);\n\t\t\t}\n\t\t\tec.lock();\n\t\t\ttry {\n\t\t\t\tString pk = parts.length > 2 ? parts[2] : null;\n\t\t\t\tEOEnterpriseObject eo;\n\t\t\t\tif(pk != null && pk.length() > 0) {\n\t\t\t\t\tpk = ERXStringUtilities.urlDecode(pk);\n\t\t\t\t\tkeyGlobalID = ERXEOControlUtilities.globalIDForString(ec, entityName, pk);\n\t\t\t\t\teo = ec.faultForGlobalID(keyGlobalID, ec);\n\t\t\t\t} else {\n\t\t\t\t\teo = ERXEOControlUtilities.createAndInsertObject(ec, entityName);\n\t\t\t\t}\n\t\t\t\tNSArray<String> attributeNames = _writableAttributeNames(eo);\n\t\t\t\tNSArray<String> relationshipNames = _includedRelationshipNames(eo);\n\t\t\t\tfor (Iterator iterator = eoDict.keys(); iterator.hasNext();) {\n\t\t\t\t\tString key = (String) iterator.next();\n\t\t\t\t\tif(!(\"javaClass\".equals(key) || \"gid\".equals(key))) {\n\t\t\t\t\t\tif (attributeNames.containsObject(key)) {\n\t\t\t\t\t\t\tObject value = eoDict.get(key);\n\t\t\t\t\t\t\tObject obj = ser.unmarshall(state, null, value);\n\t\t\t\t\t\t\tif (obj == null && !relationshipNames.containsObject(key) && (eo.toOneRelationshipKeys().containsObject(key) || eo.toManyRelationshipKeys().containsObject(key))) { \n\t\t\t\t\t\t\t\t// ignore nulls for non-included relationships \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\teo.takeValueForKey(obj, key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstate.setSerialized(o, eo);\n\t\t\t\treturn eo;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tec.unlock();\n\t\t\t}\n\t\t}\n\t\tcatch (JSONException e) {\n\t\t\tthrow new UnmarshallException(\"Failed to unmarshall EO.\", e);\n\t\t}\n\t}","commit_id":"2f7e815131de00f68270dc2c00ccef057912a084","url":"https://github.com/wocommunity/wonder"}]